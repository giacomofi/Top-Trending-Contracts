['pragma solidity 0.4.17;\n', '\n', 'library IdeaUint {\n', '\n', '    function add(uint a, uint b) constant internal returns (uint result) {\n', '        uint c = a + b;\n', '\n', '        assert(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint a, uint b) constant internal returns (uint result) {\n', '        uint c = a - b;\n', '\n', '        assert(b <= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint a, uint b) constant internal returns (uint result) {\n', '        uint c = a * b;\n', '\n', '        assert(a == 0 || c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint a, uint b) constant internal returns (uint result) {\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract IdeaBasicCoin {\n', '    using IdeaUint for uint;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint public totalSupply;\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    address[] public accounts;\n', '    mapping(address => bool) internal accountsMap;\n', '    address public owner;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function balanceOf(address _owner) constant public returns (uint balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        tryCreateAccount(_to);\n', '\n', '        Transfer(msg.sender, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        uint _allowance = allowed[_from][msg.sender];\n', '\n', '        balances[_from] = balances[_from].sub(_value);\n', '        balances[_to] = balances[_to].add(_value);\n', '        allowed[_from][msg.sender] = _allowance.sub(_value);\n', '        tryCreateAccount(_to);\n', '\n', '        Transfer(_from, _to, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _value;\n', '\n', '        Approval(msg.sender, _spender, _value);\n', '\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant public returns (uint remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {\n', '        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n', '\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\n', '        return true;\n', '    }\n', '\n', '    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {\n', '        uint oldValue = allowed[msg.sender][_spender];\n', '\n', '        if (_subtractedValue > oldValue) {\n', '            allowed[msg.sender][_spender] = 0;\n', '        } else {\n', '            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n', '        }\n', '\n', '        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n', '\n', '        return true;\n', '    }\n', '\n', '    function tryCreateAccount(address _account) internal {\n', '        if (!accountsMap[_account]) {\n', '            accounts.push(_account);\n', '            accountsMap[_account] = true;\n', '        }\n', '    }\n', '}\n', '\n', 'contract IdeaCoin is IdeaBasicCoin {\n', '\n', '    uint public earnedEthWei;\n', '    uint public soldIdeaWei;\n', '    uint public soldIdeaWeiPreIco;\n', '    uint public soldIdeaWeiIco;\n', '    uint public soldIdeaWeiPostIco;\n', '    uint public icoStartTimestamp;\n', '    mapping(address => uint) public pieBalances;\n', '    address[] public pieAccounts;\n', '    mapping(address => bool) internal pieAccountsMap;\n', '    uint public nextRoundReserve;\n', '    address[] public projects;\n', '    address public projectAgent;\n', '    address public bank1;\n', '    address public bank2;\n', '    uint public bank1Val;\n', '    uint public bank2Val;\n', '    uint public bankValReserve;\n', '\n', '    enum IcoStates {\n', '    Coming,\n', '    PreIco,\n', '    Ico,\n', '    PostIco,\n', '    Done\n', '    }\n', '\n', '    IcoStates public icoState;\n', '\n', '    function IdeaCoin() {\n', "        name = 'IdeaCoin';\n", "        symbol = 'IDEA';\n", '        decimals = 18;\n', '        totalSupply = 100000000 ether;\n', '\n', '        owner = msg.sender;\n', '        tryCreateAccount(msg.sender);\n', '    }\n', '\n', '    function() payable {\n', '        uint tokens;\n', '        bool moreThenPreIcoMin = msg.value >= 20 ether;\n', '        uint totalVal = msg.value + bankValReserve;\n', '        uint halfVal = totalVal / 2;\n', '\n', '        if (icoState == IcoStates.PreIco && moreThenPreIcoMin && soldIdeaWeiPreIco <= 2500000 ether) {\n', '\n', '            tokens = msg.value * 1500;\n', '            balances[msg.sender] += tokens;\n', '            soldIdeaWeiPreIco += tokens;\n', '\n', '        } else if (icoState == IcoStates.Ico && soldIdeaWeiIco <= 35000000 ether) {\n', '            uint elapsed = now - icoStartTimestamp;\n', '\n', '            if (elapsed <= 1 days) {\n', '\n', '                tokens = msg.value * 1250;\n', '                balances[msg.sender] += tokens;\n', '\n', '            } else if (elapsed <= 6 days && elapsed > 1 days) {\n', '\n', '                tokens = msg.value * 1150;\n', '                balances[msg.sender] += tokens;\n', '\n', '            } else if (elapsed <= 11 days && elapsed > 6 days) {\n', '\n', '                tokens = msg.value * 1100;\n', '                balances[msg.sender] += tokens;\n', '\n', '            } else if (elapsed <= 16 days && elapsed > 11 days) {\n', '\n', '                tokens = msg.value * 1050;\n', '                balances[msg.sender] += tokens;\n', '\n', '            } else {\n', '\n', '                tokens = msg.value * 1000;\n', '                balances[msg.sender] += tokens;\n', '\n', '            }\n', '\n', '            soldIdeaWeiIco += tokens;\n', '\n', '        } else if (icoState == IcoStates.PostIco && soldIdeaWeiPostIco <= 12000000 ether) {\n', '\n', '            tokens = msg.value * 500;\n', '            balances[msg.sender] += tokens;\n', '            soldIdeaWeiPostIco += tokens;\n', '\n', '        } else {\n', '            revert();\n', '        }\n', '\n', '        earnedEthWei += msg.value;\n', '        soldIdeaWei += tokens;\n', '\n', '        bank1Val += halfVal;\n', '        bank2Val += halfVal;\n', '        bankValReserve = totalVal - (halfVal * 2);\n', '\n', '        tryCreateAccount(msg.sender);\n', '    }\n', '\n', '    function setBank(address _bank1, address _bank2) public onlyOwner {\n', '        require(bank1 == address(0x0));\n', '        require(bank2 == address(0x0));\n', '        require(_bank1 != address(0x0));\n', '        require(_bank2 != address(0x0));\n', '\n', '        bank1 = _bank1;\n', '        bank2 = _bank2;\n', '\n', '        balances[bank1] = 500000 ether;\n', '        balances[bank2] = 500000 ether;\n', '    }\n', '\n', '    function startPreIco() public onlyOwner {\n', '        icoState = IcoStates.PreIco;\n', '    }\n', '\n', '    function stopPreIcoAndBurn() public onlyOwner {\n', '        stopAnyIcoAndBurn(\n', '        (2500000 ether - soldIdeaWeiPreIco) * 2\n', '        );\n', '        balances[bank1] += soldIdeaWeiPreIco / 2;\n', '        balances[bank2] += soldIdeaWeiPreIco / 2;\n', '    }\n', '\n', '    function startIco() public onlyOwner {\n', '        icoState = IcoStates.Ico;\n', '        icoStartTimestamp = now;\n', '    }\n', '\n', '    function stopIcoAndBurn() public onlyOwner {\n', '        stopAnyIcoAndBurn(\n', '        (35000000 ether - soldIdeaWeiIco) * 2\n', '        );\n', '        balances[bank1] += soldIdeaWeiIco / 2;\n', '        balances[bank2] += soldIdeaWeiIco / 2;\n', '    }\n', '\n', '    function startPostIco() public onlyOwner {\n', '        icoState = IcoStates.PostIco;\n', '    }\n', '\n', '    function stopPostIcoAndBurn() public onlyOwner {\n', '        stopAnyIcoAndBurn(\n', '        (12000000 ether - soldIdeaWeiPostIco) * 2\n', '        );\n', '        balances[bank1] += soldIdeaWeiPostIco / 2;\n', '        balances[bank2] += soldIdeaWeiPostIco / 2;\n', '    }\n', '\n', '    function stopAnyIcoAndBurn(uint _burn) internal {\n', '        icoState = IcoStates.Coming;\n', '        totalSupply = totalSupply.sub(_burn);\n', '    }\n', '\n', '    function withdrawEther() public {\n', '        require(msg.sender == bank1 || msg.sender == bank2);\n', '\n', '        if (msg.sender == bank1) {\n', '            bank1.transfer(bank1Val);\n', '            bank1Val = 0;\n', '        }\n', '\n', '        if (msg.sender == bank2) {\n', '            bank2.transfer(bank2Val);\n', '            bank2Val = 0;\n', '        }\n', '\n', '        if (bank1Val == 0 && bank2Val == 0 && this.balance != 0) {\n', '            owner.transfer(this.balance);\n', '        }\n', '    }\n', '\n', '    function pieBalanceOf(address _owner) constant public returns (uint balance) {\n', '        return pieBalances[_owner];\n', '    }\n', '\n', '    function transferToPie(uint _amount) public returns (bool success) {\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        pieBalances[msg.sender] = pieBalances[msg.sender].add(_amount);\n', '        tryCreatePieAccount(msg.sender);\n', '\n', '        return true;\n', '    }\n', '\n', '    function transferFromPie(uint _amount) public returns (bool success) {\n', '        pieBalances[msg.sender] = pieBalances[msg.sender].sub(_amount);\n', '        balances[msg.sender] = balances[msg.sender].add(_amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    function receiveDividends(uint _amount) internal {\n', '        uint minBalance = 10000 ether;\n', '        uint pieSize = calcPieSize(minBalance);\n', '        uint amount = nextRoundReserve + _amount;\n', '\n', '        accrueDividends(minBalance, pieSize, amount);\n', '    }\n', '\n', '    function calcPieSize(uint _minBalance) constant internal returns (uint _pieSize) {\n', '        for (uint i = 0; i < pieAccounts.length; i += 1) {\n', '            var balance = pieBalances[pieAccounts[i]];\n', '\n', '            if (balance >= _minBalance) {\n', '                _pieSize = _pieSize.add(balance);\n', '            }\n', '        }\n', '    }\n', '\n', '    function accrueDividends(uint _minBalance, uint _pieSize, uint _amount) internal {\n', '        uint accrued;\n', '\n', '        for (uint i = 0; i < pieAccounts.length; i += 1) {\n', '            address account = pieAccounts[i];\n', '            uint balance = pieBalances[account];\n', '\n', '            if (balance >= _minBalance) {\n', '                uint dividends = (balance * _amount) / _pieSize;\n', '\n', '                accrued = accrued.add(dividends);\n', '                pieBalances[account] = balance.add(dividends);\n', '            }\n', '        }\n', '\n', '        nextRoundReserve = _amount.sub(accrued);\n', '    }\n', '\n', '    function tryCreatePieAccount(address _account) internal {\n', '        if (!pieAccountsMap[_account]) {\n', '            pieAccounts.push(_account);\n', '            pieAccountsMap[_account] = true;\n', '        }\n', '    }\n', '\n', '    function setProjectAgent(address _project) public onlyOwner {\n', '        projectAgent = _project;\n', '    }\n', '\n', '    function makeProject(string _name, uint _required, uint _requiredDays) public returns (address _address) {\n', '        _address = ProjectAgent(projectAgent).makeProject(msg.sender, _name, _required, _requiredDays);\n', '\n', '        projects.push(_address);\n', '    }\n', '\n', '    function withdrawFromProject(address _project, uint _stage) public returns (bool _success) {\n', '        uint _value;\n', '        (_success, _value) = ProjectAgent(projectAgent).withdrawFromProject(msg.sender, _project, _stage);\n', '\n', '        if (_success) {\n', '            receiveTrancheAndDividends(_value);\n', '        }\n', '    }\n', '\n', '    function cashBackFromProject(address _project) public returns (bool _success) {\n', '        uint _value;\n', '        (_success, _value) = ProjectAgent(projectAgent).cashBackFromProject(msg.sender, _project);\n', '\n', '        if (_success) {\n', '            balances[msg.sender] = balances[msg.sender].add(_value);\n', '        }\n', '    }\n', '\n', '    function receiveTrancheAndDividends(uint _sum) internal {\n', '        uint raw = _sum * 965;\n', '        uint reserve = raw % 1000;\n', '        uint tranche = (raw - reserve) / 1000;\n', '\n', '        balances[msg.sender] = balances[msg.sender].add(tranche);\n', '        receiveDividends(_sum - tranche);\n', '    }\n', '\n', '    function buyProduct(address _product, uint _amount) public {\n', '        ProjectAgent _agent = ProjectAgent(projectAgent);\n', '\n', '        uint _price = IdeaSubCoin(_product).price();\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(_price * _amount);\n', '        _agent.buyProduct(_product, msg.sender, _amount);\n', '    }\n', '}\n', '\n', 'contract IdeaProject {\n', '    using IdeaUint for uint;\n', '\n', '    string public name;\n', '    address public engine;\n', '    address public owner;\n', '    uint public required;\n', '    uint public requiredDays;\n', '    uint public fundingEndTime;\n', '    uint public earned;\n', '    mapping(address => bool) public isCashBack;\n', '    uint public currentWorkStagePercent;\n', '    uint internal lastWorkStageStartTimestamp;\n', '    int8 public failStage = -1;\n', '    uint public failInvestPercents;\n', '    address[] public products;\n', '    uint public cashBackVotes;\n', '    mapping(address => uint) public cashBackWeight;\n', '\n', '    enum States {\n', '    Initial,\n', '    Coming,\n', '    Funding,\n', '    Workflow,\n', '    SuccessDone,\n', '    FundingFail,\n', '    WorkFail\n', '    }\n', '\n', '    States public state = States.Initial;\n', '\n', '    struct WorkStage {\n', '    uint percent;\n', '    uint stageDays;\n', '    uint sum;\n', '    uint withdrawTime;\n', '    }\n', '\n', '    WorkStage[] public workStages;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyEngine() {\n', '        require(msg.sender == engine);\n', '        _;\n', '    }\n', '\n', '    modifier onlyState(States _state) {\n', '        require(state == _state);\n', '        _;\n', '    }\n', '\n', '    modifier onlyProduct() {\n', '        bool permissionGranted;\n', '\n', '        for (uint8 i; i < products.length; i += 1) {\n', '            if (msg.sender == products[i]) {\n', '                permissionGranted = true;\n', '            }\n', '        }\n', '\n', '        if (permissionGranted) {\n', '            _;\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function IdeaProject(\n', '    address _owner,\n', '    string _name,\n', '    uint _required,\n', '    uint _requiredDays\n', '    ) {\n', '        require(bytes(_name).length > 0);\n', '        require(_required != 0);\n', '\n', '        require(_requiredDays >= 10);\n', '        require(_requiredDays <= 100);\n', '\n', '        engine = msg.sender;\n', '        owner = _owner;\n', '        name = _name;\n', '        required = _required;\n', '        requiredDays = _requiredDays;\n', '    }\n', '\n', '    function addEarned(uint _earned) public onlyEngine {\n', '        earned = earned.add(_earned);\n', '    }\n', '\n', '    function isFundingState() constant public returns (bool _result) {\n', '        return state == States.Funding;\n', '    }\n', '\n', '    function isWorkflowState() constant public returns (bool _result) {\n', '        return state == States.Workflow;\n', '    }\n', '\n', '    function isSuccessDoneState() constant public returns (bool _result) {\n', '        return state == States.SuccessDone;\n', '    }\n', '\n', '    function isFundingFailState() constant public returns (bool _result) {\n', '        return state == States.FundingFail;\n', '    }\n', '\n', '    function isWorkFailState() constant public returns (bool _result) {\n', '        return state == States.WorkFail;\n', '    }\n', '\n', '    function markAsComingAndFreeze() public onlyState(States.Initial) onlyOwner {\n', '        require(products.length > 0);\n', '        require(currentWorkStagePercent == 100);\n', '\n', '        state = States.Coming;\n', '    }\n', '\n', '    function startFunding() public onlyState(States.Coming) onlyOwner {\n', '        state = States.Funding;\n', '\n', '        fundingEndTime = uint64(now + requiredDays * 1 days);\n', '        calcLastWorkStageStart();\n', '        calcWithdrawTime();\n', '    }\n', '\n', '    function projectWorkStarted() public onlyState(States.Funding) onlyEngine {\n', '        startWorkflow();\n', '    }\n', '\n', '    function startWorkflow() internal {\n', '        uint used;\n', '        uint current;\n', '        uint len = workStages.length;\n', '\n', '        state = States.Workflow;\n', '\n', '        for (uint8 i; i < len; i += 1) {\n', '            current = earned.mul(workStages[i].percent).div(100);\n', '            workStages[i].sum = current;\n', '            used = used.add(current);\n', '        }\n', '\n', '        workStages[len - 1].sum = workStages[len - 1].sum.add(earned.sub(used));\n', '    }\n', '\n', '    function projectDone() public onlyState(States.Workflow) onlyOwner {\n', '        require(now > lastWorkStageStartTimestamp);\n', '\n', '        state = States.SuccessDone;\n', '    }\n', '\n', '    function projectFundingFail() public onlyState(States.Funding) onlyEngine {\n', '        state = States.FundingFail;\n', '    }\n', '\n', '    function projectWorkFail() internal {\n', '        state = States.WorkFail;\n', '\n', '        for (uint8 i = 1; i < workStages.length; i += 1) {\n', '            failInvestPercents += workStages[i - 1].percent;\n', '\n', '            if (workStages[i].withdrawTime > now) {\n', '                failStage = int8(i - 1);\n', '\n', '                i = uint8(workStages.length);\n', '            }\n', '        }\n', '\n', '        if (failStage == -1) {\n', '            failStage = int8(workStages.length - 1);\n', '            failInvestPercents = 100;\n', '        }\n', '    }\n', '\n', '    function makeWorkStage(\n', '    uint _percent,\n', '    uint _stageDays\n', '    ) public onlyState(States.Initial) {\n', '        require(workStages.length <= 10);\n', '        require(_stageDays >= 10);\n', '        require(_stageDays <= 100);\n', '\n', '        if (currentWorkStagePercent.add(_percent) > 100) {\n', '            revert();\n', '        } else {\n', '            currentWorkStagePercent = currentWorkStagePercent.add(_percent);\n', '        }\n', '\n', '        workStages.push(WorkStage(\n', '        _percent,\n', '        _stageDays,\n', '        0,\n', '        0\n', '        ));\n', '    }\n', '\n', '    function calcLastWorkStageStart() internal {\n', '        lastWorkStageStartTimestamp = fundingEndTime;\n', '\n', '        for (uint8 i; i < workStages.length - 1; i += 1) {\n', '            lastWorkStageStartTimestamp += workStages[i].stageDays * 1 days;\n', '        }\n', '    }\n', '\n', '    function calcWithdrawTime() internal {\n', '        for (uint8 i; i < workStages.length; i += 1) {\n', '            if (i == 0) {\n', '                workStages[i].withdrawTime = now + requiredDays * 1 days;\n', '            } else {\n', '                workStages[i].withdrawTime = workStages[i - 1].withdrawTime + workStages[i - 1].stageDays * 1 days;\n', '            }\n', '        }\n', '    }\n', '\n', '    function withdraw(uint _stage) public onlyEngine returns (uint _sum) {\n', '        WorkStage memory stageStruct = workStages[_stage];\n', '\n', '        if (stageStruct.withdrawTime <= now) {\n', '            _sum = stageStruct.sum;\n', '\n', '            workStages[_stage].sum = 0;\n', '        }\n', '    }\n', '\n', '    function voteForCashBack() public {\n', '        voteForCashBackInPercentOfWeight(100);\n', '    }\n', '\n', '    function cancelVoteForCashBack() public {\n', '        voteForCashBackInPercentOfWeight(0);\n', '    }\n', '\n', '    function voteForCashBackInPercentOfWeight(uint _percent) public {\n', '        voteForCashBackInPercentOfWeightForAccount(msg.sender, _percent);\n', '    }\n', '\n', '    function voteForCashBackInPercentOfWeightForAccount(address _account, uint _percent) internal {\n', '        require(_percent <= 100);\n', '\n', '        updateFundingStateIfNeed();\n', '\n', '        if (state == States.Workflow) {\n', '            uint currentWeight = cashBackWeight[_account];\n', '            uint supply;\n', '            uint part;\n', '\n', '            for (uint8 i; i < products.length; i += 1) {\n', '                supply += IdeaSubCoin(products[i]).totalSupply();\n', '                part += IdeaSubCoin(products[i]).balanceOf(_account);\n', '            }\n', '\n', '            cashBackVotes += ((part * (10 ** 10)) / supply) * (_percent - currentWeight);\n', '            cashBackWeight[_account] = _percent;\n', '\n', '            if (cashBackVotes > 50 * (10 ** 10)) {\n', '                projectWorkFail();\n', '            }\n', '        }\n', '    }\n', '\n', '    function updateVotesOnTransfer(address _from, address _to) public onlyProduct {\n', '        if (isWorkflowState()) {\n', '            voteForCashBackInPercentOfWeightForAccount(_from, 0);\n', '            voteForCashBackInPercentOfWeightForAccount(_to, 0);\n', '        }\n', '    }\n', '\n', '    function makeProduct(\n', '    string _name,\n', '    string _symbol,\n', '    uint _price,\n', '    uint _limit\n', '    ) public onlyState(States.Initial) onlyOwner returns (address _productAddress) {\n', '        require(products.length <= 25);\n', '\n', '        IdeaSubCoin product = new IdeaSubCoin(msg.sender, _name, _symbol, _price, _limit, engine);\n', '\n', '        products.push(address(product));\n', '\n', '        return address(product);\n', '    }\n', '\n', '    function calcInvesting(address _account) public onlyEngine returns (uint _sum) {\n', '        require(!isCashBack[_account]);\n', '\n', '        for (uint8 i = 0; i < products.length; i += 1) {\n', '            IdeaSubCoin product = IdeaSubCoin(products[i]);\n', '\n', '            _sum = _sum.add(product.balanceOf(_account) * product.price());\n', '        }\n', '\n', '        if (isWorkFailState()) {\n', '            _sum = _sum.mul(100 - failInvestPercents).div(100);\n', '        }\n', '\n', '        isCashBack[_account] = true;\n', '    }\n', '\n', '    function updateFundingStateIfNeed() internal {\n', '        if (isFundingState() && now > fundingEndTime) {\n', '            if (earned >= required) {\n', '                startWorkflow();\n', '            } else {\n', '                state = States.FundingFail;\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract ProjectAgent {\n', '\n', '    address public owner;\n', '    address public coin;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyCoin() {\n', '        require(msg.sender == coin);\n', '        _;\n', '    }\n', '\n', '    function ProjectAgent() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function makeProject(\n', '    address _owner,\n', '    string _name,\n', '    uint _required,\n', '    uint _requiredDays\n', '    ) public returns (address _address) {\n', '        return address(\n', '        new IdeaProject(\n', '        _owner,\n', '        _name,\n', '        _required,\n', '        _requiredDays\n', '        )\n', '        );\n', '    }\n', '\n', '    function setCoin(address _coin) public onlyOwner {\n', '        coin = _coin;\n', '    }\n', '\n', '    function withdrawFromProject(\n', '    address _owner,\n', '    address _project,\n', '    uint _stage\n', '    ) public onlyCoin returns (bool _success, uint _value) {\n', '        require(_owner == IdeaProject(_project).owner());\n', '\n', '        IdeaProject project = IdeaProject(_project);\n', '        updateFundingStateIfNeed(_project);\n', '\n', '        if (project.isWorkflowState() || project.isSuccessDoneState()) {\n', '            _value = project.withdraw(_stage);\n', '\n', '            if (_value > 0) {\n', '                _success = true;\n', '            } else {\n', '                _success = false;\n', '            }\n', '        } else {\n', '            _success = false;\n', '        }\n', '    }\n', '\n', '    function cashBackFromProject(\n', '    address _owner,\n', '    address _project\n', '    ) public onlyCoin returns (bool _success, uint _value) {\n', '        IdeaProject project = IdeaProject(_project);\n', '\n', '        updateFundingStateIfNeed(_project);\n', '\n', '        if (\n', '        project.isFundingFailState() ||\n', '        project.isWorkFailState()\n', '        ) {\n', '            _value = project.calcInvesting(_owner);\n', '            _success = true;\n', '        } else {\n', '            _success = false;\n', '        }\n', '    }\n', '\n', '    function updateFundingStateIfNeed(address _project) internal {\n', '        IdeaProject project = IdeaProject(_project);\n', '\n', '        if (\n', '        project.isFundingState() &&\n', '        now > project.fundingEndTime()\n', '        ) {\n', '            if (project.earned() >= project.required()) {\n', '                project.projectWorkStarted();\n', '            } else {\n', '                project.projectFundingFail();\n', '            }\n', '        }\n', '    }\n', '\n', '    function buyProduct(address _product, address _account, uint _amount) public onlyCoin {\n', '        IdeaSubCoin _productContract = IdeaSubCoin(_product);\n', '        address _project = _productContract.project();\n', '        IdeaProject _projectContract = IdeaProject(_project);\n', '\n', '        updateFundingStateIfNeed(_project);\n', '        require(_projectContract.isFundingState());\n', '\n', '        _productContract.buy(_account, _amount);\n', '        _projectContract.addEarned(_amount * _productContract.price());\n', '    }\n', '}\n', '\n', 'contract IdeaSubCoin is IdeaBasicCoin {\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public constant decimals = 0;\n', '    uint public limit;\n', '    uint public price;\n', '    address public project;\n', '    address public engine;\n', '    mapping(address => string) public shipping;\n', '\n', '    modifier onlyProject() {\n', '        require(msg.sender == project);\n', '        _;\n', '    }\n', '\n', '    modifier onlyEngine() {\n', '        require(msg.sender == engine);\n', '        _;\n', '    }\n', '\n', '    function IdeaSubCoin(\n', '    address _owner,\n', '    string _name,\n', '    string _symbol,\n', '    uint _price,\n', '    uint _limit,\n', '    address _engine\n', '    ) {\n', '        require(_price != 0);\n', '\n', '        owner = _owner;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        price = _price;\n', '        limit = _limit;\n', '        project = msg.sender;\n', '        engine = _engine;\n', '    }\n', '\n', '    function transfer(address _to, uint _value) public returns (bool success) {\n', '        require(!IdeaProject(project).isCashBack(msg.sender));\n', '        require(!IdeaProject(project).isCashBack(_to));\n', '\n', '        IdeaProject(project).updateVotesOnTransfer(msg.sender, _to);\n', '\n', '        bool result = super.transfer(_to, _value);\n', '\n', '        if (!result) {\n', '            revert();\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n', '        require(!IdeaProject(project).isCashBack(_from));\n', '        require(!IdeaProject(project).isCashBack(_to));\n', '\n', '        IdeaProject(project).updateVotesOnTransfer(_from, _to);\n', '\n', '        bool result = super.transferFrom(_from, _to, _value);\n', '\n', '        if (!result) {\n', '            revert();\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function buy(address _account, uint _amount) public onlyEngine {\n', '        uint total = totalSupply.add(_amount);\n', '\n', '        if (limit != 0) {\n', '            require(total <= limit);\n', '        }\n', '\n', '        totalSupply = totalSupply.add(_amount);\n', '        balances[_account] = balances[_account].add(_amount);\n', '        tryCreateAccount(_account);\n', '    }\n', '\n', '    function setShipping(string _shipping) public {\n', '        require(bytes(_shipping).length > 0);\n', '\n', '        shipping[msg.sender] = _shipping;\n', '    }\n', '\n', '}']