['/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', 'pragma solidity 0.4.18;\n', '/// @title Utility Functions for uint\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'library MathUint {\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '    function tolerantSub(uint a, uint b) internal pure returns (uint c) {\n', '        return (a >= b) ? a - b : 0;\n', '    }\n', '    /// @dev calculate the square of Coefficient of Variation (CV)\n', '    /// https://en.wikipedia.org/wiki/Coefficient_of_variation\n', '    function cvsquare(\n', '        uint[] arr,\n', '        uint scale\n', '        )\n', '        internal\n', '        pure\n', '        returns (uint)\n', '    {\n', '        uint len = arr.length;\n', '        require(len > 1);\n', '        require(scale > 0);\n', '        uint avg = 0;\n', '        for (uint i = 0; i < len; i++) {\n', '            avg += arr[i];\n', '        }\n', '        avg = avg / len;\n', '        if (avg == 0) {\n', '            return 0;\n', '        }\n', '        uint cvs = 0;\n', '        uint s;\n', '        uint item;\n', '        for (i = 0; i < len; i++) {\n', '            item = arr[i];\n', '            s = item > avg ? item - avg : avg - item;\n', '            cvs += mul(s, s);\n', '        }\n', '        return ((mul(mul(cvs, scale), scale) / avg) / avg) / (len - 1);\n', '    }\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\t\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    function balanceOf(address who) view public returns (uint256);\n', '    function allowance(address owner, address spender) view public returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/*\n', '  Copyright 2017 Loopring Project Ltd (Loopring Foundation).\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '*/\n', '/// @title Ownable\n', '/// @dev The Ownable contract has an owner address, and provides basic\n', '///      authorization control functions, this simplifies the implementation of\n', '///      "user permissions".\n', 'contract Ownable {\n', '    address public owner;\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '    /// @dev The Ownable constructor sets the original `owner` of the contract\n', '    ///      to the sender.\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '    /// @dev Throws if called by any account other than the owner.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to transfer control of the contract to a\n', '    ///      newOwner.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0);\n', '        OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '/// @title Claimable\n', '/// @dev Extension for the Ownable contract, where the ownership needs\n', '///      to be claimed. This allows the new owner to accept the transfer.\n', 'contract Claimable is Ownable {\n', '    address public pendingOwner;\n', '    /// @dev Modifier throws if called by any account other than the pendingOwner.\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == pendingOwner);\n', '        _;\n', '    }\n', '    /// @dev Allows the current owner to set the pendingOwner address.\n', '    /// @param newOwner The address to transfer ownership to.\n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != 0x0 && newOwner != owner);\n', '        pendingOwner = newOwner;\n', '    }\n', '    /// @dev Allows the pendingOwner address to finalize the transfer.\n', '    function claimOwnership() onlyPendingOwner public {\n', '        OwnershipTransferred(owner, pendingOwner);\n', '        owner = pendingOwner;\n', '        pendingOwner = 0x0;\n', '    }\n', '}\n', '/// @title TokenTransferDelegate\n', '/// @dev Acts as a middle man to transfer ERC20 tokens on behalf of different\n', '/// versions of Loopring protocol to avoid ERC20 re-authorization.\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', 'contract TokenTransferDelegate is Claimable {\n', '    using MathUint for uint;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Variables                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    mapping(address => AddressInfo) private addressInfos;\n', '    address public latestAddress;\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Structs                                                              ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    struct AddressInfo {\n', '        address previous;\n', '        uint32  index;\n', '        bool    authorized;\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Modifiers                                                            ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    modifier onlyAuthorized() {\n', '        require(addressInfos[msg.sender].authorized);\n', '        _;\n', '    }\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Events                                                               ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    event AddressAuthorized(address indexed addr, uint32 number);\n', '    event AddressDeauthorized(address indexed addr, uint32 number);\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// Public Functions                                                     ///\n', '    ////////////////////////////////////////////////////////////////////////////\n', '    /// @dev Add a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function authorizeAddress(address addr)\n', '        onlyOwner\n', '        external\n', '    {\n', '        var addrInfo = addressInfos[addr];\n', '        if (addrInfo.index != 0) { // existing\n', '            if (addrInfo.authorized == false) { // re-authorize\n', '                addrInfo.authorized = true;\n', '                AddressAuthorized(addr, addrInfo.index);\n', '            }\n', '        } else {\n', '            address prev = latestAddress;\n', '            if (prev == 0x0) {\n', '                addrInfo.index = 1;\n', '                addrInfo.authorized = true;\n', '            } else {\n', '                addrInfo.previous = prev;\n', '                addrInfo.index = addressInfos[prev].index + 1;\n', '            }\n', '            addrInfo.authorized = true;\n', '            latestAddress = addr;\n', '            AddressAuthorized(addr, addrInfo.index);\n', '        }\n', '    }\n', '    /// @dev Remove a Loopring protocol address.\n', '    /// @param addr A loopring protocol address.\n', '    function deauthorizeAddress(address addr)\n', '        onlyOwner\n', '        external\n', '    {\n', '        uint32 index = addressInfos[addr].index;\n', '        if (index != 0) {\n', '            addressInfos[addr].authorized = false;\n', '            AddressDeauthorized(addr, index);\n', '        }\n', '    }\n', '    function isAddressAuthorized(address addr)\n', '        public\n', '        view\n', '        returns (bool)\n', '    {\n', '        return addressInfos[addr].authorized;\n', '    }\n', '    function getLatestAuthorizedAddresses(uint max)\n', '        external\n', '        view\n', '        returns (address[] addresses)\n', '    {\n', '        addresses = new address[](max);\n', '        address addr = latestAddress;\n', '        AddressInfo memory addrInfo;\n', '        uint count = 0;\n', '        while (addr != 0x0 && count < max) {\n', '            addrInfo = addressInfos[addr];\n', '            if (addrInfo.index == 0) {\n', '                break;\n', '            }\n', '            addresses[count++] = addr;\n', '            addr = addrInfo.previous;\n', '        }\n', '    }\n', '    /// @dev Invoke ERC20 transferFrom method.\n', '    /// @param token Address of token to transfer.\n', '    /// @param from Address to transfer token from.\n', '    /// @param to Address to transfer token to.\n', '    /// @param value Amount of token to transfer.\n', '    function transferToken(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value)\n', '        onlyAuthorized\n', '        external\n', '    {\n', '        if (value > 0 && from != to) {\n', '            require(\n', '                ERC20(token).transferFrom(from, to, value)\n', '            );\n', '        }\n', '    }\n', '    function batchTransferToken(\n', '        address lrcTokenAddress,\n', '        address feeRecipient,\n', '        bytes32[] batch)\n', '        onlyAuthorized\n', '        external\n', '    {\n', '        uint len = batch.length;\n', '        require(len % 6 == 0);\n', '        var lrc = ERC20(lrcTokenAddress);\n', '        for (uint i = 0; i < len; i += 6) {\n', '            address owner = address(batch[i]);\n', '            address prevOwner = address(batch[(i + len - 6) % len]);\n', '            \n', "            // Pay token to previous order, or to miner as previous order's\n", "            // margin split or/and this order's margin split.\n", '            var token = ERC20(address(batch[i + 1]));\n', '            // Here batch[i+2] has been checked not to be 0.\n', '            if (owner != prevOwner) {\n', '                require(\n', '                    token.transferFrom(owner, prevOwner, uint(batch[i + 2]))\n', '                );\n', '            }\n', '            if (owner != feeRecipient) {\n', '                bytes32 item = batch[i + 3];\n', '                if (item != 0) {\n', '                    require(\n', '                        token.transferFrom(owner, feeRecipient, uint(item))\n', '                    );\n', '                } \n', '                item = batch[i + 4];\n', '                if (item != 0) {\n', '                    require(\n', '                        lrc.transferFrom(feeRecipient, owner, uint(item))\n', '                    );\n', '                }\n', '                item = batch[i + 5];\n', '                if (item != 0) {\n', '                    require(\n', '                        lrc.transferFrom(owner, feeRecipient, uint(item))\n', '                    );\n', '                }\n', '            }\n', '        }\n', '    }\n', '}']