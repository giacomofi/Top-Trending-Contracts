['//File: node_modules/liquidpledging/contracts/ILiquidPledgingPlugin.sol\n', 'pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Copyright 2017, Jordi Baylina\n', '    Contributor: Adrià Massanet <adria@codecontext.io>\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '/// @dev `ILiquidPledgingPlugin` is the basic interface for any\n', '///  liquid pledging plugin\n', 'contract ILiquidPledgingPlugin {\n', '\n', '    /// @notice Plugins are used (much like web hooks) to initiate an action\n', '    ///  upon any donation, delegation, or transfer; this is an optional feature\n', '    ///  and allows for extreme customization of the contract. This function\n', '    ///  implements any action that should be initiated before a transfer.\n', '    /// @param pledgeManager The admin or current manager of the pledge\n', '    /// @param pledgeFrom This is the Id from which value will be transfered.\n', '    /// @param pledgeTo This is the Id that value will be transfered to.    \n', '    /// @param context The situation that is triggering the plugin:\n', '    ///  0 -> Plugin for the owner transferring pledge to another party\n', '    ///  1 -> Plugin for the first delegate transferring pledge to another party\n', '    ///  2 -> Plugin for the second delegate transferring pledge to another party\n', '    ///  ...\n', '    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n', '    ///\n', '    ///  256 -> Plugin for the owner receiving pledge to another party\n', '    ///  257 -> Plugin for the first delegate receiving pledge to another party\n', '    ///  258 -> Plugin for the second delegate receiving pledge to another party\n', '    ///  ...\n', '    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n', '    /// @param amount The amount of value that will be transfered.\n', '    function beforeTransfer(\n', '        uint64 pledgeManager,\n', '        uint64 pledgeFrom,\n', '        uint64 pledgeTo,\n', '        uint64 context,\n', '        uint amount ) returns (uint maxAllowed);\n', '\n', '    /// @notice Plugins are used (much like web hooks) to initiate an action\n', '    ///  upon any donation, delegation, or transfer; this is an optional feature\n', '    ///  and allows for extreme customization of the contract. This function\n', '    ///  implements any action that should be initiated after a transfer.\n', '    /// @param pledgeManager The admin or current manager of the pledge\n', '    /// @param pledgeFrom This is the Id from which value will be transfered.\n', '    /// @param pledgeTo This is the Id that value will be transfered to.    \n', '    /// @param context The situation that is triggering the plugin:\n', '    ///  0 -> Plugin for the owner transferring pledge to another party\n', '    ///  1 -> Plugin for the first delegate transferring pledge to another party\n', '    ///  2 -> Plugin for the second delegate transferring pledge to another party\n', '    ///  ...\n', '    ///  255 -> Plugin for the intendedProject transferring pledge to another party\n', '    ///\n', '    ///  256 -> Plugin for the owner receiving pledge to another party\n', '    ///  257 -> Plugin for the first delegate receiving pledge to another party\n', '    ///  258 -> Plugin for the second delegate receiving pledge to another party\n', '    ///  ...\n', '    ///  511 -> Plugin for the intendedProject receiving pledge to another party\n', '    ///  @param amount The amount of value that will be transfered.\n', '    function afterTransfer(\n', '        uint64 pledgeManager,\n', '        uint64 pledgeFrom,\n', '        uint64 pledgeTo,\n', '        uint64 context,\n', '        uint amount\n', '    );\n', '}\n', '\n', '//File: node_modules/giveth-common-contracts/contracts/Owned.sol\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', '/// @title Owned\n', '/// @author Adrià Massanet <adria@codecontext.io>\n', '/// @notice The Owned contract has an owner address, and provides basic \n', '///  authorization control functions, this simplifies & the implementation of\n', '///  user permissions; this contract has three work flows for a change in\n', '///  ownership, the first requires the new owner to validate that they have the\n', '///  ability to accept ownership, the second allows the ownership to be\n', '///  directly transfered without requiring acceptance, and the third allows for\n', '///  the ownership to be removed to allow for decentralization \n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwnerCandidate;\n', '\n', '    event OwnershipRequested(address indexed by, address indexed to);\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '    event OwnershipRemoved();\n', '\n', '    /// @dev The constructor sets the `msg.sender` as the`owner` of the contract\n', '    function Owned() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /// @dev `owner` is the only address that can call a function with this\n', '    /// modifier\n', '    modifier onlyOwner() {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '    \n', '    /// @dev In this 1st option for ownership transfer `proposeOwnership()` must\n', '    ///  be called first by the current `owner` then `acceptOwnership()` must be\n', '    ///  called by the `newOwnerCandidate`\n', '    /// @notice `onlyOwner` Proposes to transfer control of the contract to a\n', '    ///  new owner\n', '    /// @param _newOwnerCandidate The address being proposed as the new owner\n', '    function proposeOwnership(address _newOwnerCandidate) public onlyOwner {\n', '        newOwnerCandidate = _newOwnerCandidate;\n', '        OwnershipRequested(msg.sender, newOwnerCandidate);\n', '    }\n', '\n', '    /// @notice Can only be called by the `newOwnerCandidate`, accepts the\n', '    ///  transfer of ownership\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwnerCandidate);\n', '\n', '        address oldOwner = owner;\n', '        owner = newOwnerCandidate;\n', '        newOwnerCandidate = 0x0;\n', '\n', '        OwnershipTransferred(oldOwner, owner);\n', '    }\n', '\n', '    /// @dev In this 2nd option for ownership transfer `changeOwnership()` can\n', '    ///  be called and it will immediately assign ownership to the `newOwner`\n', '    /// @notice `owner` can step down and assign some other address to this role\n', '    /// @param _newOwner The address of the new owner\n', '    function changeOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != 0x0);\n', '\n', '        address oldOwner = owner;\n', '        owner = _newOwner;\n', '        newOwnerCandidate = 0x0;\n', '\n', '        OwnershipTransferred(oldOwner, owner);\n', '    }\n', '\n', '    /// @dev In this 3rd option for ownership transfer `removeOwnership()` can\n', '    ///  be called and it will immediately assign ownership to the 0x0 address;\n', '    ///  it requires a 0xdece be input as a parameter to prevent accidental use\n', '    /// @notice Decentralizes the contract, this operation cannot be undone \n', '    /// @param _dac `0xdac` has to be entered for this function to work\n', '    function removeOwnership(address _dac) public onlyOwner {\n', '        require(_dac == 0xdac);\n', '        owner = 0x0;\n', '        newOwnerCandidate = 0x0;\n', '        OwnershipRemoved();     \n', '    }\n', '} \n', '\n', '//File: node_modules/giveth-common-contracts/contracts/ERC20.sol\n', 'pragma solidity ^0.4.15;\n', '\n', '\n', '/**\n', ' * @title ERC20\n', ' * @dev A standard interface for tokens.\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', ' */\n', 'contract ERC20 {\n', '  \n', '    /// @dev Returns the total token supply\n', '    function totalSupply() public constant returns (uint256 supply);\n', '\n', '    /// @dev Returns the account balance of the account with address _owner\n', '    function balanceOf(address _owner) public constant returns (uint256 balance);\n', '\n', '    /// @dev Transfers _value number of tokens to address _to\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Transfers _value number of tokens from address _from to address _to\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '\n', "    /// @dev Allows _spender to withdraw from the msg.sender's account up to the _value amount\n", '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '\n', '    /// @dev Returns the amount which _spender is still allowed to withdraw from _owner\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '}\n', '\n', '//File: node_modules/giveth-common-contracts/contracts/Escapable.sol\n', 'pragma solidity ^0.4.15;\n', '/*\n', '    Copyright 2016, Jordi Baylina\n', '    Contributor: Adrià Massanet <adria@codecontext.io>\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '\n', '/// @dev `Escapable` is a base level contract built off of the `Owned`\n', '///  contract; it creates an escape hatch function that can be called in an\n', '///  emergency that will allow designated addresses to send any ether or tokens\n', '///  held in the contract to an `escapeHatchDestination` as long as they were\n', '///  not blacklisted\n', 'contract Escapable is Owned {\n', '    address public escapeHatchCaller;\n', '    address public escapeHatchDestination;\n', '    mapping (address=>bool) private escapeBlacklist; // Token contract addresses\n', '\n', '    /// @notice The Constructor assigns the `escapeHatchDestination` and the\n', '    ///  `escapeHatchCaller`\n', '    /// @param _escapeHatchCaller The address of a trusted account or contract\n', '    ///  to call `escapeHatch()` to send the ether in this contract to the\n', '    ///  `escapeHatchDestination` it would be ideal that `escapeHatchCaller`\n', '    ///  cannot move funds out of `escapeHatchDestination`\n', '    /// @param _escapeHatchDestination The address of a safe location (usu a\n', '    ///  Multisig) to send the ether held in this contract; if a neutral address\n', '    ///  is required, the WHG Multisig is an option:\n', '    ///  0x8Ff920020c8AD673661c8117f2855C384758C572 \n', '    function Escapable(address _escapeHatchCaller, address _escapeHatchDestination) public {\n', '        escapeHatchCaller = _escapeHatchCaller;\n', '        escapeHatchDestination = _escapeHatchDestination;\n', '    }\n', '\n', '    /// @dev The addresses preassigned as `escapeHatchCaller` or `owner`\n', '    ///  are the only addresses that can call a function with this modifier\n', '    modifier onlyEscapeHatchCallerOrOwner {\n', '        require ((msg.sender == escapeHatchCaller)||(msg.sender == owner));\n', '        _;\n', '    }\n', '\n', '    /// @notice Creates the blacklist of tokens that are not able to be taken\n', '    ///  out of the contract; can only be done at the deployment, and the logic\n', '    ///  to add to the blacklist will be in the constructor of a child contract\n', '    /// @param _token the token contract address that is to be blacklisted \n', '    function blacklistEscapeToken(address _token) internal {\n', '        escapeBlacklist[_token] = true;\n', '        EscapeHatchBlackistedToken(_token);\n', '    }\n', '\n', '    /// @notice Checks to see if `_token` is in the blacklist of tokens\n', '    /// @param _token the token address being queried\n', "    /// @return False if `_token` is in the blacklist and can't be taken out of\n", '    ///  the contract via the `escapeHatch()`\n', '    function isTokenEscapable(address _token) constant public returns (bool) {\n', '        return !escapeBlacklist[_token];\n', '    }\n', '\n', '    /// @notice The `escapeHatch()` should only be called as a last resort if a\n', '    /// security issue is uncovered or something unexpected happened\n', '    /// @param _token to transfer, use 0x0 for ether\n', '    function escapeHatch(address _token) public onlyEscapeHatchCallerOrOwner {   \n', '        require(escapeBlacklist[_token]==false);\n', '\n', '        uint256 balance;\n', '\n', '        /// @dev Logic for ether\n', '        if (_token == 0x0) {\n', '            balance = this.balance;\n', '            escapeHatchDestination.transfer(balance);\n', '            EscapeHatchCalled(_token, balance);\n', '            return;\n', '        }\n', '        /// @dev Logic for tokens\n', '        ERC20 token = ERC20(_token);\n', '        balance = token.balanceOf(this);\n', '        require(token.transfer(escapeHatchDestination, balance));\n', '        EscapeHatchCalled(_token, balance);\n', '    }\n', '\n', '    /// @notice Changes the address assigned to call `escapeHatch()`\n', '    /// @param _newEscapeHatchCaller The address of a trusted account or\n', '    ///  contract to call `escapeHatch()` to send the value in this contract to\n', '    ///  the `escapeHatchDestination`; it would be ideal that `escapeHatchCaller`\n', '    ///  cannot move funds out of `escapeHatchDestination`\n', '    function changeHatchEscapeCaller(address _newEscapeHatchCaller) public onlyEscapeHatchCallerOrOwner {\n', '        escapeHatchCaller = _newEscapeHatchCaller;\n', '    }\n', '\n', '    event EscapeHatchBlackistedToken(address token);\n', '    event EscapeHatchCalled(address token, uint amount);\n', '}\n', '\n', '//File: node_modules/liquidpledging/contracts/LiquidPledgingBase.sol\n', 'pragma solidity ^0.4.11;\n', '/*\n', '    Copyright 2017, Jordi Baylina\n', '    Contributors: Adrià Massanet <adria@codecontext.io>, RJ Ewing, Griff\n', '    Green, Arthur Lunn\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '\n', '\n', '\n', '/// @dev This is an interface for `LPVault` which serves as a secure storage for\n', '///  the ETH that backs the Pledges, only after `LiquidPledging` authorizes\n', '///  payments can Pledges be converted for ETH\n', 'interface LPVault {\n', '    function authorizePayment(bytes32 _ref, address _dest, uint _amount);\n', '    function () payable;\n', '}\n', '\n', '/// @dev `LiquidPledgingBase` is the base level contract used to carry out\n', "///  liquidPledging's most basic functions, mostly handling and searching the\n", '///  data structures\n', 'contract LiquidPledgingBase is Escapable {\n', '\n', '    // Limits inserted to prevent large loops that could prevent canceling\n', '    uint constant MAX_DELEGATES = 20;\n', '    uint constant MAX_SUBPROJECT_LEVEL = 20;\n', '    uint constant MAX_INTERPROJECT_LEVEL = 20;\n', '\n', '    enum PledgeAdminType { Giver, Delegate, Project }\n', '    enum PledgeState { Pledged, Paying, Paid }\n', '\n', '    /// @dev This struct defines the details of a `PledgeAdmin` which are \n', '    ///  commonly referenced by their index in the `admins` array\n', '    ///  and can own pledges and act as delegates\n', '    struct PledgeAdmin { \n', '        PledgeAdminType adminType; // Giver, Delegate or Project\n', '        address addr; // Account or contract address for admin\n', '        string name;\n', '        string url;  // Can be IPFS hash\n', "        uint64 commitTime;  // In seconds, used for Givers' & Delegates' vetos\n", '        uint64 parentProject;  // Only for projects\n', '        bool canceled;      //Always false except for canceled projects\n', '\n', '        /// @dev if the plugin is 0x0 then nothing happens, if its an address\n', '        // than that smart contract is called when appropriate\n', '        ILiquidPledgingPlugin plugin; \n', '    }\n', '\n', '    struct Pledge {\n', '        uint amount;\n', '        uint64 owner; // PledgeAdmin\n', '        uint64[] delegationChain; // List of delegates in order of authority\n', '        uint64 intendedProject; // Used when delegates are sending to projects\n', '        uint64 commitTime;  // When the intendedProject will become the owner  \n', '        uint64 oldPledge; // Points to the id that this Pledge was derived from\n', '        PledgeState pledgeState; //  Pledged, Paying, Paid\n', '    }\n', '\n', '    Pledge[] pledges;\n', '    PledgeAdmin[] admins; //The list of pledgeAdmins 0 means there is no admin\n', '    LPVault public vault;\n', '\n', "    /// @dev this mapping allows you to search for a specific pledge's \n", '    ///  index number by the hash of that pledge\n', '    mapping (bytes32 => uint64) hPledge2idx;\n', '    mapping (bytes32 => bool) pluginWhitelist;\n', '    \n', '    bool public usePluginWhitelist = true;\n', '\n', '/////////////\n', '// Modifiers\n', '/////////////\n', '\n', '\n', '    /// @dev The `vault`is the only addresses that can call a function with this\n', '    ///  modifier\n', '    modifier onlyVault() {\n', '        require(msg.sender == address(vault));\n', '        _;\n', '    }\n', '\n', '\n', '///////////////\n', '// Constructor\n', '///////////////\n', '\n', '    /// @notice The Constructor creates `LiquidPledgingBase` on the blockchain\n', '    /// @param _vault The vault where the ETH backing the pledges is stored\n', '    function LiquidPledgingBase(\n', '        address _vault,\n', '        address _escapeHatchCaller,\n', '        address _escapeHatchDestination\n', '    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public {\n', '        admins.length = 1; // we reserve the 0 admin\n', '        pledges.length = 1; // we reserve the 0 pledge\n', '        vault = LPVault(_vault); // Assigns the specified vault\n', '    }\n', '\n', '\n', '/////////////////////////\n', '// PledgeAdmin functions\n', '/////////////////////////\n', '\n', '    /// @notice Creates a Giver Admin with the `msg.sender` as the Admin address\n', '    /// @param name The name used to identify the Giver\n', "    /// @param url The link to the Giver's profile often an IPFS hash\n", '    /// @param commitTime The length of time in seconds the Giver has to\n', "    ///   veto when the Giver's delegates Pledge funds to a project\n", "    /// @param plugin This is Giver's liquid pledge plugin allowing for \n", '    ///  extended functionality\n', '    /// @return idGiver The id number used to reference this Admin\n', '    function addGiver(\n', '        string name,\n', '        string url,\n', '        uint64 commitTime,\n', '        ILiquidPledgingPlugin plugin\n', '    ) returns (uint64 idGiver) {\n', '\n', '        require(isValidPlugin(plugin)); // Plugin check\n', '\n', '        idGiver = uint64(admins.length);\n', '\n', '        admins.push(PledgeAdmin(\n', '            PledgeAdminType.Giver,\n', '            msg.sender,\n', '            name,\n', '            url,\n', '            commitTime,\n', '            0,\n', '            false,\n', '            plugin));\n', '\n', '        GiverAdded(idGiver);\n', '    }\n', '\n', '    event GiverAdded(uint64 indexed idGiver);\n', '\n', "    /// @notice Updates a Giver's info to change the address, name, url, or \n", '    ///  commitTime, it cannot be used to change a plugin, and it must be called\n', '    ///  by the current address of the Giver\n', '    /// @param idGiver This is the Admin id number used to specify the Giver\n', '    /// @param newAddr The new address that represents this Giver\n', '    /// @param newName The new name used to identify the Giver\n', "    /// @param newUrl The new link to the Giver's profile often an IPFS hash\n", '    /// @param newCommitTime Sets the length of time in seconds the Giver has to\n', "    ///   veto when the Giver's delegates Pledge funds to a project\n", '    function updateGiver(\n', '        uint64 idGiver,\n', '        address newAddr,\n', '        string newName,\n', '        string newUrl,\n', '        uint64 newCommitTime)\n', '    {\n', '        PledgeAdmin storage giver = findAdmin(idGiver);\n', '        require(giver.adminType == PledgeAdminType.Giver); // Must be a Giver\n', '        require(giver.addr == msg.sender); // Current addr had to send this tx\n', '        giver.addr = newAddr;\n', '        giver.name = newName;\n', '        giver.url = newUrl;\n', '        giver.commitTime = newCommitTime;\n', '        GiverUpdated(idGiver);\n', '    }\n', '\n', '    event GiverUpdated(uint64 indexed idGiver);\n', '\n', '    /// @notice Creates a Delegate Admin with the `msg.sender` as the Admin addr\n', '    /// @param name The name used to identify the Delegate\n', "    /// @param url The link to the Delegate's profile often an IPFS hash\n", '    /// @param commitTime Sets the length of time in seconds that this delegate\n', '    ///  can be vetoed. Whenever this delegate is in a delegate chain the time\n', '    ///  allowed to veto any event must be greater than or equal to this time.\n', "    /// @param plugin This is Delegate's liquid pledge plugin allowing for \n", '    ///  extended functionality\n', '    /// @return idxDelegate The id number used to reference this Delegate within\n', '    ///  the admins array\n', '    function addDelegate(\n', '        string name,\n', '        string url,\n', '        uint64 commitTime,\n', '        ILiquidPledgingPlugin plugin\n', '    ) returns (uint64 idDelegate) { \n', '\n', '        require(isValidPlugin(plugin)); // Plugin check\n', '\n', '        idDelegate = uint64(admins.length);\n', '\n', '        admins.push(PledgeAdmin(\n', '            PledgeAdminType.Delegate,\n', '            msg.sender,\n', '            name,\n', '            url,\n', '            commitTime,\n', '            0,\n', '            false,\n', '            plugin));\n', '\n', '        DelegateAdded(idDelegate);\n', '    }\n', '\n', '    event DelegateAdded(uint64 indexed idDelegate);\n', '\n', "    /// @notice Updates a Delegate's info to change the address, name, url, or \n", '    ///  commitTime, it cannot be used to change a plugin, and it must be called\n', '    ///  by the current address of the Delegate\n', '    /// @param idDelegate The Admin id number used to specify the Delegate\n', '    /// @param newAddr The new address that represents this Delegate\n', '    /// @param newName The new name used to identify the Delegate\n', "    /// @param newUrl The new link to the Delegate's profile often an IPFS hash\n", '    /// @param newCommitTime Sets the length of time in seconds that this \n', '    ///  delegate can be vetoed. Whenever this delegate is in a delegate chain \n', '    ///  the time allowed to veto any event must be greater than or equal to\n', '    ///  this time.\n', '    function updateDelegate(\n', '        uint64 idDelegate,\n', '        address newAddr,\n', '        string newName,\n', '        string newUrl,\n', '        uint64 newCommitTime) {\n', '        PledgeAdmin storage delegate = findAdmin(idDelegate);\n', '        require(delegate.adminType == PledgeAdminType.Delegate);\n', '        require(delegate.addr == msg.sender);// Current addr had to send this tx\n', '        delegate.addr = newAddr;\n', '        delegate.name = newName;\n', '        delegate.url = newUrl;\n', '        delegate.commitTime = newCommitTime;\n', '        DelegateUpdated(idDelegate);\n', '    }\n', '\n', '    event DelegateUpdated(uint64 indexed idDelegate);\n', '\n', '    /// @notice Creates a Project Admin with the `msg.sender` as the Admin addr\n', '    /// @param name The name used to identify the Project\n', "    /// @param url The link to the Project's profile often an IPFS hash\n", '    /// @param projectAdmin The address for the trusted project manager \n', '    /// @param parentProject The Admin id number for the parent project or 0 if\n', '    ///  there is no parentProject\n', '    /// @param commitTime Sets the length of time in seconds the Project has to\n', '    ///   veto when the Project delegates to another Delegate and they pledge \n', '    ///   those funds to a project\n', "    /// @param plugin This is Project's liquid pledge plugin allowing for \n", '    ///  extended functionality\n', '    /// @return idProject The id number used to reference this Admin\n', '    function addProject(\n', '        string name,\n', '        string url,\n', '        address projectAdmin,\n', '        uint64 parentProject,\n', '        uint64 commitTime,\n', '        ILiquidPledgingPlugin plugin\n', '    ) returns (uint64 idProject) {\n', '        require(isValidPlugin(plugin));\n', '\n', '        if (parentProject != 0) {\n', '            PledgeAdmin storage pa = findAdmin(parentProject);\n', '            require(pa.adminType == PledgeAdminType.Project);\n', '            require(getProjectLevel(pa) < MAX_SUBPROJECT_LEVEL);\n', '        }\n', '\n', '        idProject = uint64(admins.length);\n', '\n', '        admins.push(PledgeAdmin(\n', '            PledgeAdminType.Project,\n', '            projectAdmin,\n', '            name,\n', '            url,\n', '            commitTime,\n', '            parentProject,\n', '            false,\n', '            plugin));\n', '\n', '\n', '        ProjectAdded(idProject);\n', '    }\n', '\n', '    event ProjectAdded(uint64 indexed idProject);\n', '\n', '\n', "    /// @notice Updates a Project's info to change the address, name, url, or \n", '    ///  commitTime, it cannot be used to change a plugin or a parentProject,\n', '    ///  and it must be called by the current address of the Project\n', '    /// @param idProject The Admin id number used to specify the Project\n', '    /// @param newAddr The new address that represents this Project\n', '    /// @param newName The new name used to identify the Project\n', "    /// @param newUrl The new link to the Project's profile often an IPFS hash\n", '    /// @param newCommitTime Sets the length of time in seconds the Project has\n', '    ///  to veto when the Project delegates to a Delegate and they pledge those\n', '    ///  funds to a project\n', '    function updateProject(\n', '        uint64 idProject,\n', '        address newAddr,\n', '        string newName,\n', '        string newUrl,\n', '        uint64 newCommitTime)\n', '    {\n', '        PledgeAdmin storage project = findAdmin(idProject);\n', '        require(project.adminType == PledgeAdminType.Project);\n', '        require(project.addr == msg.sender);\n', '        project.addr = newAddr;\n', '        project.name = newName;\n', '        project.url = newUrl;\n', '        project.commitTime = newCommitTime;\n', '        ProjectUpdated(idProject);\n', '    }\n', '\n', '    event ProjectUpdated(uint64 indexed idAdmin);\n', '\n', '\n', '//////////\n', '// Public constant functions\n', '//////////\n', '\n', '    /// @notice A constant getter that returns the total number of pledges\n', '    /// @return The total number of Pledges in the system\n', '    function numberOfPledges() constant returns (uint) {\n', '        return pledges.length - 1;\n', '    }\n', '\n', '    /// @notice A getter that returns the details of the specified pledge\n', '    /// @param idPledge the id number of the pledge being queried\n', '    /// @return the amount, owner, the number of delegates (but not the actual\n', '    ///  delegates, the intendedProject (if any), the current commit time and\n', '    ///  the previous pledge this pledge was derived from\n', '    function getPledge(uint64 idPledge) constant returns(\n', '        uint amount,\n', '        uint64 owner,\n', '        uint64 nDelegates,\n', '        uint64 intendedProject,\n', '        uint64 commitTime,\n', '        uint64 oldPledge,\n', '        PledgeState pledgeState\n', '    ) {\n', '        Pledge storage p = findPledge(idPledge);\n', '        amount = p.amount;\n', '        owner = p.owner;\n', '        nDelegates = uint64(p.delegationChain.length);\n', '        intendedProject = p.intendedProject;\n', '        commitTime = p.commitTime;\n', '        oldPledge = p.oldPledge;\n', '        pledgeState = p.pledgeState;\n', '    }\n', '\n', '    /// @notice Getter to find Delegate w/ the Pledge ID & the Delegate index\n', '    /// @param idPledge The id number representing the pledge being queried\n', '    /// @param idxDelegate The index number for the delegate in this Pledge \n', '    function getPledgeDelegate(uint64 idPledge, uint idxDelegate) constant returns(\n', '        uint64 idDelegate,\n', '        address addr,\n', '        string name\n', '    ) {\n', '        Pledge storage p = findPledge(idPledge);\n', '        idDelegate = p.delegationChain[idxDelegate - 1];\n', '        PledgeAdmin storage delegate = findAdmin(idDelegate);\n', '        addr = delegate.addr;\n', '        name = delegate.name;\n', '    }\n', '\n', '    /// @notice A constant getter used to check how many total Admins exist\n', '    /// @return The total number of admins (Givers, Delegates and Projects) .\n', '    function numberOfPledgeAdmins() constant returns(uint) {\n', '        return admins.length - 1;\n', '    }\n', '\n', '    /// @notice A constant getter to check the details of a specified Admin  \n', '    /// @return addr Account or contract address for admin\n', '    /// @return name Name of the pledgeAdmin\n', "    /// @return url The link to the Project's profile often an IPFS hash\n", '    /// @return commitTime The length of time in seconds the Admin has to veto\n', '    ///   when the Admin delegates to a Delegate and that Delegate pledges those\n', '    ///   funds to a project\n', '    /// @return parentProject The Admin id number for the parent project or 0\n', '    ///  if there is no parentProject\n', '    /// @return canceled 0 for Delegates & Givers, true if a Project has been \n', '    ///  canceled\n', "    /// @return plugin This is Project's liquidPledging plugin allowing for \n", '    ///  extended functionality\n', '    function getPledgeAdmin(uint64 idAdmin) constant returns (\n', '        PledgeAdminType adminType,\n', '        address addr,\n', '        string name,\n', '        string url,\n', '        uint64 commitTime,\n', '        uint64 parentProject,\n', '        bool canceled,\n', '        address plugin)\n', '    {\n', '        PledgeAdmin storage m = findAdmin(idAdmin);\n', '        adminType = m.adminType;\n', '        addr = m.addr;\n', '        name = m.name;\n', '        url = m.url;\n', '        commitTime = m.commitTime;\n', '        parentProject = m.parentProject;\n', '        canceled = m.canceled;\n', '        plugin = address(m.plugin);\n', '    }\n', '\n', '////////\n', '// Private methods\n', '///////\n', '\n', '    /// @notice This creates a Pledge with an initial amount of 0 if one is not\n', '    ///  created already; otherwise it finds the pledge with the specified\n', "    ///  attributes; all pledges technically exist, if the pledge hasn't been\n", "    ///  created in this system yet it simply isn't in the hash array\n", '    ///  hPledge2idx[] yet\n', '    /// @param owner The owner of the pledge being looked up\n', '    /// @param delegationChain The list of delegates in order of authority\n', '    /// @param intendedProject The project this pledge will Fund after the\n', '    ///  commitTime has passed\n', '    /// @param commitTime The length of time in seconds the Giver has to\n', "    ///   veto when the Giver's delegates Pledge funds to a project\n", '    /// @param oldPledge This value is used to store the pledge the current\n', '    ///  pledge was came from, and in the case a Project is canceled, the Pledge\n', "    ///  will revert back to it's previous state\n", '    /// @param state The pledge state: Pledged, Paying, or state\n', '    /// @return The hPledge2idx index number\n', '    function findOrCreatePledge(\n', '        uint64 owner,\n', '        uint64[] delegationChain,\n', '        uint64 intendedProject,\n', '        uint64 commitTime,\n', '        uint64 oldPledge,\n', '        PledgeState state\n', '        ) internal returns (uint64)\n', '    {\n', '        bytes32 hPledge = sha3(\n', '            owner, delegationChain, intendedProject, commitTime, oldPledge, state);\n', '        uint64 idx = hPledge2idx[hPledge];\n', '        if (idx > 0) return idx;\n', '        idx = uint64(pledges.length);\n', '        hPledge2idx[hPledge] = idx;\n', '        pledges.push(Pledge(\n', '            0, owner, delegationChain, intendedProject, commitTime, oldPledge, state));\n', '        return idx;\n', '    }\n', '\n', "    /// @notice A getter to look up a Admin's details\n", '    /// @param idAdmin The id for the Admin to lookup\n', '    /// @return The PledgeAdmin struct for the specified Admin\n', '    function findAdmin(uint64 idAdmin) internal returns (PledgeAdmin storage) {\n', '        require(idAdmin < admins.length);\n', '        return admins[idAdmin];\n', '    }\n', '\n', "    /// @notice A getter to look up a Pledge's details\n", '    /// @param idPledge The id for the Pledge to lookup\n', '    /// @return The PledgeA struct for the specified Pledge\n', '    function findPledge(uint64 idPledge) internal returns (Pledge storage) {\n', '        require(idPledge < pledges.length);\n', '        return pledges[idPledge];\n', '    }\n', '\n', '    // a constant for when a delegate is requested that is not in the system\n', '    uint64 constant  NOTFOUND = 0xFFFFFFFFFFFFFFFF;\n', '\n', '    /// @notice A getter that searches the delegationChain for the level of\n', '    ///  authority a specific delegate has within a Pledge\n', '    /// @param p The Pledge that will be searched\n', "    /// @param idDelegate The specified delegate that's searched for\n", '    /// @return If the delegate chain contains the delegate with the\n', '    ///  `admins` array index `idDelegate` this returns that delegates\n', '    ///  corresponding index in the delegationChain. Otherwise it returns\n', '    ///  the NOTFOUND constant\n', '    function getDelegateIdx(Pledge p, uint64 idDelegate) internal returns(uint64) {\n', '        for (uint i=0; i < p.delegationChain.length; i++) {\n', '            if (p.delegationChain[i] == idDelegate) return uint64(i);\n', '        }\n', '        return NOTFOUND;\n', '    }\n', '\n', '    /// @notice A getter to find how many old "parent" pledges a specific Pledge\n', '    ///  had using a self-referential loop\n', '    /// @param p The Pledge being queried\n', '    /// @return The number of old "parent" pledges a specific Pledge had\n', '    function getPledgeLevel(Pledge p) internal returns(uint) {\n', '        if (p.oldPledge == 0) return 0;\n', '        Pledge storage oldN = findPledge(p.oldPledge);\n', '        return getPledgeLevel(oldN) + 1; // a loop lookup\n', '    }\n', '\n', '    /// @notice A getter to find the longest commitTime out of the owner and all\n', '    ///  the delegates for a specified pledge\n', '    /// @param p The Pledge being queried\n', '    /// @return The maximum commitTime out of the owner and all the delegates\n', '    function maxCommitTime(Pledge p) internal returns(uint commitTime) {\n', '        PledgeAdmin storage m = findAdmin(p.owner);\n', "        commitTime = m.commitTime; // start with the owner's commitTime\n", '\n', '        for (uint i=0; i<p.delegationChain.length; i++) {\n', '            m = findAdmin(p.delegationChain[i]);\n', '\n', "            // If a delegate's commitTime is longer, make it the new commitTime\n", '            if (m.commitTime > commitTime) commitTime = m.commitTime;\n', '        }\n', '    }\n', '\n', '    /// @notice A getter to find the level of authority a specific Project has\n', '    ///  using a self-referential loop\n', '    /// @param m The Project being queried\n', '    /// @return The level of authority a specific Project has\n', '    function getProjectLevel(PledgeAdmin m) internal returns(uint) {\n', '        assert(m.adminType == PledgeAdminType.Project);\n', '        if (m.parentProject == 0) return(1);\n', '        PledgeAdmin storage parentNM = findAdmin(m.parentProject);\n', '        return getProjectLevel(parentNM) + 1;\n', '    }\n', '\n', '    /// @notice A getter to find if a specified Project has been canceled\n', '    /// @param projectId The Admin id number used to specify the Project\n', '    /// @return True if the Project has been canceled\n', '    function isProjectCanceled(uint64 projectId) constant returns (bool) {\n', '        PledgeAdmin storage m = findAdmin(projectId);\n', '        if (m.adminType == PledgeAdminType.Giver) return false;\n', '        assert(m.adminType == PledgeAdminType.Project);\n', '        if (m.canceled) return true;\n', '        if (m.parentProject == 0) return false;\n', '        return isProjectCanceled(m.parentProject);\n', '    }\n', '\n', "    /// @notice A getter to find the oldest pledge that hasn't been canceled\n", '    /// @param idPledge The starting place to lookup the pledges \n', "    /// @return The oldest idPledge that hasn't been canceled (DUH!)\n", '    function getOldestPledgeNotCanceled(uint64 idPledge\n', '        ) internal constant returns(uint64) {\n', '        if (idPledge == 0) return 0;\n', '        Pledge storage p = findPledge(idPledge);\n', '        PledgeAdmin storage admin = findAdmin(p.owner);\n', '        if (admin.adminType == PledgeAdminType.Giver) return idPledge;\n', '\n', '        assert(admin.adminType == PledgeAdminType.Project);\n', '\n', '        if (!isProjectCanceled(p.owner)) return idPledge;\n', '\n', '        return getOldestPledgeNotCanceled(p.oldPledge);\n', '    }\n', '\n', '    /// @notice A check to see if the msg.sender is the owner or the\n', '    ///  plugin contract for a specific Admin\n', '    /// @param m The Admin being checked\n', '    function checkAdminOwner(PledgeAdmin m) internal constant {\n', '        require((msg.sender == m.addr) || (msg.sender == address(m.plugin)));\n', '    }\n', '///////////////////////////\n', '// Plugin Whitelist Methods\n', '///////////////////////////\n', '\n', '    function addValidPlugin(bytes32 contractHash) external onlyOwner {\n', '        pluginWhitelist[contractHash] = true;\n', '    }\n', '\n', '    function removeValidPlugin(bytes32 contractHash) external onlyOwner {\n', '        pluginWhitelist[contractHash] = false;\n', '    }\n', '\n', '    function useWhitelist(bool useWhitelist) external onlyOwner {\n', '        usePluginWhitelist = useWhitelist;\n', '    }\n', '\n', '    function isValidPlugin(address addr) public returns(bool) {\n', '        if (!usePluginWhitelist || addr == 0x0) return true;\n', '\n', '        bytes32 contractHash = getCodeHash(addr);\n', '\n', '        return pluginWhitelist[contractHash];\n', '    }\n', '\n', '    function getCodeHash(address addr) public returns(bytes32) {\n', '        bytes memory o_code;\n', '        assembly {\n', '            // retrieve the size of the code, this needs assembly\n', '            let size := extcodesize(addr)\n', '            // allocate output byte array - this could also be done without assembly\n', '            // by using o_code = new bytes(size)\n', '            o_code := mload(0x40)\n', '            // new "memory end" including padding\n', '            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n', '            // store length in memory\n', '            mstore(o_code, size)\n', '            // actually retrieve the code, this needs assembly\n', '            extcodecopy(addr, add(o_code, 0x20), 0, size)\n', '        }\n', '        return keccak256(o_code);\n', '    }\n', '}\n', '\n', '//File: node_modules/liquidpledging/contracts/LiquidPledging.sol\n', 'pragma solidity ^0.4.11;\n', '\n', '/*\n', '    Copyright 2017, Jordi Baylina\n', '    Contributor: Adrià Massanet <adria@codecontext.io>\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '*/\n', '\n', '// Contract Imports\n', '\n', '\n', '/// @dev `LiquidPleding` allows for liquid pledging through the use of\n', '///  internal id structures and delegate chaining. All basic operations for\n', '///  handling liquid pledging are supplied as well as plugin features\n', '///  to allow for expanded functionality.\n', 'contract LiquidPledging is LiquidPledgingBase {\n', '\n', '\n', '//////\n', '// Constructor\n', '//////\n', '\n', '    /// @notice Basic constructor for LiquidPleding, also calls the\n', '    ///  LiquidPledgingBase contract\n', '    /// @dev This constructor  also calls the constructor \n', '    ///  for `LiquidPledgingBase`\n', '    /// @param _vault The vault where ETH backing this pledge is stored\n', '    function LiquidPledging(\n', '        address _vault,\n', '        address _escapeHatchCaller,\n', '        address _escapeHatchDestination\n', '    ) LiquidPledgingBase(_vault, _escapeHatchCaller, _escapeHatchDestination) {\n', '\n', '    }\n', '\n', '    /// @notice This is how value enters into the system which creates pledges;\n', '    ///  the token of value goes into the vault and the amount in the pledge\n', '    ///  relevant to this Giver without delegates is increased, and a normal\n', '    ///  transfer is done to the idReceiver\n', '    /// @param idGiver Identifier of the giver thats donating.\n', "    /// @param idReceiver To whom it's transfered. Can be the same giver,\n", '    ///  another giver, a delegate or a project.\n', '    function donate(uint64 idGiver, uint64 idReceiver) payable {\n', '        if (idGiver == 0) {\n', '            // default to 3 day commitTime\n', '            idGiver = addGiver("", "", 259200, ILiquidPledgingPlugin(0x0));\n', '        }\n', '\n', '        PledgeAdmin storage sender = findAdmin(idGiver);\n', '\n', '        checkAdminOwner(sender);\n', '\n', '        require(sender.adminType == PledgeAdminType.Giver);\n', '\n', '        uint amount = msg.value;\n', '\n', '        require(amount > 0);\n', '\n', '        vault.transfer(amount); // transfers the baseToken to the Vault\n', '        uint64 idPledge = findOrCreatePledge(\n', '            idGiver,\n', '            new uint64[](0), //what is new?\n', '            0,\n', '            0,\n', '            0,\n', '            PledgeState.Pledged\n', '        );\n', '\n', '\n', '        Pledge storage nTo = findPledge(idPledge);\n', '        nTo.amount += amount;\n', '\n', '        Transfer(0, idPledge, amount);\n', '\n', '        transfer(idGiver, idPledge, amount, idReceiver);\n', '    }\n', '\n', '\n', '    /// @notice Moves value between pledges\n', '    /// @param idSender ID of the giver, delegate or project admin that is \n', '    ///  transferring the funds from Pledge to Pledge; this admin must have \n', '    ///  permissions to move the value\n', "    /// @param idPledge Id of the pledge that's moving the value\n", "    /// @param amount Quantity of value that's being moved\n", '    /// @param idReceiver Destination of the value, can be a giver sending to \n', '    ///  a giver or a delegate, a delegate to another delegate or a project \n', '    ///  to pre-commit it to that project if called from a delegate,\n', '    ///  or to commit it to the project if called from the owner. \n', '    function transfer(\n', '        uint64 idSender,\n', '        uint64 idPledge,\n', '        uint amount,\n', '        uint64 idReceiver\n', '    )\n', '    {\n', '\n', '        idPledge = normalizePledge(idPledge);\n', '\n', '        Pledge storage p = findPledge(idPledge);\n', '        PledgeAdmin storage receiver = findAdmin(idReceiver);\n', '        PledgeAdmin storage sender = findAdmin(idSender);\n', '\n', '        checkAdminOwner(sender);\n', '        require(p.pledgeState == PledgeState.Pledged);\n', '\n', '        // If the sender is the owner\n', '        if (p.owner == idSender) {\n', '            if (receiver.adminType == PledgeAdminType.Giver) {\n', '                transferOwnershipToGiver(idPledge, amount, idReceiver);\n', '            } else if (receiver.adminType == PledgeAdminType.Project) {\n', '                transferOwnershipToProject(idPledge, amount, idReceiver);\n', '            } else if (receiver.adminType == PledgeAdminType.Delegate) {\n', '                idPledge = undelegate(\n', '                    idPledge,\n', '                    amount,\n', '                    p.delegationChain.length\n', '                );\n', '                appendDelegate(idPledge, amount, idReceiver);\n', '            } else {\n', '                assert(false);\n', '            }\n', '            return;\n', '        }\n', '\n', '        // If the sender is a delegate\n', '        uint senderDIdx = getDelegateIdx(p, idSender);\n', '        if (senderDIdx != NOTFOUND) {\n', '\n', '            // If the receiver is another giver\n', '            if (receiver.adminType == PledgeAdminType.Giver) {\n', '                // Only accept to change to the original giver to\n', '                // remove all delegates\n', '                assert(p.owner == idReceiver);\n', '                undelegate(idPledge, amount, p.delegationChain.length);\n', '                return;\n', '            }\n', '\n', '            // If the receiver is another delegate\n', '            if (receiver.adminType == PledgeAdminType.Delegate) {\n', '                uint receiverDIdx = getDelegateIdx(p, idReceiver);\n', '\n', '                // If the receiver is not in the delegate list\n', '                if (receiverDIdx == NOTFOUND) {\n', '                    idPledge = undelegate(\n', '                        idPledge,\n', '                        amount,\n', '                        p.delegationChain.length - senderDIdx - 1\n', '                    );\n', '                    appendDelegate(idPledge, amount, idReceiver);\n', '\n', '                // If the receiver is already part of the delegate chain and is\n', '                // after the sender, then all of the other delegates after the\n', '                // sender are removed and the receiver is appended at the\n', '                // end of the delegation chain\n', '                } else if (receiverDIdx > senderDIdx) {\n', '                    idPledge = undelegate(\n', '                        idPledge,\n', '                        amount,\n', '                        p.delegationChain.length - senderDIdx - 1\n', '                    );\n', '                    appendDelegate(idPledge, amount, idReceiver);\n', '\n', '                // If the receiver is already part of the delegate chain and is\n', '                // before the sender, then the sender and all of the other\n', '                // delegates after the RECEIVER are removed from the chain,\n', '                // this is interesting because the delegate is removed from the\n', '                // delegates that delegated to this delegate. Are there game theory\n', '                // issues? should this be allowed?\n', '                } else if (receiverDIdx <= senderDIdx) {\n', '                    undelegate(\n', '                        idPledge,\n', '                        amount,\n', '                        p.delegationChain.length - receiverDIdx - 1\n', '                    );\n', '                }\n', '                return;\n', '            }\n', '\n', '            // If the delegate wants to support a project, they remove all\n', '            // the delegates after them in the chain and choose a project\n', '            if (receiver.adminType == PledgeAdminType.Project) {\n', '                idPledge = undelegate(\n', '                    idPledge,\n', '                    amount,\n', '                    p.delegationChain.length - senderDIdx - 1\n', '                );\n', '                proposeAssignProject(idPledge, amount, idReceiver);\n', '                return;\n', '            }\n', '        }\n', '        assert(false);  // It is not the owner nor any delegate.\n', '    }\n', '\n', '    /// @notice This method is used to withdraw value from the system.\n', '    ///  This can be used by the givers withdraw any un-commited donations.\n', '    /// @param idPledge Id of the pledge that wants to be withdrawn.\n', '    /// @param amount Quantity of Ether that wants to be withdrawn.\n', '    function withdraw(uint64 idPledge, uint amount) {\n', '\n', '        idPledge = normalizePledge(idPledge);\n', '\n', '        Pledge storage p = findPledge(idPledge);\n', '\n', '        require(p.pledgeState == PledgeState.Pledged);\n', '\n', '        PledgeAdmin storage owner = findAdmin(p.owner);\n', '\n', '        checkAdminOwner(owner);\n', '\n', '        uint64 idNewPledge = findOrCreatePledge(\n', '            p.owner,\n', '            p.delegationChain,\n', '            0,\n', '            0,\n', '            p.oldPledge,\n', '            PledgeState.Paying\n', '        );\n', '\n', '        doTransfer(idPledge, idNewPledge, amount);\n', '\n', '        vault.authorizePayment(bytes32(idNewPledge), owner.addr, amount);\n', '    }\n', '\n', '    /// @notice Method called by the vault to confirm a payment.\n', '    /// @param idPledge Id of the pledge that wants to be withdrawn.\n', '    /// @param amount Quantity of Ether that wants to be withdrawn.\n', '    function confirmPayment(uint64 idPledge, uint amount) onlyVault {\n', '        Pledge storage p = findPledge(idPledge);\n', '\n', '        require(p.pledgeState == PledgeState.Paying);\n', '\n', '        uint64 idNewPledge = findOrCreatePledge(\n', '            p.owner,\n', '            p.delegationChain,\n', '            0,\n', '            0,\n', '            p.oldPledge,\n', '            PledgeState.Paid\n', '        );\n', '\n', '        doTransfer(idPledge, idNewPledge, amount);\n', '    }\n', '\n', '    /// @notice Method called by the vault to cancel a payment.\n', '    /// @param idPledge Id of the pledge that wants to be canceled for withdraw.\n', '    /// @param amount Quantity of Ether that wants to be rolled back.\n', '    function cancelPayment(uint64 idPledge, uint amount) onlyVault {\n', '        Pledge storage p = findPledge(idPledge);\n', '\n', '        require(p.pledgeState == PledgeState.Paying); //TODO change to revert\n', '\n', '        // When a payment is canceled, never is assigned to a project.\n', '        uint64 oldPledge = findOrCreatePledge(\n', '            p.owner,\n', '            p.delegationChain,\n', '            0,\n', '            0,\n', '            p.oldPledge,\n', '            PledgeState.Pledged\n', '        );\n', '\n', '        oldPledge = normalizePledge(oldPledge);\n', '\n', '        doTransfer(idPledge, oldPledge, amount);\n', '    }\n', '\n', '    /// @notice Method called to cancel this project.\n', '    /// @param idProject Id of the projct that wants to be canceled.\n', '    function cancelProject(uint64 idProject) {\n', '        PledgeAdmin storage project = findAdmin(idProject);\n', '        checkAdminOwner(project);\n', '        project.canceled = true;\n', '\n', '        CancelProject(idProject);\n', '    }\n', '\n', '    /// @notice Method called to cancel specific pledge.\n', '    /// @param idPledge Id of the pledge that should be canceled.\n', '    /// @param amount Quantity of Ether that wants to be rolled back.\n', '    function cancelPledge(uint64 idPledge, uint amount) {\n', '        idPledge = normalizePledge(idPledge);\n', '\n', '        Pledge storage p = findPledge(idPledge);\n', '        require(p.oldPledge != 0);\n', '\n', '        PledgeAdmin storage m = findAdmin(p.owner);\n', '        checkAdminOwner(m);\n', '\n', '        uint64 oldPledge = getOldestPledgeNotCanceled(p.oldPledge);\n', '        doTransfer(idPledge, oldPledge, amount);\n', '    }\n', '\n', '\n', '////////\n', '// Multi pledge methods\n', '////////\n', '\n', '    // @dev This set of functions makes moving a lot of pledges around much more\n', '    // efficient (saves gas) than calling these functions in series\n', '    \n', '    \n', '    /// Bit mask used for dividing pledge amounts in Multi pledge methods\n', '    uint constant D64 = 0x10000000000000000;\n', '\n', '    /// @notice `mTransfer` allows for multiple pledges to be transferred\n', '    ///  efficiently\n', '    /// @param idSender ID of the giver, delegate or project admin that is\n', '    ///  transferring the funds from Pledge to Pledge. This admin must have \n', '    ///  permissions to move the value\n', '    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\n', '    ///  using the D64 bitmask\n', '    /// @param idReceiver Destination of the value, can be a giver sending\n', '    ///  to a giver or a delegate or a delegate to another delegate or a\n', '    ///  project to pre-commit it to that project\n', '    function mTransfer(\n', '        uint64 idSender,\n', '        uint[] pledgesAmounts,\n', '        uint64 idReceiver\n', '    ) {\n', '        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n', '            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\n', '            uint amount = pledgesAmounts[i] / D64;\n', '\n', '            transfer(idSender, idPledge, amount, idReceiver);\n', '        }\n', '    }\n', '\n', '    /// @notice `mWithdraw` allows for multiple pledges to be\n', '    ///  withdrawn efficiently\n', '    /// @param pledgesAmounts An array of pledge amounts and IDs which are\n', '    ///  extrapolated using the D64 bitmask\n', '    function mWithdraw(uint[] pledgesAmounts) {\n', '        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n', '            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\n', '            uint amount = pledgesAmounts[i] / D64;\n', '\n', '            withdraw(idPledge, amount);\n', '        }\n', '    }\n', '\n', '    /// @notice `mConfirmPayment` allows for multiple pledges to be confirmed\n', '    ///  efficiently\n', '    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\n', '    ///  using the D64 bitmask\n', '    function mConfirmPayment(uint[] pledgesAmounts) {\n', '        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n', '            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\n', '            uint amount = pledgesAmounts[i] / D64;\n', '\n', '            confirmPayment(idPledge, amount);\n', '        }\n', '    }\n', '\n', '    /// @notice `mCancelPayment` allows for multiple pledges to be canceled\n', '    ///  efficiently\n', '    /// @param pledgesAmounts An array of pledge amounts and IDs which are extrapolated\n', '    ///  using the D64 bitmask\n', '    function mCancelPayment(uint[] pledgesAmounts) {\n', '        for (uint i = 0; i < pledgesAmounts.length; i++ ) {\n', '            uint64 idPledge = uint64( pledgesAmounts[i] & (D64-1) );\n', '            uint amount = pledgesAmounts[i] / D64;\n', '\n', '            cancelPayment(idPledge, amount);\n', '        }\n', '    }\n', '\n', '    /// @notice `mNormalizePledge` allows for multiple pledges to be\n', '    ///  normalized efficiently\n', '    /// @param pledges An array of pledge IDs\n', '    function mNormalizePledge(uint64[] pledges) {\n', '        for (uint i = 0; i < pledges.length; i++ ) {\n', '            normalizePledge( pledges[i] );\n', '        }\n', '    }\n', '\n', '////////\n', '// Private methods\n', '///////\n', '\n', '    /// @notice `transferOwnershipToProject` allows for the transfer of\n', '    ///  ownership to the project, but it can also be called by a project\n', "    ///  to un-delegate everyone by setting one's own id for the idReceiver\n", '    /// @param idPledge Id of the pledge to be transfered.\n', "    /// @param amount Quantity of value that's being transfered\n", '    /// @param idReceiver The new owner of the project (or self to un-delegate)\n', '    function transferOwnershipToProject(\n', '        uint64 idPledge,\n', '        uint amount,\n', '        uint64 idReceiver\n', '    ) internal {\n', '        Pledge storage p = findPledge(idPledge);\n', '\n', '        // Ensure that the pledge is not already at max pledge depth\n', '        // and the project has not been canceled\n', '        require(getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n', '        require(!isProjectCanceled(idReceiver));\n', '\n', '        uint64 oldPledge = findOrCreatePledge(\n', '            p.owner,\n', '            p.delegationChain,\n', '            0,\n', '            0,\n', '            p.oldPledge,\n', '            PledgeState.Pledged\n', '        );\n', '        uint64 toPledge = findOrCreatePledge(\n', '            idReceiver,                     // Set the new owner\n', '            new uint64[](0),                // clear the delegation chain\n', '            0,\n', '            0,\n', '            oldPledge,\n', '            PledgeState.Pledged\n', '        );\n', '        doTransfer(idPledge, toPledge, amount);\n', '    }   \n', '\n', '\n', '    /// @notice `transferOwnershipToGiver` allows for the transfer of\n', '    ///  value back to the Giver, value is placed in a pledged state\n', '    ///  without being attached to a project, delegation chain, or time line.\n', '    /// @param idPledge Id of the pledge to be transfered.\n', "    /// @param amount Quantity of value that's being transfered\n", '    /// @param idReceiver The new owner of the pledge\n', '    function transferOwnershipToGiver(\n', '        uint64 idPledge,\n', '        uint amount,\n', '        uint64 idReceiver\n', '    ) internal {\n', '        uint64 toPledge = findOrCreatePledge(\n', '            idReceiver,\n', '            new uint64[](0),\n', '            0,\n', '            0,\n', '            0,\n', '            PledgeState.Pledged\n', '        );\n', '        doTransfer(idPledge, toPledge, amount);\n', '    }\n', '\n', '    /// @notice `appendDelegate` allows for a delegate to be added onto the\n', '    ///  end of the delegate chain for a given Pledge.\n', '    /// @param idPledge Id of the pledge thats delegate chain will be modified.\n', "    /// @param amount Quantity of value that's being chained.\n", '    /// @param idReceiver The delegate to be added at the end of the chain\n', '    function appendDelegate(\n', '        uint64 idPledge,\n', '        uint amount,\n', '        uint64 idReceiver\n', '    ) internal {\n', '        Pledge storage p = findPledge(idPledge);\n', '\n', '        require(p.delegationChain.length < MAX_DELEGATES);\n', '        uint64[] memory newDelegationChain = new uint64[](\n', '            p.delegationChain.length + 1\n', '        );\n', '        for (uint i = 0; i<p.delegationChain.length; i++) {\n', '            newDelegationChain[i] = p.delegationChain[i];\n', '        }\n', '\n', '        // Make the last item in the array the idReceiver\n', '        newDelegationChain[p.delegationChain.length] = idReceiver;\n', '\n', '        uint64 toPledge = findOrCreatePledge(\n', '            p.owner,\n', '            newDelegationChain,\n', '            0,\n', '            0,\n', '            p.oldPledge,\n', '            PledgeState.Pledged\n', '        );\n', '        doTransfer(idPledge, toPledge, amount);\n', '    }\n', '\n', '    /// @notice `appendDelegate` allows for a delegate to be added onto the\n', '    ///  end of the delegate chain for a given Pledge.\n', '    /// @param idPledge Id of the pledge thats delegate chain will be modified.\n', "    /// @param amount Quantity of value that's shifted from delegates.\n", '    /// @param q Number (or depth) to remove as delegates\n', '    function undelegate(\n', '        uint64 idPledge,\n', '        uint amount,\n', '        uint q\n', '    ) internal returns (uint64){\n', '        Pledge storage p = findPledge(idPledge);\n', '        uint64[] memory newDelegationChain = new uint64[](\n', '            p.delegationChain.length - q\n', '        );\n', '        for (uint i=0; i<p.delegationChain.length - q; i++) {\n', '            newDelegationChain[i] = p.delegationChain[i];\n', '        }\n', '        uint64 toPledge = findOrCreatePledge(\n', '            p.owner,\n', '            newDelegationChain,\n', '            0,\n', '            0,\n', '            p.oldPledge,\n', '            PledgeState.Pledged\n', '        );\n', '        doTransfer(idPledge, toPledge, amount);\n', '\n', '        return toPledge;\n', '    }\n', '\n', '    /// @notice `proposeAssignProject` proposes the assignment of a pledge\n', '    ///  to a specific project.\n', '    /// @dev This function should potentially be named more specifically.\n', '    /// @param idPledge Id of the pledge that will be assigned.\n', '    /// @param amount Quantity of value this pledge leader would be assigned.\n', '    /// @param idReceiver The project this pledge will potentially \n', '    ///  be assigned to.\n', '    function proposeAssignProject(\n', '        uint64 idPledge,\n', '        uint amount,\n', '        uint64 idReceiver\n', '    ) internal {\n', '        Pledge storage p = findPledge(idPledge);\n', '\n', '        require(getPledgeLevel(p) < MAX_INTERPROJECT_LEVEL);\n', '        require(!isProjectCanceled(idReceiver));\n', '\n', '        uint64 toPledge = findOrCreatePledge(\n', '            p.owner,\n', '            p.delegationChain,\n', '            idReceiver,\n', '            uint64(getTime() + maxCommitTime(p)),\n', '            p.oldPledge,\n', '            PledgeState.Pledged\n', '        );\n', '        doTransfer(idPledge, toPledge, amount);\n', '    }\n', '\n', '    /// @notice `doTransfer` is designed to allow for pledge amounts to be \n', '    ///  shifted around internally.\n', '    /// @param from This is the Id from which value will be transfered.\n', '    /// @param to This is the Id that value will be transfered to.\n', '    /// @param _amount The amount of value that will be transfered.\n', '    function doTransfer(uint64 from, uint64 to, uint _amount) internal {\n', '        uint amount = callPlugins(true, from, to, _amount);\n', '        if (from == to) { \n', '            return;\n', '        }\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '        Pledge storage nFrom = findPledge(from);\n', '        Pledge storage nTo = findPledge(to);\n', '        require(nFrom.amount >= amount);\n', '        nFrom.amount -= amount;\n', '        nTo.amount += amount;\n', '\n', '        Transfer(from, to, amount);\n', '        callPlugins(false, from, to, amount);\n', '    }\n', '\n', '    /// @notice `normalizePledge` only affects pledges with the Pledged PledgeState\n', '    /// and does 2 things:\n', '    ///   #1: Checks if the pledge should be committed. This means that\n', '    ///       if the pledge has an intendedProject and it is past the\n', '    ///       commitTime, it changes the owner to be the proposed project\n', '    ///       (The UI will have to read the commit time and manually do what\n', '    ///       this function does to the pledge for the end user\n', '    ///       at the expiration of the commitTime)\n', '    ///\n', '    ///   #2: Checks to make sure that if there has been a cancellation in the\n', "    ///       chain of projects, the pledge's owner has been changed\n", '    ///       appropriately.\n', '    ///\n', '    /// This function can be called by anybody at anytime on any pledge.\n', '    /// In general it can be called to force the calls of the affected \n', '    /// plugins, which also need to be predicted by the UI\n', '    /// @param idPledge This is the id of the pledge that will be normalized\n', '    function normalizePledge(uint64 idPledge) returns(uint64) {\n', '\n', '        Pledge storage p = findPledge(idPledge);\n', '\n', "        // Check to make sure this pledge hasn't already been used \n", '        // or is in the process of being used\n', '        if (p.pledgeState != PledgeState.Pledged) {\n', '            return idPledge;\n', '        }\n', '\n', "        // First send to a project if it's proposed and committed\n", '        if ((p.intendedProject > 0) && ( getTime() > p.commitTime)) {\n', '            uint64 oldPledge = findOrCreatePledge(\n', '                p.owner,\n', '                p.delegationChain,\n', '                0,\n', '                0,\n', '                p.oldPledge,\n', '                PledgeState.Pledged\n', '            );\n', '            uint64 toPledge = findOrCreatePledge(\n', '                p.intendedProject,\n', '                new uint64[](0),\n', '                0,\n', '                0,\n', '                oldPledge,\n', '                PledgeState.Pledged\n', '            );\n', '            doTransfer(idPledge, toPledge, p.amount);\n', '            idPledge = toPledge;\n', '            p = findPledge(idPledge);\n', '        }\n', '\n', '        toPledge = getOldestPledgeNotCanceled(idPledge);\n', '        if (toPledge != idPledge) {\n', '            doTransfer(idPledge, toPledge, p.amount);\n', '        }\n', '\n', '        return toPledge;\n', '    }\n', '\n', '/////////////\n', '// Plugins\n', '/////////////\n', '\n', '    /// @notice `callPlugin` is used to trigger the general functions in the\n', '    ///  plugin for any actions needed before and after a transfer happens.\n', '    ///  Specifically what this does in relation to the plugin is something\n', '    ///  that largely depends on the functions of that plugin. This function\n', '    ///  is generally called in pairs, once before, and once after a transfer.\n', '    /// @param before This toggle determines whether the plugin call is occurring\n', '    ///  before or after a transfer.\n', '    /// @param adminId This should be the Id of the *trusted* individual\n', '    ///  who has control over this plugin.\n', '    /// @param fromPledge This is the Id from which value is being transfered.\n', '    /// @param toPledge This is the Id that value is being transfered to.\n', '    /// @param context The situation that is triggering the plugin. See plugin\n', '    ///  for a full description of contexts.\n', '    /// @param amount The amount of value that is being transfered.\n', '    function callPlugin(\n', '        bool before,\n', '        uint64 adminId,\n', '        uint64 fromPledge,\n', '        uint64 toPledge,\n', '        uint64 context,\n', '        uint amount\n', '    ) internal returns (uint allowedAmount) {\n', '\n', '        uint newAmount;\n', '        allowedAmount = amount;\n', '        PledgeAdmin storage admin = findAdmin(adminId);\n', '        // Checks admin has a plugin assigned and a non-zero amount is requested\n', '        if ((address(admin.plugin) != 0) && (allowedAmount > 0)) {\n', '            // There are two seperate functions called in the plugin.\n', '            // One is called before the transfer and one after\n', '            if (before) {\n', '                newAmount = admin.plugin.beforeTransfer(\n', '                    adminId,\n', '                    fromPledge,\n', '                    toPledge,\n', '                    context,\n', '                    amount\n', '                );\n', '                require(newAmount <= allowedAmount);\n', '                allowedAmount = newAmount;\n', '            } else {\n', '                admin.plugin.afterTransfer(\n', '                    adminId,\n', '                    fromPledge,\n', '                    toPledge,\n', '                    context,\n', '                    amount\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice `callPluginsPledge` is used to apply plugin calls to\n', '    ///  the delegate chain and the intended project if there is one.\n', '    ///  It does so in either a transferring or receiving context based\n', '    ///  on the `idPledge` and  `fromPledge` parameters.\n', '    /// @param before This toggle determines whether the plugin call is occuring\n', '    ///  before or after a transfer.\n', '    /// @param idPledge This is the Id of the pledge on which this plugin\n', '    ///  is being called.\n', '    /// @param fromPledge This is the Id from which value is being transfered.\n', '    /// @param toPledge This is the Id that value is being transfered to.\n', '    /// @param amount The amount of value that is being transfered.\n', '    function callPluginsPledge(\n', '        bool before,\n', '        uint64 idPledge,\n', '        uint64 fromPledge,\n', '        uint64 toPledge,\n', '        uint amount\n', '    ) internal returns (uint allowedAmount) {\n', '        // Determine if callPlugin is being applied in a receiving\n', '        // or transferring context\n', '        uint64 offset = idPledge == fromPledge ? 0 : 256;\n', '        allowedAmount = amount;\n', '        Pledge storage p = findPledge(idPledge);\n', '\n', '        // Always call the plugin on the owner\n', '        allowedAmount = callPlugin(\n', '            before,\n', '            p.owner,\n', '            fromPledge,\n', '            toPledge,\n', '            offset,\n', '            allowedAmount\n', '        );\n', '\n', '        // Apply call plugin to all delegates\n', '        for (uint64 i=0; i<p.delegationChain.length; i++) {\n', '            allowedAmount = callPlugin(\n', '                before,\n', '                p.delegationChain[i],\n', '                fromPledge,\n', '                toPledge,\n', '                offset + i+1,\n', '                allowedAmount\n', '            );\n', '        }\n', '\n', '        // If there is an intended project also call the plugin in\n', '        // either a transferring or receiving context based on offset\n', '        // on the intended project\n', '        if (p.intendedProject > 0) {\n', '            allowedAmount = callPlugin(\n', '                before,\n', '                p.intendedProject,\n', '                fromPledge,\n', '                toPledge,\n', '                offset + 255,\n', '                allowedAmount\n', '            );\n', '        }\n', '    }\n', '\n', '\n', '    /// @notice `callPlugins` calls `callPluginsPledge` once for the transfer\n', '    ///  context and once for the receiving context. The aggregated \n', '    ///  allowed amount is then returned.\n', '    /// @param before This toggle determines whether the plugin call is occurring\n', '    ///  before or after a transfer.\n', '    /// @param fromPledge This is the Id from which value is being transferred.\n', '    /// @param toPledge This is the Id that value is being transferred to.\n', '    /// @param amount The amount of value that is being transferred.\n', '    function callPlugins(\n', '        bool before,\n', '        uint64 fromPledge,\n', '        uint64 toPledge,\n', '        uint amount\n', '    ) internal returns (uint allowedAmount) {\n', '        allowedAmount = amount;\n', '\n', '        // Call the pledges plugins in the transfer context\n', '        allowedAmount = callPluginsPledge(\n', '            before,\n', '            fromPledge,\n', '            fromPledge,\n', '            toPledge,\n', '            allowedAmount\n', '        );\n', '\n', '        // Call the pledges plugins in the receive context\n', '        allowedAmount = callPluginsPledge(\n', '            before,\n', '            toPledge,\n', '            fromPledge,\n', '            toPledge,\n', '            allowedAmount\n', '        );\n', '    }\n', '\n', '/////////////\n', '// Test functions\n', '/////////////\n', '\n', '    /// @notice Basic helper function to return the current time\n', '    function getTime() internal returns (uint) {\n', '        return now;\n', '    }\n', '\n', '    // Event Delcerations\n', '    event Transfer(uint64 indexed from, uint64 indexed to, uint amount);\n', '    event CancelProject(uint64 indexed idProject);\n', '\n', '}\n', '\n', '//File: node_modules/minimetoken/contracts/Controlled.sol\n', 'pragma solidity ^0.4.18;\n', '\n', 'contract Controlled {\n', '    /// @notice The address of the controller is the only address that can call\n', '    ///  a function with this modifier\n', '    modifier onlyController { require(msg.sender == controller); _; }\n', '\n', '    address public controller;\n', '\n', '    function Controlled() public { controller = msg.sender;}\n', '\n', '    /// @notice Changes the controller of the contract\n', '    /// @param _newController The new controller of the contract\n', '    function changeController(address _newController) public onlyController {\n', '        controller = _newController;\n', '    }\n', '}\n', '\n', '//File: node_modules/minimetoken/contracts/TokenController.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '/// @dev The token controller contract must implement these functions\n', 'contract TokenController {\n', '    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n', '    /// @param _owner The address that sent the ether to create tokens\n', '    /// @return True if the ether is accepted, false if it throws\n', '    function proxyPayment(address _owner) public payable returns(bool);\n', '\n', '    /// @notice Notifies the controller about a token transfer allowing the\n', '    ///  controller to react if desired\n', '    /// @param _from The origin of the transfer\n', '    /// @param _to The destination of the transfer\n', '    /// @param _amount The amount of the transfer\n', '    /// @return False if the controller does not authorize the transfer\n', '    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\n', '\n', '    /// @notice Notifies the controller about an approval allowing the\n', '    ///  controller to react if desired\n', '    /// @param _owner The address that calls `approve()`\n', '    /// @param _spender The spender in the `approve()` call\n', '    /// @param _amount The amount in the `approve()` call\n', '    /// @return False if the controller does not authorize the approval\n', '    function onApprove(address _owner, address _spender, uint _amount) public\n', '        returns(bool);\n', '}\n', '\n', '//File: node_modules/minimetoken/contracts/MiniMeToken.sol\n', 'pragma solidity ^0.4.18;\n', '\n', '/*\n', '    Copyright 2016, Jordi Baylina\n', '\n', '    This program is free software: you can redistribute it and/or modify\n', '    it under the terms of the GNU General Public License as published by\n', '    the Free Software Foundation, either version 3 of the License, or\n', '    (at your option) any later version.\n', '\n', '    This program is distributed in the hope that it will be useful,\n', '    but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '    GNU General Public License for more details.\n', '\n', '    You should have received a copy of the GNU General Public License\n', '    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', ' */\n', '\n', '/// @title MiniMeToken Contract\n', '/// @author Jordi Baylina\n', "/// @dev This token contract's goal is to make it easy for anyone to clone this\n", "///  token using the token distribution at a given block, this will allow DAO's\n", '///  and DApps to upgrade their features in a decentralized manner without\n', '///  affecting the original token\n', '/// @dev It is ERC20 compliant, but still needs to under go further testing.\n', '\n', '\n', '\n', '\n', 'contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\n', '}\n', '\n', '/// @dev The actual token contract, the default controller is the msg.sender\n', '///  that deploys the contract, so usually this token will be deployed by a\n', '///  token controller contract, which Giveth will call a "Campaign"\n', 'contract MiniMeToken is Controlled {\n', '\n', "    string public name;                //The Token's name: e.g. DigixDAO Tokens\n", '    uint8 public decimals;             //Number of decimals of the smallest unit\n', '    string public symbol;              //An identifier: e.g. REP\n', "    string public version = 'MMT_0.2'; //An arbitrary versioning scheme\n", '\n', '\n', '    /// @dev `Checkpoint` is the structure that attaches a block number to a\n', '    ///  given value, the block number attached is the one that last changed the\n', '    ///  value\n', '    struct  Checkpoint {\n', '\n', '        // `fromBlock` is the block number that the value was generated from\n', '        uint128 fromBlock;\n', '\n', '        // `value` is the amount of tokens at a specific block number\n', '        uint128 value;\n', '    }\n', '\n', '    // `parentToken` is the Token address that was cloned to produce this token;\n', '    //  it will be 0x0 for a token that was not cloned\n', '    MiniMeToken public parentToken;\n', '\n', '    // `parentSnapShotBlock` is the block number from the Parent Token that was\n', '    //  used to determine the initial distribution of the Clone Token\n', '    uint public parentSnapShotBlock;\n', '\n', '    // `creationBlock` is the block number that the Clone Token was created\n', '    uint public creationBlock;\n', '\n', '    // `balances` is the map that tracks the balance of each address, in this\n', '    //  contract when the balance changes the block number that the change\n', '    //  occurred is also included in the map\n', '    mapping (address => Checkpoint[]) balances;\n', '\n', '    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    // Tracks the history of the `totalSupply` of the token\n', '    Checkpoint[] totalSupplyHistory;\n', '\n', '    // Flag that determines if the token is transferable or not.\n', '    bool public transfersEnabled;\n', '\n', '    // The factory used to create new clone tokens\n', '    MiniMeTokenFactory public tokenFactory;\n', '\n', '////////////////\n', '// Constructor\n', '////////////////\n', '\n', '    /// @notice Constructor to create a MiniMeToken\n', '    /// @param _tokenFactory The address of the MiniMeTokenFactory contract that\n', '    ///  will create the Clone token contracts, the token factory needs to be\n', '    ///  deployed first\n', '    /// @param _parentToken Address of the parent token, set to 0x0 if it is a\n', '    ///  new token\n', '    /// @param _parentSnapShotBlock Block of the parent token that will\n', '    ///  determine the initial distribution of the clone token, set to 0 if it\n', '    ///  is a new token\n', '    /// @param _tokenName Name of the new token\n', '    /// @param _decimalUnits Number of decimals of the new token\n', '    /// @param _tokenSymbol Token Symbol for the new token\n', '    /// @param _transfersEnabled If true, tokens will be able to be transferred\n', '    function MiniMeToken(\n', '        address _tokenFactory,\n', '        address _parentToken,\n', '        uint _parentSnapShotBlock,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol,\n', '        bool _transfersEnabled\n', '    ) public {\n', '        tokenFactory = MiniMeTokenFactory(_tokenFactory);\n', '        name = _tokenName;                                 // Set the name\n', '        decimals = _decimalUnits;                          // Set the decimals\n', '        symbol = _tokenSymbol;                             // Set the symbol\n', '        parentToken = MiniMeToken(_parentToken);\n', '        parentSnapShotBlock = _parentSnapShotBlock;\n', '        transfersEnabled = _transfersEnabled;\n', '        creationBlock = block.number;\n', '    }\n', '\n', '\n', '///////////////////\n', '// ERC20 Methods\n', '///////////////////\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint256 _amount) public returns (bool success) {\n', '        require(transfersEnabled);\n', '        return doTransfer(msg.sender, _to, _amount);\n', '    }\n', '\n', '    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n', '    ///  is approved by `_from`\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function transferFrom(address _from, address _to, uint256 _amount\n', '    ) public returns (bool success) {\n', '\n', '        // The controller of this contract can move tokens around at will,\n', '        //  this is important to recognize! Confirm that you trust the\n', '        //  controller of this contract, which in most situations should be\n', '        //  another open source smart contract or 0x0\n', '        if (msg.sender != controller) {\n', '            require(transfersEnabled);\n', '\n', '            // The standard ERC 20 transferFrom functionality\n', '            if (allowed[_from][msg.sender] < _amount) return false;\n', '            allowed[_from][msg.sender] -= _amount;\n', '        }\n', '        return doTransfer(_from, _to, _amount);\n', '    }\n', '\n', '    /// @dev This is the actual transfer function in the token contract, it can\n', '    ///  only be called by other functions in this contract.\n', '    /// @param _from The address holding the tokens being transferred\n', '    /// @param _to The address of the recipient\n', '    /// @param _amount The amount of tokens to be transferred\n', '    /// @return True if the transfer was successful\n', '    function doTransfer(address _from, address _to, uint _amount\n', '    ) internal returns(bool) {\n', '\n', '           if (_amount == 0) {\n', '               return true;\n', '           }\n', '\n', '           require(parentSnapShotBlock < block.number);\n', '\n', '           // Do not allow transfer to 0x0 or the token contract itself\n', '           require((_to != 0) && (_to != address(this)));\n', '\n', '           // If the amount being transfered is more than the balance of the\n', '           //  account the transfer returns false\n', '           var previousBalanceFrom = balanceOfAt(_from, block.number);\n', '           if (previousBalanceFrom < _amount) {\n', '               return false;\n', '           }\n', '\n', '           // Alerts the token controller of the transfer\n', '           if (isContract(controller)) {\n', '               require(TokenController(controller).onTransfer(_from, _to, _amount));\n', '           }\n', '\n', '           // First update the balance array with the new value for the address\n', '           //  sending the tokens\n', '           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n', '\n', '           // Then update the balance array with the new value for the address\n', '           //  receiving the tokens\n', '           var previousBalanceTo = balanceOfAt(_to, block.number);\n', '           require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n', '           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n', '\n', '           // An event to make the transfer easy to find on the blockchain\n', '           Transfer(_from, _to, _amount);\n', '\n', '           return true;\n', '    }\n', '\n', "    /// @param _owner The address that's balance is being requested\n", '    /// @return The balance of `_owner` at the current block\n', '    function balanceOf(address _owner) public constant returns (uint256 balance) {\n', '        return balanceOfAt(_owner, block.number);\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n', '    ///  its behalf. This is a modified version of the ERC20 approve function\n', '    ///  to be a little bit safer\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the approval was successful\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '        require(transfersEnabled);\n', '\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender,0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        // Alerts the token controller of the approve function call\n', '        if (isContract(controller)) {\n', '            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\n', '        }\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    /// @dev This function makes it easy to read the `allowed[]` map\n', '    /// @param _owner The address of the account that owns the token\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens of _owner that _spender is allowed\n', '    ///  to spend\n', '    function allowance(address _owner, address _spender\n', '    ) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\n', '    ///  its behalf, and then a function is triggered in the contract that is\n', '    ///  being approved, `_spender`. This allows users to use their tokens to\n', '    ///  interact with contracts in one function call instead of two\n', '    /// @param _spender The address of the contract able to transfer the tokens\n', '    /// @param _amount The amount of tokens to be approved for transfer\n', '    /// @return True if the function call was successful\n', '    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\n', '    ) public returns (bool success) {\n', '        require(approve(_spender, _amount));\n', '\n', '        ApproveAndCallFallBack(_spender).receiveApproval(\n', '            msg.sender,\n', '            _amount,\n', '            this,\n', '            _extraData\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /// @dev This function makes it easy to get the total number of tokens\n', '    /// @return The total number of tokens\n', '    function totalSupply() public constant returns (uint) {\n', '        return totalSupplyAt(block.number);\n', '    }\n', '\n', '\n', '////////////////\n', '// Query balance and totalSupply in History\n', '////////////////\n', '\n', '    /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @param _blockNumber The block number when the balance is queried\n', '    /// @return The balance at `_blockNumber`\n', '    function balanceOfAt(address _owner, uint _blockNumber) public constant\n', '        returns (uint) {\n', '\n', '        // These next few lines are used when the balance of the token is\n', '        //  requested before a check point was ever created for this token, it\n', '        //  requires that the `parentToken.balanceOfAt` be queried at the\n', '        //  genesis block for that token as this contains initial balance of\n', '        //  this token\n', '        if ((balances[_owner].length == 0)\n', '            || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n', '            } else {\n', '                // Has no parent\n', '                return 0;\n', '            }\n', '\n', '        // This will return the expected balance during normal situations\n', '        } else {\n', '            return getValueAt(balances[_owner], _blockNumber);\n', '        }\n', '    }\n', '\n', '    /// @notice Total amount of tokens at a specific `_blockNumber`.\n', '    /// @param _blockNumber The block number when the totalSupply is queried\n', '    /// @return The total amount of tokens at `_blockNumber`\n', '    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\n', '\n', '        // These next few lines are used when the totalSupply of the token is\n', '        //  requested before a check point was ever created for this token, it\n', '        //  requires that the `parentToken.totalSupplyAt` be queried at the\n', '        //  genesis block for this token as that contains totalSupply of this\n', '        //  token at this block number.\n', '        if ((totalSupplyHistory.length == 0)\n', '            || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '            if (address(parentToken) != 0) {\n', '                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n', '            } else {\n', '                return 0;\n', '            }\n', '\n', '        // This will return the expected totalSupply during normal situations\n', '        } else {\n', '            return getValueAt(totalSupplyHistory, _blockNumber);\n', '        }\n', '    }\n', '\n', '////////////////\n', '// Clone Token Method\n', '////////////////\n', '\n', '    /// @notice Creates a new clone token with the initial distribution being\n', '    ///  this token at `_snapshotBlock`\n', '    /// @param _cloneTokenName Name of the clone token\n', '    /// @param _cloneDecimalUnits Number of decimals of the smallest unit\n', '    /// @param _cloneTokenSymbol Symbol of the clone token\n', '    /// @param _snapshotBlock Block when the distribution of the parent token is\n', '    ///  copied to set the initial distribution of the new clone token;\n', '    ///  if the block is zero than the actual block, the current block is used\n', '    /// @param _transfersEnabled True if transfers are allowed in the clone\n', '    /// @return The address of the new MiniMeToken Contract\n', '    function createCloneToken(\n', '        string _cloneTokenName,\n', '        uint8 _cloneDecimalUnits,\n', '        string _cloneTokenSymbol,\n', '        uint _snapshotBlock,\n', '        bool _transfersEnabled\n', '        ) public returns(address) {\n', '        if (_snapshotBlock == 0) _snapshotBlock = block.number;\n', '        MiniMeToken cloneToken = tokenFactory.createCloneToken(\n', '            this,\n', '            _snapshotBlock,\n', '            _cloneTokenName,\n', '            _cloneDecimalUnits,\n', '            _cloneTokenSymbol,\n', '            _transfersEnabled\n', '            );\n', '\n', '        cloneToken.changeController(msg.sender);\n', '\n', '        // An event to make the token easy to find on the blockchain\n', '        NewCloneToken(address(cloneToken), _snapshotBlock);\n', '        return address(cloneToken);\n', '    }\n', '\n', '////////////////\n', '// Generate and destroy tokens\n', '////////////////\n', '\n', '    /// @notice Generates `_amount` tokens that are assigned to `_owner`\n', '    /// @param _owner The address that will be assigned the new tokens\n', '    /// @param _amount The quantity of tokens generated\n', '    /// @return True if the tokens are generated correctly\n', '    function generateTokens(address _owner, uint _amount\n', '    ) public onlyController returns (bool) {\n', '        uint curTotalSupply = totalSupply();\n', '        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n', '        uint previousBalanceTo = balanceOf(_owner);\n', '        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n', '        Transfer(0, _owner, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    /// @notice Burns `_amount` tokens from `_owner`\n', '    /// @param _owner The address that will lose the tokens\n', '    /// @param _amount The quantity of tokens to burn\n', '    /// @return True if the tokens are burned correctly\n', '    function destroyTokens(address _owner, uint _amount\n', '    ) onlyController public returns (bool) {\n', '        uint curTotalSupply = totalSupply();\n', '        require(curTotalSupply >= _amount);\n', '        uint previousBalanceFrom = balanceOf(_owner);\n', '        require(previousBalanceFrom >= _amount);\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n', '        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n', '        Transfer(_owner, 0, _amount);\n', '        return true;\n', '    }\n', '\n', '////////////////\n', '// Enable tokens transfers\n', '////////////////\n', '\n', '\n', '    /// @notice Enables token holders to transfer their tokens freely if true\n', '    /// @param _transfersEnabled True if transfers are allowed in the clone\n', '    function enableTransfers(bool _transfersEnabled) public onlyController {\n', '        transfersEnabled = _transfersEnabled;\n', '    }\n', '\n', '////////////////\n', '// Internal helper functions to query and set a value in a snapshot array\n', '////////////////\n', '\n', '    /// @dev `getValueAt` retrieves the number of tokens at a given block number\n', '    /// @param checkpoints The history of values being queried\n', '    /// @param _block The block number to retrieve the value at\n', '    /// @return The number of tokens being queried\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint _block\n', '    ) constant internal returns (uint) {\n', '        if (checkpoints.length == 0) return 0;\n', '\n', '        // Shortcut for the actual value\n', '        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n', '            return checkpoints[checkpoints.length-1].value;\n', '        if (_block < checkpoints[0].fromBlock) return 0;\n', '\n', '        // Binary search of the value in the array\n', '        uint min = 0;\n', '        uint max = checkpoints.length-1;\n', '        while (max > min) {\n', '            uint mid = (max + min + 1)/ 2;\n', '            if (checkpoints[mid].fromBlock<=_block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid-1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '    /// @dev `updateValueAtNow` used to update the `balances` map and the\n', '    ///  `totalSupplyHistory`\n', '    /// @param checkpoints The history of data being updated\n', '    /// @param _value The new number of tokens\n', '    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\n', '    ) internal  {\n', '        if ((checkpoints.length == 0)\n', '        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\n', '               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\n', '               newCheckPoint.fromBlock =  uint128(block.number);\n', '               newCheckPoint.value = uint128(_value);\n', '           } else {\n', '               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n', '               oldCheckPoint.value = uint128(_value);\n', '           }\n', '    }\n', '\n', '    /// @dev Internal function to determine if an address is a contract\n', '    /// @param _addr The address being queried\n', '    /// @return True if `_addr` is a contract\n', '    function isContract(address _addr) constant internal returns(bool) {\n', '        uint size;\n', '        if (_addr == 0) return false;\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return size>0;\n', '    }\n', '\n', '    /// @dev Helper function to return a min betwen the two uints\n', '    function min(uint a, uint b) pure internal returns (uint) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', "    /// @notice The fallback function: If the contract's controller has not been\n", '    ///  set to 0, then the `proxyPayment` method is called which relays the\n', '    ///  ether and creates tokens as described in the token controller contract\n', '    function () public payable {\n', '        require(isContract(controller));\n', '        require(TokenController(controller).proxyPayment.value(msg.value)(msg.sender));\n', '    }\n', '\n', '//////////\n', '// Safety Methods\n', '//////////\n', '\n', '    /// @notice This method can be used by the controller to extract mistakenly\n', '    ///  sent tokens to this contract.\n', '    /// @param _token The address of the token contract that you want to recover\n', '    ///  set to 0 in case you want to extract ether.\n', '    function claimTokens(address _token) public onlyController {\n', '        if (_token == 0x0) {\n', '            controller.transfer(this.balance);\n', '            return;\n', '        }\n', '\n', '        MiniMeToken token = MiniMeToken(_token);\n', '        uint balance = token.balanceOf(this);\n', '        token.transfer(controller, balance);\n', '        ClaimedTokens(_token, controller, balance);\n', '    }\n', '\n', '////////////////\n', '// Events\n', '////////////////\n', '    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n', '    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\n', '    event Approval(\n', '        address indexed _owner,\n', '        address indexed _spender,\n', '        uint256 _amount\n', '        );\n', '\n', '}\n', '\n', '\n', '////////////////\n', '// MiniMeTokenFactory\n', '////////////////\n', '\n', '/// @dev This contract is used to generate clone contracts from a contract.\n', '///  In solidity this is the way to create a contract from a contract of the\n', '///  same class\n', 'contract MiniMeTokenFactory {\n', '\n', '    /// @notice Update the DApp by creating a new token with new functionalities\n', '    ///  the msg.sender becomes the controller of this clone token\n', '    /// @param _parentToken Address of the token being cloned\n', '    /// @param _snapshotBlock Block of the parent token that will\n', '    ///  determine the initial distribution of the clone token\n', '    /// @param _tokenName Name of the new token\n', '    /// @param _decimalUnits Number of decimals of the new token\n', '    /// @param _tokenSymbol Token Symbol for the new token\n', '    /// @param _transfersEnabled If true, tokens will be able to be transferred\n', '    /// @return The address of the new token contract\n', '    function createCloneToken(\n', '        address _parentToken,\n', '        uint _snapshotBlock,\n', '        string _tokenName,\n', '        uint8 _decimalUnits,\n', '        string _tokenSymbol,\n', '        bool _transfersEnabled\n', '    ) public returns (MiniMeToken) {\n', '        MiniMeToken newToken = new MiniMeToken(\n', '            this,\n', '            _parentToken,\n', '            _snapshotBlock,\n', '            _tokenName,\n', '            _decimalUnits,\n', '            _tokenSymbol,\n', '            _transfersEnabled\n', '            );\n', '\n', '        newToken.changeController(msg.sender);\n', '        return newToken;\n', '    }\n', '}\n', '\n', '//File: contracts/LPPCampaign.sol\n', 'pragma solidity ^0.4.13;\n', '\n', '\n', '\n', '\n', '\n', '/// @title LPPCampaign\n', '/// @author perissology <perissology@protonmail.com>\n', '/// @notice The LPPCampaign contract is a plugin contract for liquidPledging,\n', '///  extending the functionality of a liquidPledging project. This contract\n', '///  prevents withdrawals from any pledges this contract is the owner of.\n', '///  This contract has 2 roles. The owner and a reviewer. The owner can transfer or cancel\n', '///  any pledges this contract owns. The reviewer can only cancel the pledges.\n', '///  If this contract is canceled, all pledges will be rolled back to the previous owner\n', '///  and will reject all future pledge transfers to the pledgeAdmin represented by this contract\n', 'contract LPPCampaign is Escapable, TokenController {\n', '    uint constant FROM_OWNER = 0;\n', '    uint constant FROM_PROPOSEDPROJECT = 255;\n', '    uint constant TO_OWNER = 256;\n', '    uint constant TO_PROPOSEDPROJECT = 511;\n', '\n', '    LiquidPledging public liquidPledging;\n', '    MiniMeToken public token;\n', '    bool public initPending;\n', '    uint64 public idProject;\n', '    address public reviewer;\n', '    address public newReviewer;\n', '\n', '    event GenerateTokens(address indexed liquidPledging, address addr, uint amount);\n', '\n', '    function LPPCampaign(\n', '        LiquidPledging _liquidPledging,\n', '        string tokenName,\n', '        string tokenSymbol,\n', '        address _escapeHatchCaller,\n', '        address _escapeHatchDestination\n', '    ) Escapable(_escapeHatchCaller, _escapeHatchDestination) public\n', '    {\n', '      require(msg.sender != tx.origin);\n', '      liquidPledging = _liquidPledging;\n', '      MiniMeTokenFactory tokenFactory = new MiniMeTokenFactory();\n', '      token = new MiniMeToken(tokenFactory, 0x0, 0, tokenName, 18, tokenSymbol, false);\n', '      initPending = true;\n', '    }\n', '\n', '    function init(\n', '        string name,\n', '        string url,\n', '        uint64 parentProject,\n', '        address _reviewer\n', '    ) {\n', '        require(initPending);\n', '        idProject = liquidPledging.addProject(name, url, address(this), parentProject, 0, ILiquidPledgingPlugin(this));\n', '        reviewer = _reviewer;\n', '        initPending = false;\n', '    }\n', '\n', '    modifier initialized() {\n', '      require(!initPending);\n', '      _;\n', '    }\n', '\n', '    modifier onlyReviewer() {\n', '        require(msg.sender == reviewer);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnerOrReviewer() {\n', '        require( msg.sender == owner || msg.sender == reviewer );\n', '        _;\n', '    }\n', '\n', '    function changeReviewer(address _newReviewer) public initialized onlyReviewer {\n', '        newReviewer = _newReviewer;\n', '    }\n', '\n', '    function acceptNewReviewer() public initialized {\n', '        require(newReviewer == msg.sender);\n', '        reviewer = newReviewer;\n', '        newReviewer = 0;\n', '    }\n', '\n', '    function beforeTransfer(\n', '        uint64 pledgeAdmin,\n', '        uint64 pledgeFrom,\n', '        uint64 pledgeTo,\n', '        uint64 context,\n', '        uint amount\n', '    ) external initialized returns (uint maxAllowed) {\n', '        require(msg.sender == address(liquidPledging));\n', '        var (, , , fromProposedProject , , , ) = liquidPledging.getPledge(pledgeFrom);\n', '        var (, , , , , , toPledgeState ) = liquidPledging.getPledge(pledgeTo);\n', '\n', '        // campaigns can not withdraw funds\n', '        if ( (context == TO_OWNER) && (toPledgeState != LiquidPledgingBase.PledgeState.Pledged) ) return 0;\n', '\n', '        // If this campaign is the proposed recipient of delegated funds or funds are being directly\n', '        // transferred to me, ensure that the campaign has not been canceled\n', '        if ( (context == TO_PROPOSEDPROJECT)\n', '            || ( (context == TO_OWNER) && (fromProposedProject != idProject) ))\n', '        {\n', '            if (isCanceled()) return 0;\n', '        }\n', '        return amount;\n', '    }\n', '\n', '    function afterTransfer(\n', '        uint64 pledgeAdmin,\n', '        uint64 pledgeFrom,\n', '        uint64 pledgeTo,\n', '        uint64 context,\n', '        uint amount\n', '    ) external initialized {\n', '      require(msg.sender == address(liquidPledging));\n', '      var (, , , , , , toPledgeState) = liquidPledging.getPledge(pledgeTo);\n', '      var (, fromOwner, , , , , ) = liquidPledging.getPledge(pledgeFrom);\n', '\n', '      // only issue tokens when pledge is committed to this campaign\n', '      if ( (context == TO_OWNER) &&\n', '              (toPledgeState == LiquidPledgingBase.PledgeState.Pledged)) {\n', '        var (, fromAddr , , , , , , ) = liquidPledging.getPledgeAdmin(fromOwner);\n', '\n', '        token.generateTokens(fromAddr, amount);\n', '        GenerateTokens(liquidPledging, fromAddr, amount);\n', '      }\n', '    }\n', '\n', '    function cancelCampaign() public initialized onlyOwnerOrReviewer {\n', '        require( !isCanceled() );\n', '\n', '        liquidPledging.cancelProject(idProject);\n', '    }\n', '\n', '    function transfer(uint64 idPledge, uint amount, uint64 idReceiver) public initialized onlyOwner {\n', '      require( !isCanceled() );\n', '\n', '      liquidPledging.transfer(idProject, idPledge, amount, idReceiver);\n', '    }\n', '\n', '    function isCanceled() public constant initialized returns (bool) {\n', '      return liquidPledging.isProjectCanceled(idProject);\n', '    }\n', '\n', '    // allows the owner to send any tx, similar to a multi-sig\n', '    // this is necessary b/c the campaign may receive dac/campaign tokens\n', '    // if they transfer a pledge they own to another dac/campaign.\n', '    // this allows the owner to participate in governance with the tokens\n', '    // it holds.\n', '    function sendTransaction(address destination, uint value, bytes data) public initialized onlyOwner {\n', '      require(destination.call.value(value)(data));\n', '    }\n', '\n', '////////////////\n', '// TokenController\n', '////////////////\n', '\n', '  /// @notice Called when `_owner` sends ether to the MiniMe Token contract\n', '  /// @param _owner The address that sent the ether to create tokens\n', '  /// @return True if the ether is accepted, false if it throws\n', '  function proxyPayment(address _owner) public payable initialized returns(bool) {\n', '    return false;\n', '  }\n', '\n', '  /// @notice Notifies the controller about a token transfer allowing the\n', '  ///  controller to react if desired\n', '  /// @param _from The origin of the transfer\n', '  /// @param _to The destination of the transfer\n', '  /// @param _amount The amount of the transfer\n', '  /// @return False if the controller does not authorize the transfer\n', '  function onTransfer(address _from, address _to, uint _amount) public initialized returns(bool) {\n', '    return false;\n', '  }\n', '\n', '  /// @notice Notifies the controller about an approval allowing the\n', '  ///  controller to react if desired\n', '  /// @param _owner The address that calls `approve()`\n', '  /// @param _spender The spender in the `approve()` call\n', '  /// @param _amount The amount in the `approve()` call\n', '  /// @return False if the controller does not authorize the approval\n', '  function onApprove(address _owner, address _spender, uint _amount) public initialized returns(bool) {\n', '    return false;\n', '  }\n', '}\n', '\n', '//File: contracts/LPPCampaignFactory.sol\n', 'pragma solidity ^0.4.13;\n', '\n', '\n', '\n', 'contract LPPCampaignFactory is Escapable {\n', '\n', '    function LPPCampaignFactory(address _escapeHatchCaller, address _escapeHatchDestination)\n', '        Escapable(_escapeHatchCaller, _escapeHatchDestination)\n', '    {\n', '    }\n', '\n', '    function deploy(\n', '        LiquidPledging liquidPledging,\n', '        string name,\n', '        string url,\n', '        uint64 parentProject,\n', '        address reviewer,\n', '        string tokenName,\n', '        string tokenSymbol,\n', '        address escapeHatchCaller,\n', '        address escapeHatchDestination\n', '  ) {\n', '        LPPCampaign campaign = new LPPCampaign(liquidPledging, tokenName, tokenSymbol, escapeHatchCaller, escapeHatchDestination);\n', '        campaign.init(name, url, parentProject, reviewer);\n', '        campaign.changeOwnership(msg.sender);\n', '    }\n', '}']