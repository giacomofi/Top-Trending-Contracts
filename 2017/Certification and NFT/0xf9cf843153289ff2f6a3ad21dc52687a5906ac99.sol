['pragma solidity ^0.4.15;\n', '\n', '// File: contracts/BTC.sol\n', '\n', '// Bitcoin transaction parsing library\n', '\n', '// Copyright 2016 rain <https://keybase.io/rain>\n', '//\n', '// Licensed under the Apache License, Version 2.0 (the "License");\n', '// you may not use this file except in compliance with the License.\n', '// You may obtain a copy of the License at\n', '//\n', '//      http://www.apache.org/licenses/LICENSE-2.0\n', '//\n', '// Unless required by applicable law or agreed to in writing, software\n', '// distributed under the License is distributed on an "AS IS" BASIS,\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '// See the License for the specific language governing permissions and\n', '// limitations under the License.\n', '\n', '// https://en.bitcoin.it/wiki/Protocol_documentation#tx\n', '//\n', '// Raw Bitcoin transaction structure:\n', '//\n', '// field     | size | type     | description\n', '// version   | 4    | int32    | transaction version number\n', '// n_tx_in   | 1-9  | var_int  | number of transaction inputs\n', '// tx_in     | 41+  | tx_in[]  | list of transaction inputs\n', '// n_tx_out  | 1-9  | var_int  | number of transaction outputs\n', '// tx_out    | 9+   | tx_out[] | list of transaction outputs\n', '// lock_time | 4    | uint32   | block number / timestamp at which tx locked\n', '//\n', '// Transaction input (tx_in) structure:\n', '//\n', '// field      | size | type     | description\n', '// previous   | 36   | outpoint | Previous output transaction reference\n', '// script_len | 1-9  | var_int  | Length of the signature script\n', '// sig_script | ?    | uchar[]  | Script for confirming transaction authorization\n', '// sequence   | 4    | uint32   | Sender transaction version\n', '//\n', '// OutPoint structure:\n', '//\n', '// field      | size | type     | description\n', '// hash       | 32   | char[32] | The hash of the referenced transaction\n', '// index      | 4    | uint32   | The index of this output in the referenced transaction\n', '//\n', '// Transaction output (tx_out) structure:\n', '//\n', '// field         | size | type     | description\n', '// value         | 8    | int64    | Transaction value (Satoshis)\n', '// pk_script_len | 1-9  | var_int  | Length of the public key script\n', '// pk_script     | ?    | uchar[]  | Public key as a Bitcoin script.\n', '//\n', '// Variable integers (var_int) can be encoded differently depending\n', '// on the represented value, to save space. Variable integers always\n', '// precede an array of a variable length data type (e.g. tx_in).\n', '//\n', '// Variable integer encodings as a function of represented value:\n', '//\n', '// value           | bytes  | format\n', '// <0xFD (253)     | 1      | uint8\n', '// <=0xFFFF (65535)| 3      | 0xFD followed by length as uint16\n', '// <=0xFFFF FFFF   | 5      | 0xFE followed by length as uint32\n', '// -               | 9      | 0xFF followed by length as uint64\n', '//\n', '// Public key scripts `pk_script` are set on the output and can\n', '// take a number of forms. The regular transaction script is\n', "// called 'pay-to-pubkey-hash' (P2PKH):\n", '//\n', '// OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n', '//\n', '// OP_x are Bitcoin script opcodes. The bytes representation (including\n', '// the 0x14 20-byte stack push) is:\n', '//\n', '// 0x76 0xA9 0x14 <pubKeyHash> 0x88 0xAC\n', '//\n', '// The <pubKeyHash> is the ripemd160 hash of the sha256 hash of\n', '// the public key, preceded by a network version byte. (21 bytes total)\n', '//\n', '// Network version bytes: 0x00 (mainnet); 0x6f (testnet); 0x34 (namecoin)\n', '//\n', '// The Bitcoin address is derived from the pubKeyHash. The binary form is the\n', '// pubKeyHash, plus a checksum at the end.  The checksum is the first 4 bytes\n', '// of the (32 byte) double sha256 of the pubKeyHash. (25 bytes total)\n', '// This is converted to base58 to form the publicly used Bitcoin address.\n', "// Mainnet P2PKH transaction scripts are to addresses beginning with '1'.\n", '//\n', "// P2SH ('pay to script hash') scripts only supply a script hash. The spender\n", '// must then provide the script that would allow them to redeem this output.\n', '// This allows for arbitrarily complex scripts to be funded using only a\n', '// hash of the script, and moves the onus on providing the script from\n', '// the spender to the redeemer.\n', '//\n', '// The P2SH script format is simple:\n', '//\n', '// OP_HASH160 <scriptHash> OP_EQUAL\n', '//\n', '// 0xA9 0x14 <scriptHash> 0x87\n', '//\n', '// The <scriptHash> is the ripemd160 hash of the sha256 hash of the\n', '// redeem script. The P2SH address is derived from the scriptHash.\n', '// Addresses are the scriptHash with a version prefix of 5, encoded as\n', "// Base58check. These addresses begin with a '3'.\n", '\n', '// parse a raw bitcoin transaction byte array\n', 'library BTC {\n', '    // Convert a variable integer into something useful and return it and\n', '    // the index to after it.\n', '    function parseVarInt(bytes txBytes, uint pos) returns (uint, uint) {\n', '        // the first byte tells us how big the integer is\n', '        var ibit = uint8(txBytes[pos]);\n', '        pos += 1;  // skip ibit\n', '\n', '        if (ibit < 0xfd) {\n', '            return (ibit, pos);\n', '        } else if (ibit == 0xfd) {\n', '            return (getBytesLE(txBytes, pos, 16), pos + 2);\n', '        } else if (ibit == 0xfe) {\n', '            return (getBytesLE(txBytes, pos, 32), pos + 4);\n', '        } else if (ibit == 0xff) {\n', '            return (getBytesLE(txBytes, pos, 64), pos + 8);\n', '        }\n', '    }\n', '    // convert little endian bytes to uint\n', '    function getBytesLE(bytes data, uint pos, uint bits) returns (uint) {\n', '        if (bits == 8) {\n', '            return uint8(data[pos]);\n', '        } else if (bits == 16) {\n', '            return uint16(data[pos])\n', '                 + uint16(data[pos + 1]) * 2 ** 8;\n', '        } else if (bits == 32) {\n', '            return uint32(data[pos])\n', '                 + uint32(data[pos + 1]) * 2 ** 8\n', '                 + uint32(data[pos + 2]) * 2 ** 16\n', '                 + uint32(data[pos + 3]) * 2 ** 24;\n', '        } else if (bits == 64) {\n', '            return uint64(data[pos])\n', '                 + uint64(data[pos + 1]) * 2 ** 8\n', '                 + uint64(data[pos + 2]) * 2 ** 16\n', '                 + uint64(data[pos + 3]) * 2 ** 24\n', '                 + uint64(data[pos + 4]) * 2 ** 32\n', '                 + uint64(data[pos + 5]) * 2 ** 40\n', '                 + uint64(data[pos + 6]) * 2 ** 48\n', '                 + uint64(data[pos + 7]) * 2 ** 56;\n', '        }\n', '    }\n', '    // scan the full transaction bytes and return the first two output\n', '    // values (in satoshis) and addresses (in binary)\n', '    function getFirstTwoOutputs(bytes txBytes)\n', '             returns (uint, bytes20, uint, bytes20)\n', '    {\n', '        uint pos;\n', '        uint[] memory input_script_lens = new uint[](2);\n', '        uint[] memory output_script_lens = new uint[](2);\n', '        uint[] memory script_starts = new uint[](2);\n', '        uint[] memory output_values = new uint[](2);\n', '        bytes20[] memory output_addresses = new bytes20[](2);\n', '\n', '        pos = 4;  // skip version\n', '\n', '        (input_script_lens, pos) = scanInputs(txBytes, pos, 0);\n', '\n', '        (output_values, script_starts, output_script_lens, pos) = scanOutputs(txBytes, pos, 2);\n', '\n', '        for (uint i = 0; i < 2; i++) {\n', '            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\n', '            output_addresses[i] = pkhash;\n', '        }\n', '\n', '        return (output_values[0], output_addresses[0],\n', '                output_values[1], output_addresses[1]);\n', '    }\n', '    // Check whether `btcAddress` is in the transaction outputs *and*\n', '    // whether *at least* `value` has been sent to it.\n', '        // Check whether `btcAddress` is in the transaction outputs *and*\n', '    // whether *at least* `value` has been sent to it.\n', '    function checkValueSent(bytes txBytes, bytes20 btcAddress, uint value)\n', '             returns (bool,uint)\n', '    {\n', '        uint pos = 4;  // skip version\n', '        (, pos) = scanInputs(txBytes, pos, 0);  // find end of inputs\n', '\n', '        // scan *all* the outputs and find where they are\n', '        var (output_values, script_starts, output_script_lens,) = scanOutputs(txBytes, pos, 0);\n', '\n', '        // look at each output and check whether it at least value to btcAddress\n', '        for (uint i = 0; i < output_values.length; i++) {\n', '            var pkhash = parseOutputScript(txBytes, script_starts[i], output_script_lens[i]);\n', '            if (pkhash == btcAddress && output_values[i] >= value) {\n', '                return (true,output_values[i]);\n', '            }\n', '        }\n', '    }\n', '    // scan the inputs and find the script lengths.\n', '    // return an array of script lengths and the end position\n', '    // of the inputs.\n', "    // takes a 'stop' argument which sets the maximum number of\n", '    // outputs to scan through. stop=0 => scan all.\n', '    function scanInputs(bytes txBytes, uint pos, uint stop)\n', '             returns (uint[], uint)\n', '    {\n', '        uint n_inputs;\n', '        uint halt;\n', '        uint script_len;\n', '\n', '        (n_inputs, pos) = parseVarInt(txBytes, pos);\n', '\n', '        if (stop == 0 || stop > n_inputs) {\n', '            halt = n_inputs;\n', '        } else {\n', '            halt = stop;\n', '        }\n', '\n', '        uint[] memory script_lens = new uint[](halt);\n', '\n', '        for (var i = 0; i < halt; i++) {\n', '            pos += 36;  // skip outpoint\n', '            (script_len, pos) = parseVarInt(txBytes, pos);\n', '            script_lens[i] = script_len;\n', '            pos += script_len + 4;  // skip sig_script, seq\n', '        }\n', '\n', '        return (script_lens, pos);\n', '    }\n', '    // scan the outputs and find the values and script lengths.\n', '    // return array of values, array of script lengths and the\n', '    // end position of the outputs.\n', "    // takes a 'stop' argument which sets the maximum number of\n", '    // outputs to scan through. stop=0 => scan all.\n', '    function scanOutputs(bytes txBytes, uint pos, uint stop)\n', '             returns (uint[], uint[], uint[], uint)\n', '    {\n', '        uint n_outputs;\n', '        uint halt;\n', '        uint script_len;\n', '\n', '        (n_outputs, pos) = parseVarInt(txBytes, pos);\n', '\n', '        if (stop == 0 || stop > n_outputs) {\n', '            halt = n_outputs;\n', '        } else {\n', '            halt = stop;\n', '        }\n', '\n', '        uint[] memory script_starts = new uint[](halt);\n', '        uint[] memory script_lens = new uint[](halt);\n', '        uint[] memory output_values = new uint[](halt);\n', '\n', '        for (var i = 0; i < halt; i++) {\n', '            output_values[i] = getBytesLE(txBytes, pos, 64);\n', '            pos += 8;\n', '\n', '            (script_len, pos) = parseVarInt(txBytes, pos);\n', '            script_starts[i] = pos;\n', '            script_lens[i] = script_len;\n', '            pos += script_len;\n', '        }\n', '\n', '        return (output_values, script_starts, script_lens, pos);\n', '    }\n', '    // Slice 20 contiguous bytes from bytes `data`, starting at `start`\n', '    function sliceBytes20(bytes data, uint start) returns (bytes20) {\n', '        uint160 slice = 0;\n', '        for (uint160 i = 0; i < 20; i++) {\n', '            slice += uint160(data[i + start]) << (8 * (19 - i));\n', '        }\n', '        return bytes20(slice);\n', '    }\n', '    // returns true if the bytes located in txBytes by pos and\n', '    // script_len represent a P2PKH script\n', '    function isP2PKH(bytes txBytes, uint pos, uint script_len) returns (bool) {\n', '        return (script_len == 25)           // 20 byte pubkeyhash + 5 bytes of script\n', '            && (txBytes[pos] == 0x76)       // OP_DUP\n', '            && (txBytes[pos + 1] == 0xa9)   // OP_HASH160\n', '            && (txBytes[pos + 2] == 0x14)   // bytes to push\n', '            && (txBytes[pos + 23] == 0x88)  // OP_EQUALVERIFY\n', '            && (txBytes[pos + 24] == 0xac); // OP_CHECKSIG\n', '    }\n', '    // returns true if the bytes located in txBytes by pos and\n', '    // script_len represent a P2SH script\n', '    function isP2SH(bytes txBytes, uint pos, uint script_len) returns (bool) {\n', '        return (script_len == 23)           // 20 byte scripthash + 3 bytes of script\n', '            && (txBytes[pos + 0] == 0xa9)   // OP_HASH160\n', '            && (txBytes[pos + 1] == 0x14)   // bytes to push\n', '            && (txBytes[pos + 22] == 0x87); // OP_EQUAL\n', '    }\n', '    // Get the pubkeyhash / scripthash from an output script. Assumes\n', '    // pay-to-pubkey-hash (P2PKH) or pay-to-script-hash (P2SH) outputs.\n', '    // Returns the pubkeyhash/ scripthash, or zero if unknown output.\n', '    function parseOutputScript(bytes txBytes, uint pos, uint script_len)\n', '             returns (bytes20)\n', '    {\n', '        if (isP2PKH(txBytes, pos, script_len)) {\n', '            return sliceBytes20(txBytes, pos + 3);\n', '        } else if (isP2SH(txBytes, pos, script_len)) {\n', '            return sliceBytes20(txBytes, pos + 2);\n', '        } else {\n', '            return;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/Ownable.sol\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '  address public owner1;\n', '  address public owner2;\n', '  address public owner3;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '    function Ownable1() {\n', '    owner1 = msg.sender;\n', '  }\n', '\n', '    function Ownable2() {\n', '    owner2 = msg.sender;\n', '  }\n', '\n', '    function Ownable3() {\n', '    owner3 = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender == owner)\n', '      _;\n', '  }\n', '\n', '  modifier onlyOwner1() {\n', '    if (msg.sender == owner1)\n', '      _;\n', '  }\n', '\n', '  modifier onlyOwner2() {\n', '    if (msg.sender == owner2)\n', '      _;\n', '  }\n', '\n', '  modifier onlyOwner3() {\n', '    if (msg.sender == owner3)\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '    if (newOwner != address(0)) owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/Pausable.sol\n', '\n', '/*\n', ' * Pausable\n', ' * Abstract contract that allows children to implement an\n', ' * emergency stop mechanism.\n', ' */\n', '\n', 'contract Pausable is Ownable {\n', '  bool public stopped;\n', '\n', '  modifier stopInEmergency {\n', '    if (stopped) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '  \n', '  modifier onlyInEmergency {\n', '    if (!stopped) {\n', '      throw;\n', '    }\n', '    _;\n', '  }\n', '\n', '  // called by the owner on emergency, triggers stopped state\n', '  function emergencyStop() external onlyOwner {\n', '    stopped = true;\n', '  }\n', '\n', '  // called by the owner on end of emergency, returns to normal state\n', '  function release() external onlyOwner onlyInEmergency {\n', '    stopped = false;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/StandardToken.sol\n', '\n', 'contract Token {\n', '    uint256 public totalSupply;\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '\n', '/*  ERC 20 token */\n', 'contract StandardToken is Token {\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success) {\n', '      if (balances[msg.sender] >= _value && _value > 0) {\n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n', '      if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success) {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '      return allowed[_owner][_spender];\n', '  }\n', '\n', '\n', '}\n', '\n', '// File: contracts/Utils.sol\n', '\n', 'contract Utils{\n', '\n', '\t//verifies the amount greater than zero\n', '\n', '\tmodifier greaterThanZero(uint256 _value){\n', '\t\trequire(_value>0);\n', '\t\t_;\n', '\t}\n', '\n', '\t///verifies an address\n', '\n', '\tmodifier validAddress(address _add){\n', '\t\trequire(_add!=0x0);\n', '\t\t_;\n', '\t}\n', '}\n', '\n', '// File: contracts/Crowdsale.sol\n', '\n', 'contract Crowdsale is StandardToken, Pausable, SafeMath, Utils{\n', '\tstring public constant name = "Mudra";\n', '\tstring public constant symbol = "MDR";\n', '\tuint256 public constant decimals = 18;\n', '\tstring public version = "1.0";\n', '\tbool public tradingStarted = false;\n', '\n', '    /**\n', '   * @dev modifier that throws if trading has not started yet\n', '   */\n', '   modifier hasStartedTrading() {\n', '   \trequire(tradingStarted);\n', '   \t_;\n', '   }\n', '  /**\n', '   * @dev Allows the owner to enable the trading. This can not be undone\n', '   */\n', '   function startTrading() only(finalOwner) {\n', '   \ttradingStarted = true;\n', '   }\n', '\n', '   function transfer(address _to, uint _value) hasStartedTrading returns (bool success) {super.transfer(_to, _value);}\n', '\n', '   function transferFrom(address _from, address _to, uint _value) hasStartedTrading returns (bool success) {super.transferFrom(_from, _to, _value);}\n', '\n', '   enum State{\n', '   \tInactive,\n', '   \tFunding,\n', '   \tSuccess,\n', '   \tFailure\n', '   }\n', '\n', '   modifier only(address allowed) {\n', '   \tif (msg.sender != allowed) throw;\n', '   \t_;\n', '   }\n', '\n', '   uint256 public investmentETH;\n', '   uint256 public investmentBTC;\n', '   mapping(uint256 => bool) transactionsClaimed;\n', '   uint256 public initialSupply;\n', '   address finalOwner;\n', '   address wallet;\n', '   uint256 public constant _totalSupply = 100 * (10**6) * 10 ** decimals; // 100M ~ 10 Crores\n', '   uint256 public fundingStartBlock; // crowdsale start block\n', '   uint256 public constant minBtcValue = 10000; // ~ approx 1$\n', '   uint256 public tokensPerEther = 460; // 1 ETH = 460 tokens\n', '   uint256 public tokensPerBTC = 115 * 10 ** 10 * 10 ** 2; // 1 btc = 11500 Tokens\n', '   uint256 public constant tokenCreationMax = 10 * (10**6) * 10 ** decimals; // 10M ~ 1 Crores\n', '   address[] public investors;\n', '\n', '   //displays number of uniq investors\n', '   function investorsCount() constant external returns(uint) { return investors.length; }\n', '\n', '   function Crowdsale(uint256 _fundingStartBlock,address owner,address _wallet){\n', '   \towner = msg.sender;\n', '   \tfundingStartBlock =_fundingStartBlock;\n', '   \ttotalSupply = _totalSupply;\n', '   \tinitialSupply = 0;\n', '   \tfinalOwner = owner;\n', '      wallet = _wallet;\n', '\n', '      //check configuration if something in setup is looking weird\n', '      if (\n', '       tokensPerEther == 0\n', '       || tokensPerBTC == 0\n', '       || finalOwner == 0x0\n', '       || wallet == 0x0\n', '       || fundingStartBlock == 0\n', '       || totalSupply == 0\n', '       || tokenCreationMax == 0\n', '       || fundingStartBlock <= block.number)\n', '      throw;\n', '\n', '   }\n', '\n', "   // don't just send ether to the contract expecting to get tokens\n", '   //function() { throw; }\n', '   ////@dev This function manages the Crowdsale State machine\n', '   ///We make it a function and do not assign to a variable//\n', '   ///so that no chance of stale variable\n', '   function getState() constant public returns(State){\n', '   \t///once we reach success lock the State\n', '   \tif(block.number<fundingStartBlock) return State.Inactive;\n', '   \telse if(block.number>fundingStartBlock && initialSupply<tokenCreationMax) return State.Funding;\n', '   \telse if (initialSupply >= tokenCreationMax) return State.Success;\n', '   \telse return State.Failure;\n', '   }\n', '\n', '   ///get total tokens in that address mapping\n', '   function getTokens(address addr) public returns(uint256){\n', '   \treturn balances[addr];\n', '   }\n', '\n', '   ///get the block number state\n', '   function getStateFunding() public returns (uint256){\n', '   \t// average 6000 blocks mined in 24 hrs\n', '   \tif(block.number<fundingStartBlock + 180000) return 20; // 1 month 20%\n', '   \telse if(block.number>=fundingStartBlock+ 180001 && block.number<fundingStartBlock + 270000) return 10; // next 15 days\n', '   \telse if(block.number>=fundingStartBlock + 270001 && block.number<fundingStartBlock + 36000) return 5; // next 15 days\n', '   \telse return 0;\n', '   }\n', '   ///a function using safemath to work with\n', '   ///the new function\n', '   function calNewTokens(uint256 tokens) returns (uint256){\n', '   \tuint256 disc = getStateFunding();\n', '   \ttokens = safeAdd(tokens,safeDiv(safeMul(tokens,disc),100));\n', '   \treturn tokens;\n', '   }\n', '\n', '   function() external payable stopInEmergency{\n', '   \t// Abort if not in Funding Active state.\n', '   \tif(getState() == State.Success) throw;\n', '   \tif (msg.value == 0) throw;\n', '   \tuint256 newCreatedTokens = safeMul(msg.value,tokensPerEther);\n', '   \tnewCreatedTokens = calNewTokens(newCreatedTokens);\n', '   \t///since we are creating tokens we need to increase the total supply\n', '   \tinitialSupply = safeAdd(initialSupply,newCreatedTokens);\n', '   \tif(initialSupply>tokenCreationMax) throw;\n', '      if (balances[msg.sender] == 0) investors.push(msg.sender);\n', '      investmentETH += msg.value;\n', '      balances[msg.sender] = safeAdd(balances[msg.sender],newCreatedTokens);\n', '      // Pocket the money\n', '      if(!wallet.send(msg.value)) throw;\n', '   }\n', '\n', '\n', '   ///token distribution initial function for the one in the exchanges\n', '   ///to be done only the owner can run this function\n', '   function tokenAssignExchange(address addr,uint256 val)\n', '   external\n', '   only(finalOwner)\n', '   {\n', '   \tif(getState() == State.Success) throw;\n', '   \tif (val == 0) throw;\n', '   \tuint256 newCreatedTokens = safeMul(val,tokensPerEther);\n', '   \tnewCreatedTokens = calNewTokens(newCreatedTokens);\n', '   \tinitialSupply = safeAdd(initialSupply,newCreatedTokens);\n', '   \tif(initialSupply>tokenCreationMax) throw;\n', '      if (balances[addr] == 0) investors.push(addr);\n', '      investmentETH += val;\n', '      balances[addr] = safeAdd(balances[addr],newCreatedTokens);\n', '   }\n', '\n', '   ///function to run when the transaction has been veified\n', '   function processTransaction(bytes txn, uint256 txHash,address addr,bytes20 btcaddr)\n', '   external\n', '   only(finalOwner)\n', '   returns (uint)\n', '   {\n', '   \tif(getState() == State.Success) throw;\n', '   \tvar (output1,output2,output3,output4) = BTC.getFirstTwoOutputs(txn);\n', '      if(transactionsClaimed[txHash]) throw;\n', '      var (a,b) = BTC.checkValueSent(txn,btcaddr,minBtcValue);\n', '      if(a){\n', '         transactionsClaimed[txHash] = true;\n', '         uint256 newCreatedTokens = safeMul(b,tokensPerBTC);\n', '         ///since we are creating tokens we need to increase the total supply\n', '         newCreatedTokens = calNewTokens(newCreatedTokens);\n', '         initialSupply = safeAdd(initialSupply,newCreatedTokens);\n', '         ///remember not to go off the LIMITS!!\n', '         if(initialSupply>tokenCreationMax) throw;\n', '         if (balances[addr] == 0) investors.push(addr);\n', '         investmentBTC += b;\n', '         balances[addr] = safeAdd(balances[addr],newCreatedTokens);\n', '         return 1;\n', '      }\n', '      else return 0;\n', '   }\n', '\n', '   ///change exchange rate\n', '   function changeExchangeRate(uint256 eth, uint256 btc)\n', '   external\n', '   only(finalOwner)\n', '   {\n', '    if(eth == 0 || btc == 0) throw;\n', '    tokensPerEther = eth;\n', '    tokensPerBTC = btc;\n', ' }\n', '\n', ' ///blacklist the users which are fraudulent\n', ' ///from getting any tokens\n', ' ///to do also refund just in cases\n', ' function blacklist(address addr)\n', ' external\n', ' only(finalOwner)\n', ' {\n', '    balances[addr] = 0;\n', ' }\n', '\n', '}']