['pragma solidity ^0.4.11;\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '/**\n', ' * @title Pausable\n', ' * @dev Base contract which allows children to implement an emergency stop mechanism.\n', ' */\n', 'contract Pausable is Ownable {\n', '  event Pause();\n', '  event Unpause();\n', '  bool public paused = false;\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!paused);\n', '    _;\n', '  }\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(paused);\n', '    _;\n', '  }\n', '  /**\n', '   * @dev called by the owner to pause, triggers stopped state\n', '   */\n', '  function pause() onlyOwner whenNotPaused public {\n', '    paused = true;\n', '    Pause();\n', '  }\n', '  /**\n', '   * @dev called by the owner to unpause, returns to normal state\n', '   */\n', '  function unpause() onlyOwner whenPaused public {\n', '    paused = false;\n', '    Unpause();\n', '  }\n', '}\n', '/**\n', ' * The QuantstampSale smart contract is used for selling QuantstampToken\n', ' * tokens (QSP). It does so by converting ETH received into a quantity of\n', ' * tokens that are transferred to the contributor via the ERC20-compatible\n', ' * transferFrom() function.\n', ' */\n', 'contract QuantstampSale is Pausable {\n', '    using SafeMath for uint256;\n', '    // The beneficiary is the future recipient of the funds\n', '    address public beneficiary;\n', '    // The crowdsale has a funding goal, cap, deadline, and minimum contribution\n', '    uint public fundingCap;\n', '    uint public minContribution;\n', '    bool public fundingCapReached = false;\n', '    bool public saleClosed = false;\n', '    // Whitelist data\n', '    mapping(address => bool) public registry;\n', '    // For each user, specifies the cap (in wei) that can be contributed for each tier\n', '    // Tiers are filled in the order 3, 2, 1, 4\n', '    mapping(address => uint256) public cap1;        // 100% bonus\n', '    mapping(address => uint256) public cap2;        // 40% bonus\n', '    mapping(address => uint256) public cap3;        // 20% bonus\n', '    mapping(address => uint256) public cap4;        // 0% bonus\n', '    // Stores the amount contributed for each tier for a given address\n', '    mapping(address => uint256) public contributed1;\n', '    mapping(address => uint256) public contributed2;\n', '    mapping(address => uint256) public contributed3;\n', '    mapping(address => uint256) public contributed4;\n', '    // Conversion rate by tier (QSP : ETHER)\n', '    uint public rate1 = 10000;\n', '    uint public rate2 = 7000;\n', '    uint public rate3 = 6000;\n', '    uint public rate4 = 5000;\n', '    // Time period of sale (UNIX timestamps)\n', '    uint public startTime;\n', '    uint public endTime;\n', '    // Keeps track of the amount of wei raised\n', '    uint public amountRaised;\n', '    // prevent certain functions from being recursively called\n', '    bool private rentrancy_lock = false;\n', '    // The token being sold\n', '    // QuantstampToken public tokenReward;\n', '    // A map that tracks the amount of wei contributed by address\n', '    mapping(address => uint256) public balanceOf;\n', '    // A map that tracks the amount of QSP tokens that should be allocated to each address\n', '    mapping(address => uint256) public tokenBalanceOf;\n', '    // Events\n', '    event CapReached(address _beneficiary, uint _amountRaised);\n', '    event FundTransfer(address _backer, uint _amount, bool _isContribution);\n', '    event RegistrationStatusChanged(address target, bool isRegistered, uint c1, uint c2, uint c3, uint c4);\n', '    // Modifiers\n', '    modifier beforeDeadline()   { require (currentTime() < endTime); _; }\n', '    // modifier afterDeadline()    { require (currentTime() >= endTime); _; } no longer used without fundingGoal\n', '    modifier afterStartTime()    { require (currentTime() >= startTime); _; }\n', '    modifier saleNotClosed()    { require (!saleClosed); _; }\n', '    modifier nonReentrant() {\n', '        require(!rentrancy_lock);\n', '        rentrancy_lock = true;\n', '        _;\n', '        rentrancy_lock = false;\n', '    }\n', '    /**\n', '     * Constructor for a crowdsale of QuantstampToken tokens.\n', '     *\n', '     * @param ifSuccessfulSendTo            the beneficiary of the fund\n', '     * @param fundingCapInEthers            the cap (maximum) size of the fund\n', '     * @param minimumContributionInWei      minimum contribution (in wei)\n', '     * @param start                         the start time (UNIX timestamp)\n', '     * @param durationInMinutes             the duration of the crowdsale in minutes\n', '     */\n', '    function QuantstampSale(\n', '        address ifSuccessfulSendTo,\n', '        uint fundingCapInEthers,\n', '        uint minimumContributionInWei,\n', '        uint start,\n', '        uint durationInMinutes\n', '        // address addressOfTokenUsedAsReward\n', '    ) {\n', '        require(ifSuccessfulSendTo != address(0) && ifSuccessfulSendTo != address(this));\n', '        //require(addressOfTokenUsedAsReward != address(0) && addressOfTokenUsedAsReward != address(this));\n', '        require(durationInMinutes > 0);\n', '        beneficiary = ifSuccessfulSendTo;\n', '        fundingCap = fundingCapInEthers * 1 ether;\n', '        minContribution = minimumContributionInWei;\n', '        startTime = start;\n', '        endTime = start + (durationInMinutes * 1 minutes);\n', '        // tokenReward = QuantstampToken(addressOfTokenUsedAsReward);\n', '    }\n', '    /**\n', '     * This function is called whenever Ether is sent to the\n', '     * smart contract. It can only be executed when the crowdsale is\n', '     * not paused, not closed, and before the deadline has been reached.\n', '     *\n', '     * This function will update state variables for whether or not the\n', '     * funding goal or cap have been reached. It also ensures that the\n', '     * tokens are transferred to the sender, and that the correct\n', '     * number of tokens are sent according to the current rate.\n', '     */\n', '    function () payable {\n', '        buy();\n', '    }\n', '    function buy ()\n', '        payable public\n', '        whenNotPaused\n', '        beforeDeadline\n', '        afterStartTime\n', '        saleNotClosed\n', '        nonReentrant\n', '    {\n', '        require(msg.value >= minContribution);\n', '        uint amount = msg.value;\n', '        // ensure that the user adheres to whitelist restrictions\n', '        require(registry[msg.sender]);\n', '        uint numTokens = computeTokenAmount(msg.sender, amount);\n', '        assert(numTokens > 0);\n', '        // update the total amount raised\n', '        amountRaised = amountRaised.add(amount);\n', '        require(amountRaised <= fundingCap);\n', "        // update the sender's balance of wei contributed\n", '        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\n', '        // add to the token balance of the sender\n', '        tokenBalanceOf[msg.sender] = tokenBalanceOf[msg.sender].add(numTokens);\n', '        FundTransfer(msg.sender, amount, true);\n', '        updateFundingCap();\n', '    }\n', '    /**\n', '    * Computes the amount of QSP that should be issued for the given transaction.\n', '    * Contribution tiers are filled up in the order 3, 2, 1, 4.\n', '    * @param addr      The wallet address of the contributor\n', '    * @param amount    Amount of wei for payment\n', '    */\n', '    function computeTokenAmount(address addr, uint amount) internal\n', '        returns (uint){\n', '        require(amount > 0);\n', '        uint r3 = cap3[addr].sub(contributed3[addr]);\n', '        uint r2 = cap2[addr].sub(contributed2[addr]);\n', '        uint r1 = cap1[addr].sub(contributed1[addr]);\n', '        uint r4 = cap4[addr].sub(contributed4[addr]);\n', '        uint numTokens = 0;\n', '        // cannot contribute more than the remaining sum\n', '        assert(amount <= r3.add(r2).add(r1).add(r4));\n', '        // Compute tokens for tier 3\n', '        if(r3 > 0){\n', '            if(amount <= r3){\n', '                contributed3[addr] = contributed3[addr].add(amount);\n', '                return rate3.mul(amount);\n', '            }\n', '            else{\n', '                numTokens = rate3.mul(r3);\n', '                amount = amount.sub(r3);\n', '                contributed3[addr] = cap3[addr];\n', '            }\n', '        }\n', '        // Compute tokens for tier 2\n', '        if(r2 > 0){\n', '            if(amount <= r2){\n', '                contributed2[addr] = contributed2[addr].add(amount);\n', '                return numTokens.add(rate2.mul(amount));\n', '            }\n', '            else{\n', '                numTokens = numTokens.add(rate2.mul(r2));\n', '                amount = amount.sub(r2);\n', '                contributed2[addr] = cap2[addr];\n', '            }\n', '        }\n', '        // Compute tokens for tier 1\n', '        if(r1 > 0){\n', '            if(amount <= r1){\n', '                contributed1[addr] = contributed1[addr].add(amount);\n', '                return numTokens.add(rate1.mul(amount));\n', '            }\n', '            else{\n', '                numTokens = numTokens.add(rate1.mul(r1));\n', '                amount = amount.sub(r1);\n', '                contributed1[addr] = cap1[addr];\n', '            }\n', '        }\n', '        // Compute tokens for tier 4 (overflow)\n', '        contributed4[addr] = contributed4[addr].add(amount);\n', '        return numTokens.add(rate4.mul(amount));\n', '    }\n', '    /**\n', '     * @dev Check if a contributor was at any point registered.\n', '     *\n', '     * @param contributor Address that will be checked.\n', '     */\n', '    function hasPreviouslyRegistered(address contributor)\n', '        internal\n', '        constant\n', '        onlyOwner returns (bool)\n', '    {\n', '        // if caps for this customer exist, then the customer has previously been registered\n', '        return (cap1[contributor].add(cap2[contributor]).add(cap3[contributor]).add(cap4[contributor])) > 0;\n', '    }\n', '    /*\n', '    * If the user was already registered, ensure that the new caps do not conflict previous contributions\n', '    *\n', '    * NOTE: cannot use SafeMath here, because it exceeds the local variable stack limit.\n', '    * Should be ok since it is onlyOwner, and conditionals should guard the subtractions from underflow.\n', '    */\n', '    function validateUpdatedRegistration(address addr, uint c1, uint c2, uint c3, uint c4)\n', '        internal\n', '        constant\n', '        onlyOwner returns(bool)\n', '    {\n', '        return (contributed3[addr] <= c3) && (contributed2[addr] <= c2)\n', '            && (contributed1[addr] <= c1) && (contributed4[addr] <= c4);\n', '    }\n', '    /**\n', '     * @dev Sets registration status of an address for participation.\n', '     *\n', '     * @param contributor Address that will be registered/deregistered.\n', '     * @param c1 The maximum amount of wei that the user can contribute in tier 1.\n', '     * @param c2 The maximum amount of wei that the user can contribute in tier 2.\n', '     * @param c3 The maximum amount of wei that the user can contribute in tier 3.\n', '     * @param c4 The maximum amount of wei that the user can contribute in tier 4.\n', '     */\n', '    function registerUser(address contributor, uint c1, uint c2, uint c3, uint c4)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(contributor != address(0));\n', '        // if the user was already registered ensure that the new caps do not contradict their current contributions\n', '        if(hasPreviouslyRegistered(contributor)){\n', '            require(validateUpdatedRegistration(contributor, c1, c2, c3, c4));\n', '        }\n', '        require(c1.add(c2).add(c3).add(c4) >= minContribution);\n', '        registry[contributor] = true;\n', '        cap1[contributor] = c1;\n', '        cap2[contributor] = c2;\n', '        cap3[contributor] = c3;\n', '        cap4[contributor] = c4;\n', '        RegistrationStatusChanged(contributor, true, c1, c2, c3, c4);\n', '    }\n', '     /**\n', '     * @dev Remove registration status of an address for participation.\n', '     *\n', '     * NOTE: if the user made initial contributions to the crowdsale,\n', '     *       this will not return the previously allotted tokens.\n', '     *\n', '     * @param contributor Address to be unregistered.\n', '     */\n', '    function deactivate(address contributor)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(registry[contributor]);\n', '        registry[contributor] = false;\n', '        RegistrationStatusChanged(contributor, false, cap1[contributor], cap2[contributor], cap3[contributor], cap4[contributor]);\n', '    }\n', '    /**\n', '     * @dev Re-registers an already existing contributor\n', '     *\n', '     * @param contributor Address to be unregistered.\n', '     */\n', '    function reactivate(address contributor)\n', '        public\n', '        onlyOwner\n', '    {\n', '        require(hasPreviouslyRegistered(contributor));\n', '        registry[contributor] = true;\n', '        RegistrationStatusChanged(contributor, true, cap1[contributor], cap2[contributor], cap3[contributor], cap4[contributor]);\n', '    }\n', '    /**\n', '     * @dev Sets registration statuses of addresses for participation.\n', '     * @param contributors Addresses that will be registered/deregistered.\n', '     * @param caps1 The maximum amount of wei that each user can contribute to cap1, in the same order as the addresses.\n', '     * @param caps2 The maximum amount of wei that each user can contribute to cap2, in the same order as the addresses.\n', '     * @param caps3 The maximum amount of wei that each user can contribute to cap3, in the same order as the addresses.\n', '     * @param caps4 The maximum amount of wei that each user can contribute to cap4, in the same order as the addresses.\n', '     */\n', '    function registerUsers(address[] contributors,\n', '                           uint[] caps1,\n', '                           uint[] caps2,\n', '                           uint[] caps3,\n', '                           uint[] caps4)\n', '        external\n', '        onlyOwner\n', '    {\n', '        // check that all arrays have the same length\n', '        require(contributors.length == caps1.length);\n', '        require(contributors.length == caps2.length);\n', '        require(contributors.length == caps3.length);\n', '        require(contributors.length == caps4.length);\n', '        for (uint i = 0; i < contributors.length; i++) {\n', '            registerUser(contributors[i], caps1[i], caps2[i], caps3[i], caps4[i]);\n', '        }\n', '    }\n', '    /**\n', '     * The owner can terminate the crowdsale at any time.\n', '     */\n', '    function terminate() external onlyOwner {\n', '        saleClosed = true;\n', '    }\n', '    /**\n', '     * The owner can allocate the specified amount of tokens from the\n', '     * crowdsale allowance to the recipient addresses.\n', '     *\n', '     * NOTE: be extremely careful to get the amounts correct, which\n', '     * are in units of wei and mini-QSP. Every digit counts.\n', '     *\n', '     * @param addrs          the recipient addresses\n', '     * @param weiAmounts     the amounts contributed in wei\n', '     * @param miniQspAmounts the amounts of tokens transferred in mini-QSP\n', '     */\n', '    function ownerAllocateTokensForList(address[] addrs, uint[] weiAmounts, uint[] miniQspAmounts)\n', '            external onlyOwner\n', '    {\n', '        require(addrs.length == weiAmounts.length);\n', '        require(addrs.length == miniQspAmounts.length);\n', '        for(uint i = 0; i < addrs.length; i++){\n', '            ownerAllocateTokens(addrs[i], weiAmounts[i], miniQspAmounts[i]);\n', '        }\n', '    }\n', '    /**\n', '     *\n', '     * The owner can allocate the specified amount of tokens from the\n', '     * crowdsale allowance to the recipient (_to).\n', '     *\n', '     *\n', '     *\n', '     * NOTE: be extremely careful to get the amounts correct, which\n', '     * are in units of wei and mini-QSP. Every digit counts.\n', '     *\n', '     * @param _to            the recipient of the tokens\n', '     * @param amountWei     the amount contributed in wei\n', '     * @param amountMiniQsp the amount of tokens transferred in mini-QSP\n', '     */\n', '    function ownerAllocateTokens(address _to, uint amountWei, uint amountMiniQsp)\n', '            onlyOwner nonReentrant\n', '    {\n', "        // don't allocate tokens for the admin\n", '        // require(tokenReward.adminAddr() != _to);\n', '        amountRaised = amountRaised.add(amountWei);\n', '        require(amountRaised <= fundingCap);\n', '        tokenBalanceOf[_to] = tokenBalanceOf[_to].add(amountMiniQsp);\n', '        balanceOf[_to] = balanceOf[_to].add(amountWei);\n', '        FundTransfer(_to, amountWei, true);\n', '        updateFundingCap();\n', '    }\n', '    /**\n', '     * The owner can call this function to withdraw the funds that\n', '     * have been sent to this contract for the crowdsale subject to\n', '     * the funding goal having been reached. The funds will be sent\n', '     * to the beneficiary specified when the crowdsale was created.\n', '     */\n', '    function ownerSafeWithdrawal() external onlyOwner nonReentrant {\n', '        uint balanceToSend = this.balance;\n', '        beneficiary.transfer(balanceToSend);\n', '        FundTransfer(beneficiary, balanceToSend, false);\n', '    }\n', '    /**\n', '     * Checks if the funding cap has been reached. If it has, then\n', '     * the CapReached event is triggered.\n', '     */\n', '    function updateFundingCap() internal {\n', '        assert (amountRaised <= fundingCap);\n', '        if (amountRaised == fundingCap) {\n', '            // Check if the funding cap has been reached\n', '            fundingCapReached = true;\n', '            saleClosed = true;\n', '            CapReached(beneficiary, amountRaised);\n', '        }\n', '    }\n', '    /**\n', '     * Returns the current time.\n', '     * Useful to abstract calls to "now" for tests.\n', '    */\n', '    function currentTime() constant returns (uint _currentTime) {\n', '        return now;\n', '    }\n', '}']