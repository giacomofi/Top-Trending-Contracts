['pragma solidity ^0.4.18;\n', '\n', '/**\n', ' * ICrowdsale\n', ' *\n', ' * Base crowdsale interface to manage the sale of \n', ' * an ERC20 token\n', ' *\n', ' * #created 09/09/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface ICrowdsale {\n', '\n', '    /**\n', '     * Returns true if the contract is currently in the presale phase\n', '     *\n', '     * @return True if in presale phase\n', '     */\n', '    function isInPresalePhase() public view returns (bool);\n', '\n', '\n', '    /**\n', '     * Returns true if the contract is currently in the ended stage\n', '     *\n', '     * @return True if ended\n', '     */\n', '    function isEnded() public view returns (bool);\n', '\n', '\n', '    /**\n', '     * Returns true if `_beneficiary` has a balance allocated\n', '     *\n', '     * @param _beneficiary The account that the balance is allocated for\n', '     * @param _releaseDate The date after which the balance can be withdrawn\n', '     * @return True if there is a balance that belongs to `_beneficiary`\n', '     */\n', '    function hasBalance(address _beneficiary, uint _releaseDate) public view returns (bool);\n', '\n', '\n', '    /** \n', '     * Get the allocated token balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated token balance will be retrieved\n', '     * @return The allocated token balance\n', '     */\n', '    function balanceOf(address _owner) public view returns (uint);\n', '\n', '\n', '    /** \n', '     * Get the allocated eth balance of `_owner`\n', '     * \n', '     * @param _owner The address from which the allocated eth balance will be retrieved\n', '     * @return The allocated eth balance\n', '     */\n', '    function ethBalanceOf(address _owner) public view returns (uint);\n', '\n', '\n', '    /** \n', '     * Get invested and refundable balance of `_owner` (only contributions during the ICO phase are registered)\n', '     * \n', '     * @param _owner The address from which the refundable balance will be retrieved\n', '     * @return The invested refundable balance\n', '     */\n', '    function refundableEthBalanceOf(address _owner) public view returns (uint);\n', '\n', '\n', '    /**\n', '     * Returns the rate and bonus release date\n', '     *\n', '     * @param _phase The phase to use while determining the rate\n', '     * @param _volume The amount wei used to determine what volume multiplier to use\n', '     * @return The rate used in `_phase` multiplied by the corresponding volume multiplier\n', '     */\n', '    function getRate(uint _phase, uint _volume) public view returns (uint);\n', '\n', '\n', '    /**\n', '     * Convert `_wei` to an amount in tokens using \n', '     * the `_rate`\n', '     *\n', '     * @param _wei amount of wei to convert\n', '     * @param _rate rate to use for the conversion\n', '     * @return Amount in tokens\n', '     */\n', '    function toTokens(uint _wei, uint _rate) public view returns (uint);\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     * \n', '     * Contracts can call the contribute() function instead\n', '     */\n', '    function () public payable;\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     *\n', '     * @return The accepted ether amount\n', '     */\n', '    function contribute() public payable returns (uint);\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to `_beneficiary`\n', '     *\n', '     * @param _beneficiary The account that receives the tokens\n', '     * @return The accepted ether amount\n', '     */\n', '    function contributeFor(address _beneficiary) public payable returns (uint);\n', '\n', '\n', '    /**\n', '     * Withdraw allocated tokens\n', '     */\n', '    function withdrawTokens() public;\n', '\n', '\n', '    /**\n', '     * Withdraw allocated ether\n', '     */\n', '    function withdrawEther() public;\n', '\n', '\n', '    /**\n', '     * Refund in the case of an unsuccessful crowdsale. The \n', '     * crowdsale is considered unsuccessful if minAmount was \n', '     * not raised before end of the crowdsale\n', '     */\n', '    function refund() public;\n', '}\n', '\n', '\n', '/**\n', ' * ICrowdsaleProxy\n', ' *\n', ' * #created 23/11/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'interface ICrowdsaleProxy {\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     * \n', '     * Contracts can call the contribute() function instead\n', '     */\n', '    function () public payable;\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     *\n', '     * @return The accepted ether amount\n', '     */\n', '    function contribute() public payable returns (uint);\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to `_beneficiary`\n', '     *\n', '     * @param _beneficiary The account that receives the tokens\n', '     * @return The accepted ether amount\n', '     */\n', '    function contributeFor(address _beneficiary) public payable returns (uint);\n', '}\n', '\n', '\n', '/**\n', ' * CrowdsaleProxy\n', ' *\n', ' * #created 22/11/2017\n', ' * #author Frank Bonnet\n', ' */\n', 'contract CrowdsaleProxy is ICrowdsaleProxy {\n', '\n', '    address public owner;\n', '    ICrowdsale public target;\n', '    \n', '\n', '    /**\n', '     * Deploy proxy\n', '     *\n', '     * @param _owner Owner of the proxy\n', '     * @param _target Target crowdsale\n', '     */\n', '    function CrowdsaleProxy(address _owner, address _target) public {\n', '        target = ICrowdsale(_target);\n', '        owner = _owner;\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive contribution and forward to the crowdsale\n', '     * \n', "     * This function requires that msg.sender is not a contract. This is required because it's \n", '     * not possible for a contract to specify a gas amount when calling the (internal) send() \n', '     * function. Solidity imposes a maximum amount of gas (2300 gas at the time of writing)\n', '     */\n', '    function () public payable {\n', '        target.contributeFor.value(msg.value)(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to the sender\n', '     *\n', '     * @return The accepted ether amount\n', '     */\n', '    function contribute() public payable returns (uint) {\n', '        target.contributeFor.value(msg.value)(msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * Receive ether and issue tokens to `_beneficiary`\n', '     *\n', '     * @param _beneficiary The account that receives the tokens\n', '     * @return The accepted ether amount\n', '     */\n', '    function contributeFor(address _beneficiary) public payable returns (uint) {\n', '        target.contributeFor.value(msg.value)(_beneficiary);\n', '    }\n', '}']