['/*\n', '\n', '  Copyright 2017 ZeroEx Intl.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', 'pragma solidity 0.4.18;\n', '\n', 'contract Token {\n', '\n', '    /// @notice send `_value` token to `_to` from `msg.sender`\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transfer(address _to, uint _value) public returns (bool) {}\n', '\n', '    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n', '    /// @param _from The address of the sender\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {}\n', '\n', '    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @param _value The amount of wei to be approved for transfer\n', '    /// @return Whether the approval was successful or not\n', '    function approve(address _spender, uint _value) public returns (bool) {}\n', '\n', '    /// @param _owner The address from which the balance will be retrieved\n', '    /// @return The balance\n', '    function balanceOf(address _owner) public view returns (uint) {}\n', '\n', '    /// @param _owner The address of the account owning tokens\n', '    /// @param _spender The address of the account able to transfer the tokens\n', '    /// @return Amount of remaining tokens allowed to spent\n', '    function allowance(address _owner, address _spender) public view returns (uint) {}\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', 'contract ERC20Token is Token {\n', '\n', '    function transfer(address _to, uint _value)\n', '        public\n', '        returns (bool) \n', '    {\n', '        require(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]); \n', '        balances[msg.sender] -= _value;\n', '        balances[_to] += _value;\n', '        Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public \n', '        returns (bool) \n', '    {\n', '        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]); \n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        allowed[_from][msg.sender] -= _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _value) \n', '        public\n', '        returns (bool)\n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function balanceOf(address _owner)\n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) \n', '        public\n', '        view\n', '        returns (uint)\n', '    {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint) balances;\n', '    mapping (address => mapping (address => uint)) allowed;\n', '    uint public totalSupply;\n', '}\n', '\n', 'contract UnlimitedAllowanceToken is ERC20Token {\n', '\n', '    uint constant MAX_UINT = 2**256 - 1;\n', '\n', '    /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited allowance. See https://github.com/ethereum/EIPs/issues/717\n', '    /// @param _from Address to transfer from.\n', '    /// @param _to Address to transfer to.\n', '    /// @param _value Amount to transfer.\n', '    /// @return Success of transfer.\n', '    function transferFrom(address _from, address _to, uint _value)\n', '        public \n', '        returns (bool) \n', '    {\n', '        uint allowance = allowed[_from][msg.sender];\n', '        require(balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to]); \n', '        balances[_to] += _value;\n', '        balances[_from] -= _value;\n', '        if (allowance < MAX_UINT) {\n', '            allowed[_from][msg.sender] -= _value;\n', '        }\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '}\n', '\n', 'contract SafeMath {\n', '    function safeMul(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function safeDiv(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function safeSub(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function safeAdd(uint a, uint b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        uint c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '\n', '    function max64(uint64 a, uint64 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min64(uint64 a, uint64 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min256(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return a < b ? a : b;\n', '    }\n', '}\n', '\n', 'contract EtherToken is UnlimitedAllowanceToken, SafeMath {\n', '\n', '    string constant public name = "Ether Token";\n', '    string constant public symbol = "WETH";\n', '    string constant public version = "2.0.0"; // version 1.0.0 deployed on mainnet at 0x2956356cd2a2bf3202f771f50d3d14a367b48070\n', '    uint8 constant public decimals = 18;\n', '\n', '    /// @dev Fallback to calling deposit when ether is sent directly to contract.\n', '    function()\n', '        public\n', '        payable\n', '    {\n', '        deposit();\n', '    }\n', '\n', '    /// @dev Buys tokens with Ether, exchanging them 1:1.\n', '    function deposit()\n', '        public\n', '        payable\n', '    {\n', '        balances[msg.sender] = safeAdd(balances[msg.sender], msg.value);\n', '        totalSupply = safeAdd(totalSupply, msg.value);\n', '        Transfer(address(0), msg.sender, msg.value);\n', '    }\n', '\n', '    /// @dev Sells tokens in exchange for Ether, exchanging them 1:1.\n', '    /// @param _value Number of tokens to sell.\n', '    function withdraw(uint _value)\n', '        public\n', '    {\n', '        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n', '        totalSupply = safeSub(totalSupply, _value);\n', '        require(msg.sender.send(_value));\n', '        Transfer(msg.sender, address(0), _value);\n', '    }\n', '}']