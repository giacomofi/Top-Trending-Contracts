['pragma solidity ^0.4.19;\n', '\n', 'contract Frikandel {\n', '    address creator = msg.sender; //King Frikandel\n', '\n', '    bool public Enabled = true; //Enable selling new Frikandellen\n', '    bool internal Killable = true; //Enabled when the contract can commit suicide (In case of a problem with the contract in its early development, we will set this to false later on)\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '\n', "    uint256 public totalSupply = 500000; //500k Frikandellen (y'all ready for some airdrop??)\n", '    uint256 public hardLimitICO = 750000; //Do not allow more then 750k frikandellen to exist, ever. (The ICO will not sell past this)\n', '\n', '    function name() public pure returns (string) { return "Frikandel"; } //Frikandellen zijn lekker\n', '    function symbol() public pure returns (string) { return "FRKNDL"; }\n', '    function decimals() public pure returns (uint8) { return 0; } //Imagine getting half of a frikandel, that must be pretty shitty... Lets not do that\n', '\n', '    function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; }\n', '\n', '\tfunction Frikandel() public {\n', '\t    balances[creator] = totalSupply; //Lets get this started :)\n', '\t}\n', '\t\n', '\tfunction Destroy() public {\n', '\t    if (msg.sender != creator) { revert(); } //yo what why\n', '\t    \n', '\t    if ((balances[creator] > 25000) && Killable == true){ //Only if the owner has more then 25k (indicating the airdrop was not finished yet) and the contract is killable.. Go ahead\n', '\t        selfdestruct(creator);\n', '\t    }\n', '\t}\n', '\t\n', '\tfunction DisableSuicide() public returns (bool success){\n', '\t    if (msg.sender != creator) { revert(); } //u dont control me\n', '\t    \n', '\t    Killable = false;\n', '\t    return true;\n', '\t}\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        if(msg.data.length < (2 * 32) + 4) { revert(); } //Something wrong yo\n', '\n', '        if (_value == 0) { return false; } //y try to transfer without specifying any???\n', '\n', '        uint256 fromBalance = balances[msg.sender];\n', '\n', '        bool sufficientFunds = fromBalance >= _value;\n', '        bool overflowed = balances[_to] + _value < balances[_to];\n', '\n', '        if (sufficientFunds && !overflowed) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            \n', '            Transfer(msg.sender, _to, _value);\n', '            return true; //Smakelijk!\n', '        } else { return false; } //Sorry man je hebt niet genoeg F R I K A N D E L L E N\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n', '        if(msg.data.length < (3 * 32) + 4) { revert(); } //Something wrong yo\n', '\n', '        if (_value == 0) { return false; }\n', '\n', '        uint256 fromBalance = balances[_from];\n', '        uint256 allowance = allowed[_from][msg.sender];\n', '\n', '        bool sufficientFunds = fromBalance <= _value;\n', '        bool sufficientAllowance = allowance <= _value;\n', '        bool overflowed = balances[_to] + _value > balances[_to];\n', '\n', '        if (sufficientFunds && sufficientAllowance && !overflowed) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            \n', '            allowed[_from][msg.sender] -= _value;\n', '            \n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) internal returns (bool success) {\n', '        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }\n', '        \n', '        allowed[msg.sender][_spender] = _value;\n', '        \n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function enable() public {\n', '        if (msg.sender != creator) { revert(); } //Bro stay of my contract\n', '        Enabled = true;\n', '    }\n', '\n', '    function disable() public {\n', '        if (msg.sender != creator) { revert(); } //BRO what did I tell you\n', '        Enabled = false;\n', '    }\n', '\n', '    function() payable public {\n', '        if (!Enabled) { revert(); }\n', "        if(balances[msg.sender]+(msg.value / 1e14) > 30000) { revert(); } //This would give you more then 30000 frikandellen, you can't buy from this account anymore through the ICO\n", '        if(totalSupply+(msg.value / 1e14) > hardLimitICO) { revert(); } //Hard limit on Frikandellen\n', '        if (msg.value == 0) { return; }\n', '\n', '        creator.transfer(msg.value);\n', '\n', '        uint256 tokensIssued = (msg.value / 1e14); //Since 1 token can be bought for 0.0001 ETH split the value (in Wei) through 1e14 to get the amount of tokens\n', '\n', '        totalSupply += tokensIssued;\n', '        balances[msg.sender] += tokensIssued;\n', '\n', '        Transfer(address(this), msg.sender, tokensIssued);\n', '    }\n', '}']