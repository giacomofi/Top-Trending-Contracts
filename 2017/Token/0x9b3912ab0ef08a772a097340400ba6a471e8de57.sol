['pragma solidity 0.4.18;\n', '\n', '/// @title LRC Foundation Icebox Program\n', '/// @author Daniel Wang - <daniel@loopring.org>.\n', '/// For more information, please visit https://loopring.org.\n', '\n', "/// Loopring Foundation's LRC (20% of total supply) will be locked during the first two yearsï¼Œ\n", '/// two years later, 1/24 of all locked LRC fund can be unlocked every month.\n', '\n', '/// @title ERC20 ERC20 Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <daniel@loopring.org>\n', 'contract ERC20 {\n', '    uint public totalSupply;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function balanceOf(address who) view public returns (uint256);\n', '    function allowance(address owner, address spender) view public returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '}\n', '\n', 'contract AirDropContract {\n', '\n', '    event AirDropped(address addr, uint amount);\n', '\n', '    function drop(\n', '        address tokenAddress,\n', '        uint amount,\n', '        uint minTokenBalance,\n', '        uint maxTokenBalance,\n', '        uint minEthBalance,\n', '        uint maxEthBalance,\n', '        address[] recipients) public {\n', '\n', '        require(tokenAddress != 0x0);\n', '        require(amount > 0);\n', '        require(maxTokenBalance >= minTokenBalance);\n', '        require(maxEthBalance >= minEthBalance);\n', '\n', '        ERC20 token = ERC20(tokenAddress);\n', '\n', '        uint balance = token.balanceOf(msg.sender);\n', '        uint allowance = token.allowance(msg.sender, address(this));\n', '        uint available = balance > allowance ? allowance : balance;\n', '\n', '        for (uint i = 0; i < recipients.length; i++) {\n', '            require(available >= amount);\n', '            address recipient = recipients[i];\n', '            if (isQualitifiedAddress(\n', '                token,\n', '                recipient,\n', '                minTokenBalance,\n', '                maxTokenBalance,\n', '                minEthBalance,\n', '                maxEthBalance\n', '            )) {\n', '                available -= amount;\n', '                require(token.transferFrom(msg.sender, recipient, amount));\n', '\n', '                AirDropped(recipient, amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function isQualitifiedAddress(\n', '        ERC20 token,\n', '        address addr,\n', '        uint minTokenBalance,\n', '        uint maxTokenBalance,\n', '        uint minEthBalance,\n', '        uint maxEthBalance\n', '        )\n', '        public\n', '        view\n', '        returns (bool result)\n', '    {\n', '        result = addr != 0x0 && addr != msg.sender && !isContract(addr);\n', '\n', '        uint ethBalance = addr.balance;\n', '        uint tokenBbalance = token.balanceOf(addr);\n', '\n', '        result = result && (ethBalance>= minEthBalance &&\n', '            ethBalance <= maxEthBalance &&\n', '            tokenBbalance >= minTokenBalance &&\n', '            tokenBbalance <= maxTokenBalance);\n', '    }\n', '\n', '    function isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    function () payable public {\n', '        revert();\n', '    }\n', '}']