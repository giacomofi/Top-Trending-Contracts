['pragma solidity ^0.4.13; \n', 'contract Owned { \n', '    address public owner;\n', '    function Owned() {\n', '      owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '      require(msg.sender == owner);\n', '      _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) onlyOwner {\n', '      owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract Token {\n', '    /* Public variables of the token */ \n', '    string public name; \n', '    string public symbol; \n', '    uint8 public decimals; \n', '    uint256 public totalSupply;      \n', '    /* This creates an array with all balances */    \n', '    mapping (address => uint256) public balanceOf;\n', '  \n', '  /* This generates a public event on the blockchain that will notify clients */\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  /* This notifies clients about the amount burnt */\n', '  event Burn(address indexed from, uint256 value);\n', '\n', '  /* Initializes contract with initial supply tokens to the creator of the contract */\n', '  function Token(\n', '      uint256 initialSupply,\n', '      string tokenName,\n', '      uint8 decimalUnits,\n', '      string tokenSymbol\n', '      ) {\n', '      balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n', '      totalSupply = initialSupply;                        // Update total supply\n', '      name = tokenName;                                   // Set the name for display purposes\n', '      symbol = tokenSymbol;                               // Set the symbol for display purposes\n', '      decimals = decimalUnits;                            // Amount of decimals for display purposes      \n', '  }\n', '\n', '  /* Internal transfer, only can be called by this contract */\n', '  function _transfer(address _from, address _to, uint _value) internal {\n', '      require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '      require (balanceOf[_from] >= _value);                // Check if the sender has enough\n', '      require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n', '      balanceOf[_from] -= _value;                         // Subtract from the sender\n', '      balanceOf[_to] += _value;                            // Add the same to the recipient\n', '      Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /// @notice Send `_value` tokens to `_to` from your account\n', '  /// @param _to The address of the recipient\n', '  /// @param _value the amount to send\n', '  function transfer(address _to, uint256 _value) {       \n', '      _transfer(msg.sender, _to, _value);\n', '  }\n', '    \n', '  /// @notice Remove `_value` tokens from the system irreversibly\n', '  /// @param _value the amount of money to burn\n', '  function burn(uint256 _value) returns (bool success) {\n', '      require (balanceOf[msg.sender] >= _value);            // Check if the sender has enough\n', '      balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n', '      totalSupply -= _value;                                // Updates totalSupply\n', '      Burn(msg.sender, _value);\n', '      return true;\n', '  } \n', '}\n', '\n', 'contract BiteduToken is Owned, Token {  \n', '  mapping (address => bool) public frozenAccount;\n', '\n', '  /* This generates a public event on the blockchain that will notify clients */\n', '  event FrozenFunds(address target, bool frozen);\n', '\n', '  /* Initializes contract with initial supply tokens to the creator of the contract */\n', '  function BiteduToken() Token (29000000, "BITEDU", 0, "BTEU") {\n', '      \n', '  }\n', '\n', ' /* Internal transfer, only can be called by this contract */\n', '  function _transfer(address _from, address _to, uint _value) internal {      \n', '      require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '      require (balanceOf[_from] >= _value);                // Check if the sender has enough\n', '      require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n', '      require(!frozenAccount[_from]);                     // Check if sender is frozen\n', '      require(!frozenAccount[_to]);                       // Check if recipient is frozen\n', '      balanceOf[_from] -= _value;                         // Subtract from the sender\n', '      balanceOf[_to] += _value;                           // Add the same to the recipient      \n', '      Transfer(_from, _to, _value);\n', '  }\n', '\n', '  /* Internal transfer, only can be called by this contract */\n', '  function _transferFrom(address _from, address _to, uint256 _value) internal {            \n', '      require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n', '      require (balanceOf[_from] >= _value);                // Check if the sender has enough\n', '      require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n', '      require(!frozenAccount[_from]);                     // Check if sender is frozen\n', '      require(!frozenAccount[_to]);                       // Check if recipient is frozen\n', '      balanceOf[_from] -= _value;                         // Subtract from the sender\n', '      balanceOf[_to] += _value;                           // Add the same to the recipient         \n', '      Transfer(_from, _to, _value);\n', '  }\n', '  /// @notice Send `_value` tokens to `_to` in behalf of `_from`\n', '  /// @param _from The address of the sender\n', '  /// @param _to The address of the recipient\n', '  /// @param _value the amount to send\n', '  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {                   \n', '      _transferFrom(_from, _to, _value);\n', '      return true;\n', '  }\n', '  /// @notice Create `mintedAmount` tokens and send it to `target`\n', '  /// @param target Address to receive the tokens\n', '  /// @param mintedAmount the amount of tokens it will receive\n', '  function mintToken(address target, uint256 mintedAmount) onlyOwner {\n', '      balanceOf[target] += mintedAmount;\n', '      totalSupply += mintedAmount;\n', '      Transfer(0, this, mintedAmount);\n', '      Transfer(this, target, mintedAmount);\n', '  }\n', '  /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n', '  /// @param target Address to be frozen\n', '  /// @param freeze either to freeze it or not\n', '  function freezeAccount(address target, bool freeze) onlyOwner {\n', '      frozenAccount[target] = freeze;\n', '      FrozenFunds(target, freeze);\n', '  }  \n', '   \n', '}']