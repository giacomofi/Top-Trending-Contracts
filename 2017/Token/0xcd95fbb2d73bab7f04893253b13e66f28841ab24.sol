['pragma solidity ^0.4.15;\n', '\n', 'contract owned \n', '{\n', '\taddress public owner;\n', '\n', '\tfunction owned() public\n', '\t{\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tfunction changeOwner(address newOwner) public onlyOwner \n', '\t{\n', '\t\towner = newOwner;\n', '\t}\n', '\n', '\tmodifier onlyOwner \n', '\t{\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '}\n', '\n', 'contract ERC20 {\n', '\tfunction totalSupply() public constant returns (uint totalTokenCount);\n', '\tfunction balanceOf(address _owner) public constant returns (uint balance);\n', '\tfunction transfer(address _to, uint _value) public returns (bool success);\n', '\tfunction transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '\tfunction approve(address _spender, uint _value) public returns (bool success);\n', '\tfunction allowance(address _owner, address _spender) public constant returns (uint remaining);\n', '\tevent Transfer(address indexed _from, address indexed _to, uint _value);\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '\n', 'contract GamblicaCoin is ERC20, owned \n', '{\n', '\tstring public constant symbol = "GMBC";\n', '\tstring public constant name = "Gamblica Coin";\n', '\tuint8 public constant decimals = 18;\n', '\n', '\tuint256 _totalSupply = 0;\n', '\t\n', '\tevent Burned(address backer, uint _value);\n', ' \n', '\t// Balances for each account\n', '\tmapping(address => uint256) balances;\n', ' \n', '\t// Owner of account approves the transfer of an amount to another account\n', '\tmapping(address => mapping (address => uint256)) allowed;\n', '\n', '\taddress public crowdsale;\n', '\n', '\tfunction changeCrowdsale(address newCrowdsale) public onlyOwner \n', '\t{\n', '\t\tcrowdsale = newCrowdsale;\n', '\t}\n', '\n', '\tmodifier onlyOwnerOrCrowdsale \n', '\t{\n', '\t\trequire(msg.sender == owner || msg.sender == crowdsale);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) \n', '\t{\n', '\t\tuint256 z = _x + _y;\n', '\t\tassert(z >= _x);\n', '\t\treturn z;\n', '\t}\n', '\n', '\tfunction safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) \n', '\t{\n', '\t\tassert(_x >= _y);\n', '\t\treturn _x - _y;\n', '\t}\n', '\t\n', '\tfunction totalSupply() public constant returns (uint256 totalTokenCount) \n', '\t{\n', '\t\treturn _totalSupply;\n', '\t}\n', ' \n', '\t// What is the balance of a particular account?\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance) \n', '\t{\n', '\t\treturn balances[_owner];\n', '\t}\n', '\n', ' \n', "\t// Transfer the balance from owner's account to another account\n", '\tfunction transfer(address _to, uint256 _amount) public returns (bool success) \n', '\t{\n', '\t\tif (balances[msg.sender] >= _amount \n', '\t\t\t&& _amount > 0\n', '\t\t\t&& balances[_to] + _amount > balances[_to]\n', '\t\t\t) \n', '\t\t{\n', '\t\t\tbalances[msg.sender] -= _amount;\n', '\t\t\tbalances[_to] += _amount;\n', '\t\t\tTransfer(msg.sender, _to, _amount);\n', '\t\t\treturn true;\n', '\t\t} else {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', ' \n', '\t// Send _value amount of tokens from address _from to address _to\n', '\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '\t// tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '\t// fees in sub-currencies; the command should fail unless the _from account has\n', '\t// deliberately authorized the sender of the message via some mechanism; we propose\n', '\t// these standardized APIs for approval:\n', '\tfunction transferFrom(\n', '\t\taddress _from,\n', '\t\taddress _to,\n', '\t\tuint256 _amount\n', '\t) public returns (bool success) \n', '\t{\n', '\t\tif (balances[_from] >= _amount\n', '\t\t\t&& allowed[_from][msg.sender] >= _amount\n', '\t\t\t&& _amount > 0\n', '\t\t\t&& balances[_to] + _amount > balances[_to] \n', '\t\t\t)\n', '\t\t{\n', '\t\t\tbalances[_from] -= _amount;\n', '\t\t\tallowed[_from][msg.sender] -= _amount;\n', '\t\t\tbalances[_to] += _amount;\n', '\t\t\tTransfer(_from, _to, _amount);\n', '\t\t\treturn true;\n', '\t\t} else {\n', '\t\t\trevert();\n', '\t\t}\n', '\t}\n', ' \n', '\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '\t// If this function is called again it overwrites the current allowance with _value.\n', '\tfunction approve(address _spender, uint256 _amount) public returns (bool success) \n', '\t{\n', '\t\tallowed[msg.sender][_spender] = _amount;\n', '\t\tApproval(msg.sender, _spender, _amount);\n', '\t\treturn true;\n', '\t}\n', ' \n', '\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) \n', '\t{\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '\tfunction send(address target, uint256 mintedAmount) public onlyOwnerOrCrowdsale \n', '\t{\n', '\t\trequire(mintedAmount > 0);\n', '\n', '\t\tbalances[target] = safeAdd(balances[target], mintedAmount);\n', '\t\t_totalSupply = safeAdd(_totalSupply, mintedAmount);\n', '\t\tTransfer(msg.sender, target, mintedAmount);\n', '\t}\n', '\n', '\tfunction burn(address target, uint256 burnedAmount) public onlyOwnerOrCrowdsale\n', '\t{\n', '\t\trequire(burnedAmount > 0);\n', '\n', '\t\tif (balances[target] >= burnedAmount)\n', '\t\t{\n', '\t\t\tbalances[target] -= burnedAmount;\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tburnedAmount = balances[target];\n', '\t\t\tbalances[target] = 0;\n', '\t\t}\n', '\n', '\t\t_totalSupply = safeSub(_totalSupply, burnedAmount);\n', '\t\tBurned(target, burnedAmount);\n', '\t}\n', '}']