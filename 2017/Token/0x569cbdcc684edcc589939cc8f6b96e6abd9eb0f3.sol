['contract SafeMath {\n', '    uint256 constant public MAX_UINT256 =\n', '    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', ' \n', '    function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x > MAX_UINT256 - y) throw;\n', '        return x + y;\n', '    }\n', ' \n', '    function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (x < y) throw;\n', '        return x - y;\n', '    }\n', ' \n', '    function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) {\n', '        if (y == 0) return 0;\n', '        if (x > MAX_UINT256 / y) throw;\n', '        return x * y;\n', '    }\n', '}\n', '\n', 'contract ERC223ReceivingContract {\n', '     \n', '    struct iGn {\n', '        address sender;\n', '        uint value;\n', '        bytes data;\n', '        bytes4 sig;\n', '    }\n', '    \n', '      function tokenFallback(address _from, uint _value, bytes _data){\n', '      iGn memory ignite;\n', '      ignite.sender = _from;\n', '      ignite.value = _value;\n', '      ignite.data = _data;\n', '      uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24);\n', '      ignite.sig = bytes4(u);\n', ' \n', '    }\n', '}\n', '\n', 'contract iGnite is SafeMath { \n', '\n', '    string public name;\n', '    bytes32 public symbol;\n', '    uint8 public decimals;\n', '    uint256 public rewardPerBlockPerAddress;\n', '    uint256 public totalGenesisAddresses;\n', '    address public genesisCallerAddress;\n', '    uint256 public genesisBlockCount;\n', '    uint256 private minedBlocks;\n', '    uint256 private iGnited;\n', '    uint256 private genesisSupplyPerAddress;\n', '    uint256 private totalMaxAvailableAmount;\n', '    uint256 private availableAmount;\n', '    uint256 private availableBalance;\n', '    uint256 private balanceOfAddress;\n', '    uint256 private genesisSupply;\n', '    uint256 private _totalSupply;\n', '   \n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => uint) balances; //balances\n', '    mapping(address => bool) public genesisAddress;\n', '    mapping (address => mapping (address => uint)) internal _allowances;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Burn(address indexed from, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function iGnite() {\n', '\n', '        genesisSupplyPerAddress = 10000000000; //10000\n', '        genesisBlockCount = 4498200; \n', '        rewardPerBlockPerAddress = 135;\n', '        totalGenesisAddresses = 1000;\n', '        genesisSupply = genesisSupplyPerAddress * totalGenesisAddresses; \n', '\n', '        genesisCallerAddress = 0x0000000000000000000000000000000000000000;\n', '    }\n', '\n', '    function currentBlock() constant returns (uint256 blockNumber)\n', '    {\n', '        return block.number;\n', '    }\n', '\n', '    function blockDiff() constant returns (uint256 blockNumber)\n', '    {\n', '        return block.number - genesisBlockCount;\n', '    }\n', '\n', '    function assignGenesisAddresses(address[] _address) public returns (bool success)\n', '    {\n', '        if (block.number <= 4538447) \n', '        { \n', '            if (msg.sender == genesisCallerAddress)\n', '            {\n', '                for (uint i = 0; i < _address.length; i++)\n', '                {\n', '                    balanceOf[_address[i]] = genesisSupplyPerAddress;\n', '                    genesisAddress[_address[i]] = true;\n', '                }\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    \n', '\n', '    function balanceOf(address _address) constant returns (uint256 Balance) //how much?\n', '    {\n', '        if (genesisAddress[_address]) {\n', '            minedBlocks = block.number - genesisBlockCount;\n', '\n', '            if (minedBlocks >= 75000000) return balanceOf[_address]; //app. 2052\n', '\n', '            availableAmount = rewardPerBlockPerAddress * minedBlocks;\n', '            availableBalance = balanceOf[_address] + availableAmount;\n', '\n', '            return availableBalance;\n', '        }\n', '        else\n', '            return balanceOf[_address];\n', '    }\n', '\n', '    function name() constant returns (string _name)\n', '    {\n', '        name = "iGnite";\n', '        return name;\n', '    }\n', '    \n', '    function symbol() constant returns (bytes32 _symbol)\n', '    {\n', '        symbol = "iGn";\n', '        return symbol;\n', '    }\n', '    \n', '    function decimals() constant returns (uint8 _decimals)\n', '    {\n', '        decimals = 6;\n', '        return decimals;\n', '    }\n', '    \n', '    function totalSupply() constant returns (uint256 totalSupply)\n', '    {\n', '        minedBlocks = block.number - genesisBlockCount;\n', '        availableAmount = rewardPerBlockPerAddress * minedBlocks;\n', '        iGnited = availableAmount * totalGenesisAddresses;\n', '        return iGnited + genesisSupply;\n', '    }\n', '    \n', '    function minedTotalSupply() constant returns (uint256 minedBlocks)\n', '    {\n', '        minedBlocks = block.number - genesisBlockCount;\n', '        availableAmount = rewardPerBlockPerAddress * minedBlocks;\n', '        return availableAmount * totalGenesisAddresses;\n', '    }\n', '\n', '    function initialiGnSupply() constant returns (uint256 maxSupply)  \n', '    {\n', '        return genesisSupplyPerAddress * totalGenesisAddresses;\n', '    }\n', '\n', '   \n', '    //burn tokens\n', '    function burn(uint256 _value) public returns(bool success) {\n', '        \n', '        //get sum\n', '        minedBlocks = block.number - genesisBlockCount;\n', '        availableAmount = rewardPerBlockPerAddress * minedBlocks;\n', '        iGnited = availableAmount * totalGenesisAddresses;\n', '        _totalSupply = iGnited + genesisSupply;\n', '        \n', '        //burn time\n', '        require(balanceOf[msg.sender] >= _value);\n', '        balanceOf[msg.sender] -= _value;\n', '        _totalSupply -= _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }//\n', '\n', '    function assignGenesisCallerAddress(address _caller) public returns(bool success)\n', '    {\n', '        if (genesisCallerAddress != 0x0000000000000000000000000000000000000000) return false;\n', '\n', '        genesisCallerAddress = _caller;\n', '\n', '        return true;\n', '    }\n', '    \n', '    function transfer(address _to, uint _value) public returns (bool) {\n', '        if (_value > 0 && _value <= balanceOf[msg.sender] && !isContract(_to)) {\n', '            balanceOf[msg.sender] -= _value;\n', '            balanceOf[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function transfer(address _to, uint _value, bytes _data) public returns (bool) {\n', '        if (_value > 0 && _value <= balanceOf[msg.sender] && isContract(_to)) {\n', '            balanceOf[msg.sender] -= _value;\n', '            balanceOf[_to] += _value;\n', '            ERC223ReceivingContract _contract = ERC223ReceivingContract(_to);\n', '                _contract.tokenFallback(msg.sender, _value, _data);\n', '            Transfer(msg.sender, _to, _value, _data);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function isContract(address _addr) returns (bool) {\n', '        uint codeSize;\n', '        assembly {\n', '            codeSize := extcodesize(_addr)\n', '        }\n', '        return codeSize > 0;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n', '        if (_allowances[_from][msg.sender] > 0 && _value > 0 && _allowances[_from][msg.sender] >= _value &&\n', '            balanceOf[_from] >= _value) {\n', '            balanceOf[_from] -= _value;\n', '            balanceOf[_to] += _value;\n', '            _allowances[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function approve(address _spender, uint _value) public returns (bool) {\n', '        _allowances[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    function allowance(address _owner, address _spender) public constant returns (uint) {\n', '        return _allowances[_owner][_spender];\n', '    }\n', '}']