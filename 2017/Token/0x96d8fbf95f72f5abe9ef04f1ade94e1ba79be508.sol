['pragma solidity ^0.4.18;\n', '\n', 'pragma solidity ^0.4.18;\n', '\n', 'contract EtherealFoundationOwned {\n', '\taddress private Owner;\n', '    \n', '\tfunction IsOwner(address addr) view public returns(bool)\n', '\t{\n', '\t    return Owner == addr;\n', '\t}\n', '\t\n', '\tfunction TransferOwner(address newOwner) public onlyOwner\n', '\t{\n', '\t    Owner = newOwner;\n', '\t}\n', '\t\n', '\tfunction EtherealFoundationOwned() public\n', '\t{\n', '\t    Owner = msg.sender;\n', '\t}\n', '\t\n', '\tfunction Terminate() public onlyOwner\n', '\t{\n', '\t    selfdestruct(Owner);\n', '\t}\n', '\t\n', '\tmodifier onlyOwner(){\n', '        require(msg.sender == Owner);\n', '        _;\n', '    }\n', '}\n', '\n', 'contract GiftzNetworkToken is EtherealFoundationOwned {\n', '    string public constant CONTRACT_NAME = "GiftzNetworkToken";\n', '    string public constant CONTRACT_VERSION = "A";\n', '    \n', '    string public constant name = "itCoinÂ® Black";\n', '    string public constant symbol = "ITC";\n', '    uint256 public constant decimals = 18;  // 18 is the most common number of decimal places\n', '    bool private tradeable;\n', '    uint256 private currentSupply;\n', '    mapping(address => uint256) private balances;\n', '    mapping(address => mapping(address=> uint256)) private allowed;\n', '    mapping(address => bool) private lockedAccounts;  \n', '\t\n', '\t/*\n', '\t\tIncomming Ether\n', '\t*/\t\n', '    event RecievedEth(address indexed _from, uint256 _value);\n', '\t//this is the fallback\n', '\tfunction () payable public {\n', '\t\tRecievedEth(msg.sender, msg.value);\t\t\n', '\t}\n', '\t\n', '\tevent TransferedEth(address indexed _to, uint256 _value);\n', '\tfunction FoundationTransfer(address _to, uint256 amtEth, uint256 amtToken) public onlyOwner\n', '\t{\n', '\t\trequire(this.balance >= amtEth && balances[this] >= amtToken );\n', '\t\t\n', '\t\tif(amtEth >0)\n', '\t\t{\n', '\t\t\t_to.transfer(amtEth);\n', '\t\t\tTransferedEth(_to, amtEth);\n', '\t\t}\n', '\t\t\n', '\t\tif(amtToken > 0)\n', '\t\t{\n', '\t\t\trequire(balances[_to] + amtToken > balances[_to]);\n', '\t\t\tbalances[this] -= amtToken;\n', '\t\t\tbalances[_to] += amtToken;\n', '\t\t\tTransfer(this, _to, amtToken);\n', '\t\t}\n', '\t\t\n', '\t\t\n', '\t}\t\n', '\t/*\n', '\t\tEnd Incomming Ether\n', '\t*/\n', '\t\n', '\t\n', '\t\n', '    function GiftzNetworkToken(\n', '\t\tuint256 initialTotalSupply, \n', '\t\taddress[] addresses, \n', '\t\tuint256[] initialBalances, \n', '\t\tbool initialBalancesLocked\n', '\t\t) public\n', '    {\n', '        require(addresses.length == initialBalances.length);\n', '        \n', '        currentSupply = initialTotalSupply * (10**decimals);\n', '        uint256 totalCreated;\n', '        for(uint8 i =0; i < addresses.length; i++)\n', '        {\n', '            if(initialBalancesLocked){\n', '                lockedAccounts[addresses[i]] = true;\n', '            }\n', '            balances[addresses[i]] = initialBalances[i]* (10**decimals);\n', '            totalCreated += initialBalances[i]* (10**decimals);\n', '        }\n', '        \n', '        \n', '        if(currentSupply < totalCreated)\n', '        {\n', '            selfdestruct(msg.sender);\n', '        }\n', '        else\n', '        {\n', '            balances[this] = currentSupply - totalCreated;\n', '        }\n', '    }\n', '    \n', '\t\n', '    event SoldToken(address _buyer, uint256 _value, string note);\n', '    function BuyToken(address _buyer, uint256 _value, string note) public onlyOwner\n', '    {\n', '\t\trequire(balances[this] >= _value && balances[_buyer] + _value > balances[_buyer]);\n', '\t\t\n', '        SoldToken( _buyer,  _value,  note);\n', '        balances[this] -= _value;\n', '        balances[_buyer] += _value;\n', '        Transfer(this, _buyer, _value);\n', '    }\n', '    \n', '    function LockAccount(address toLock) public onlyOwner\n', '    {\n', '        lockedAccounts[toLock] = true;\n', '    }\n', '    function UnlockAccount(address toUnlock) public onlyOwner\n', '    {\n', '        delete lockedAccounts[toUnlock];\n', '    }\n', '    \n', '    function SetTradeable(bool t) public onlyOwner\n', '    {\n', '        tradeable = t;\n', '    }\n', '    function IsTradeable() public view returns(bool)\n', '    {\n', '        return tradeable;\n', '    }\n', '    \n', '    \n', '    function totalSupply() constant public returns (uint256)\n', '    {\n', '        return currentSupply;\n', '    }\n', '    function balanceOf(address _owner) constant public returns (uint256 balance)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '    function transfer(address _to, uint256 _value) public notLocked returns (bool success) {\n', '        require(tradeable);\n', '         if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) {\n', '             Transfer( msg.sender, _to,  _value);\n', '             balances[msg.sender] -= _value;\n', '             balances[_to] += _value;\n', '             return true;\n', '         } else {\n', '             return false;\n', '         }\n', '     }\n', '    function transferFrom(address _from, address _to, uint _value)public notLocked returns (bool success) {\n', '        require(!lockedAccounts[_from] && !lockedAccounts[_to]);\n', '\t\trequire(tradeable);\n', '        if (balances[_from] >= _value\n', '            && allowed[_from][msg.sender] >= _value\n', '            && _value > 0\n', '            && balances[_to] + _value > balances[_to]) {\n', '                \n', '            Transfer( _from, _to,  _value);\n', '                \n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '    \n', '    function approve(address _spender, uint _value) public returns (bool success) {\n', '        Approval(msg.sender,  _spender, _value);\n', '        allowed[msg.sender][_spender] = _value;\n', '        return true;\n', '    }\n', '    function allowance(address _owner, address _spender) constant public returns (uint remaining){\n', '        return allowed[_owner][_spender];\n', '    }\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '   \n', '   modifier notLocked(){\n', '       require (!lockedAccounts[msg.sender]);\n', '       _;\n', '   }\n', '}']