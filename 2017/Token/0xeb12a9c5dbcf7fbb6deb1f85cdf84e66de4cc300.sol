['pragma solidity ^0.4.13;\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    if (msg.sender != owner) {\n', '      revert();\n', '    }\n', '    _;\n', '  }\n', '}\n', '\n', 'contract RBInformationStore is Ownable {\n', '    address public profitContainerAddress;\n', '    address public companyWalletAddress;\n', '    uint public etherRatioForOwner;\n', '    address public multisig;\n', '\n', '    function RBInformationStore(address _profitContainerAddress, address _companyWalletAddress, uint _etherRatioForOwner, address _multisig) {\n', '        profitContainerAddress = _profitContainerAddress;\n', '        companyWalletAddress = _companyWalletAddress;\n', '        etherRatioForOwner = _etherRatioForOwner;\n', '        multisig = _multisig;\n', '    }\n', '\n', '    function setProfitContainerAddress(address _address)  {\n', '        require(multisig == msg.sender);\n', '        if(_address != 0x0) {\n', '            profitContainerAddress = _address;\n', '        }\n', '    }\n', '\n', '    function setCompanyWalletAddress(address _address)  {\n', '        require(multisig == msg.sender);\n', '        if(_address != 0x0) {\n', '            companyWalletAddress = _address;\n', '        }\n', '    }\n', '\n', '    function setEtherRatioForOwner(uint _value)  {\n', '        require(multisig == msg.sender);\n', '        if(_value != 0) {\n', '            etherRatioForOwner = _value;\n', '        }\n', '    }\n', '\n', '    function changeMultiSig(address newAddress){\n', '        require(multisig == msg.sender);\n', '        multisig = newAddress;\n', '    }\n', '\n', '    function changeOwner(address newOwner){\n', '        require(multisig == msg.sender);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '  function mul(uint a, uint b) internal returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint a, uint b) internal returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function sub(uint a, uint b) internal returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal returns (uint) {\n', '    uint c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function assert(bool assertion) internal {\n', '    if (!assertion) {\n', '      revert();\n', '    }\n', '  }\n', '}\n', '\n', '/*\n', ' * ERC20Basic\n', ' * Simpler version of ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20Basic {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) constant returns (uint);\n', '  function transfer(address to, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', '/*\n', ' * ERC20 interface\n', ' * see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract ERC20 is ERC20Basic {\n', '  function allowance(address owner, address spender) constant returns (uint);\n', '  function transferFrom(address from, address to, uint value);\n', '  function approve(address spender, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '/*\n', ' * Basic token\n', ' * Basic version of StandardToken, with no allowances\n', ' */\n', 'contract BasicToken is ERC20Basic {\n', '  using SafeMath for uint;\n', '\n', '  mapping(address => uint) balances;\n', '\n', '  /*\n', '   * Fix for the ERC20 short address attack\n', '   */\n', '  modifier onlyPayloadSize(uint size) {\n', '     if(msg.data.length < size + 4) {\n', '       revert();\n', '     }\n', '     _;\n', '  }\n', '\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n', '    balances[msg.sender] = balances[msg.sender].sub(_value);\n', '    balances[_to] = balances[_to].add(_value);\n', '    Transfer(msg.sender, _to, _value);\n', '  }\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * Standard ERC20 token\n', ' *\n', ' * https://github.com/ethereum/EIPs/issues/20\n', ' * Based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' */\n', 'contract StandardToken is BasicToken, ERC20 {\n', '\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  function transferFrom(address _from, address _to, uint _value) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    // Check is not needed because sub(_allowance, _value) will already revert() if this condition is not met\n', '    // if (_value > _allowance) revert();\n', '\n', '    balances[_to] = balances[_to].add(_value);\n', '    balances[_from] = balances[_from].sub(_value);\n', '    allowed[_from][msg.sender] = _allowance.sub(_value);\n', '    Transfer(_from, _to, _value);\n', '  }\n', '\n', '  function approve(address _spender, uint _value) {\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '  }\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', 'contract Rate {\n', '    uint public ETH_USD_rate;\n', '    RBInformationStore public rbInformationStore;\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != rbInformationStore.owner()) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    function Rate(uint _rate, address _address) {\n', '        ETH_USD_rate = _rate;\n', '        rbInformationStore = RBInformationStore(_address);\n', '    }\n', '\n', '    function setRate(uint _rate) onlyOwner {\n', '        ETH_USD_rate = _rate;\n', '    }\n', '}\n', '\n', '/**\n', '@title SponseeTokenModelSolaCoin\n', '@dev TODO add contract code of three contract above when deploy to mainnet\n', '*/\n', 'contract SponseeTokenModelSolaCoin is StandardToken {\n', '\n', '    string public name = "SOLA COIN";\n', '    uint8 public decimals = 18;\n', '    string public symbol = "SLC";\n', '    uint public totalSupply = 500000000 * (10 ** uint256(decimals));\n', '    uint public cap = 1000000000 * (10 ** uint256(decimals)); // maximum cap = 10 000 000 $ = 1 000 000 000 tokens\n', '    RBInformationStore public rbInformationStore;\n', '    Rate public rate;\n', '    uint public minimumSupport = 500; // minimum support is 5$\n', '    uint public etherRatioForInvestor = 10; // etherRatio (10%) to send ether to investor\n', '    address public sponseeAddress;\n', '    address public multiSigAddress; // account controls transfer ether/token and change multisig address\n', '    address public accountAddressForSponseeAddress; // account controls sponsee address to receive ether\n', '    bool public isPayableEnabled = false;\n', '\n', '    event LogReceivedEther(address indexed from, address indexed to, uint etherValue, string tokenName);\n', '    event LogTransferFromOwner(address indexed from, address indexed to, uint tokenValue, uint etherValue, uint rateUSDETH);\n', '    event LogBuy(address indexed from, address indexed to, uint indexed value, uint paymentId);\n', '    event LogRollbackTransfer(address indexed from, address indexed to, uint value);\n', '    event LogExchange(address indexed from, address indexed token, uint value);\n', '    event LogIncreaseCap(uint value);\n', '    event LogDecreaseCap(uint value);\n', '    event LogSetRBInformationStoreAddress(address indexed to);\n', '    event LogSetName(string name);\n', '    event LogSetSymbol(string symbol);\n', '    event LogMint(address indexed to, uint value);\n', '    event LogChangeMultiSigAddress(address indexed to);\n', '    event LogChangeAccountAddressForSponseeAddress(address indexed to);\n', '    event LogChangeSponseeAddress(address indexed to);\n', '    event LogChangeIsPayableEnabled();\n', '\n', '    modifier onlyOwner() {\n', '        if (msg.sender != rbInformationStore.owner()) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // constructor\n', '    function SponseeTokenModelSolaCoin(\n', '        address _rbInformationStoreAddress,\n', '        address _rateAddress,\n', '        address _sponsee,\n', '        address _multiSig,\n', '        address _accountForSponseeAddress,\n', '        address _to\n', '    ) {\n', '        rbInformationStore = RBInformationStore(_rbInformationStoreAddress);\n', '        rate = Rate(_rateAddress);\n', '        sponseeAddress = _sponsee;\n', '        multiSigAddress = _multiSig;\n', '        accountAddressForSponseeAddress = _accountForSponseeAddress;\n', '        balances[_to] = totalSupply;\n', '    }\n', '\n', '    /**\n', '    @notice Receive ether from any EOA accounts. Amount of ether received in this function is distributed to 3 parts.\n', '    One is a profitContainerAddress which is address of containerWallet to dividend to investor of Boost token.\n', '    Another is an ownerAddress which is address of owner of REALBOOST site.\n', '    The other is an sponseeAddress which is address of owner of this contract.\n', '    */\n', '    function() payable {\n', '        // check condition\n', '        require(isPayableEnabled);\n', '\n', '        // check validation\n', '        if(msg.value <= 0) { revert(); }\n', '\n', '        // calculate support amount in USD\n', '        uint supportedAmount = msg.value.mul(rate.ETH_USD_rate()).div(10**18);\n', '        // if support is less than minimum => return money to supporter\n', '        if(supportedAmount < minimumSupport) { revert(); }\n', '\n', '        // calculate the ratio of Ether for distribution\n', '        uint etherRatioForOwner = rbInformationStore.etherRatioForOwner();\n', '        uint etherRatioForSponsee = uint(100).sub(etherRatioForOwner).sub(etherRatioForInvestor);\n', '\n', '        /* divide Ether */\n', '        // calculate\n', '        uint etherForOwner = msg.value.mul(etherRatioForOwner).div(100);\n', '        uint etherForInvestor = msg.value.mul(etherRatioForInvestor).div(100);\n', '        uint etherForSponsee = msg.value.mul(etherRatioForSponsee).div(100);\n', '\n', '        // get address\n', '        address profitContainerAddress = rbInformationStore.profitContainerAddress();\n', '        address companyWalletAddress = rbInformationStore.companyWalletAddress();\n', '\n', '        // send Ether\n', '        if(!profitContainerAddress.send(etherForInvestor)) { revert(); }\n', '        if(!companyWalletAddress.send(etherForOwner)) { revert(); }\n', '        if(!sponseeAddress.send(etherForSponsee)) { revert(); }\n', '\n', '        // token amount is transfered to sender\n', '        // 1.0 token = 1 cent, 1 usd = 100 cents\n', '        // wei * US$/(10 ** 18 wei) * 100 cent/US$ * (10 ** 18(decimals))\n', '        uint tokenAmount = msg.value.mul(rate.ETH_USD_rate());\n', '\n', '        // add tokens\n', '        balances[msg.sender] = balances[msg.sender].add(tokenAmount);\n', '\n', '        // increase total supply\n', '        totalSupply = totalSupply.add(tokenAmount);\n', '\n', '        // check cap\n', '        if(totalSupply > cap) { revert(); }\n', '\n', '        // send exchange event\n', '        LogExchange(msg.sender, this, tokenAmount);\n', '\n', '        // send Event\n', '        LogReceivedEther(msg.sender, this, msg.value, name);\n', '\n', '        // tranfer event\n', '        Transfer(address(0x0), msg.sender, tokenAmount);\n', '    }\n', '\n', '    /**\n', '    @notice Change rbInformationStoreAddress.\n', '    @param _address The address of new rbInformationStore\n', '    */\n', '    function setRBInformationStoreAddress(address _address) {\n', '        // check sender is multisig address\n', '        require(multiSigAddress == msg.sender);\n', '\n', '        rbInformationStore = RBInformationStore(_address);\n', '\n', '        LogSetRBInformationStoreAddress(_address);\n', '    }\n', '\n', '    /**\n', '    @notice Change name.\n', '    @param _name The new name of token\n', '    */\n', '    function setName(string _name) onlyOwner {\n', '        name = _name;\n', '\n', '        LogSetName(_name);\n', '    }\n', '\n', '    /**\n', '    @notice Change symbol.\n', '    @param _symbol The new symbol of token\n', '    */\n', '    function setSymbol(string _symbol) onlyOwner {\n', '        symbol = _symbol;\n', '\n', '        LogSetSymbol(_symbol);\n', '    }\n', '\n', '    /**\n', '    @notice Mint new token amount.\n', '    @param _address The address that new token amount is added\n', '    @param _value The new amount of token\n', '    */\n', '    function mint(address _address, uint _value) {\n', '\n', '        // check sender is multisig address\n', '        require(accountAddressForSponseeAddress == msg.sender);\n', '\n', '        // add tokens\n', '        balances[_address] = balances[_address].add(_value);\n', '\n', '        // increase total supply\n', '        totalSupply = totalSupply.add(_value);\n', '\n', '        // check cap\n', '        if(totalSupply > cap) { revert(); }\n', '\n', '        LogMint(_address, _value);\n', '\n', '        // tranfer event\n', '        Transfer(address(0x0), _address, _value);\n', '    }\n', '\n', '    /**\n', '    @notice Increase cap.\n', '    @param _value The amount of token that should be increased\n', '    */\n', '    function increaseCap(uint _value) onlyOwner {\n', '        // change cap here\n', '        cap = cap.add(_value);\n', '\n', '        LogIncreaseCap(_value);\n', '    }\n', '\n', '    /**\n', '    @notice Decrease cap.\n', '    @param _value The amount of token that should be decreased\n', '    */\n', '    function decreaseCap(uint _value) onlyOwner {\n', '        // check whether cap is lower than totalSupply or not\n', '        if(totalSupply > cap.sub(_value)) { revert(); }\n', '        // change cap here\n', '        cap = cap.sub(_value);\n', '\n', '        LogDecreaseCap(_value);\n', '    }\n', '\n', '    /**\n', '    @notice Rollback transfer.\n', '    @param _from The EOA address for rollback transfer\n', '    @param _to The EOA address for rollback transfer\n', '    @param _value The number of token for rollback transfer\n', '    */\n', '    function rollbackTransfer(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n', '        // check sender is multisig address\n', '        require(multiSigAddress == msg.sender);\n', '\n', '        balances[_to] = balances[_to].sub(_value);\n', '        balances[_from] = balances[_from].add(_value);\n', '\n', '        LogRollbackTransfer(_from, _to, _value);\n', '\n', '        // tranfer event\n', '        Transfer(_from, _to, _value);\n', '    }\n', '\n', '    /**\n', '    @notice Transfer from msg.sender for downloading of content.\n', '    @param _to The EOA address for buy content\n', '    @param _value The number of token for buy content\n', '    @param _paymentId The id of content which msg.sender want to buy\n', '    */\n', '    function buy(address _to, uint _value, uint _paymentId) {\n', '        transfer(_to, _value);\n', '\n', '        LogBuy(msg.sender, _to, _value, _paymentId);\n', '    }\n', '\n', '    /**\n', '    @notice This method will change old multi signature address with new one.\n', '    @param _newAddress new address is set\n', '    */\n', '    function changeMultiSigAddress(address _newAddress) {\n', '        // check sender is multisig address\n', '        require(multiSigAddress == msg.sender);\n', '\n', '        multiSigAddress = _newAddress;\n', '\n', '        LogChangeMultiSigAddress(_newAddress);\n', '\n', '    }\n', '\n', '    /**\n', '    @notice This method will change old multi signature for sponsee address with new one.\n', '    @param _newAddress new address is set\n', '    */\n', '    function changeAccountAddressForSponseeAddress(address _newAddress) {\n', '        // check sender is account for changing sponsee address\n', '        require(accountAddressForSponseeAddress == msg.sender);\n', '\n', '        accountAddressForSponseeAddress = _newAddress;\n', '\n', '        LogChangeAccountAddressForSponseeAddress(_newAddress);\n', '\n', '    }\n', '\n', '    /**\n', '    @notice This method will change old sponsee address with new one.\n', '    @param _newAddress new address is set\n', '    */\n', '    function changeSponseeAddress(address _newAddress) {\n', '        // check sender is account for changing sponsee address\n', '        require(accountAddressForSponseeAddress == msg.sender);\n', '\n', '        sponseeAddress = _newAddress;\n', '\n', '        LogChangeSponseeAddress(_newAddress);\n', '\n', '    }\n', '\n', '    /**\n', '    @notice This method will change isPayableEnabled flag.\n', '    */\n', '    function changeIsPayableEnabled() {\n', '        // check sender is multisig address\n', '        require(multiSigAddress == msg.sender);\n', '\n', '        isPayableEnabled = !isPayableEnabled;\n', '\n', '        LogChangeIsPayableEnabled();\n', '\n', '    }\n', '}']