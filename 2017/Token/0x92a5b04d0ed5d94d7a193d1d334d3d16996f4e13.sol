['pragma solidity ^0.4.15;\n', '\n', 'library SafeMath {\n', '    function div(uint a, uint b) internal returns (uint) {\n', '        assert(b > 0);\n', '        uint c = a / b;\n', '        assert(a == b * c + a % b);\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '     }\n', '    function add(uint a, uint b) internal returns (uint) {\n', '         uint c = a + b;\n', '         assert(c >= a);\n', '         return c;\n', '     }\n', '}\n', '\n', '\n', 'contract ERC20 {\n', '    uint public totalSupply = 0;\n', '\n', '    mapping(address => uint256) balances;\n', '    mapping(address => mapping (address => uint256)) allowed;\n', '\n', '    function balanceOf(address _owner) constant returns (uint);\n', '    function transfer(address _to, uint _value) returns (bool);\n', '    function transferFrom(address _from, address _to, uint _value) returns (bool);\n', '    function approve(address _spender, uint _value) returns (bool);\n', '    function allowance(address _owner, address _spender) constant returns (uint);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '} // Functions of ERC20 standard\n', '\n', 'contract ERT  is ERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public name = "Eristica TOKEN";\n', '    string public symbol = "ERT";\n', '    uint public decimals = 18;\n', '\n', '    address public ico;\n', '\n', '    event Burn(address indexed from, uint256 value);\n', '\n', '    bool public tokensAreFrozen = true;\n', '\n', '    modifier icoOnly { require(msg.sender == ico); _; }\n', '\n', '    function ERT(address _ico) {\n', '       ico = _ico;\n', '    }\n', '\n', '\n', '    function mint(address _holder, uint _value) external icoOnly {\n', '       require(_value != 0);\n', '       balances[_holder] = balances[_holder].add(_value);\n', '       totalSupply = totalSupply.add(_value);\n', '       Transfer(0x0, _holder, _value);\n', '    }\n', '\n', '\n', '    function defrost() external icoOnly {\n', '       tokensAreFrozen = false;\n', '    }\n', '\n', '    function burn(uint256 _value) {\n', '       require(!tokensAreFrozen);\n', '       balances[msg.sender] = balances[msg.sender].sub(_value);\n', '       totalSupply = totalSupply.sub(_value);\n', '       Burn(msg.sender, _value);\n', '    }\n', '\n', '\n', '    function balanceOf(address _owner) constant returns (uint256) {\n', '         return balances[_owner];\n', '    }\n', '\n', '\n', '    function transfer(address _to, uint256 _amount) returns (bool) {\n', '        require(!tokensAreFrozen);\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _amount) returns (bool) {\n', '        require(!tokensAreFrozen);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '     }\n', '\n', '\n', '    function approve(address _spender, uint256 _amount) returns (bool) {\n', '        // To change the approve amount you first have to reduce the addresses`\n', '        //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '        //  already 0 to mitigate the race condition described here:\n', '        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '}']