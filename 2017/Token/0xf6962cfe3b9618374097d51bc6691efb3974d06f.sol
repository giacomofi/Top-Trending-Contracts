['/**\n', '*\n', '* Inspired by FirstBlood Token - firstblood.io\n', '*\n', '*/\n', '\n', 'pragma solidity ^0.4.16;\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Math operations with safety checks that throw on error\n', '**/\n', 'library SafeMath {\n', '\tfunction mul(uint256 a, uint256 b) internal returns (uint256) {\n', '\t\tuint256 c = a * b;\n', '\t\tassert(a == 0 || c / a == b);\n', '\t\treturn c;\n', '  \t}\n', '\n', '  \tfunction div(uint256 a, uint256 b) internal returns (uint256) {\n', '\t\tuint256 c = a / b;\n', '\t\treturn c;\n', '  \t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal returns (uint256) {\n', '\t\tassert(b <= a);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction add(uint256 a, uint256 b) internal returns (uint256) {\n', '\t\t uint256 c = a + b;\n', '\t\t assert(c >= a);\n', '\t\t return c;\n', '\t}\n', '}\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '**/\n', 'contract Ownable {\n', '\taddress public owner;\n', '\n', '\t/**\n', "\t* @dev The Ownable constructor sets the original 'owner' of the contract to the sender\n", '\t* account.\n', '\t**/\n', '\tfunction Ownable() {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Throws if called by any account other than the owner.\n', '\t**/\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t* @param newOwner The address to transfer ownership to.\n', '\t**/\n', '\tfunction transferOwnership(address newOwner) onlyOwner {\n', '\t\tif (newOwner != address(0)) {\n', '\t\t\towner = newOwner;\n', '\t\t}\n', '\t}\n', '}\n', '\n', '/**\n', '* @title Pausable\n', '* @dev Base contract which allows children to implement an emergency stop mechanism.\n', '**/\n', 'contract Pausable is Ownable {\n', '\tevent Pause();\n', '\tevent Unpause();\n', '\tevent PauseRefund();\n', '\tevent UnpauseRefund();\n', '\n', '\tbool public paused = true;\n', '\tbool public refundPaused = true;\n', '\t// Deadline set to December 29th, 2017 at 11:59pm PST\n', '\tuint256 public durationInMinutes = 60*24*29+60*3+10;\n', '\tuint256 public dayAfterInMinutes = 60*24*30+60*3+10;\n', '\tuint256 public deadline = now + durationInMinutes * 1 minutes;\n', '\tuint256 public dayAfterDeadline = now + dayAfterInMinutes * 1 minutes;\n', '\n', '\t/**\n', '\t* @dev modifier to allow actions only when the contract IS NOT paused\n', '\t**/\n', '\tmodifier whenNotPaused() {\n', '\t\trequire(!paused);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev modifier to allow actions only when the refund IS NOT paused\n', '\t**/\n', '\tmodifier whenRefundNotPaused() {\n', '\t\trequire(!refundPaused);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev modifier to allow actions only when the contract IS paused\n', '\t**/\n', '\tmodifier whenPaused {\n', '\t\trequire(paused);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev modifier to allow actions only when the refund IS paused\n', '\t**/\n', '\tmodifier whenRefundPaused {\n', '\t\trequire(refundPaused);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev modifier to allow actions only when the crowdsale has ended\n', '\t**/\n', '\tmodifier whenCrowdsaleEnded {\n', '\t\trequire(deadline < now);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev modifier to allow actions only when the crowdsale has not ended\n', '\t**/\n', '\tmodifier whenCrowdsaleNotEnded {\n', '\t\trequire(deadline >= now);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev called by the owner to pause, triggers stopped state\n', '\t**/\n', '\tfunction pause() onlyOwner whenNotPaused returns (bool) {\n', '\t\tpaused = true;\n', '\t\tPause();\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev called by the owner to pause, triggers stopped state\n', '\t**/\n', '\tfunction pauseRefund() onlyOwner whenRefundNotPaused returns (bool) {\n', '\t\trefundPaused = true;\n', '\t\tPauseRefund();\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev called by the owner to unpause, returns to normal state\n', '\t**/\n', '\tfunction unpause() onlyOwner whenPaused returns (bool) {\n', '\t\tpaused = false;\n', '\t\tUnpause();\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev called by the owner to unpause, returns to normal state\n', '\t**/\n', '\tfunction unpauseRefund() onlyOwner whenRefundPaused returns (bool) {\n', '\t\trefundPaused = false;\n', '\t\tUnpauseRefund();\n', '\t\treturn true;\n', '\t}\n', '}\n', '\n', '/**\n', '* @title ERC20Basic\n', '* @dev Simpler version of ERC20 interface\n', '* @dev see https://github.com/ethereum/EIPs/issues/179\n', '**/\n', 'contract ERC20Basic {\n', '\tuint256 public totalSupply;\n', '\tfunction balanceOf(address who) constant returns (uint256);\n', '\tfunction transfer(address to, uint256 value) returns (bool);\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '/**\n', '* @title Basic token\n', '* @dev Basic version of StandardToken, with no allowances.\n', '**/\n', 'contract BasicToken is ERC20Basic {\n', '\tusing SafeMath for uint256;\n', '\n', '\tmapping(address => uint256) balances;\n', '\n', '\t/**\n', '\t* @dev transfer token for a specified address\n', '\t* @param _to The address to transfer to.\n', '\t* @param _value The amount to be transferred.\n', '\t**/\n', '\tfunction transfer(address _to, uint256 _value) returns (bool) {\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tTransfer(msg.sender, _to, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Gets the balance of the specified address.\n', '\t* @param _owner The address to query the the balance of.\n', '\t* @return An uint256 representing the amount owned by the passed address.\n', '\t**/\n', '\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n', '\t\treturn balances[_owner];\n', '\t}\n', '}\n', '\n', '/**\n', '* @title ERC20 interface\n', '* @dev see https://github.com/ethereum/EIPs/issues/20\n', '**/\n', 'contract ERC20 is ERC20Basic {\n', '\tfunction allowance(address owner, address spender) constant returns (uint256);\n', '\tfunction transferFrom(address from, address to, uint256 value) returns (bool);\n', '\tfunction approve(address spender, uint256 value) returns (bool);\n', '\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', '* @title Standard ERC20 token\n', '*\n', '* @dev Implementation of the basic standard token.\n', '* @dev https://github.com/ethereum/EIPs/issues/20\n', '* @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', '**/\n', 'contract StandardToken is ERC20, BasicToken {\n', '\n', '\tmapping (address => mapping (address => uint256)) allowed;\n', '\n', '\t/**\n', '\t* @dev Transfer tokens from one address to another\n', '\t* @param _from address The address which you want to send tokens from\n', '\t* @param _to address The address which you want to transfer to\n', '\t* @param _value uint256 the amout of tokens to be transfered\n', '\t**/\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) returns (bool) {\n', '\t\tvar _allowance = allowed[_from][msg.sender];\n', '\n', '\t\trequire (_value <= _allowance);\n', '\n', '\t\tbalances[_to] = balances[_to].add(_value);\n', '\t\tbalances[_from] = balances[_from].sub(_value);\n', '\t\tallowed[_from][msg.sender] = _allowance.sub(_value);\n', '\t\t\n', '\t\tTransfer(_from, _to, _value);\n', '\t\t\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '\t* @param _spender The address which will spend the funds.\n', '\t* @param _value The amount of tokens to be spent.\n', '\t**/\n', '\tfunction approve(address _spender, uint256 _value) returns (bool) {\n', '\t\t\n', '\t\t/**\n', "\t\t* To change the approve amount you first have to reduce the addresses'\n", "\t\t* allowance to zero by calling 'approve(_spender, 0)' if it is not\n", '\t\t* already 0 to mitigate the race condition described here: \n', '\t\thttps://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '\t\t**/\n', '\t\trequire((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '\t\tallowed[msg.sender][_spender] = _value;\n', '\t\tApproval(msg.sender, _spender, _value);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '\t* @param _owner address The address which owns the funds.\n', '\t* @param _spender address The address which will spend the funds.\n', '\t* @return A uint256 specifing the amount of tokens still available for the spender.\n', '\t**/\n', '\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '\t\treturn allowed[_owner][_spender];\n', '\t}\n', '\n', '}\n', '\n', '/**\n', '* @title hodlToken\n', '* @dev All tokens are pre-assigned to the creator.\n', "* Tokens can be transferred using 'transfer' and other\n", "* 'StandardToken' functions.\n", '**/\n', 'contract hodlToken is Pausable, StandardToken {\n', '\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public escrow = this;\n', '\n', '\t//20% Finder allocation \n', '\tuint256 public purchasableTokens = 112000 * 10**18;\n', '\tuint256 public founderAllocation = 28000 * 10**18;\n', '\n', '\tstring public name = "TeamHODL Token";\n', '\tstring public symbol = "THODL";\n', '\tuint256 public decimals = 18;\n', '\tuint256 public INITIAL_SUPPLY = 140000 * 10**18;\n', '\n', '\tuint256 public RATE = 200;\n', '\tuint256 public REFUND_RATE = 200;\n', '\n', '\t/**\n', '\t* @dev Contructor that gives msg.sender all of existing tokens.\n', '\t**/\n', '\tfunction hodlToken() {\n', '\t\ttotalSupply = INITIAL_SUPPLY;\n', '\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '\t* @param newOwner The address to transfer ownership to.\n', '\t**/\n', '\tfunction transferOwnership(address newOwner) onlyOwner {\n', '\t\taddress oldOwner = owner;\n', '\t\tsuper.transferOwnership(newOwner);\n', '\t\tbalances[newOwner] = balances[oldOwner];\n', '\t\tbalances[oldOwner] = 0;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Allows the current owner to transfer escrowship of the contract to a escrow account.\n', '\t* @param newEscrow The address to transfer the escrow account to.\n', '\t**/\n', '\tfunction transferEscrowship(address newEscrow) onlyOwner {\n', '\t\tif (newEscrow != address(0)) {\n', '\t\t\tescrow = newEscrow;\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Allows the current owner to set the new total supply, to be used iff not all tokens sold during crowdsale.\n', '\t**/\n', '\tfunction setTotalSupply() onlyOwner whenCrowdsaleEnded {\n', '\t\tif (purchasableTokens > 0) {\n', '\t\t\ttotalSupply = totalSupply.sub(purchasableTokens);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Allows the current owner to withdraw ether funds after ICO ended.\n', '\t**/\n', '\tfunction cashOut() onlyOwner whenCrowdsaleEnded {\n', '\t\t\n', '\t\t/**\n', '\t\t* Transfer money from escrow wallet up to 1 day after ICO end.\n', '\t\t**/\n', '\t\tif (dayAfterDeadline >= now) {\n', '\t\t\towner.transfer(escrow.balance);\n', '\t\t}\n', '\t}\n', '  \n', '\t/**\n', '\t* @dev Allows owner to change the exchange rate of tokens (default 0.005 Ether)\n', '\t**/\n', '\tfunction setRate(uint256 rate) {\n', '\n', '\t\t/**\n', '\t\t* If break-even point has been reached (3500 Eth = 3.5*10**21 Wei),\n', '\t\t* rate updates to 20% of total revenue (100% of dedicated wallet after forwarding contract)\n', '\t\t**/\n', '\t\tif (escrow.balance >= 7*10**20) {\n', '\n', '\t\t\t/**\n', '\t\t\t* Rounds up to address division error\n', '\t\t\t**/\n', '\t\t\tRATE = (((totalSupply.mul(10000)).div(escrow.balance)).add(9999)).div(10000);\n', '\t\t}\n', '\t}\n', '  \n', '\t/**\n', '\t* @dev Allows owner to change the refund exchange rate of tokens (default 0.005 Ether)\n', '\t* @param rate The number of tokens to release\n', '\t**/\n', '\tfunction setRefundRate(uint256 rate) {\n', '\n', '\t\t/**\n', '\t\t* If break-even point has been reached (3500 Eth = 3.5*10**21 Wei),\n', '\t\t* refund rate updates to 20% of total revenue (100% of dedicated wallet after forwarding contract)\n', '\t\t**/\n', '\t\tif (escrow.balance >= 7*10**20) {\n', '\n', '\t\t\t/**\n', '\t\t\t* Rounds up to address division error\n', '\t\t\t**/\n', '\t\t\tREFUND_RATE = (((totalSupply.mul(10000)).div(escrow.balance)).add(9999)).div(10000);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t* @dev fallback function\n', '\t**/\n', '\tfunction () payable {\n', '\t\tif(now <= deadline){\n', '\t\t\tbuyTokens(msg.sender);\n', '\t\t}\n', '\t}\n', '\n', '\t/**\n', '\t* @dev function that sells available tokens\n', '\t**/\n', '\tfunction buyTokens(address addr) payable whenNotPaused whenCrowdsaleNotEnded {\n', '\t\t\n', '\t\t/**\n', '\t\t* Calculate tokens to sell and check that they are purchasable\n', '\t\t**/\n', '\t\tuint256 weiAmount = msg.value;\n', '\t\tuint256 tokens = weiAmount.mul(RATE);\n', '\t\trequire(purchasableTokens >= tokens);\n', '\n', '\t\t/**\n', '\t\t* Send tokens to buyer\n', '\t\t**/\n', '\t\tpurchasableTokens = purchasableTokens.sub(tokens);\n', '\t\tbalances[owner] = balances[owner].sub(tokens);\n', '\t\tbalances[addr] = balances[addr].add(tokens);\n', '\n', '\t\tTransfer(owner, addr, tokens);\n', '\t}\n', '  \n', '\tfunction fund() payable {}\n', '\n', '\tfunction defund() onlyOwner {}\n', '\n', '\tfunction refund(uint256 _amount) payable whenNotPaused whenCrowdsaleEnded {\n', '\n', '\t\t/**\n', '\t\t* Calculate amount of THODL to refund\n', '\t\t**/\n', '\t\tuint256 refundTHODL = _amount.mul(10**18);\n', '\t\trequire(balances[msg.sender] >= refundTHODL);\n', '\n', '\t\t/**\n', '\t\t* Calculate refund in wei\n', '\t\t**/\n', '\t\tuint256 weiAmount = refundTHODL.div(REFUND_RATE);\n', '\t\trequire(this.balance >= weiAmount);\n', '\n', '\t\tbalances[msg.sender] = balances[msg.sender].sub(refundTHODL);\n', '\t\t\n', '\t\t/**\n', '\t\t* The tokens are burned\n', '\t\t**/\n', '\t\ttotalSupply = totalSupply.sub(refundTHODL);\n', '\n', '\t\tmsg.sender.transfer(weiAmount);\n', '\t}\n', '}']