['pragma solidity ^0.4.16;\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// BULB TulipMania token public sale contract\n', '//\n', '// For details, please visit: https://tulipmania.co\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// SafeMath3\n', '//\n', '// Adapted from https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '// (no need to implement division)\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'library SafeMath3 {\n', '\n', '  function mul(uint a, uint b) internal constant returns (uint c) {\n', '    c = a * b;\n', '    assert( a == 0 || c / a == b );\n', '  }\n', '\n', '  function sub(uint a, uint b) internal constant returns (uint) {\n', '    assert( b <= a );\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint a, uint b) internal constant returns (uint c) {\n', '    c = a + b;\n', '    assert( c >= a );\n', '  }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// Owned contract\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '  address public owner;\n', '  address public newOwner;\n', '\n', '  // Events ---------------------------\n', '\n', '  event OwnershipTransferProposed(address indexed _from, address indexed _to);\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '  // Modifier -------------------------\n', '\n', '  modifier onlyOwner {\n', '    require( msg.sender == owner );\n', '    _;\n', '  }\n', '\n', '  // Functions ------------------------\n', '\n', '  function Owned() {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  function transferOwnership(address _newOwner) onlyOwner {\n', '    require( _newOwner != owner );\n', '    require( _newOwner != address(0x0) );\n', '    OwnershipTransferProposed(owner, _newOwner);\n', '    newOwner = _newOwner;\n', '  }\n', '\n', '  function acceptOwnership() {\n', '    require(msg.sender == newOwner);\n', '    OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Interface {\n', '\n', '  // Events ---------------------------\n', '\n', '  event Transfer(address indexed _from, address indexed _to, uint _value);\n', '  event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '  // Functions ------------------------\n', '\n', '  function totalSupply() constant returns (uint);\n', '  function balanceOf(address _owner) constant returns (uint balance);\n', '  function transfer(address _to, uint _value) returns (bool success);\n', '  function transferFrom(address _from, address _to, uint _value) returns (bool success);\n', '  function approve(address _spender, uint _value) returns (bool success);\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining);\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC Token Standard #20\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Token is ERC20Interface, Owned {\n', '  \n', '  using SafeMath3 for uint;\n', '\n', '  uint public tokensIssuedTotal = 0;\n', '  mapping(address => uint) balances;\n', '  mapping(address => mapping (address => uint)) allowed;\n', '\n', '  // Functions ------------------------\n', '\n', '  /* Total token supply */\n', '\n', '  function totalSupply() constant returns (uint) {\n', '    return tokensIssuedTotal;\n', '  }\n', '\n', '  /* Get the account balance for an address */\n', '\n', '  function balanceOf(address _owner) constant returns (uint balance) {\n', '    return balances[_owner];\n', '  }\n', '\n', "  /* Transfer the balance from owner's account to another account */\n", '\n', '  function transfer(address _to, uint _amount) returns (bool success) {\n', '    // amount sent cannot exceed balance\n', '    require( balances[msg.sender] >= _amount );\n', '\n', '    // update balances\n', '    balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '    balances[_to]        = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(msg.sender, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Allow _spender to withdraw from your account up to _amount */\n', '\n', '  function approve(address _spender, uint _amount) returns (bool success) {\n', '    // approval amount cannot exceed the balance\n', '    require ( balances[msg.sender] >= _amount );\n', '      \n', '    // update allowed amount\n', '    allowed[msg.sender][_spender] = _amount;\n', '    \n', '    // log event\n', '    Approval(msg.sender, _spender, _amount);\n', '    return true;\n', '  }\n', '\n', "  /* Spender of tokens transfers tokens from the owner's balance */\n", '  /* Must be pre-approved by owner */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) returns (bool success) {\n', '    // balance checks\n', '    require( balances[_from] >= _amount );\n', '    require( allowed[_from][msg.sender] >= _amount );\n', '\n', '    // update balances and allowed amount\n', '    balances[_from]            = balances[_from].sub(_amount);\n', '    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '    balances[_to]              = balances[_to].add(_amount);\n', '\n', '    // log event\n', '    Transfer(_from, _to, _amount);\n', '    return true;\n', '  }\n', '\n', '  /* Returns the amount of tokens approved by the owner */\n', '  /* that can be transferred by spender */\n', '\n', '  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// TulipMania public token sale\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract TulipMania is ERC20Token {\n', '\n', '  /* Utility variable */\n', '  \n', '  uint constant E6 = 10**6;\n', '  \n', '  /* Basic token data */\n', '\n', '  string public constant name     = "Tulip Mania";\n', '  string public constant symbol   = "BULB";\n', '  uint8  public constant decimals = 6;\n', '\n', '  /* Wallet addresses - initially set to owner at deployment */\n', '  \n', '  address public wallet;\n', '  address public adminWallet;\n', '\n', '  /* ICO dates */\n', '\n', '  uint public constant DATE_PRESALE_START = 1510758000; // 15-Nov-2017 15:00 UTC\n', '  uint public constant DATE_PRESALE_END   = 1511362800; // 22-Nov-2017 15:00 UTC\n', '\n', '  uint public constant DATE_ICO_START = 1511362801; // 22-Nov-2017 15:00:01 UTC\n', '  uint public constant DATE_ICO_END   = 1513868400; // 21-Dec-2017 15:00 UTC\n', '\n', '  /* ICO tokens per ETH */\n', '  \n', '  uint public tokensPerEth = 336 * E6;\n', '  uint public constant BONUS_PRESALE = 100;\n', '\n', '  /* Other ICO parameters */  \n', '  \n', '  uint public constant TOKEN_SUPPLY_TOTAL = 10000000 * E6; // 10M tokens\n', '  uint public constant TOKEN_SUPPLY_ICO   = 8500000 * E6; // 8.5M tokens\n', '  uint public constant TOKEN_SUPPLY_MKT   =  1500000 * E6; //  1.5M tokens\n', '\n', '  uint public constant PRESALE_ETH_CAP =  750 ether;\n', '\n', '  uint public constant MIN_CONTRIBUTION = 1 ether / 500; // 0.002 Ether\n', '  uint public constant MAX_CONTRIBUTION = 300 ether;\n', '\n', '  uint public constant COOLDOWN_PERIOD =  2 days;\n', '  uint public constant CLAWBACK_PERIOD = 2 days;\n', '\n', '  /* Crowdsale variables */\n', '\n', '  uint public icoEtherReceived = 0; // Ether actually received by the contract\n', '\n', '  uint public tokensIssuedIco   = 0;\n', '  uint public tokensIssuedMkt   = 0;\n', '  \n', '  uint public tokensClaimedAirdrop = 0;\n', '  \n', '  /* Keep track of Ether contributed and tokens received during Crowdsale */\n', '  \n', '  mapping(address => uint) public icoEtherContributed;\n', '  mapping(address => uint) public icoTokensReceived;\n', '\n', '  /* Keep track of participants who \n', '  /* - have received their airdropped tokens after a successful ICO */\n', '  /* - or have reclaimed their contributions in case of failed Crowdsale */\n', '  /* - are locked */\n', '  \n', '  mapping(address => bool) public airdropClaimed;\n', '  mapping(address => bool) public refundClaimed;\n', '  mapping(address => bool) public locked;\n', '\n', '  // Events ---------------------------\n', '  \n', '  event WalletUpdated(address _newWallet);\n', '  event AdminWalletUpdated(address _newAdminWallet);\n', '  event TokensPerEthUpdated(uint _tokensPerEth);\n', '  event TokensMinted(address indexed _owner, uint _tokens, uint _balance);\n', '  event TokensIssued(address indexed _owner, uint _tokens, uint _balance, uint _etherContributed);\n', '  event Refund(address indexed _owner, uint _amount, uint _tokens);\n', '  event Airdrop(address indexed _owner, uint _amount, uint _balance);\n', '  event LockRemoved(address indexed _participant);\n', '\n', '  // Basic Functions ------------------\n', '\n', '  /* Initialize (owner is set to msg.sender by Owned.Owned() */\n', '\n', '  function TulipMania() {\n', '    require( TOKEN_SUPPLY_ICO + TOKEN_SUPPLY_MKT == TOKEN_SUPPLY_TOTAL );\n', '    wallet = owner;\n', '    adminWallet = owner;\n', '  }\n', '\n', '  /* Fallback */\n', '  \n', '  function () payable {\n', '    buyTokens();\n', '  }\n', '  \n', '  // Information functions ------------\n', '  \n', '  /* What time is it? */\n', '  \n', '  function atNow() constant returns (uint) {\n', '    return now;\n', '  }\n', '  \n', '  /* Are tokens transferable? */\n', '\n', '  function isTransferable() constant returns (bool transferable) {\n', '     if ( atNow() < DATE_ICO_END + COOLDOWN_PERIOD ) return false;\n', '     return true;\n', '  }\n', '  \n', '  // Lock functions -------------------\n', '\n', '  /* Manage locked */\n', '\n', '  function removeLock(address _participant) {\n', '    require( msg.sender == adminWallet || msg.sender == owner );\n', '    locked[_participant] = false;\n', '    LockRemoved(_participant);\n', '  }\n', '\n', '  function removeLockMultiple(address[] _participants) {\n', '    require( msg.sender == adminWallet || msg.sender == owner );\n', '    for (uint i = 0; i < _participants.length; i++) {\n', '      locked[_participants[i]] = false;\n', '      LockRemoved(_participants[i]);\n', '    }\n', '  }\n', '\n', '  // Owner Functions ------------------\n', '  \n', '  /* Change the crowdsale wallet address */\n', '\n', '  function setWallet(address _wallet) onlyOwner {\n', '    require( _wallet != address(0x0) );\n', '    wallet = _wallet;\n', '    WalletUpdated(wallet);\n', '  }\n', '\n', '  /* Change the admin wallet address */\n', '\n', '  function setAdminWallet(address _wallet) onlyOwner {\n', '    require( _wallet != address(0x0) );\n', '    adminWallet = _wallet;\n', '    AdminWalletUpdated(adminWallet);\n', '  }\n', '\n', '  /* Change tokensPerEth before ICO start */\n', '  \n', '  function updateTokensPerEth(uint _tokensPerEth) onlyOwner {\n', '    require( atNow() < DATE_PRESALE_START );\n', '    tokensPerEth = _tokensPerEth;\n', '    TokensPerEthUpdated(_tokensPerEth);\n', '  }\n', '\n', '  /* Minting of marketing tokens by owner */\n', '\n', '  function mintMarketing(address _participant, uint _tokens) onlyOwner {\n', '    // check amount\n', '    require( _tokens <= TOKEN_SUPPLY_MKT.sub(tokensIssuedMkt) );\n', '    \n', '    // update balances\n', '    balances[_participant] = balances[_participant].add(_tokens);\n', '    tokensIssuedMkt        = tokensIssuedMkt.add(_tokens);\n', '    tokensIssuedTotal      = tokensIssuedTotal.add(_tokens);\n', '    \n', '    // locked\n', '    locked[_participant] = true;\n', '    \n', '    // log the minting\n', '    Transfer(0x0, _participant, _tokens);\n', '    TokensMinted(_participant, _tokens, balances[_participant]);\n', '  }\n', '\n', '  /* Owner clawback of remaining funds after clawback period */\n', '  /* (for use in case of a failed Crowdsale) */\n', '  \n', '  function ownerClawback() external onlyOwner {\n', '    require( atNow() > DATE_ICO_END + CLAWBACK_PERIOD );\n', '    wallet.transfer(this.balance);\n', '  }\n', '\n', '  /* Transfer out any accidentally sent ERC20 tokens */\n', '\n', '  function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner returns (bool success) {\n', '      return ERC20Interface(tokenAddress).transfer(owner, amount);\n', '  }\n', '\n', '  // Private functions ----------------\n', '\n', '  /* Accept ETH during crowdsale (called by default function) */\n', '\n', '  function buyTokens() private {\n', '    uint ts = atNow();\n', '    bool isPresale = false;\n', '    bool isIco = false;\n', '    uint tokens = 0;\n', '    \n', '    // minimum contribution\n', '    require( msg.value >= MIN_CONTRIBUTION );\n', '    \n', '    // one address transfer hard cap\n', '    require( icoEtherContributed[msg.sender].add(msg.value) <= MAX_CONTRIBUTION );\n', '\n', '    // check dates for presale or ICO\n', '    if (ts > DATE_PRESALE_START && ts < DATE_PRESALE_END) isPresale = true;  \n', '    if (ts > DATE_ICO_START && ts < DATE_ICO_END) isIco = true;  \n', '    require( isPresale || isIco );\n', '\n', '    // presale cap in Ether\n', '    if (isPresale) require( icoEtherReceived.add(msg.value) <= PRESALE_ETH_CAP );\n', '    \n', '    // get baseline number of tokens\n', '    tokens = tokensPerEth.mul(msg.value) / 1 ether;\n', '    \n', '    // apply presale bonus\n', '    if (isPresale) {\n', '      tokens = tokens.mul(100 + BONUS_PRESALE) / 100;\n', '    }\n', '    \n', '    // ICO token volume cap\n', '    require( tokensIssuedIco.add(tokens) <= TOKEN_SUPPLY_ICO );\n', '\n', '    // register tokens\n', '    balances[msg.sender]          = balances[msg.sender].add(tokens);\n', '    icoTokensReceived[msg.sender] = icoTokensReceived[msg.sender].add(tokens);\n', '    tokensIssuedIco               = tokensIssuedIco.add(tokens);\n', '    tokensIssuedTotal             = tokensIssuedTotal.add(tokens);\n', '    \n', '    // register Ether\n', '    icoEtherReceived                = icoEtherReceived.add(msg.value);\n', '    icoEtherContributed[msg.sender] = icoEtherContributed[msg.sender].add(msg.value);\n', '    \n', '    // locked\n', '    locked[msg.sender] = true;\n', '    \n', '    // log token issuance\n', '    Transfer(0x0, msg.sender, tokens);\n', '    TokensIssued(msg.sender, tokens, balances[msg.sender], msg.value);\n', '\n', '    wallet.transfer(this.balance);\n', '  }\n', '  \n', '  // ERC20 functions ------------------\n', '\n', '  /* Override "transfer" (ERC20) */\n', '\n', '  function transfer(address _to, uint _amount) returns (bool success) {\n', '    require( isTransferable() );\n', '    require( locked[msg.sender] == false );\n', '    require( locked[_to] == false );\n', '    return super.transfer(_to, _amount);\n', '  }\n', '  \n', '  /* Override "transferFrom" (ERC20) */\n', '\n', '  function transferFrom(address _from, address _to, uint _amount) returns (bool success) {\n', '    require( isTransferable() );\n', '    require( locked[_from] == false );\n', '    require( locked[_to] == false );\n', '    return super.transferFrom(_from, _to, _amount);\n', '  }\n', '\n', '  // External functions ---------------\n', '\n', '  /* Reclaiming of funds by contributors in case of a failed crowdsale */\n', '  /* (it will fail if account is empty after ownerClawback) */\n', '\n', '  /* While there could not have been any token transfers yet, a contributor */\n', '  /* may have received minted tokens, so the token balance after a refund */ \n', '  /* may still be positive */\n', '  \n', '  function reclaimFunds() external {\n', '    uint tokens; // tokens to destroy\n', '    uint amount; // refund amount\n', '    \n', '    // ico is finished\n', '    require( atNow() > DATE_ICO_END);\n', '    \n', '    // check if refund has already been claimed\n', '    require( !refundClaimed[msg.sender] );\n', '    \n', '    // check if there is anything to refund\n', '    require( icoEtherContributed[msg.sender] > 0 );\n', '    \n', '    // update variables affected by refund\n', '    tokens = icoTokensReceived[msg.sender];\n', '    amount = icoEtherContributed[msg.sender];\n', '\n', '    balances[msg.sender] = balances[msg.sender].sub(tokens);\n', '    tokensIssuedTotal    = tokensIssuedTotal.sub(tokens);\n', '    \n', '    refundClaimed[msg.sender] = true;\n', '    \n', '    // transfer out refund\n', '    msg.sender.transfer(amount);\n', '    \n', '    // log\n', '    Transfer(msg.sender, 0x0, tokens);\n', '    Refund(msg.sender, amount, tokens);\n', '  }\n', '\n', '  /* Claiming of "airdropped" tokens in case of successful crowdsale */\n', '  /* Can be done by token holder, or by adminWallet */ \n', '\n', '  function claimAirdrop() external {\n', '    doAirdrop(msg.sender);\n', '  }\n', '\n', '  function adminClaimAirdrop(address _participant) external {\n', '    require( msg.sender == adminWallet );\n', '    doAirdrop(_participant);\n', '  }\n', '\n', '  function adminClaimAirdropMultiple(address[] _addresses) external {\n', '    require( msg.sender == adminWallet );\n', '    for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i]);\n', '  }  \n', '  \n', '  function doAirdrop(address _participant) internal {\n', '    uint airdrop = computeAirdrop(_participant);\n', '\n', '    require( airdrop > 0 );\n', '\n', '    // update balances and token issue volume\n', '    airdropClaimed[_participant] = true;\n', '    balances[_participant] = balances[_participant].add(airdrop);\n', '    tokensIssuedTotal      = tokensIssuedTotal.add(airdrop);\n', '    tokensClaimedAirdrop   = tokensClaimedAirdrop.add(airdrop);\n', '    \n', '    // log\n', '    Airdrop(_participant, airdrop, balances[_participant]);\n', '    Transfer(0x0, _participant, airdrop);\n', '  }\n', '\n', '  /* Function to estimate airdrop amount. For some accounts, the value of */\n', '  /* tokens received by calling claimAirdrop() may be less than gas costs */\n', '  \n', '  /* If an account has tokens from the ico, the amount after the airdrop */\n', '  /* will be newBalance = tokens * TOKEN_SUPPLY_ICO / tokensIssuedIco */\n', '      \n', '  function computeAirdrop(address _participant) constant returns (uint airdrop) {\n', "    // return 0 if it's too early\n", '    if ( atNow() < DATE_ICO_END ) return 0;\n', '    \n', '    // return 0 if the airdrop was already claimed\n', '    if( airdropClaimed[_participant] ) return 0;\n', '\n', '    // return 0 if the account does not hold any crowdsale tokens\n', '    if( icoTokensReceived[_participant] == 0 ) return 0;\n', '    \n', '    // airdrop amount\n', '    uint tokens = icoTokensReceived[_participant];\n', '    uint newBalance = tokens.mul(TOKEN_SUPPLY_ICO) / tokensIssuedIco;\n', '    airdrop = newBalance - tokens;\n', '  }  \n', '\n', '  /* Multiple token transfers from one address to save gas */\n', '  /* (longer _amounts array not accepted = sanity check) */\n', '\n', '  function transferMultiple(address[] _addresses, uint[] _amounts) external {\n', '    require( isTransferable() );\n', '    require( locked[msg.sender] == false );\n', '    require( _addresses.length == _amounts.length );\n', '    for (uint i = 0; i < _addresses.length; i++) {\n', '      if (locked[_addresses[i]] == false) super.transfer(_addresses[i], _amounts[i]);\n', '    }\n', '  }  \n', '\n', '}']