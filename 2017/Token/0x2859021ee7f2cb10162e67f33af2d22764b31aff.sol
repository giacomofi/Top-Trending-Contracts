['pragma solidity ^0.4.18;\n', '\n', ' /// @title SafeMath contract - math operations with safety checks\n', 'contract SafeMath {\n', '  function safeMul(uint a, uint b) internal pure  returns (uint) {\n', '    uint c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint a, uint b) internal pure returns (uint) {\n', '    assert(b > 0);\n', '    uint c = a / b;\n', '    assert(a == b * c + a % b);\n', '    return c;\n', '  }\n', '\n', '  function safeSub(uint a, uint b) internal pure returns (uint) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint a, uint b) internal pure returns (uint) {\n', '    uint c = a + b;\n', '    assert(c>=a && c>=b);\n', '    return c;\n', '  }\n', '\n', '  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\n', '    return a < b ? a : b;\n', '  }\n', '\n', '  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a >= b ? a : b;\n', '  }\n', '\n', '  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return a < b ? a : b;\n', '  }\n', '}\n', '\n', ' /// @title Ownable contract - base contract with an owner\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  function Ownable() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    if (newOwner != address(0)) {\n', '      owner = newOwner;\n', '    }\n', '  }\n', '}\n', '\n', ' /// @title Killable contract - base contract that can be killed by owner. All funds in contract will be sent to the owner.\n', 'contract Killable is Ownable {\n', '  function kill() public onlyOwner {\n', '    selfdestruct(owner);\n', '  }\n', '}\n', '\n', ' /// @title ERC20 interface see https://github.com/ethereum/EIPs/issues/20\n', 'contract ERC20 {\n', '  uint public totalSupply;\n', '  function balanceOf(address who) public constant returns (uint);\n', '  function allowance(address owner, address spender) public constant returns (uint);  \n', '  function transfer(address to, uint value) public returns (bool ok);\n', '  function transferFrom(address from, address to, uint value) public returns (bool ok);\n', '  function approve(address spender, uint value) public returns (bool ok);\n', '  function decimals() public constant returns (uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', ' /// @title SilentNotaryToken contract - standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n', 'contract SilentNotaryToken is SafeMath, ERC20, Killable {\n', '  string constant public name = "Silent Notary Token";\n', '  string constant public symbol = "SNTR";\n', ' \n', '  /// Holder list\n', '  address[] public holders;\n', '  /// Balance data\n', '  struct Balance {\n', '    /// Tokens amount\n', '    uint value;\n', '    /// Object exist\n', '    bool exist;\n', '  }\n', '  /// Holder balances\n', '  mapping(address => Balance) public balances;\n', '  /// Contract that is allowed to create new tokens and allows unlift the transfer limits on this token\n', '  address public crowdsaleAgent;\n', '  /// A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.\n', '  bool public released = false;\n', '  /// approve() allowances\n', '  mapping (address => mapping (address => uint)) allowed;\n', '\n', '  /// @dev Limit token transfer until the crowdsale is over.\n', '  modifier canTransfer() {\n', '    if(!released)\n', '      require(msg.sender == crowdsaleAgent);\n', '    _;\n', '  }\n', '\n', '  /// @dev The function can be called only before or after the tokens have been releasesd\n', '  /// @param _released token transfer and mint state\n', '  modifier inReleaseState(bool _released) {\n', '    require(_released == released);\n', '    _;\n', '  }\n', '\n', '  /// @dev If holder does not exist add to array\n', '  /// @param holder Token holder\n', '  modifier addIfNotExist(address holder) {\n', '    if(!balances[holder].exist)\n', '      holders.push(holder);\n', '    _;\n', '  }\n', '\n', '  /// @dev The function can be called only by release agent.\n', '  modifier onlyCrowdsaleAgent() {\n', '    require(msg.sender == crowdsaleAgent);\n', '    _;\n', '  }\n', '\n', '  /// @dev Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/\n', '  /// @param size payload size\n', '  modifier onlyPayloadSize(uint size) {\n', '    require(msg.data.length >= size + 4);\n', '    _;\n', '  }\n', '\n', '  /// @dev Make sure we are not done yet.\n', '  modifier canMint() {\n', '    require(!released);\n', '    _;\n', '  }\n', '\n', '  /// @dev Constructor\n', '  function SilentNotaryToken() public {\n', '  }\n', '\n', '  /// Fallback method\n', '  function() payable public {\n', '\t  revert();\n', '  }\n', '\n', '  function decimals() public constant returns (uint value) {\n', '    return 4;\n', '  }\n', '  /// @dev Create new tokens and allocate them to an address. Only callably by a crowdsale contract\n', '  /// @param receiver Address of receiver\n', '  /// @param amount  Number of tokens to issue.\n', '  function mint(address receiver, uint amount) onlyCrowdsaleAgent canMint addIfNotExist(receiver) public {\n', '      totalSupply = safeAdd(totalSupply, amount);\n', '      balances[receiver].value = safeAdd(balances[receiver].value, amount);\n', '      balances[receiver].exist = true;\n', '      Transfer(0, receiver, amount);\n', '  }\n', '\n', '  /// @dev Set the contract that can call release and make the token transferable.\n', '  /// @param _crowdsaleAgent crowdsale contract address\n', '  function setCrowdsaleAgent(address _crowdsaleAgent) onlyOwner inReleaseState(false) public {\n', '    crowdsaleAgent = _crowdsaleAgent;\n', '  }\n', '  /// @dev One way function to release the tokens to the wild. Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached).\n', '  function releaseTokenTransfer() public onlyCrowdsaleAgent {\n', '    released = true;\n', '  }\n', '  /// @dev Tranfer tokens to address\n', '  /// @param _to dest address\n', '  /// @param _value tokens amount\n', '  /// @return transfer result\n', '  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) canTransfer addIfNotExist(_to) public returns (bool success) {\n', '    balances[msg.sender].value = safeSub(balances[msg.sender].value, _value);\n', '    balances[_to].value = safeAdd(balances[_to].value, _value);\n', '    balances[_to].exist = true;\n', '    Transfer(msg.sender, _to, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Tranfer tokens from one address to other\n', '  /// @param _from source address\n', '  /// @param _to dest address\n', '  /// @param _value tokens amount\n', '  /// @return transfer result\n', '  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(2 * 32) canTransfer addIfNotExist(_to) public returns (bool success) {\n', '    var _allowance = allowed[_from][msg.sender];\n', '\n', '    balances[_to].value = safeAdd(balances[_to].value, _value);\n', '    balances[_from].value = safeSub(balances[_from].value, _value);\n', '    balances[_to].exist = true;\n', '\n', '    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n', '    Transfer(_from, _to, _value);\n', '    return true;\n', '  }\n', '  /// @dev Tokens balance\n', '  /// @param _owner holder address\n', '  /// @return balance amount\n', '  function balanceOf(address _owner) constant public returns (uint balance) {\n', '    return balances[_owner].value;\n', '  }\n', '\n', '  /// @dev Approve transfer\n', '  /// @param _spender holder address\n', '  /// @param _value tokens amount\n', '  /// @return result\n', '  function approve(address _spender, uint _value) public returns (bool success) {\n', '    // To change the approve amount you first have to reduce the addresses`\n', '    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n', '    //  already 0 to mitigate the race condition described here:\n', '    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    require ((_value == 0) || (allowed[msg.sender][_spender] == 0));\n', '\n', '    allowed[msg.sender][_spender] = _value;\n', '    Approval(msg.sender, _spender, _value);\n', '    return true;\n', '  }\n', '\n', '  /// @dev Token allowance\n', '  /// @param _owner holder address\n', '  /// @param _spender spender address\n', '  /// @return remain amount\n', '  function allowance(address _owner, address _spender) constant public returns (uint remaining) {\n', '    return allowed[_owner][_spender];\n', '  }\n', '}']