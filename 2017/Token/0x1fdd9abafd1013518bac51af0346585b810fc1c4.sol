['pragma solidity ^0.4.8;\n', '/*\n', 'AvatarNetwork Copyright\n', '\n', 'https://avatarnetwork.io\n', 'https://avatar.blue\n', 'https://www.avatar-network.com\n', 'https://www.avatar-bank.com\n', '*/\n', '\n', '/* Родительский контракт */\n', 'contract Owned {\n', '\n', '    /* Адрес владельца контракта*/\n', '    address owner;\n', '\n', '    /* Конструктор контракта, вызывается при первом запуске */\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '        /* Изменить владельца контракта, newOwner - адрес нового владельца */\n', '    function changeOwner(address newOwner) onlyowner {\n', '        owner = newOwner;\n', '    }\n', '\n', '\n', '    /* Модификатор для ограничения доступа к функциям только для владельца */\n', '    modifier onlyowner() {\n', '        if (msg.sender==owner) _;\n', '    }\n', '\n', '    \n', '}\n', '\n', '// Абстрактный контракт для токена стандарта ERC 20\n', '// https://github.com/ethereum/EIPs/issues/20\n', 'contract Token is Owned {\n', '\n', '    /// Общее кол-во токенов\n', '    uint256 public totalSupply;\n', '\n', '    /// @param _owner адрес, с которого будет получен баланс\n', '    /// @return Баланс\n', '    function balanceOf(address _owner) constant returns (uint256 balance);\n', '\n', '    /// @notice Отправить кол-во `_value` токенов на адрес `_to` с адреса `msg.sender`\n', '    /// @param _to Адрес получателя\n', '    /// @param _value Кол-во токенов для отправки\n', '    /// @return Была ли отправка успешной или нет\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice Отправить кол-во `_value` токенов на адрес `_to` с адреса `_from` при условии что это подтверждено отправителем `_from`\n', '    /// @param _from Адрес отправителя\n', '    /// @param _to The address of the recipient\n', '    /// @param _value The amount of token to be transferred\n', '    /// @return Whether the transfer was successful or not\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '\n', '    /// @notice Вызывающий функции `msg.sender` подтверждает что с адреса `_spender` спишется `_value` токенов\n', '    /// @param _spender Адрес аккаунта, с которого возможно списать токены\n', '    /// @param _value Кол-во токенов к подтверждению для отправки\n', '    /// @return Было ли подтверждение успешным или нет\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '\n', '    /// @param _owner Адрес аккаунта владеющего токенами\n', '    /// @param _spender Адрес аккаунта, с которого возможно списать токены\n', '    /// @return Кол-во оставшихся токенов разрешённых для отправки\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', '/*\n', 'Контракт реализует ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n', '*/\n', 'contract ERC20Token is Token\n', '{\n', '\n', '    function transfer(address _to, uint256 _value) returns (bool success)\n', '    {\n', '        //По-умолчанию предполагается, что totalSupply не может быть больше (2^256 - 1).\n', '        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[msg.sender] -= _value;\n', '            balances[_to] += _value;\n', '            Transfer(msg.sender, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success)\n', '    {\n', '        //По-умолчанию предполагается, что totalSupply не может быть больше (2^256 - 1).\n', '        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n', '            balances[_to] += _value;\n', '            balances[_from] -= _value;\n', '            allowed[_from][msg.sender] -= _value;\n', '            Transfer(_from, _to, _value);\n', '            return true;\n', '        } else { return false; }\n', '    }\n', '\n', '    function balanceOf(address _owner) constant returns (uint256 balance)\n', '    {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) returns (bool success)\n', '    {\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining)\n', '    {\n', '      return allowed[_owner][_spender];\n', '    }\n', '\n', '    mapping (address => uint256) balances;\n', '    mapping (address => mapping (address => uint256)) allowed;\n', '}\n', '\n', '/* Основной контракт токена, наследует ERC20Token */\n', 'contract Meridian is ERC20Token\n', '{\n', '\n', '    function ()\n', '    {\n', '        // Если кто то пытается отправить эфир на адрес контракта, то будет вызвана ошибка.\n', '        throw;\n', '    }\n', '\n', '    /* Публичные переменные токена */\n', '    string public name;                 // Название\n', '    uint8 public decimals;              // Сколько десятичных знаков\n', '    string public symbol;               // Идентификатор (трехбуквенный обычно)\n', "    string public version = '1.0';      // Версия\n", '\n', '    function Meridian(\n', '            uint256 _initialAmount,\n', '            string _tokenName,\n', '            uint8 _decimalUnits,\n', '            string _tokenSymbol)\n', '    {\n', '        balances[msg.sender] = _initialAmount;  // Передача создателю всех выпущенных монет\n', '        totalSupply = _initialAmount;\n', '        name = _tokenName;\n', '        decimals = _decimalUnits;\n', '        symbol = _tokenSymbol;\n', '    }\n', '\n', '    \n', '\n', '    \n', '}']