['/* version metahashtoken 0.1.4 RC */\n', 'pragma solidity ^0.4.18;\n', 'contract metahashtoken {\n', '\n', '    /* token settings */\n', '    string public name;             /* token name               */\n', '    string public symbol;           /* token symbol         */\n', '    uint8  public decimals;         /* number of digits after the decimal point      */\n', '    uint   public totalTokens;      /* total amount of tokens  */\n', '    uint   public finalyze;\n', '\n', '    /* token management data */\n', '    address public ownerContract;   /* contract owner       */\n', '    address public owner;           /* owner                */\n', '    \n', '    /* arrays */\n', '    mapping (address => uint256) public balance;                /* array of balance              */\n', '    mapping (address => mapping (address => uint256)) allowed;    /* arrays of allowed transfers  */\n', '    \n', '    /* events */\n', '    event Burn(address indexed from, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    \n', '    /* get the total amount of tokens */\n', '    function totalSupply() public constant returns (uint256 _totalSupply){\n', '        return totalTokens;\n', '    }\n', '    \n', '    /* get the amount of tokens from a particular user */\n', '    function balanceOf(address _owner) public constant returns (uint256 _balance){\n', '        return balance[_owner];\n', '    }\n', '    \n', '    /* transfer tokens */\n', '    function transfer(address _to, uint256 _value) public returns (bool success) {\n', '        address addrSender;\n', '        if (msg.sender == ownerContract){\n', '            /* the message was sent by the owner. it means a bounty program */\n', '            addrSender = ownerContract;\n', '        } else {\n', '            /* transfer between users*/\n', '            addrSender = msg.sender;\n', '        }\n', '        \n', '        /* tokens are not enough */\n', '        if (balance[addrSender] < _value){\n', '            revert();\n', '        }\n', '        \n', '        /* overflow */\n', '        if ((balance[_to] + _value) < balance[_to]){\n', '            revert();\n', '        }\n', '        balance[addrSender] -= _value;\n', '        balance[_to] += _value;\n', '        \n', '        Transfer(addrSender, _to, _value);  \n', '        return true;\n', '    }\n', '    \n', '    /* how many tokens were allowed to send */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '    \n', '    /* Send tokens from the recipient to the recipient */\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){\n', '        var _allowance = allowed[_from][msg.sender];\n', '        \n', '        /* check of allowed value */\n', '        if (_allowance < _value){\n', '            revert();\n', '        }\n', '        \n', '        /* not enough tokens */\n', '        if (balance[_from] < _value){\n', '            revert();\n', '        }\n', '        balance[_to] += _value;\n', '        balance[_from] -= _value;\n', '        allowed[_from][msg.sender] = _allowance - _value;\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /* allow to send tokens between recipients */\n', '    function approve(address _spender, uint256 _value) public returns (bool success){\n', '        allowed[msg.sender][_spender] = _value;\n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    \n', '    /* constructor */\n', '    function metahashtoken() public {\n', "        name = 'BITCOMO';\n", "        symbol = 'BM';\n", '        decimals = 2;\n', '        owner = msg.sender;\n', '        totalTokens = 0; /* when creating a token we do not add them */\n', '        finalyze = 0;\n', '    }\n', '    \n', '    /* set contract owner */\n', '    function setContract(address _ownerContract) public {\n', '        if (msg.sender == owner){\n', '            ownerContract = _ownerContract;\n', '        }\n', '    }\n', '    \n', '    function setOptions(uint256 tokenCreate) public {\n', '        /* set the amount, give the tokens to the contract */\n', '        if ((msg.sender == ownerContract) && (finalyze == 0)){\n', '            totalTokens += tokenCreate;\n', '            balance[ownerContract] += tokenCreate;\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '    \n', '    function burn(uint256 _value) public returns (bool success) {\n', '        if (balance[msg.sender] <= _value){\n', '            revert();\n', '        }\n', '\n', '        balance[msg.sender] -= _value;\n', '        totalTokens -= _value;\n', '        Burn(msg.sender, _value);\n', '        return true;\n', '    }\n', '    \n', '    /* the contract is closed. Either because of the amount reached, or by the deadline. */\n', '    function finalyzeContract() public {\n', '        if (msg.sender != owner){\n', '            revert();\n', '        }\n', '        finalyze = 1;\n', '    }\n', '\n', '}']