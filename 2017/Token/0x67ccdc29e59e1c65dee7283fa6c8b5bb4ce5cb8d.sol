['pragma solidity >=0.4.10;\n', '\n', '/*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    "Owned" to ensure control of contracts\n', '\n', '            Identical to https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', '\n', '    ---------------------------------------------------------------------------------------- */\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    function Owned() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) onlyOwner {\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', '/*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    SafeMath library\n', '\n', '            Identical to https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', '\n', '    ---------------------------------------------------------------------------------------- */\n', 'library SafeMath {\n', '  function safeMul(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function safeDiv(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function safeSub(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    assert(b <= a); // Ensuring no negatives\n', '    return a - b;\n', '  }\n', '\n', '  function safeAdd(uint256 a, uint256 b) internal constant returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a && c>=b);\n', '    return c;\n', '  }\n', '}\n', '\n', '/*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    ESG Asset Holder is called when the token "burn" function is called\n', '\n', '    Sum:    Locked to false so users cannot burn their tokens until the Asset Contract is\n', '            put in place with value.\n', '\n', '    ---------------------------------------------------------------------------------------- */\n', 'contract ESGAssetHolder {\n', '    \n', '    function burn(address _holder, uint _amount) returns (bool result) {\n', '\n', '        _holder = 0x0;                              // To avoid variable not used issue on deployment\n', '        _amount = 0;                                // To avoid variable not used issue on deployment\n', '        return false;\n', '    }\n', '}\n', '\n', '\n', '/*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    The Esports Gold Token:  ERC20 standard token with MINT and BURN functions\n', '\n', '    Func:   Mint, Approve, Transfer, TransferFrom  \n', '\n', '    Note:   Mint function takes UNITS of tokens to mint as ICO event is set to have a minimum\n', '            contribution of 1 token. All other functions (transfer etc), the value to transfer\n', '            is the FULL DECIMAL value\n', '            The user is only ever presented with the latter option, therefore should avoid\n', '            any confusion.\n', '    ---------------------------------------------------------------------------------------- */\n', 'contract ESGToken is Owned {\n', '        \n', '    string public name = "ESG Token";               // Name of token\n', '    string public symbol = "ESG";                   // Token symbol\n', '    uint256 public decimals = 3;                    // Decimals for the token\n', '    uint256 public totalSupply;                   // Current supply of tokens\n', '    uint256 public supplyCap;                       // Hard cap on supply of tokens\n', '    address public ICOcontroller;                   // Controlling contract from ICO\n', '    address public timelockTokens;                  // Address for locked management tokens\n', '    bool public tokenParametersSet;                        // Ensure that parameters required are set\n', '    bool public controllerSet;                             // Ensure that ICO controller is set\n', '\n', '    mapping (address => uint256) public balanceOf;                      // Balances of addresses\n', '    mapping (address => mapping (address => uint)) public allowance;    // Allowances from addresses\n', '    mapping (address => bool) public frozenAccount;                     // Safety mechanism\n', '\n', '\n', '    modifier onlyControllerOrOwner() {            // Ensures that only contracts can manage key functions\n', '        require(msg.sender == ICOcontroller || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Mint(address owner, uint amount);\n', '    event FrozenFunds(address target, bool frozen);\n', '    event Burn(address coinholder, uint amount);\n', '    \n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    Constructor\n', '\n', '    param:  Owner:  Address of owner\n', '            Name:   Esports Gold Token\n', '            Sym:    ESG_TKN\n', '            Dec:    3\n', '            Cap:    Hard coded cap to ensure excess tokens cannot be minted\n', '\n', '    Other parameters have been set up as a separate function to help lower initial gas deployment cost.\n', '\n', '    ---------------------------------------------------------------------------------------- */\n', '    function ESGToken() {\n', '        totalSupply = 0;                      // Starting supply is zero\n', '        supplyCap = 0;                          // Hard cap supply in Tokens set by ICO\n', '        tokenParametersSet = false;             // Ensure parameters are set\n', '        controllerSet = false;                  // Ensure controller is set\n', '    }\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    Key parameters to setup for ICO event\n', '\n', '    Param:  _ico    Address of the ICO Event contract to ensure the ICO event can control\n', '                    the minting function\n', '    \n', '    ---------------------------------------------------------------------------------------- */\n', '    function setICOController(address _ico) onlyOwner {     // ICO event address is locked in\n', '        require(_ico != 0x0);\n', '        ICOcontroller = _ico;\n', '        controllerSet = true;\n', '    }\n', '\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '    NEW\n', '    Dev:    Address for the timelock tokens to be held\n', '\n', '    Param:  _timelockAddr   Address of the timelock contract that will hold the locked tokens\n', '    \n', '    ---------------------------------------------------------------------------------------- */\n', '    function setParameters(address _timelockAddr) onlyOwner {\n', '        require(_timelockAddr != 0x0);\n', '\n', '        timelockTokens = _timelockAddr;\n', '\n', '        tokenParametersSet = true;\n', '    }\n', '\n', '    function parametersAreSet() constant returns (bool) {\n', '        return tokenParametersSet && controllerSet;\n', '    }\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    Set the total number of Tokens that can be minted\n', '\n', '    Param:  _supplyCap  The number of tokens (in whole units) that can be minted. This number then\n', '                        gets increased by the decimal number\n', '   \n', '    ---------------------------------------------------------------------------------------- */\n', '    function setTokenCapInUnits(uint256 _supplyCap) onlyControllerOrOwner {   // Supply cap in UNITS\n', '        assert(_supplyCap > 0);\n', '        \n', '        supplyCap = SafeMath.safeMul(_supplyCap, (10**decimals));\n', '    }\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    Mint the number of tokens for the timelock contract\n', '\n', '    Param:  _mMentTkns  Number of tokens in whole units that need to be locked into the Timelock\n', '    \n', '    ---------------------------------------------------------------------------------------- */\n', '    function mintLockedTokens(uint256 _mMentTkns) onlyControllerOrOwner {\n', '        assert(_mMentTkns > 0);\n', '        assert(tokenParametersSet);\n', '\n', '        mint(timelockTokens, _mMentTkns);  \n', '    }\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    ERC20 protocols\n', '    \n', '    ---------------------------------------------------------------------------------------- */\n', '    function balanceOf(address _owner) constant returns (uint256 balance) {\n', '        return balanceOf[_owner];\n', '    }\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    Mint ESG Tokens by controller\n', '\n', '    Control:            OnlyControllers. ICO event needs to be able to control the minting\n', '                        function\n', '\n', '    Param:  Address     Address for tokens to be minted to\n', '            Amount      Number of tokens to be minted (in whole UNITS. Min minting is 1 token)\n', '                        Minimum ETH contribution in ICO event is 0.01ETH at 100 tokens per ETH\n', '    \n', '    ---------------------------------------------------------------------------------------- */\n', '    function mint(address _address, uint _amount) onlyControllerOrOwner {\n', '        require(_address != 0x0);\n', '        uint256 amount = SafeMath.safeMul(_amount, (10**decimals));             // Tokens minted using unit parameter supplied\n', '\n', "        // Ensure that supplyCap is set and that new tokens don't breach cap\n", '        assert(supplyCap > 0 && amount > 0 && SafeMath.safeAdd(totalSupply, amount) <= supplyCap);\n', '        \n', '        balanceOf[_address] = SafeMath.safeAdd(balanceOf[_address], amount);    // Add tokens to address\n', '        totalSupply = SafeMath.safeAdd(totalSupply, amount);                // Add to supply\n', '        \n', '        Mint(_address, amount);\n', '        Transfer(0x0, _address, amount);\n', '    }\n', '    \n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    ERC20 standard transfer function\n', '\n', '    Param:  _to         Address to send to\n', '            _value      Number of tokens to be sent - in FULL decimal length\n', '    \n', '    Ref:    https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/BasicToken.sol\n', '    ---------------------------------------------------------------------------------------- */\n', '    function transfer(address _to, uint _value) returns (bool success) {\n', '        require(!frozenAccount[msg.sender]);        // Ensure account is not frozen\n', '\n', '        /* \n', '            Update balances from "from" and "to" addresses with the tokens transferred\n', '            safeSub method ensures that address sender has enough tokens to send\n', '        */\n', '        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);    \n', '        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                  \n', '        Transfer(msg.sender, _to, _value);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    ERC20 standard transferFrom function\n', '\n', '    Param:  _from       Address to send from\n', '            _to         Address to send to\n', '            Amount      Number of tokens to be sent - in FULL decimal length\n', '\n', '    ---------------------------------------------------------------------------------------- */\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {   \n', '        require(!frozenAccount[_from]);                         // Check account is not frozen\n', '        \n', '        /* \n', '            Ensure sender has been authorised to send the required number of tokens\n', '        */\n', '        if (allowance[_from][msg.sender] < _value)\n', '            return false;\n', '\n', '        /* \n', '            Update allowance of sender to reflect tokens sent\n', '        */\n', '        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); \n', '\n', '        /* \n', '            Update balances from "from" and "to" addresses with the tokens transferred\n', '            safeSub method ensures that address sender has enough tokens to send\n', '        */\n', '        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);\n', '        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);\n', '\n', '        Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    ERC20 standard approve function\n', '\n', '    Param:  _spender        Address of sender who is approved\n', '            _value          The number of tokens (full decimals) that are approved\n', '\n', '    ---------------------------------------------------------------------------------------- */\n', '    function approve(address _spender, uint256 _value)      // FULL DECIMALS OF TOKENS\n', '        returns (bool success)\n', '    {\n', '        require(!frozenAccount[msg.sender]);                // Check account is not frozen\n', '\n', '        /* Requiring the user to set to zero before resetting to nonzero */\n', '        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) {\n', '           return false;\n', '        }\n', '\n', '        allowance[msg.sender][_spender] = _value;\n', '        \n', '        Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    Function to check the amount of tokens that the owner has allowed the "spender" to\n', '            transfer\n', '\n', '    Param:  _owner          Address of the authoriser who owns the tokens\n', '            _spender        Address of sender who will be authorised to spend the tokens\n', '\n', '    ---------------------------------------------------------------------------------------- */\n', '\n', '    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n', '        return allowance[_owner][_spender];\n', '    }\n', '    \n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    As ESG is aiming to be a regulated betting operator. Regulatory hurdles may require\n', '            this function if an account on the betting platform, using the token, breaches\n', '            a regulatory requirement.\n', '\n', '            ESG can then engage with the account holder to get it unlocked\n', '\n', '            This does not stop the token accruing value from its share of the Asset Contract\n', '\n', '    Param:  _target         Address of account\n', '            _freeze         Boolean to lock/unlock account\n', '\n', '    Ref:    This is a replica of the code as per https://ethereum.org/token\n', '    ---------------------------------------------------------------------------------------- */\n', '    function freezeAccount(address target, bool freeze) onlyOwner {\n', '        frozenAccount[target] = freeze;\n', '        FrozenFunds(target, freeze);\n', '    }\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    Burn function: User is able to burn their token for a share of the ESG Asset Contract\n', '\n', '    Note:   Deployed with the ESG Asset Contract set to false to ensure token holders cannot\n', '            accidentally burn their tokens for zero value\n', '\n', '    Param:  _amount         Number of tokens (full decimals) that should be burnt\n', '\n', '    Ref:    Based on the open source TokenCard Burn function. A copy can be found at\n', '            https://github.com/bokkypoobah/TokenCardICOAnalysis\n', '    ---------------------------------------------------------------------------------------- */\n', '    function burn(uint _amount) returns (bool result) {\n', '\n', '        if (_amount > balanceOf[msg.sender])\n', '            return false;       // If owner has enough to burn\n', '\n', '        /* \n', '            Remove tokens from circulation\n', "            Update sender's balance of tokens\n", '        */\n', '        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _amount);\n', '        totalSupply = SafeMath.safeSub(totalSupply, _amount);\n', '\n', '        // Call burn function\n', '        result = esgAssetHolder.burn(msg.sender, _amount);\n', '        require(result);\n', '\n', '        Burn(msg.sender, _amount);\n', '    }\n', '\n', '    /*  ----------------------------------------------------------------------------------------\n', '\n', '    Dev:    Section of the contract that links to the ESG Asset Contract\n', '\n', '    Note:   Deployed with the ESG Asset Contract set to false to ensure token holders cannot\n', '            accidentally burn their tokens for zero value\n', '\n', '    Param:  _amount         Number of tokens (full decimals) that should be burnt\n', '\n', '    Ref:    Based on the open source TokenCard Burn function. A copy can be found at\n', '            https://github.com/bokkypoobah/TokenCardICOAnalysis\n', '    ---------------------------------------------------------------------------------------- */\n', '\n', '    ESGAssetHolder esgAssetHolder;              // Holds the accumulated asset contract\n', '    bool lockedAssetHolder;                     // Will be locked to stop tokenholder to be upgraded\n', '\n', '    function lockAssetHolder() onlyOwner {      // Locked once deployed\n', '        lockedAssetHolder = true;\n', '    }\n', '\n', '    function setAssetHolder(address _assetAdress) onlyOwner {   // Used to lock in the Asset Contract\n', "        assert(!lockedAssetHolder);             // Check that we haven't locked the asset holder yet\n", '        esgAssetHolder = ESGAssetHolder(_assetAdress);\n', '    }    \n', '}']