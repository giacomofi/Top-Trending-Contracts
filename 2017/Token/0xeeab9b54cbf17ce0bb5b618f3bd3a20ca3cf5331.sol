['pragma solidity ^0.4.16; //YourMomToken\n', '\n', 'contract owned {\t//Defines contract Owner\n', '\taddress public owner;\n', '\n', '\t//Events\n', '\tevent TransferOwnership (address indexed _owner, address indexed _newOwner);\t//Notifies about the ownership transfer\n', '\n', '\t//Constrctor function\n', '\tfunction owned() public {\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tfunction transferOwnership(address newOwner) onlyOwner() public {\n', '\t\tTransferOwnership (owner, newOwner);\n', '\t\towner = newOwner;\n', '\t}\n', '\t\n', '\t//Modifiers\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyPayloadSize(uint size) {\t\t//Mitigates ERC20 Short Address Attack\n', '\t\tassert(msg.data.length >= size + 4);\n', '\t\t_;\n', '\t}\n', '}\n', '\n', '\n', 'contract YourMomToken is owned {\n', '\tmapping (address => uint256) public balanceOf;\t\t//This creates an array with all balances\n', '\tmapping (address => mapping (address => uint256)) public allowance;\t//This creates an array of arrays with adress->adress=value\n', '\tuint256 public totalSupply;\n', '\tstring public name;\n', '\tstring public symbol;\n', '\tuint8 public decimals;\n', '\n', '\t//Events\n', '\tevent Transfer(address indexed from, address indexed to, uint256 value);\t\t//Declaring the event function to help clients like the Ethereum Wallet keep track of activities happening in the contract\n', '\tevent Approval(address indexed _owner, address indexed _spender, uint _value);\t//Notifies clients about the Approval\n', '\tevent Burn(address indexed from, uint256 value);\t\t\t\t\t\t\t\t//This notifies clients about the amount burnt\n', '\n', '\t//Constructor function\n', '\tfunction YourMomToken(string tokenName, string tokenSymbol, uint256 initialSupplyInEther) public {\n', '\t\tname = tokenName;\t\t\t\t\t\t\t\t//Set the name for display purposes\n', '\t\tsymbol = tokenSymbol;\t\t\t\t\t\t\t//Set the symbol for display purposes\n', '\t\tdecimals = 18;\t\t\t\t\t\t\t\t\t//Amount of decimals for display purposes\n', '\t\ttotalSupply = initialSupplyInEther * 10**18;\t//Defines the initial supply as the total supply (in wei)\n', '\t\tbalanceOf[msg.sender] = totalSupply;\t\t\t//Give the creator all initial tokens\n', '\t}\n', '\n', '\t//Call functions\n', '\tfunction name() public constant returns (string) { return name; }\n', '\tfunction symbol() public constant returns (string) { return symbol; }\n', '\tfunction decimals() public constant returns (uint8) { return decimals; }\n', '\tfunction totalSupply() public constant returns (uint256) { return totalSupply; }\n', '\tfunction balanceOf(address _owner) public constant returns (uint256 balance) { return balanceOf[_owner]; }\n', '\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowance[_owner][_spender]; }\n', '\n', "\tfunction transfer(address _to, uint256 _value) onlyPayloadSize (2 * 32) public returns (bool success) {\t//Transfer _value tokens from msg.sender to '_to'\n", "\t\t_transfer(msg.sender, _to, _value);\t\t//Call the _transfer function (internal). Calling it it's cleaner than write two identical functions for 'transfer' and 'transferFrom'\n", '\t\treturn true;\n', '\t}\n', '\n', '\tfunction transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize (3 * 32) public returns (bool success) {\t//Transfer tokens from other address\n', "\t\trequire(_value <= allowance[_from][msg.sender]);\t//Check allowance array, if '_from' has authorized 'msg.sender' spend <= _value\n", "\t\t_transfer(_from, _to, _value);\t\t\t\t\t\t//Send '_value' tokens to '_to' in behalf of '_from'\n", "\t\tallowance[_from][msg.sender] -= _value;\t\t\t\t//Reduce msg.sender's allowance to spend '_from's tokens in '_value'\n", '\t\treturn true;\n', '\t}\n', '\t\n', '\tfunction _transfer(address _from, address _to, uint _value) internal returns (bool success) {\n', '\t\trequire(_to != 0x0);\t\t\t\t\t\t\t\t\t//Prevent transfer to 0x0 address. Use burn() instead\n', '\t\trequire(balanceOf[_from] >= _value);\t\t\t\t\t//Check if the sender has enough\n', '\t\trequire(balanceOf[_to] + _value >= balanceOf[_to]);\t\t//Check for overflows\n', "\t\trequire(_value != 0);\t\t\t\t\t\t\t\t\t//Prevents a transaction of '0' to be executed\n", '\t\trequire(_from != _to);\t\t\t\t\t\t\t\t\t//Prevents sending a transaction to yourself\n', '\t\tbalanceOf[_from] -= _value;\t\t\t\t\t\t\t\t//Subtract from the sender\n', '\t\tbalanceOf[_to] += _value;\t\t\t\t\t\t\t\t//Add the same to the recipient\n', '\t\tTransfer(_from, _to, _value);\t\t\t\t\t\t\t//Notify anyone listening that this transfer took place\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\t//Set allowance for other address\n', '\t\trequire((_value == 0) || (allowance[msg.sender][_spender] == 0));\t\t//Mitigates the approve/transfer attack (race condition)\n', '\t\trequire(_value != allowance[msg.sender][_spender]);\t//Prevents setting allowance for the already setted value\n', '\t\tallowance[msg.sender][_spender] = _value;\t\t\t//Set allowance array\n', '\t\tApproval(msg.sender, _spender, _value);\t\t\t\t//Call the Approval event\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction burn(uint256 _value) public returns (bool success) {\t//Function to destroy tokens\n', '\t\trequire(balanceOf[msg.sender] >= _value);\t\t\t//Check if the targeted balance has enough\n', "\t\trequire(_value != 0);\t\t\t\t\t\t\t\t//Prevents a transaction of '0' to be executed\n", '\t\tbalanceOf[msg.sender] -= _value;\t\t\t\t\t//Subtract from the targeted balance\n', '\t\ttotalSupply -= _value;\t\t\t\t\t\t\t\t//Update totalSupply\n', '\t\tBurn(msg.sender, _value);\t\t\t\t\t\t\t//Call the Event to notice about the burn\n', '\t\treturn true;\n', '\t}\n', '}']