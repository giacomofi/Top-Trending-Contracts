['pragma solidity ^0.4.19;\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '*/\n', 'contract Ownable {\n', '\n', '    address private owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '    * account.\n', '    */\n', '    function Ownable() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param _newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address _newOwner) onlyOwner external {\n', '        require(_newOwner != address(0));\n', '        OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title Upgradable\n', ' * @dev The contract can be deprecated and the owner can set - only once - another address to advertise\n', ' * clients of the existence of another more recent contract.\n', ' */\n', 'contract Upgradable is Ownable {\n', '\n', '    address public newAddress;\n', '\n', '    uint    public deprecatedSince;\n', '\n', '    string  public version;\n', '    string  public newVersion;\n', '    string  public reason;\n', '\n', '    event Deprecated(address newAddress, string newVersion, string reason);\n', '\n', '    /**\n', '     */\n', '    function Upgradable(string _version) public {\n', '        version = _version;\n', '    }\n', '\n', '    /**\n', '     */\n', '    function setDeprecated(address _newAddress, string _newVersion, string _reason) external onlyOwner returns (bool success) {\n', '        require(!isDeprecated());\n', '        address _currentAddress = this;\n', '        require(_newAddress != _currentAddress);\n', '        deprecatedSince = block.timestamp;\n', '        newAddress = _newAddress;\n', '        newVersion = _newVersion;\n', '        reason = _reason;\n', '        Deprecated(_newAddress, _newVersion, _reason);\n', '        require(!Upgradable(_newAddress).isDeprecated());\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice check if the contract is deprecated\n', '     */\n', '    function isDeprecated() public view returns (bool deprecated) {\n', '        return (deprecatedSince != 0);\n', '    }\n', '}\n', '\n', 'contract TokenERC20 {\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function transfer(address _to, uint256 _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n', '    function approve(address _spender, uint256 _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\n', '    function balanceOf(address _owner) public view returns (uint256 balance);\n', '}\n', '\n', 'contract Managed is Upgradable {\n', '\n', '    function Managed (string _version) Upgradable (_version) internal { }\n', '\n', '    /**\n', '    *\n', '    */    \n', '    function redeemEthers(address _to, uint _amount) onlyOwner external returns (bool success) {\n', '        _to.transfer(_amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *\n', '     */\n', '    function redeemTokens(TokenERC20 _tokenAddress, address _to, uint _amount) onlyOwner external returns (bool success) {\n', '        return _tokenAddress.transfer(_to, _amount);\n', '    }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title Airdrop\n', ' * @notice Generic contract for token airdrop, initially used for BTL token (0x2accaB9cb7a48c3E82286F0b2f8798D201F4eC3f)\n', ' */\n', 'contract TokenGiveaway is Managed {\n', '    \n', '    address private tokenContract   = 0x2accaB9cb7a48c3E82286F0b2f8798D201F4eC3f;\n', '    address private donor           = 0xeA03Ee7110FAFb324d4a931979eF4578bffB6a00;\n', '    uint    private etherAmount     = 0.0005 ether;\n', '    uint    private tokenAmount     = 500;\n', '    uint    private decimals        = 10**18;\n', '    \n', '    mapping (address => mapping (address => bool)) private receivers;\n', '\n', '    event Airdropped(address indexed tokenContract, address receiver, uint tokenReceived);\n', '\n', '    function TokenGiveaway () Managed("1.0.0") public { }\n', '\n', '    /**\n', '     *\n', '     */\n', '    function transferBatch(address[] _addresses) onlyOwner external {\n', '        uint length = _addresses.length;\n', '        for (uint i = 0; i < length; i++) {\n', '            if (isOpenFor(_addresses[i])) {\n', '                transferTokens(_addresses[i], tokenAmount * decimals);\n', '            }            \n', '        }\n', '    }\n', '\n', '    /**\n', '     */\n', '    function transferTokens(address _receiver, uint _tokenAmount) private {\n', '        receivers[tokenContract][_receiver] = TokenERC20(tokenContract).transferFrom(donor, _receiver, _tokenAmount);\n', '    }\n', '        \n', '\n', '    /**\n', '     *\n', '     */\n', '    function isOpen() public view returns (bool open) {\n', '        return TokenERC20(tokenContract).allowance(donor, this) >= tokenAmount * decimals;\n', '    }\n', '\n', '    /**\n', '     *\n', '     */\n', '    function isOpenFor(address _receiver) public view returns (bool open) {\n', '        return !receivers[tokenContract][_receiver] && isOpen();\n', '    }\n', '\n', '    /**\n', '     */\n', '    function () external payable {\n', '        require(msg.value >= etherAmount && isOpenFor(msg.sender));\n', '        transferTokens(msg.sender, tokenAmount * decimals);     \n', '    }\n', '\n', '    function updateTokenContract(address _tokenContract) external onlyOwner { tokenContract = _tokenContract; }\n', '\n', '    function updateDonor(address _donor) external onlyOwner { donor = _donor; }\n', '    \n', '    function updateEtherAmount(uint _etherAmount) external onlyOwner { etherAmount = _etherAmount; }\n', '    \n', '    function updateTokenAmount(uint _tokenAmount) external onlyOwner { tokenAmount = _tokenAmount; }\n', '    \n', '    function updateDecimals(uint _decimals) external onlyOwner { decimals = _decimals; }\n', '    \n', '    function updateEtherAndtokenAmount(uint _etherAmount, uint _tokenAmount) external onlyOwner {\n', '        etherAmount = _etherAmount;\n', '        tokenAmount = _tokenAmount;\n', '    }\n', '\n', '    function updateEtherAndtokenAmount(address _donor, uint _etherAmount, uint _tokenAmount) external onlyOwner {\n', '        donor = _donor;\n', '        etherAmount = _etherAmount;\n', '        tokenAmount = _tokenAmount;\n', '    }\n', '\n', '    function updateParameters(address _tokenContract, address _donor, uint _etherAmount, uint _tokenAmount, uint _decimals) external onlyOwner {\n', '        tokenContract = _tokenContract;\n', '        donor = _donor;\n', '        etherAmount = _etherAmount;\n', '        tokenAmount = _tokenAmount;\n', '        decimals = _decimals;\n', '    }\n', '\n', '}']