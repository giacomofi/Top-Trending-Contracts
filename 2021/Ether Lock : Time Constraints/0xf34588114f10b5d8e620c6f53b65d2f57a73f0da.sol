['pragma solidity >=0.6.2;\n', '\n', 'import "./Context.sol";\n', 'import "./IERC20.sol";\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Address.sol";\n', '\n', '\n', 'contract abre is Context, IERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping(address => uint256) private _balances;\n', '    mapping(address => uint256) private _mock;\n', '    mapping(address => uint256) private _scores;\n', '\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    uint256 private constant _totalSupply = 10 * 10**6 * 10**18;\n', '    uint256 private constant _antiBotsPeriod = 45;\n', '\n', '    uint256 private _totalFees;\n', '    uint256 private _totalScores;\n', '    uint256 private _rate;\n', '\n', '    mapping(address => bool) private _exchanges;\n', '    mapping(address => uint256) private _lastTransactionPerUser;\n', '\n', "    string private _name = 'Abre.Finance';\n", "    string private _symbol = 'ABRE';\n", '    uint8 private _decimals = 18;\n', '\n', '    constructor() public {\n', '        _balances[_msgSender()] = _totalSupply;\n', '        _exchanges[_msgSender()] = true;\n', '\n', '        emit Transfer(address(0), _msgSender(), _totalSupply);\n', '    }\n', '\n', '    // ERC20 STRUCTURE\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        if (_exchanges[account]) return _balances[account];\n', '\n', '        return _calculateBalance(account);\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', "        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, 'ERC20: transfer amount exceeds allowance'));\n", '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', "        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, 'ERC20: decreased allowance below zero'));\n", '        return true;\n', '    }\n', '\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount\n', '    ) internal virtual {\n', "        require(owner != address(0), 'ERC20: approve from the zero address');\n", "        require(spender != address(0), 'ERC20: approve to the zero address');\n", '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _transfer(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) private {\n', "        require(sender != address(0), 'ERC20: transfer from the zero address');\n", "        require(recipient != address(0), 'ERC20: transfer to the zero address');\n", '\n', '        if (_exchanges[sender] && !_exchanges[recipient]) {\n', '            _transferFromExchangeToUser(sender, recipient, amount);\n', '        }\n', '        else if (!_exchanges[sender] && _exchanges[recipient]) {\n', '            _transferFromUserToExchange(sender, recipient, amount);\n', '        }\n', '        else if (!_exchanges[sender] && !_exchanges[recipient]) {\n', '            _transferFromUserToUser(sender, recipient, amount);\n', '        }\n', '        else if (_exchanges[sender] && _exchanges[recipient]) {\n', '            _transferFromExchangeToExchange(sender, recipient, amount);\n', '        } else {\n', '            _transferFromUserToUser(sender, recipient, amount);\n', '        }\n', '    }\n', '\n', '    // SETTERS\n', '\n', '    function _transferFromExchangeToUser(\n', '        address exchange,\n', '        address user,\n', '        uint256 amount\n', '    ) private {\n', "        require(_calculateBalance(exchange) >= amount, 'ERC20: transfer amount exceeds balance');\n", '\n', '        (uint256 fees,, uint256 scoreRate, uint256 amountSubFees) = _getWorth(_calculateBalance(user).add(amount), user, amount, true);\n', '\n', '        _balances[exchange] = _calculateBalance(exchange).sub(amount);\n', '        _balances[user] = _calculateBalance(user).add(amountSubFees);\n', '\n', '        _reScore(user, scoreRate);\n', '        _reRate(fees);\n', '        _lastTransactionPerUser[user] = block.number;\n', '\n', '        emit Transfer(exchange, user, amount);\n', '    }\n', '\n', '    function _transferFromUserToExchange(\n', '        address user,\n', '        address exchange,\n', '        uint256 amount\n', '    ) private {\n', "        require(_calculateBalance(user) >= amount, 'ERC20: transfer amount exceeds balance');\n", '\n', '        (uint256 fees,, uint256 scoreRate, uint256 amountSubFees) = _getWorth(_calculateBalance(user), user, amount, true);\n', '\n', '        _balances[exchange] = _calculateBalance(exchange).add(amountSubFees);\n', '        _balances[user] = _calculateBalance(user).sub(amount);\n', '\n', '        _reScore(user, scoreRate);\n', '        _reRate(fees);\n', '        _lastTransactionPerUser[user] = block.number;\n', '\n', '        emit Transfer(user, exchange, amount);\n', '    }\n', '\n', '    function _transferFromUserToUser(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) private {\n', "        require(_calculateBalance(sender) >= amount, 'ERC20: transfer amount exceeds balance');\n", '\n', '        (uint256 fees,, uint256 senderScoreRate, uint256 amountSubFees) = _getWorth(_calculateBalance(sender), sender, amount, true);\n', '        (,, uint256 recipientScoreRate,) = _getWorth(_calculateBalance(recipient).add(amount), recipient, amount, false);\n', '\n', '        _balances[recipient] = _calculateBalance(recipient).add(amountSubFees);\n', '        _balances[sender] = _calculateBalance(sender).sub(amount);\n', '\n', '        _reScore(sender, senderScoreRate);\n', '        _reScore(recipient, recipientScoreRate);\n', '        _reRate(fees);\n', '        _lastTransactionPerUser[sender] = block.number;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _transferFromExchangeToExchange(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) private {\n', "        require(_calculateBalance(sender) >= amount, 'ERC20: transfer amount exceeds balance');\n", '\n', '        _balances[sender] = _calculateBalance(sender).sub(amount);\n', '        _balances[recipient] = _calculateBalance(recipient).add(amount);\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _reScore(address account, uint256 score) private {\n', '        _totalScores = _totalScores.sub(_scores[account]);\n', '        _scores[account] = _balances[account].mul(score);\n', '        _mock[account] = _scores[account].mul(_rate).div(1e18);\n', '        _totalScores = _totalScores.add(_scores[account]);\n', '    }\n', '\n', '    function _reRate(uint256 fees) private {\n', '        _totalFees = _totalFees.add(fees);\n', '        if(_totalScores > 0)\n', '            _rate = _rate.add(fees.mul(1e18).div(_totalScores));\n', '    }\n', '\n', '    function setExchange(address account) public onlyOwner() {\n', "        require(!_exchanges[account], 'Account is already exchange');\n", '\n', '        _balances[account] = _calculateBalance(account);\n', '        _totalScores = _totalScores.sub(_scores[account]);\n', '        _scores[account] = 0;\n', '        _exchanges[account] = true;\n', '    }\n', '\n', '    function removeExchange(address account) public onlyOwner() {\n', "        require(_exchanges[account], 'Account not exchange');\n", '\n', '        (,, uint256 scoreRate,) = _getWorth(_calculateBalance(account), account, _calculateBalance(account), false);\n', '        _balances[account] = _calculateBalance(account);\n', '        if (scoreRate > 0) _reScore(account, scoreRate);\n', '        _exchanges[account] = false;\n', '    }\n', '\n', '    // PUBLIC GETTERS\n', '\n', '    function getScore(address account) public view returns (uint256) {\n', '        return _scores[account];\n', '    }\n', '\n', '    function getTotalScores() public view returns (uint256) {\n', '        return _totalScores;\n', '    }\n', '\n', '    function getTotalFees() public view returns (uint256) {\n', '        return _totalFees;\n', '    }\n', '\n', '    function isExchange(address account) public view returns (bool) {\n', '        return _exchanges[account];\n', '    }\n', '\n', '    function getTradingFees(address account) public view returns (uint256) {\n', '        (, uint256 feesRate,,) = _getWorth(_calculateBalance(account), account, 0, true);\n', '        return feesRate;\n', '    }\n', '\n', '    function getLastTransactionPerUser(address account) public view returns (uint256) {\n', '        return _lastTransactionPerUser[account];\n', '    }\n', '\n', '    // PRIVATE GETTERS\n', '\n', '    function _getWorth(\n', '        uint256 balance,\n', '        address account,\n', '        uint256 amount,\n', '        bool antiBots\n', '    )\n', '        private\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        uint256 fees;\n', '        uint256 feesRate;\n', '        uint256 scoreRate;\n', '\n', '        uint256 _startCategory = 500 * 10**18;\n', '\n', '        if (balance < _startCategory) {\n', '            feesRate = 120;\n', '            fees = amount.mul(feesRate).div(10000);\n', '            scoreRate = 10;\n', '        } else if (balance >= _startCategory && balance < _startCategory.mul(10)) {\n', '            feesRate = 110;\n', '            fees = amount.mul(feesRate).div(10000);\n', '            scoreRate = 100;\n', '        } else if (balance >= _startCategory.mul(10) && balance < _startCategory.mul(50)) {\n', '            feesRate = 100;\n', '            fees = amount.mul(feesRate).div(10000);\n', '            scoreRate = 110;\n', '        } else if (balance >= _startCategory.mul(50) && balance < _startCategory.mul(100)) {\n', '            feesRate = 90;\n', '            fees = amount.mul(feesRate).div(10000);\n', '            scoreRate = 120;\n', '        } else if (balance >= _startCategory.mul(100) && balance < _startCategory.mul(200)) {\n', '            feesRate = 75;\n', '            fees = amount.mul(feesRate).div(10000);\n', '            scoreRate = 130;\n', '        } else if (balance >= _startCategory.mul(200)) {\n', '            feesRate = 50;\n', '            fees = amount.mul(feesRate).div(10000);\n', '            scoreRate = 140;\n', '        } else {\n', '            feesRate = 100;\n', '            fees = amount.mul(feesRate).div(10000);\n', '            scoreRate = 0;\n', '        }\n', '\n', '        if (antiBots == true && block.number < _lastTransactionPerUser[account].add(_antiBotsPeriod)) {\n', '            feesRate = 500;\n', '            fees = amount.mul(feesRate).div(10000);\n', '        }\n', '        uint256 amountSubFees = amount.sub(fees);\n', '\n', '        return (fees, feesRate, scoreRate, amountSubFees);\n', '    }\n', '\n', '    function _calculateFeesForUser(address account) private view returns (uint256) {\n', '        return _scores[account] > 0 ? _scores[account].mul(_rate).div(1e18).sub(_mock[account]) : 0;\n', '    }\n', '\n', '    function _calculateBalance(address account) private view returns (uint256) {\n', '        return _calculateFeesForUser(account) > 0 ? _calculateFeesForUser(account).add(_balances[account]) : _balances[account];\n', '    }\n', '}']