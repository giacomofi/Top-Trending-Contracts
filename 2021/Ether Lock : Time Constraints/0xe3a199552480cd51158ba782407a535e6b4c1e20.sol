['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-12\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'interface UniswapRouter {\n', '    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory);\n', '}\n', '\n', 'interface YCrvGauge {\n', '    function deposit(uint256 amount) external;\n', '    function withdraw(uint256 amount) external;\n', '}\n', '\n', 'interface TokenMinter {\n', '    function mint(address account) external;\n', '}\n', '\n', 'contract Svault {\n', '\n', '    IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    UniswapRouter constant UNIROUTER = UniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '    YCrvGauge constant YCRVGAUGE = YCrvGauge(0xFA712EE4788C042e2B7BB55E6cb8ec569C4530c1);\n', '    TokenMinter constant TOKENMINTER = TokenMinter(0xd061D61a4d941c39E5453435B6345Dc261C2fcE0);\n', '    uint32 constant TOTALRATE = 10000;\n', '    IERC20 constant CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\n', '    \n', '    mapping(address => uint) public rewardedBalancePerUser;\n', '    mapping(address => uint) public lastTimestampPerUser;\n', '    mapping(address => uint) public depositBalancePerUser;\n', '    mapping(address => uint) public accDepositBalancePerUser;\n', '\n', '    uint public lastTotalTimestamp;\n', '    uint public accTotalReward;\n', '    uint public totalDeposit;\n', '    uint public accTotalDeposit;\n', '\n', '    string public vaultName;\n', '    IERC20 public token0;\n', '    IERC20 public token1;\n', '\n', '    address public feeAddress;\n', '\n', '    uint32 public feeRate;\n', '\n', '    address public treasury;\n', '\n', '\n', '    uint32 public rewardUserRate = 7000;\n', '    uint32 public rewardTreasuryRate = 3000;\n', '\n', '    \n', '    address public gov;\n', '\n', '    event Deposited(address indexed user, uint amount);\n', '    event ClaimedReward(address indexed user, uint amount);\n', '    event Withdrawn(address indexed user, uint amount);\n', '\n', '    constructor (address _token0, address _token1, address _feeAddress, string memory name, address _treasury) payable {\n', '        token0 = IERC20(_token0);\n', '        token1 = IERC20(_token1);\n', '        feeAddress = _feeAddress;\n', '        vaultName = name;\n', '        gov = msg.sender;\n', '        treasury = _treasury;\n', '        token0.approve(address(YCRVGAUGE), type(uint).max);\n', '        CRV.approve(address(UNIROUTER), type(uint).max);\n', '    }\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == gov, "!governance");\n', '        _;\n', '    }\n', '\n', '    modifier updateBalance(address userAddress) {\n', '        uint lastTimestamp = lastTimestampPerUser[userAddress];\n', '        uint totalTimestamp = lastTotalTimestamp;\n', '        if (lastTimestamp > 0) {\n', '            accDepositBalancePerUser[userAddress] += depositBalancePerUser[userAddress] * (block.timestamp - lastTimestamp);\n', '        }\n', '\n', '        if (totalTimestamp > 0) {\n', '            accTotalDeposit += totalDeposit * (block.timestamp - totalTimestamp);\n', '        }\n', '        lastTimestampPerUser[userAddress] = block.timestamp;\n', '        lastTotalTimestamp = block.timestamp;\n', '        _;\n', '    }\n', '\n', '    function setGovernance(address _gov)\n', '        external\n', '        onlyGov\n', '    {\n', '        gov = _gov;\n', '    }\n', '\n', '    function setToken0(address _token)\n', '        external\n', '        onlyGov\n', '    {\n', '        token0 = IERC20(_token);\n', '    }\n', '\n', '    function setToken1(address _token)\n', '        external\n', '        onlyGov\n', '    {\n', '        token1 = IERC20(_token);\n', '    }\n', '\n', '    function setTreasury(address _treasury)\n', '        external\n', '        onlyGov\n', '    {\n', '        treasury = _treasury;\n', '    }\n', '\n', '    function setUserRate(uint32 _rewardUserRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        rewardUserRate = _rewardUserRate;\n', '    }\n', '\n', '    function setTreasuryRate(uint32 _rewardTreasuryRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        rewardTreasuryRate = _rewardTreasuryRate;\n', '    }\n', '\n', '    function setFeeAddress(address _feeAddress)\n', '        external\n', '        onlyGov\n', '    {\n', '        feeAddress = _feeAddress;\n', '    }\n', '\n', '    function setFeeRate(uint32 _feeRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        feeRate = _feeRate;\n', '    }\n', '\n', '    function setVaultName(string memory name)\n', '        external\n', '        onlyGov\n', '    {\n', '        vaultName = name;\n', '    }\n', '\n', '    function getReward() internal\n', '    {\n', '        uint rewardAmountForCRVToken = CRV.balanceOf(address(this));\n', '        TOKENMINTER.mint(address(YCRVGAUGE));\n', '        rewardAmountForCRVToken = CRV.balanceOf(address(this)) - rewardAmountForCRVToken;\n', '        uint rewardCRVTokenAmountForUsers = rewardAmountForCRVToken * rewardUserRate / TOTALRATE;\n', '        uint rewardCRVTokenAmountForTreasury = rewardAmountForCRVToken * rewardTreasuryRate / TOTALRATE;\n', '        address[] memory tokens = new address[](3);\n', '        tokens[0] = address(CRV);\n', '        tokens[1] = address(WETH);\n', '        tokens[2] = address(token1);\n', '        address[] memory tokens1 = new address[](2);\n', '        tokens1[0] = address(CRV);\n', '        tokens1[1] = address(WETH);\n', '        uint rewardPylonTokenAmountForUsers = token1.balanceOf(address(this));\n', '        if (rewardCRVTokenAmountForUsers > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(rewardCRVTokenAmountForUsers, 0, tokens, address(this), type(uint).max);\n', '        }\n', '        uint wethBalance = WETH.balanceOf(address(this));\n', '        if (rewardCRVTokenAmountForTreasury > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(rewardCRVTokenAmountForTreasury, 0, tokens1, address(this), type(uint).max);\n', '        }\n', '    \n', '        rewardPylonTokenAmountForUsers = token1.balanceOf(address(this)) - rewardPylonTokenAmountForUsers; // fYCRV -> Pylon   from rewardFarmTokenAmountForUsers\n', '        accTotalReward += rewardPylonTokenAmountForUsers;\n', '        wethBalance = WETH.balanceOf(address(this)) - wethBalance;\n', '        if (wethBalance > 0) {\n', '            WETH.transfer(treasury, wethBalance);\n', '        }\n', '    }\n', '\n', '    function deposit(uint amount) external updateBalance(msg.sender) {\n', '        getReward();\n', '        // minimum fee 0.01%\n', '        uint feeAmount = amount * feeRate / TOTALRATE;\n', '        uint realAmount = amount - feeAmount;\n', '\n', '        if (feeAmount > 0) {\n', '            token0.transferFrom(msg.sender, feeAddress, feeAmount);\n', '        }\n', '        \n', '        if (realAmount > 0) {\n', '            token0.transferFrom(msg.sender, address(this), realAmount);\n', '            YCRVGAUGE.deposit(realAmount);\n', '            depositBalancePerUser[msg.sender] += realAmount;\n', '            totalDeposit += realAmount;\n', '            emit Deposited(msg.sender, realAmount);\n', '        }\n', '    }\n', '\n', '    function withdraw(uint amount) external updateBalance(msg.sender) {\n', '        getReward();\n', '        uint depositBalance = depositBalancePerUser[msg.sender];\n', '        if (amount > depositBalance) {\n', '            amount = depositBalance;\n', '        }\n', '        uint amountWithdrawForYCRV = token0.balanceOf(address(this));\n', '        YCRVGAUGE.withdraw(amount);\n', '        amountWithdrawForYCRV = token0.balanceOf(address(this)) - amountWithdrawForYCRV;\n', '        token0.transfer(msg.sender, amountWithdrawForYCRV);\n', '        \n', '        depositBalancePerUser[msg.sender] = depositBalance - amountWithdrawForYCRV;\n', '        totalDeposit -= amountWithdrawForYCRV;\n', '\n', '        emit Withdrawn(msg.sender, amountWithdrawForYCRV);\n', '    }\n', '\n', '    function claimReward() external updateBalance(msg.sender) {\n', '        getReward();\n', '\n', '        uint reward = 0;\n', '        uint currentRewardAmount = accTotalReward * accDepositBalancePerUser[msg.sender] / accTotalDeposit;\n', '        uint rewardedAmount = rewardedBalancePerUser[msg.sender];\n', '        if (currentRewardAmount > rewardedAmount) {\n', '            reward = currentRewardAmount - rewardedAmount;\n', '            rewardedBalancePerUser[msg.sender] = rewardedAmount + reward;\n', '            uint token1Balance = token1.balanceOf(address(this));\n', '            if (reward > token1Balance) {\n', '                reward = token1Balance;\n', '            }\n', '        }\n', '        if (reward > 0) {\n', '            token1.transfer(msg.sender, reward);\n', '            emit ClaimedReward(msg.sender, reward);\n', '        }\n', '    }\n', '\n', '    function seize(address token, address to) external onlyGov {\n', '        require(IERC20(token) != token1, "main tokens");\n', '        if (token != address(0)) {\n', '            uint amount = IERC20(token).balanceOf(address(this));\n', '            IERC20(token).transfer(to, amount);\n', '        }\n', '        else {\n', '            uint amount = address(this).balance;\n', '            payable(to).transfer(amount);\n', '        }\n', '    }\n', '        \n', '    fallback () external payable { }\n', '    receive () external payable { }\n', '}']