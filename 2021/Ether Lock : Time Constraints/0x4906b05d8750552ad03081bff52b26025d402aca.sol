['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-14\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.12;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'library Address {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract FIXToken is IERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    using Address for address;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    mapping (address => bool) private _isFirstSale;\n', '\n', '    uint256 public constant SECONDS_PER_WEEK = 604800;\n', '\n', '    uint256 private constant PERCENTAGE_MULTIPLICATOR = 1e4;\n', '\n', '    uint8 private constant DEFAULT_DECIMALS = 6;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    uint256 private _firstUpdate;\n', '    uint256 private _lastUpdate;\n', '\n', '    uint256 private _growthRate;\n', '    uint256 private _growthRate_after;\n', '\n', '    uint256 private _price;\n', '\n', '    uint256 private _presaleStart;\n', '    uint256 private _presaleEnd;\n', '\n', '    bool private _isStarted;\n', '\n', '    uint256 [] _zeros;\n', '\n', '    event TokensPurchased(address indexed purchaser, uint256 value, uint256 amount, uint256 price);\n', '    event TokensSold(address indexed seller, uint256 amount, uint256 USDT, uint256 price);\n', '    event PriceUpdated(uint price);\n', '\n', '\n', '    constructor (uint256 _ownerSupply) public {\n', '        _decimals = 18;\n', '        _totalSupply = 500000000 * uint(10) ** _decimals;\n', '        require (_ownerSupply < _totalSupply, "Owner supply must be lower than total supply");\n', '        _name = "ProFIXone Token";\n', '        _symbol = "FIX";\n', '        _price = 1000000;\n', '        _growthRate = 100;\n', '        _balances[address(this)] = _totalSupply.sub(_ownerSupply);\n', '        _balances[owner()] = _ownerSupply;\n', '        emit Transfer(address(0), address(this), _totalSupply.sub(_ownerSupply));\n', '        emit Transfer(address(0), owner(), _ownerSupply);\n', '    }\n', '\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '\n', '    function decimals() public view override returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        if (msg.sender != owner()) {\n', '            require(recipient == owner(), "Tokens can be sent only to owner address.");\n', '        }\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '\n', '    function calculatePrice() public view returns (uint256) {\n', '        if (_isStarted == false || _firstUpdate > now) {\n', '            return _price;\n', '        }\n', '        uint256 i;\n', '        uint256 newPrice = _price;\n', '        if (now > _lastUpdate) {\n', '            i = uint256((_lastUpdate.sub(_firstUpdate)).div(SECONDS_PER_WEEK).add(uint256(1)).sub(_zeros.length));\n', '            for (uint256 x = 0; x < i; x++) {\n', '                newPrice = newPrice.mul(PERCENTAGE_MULTIPLICATOR.add(_growthRate)).div(PERCENTAGE_MULTIPLICATOR);\n', '            }\n', '            if (_growthRate_after > 0) {\n', '                i = uint256((now.sub(_lastUpdate)).div(SECONDS_PER_WEEK));\n', '                for (uint256 x = 0; x < i; x++) {\n', '                    newPrice = newPrice.mul(PERCENTAGE_MULTIPLICATOR.add(_growthRate_after)).div(PERCENTAGE_MULTIPLICATOR);\n', '                }\n', '            }\n', '        } else {\n', '            i = uint256((now.sub(_firstUpdate)).div(SECONDS_PER_WEEK)).add(uint256(1));\n', '            for (uint8 x = 0; x < _zeros.length; x++) {\n', '                if (_zeros[x] >= _firstUpdate && _zeros[x] <= now) {\n', '                    i = i.sub(uint256(1));\n', '                }\n', '            }\n', '            for (uint256 x = 0; x < i; x++) {\n', '                newPrice = newPrice.mul(PERCENTAGE_MULTIPLICATOR.add(_growthRate)).div(PERCENTAGE_MULTIPLICATOR);\n', '            }\n', '\n', '        }\n', '\n', '        return newPrice;\n', '    }\n', '\n', '\n', '    function currentPrice() public view returns (uint256) {\n', '        return calculatePrice();\n', '    }\n', '\n', '    function growthRate() public view returns (uint256) {\n', '        return _growthRate_after;\n', '    }\n', '\n', '\n', '    function isStarted() public view returns (bool) {\n', '        return _isStarted;\n', '    }\n', '\n', '    function presaleStart() public view returns (uint256) {\n', '        return _presaleStart;\n', '    }\n', '\n', '    function presaleEnd() public view returns (uint256) {\n', '        return _presaleEnd;\n', '    }\n', '\n', '\n', '    function startContract(uint256 firstUpdate, uint256 lastUpdate, uint256 [] memory zeros) external onlyOwner {\n', '        require (_isStarted == false, "Contract is already started.");\n', '        require (firstUpdate >= now, "First price update time must be later than today");\n', '        require (lastUpdate >= now, "Last price update time must be later than today");\n', '        require (lastUpdate > firstUpdate, "Last price update time must be later than first update");\n', '        _firstUpdate = firstUpdate;\n', '        _lastUpdate = lastUpdate;\n', '        _isStarted = true;\n', '        for (uint8 x = 0; x < zeros.length; x++) {\n', '            _zeros.push(zeros[x]);\n', '        }\n', '\n', '    }\n', '\n', '    function setPresaleStart(uint256 new_date) external onlyOwner {\n', '        require (_isStarted == true, "Contract is not started.");\n', '        require(new_date >= now, "Start time must be later, than now");\n', '        require(new_date > _presaleStart, "New start time must be higher then previous.");\n', '        _presaleStart = new_date;\n', '    }\n', '\n', '    function setPresaleEnd(uint256 new_date) external onlyOwner {\n', '        require (_isStarted == true, "Contract is not started.");\n', '        require(new_date >= now, "End time must be later, than now");\n', '        require(new_date > _presaleEnd, "New end time must be higher then previous.");\n', '        require(new_date > _presaleStart, "New end time must be higher then start date.");\n', '        _presaleEnd = new_date;\n', '    }\n', '\n', '\n', '    function setGrowthRate(uint256 _newGrowthRate) external onlyOwner {\n', '        require (_isStarted == true, "Contract is not started.");\n', '        require(now > _lastUpdate, "Growth rate cannot be changed within 60 months");\n', '        _growthRate_after =_newGrowthRate;\n', '    }\n', '\n', '\n', '    function calculateTokens(uint256 amount, uint8 coin_decimals, uint256 updatedPrice) public view returns(uint256) {\n', '        uint256 result;\n', '        if (coin_decimals >= DEFAULT_DECIMALS) {\n', '            result = amount.mul(10 ** uint256(_decimals)).div(updatedPrice.mul(10 ** uint256(coin_decimals-DEFAULT_DECIMALS)));\n', '        } else {\n', '            result = amount.mul(10 ** uint256(_decimals)).div(updatedPrice.div(10 ** uint256(DEFAULT_DECIMALS-coin_decimals)));\n', '\n', '        }\n', '        if (now >= _presaleStart && now <= _presaleEnd) {\n', '            if (amount >= uint256(1000).mul(10 ** uint256(coin_decimals))) {\n', '                result.add(100 * uint(10) ** _decimals);\n', '            }\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '\n', '    function sendTokens(address recepient, uint256 amount, uint8 coinDecimals) external onlyOwner {\n', '        require (_isStarted == true, "Contract is not started.");\n', '        require (_presaleStart > 0, "Presale start not set");\n', '        require (_presaleEnd > 0, "Presale end not set");\n', '        require (coinDecimals > 0, "Stablecoin decimals must be grater than 0");\n', '        require (amount > 0, "Stablecoin value cannot be zero.");\n', '        require(recepient != address(0), "ERC20: transfer to the zero address");\n', '        uint256 lastPrice = calculatePrice();\n', '        uint FIXAmount = calculateTokens(amount.mul(99).div(100), coinDecimals, lastPrice);\n', '        require(_balances[address(this)] >= FIXAmount, "Insufficinet FIX amount left on contract");\n', '        _balances[address(this)] = _balances[address(this)].sub(FIXAmount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recepient] = _balances[recepient].add(FIXAmount);\n', '        emit TokensPurchased(recepient, amount, FIXAmount, lastPrice);\n', '        emit Transfer(address(this), recepient, FIXAmount);\n', '\n', '    }\n', '\n', '    function sellTokens(address stablecoin, uint256 amount) external {\n', '        require (_isStarted == true, "Contract is not started.");\n', '        require (_presaleStart > 0, "Presale start not set");\n', '        require (_presaleEnd > 0, "Presale end not set");\n', '        require (amount > 0, "FIX value cannot be zero.");\n', '        require(msg.sender != address(0), "ERC20: transfer to the zero address");\n', '        require(stablecoin != address(0), "Stablecoin must not be zero address");\n', '        require(stablecoin.isContract(), "Not a valid stablecoin contract address");\n', '        uint256 coin_amount;\n', '        uint256 new_amount = amount;\n', '        IERC20 coin = IERC20(stablecoin);\n', '        uint8 coin_decimals = coin.decimals();\n', '        uint256 lastPrice = calculatePrice();\n', '        if (!_isFirstSale[msg.sender]) {\n', '            new_amount = amount.mul(98).div(100);\n', '            _isFirstSale[msg.sender] = true;\n', '        }\n', '        require (_balances[msg.sender] >= amount, "Insufficient FIX token amount");\n', '        if (coin_decimals >= 12) {\n', '            coin_amount = new_amount.div(lastPrice).mul(10 ** uint256(coin_decimals-12));\n', '        } else {\n', '            coin_amount = new_amount.div(lastPrice).div(10 ** uint256(12 - coin_decimals));\n', '        }\n', '\n', '        _balances[address(this)] = _balances[address(this)].add(amount);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '        emit Transfer(msg.sender, address(this), amount);\n', '        emit TokensSold(msg.sender, amount, coin_amount, lastPrice);\n', '    }\n', '\n', '}']