['# @version 0.2.12\n', '"""\n', '@title Liquidity Gauge v3\n', '@author Curve Finance\n', '@license MIT\n', '"""\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', '\n', 'interface CRV20:\n', '    def future_epoch_time_write() -> uint256: nonpayable\n', '    def rate() -> uint256: view\n', '\n', 'interface Controller:\n', '    def period() -> int128: view\n', '    def period_write() -> int128: nonpayable\n', '    def period_timestamp(p: int128) -> uint256: view\n', '    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\n', '    def voting_escrow() -> address: view\n', '    def checkpoint(): nonpayable\n', '    def checkpoint_gauge(addr: address): nonpayable\n', '\n', 'interface Minter:\n', '    def token() -> address: view\n', '    def controller() -> address: view\n', '    def minted(user: address, gauge: address) -> uint256: view\n', '\n', 'interface VotingEscrow:\n', '    def user_point_epoch(addr: address) -> uint256: view\n', '    def user_point_history__ts(addr: address, epoch: uint256) -> uint256: view\n', '\n', 'interface ERC20Extended:\n', '    def symbol() -> String[26]: view\n', '\n', '\n', 'event Deposit:\n', '    provider: indexed(address)\n', '    value: uint256\n', '\n', 'event Withdraw:\n', '    provider: indexed(address)\n', '    value: uint256\n', '\n', 'event UpdateLiquidityLimit:\n', '    user: address\n', '    original_balance: uint256\n', '    original_supply: uint256\n', '    working_balance: uint256\n', '    working_supply: uint256\n', '\n', 'event CommitOwnership:\n', '    admin: address\n', '\n', 'event ApplyOwnership:\n', '    admin: address\n', '\n', 'event Transfer:\n', '    _from: indexed(address)\n', '    _to: indexed(address)\n', '    _value: uint256\n', '\n', 'event Approval:\n', '    _owner: indexed(address)\n', '    _spender: indexed(address)\n', '    _value: uint256\n', '\n', '\n', 'MAX_REWARDS: constant(uint256) = 8\n', 'TOKENLESS_PRODUCTION: constant(uint256) = 40\n', 'WEEK: constant(uint256) = 604800\n', 'CLAIM_FREQUENCY: constant(uint256) = 3600\n', '\n', 'minter: public(address)\n', 'crv_token: public(address)\n', 'lp_token: public(address)\n', 'controller: public(address)\n', 'voting_escrow: public(address)\n', 'future_epoch_time: public(uint256)\n', '\n', 'balanceOf: public(HashMap[address, uint256])\n', 'totalSupply: public(uint256)\n', 'allowances: HashMap[address, HashMap[address, uint256]]\n', '\n', 'name: public(String[64])\n', 'symbol: public(String[32])\n', '\n', 'working_balances: public(HashMap[address, uint256])\n', 'working_supply: public(uint256)\n', '\n', '# The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\n', '# All values are kept in units of being multiplied by 1e18\n', 'period: public(int128)\n', 'period_timestamp: public(uint256[100000000000000000000000000000])\n', '\n', '# 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\n', 'integrate_inv_supply: public(uint256[100000000000000000000000000000])  # bump epoch when rate() changes\n', '\n', '# 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\n', 'integrate_inv_supply_of: public(HashMap[address, uint256])\n', 'integrate_checkpoint_of: public(HashMap[address, uint256])\n', '\n', '# ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n', '# Units: rate * t = already number of coins per address to issue\n', 'integrate_fraction: public(HashMap[address, uint256])\n', '\n', 'inflation_rate: public(uint256)\n', '\n', '# For tracking external rewards\n', 'reward_data: uint256\n', 'reward_tokens: public(address[MAX_REWARDS])\n', '\n', '# deposit / withdraw / claim\n', 'reward_sigs: bytes32\n', '\n', '# claimant -> default reward receiver\n', 'rewards_receiver: public(HashMap[address, address])\n', '\n', '# reward token -> integral\n', 'reward_integral: public(HashMap[address, uint256])\n', '\n', '# reward token -> claiming address -> integral\n', 'reward_integral_for: public(HashMap[address, HashMap[address, uint256]])\n', '\n', '# user -> [uint128 claimable amount][uint128 claimed amount]\n', 'claim_data: HashMap[address, HashMap[address, uint256]]\n', '\n', 'admin: public(address)\n', 'future_admin: public(address)  # Can and will be a smart contract\n', 'is_killed: public(bool)\n', '\n', '\n', '@external\n', 'def __init__(_lp_token: address, _minter: address, _admin: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _lp_token Liquidity Pool contract address\n', '    @param _minter Minter contract address\n', '    @param _admin Admin who can kill the gauge\n', '    """\n', '\n', '    symbol: String[26] = ERC20Extended(_lp_token).symbol()\n', '    self.name = concat("Curve.fi ", symbol, " Gauge Deposit")\n', '    self.symbol = concat(symbol, "-gauge")\n', '\n', '    crv_token: address = Minter(_minter).token()\n', '    controller: address = Minter(_minter).controller()\n', '\n', '    self.lp_token = _lp_token\n', '    self.minter = _minter\n', '    self.admin = _admin\n', '    self.crv_token = crv_token\n', '    self.controller = controller\n', '    self.voting_escrow = Controller(controller).voting_escrow()\n', '\n', '    self.period_timestamp[0] = block.timestamp\n', '    self.inflation_rate = CRV20(crv_token).rate()\n', '    self.future_epoch_time = CRV20(crv_token).future_epoch_time_write()\n', '\n', '\n', '@view\n', '@external\n', 'def decimals() -> uint256:\n', '    """\n', '    @notice Get the number of decimals for this token\n', '    @dev Implemented as a view method to reduce gas costs\n', '    @return uint256 decimal places\n', '    """\n', '    return 18\n', '\n', '\n', '@view\n', '@external\n', 'def integrate_checkpoint() -> uint256:\n', '    return self.period_timestamp[self.period]\n', '\n', '\n', '@internal\n', 'def _update_liquidity_limit(addr: address, l: uint256, L: uint256):\n', '    """\n', '    @notice Calculate limits which depend on the amount of CRV token per-user.\n', '            Effectively it calculates working balances to apply amplification\n', '            of CRV production by CRV\n', '    @param addr User address\n', "    @param l User's amount of liquidity (LP tokens)\n", '    @param L Total amount of liquidity (LP tokens)\n', '    """\n', '    # To be called after totalSupply is updated\n', '    _voting_escrow: address = self.voting_escrow\n', '    voting_balance: uint256 = ERC20(_voting_escrow).balanceOf(addr)\n', '    voting_total: uint256 = ERC20(_voting_escrow).totalSupply()\n', '\n', '    lim: uint256 = l * TOKENLESS_PRODUCTION / 100\n', '    if voting_total > 0:\n', '        lim += L * voting_balance / voting_total * (100 - TOKENLESS_PRODUCTION) / 100\n', '\n', '    lim = min(l, lim)\n', '    old_bal: uint256 = self.working_balances[addr]\n', '    self.working_balances[addr] = lim\n', '    _working_supply: uint256 = self.working_supply + lim - old_bal\n', '    self.working_supply = _working_supply\n', '\n', '    log UpdateLiquidityLimit(addr, l, L, lim, _working_supply)\n', '\n', '\n', '@internal\n', 'def _checkpoint_rewards( _user: address, _total_supply: uint256, _claim: bool, _receiver: address):\n', '    """\n', '    @notice Claim pending rewards and checkpoint rewards for a user\n', '    """\n', '    # load reward tokens and integrals into memory\n', '    reward_tokens: address[MAX_REWARDS] = empty(address[MAX_REWARDS])\n', '    reward_integrals: uint256[MAX_REWARDS] = empty(uint256[MAX_REWARDS])\n', '    for i in range(MAX_REWARDS):\n', '        token: address = self.reward_tokens[i]\n', '        if token == ZERO_ADDRESS:\n', '            break\n', '        reward_tokens[i] = token\n', '        reward_integrals[i] = self.reward_integral[token]\n', '\n', '    reward_data: uint256 = self.reward_data\n', '    if _total_supply != 0 and reward_data != 0 and block.timestamp > shift(reward_data, -160) + CLAIM_FREQUENCY:\n', '        # track balances prior to claiming\n', '        reward_balances: uint256[MAX_REWARDS] = empty(uint256[MAX_REWARDS])\n', '        for i in range(MAX_REWARDS):\n', '            token: address = self.reward_tokens[i]\n', '            if token == ZERO_ADDRESS:\n', '                break\n', '            reward_balances[i] = ERC20(token).balanceOf(self)\n', '\n', '        # claim from reward contract\n', '        reward_contract: address = convert(reward_data % 2**160, address)\n', '        raw_call(reward_contract, slice(self.reward_sigs, 8, 4))  # dev: bad claim sig\n', '        self.reward_data = convert(reward_contract, uint256) + shift(block.timestamp, 160)\n', '\n', '        # get balances after claim and calculate new reward integrals\n', '        for i in range(MAX_REWARDS):\n', '            token: address = reward_tokens[i]\n', '            if token == ZERO_ADDRESS:\n', '                break\n', '            dI: uint256 = 10**18 * (ERC20(token).balanceOf(self) - reward_balances[i]) / _total_supply\n', '            if dI > 0:\n', '                reward_integrals[i] += dI\n', '                self.reward_integral[token] = reward_integrals[i]\n', '\n', '    if _user != ZERO_ADDRESS:\n', '        user_balance: uint256 = self.balanceOf[_user]\n', '        receiver: address = _receiver\n', '        if _claim and _receiver == ZERO_ADDRESS:\n', '            # if receiver is not explicitly declared, check if a default receiver is set\n', '            receiver = self.rewards_receiver[_user]\n', '            if receiver == ZERO_ADDRESS:\n', '                # if no default receiver is set, direct claims to the user\n', '                receiver = _user\n', '\n', '        # calculate new user reward integral and transfer any owed rewards\n', '        for i in range(MAX_REWARDS):\n', '            token: address = reward_tokens[i]\n', '            if token == ZERO_ADDRESS:\n', '                break\n', '\n', '            integral: uint256 = reward_integrals[i]\n', '            integral_for: uint256 = self.reward_integral_for[token][_user]\n', '            if integral_for < integral or _total_supply == 0:\n', '                self.reward_integral_for[token][_user] = integral\n', '                claim_data: uint256 = self.claim_data[_user][token]\n', '\n', '                new_claimable: uint256 = user_balance * (integral - integral_for) / 10**18\n', '\n', '                total_claimed: uint256 = claim_data % 2**128\n', '                total_claimable: uint256 = shift(claim_data, -128) + new_claimable\n', '\n', '                if _claim and total_claimable > 0:\n', '                    response: Bytes[32] = raw_call(\n', '                        token,\n', '                        concat(\n', '                            method_id("transfer(address,uint256)"),\n', '                            convert(receiver, bytes32),\n', '                            convert(total_claimable, bytes32),\n', '                        ),\n', '                        max_outsize=32,\n', '                    )\n', '                    if len(response) != 0:\n', '                        assert convert(response, bool)\n', '                    self.claim_data[_user][token] = total_claimed + total_claimable\n', '                elif new_claimable > 0:\n', '                    self.claim_data[_user][token] = total_claimed + shift(total_claimable, 128)\n', '\n', '\n', '@internal\n', 'def _checkpoint(addr: address):\n', '    """\n', '    @notice Checkpoint for a user\n', '    @param addr User address\n', '    """\n', '    _period: int128 = self.period\n', '    _period_time: uint256 = self.period_timestamp[_period]\n', '    _integrate_inv_supply: uint256 = self.integrate_inv_supply[_period]\n', '    rate: uint256 = self.inflation_rate\n', '    new_rate: uint256 = rate\n', '    prev_future_epoch: uint256 = self.future_epoch_time\n', '    if prev_future_epoch >= _period_time:\n', '        _token: address = self.crv_token\n', '        self.future_epoch_time = CRV20(_token).future_epoch_time_write()\n', '        new_rate = CRV20(_token).rate()\n', '        self.inflation_rate = new_rate\n', '\n', '    if self.is_killed:\n', '        # Stop distributing inflation as soon as killed\n', '        rate = 0\n', '\n', '    # Update integral of 1/supply\n', '    if block.timestamp > _period_time:\n', '        _working_supply: uint256 = self.working_supply\n', '        _controller: address = self.controller\n', '        Controller(_controller).checkpoint_gauge(self)\n', '        prev_week_time: uint256 = _period_time\n', '        week_time: uint256 = min((_period_time + WEEK) / WEEK * WEEK, block.timestamp)\n', '\n', '        for i in range(500):\n', '            dt: uint256 = week_time - prev_week_time\n', '            w: uint256 = Controller(_controller).gauge_relative_weight(self, prev_week_time / WEEK * WEEK)\n', '\n', '            if _working_supply > 0:\n', '                if prev_future_epoch >= prev_week_time and prev_future_epoch < week_time:\n', '                    # If we went across one or multiple epochs, apply the rate\n', '                    # of the first epoch until it ends, and then the rate of\n', '                    # the last epoch.\n', '                    # If more than one epoch is crossed - the gauge gets less,\n', "                    # but that'd meen it wasn't called for more than 1 year\n", '                    _integrate_inv_supply += rate * w * (prev_future_epoch - prev_week_time) / _working_supply\n', '                    rate = new_rate\n', '                    _integrate_inv_supply += rate * w * (week_time - prev_future_epoch) / _working_supply\n', '                else:\n', '                    _integrate_inv_supply += rate * w * dt / _working_supply\n', '                # On precisions of the calculation\n', '                # rate ~= 10e18\n', '                # last_weight > 0.01 * 1e18 = 1e16 (if pool weight is 1%)\n', '                # _working_supply ~= TVL * 1e18 ~= 1e26 ($100M for example)\n', '                # The largest loss is at dt = 1\n', '                # Loss is 1e-9 - acceptable\n', '\n', '            if week_time == block.timestamp:\n', '                break\n', '            prev_week_time = week_time\n', '            week_time = min(week_time + WEEK, block.timestamp)\n', '\n', '    _period += 1\n', '    self.period = _period\n', '    self.period_timestamp[_period] = block.timestamp\n', '    self.integrate_inv_supply[_period] = _integrate_inv_supply\n', '\n', '    # Update user-specific integrals\n', '    _working_balance: uint256 = self.working_balances[addr]\n', '    self.integrate_fraction[addr] += _working_balance * (_integrate_inv_supply - self.integrate_inv_supply_of[addr]) / 10 ** 18\n', '    self.integrate_inv_supply_of[addr] = _integrate_inv_supply\n', '    self.integrate_checkpoint_of[addr] = block.timestamp\n', '\n', '\n', '@external\n', 'def user_checkpoint(addr: address) -> bool:\n', '    """\n', '    @notice Record a checkpoint for `addr`\n', '    @param addr User address\n', '    @return bool success\n', '    """\n', '    assert (msg.sender == addr) or (msg.sender == self.minter)  # dev: unauthorized\n', '    self._checkpoint(addr)\n', '    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n', '    return True\n', '\n', '\n', '@external\n', 'def claimable_tokens(addr: address) -> uint256:\n', '    """\n', '    @notice Get the number of claimable tokens per user\n', '    @dev This function should be manually changed to "view" in the ABI\n', '    @return uint256 number of claimable tokens per user\n', '    """\n', '    self._checkpoint(addr)\n', '    return self.integrate_fraction[addr] - Minter(self.minter).minted(addr, self)\n', '\n', '\n', '@view\n', '@external\n', 'def reward_contract() -> address:\n', '    """\n', '    @notice Address of the reward contract providing non-CRV incentives for this gauge\n', '    @dev Returns `ZERO_ADDRESS` if there is no reward contract active\n', '    """\n', '    return convert(self.reward_data % 2**160, address)\n', '\n', '\n', '@view\n', '@external\n', 'def last_claim() -> uint256:\n', '    """\n', '    @notice Epoch timestamp of the last call to claim from `reward_contract`\n', '    @dev Rewards are claimed at most once per hour in order to reduce gas costs\n', '    """\n', '    return shift(self.reward_data, -160)\n', '\n', '\n', '@view\n', '@external\n', 'def claimed_reward(_addr: address, _token: address) -> uint256:\n', '    """\n', '    @notice Get the number of already-claimed reward tokens for a user\n', '    @param _addr Account to get reward amount for\n', '    @param _token Token to get reward amount for\n', '    @return uint256 Total amount of `_token` already claimed by `_addr`\n', '    """\n', '    return self.claim_data[_addr][_token] % 2**128\n', '\n', '\n', '@view\n', '@external\n', 'def claimable_reward(_addr: address, _token: address) -> uint256:\n', '    """\n', '    @notice Get the number of claimable reward tokens for a user\n', '    @dev This call does not consider pending claimable amount in `reward_contract`.\n', '         Off-chain callers should instead use `claimable_rewards_write` as a\n', '         view method.\n', '    @param _addr Account to get reward amount for\n', '    @param _token Token to get reward amount for\n', '    @return uint256 Claimable reward token amount\n', '    """\n', '    return shift(self.claim_data[_addr][_token], -128)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def claimable_reward_write(_addr: address, _token: address) -> uint256:\n', '    """\n', '    @notice Get the number of claimable reward tokens for a user\n', '    @dev This function should be manually changed to "view" in the ABI\n', '         Calling it via a transaction will claim available reward tokens\n', '    @param _addr Account to get reward amount for\n', '    @param _token Token to get reward amount for\n', '    @return uint256 Claimable reward token amount\n', '    """\n', '    if self.reward_tokens[0] != ZERO_ADDRESS:\n', '        self._checkpoint_rewards(_addr, self.totalSupply, False, ZERO_ADDRESS)\n', '    return shift(self.claim_data[_addr][_token], -128)\n', '\n', '\n', '@external\n', 'def set_rewards_receiver(_receiver: address):\n', '    """\n', '    @notice Set the default reward receiver for the caller.\n', '    @dev When set to ZERO_ADDRESS, rewards are sent to the caller\n', '    @param _receiver Receiver address for any rewards claimed via `claim_rewards`\n', '    """\n', '    self.rewards_receiver[msg.sender] = _receiver\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def claim_rewards(_addr: address = msg.sender, _receiver: address = ZERO_ADDRESS):\n', '    """\n', '    @notice Claim available reward tokens for `_addr`\n', '    @param _addr Address to claim for\n', '    @param _receiver Address to transfer rewards to - if set to\n', '                     ZERO_ADDRESS, uses the default reward receiver\n', '                     for the caller\n', '    """\n', '    if _receiver != ZERO_ADDRESS:\n', '        assert _addr == msg.sender  # dev: cannot redirect when claiming for another user\n', '    self._checkpoint_rewards(_addr, self.totalSupply, True, _receiver)\n', '\n', '\n', '@external\n', 'def kick(addr: address):\n', '    """\n', '    @notice Kick `addr` for abusing their boost\n', '    @dev Only if either they had another voting event, or their voting escrow lock expired\n', '    @param addr Address to kick\n', '    """\n', '    _voting_escrow: address = self.voting_escrow\n', '    t_last: uint256 = self.integrate_checkpoint_of[addr]\n', '    t_ve: uint256 = VotingEscrow(_voting_escrow).user_point_history__ts(\n', '        addr, VotingEscrow(_voting_escrow).user_point_epoch(addr)\n', '    )\n', '    _balance: uint256 = self.balanceOf[addr]\n', '\n', '    assert ERC20(self.voting_escrow).balanceOf(addr) == 0 or t_ve > t_last # dev: kick not allowed\n', '    assert self.working_balances[addr] > _balance * TOKENLESS_PRODUCTION / 100  # dev: kick not needed\n', '\n', '    self._checkpoint(addr)\n', '    self._update_liquidity_limit(addr, self.balanceOf[addr], self.totalSupply)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def deposit(_value: uint256, _addr: address = msg.sender, _claim_rewards: bool = False):\n', '    """\n', '    @notice Deposit `_value` LP tokens\n', '    @dev Depositting also claims pending reward tokens\n', '    @param _value Number of tokens to deposit\n', '    @param _addr Address to deposit for\n', '    """\n', '\n', '    self._checkpoint(_addr)\n', '\n', '    if _value != 0:\n', '        is_rewards: bool = self.reward_tokens[0] != ZERO_ADDRESS\n', '        total_supply: uint256 = self.totalSupply\n', '        if is_rewards:\n', '            self._checkpoint_rewards(_addr, total_supply, _claim_rewards, ZERO_ADDRESS)\n', '\n', '        total_supply += _value\n', '        new_balance: uint256 = self.balanceOf[_addr] + _value\n', '        self.balanceOf[_addr] = new_balance\n', '        self.totalSupply = total_supply\n', '\n', '        self._update_liquidity_limit(_addr, new_balance, total_supply)\n', '\n', '        ERC20(self.lp_token).transferFrom(msg.sender, self, _value)\n', '        if is_rewards:\n', '            deposit_sig: Bytes[4] = slice(self.reward_sigs, 0, 4)\n', '            if convert(deposit_sig, uint256) != 0:\n', '                raw_call(\n', '                    convert(self.reward_data % 2**160, address),\n', '                    concat(deposit_sig, convert(_value, bytes32))\n', '                )\n', '\n', '    log Deposit(_addr, _value)\n', '    log Transfer(ZERO_ADDRESS, _addr, _value)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def withdraw(_value: uint256, _claim_rewards: bool = False):\n', '    """\n', '    @notice Withdraw `_value` LP tokens\n', '    @dev Withdrawing also claims pending reward tokens\n', '    @param _value Number of tokens to withdraw\n', '    """\n', '    self._checkpoint(msg.sender)\n', '\n', '    if _value != 0:\n', '        is_rewards: bool = self.reward_tokens[0] != ZERO_ADDRESS\n', '        total_supply: uint256 = self.totalSupply\n', '        if is_rewards:\n', '            self._checkpoint_rewards(msg.sender, total_supply, _claim_rewards, ZERO_ADDRESS)\n', '\n', '        total_supply -= _value\n', '        new_balance: uint256 = self.balanceOf[msg.sender] - _value\n', '        self.balanceOf[msg.sender] = new_balance\n', '        self.totalSupply = total_supply\n', '\n', '        self._update_liquidity_limit(msg.sender, new_balance, total_supply)\n', '\n', '        if is_rewards:\n', '            withdraw_sig: Bytes[4] = slice(self.reward_sigs, 4, 4)\n', '            if convert(withdraw_sig, uint256) != 0:\n', '                raw_call(\n', '                    convert(self.reward_data % 2**160, address),\n', '                    concat(withdraw_sig, convert(_value, bytes32))\n', '                )\n', '        ERC20(self.lp_token).transfer(msg.sender, _value)\n', '\n', '    log Withdraw(msg.sender, _value)\n', '    log Transfer(msg.sender, ZERO_ADDRESS, _value)\n', '\n', '\n', '@view\n', '@external\n', 'def allowance(_owner : address, _spender : address) -> uint256:\n', '    """\n', '    @notice Check the amount of tokens that an owner allowed to a spender\n', '    @param _owner The address which owns the funds\n', '    @param _spender The address which will spend the funds\n', '    @return uint256 Amount of tokens still available for the spender\n', '    """\n', '    return self.allowances[_owner][_spender]\n', '\n', '\n', '@internal\n', 'def _transfer(_from: address, _to: address, _value: uint256):\n', '    self._checkpoint(_from)\n', '    self._checkpoint(_to)\n', '\n', '    if _value != 0:\n', '        total_supply: uint256 = self.totalSupply\n', '        is_rewards: bool = self.reward_tokens[0] != ZERO_ADDRESS\n', '        if is_rewards:\n', '            self._checkpoint_rewards(_from, total_supply, False, ZERO_ADDRESS)\n', '        new_balance: uint256 = self.balanceOf[_from] - _value\n', '        self.balanceOf[_from] = new_balance\n', '        self._update_liquidity_limit(_from, new_balance, total_supply)\n', '\n', '        if is_rewards:\n', '            self._checkpoint_rewards(_to, total_supply, False, ZERO_ADDRESS)\n', '        new_balance = self.balanceOf[_to] + _value\n', '        self.balanceOf[_to] = new_balance\n', '        self._update_liquidity_limit(_to, new_balance, total_supply)\n', '\n', '    log Transfer(_from, _to, _value)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def transfer(_to : address, _value : uint256) -> bool:\n', '    """\n', '    @notice Transfer token for a specified address\n', '    @dev Transferring claims pending reward tokens for the sender and receiver\n', '    @param _to The address to transfer to.\n', '    @param _value The amount to be transferred.\n', '    """\n', '    self._transfer(msg.sender, _to, _value)\n', '\n', '    return True\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def transferFrom(_from : address, _to : address, _value : uint256) -> bool:\n', '    """\n', '     @notice Transfer tokens from one address to another.\n', '     @dev Transferring claims pending reward tokens for the sender and receiver\n', '     @param _from address The address which you want to send tokens from\n', '     @param _to address The address which you want to transfer to\n', '     @param _value uint256 the amount of tokens to be transferred\n', '    """\n', '    _allowance: uint256 = self.allowances[_from][msg.sender]\n', '    if _allowance != MAX_UINT256:\n', '        self.allowances[_from][msg.sender] = _allowance - _value\n', '\n', '    self._transfer(_from, _to, _value)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def approve(_spender : address, _value : uint256) -> bool:\n', '    """\n', '    @notice Approve the passed address to transfer the specified amount of\n', '            tokens on behalf of msg.sender\n', '    @dev Beware that changing an allowance via this method brings the risk\n', '         that someone may use both the old and new allowance by unfortunate\n', '         transaction ordering. This may be mitigated with the use of\n', '         {incraseAllowance} and {decreaseAllowance}.\n', '         https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param _spender The address which will transfer the funds\n', '    @param _value The amount of tokens that may be transferred\n', '    @return bool success\n', '    """\n', '    self.allowances[msg.sender][_spender] = _value\n', '    log Approval(msg.sender, _spender, _value)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def increaseAllowance(_spender: address, _added_value: uint256) -> bool:\n', '    """\n', '    @notice Increase the allowance granted to `_spender` by the caller\n', '    @dev This is alternative to {approve} that can be used as a mitigation for\n', '         the potential race condition\n', '    @param _spender The address which will transfer the funds\n', '    @param _added_value The amount of to increase the allowance\n', '    @return bool success\n', '    """\n', '    allowance: uint256 = self.allowances[msg.sender][_spender] + _added_value\n', '    self.allowances[msg.sender][_spender] = allowance\n', '\n', '    log Approval(msg.sender, _spender, allowance)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def decreaseAllowance(_spender: address, _subtracted_value: uint256) -> bool:\n', '    """\n', '    @notice Decrease the allowance granted to `_spender` by the caller\n', '    @dev This is alternative to {approve} that can be used as a mitigation for\n', '         the potential race condition\n', '    @param _spender The address which will transfer the funds\n', '    @param _subtracted_value The amount of to decrease the allowance\n', '    @return bool success\n', '    """\n', '    allowance: uint256 = self.allowances[msg.sender][_spender] - _subtracted_value\n', '    self.allowances[msg.sender][_spender] = allowance\n', '\n', '    log Approval(msg.sender, _spender, allowance)\n', '\n', '    return True\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def set_rewards(_reward_contract: address, _sigs: bytes32, _reward_tokens: address[MAX_REWARDS]):\n', '    """\n', '    @notice Set the active reward contract\n', '    @dev A reward contract cannot be set while this contract has no deposits\n', '    @param _reward_contract Reward contract address. Set to ZERO_ADDRESS to\n', '                            disable staking.\n', '    @param _sigs Four byte selectors for staking, withdrawing and claiming,\n', '                 right padded with zero bytes. If the reward contract can\n', '                 be claimed from but does not require staking, the staking\n', '                 and withdraw selectors should be set to 0x00\n', '    @param _reward_tokens List of claimable reward tokens. New reward tokens\n', '                          may be added but they cannot be removed. When calling\n', '                          this function to unset or modify a reward contract,\n', '                          this array must begin with the already-set reward\n', '                          token addresses.\n', '    """\n', '    assert msg.sender == self.admin\n', '\n', '    lp_token: address = self.lp_token\n', '    current_reward_contract: address = convert(self.reward_data % 2**160, address)\n', '    total_supply: uint256 = self.totalSupply\n', '    if self.reward_tokens[0] != ZERO_ADDRESS:\n', '        self._checkpoint_rewards(ZERO_ADDRESS, total_supply, False, ZERO_ADDRESS)\n', '    if current_reward_contract != ZERO_ADDRESS:\n', '        withdraw_sig: Bytes[4] = slice(self.reward_sigs, 4, 4)\n', '        if convert(withdraw_sig, uint256) != 0:\n', '            if total_supply != 0:\n', '                raw_call(\n', '                    current_reward_contract,\n', '                    concat(withdraw_sig, convert(total_supply, bytes32))\n', '                )\n', '            ERC20(lp_token).approve(current_reward_contract, 0)\n', '\n', '    if _reward_contract != ZERO_ADDRESS:\n', '        assert _reward_tokens[0] != ZERO_ADDRESS  # dev: no reward token\n', '        assert _reward_contract.is_contract  # dev: not a contract\n', '        deposit_sig: Bytes[4] = slice(_sigs, 0, 4)\n', '        withdraw_sig: Bytes[4] = slice(_sigs, 4, 4)\n', '\n', '        if convert(deposit_sig, uint256) != 0:\n', '            # need a non-zero total supply to verify the sigs\n', '            assert total_supply != 0  # dev: zero total supply\n', '            ERC20(lp_token).approve(_reward_contract, MAX_UINT256)\n', '\n', '            # it would be Very Bad if we get the signatures wrong here, so\n', '            # we do a test deposit and withdrawal prior to setting them\n', '            raw_call(\n', '                _reward_contract,\n', '                concat(deposit_sig, convert(total_supply, bytes32))\n', '            )  # dev: failed deposit\n', '            assert ERC20(lp_token).balanceOf(self) == 0\n', '            raw_call(\n', '                _reward_contract,\n', '                concat(withdraw_sig, convert(total_supply, bytes32))\n', '            )  # dev: failed withdraw\n', '            assert ERC20(lp_token).balanceOf(self) == total_supply\n', '\n', '            # deposit and withdraw are good, time to make the actual deposit\n', '            raw_call(\n', '                _reward_contract,\n', '                concat(deposit_sig, convert(total_supply, bytes32))\n', '            )\n', '        else:\n', '            assert convert(withdraw_sig, uint256) == 0  # dev: withdraw without deposit\n', '\n', '    self.reward_data = convert(_reward_contract, uint256)\n', '    self.reward_sigs = _sigs\n', '    for i in range(MAX_REWARDS):\n', '        current_token: address = self.reward_tokens[i]\n', '        new_token: address = _reward_tokens[i]\n', '        if current_token != ZERO_ADDRESS:\n', '            assert current_token == new_token  # dev: cannot modify existing reward token\n', '        elif new_token != ZERO_ADDRESS:\n', '            # store new reward token\n', '            self.reward_tokens[i] = new_token\n', '        else:\n', '            break\n', '\n', '    if _reward_contract != ZERO_ADDRESS:\n', '        # do an initial checkpoint to verify that claims are working\n', '        self._checkpoint_rewards(ZERO_ADDRESS, total_supply, False, ZERO_ADDRESS)\n', '\n', '\n', '@external\n', 'def set_killed(_is_killed: bool):\n', '    """\n', '    @notice Set the killed status for this contract\n', '    @dev When killed, the gauge always yields a rate of 0 and so cannot mint CRV\n', '    @param _is_killed Killed status to set\n', '    """\n', '    assert msg.sender == self.admin\n', '\n', '    self.is_killed = _is_killed\n', '\n', '\n', '@external\n', 'def commit_transfer_ownership(addr: address):\n', '    """\n', '    @notice Transfer ownership of GaugeController to `addr`\n', '    @param addr Address to have ownership transferred to\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '\n', '    self.future_admin = addr\n', '    log CommitOwnership(addr)\n', '\n', '\n', '@external\n', 'def accept_transfer_ownership():\n', '    """\n', '    @notice Accept a pending ownership transfer\n', '    """\n', '    _admin: address = self.future_admin\n', '    assert msg.sender == _admin  # dev: future admin only\n', '\n', '    self.admin = _admin\n', '    log ApplyOwnership(_admin)']