['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-02\n', '*/\n', '\n', '/**                  ____ \n', "                  .'* *.'\n", '               __/_*_*(_\n', '              / _______ \\\n', '             _\\_)/___\\(_/_ \n', '            / _((\\- -/))_ \\\n', '            \\ \\())(-)(()/ /\n', "             ' \\(((()))/ '\n", "            / ' \\)).))/ ' \\\n", '           / _ \\ - | - /_  \\\n', "          (   ( .;''';. .'  )\n", '          _\\"__ /    )\\ __"/_\n', "            \\/  \\   ' /  \\/\n", "             .'  '...' ' )\n", '              / /  |  \\ \\\n', '             / .   .   . \\\n', '            /   .     .   \\\n', '           /   /   |   \\   \\\n', "         .'   /    b    '.  '.\n", "     _.-'    /     Bb     '-. '-._ \n", " _.-'       |      BBb       '-.  '-. \n", '(___________\\____.dBBBb.________)____)\n', '    \n', '╔╦╗┌─┐┌─┐┬┌─┐  ╔╗ ┌─┐┬  ┌─┐┌┐┌┌─┐┌─┐┬─┐\n', '║║║├─┤│ ┬││    ╠╩╗├─┤│  ├─┤││││  ├┤ ├┬┘\n', '╩ ╩┴ ┴└─┘┴└─┘  ╚═╝┴ ┴┴─┘┴ ┴┘└┘└─┘└─┘┴└─\n', '     https://magicbalancer.org/\n', '     \n', '*/\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.7.6;\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', ' function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address payable owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() {\n', '    owner = payable(msg.sender);\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address payable newOwner) onlyOwner public {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', 'interface MGBToken {\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function balanceOf(address _owner) external returns (uint256 balance);\n', '    function mint(address wallet, address buyer, uint256 tokenAmount) external;\n', '    function showMyTokenBalance(address addr) external;\n', '}\n', '\n', 'contract Presale is Ownable {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '  \n', '    mapping(address=>uint256) public ownerAddresses;  \n', '    mapping(address=>uint256) public BuyerList;\n', '    address public _burnaddress = 0x000000000000000000000000000000000000dEaD;\n', '    address payable[] owners;\n', '\n', '    uint256 public MAX_BUY_LIMIT = 3000000000000000000;\n', '    uint256 public majorOwnerShares = 100;\n', '    uint public    referralReward = 10;\n', '    uint256 public coinPercentage = 56;\n', '    uint256 public rate = 999;\n', '    uint256 public weiRaised;\n', '  \n', '    bool public isPresaleStopped = false;\n', '  \n', '    bool public isPresalePaused = false;\n', '    \n', '    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\n', '    event Transfered(address indexed purchaser, address indexed referral, uint256 amount);\n', '\n', '  \n', '    MGBToken public token;\n', '    \n', '    \n', '    constructor(address payable _walletMajorOwner) \n', '    {\n', '        token = MGBToken(0xF4f3d6A60765bF705B27716f50FccBa5F0eA0CA1); \n', '        startTime = 1614340592 ;   \n', '        endTime = startTime + 90 days;\n', '        require(endTime >= startTime);\n', '        require(_walletMajorOwner != address(0));\n', '        \n', '        ownerAddresses[_walletMajorOwner] = majorOwnerShares;\n', '        \n', '        owners.push(_walletMajorOwner);\n', '        \n', '        owner = _walletMajorOwner;\n', '    }\n', '    \n', '    fallback() external payable {\n', '        buy(msg.sender, owner);\n', '    }\n', '    \n', '    receive() external payable {}\n', '    \n', '    function isContract(address _addr) public view returns (bool _isContract){\n', '        uint32 size;\n', '        assembly {\n', '        size := extcodesize(_addr)}\n', '        \n', '        return (size > 0);\n', '    }\n', '    \n', '    function buy(address beneficiary, address payable referral) public payable\n', '    {\n', "        require (isPresaleStopped != true, 'Presale is stopped');\n", "        require (isPresalePaused != true, 'Presale is paused');\n", "        require ( !(isContract(msg.sender)), 'Bots not allowed');\n", "        require(beneficiary != address(0), 'user asking for tokens sent to be on 0 address');\n", "        require(validPurchase(), 'its not a valid purchase');\n", "        require(BuyerList[msg.sender] < MAX_BUY_LIMIT, 'MAX_BUY_LIMIT Achieved already for this wallet');\n", '        uint256 weiAmount = msg.value;\n', "        require(weiAmount <3000000000000000001 , 'MAX_BUY_LIMIT is 3 ETH'); \n", '        uint256 tokens = weiAmount.mul(rate);\n', '        \n', '        uint256 weiMinusfee = msg.value - (msg.value * referralReward / 100);\n', '        uint256 refReward = msg.value * referralReward / 100;\n', '        \n', '        weiRaised = weiRaised.add(weiAmount);\n', '        splitFunds(referral, refReward);\n', '        \n', '        token.transfer(beneficiary,tokens);\n', '         uint partnerCoins = tokens.mul(coinPercentage);\n', '        partnerCoins = partnerCoins.div(100);\n', '        \n', '        BuyerList[msg.sender] = BuyerList[msg.sender].add(msg.value);\n', '        \n', '        emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);\n', '\n', '        forwardFunds(partnerCoins, weiMinusfee);\n', '    }\n', '    \n', '    function splitFunds(address payable _b, uint256 amount) internal {\n', '\n', '        _b.transfer(amount);\n', '        \n', '         emit Transfered(msg.sender, _b, amount);\n', '    }\n', '    \n', '    function forwardFunds(uint256 partnerTokenAmount, uint256 weiMinusfee) internal {\n', '      for (uint i=0;i<owners.length;i++)\n', '      {\n', '         uint percent = ownerAddresses[owners[i]];\n', '         uint amountToBeSent = weiMinusfee.mul(percent);\n', '         amountToBeSent = amountToBeSent.div(100);\n', '         owners[i].transfer(amountToBeSent);\n', '         \n', '         if (owners[i]!=owner &&  ownerAddresses[owners[i]]>0)\n', '         {\n', '             token.transfer(owners[i],partnerTokenAmount);\n', '         }\n', '      }\n', '    }\n', ' \n', '    function addLiquidityPool(address payable partner) public onlyOwner {\n', '\n', '        require(partner != address(0));\n', '        require(ownerAddresses[owner] >=78);\n', '        require(ownerAddresses[partner] == 0);\n', '        owners.push(partner);\n', '        ownerAddresses[partner] = 78;\n', '        uint majorOwnerShare = ownerAddresses[owner];\n', '        ownerAddresses[owner] = majorOwnerShare.sub(78);\n', '    }\n', '\n', '    function validPurchase() internal returns (bool) {\n', '        bool withinPeriod = block.timestamp >= startTime && block.timestamp <= endTime;\n', '        bool nonZeroPurchase = msg.value != 0;\n', '        return withinPeriod && nonZeroPurchase;\n', '    }\n', '\n', '    function hasEnded() public view returns (bool) {\n', '        return block.timestamp > endTime;\n', '    }\n', '  \n', '    function showMyTokenBalance(address myAddress) public returns (uint256 tokenBalance) {\n', '       tokenBalance = token.balanceOf(myAddress);\n', '    }\n', '\n', '    function setEndDate(uint256 daysToEndFromToday) public onlyOwner returns(bool) {\n', '        daysToEndFromToday = daysToEndFromToday * 1 days;\n', '        endTime = block.timestamp + daysToEndFromToday;\n', '        return true;\n', '    }\n', '\n', '    function setPriceRate(uint256 newPrice) public onlyOwner returns (bool) {\n', '        rate = newPrice;\n', '         return true;\n', '    }\n', '    \n', '    function setReferralReward(uint256 newReward) public onlyOwner returns (bool) {\n', '        referralReward = newReward;\n', '         return true;\n', '    }\n', '\n', '    function pausePresale() public onlyOwner returns(bool) {\n', '        isPresalePaused = true;\n', '         return isPresalePaused;\n', '    }\n', '\n', '    function resumePresale() public onlyOwner returns (bool) {\n', '        isPresalePaused = false;\n', '        return !isPresalePaused;\n', '    }\n', '\n', '    function stopPresale() public onlyOwner returns (bool) {\n', '        isPresaleStopped = true;\n', '        return true;\n', '    }\n', '    function BurnUnsoldTokens() public onlyOwner {\n', '        uint256 unsold = token.balanceOf(address(this));\n', '        token.transfer(_burnaddress,unsold);\n', '    }\n', '    \n', '    function startPresale() public onlyOwner returns (bool) {\n', '        isPresaleStopped = false;\n', '        startTime = block.timestamp; \n', '        return true;\n', '    }\n', '    \n', '    function tokensRemainingForSale(address contractAddress) public returns (uint balance) {\n', '        balance = token.balanceOf(contractAddress);\n', '    }\n', '\n', '    function checkOwnerShare (address owner) public view onlyOwner returns (uint) {\n', '        uint share = ownerAddresses[owner];\n', '        return share;\n', '    }\n', '}']