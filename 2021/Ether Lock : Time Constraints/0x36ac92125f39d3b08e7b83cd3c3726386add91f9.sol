['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-28\n', '*/\n', '\n', '/**\n', '*\n', "*  d88    8bP    d8888P'                   ’8b8        ’8b8\n", "*  88P'   88P  d88                         ’8b8        ’8b8\n", "*  d88'   88P d88                          ’8b8        ’8b8\n", '*  ?88888d88’ d88     dd8888P     d8888b   ’8b8    8b8P’8b8            \n', "*  88P   88P  d8P      8P 8P   d8P'   ?88  ,8b8  d8b.  ’8b8\n", '*  d88   88P  d8P     8P  8P   88b    d88  ,8b8  d88b. ’8b8\n', "*  d88'  88P   d8P88P88   8P   `?8888P’.   ,8b8   d88bP88b8\n", '*                                                                                                \n', '*\n', '* \n', '* SmartWay HGold\n', '* https://www.holly.gold/\n', '* (only for HGold members)\n', '* \n', '**/\n', '\n', '\n', 'pragma solidity >=0.4.22 <0.6.0;\n', '\n', '\n', '\n', 'library SafeMath {\n', '    \n', '    function mul(uint a, uint b) internal pure returns(uint) {\n', '        uint c = a * b;\n', '        require(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns(uint) {\n', '        require(b > 0);\n', '        uint c = a / b;\n', '        require(a == b * c + a % b);\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns(uint) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint a, uint b) internal pure returns(uint) {\n', '        uint c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '    function max64(uint64 a, uint64 b) internal pure returns(uint64) {\n', '        return a >= b ? a: b;\n', '    }\n', '    function min64(uint64 a, uint64 b) internal pure returns(uint64) {\n', '        return a < b ? a: b;\n', '    }\n', '    function max256(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return a >= b ? a: b;\n', '    }\n', '    function min256(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return a < b ? a: b;\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public  returns (uint);\n', '    function balanceOf(address tokenOwner) public returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public  returns (uint remaining);\n', '    function transfer(address to, uint tokens) public returns (bool success);\n', '    function approve(address spender, uint tokens) public returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '\n', 'contract HGoldStaking90Contract {\n', '     /****\n', '     *\n', '     *This value is staking reword and lock days\n', '     *     \n', '     ****/\n', '     int constant stakingDays = 90;\n', '     int constant reward = 25000;\n', '     int calcDays = 0;\n', '     \n', '     /**\n', '     * @notice We usually require to know who are all the stakeholders.\n', '     */\n', '    address[] internal stakeholders;\n', '     \n', '     mapping (address => bool) public allowedTokens;\n', '     mapping (address => address) public Mediator;\n', '     \n', '     modifier isValidToken(address _tokenAddr){\n', '        require(allowedTokens[_tokenAddr]);\n', '        _;\n', '    }\n', '    modifier isMediator(address _tokenAddr){\n', '        require(Mediator[_tokenAddr] == msg.sender);\n', '        _;\n', '    }\n', '    \n', '      /**\n', '    * @dev add approved token address to the mapping \n', '    */\n', '    \n', '    function addToken( address _tokenAddr) external {\n', '        allowedTokens[_tokenAddr] = true;\n', '    }\n', '    \n', '    /**\n', '    * @dev remove approved token address from the mapping \n', '    */\n', '    function removeToken( address _tokenAddr) external {\n', '        allowedTokens[_tokenAddr] = false;\n', '    }\n', '    \n', '    address ContractOwner = 0xAbfb22cEA4034a7d5B5B2A2a707578c60a3097bb;\n', '    \n', '    address public owner;\n', '    mapping(address => Member) public users;\n', '    mapping(uint => Member) public userIds;\n', '    uint public contractFeedBack = 8;\n', '    uint private userCount;\n', '    \n', '     struct Member {\n', '        uint member_id;\n', '        address member_address;\n', '\t\tuint referrer_id;\n', '        address referrer_address;\n', '    }\n', '    \n', '    \n', '    constructor() public { \n', '        owner = msg.sender;\n', '    }\n', '    \n', '    \n', '    function transfer(address token,uint coin) public {\n', '        // add the deposited coin into existing balance \n', '        // transfer the coin from the sender to this contract\n', '        //ERC20(token).transferFrom(msg.sender, address(this), coin);\n', '        address receiver =  ContractOwner;\n', '        ERC20(token).transfer(receiver, coin);\n', '    }\n', '    \n', '    function parseAddr(string memory _a) internal pure returns (address _parsedAddress) {\n', '        bytes memory tmp = bytes(_a);\n', '        uint160 iaddr = 0;\n', '        uint160 b1;\n', '        uint160 b2;\n', '        for (uint i = 2; i < 2 + 2 * 20; i += 2) {\n', '            iaddr *= 256;\n', '            b1 = uint160(uint8(tmp[i]));\n', '            b2 = uint160(uint8(tmp[i + 1]));\n', '            if ((b1 >= 97) && (b1 <= 102)) {\n', '                b1 -= 87;\n', '            } else if ((b1 >= 65) && (b1 <= 70)) {\n', '                b1 -= 55;\n', '            } else if ((b1 >= 48) && (b1 <= 57)) {\n', '                b1 -= 48;\n', '            }\n', '            if ((b2 >= 97) && (b2 <= 102)) {\n', '                b2 -= 87;\n', '            } else if ((b2 >= 65) && (b2 <= 70)) {\n', '                b2 -= 55;\n', '            } else if ((b2 >= 48) && (b2 <= 57)) {\n', '                b2 -= 48;\n', '            }\n', '            iaddr += (b1 * 16 + b2);\n', '        }\n', '        return address(iaddr);\n', '    }\n', '    \n', '    \n', '    struct stakingInfo {\n', '        uint amount;\n', '        bool requested;\n', '        uint releaseDate;\n', '    }\n', '    mapping (address => mapping(address => stakingInfo)) public StakeMap; //tokenAddr to user to stake amount\n', '    mapping (address => mapping(address => uint)) public userCummRewardPerStake; //tokenAddr to user to remaining claimable amount per stake\n', '    mapping (address => uint) public tokenCummRewardPerStake; //tokenAddr to cummulative per token reward since the beginning or time\n', '    mapping (address => uint) public tokenTotalStaked; //tokenAddr to total token claimed \n', '    \n', '    function stake(uint _amount, address _tokenAddr) isValidToken(_tokenAddr) external returns (bool){\n', '            require(_amount != 0);\n', '            //require(ERC20(StakeTokenAddr).transferFrom(msg.sender,this,_amount));\n', '            int feedbackReward = 0;\n', '            if (stakingDays < 90){\n', '                calcDays++;\n', '            }\n', '            else{\n', '               feedbackReward = reward;\n', '            }\n', '            \n', '            if (StakeMap[_tokenAddr][msg.sender].amount ==0){\n', '                StakeMap[_tokenAddr][msg.sender].amount = _amount;\n', '                userCummRewardPerStake[_tokenAddr][msg.sender] = tokenCummRewardPerStake[_tokenAddr];\n', '                return false;\n', '            }else{\n', '              \n', '                StakeMap[_tokenAddr][msg.sender].amount = _amount;\n', '           \n', '                return true;\n', '            }\n', '    }\n', '  \n', '    function initWithdraw(address _tokenAddr) isValidToken(_tokenAddr)  external returns (bool){\n', '        require(StakeMap[_tokenAddr][msg.sender].amount >0 );\n', '        require(! StakeMap[_tokenAddr][msg.sender].requested );\n', '        StakeMap[_tokenAddr][msg.sender].releaseDate = now + 4 weeks;\n', '        return true;\n', '\n', '    }\n', '    \n', '     /**\n', '    * @notice The accumulated rewards for each stakeholder.\n', '    */\n', '   mapping(address => uint256) internal rewards;\n', '  \n', '   /**\n', '    * @notice A method to allow a stakeholder to check his rewards.\n', '    * @param _stakeholder The stakeholder to check rewards for.\n', '    */\n', '   function rewardOf(address _stakeholder)\n', '       public\n', '       view\n', '       returns(uint256)\n', '   {\n', '       return rewards[_stakeholder];\n', '   }\n', '\n', '   /**\n', '    * @notice A method to the aggregated rewards from all stakeholders.\n', '    * @return uint256 The aggregated rewards from all stakeholders.\n', '    */\n', '   function totalRewards()\n', '       public\n', '       view\n', '       returns(uint256)\n', '   {\n', '       uint256 _totalRewards = 0;\n', '       for (uint256 s = 0; s < stakeholders.length; s += 1){\n', '           _totalRewards = rewards[stakeholders[s]];\n', '       }\n', '       return _totalRewards;\n', '   }\n', '    \n', '}']