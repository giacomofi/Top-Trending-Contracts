['pragma solidity ^0.4.18;\n', '\n', 'import "./EchoToken.sol";\n', '\n', '\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '\n', '  constructor() public {\n', '\n', '    owner = msg.sender;\n', '\n', '  }\n', '\n', '\n', '  modifier onlyOwner() {\n', '\n', '    require(msg.sender == owner);\n', '\n', '    _;\n', '\n', '  }\n', '\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '\n', '    require(newOwner != address(0));\n', '\n', '    emit OwnershipTransferred(owner, newOwner);\n', '\n', '    owner = newOwner;\n', '\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', 'contract EchoTokenLock is Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', ' \n', '    address public firstReserveWallet = 0xc6f2b171ce9c0d53dfEbE6428346895204345EE6;\n', '\n', '    address public secondReserveWallet = 0x456EF4ecfe42f3351D0006E9E219131022BC2700;\n', '    \n', '    address public fiveReserveWallet = 0x849b8168aD6F255A23c87b8B059231Cf74f6C976;\n', '    \n', '    address public sixReserveWallet = 0x9bEE59F321Ef10bCF7A1B5B87E22c32273544157;\n', '\n', '    address public sevenReserveWallet = 0xbB2e9ACBa084Ae0d804cBAA81776318199416E35;\n', '\n', '    address public eightReserveWallet = 0xec510cff20247E2b2A89ADfb7420d6361F07D32C;\n', '\n', '\n', '    uint256 public firstReserveAllocation = 3 * (10 ** 7) * (10 ** 18);\n', '\n', '    uint256 public secondReserveAllocation = 2 * (10 ** 7) * (10 ** 18);\n', '    \n', '    uint256 public fiveReserveAllocation = 5 * (10 ** 8) * (10 ** 18);\n', '\n', '    uint256 public sixReserveAllocation = 1 * (10 ** 7) * (10 ** 18);\n', '\n', '    uint256 public sevenReserveAllocation = 2 * (10 ** 7) * (10 ** 18);\n', '\n', '    uint256 public eightReserveAllocation = 2 * (10 ** 7) * (10 ** 18);\n', '\n', '    \n', '    uint256 public totalAllocation = 6 * (10 ** 8) * (10 ** 18);\n', '\n', '    \n', '\n', '    uint256 public firstReserveTimeLock = 4 * 365 days;\n', '    uint256 public firstLockStages = 4;\n', '\n', ' \n', '    uint256 public secondReserveTimeLock = 10 * 365 days;\n', '    uint256 public secondLockStages = 10;\n', '    \n', '   \n', '    uint256 public fiveReserveTimeLock = 5 * 365 days;\n', '    uint256 public fiveLockStages = 1;\n', '    \n', '\n', '    uint256 public sixReserveTimeLock = 2 * 365 days;\n', '    uint256 public sixLockStages = 4;\n', '    \n', '\n', '    uint256 public sevenReserveTimeLock = 2 * 365 days;\n', '    uint256 public sevenLockStages = 4;\n', '\n', '  \n', '    uint256 public eightReserveTimeLock = 2 * 365 days;\n', '    uint256 public eightLockStages = 4;\n', '    \n', '\n', '    \n', '\n', '\n', '    mapping(address => uint256) public vestingStages; \n', '    \n', '\n', '\n', '    mapping(address => uint256) public lockedLockStages;  \n', '    \n', '\n', '\n', '    mapping(address => uint256) public allocations;  \n', '\n', '\n', '\n', '    mapping(address => uint256) public timeLocks; \n', '    \n', '    mapping(address => uint256) public nextTimeLocks;  \n', '\n', '    \n', '\n', '    mapping(address => uint256) public claimed;  \n', '\n', '\n', '\n', '    uint256 public lockedAt = 0;\n', '\n', '    EchoToken public token;\n', '\n', '\n', '\n', '    event Allocated(address wallet, uint256 value);\n', '\n', '  \n', '\n', '    event Distributed(address wallet, uint256 value);\n', '\n', ' \n', '\n', '    event Locked(uint256 lockTime);\n', '\n', '   \n', '\n', '    modifier onlyReserveWallets {  \n', '\n', '        require(allocations[msg.sender] > 0);\n', '\n', '        _;\n', '\n', '    }\n', '\n', '\n', '\n', '\n', '    modifier onlyFirstReserve {\n', '    \n', '        require(msg.sender == firstReserveWallet || msg.sender == secondReserveWallet || msg.sender == fiveReserveWallet || msg.sender == sixReserveWallet || msg.sender == sevenReserveWallet || msg.sender == eightReserveWallet);\n', '\n', '        require(allocations[msg.sender] > 0);\n', '\n', '        _;\n', '        \n', '    }\n', '   \n', '\n', '  \n', '\n', '    modifier notLocked {  // 未锁定\n', '\n', '        require(lockedAt == 0);\n', '\n', '        _;\n', '\n', '    }\n', '\n', '    modifier locked { // 锁定\n', '\n', '        require(lockedAt > 0);\n', '\n', '        _;\n', '\n', '    }\n', '\n', '   \n', '\n', '    modifier notAllocated {  \n', '\n', '        require(allocations[firstReserveWallet] == 0);\n', '\n', '        require(allocations[secondReserveWallet] == 0);\n', '        \n', '        require(allocations[fiveReserveWallet] == 0);\n', '\n', '        require(allocations[sixReserveWallet] == 0);\n', '        \n', '        require(allocations[sevenReserveWallet] == 0);\n', '        \n', '        require(allocations[eightReserveWallet] == 0);\n', '\n', '        _;\n', '\n', '    }\n', '\n', '    constructor(ERC20 _token) public {  \n', '\n', '        owner = msg.sender; \n', '\n', '        token = EchoToken(_token);\n', '\n', '    }\n', '\n', '    function allocate() public notLocked notAllocated onlyOwner { \n', '\n', '        //Makes sure Token Contract has the exact number of tokens\n', '\n', '        require(token.balanceOf(address(this)) == totalAllocation, "TokenLock: Makes sure Token Contract has the exact number of tokens"); \n', '\n', '        allocations[firstReserveWallet] = firstReserveAllocation;\n', '\n', '        allocations[secondReserveWallet] = secondReserveAllocation;\n', '\n', '        allocations[fiveReserveWallet] = fiveReserveAllocation;\n', '        \n', '        allocations[sixReserveWallet] = sixReserveAllocation;\n', '\n', '        allocations[sevenReserveWallet] = sevenReserveAllocation;\n', '\n', '        allocations[eightReserveWallet] = eightReserveAllocation;\n', '        \n', '        \n', '        emit Allocated(firstReserveWallet, firstReserveAllocation);\n', '\n', '        emit Allocated(secondReserveWallet, secondReserveAllocation);\n', '\n', '        emit Allocated(fiveReserveWallet, fiveReserveAllocation);\n', '        \n', '        emit Allocated(sixReserveWallet, sixReserveAllocation);\n', '\n', '        emit Allocated(sevenReserveWallet, sevenReserveAllocation);\n', '\n', '        emit Allocated(eightReserveWallet, eightReserveAllocation);\n', '\n', '        lock();\n', '\n', '    }\n', '\n', '    function getlockedLockStage(address reserveWallet) public view  returns(uint256){\n', '\n', '        uint256 vestingStage = vestingStages[reserveWallet];\n', '        uint256 reserveTimeLock = timeLocks[reserveWallet];\n', '        uint256 vestingMonths = reserveTimeLock.div(vestingStage);\n', '        \n', '        return vestingMonths;\n', '\n', '    }\n', '\n', '    function lock() internal notLocked onlyOwner {\n', '        \n', '        vestingStages[firstReserveWallet] = firstLockStages;\n', '\n', '        vestingStages[secondReserveWallet] = secondLockStages;\n', '\n', '        vestingStages[fiveReserveWallet] = fiveLockStages;\n', '        \n', '        vestingStages[sixReserveWallet] = sixLockStages;\n', '\n', '        vestingStages[sevenReserveWallet] = sevenLockStages;\n', '\n', '        vestingStages[eightReserveWallet] = eightLockStages;\n', '        \n', '        \n', '        timeLocks[firstReserveWallet] = firstReserveTimeLock;\n', '\n', '        timeLocks[secondReserveWallet] = secondReserveTimeLock;\n', '        \n', '        timeLocks[fiveReserveWallet] = fiveReserveTimeLock;\n', '\n', '        timeLocks[sixReserveWallet] = sixReserveTimeLock;\n', '\n', '        timeLocks[sevenReserveWallet] = sevenReserveTimeLock;\n', '\n', '        timeLocks[eightReserveWallet] = eightReserveTimeLock;\n', '        \n', '        \n', '        lockedAt = block.timestamp; // 区块当前时间\n', '                \n', '        nextTimeLocks[firstReserveWallet] = lockedAt.add(getlockedLockStage(firstReserveWallet));\n', '\n', '        nextTimeLocks[secondReserveWallet] = lockedAt.add(getlockedLockStage(secondReserveWallet));\n', '        \n', '        nextTimeLocks[fiveReserveWallet] = lockedAt.add(getlockedLockStage(fiveReserveWallet));\n', '\n', '        nextTimeLocks[sixReserveWallet] = lockedAt.add(getlockedLockStage(sixReserveWallet));\n', '\n', '        nextTimeLocks[sevenReserveWallet] = lockedAt.add(getlockedLockStage(sevenReserveWallet));\n', '\n', '        nextTimeLocks[eightReserveWallet] = lockedAt.add(getlockedLockStage(eightReserveWallet));\n', '        \n', '\n', '        emit Locked(lockedAt);\n', '\n', '    }\n', '    \n', '\n', '    function recoverFailedLock() external notLocked notAllocated onlyOwner {\n', '\n', '       \n', '\n', '        require(token.transfer(owner, token.balanceOf(address(this))));\n', '\n', '    }\n', '\n', '   \n', '\n', '    function getTotalBalance() public view returns (uint256 tokensCurrentlyInVault) {\n', '\n', '        return token.balanceOf(address(this));\n', '\n', '    }\n', '\n', '    // Number of tokens that are still locked\n', '\n', '    function getLockedBalance() public view onlyReserveWallets returns (uint256 tokensLocked) {\n', '\n', '        return allocations[msg.sender].sub(claimed[msg.sender]); \n', '\n', '    }\n', '    \n', '    \n', '    function claimFirstReserve() onlyFirstReserve locked public {\n', '        \n', '        address reserveWallet = msg.sender;\n', '        uint256 nextTime = nextTimeLocks[reserveWallet];\n', '        \n', "        // Can't claim before Lock ends\n", '        require(block.timestamp >= nextTime, "TokenLock: release time is before current time"); \n', '\n', '        uint256 payment = allocations[reserveWallet].div(vestingStages[reserveWallet]); // 总的解锁量\n', '        require(payment <= allocations[reserveWallet], "TokenLock: no enough tokens to reserve");\n', '        \n', '        uint256 totalLocked = claimed[reserveWallet].add(payment);\n', '        require(totalLocked <= allocations[reserveWallet], "TokenLock: total release exceeded"); \n', '\n', '        claimed[reserveWallet] = totalLocked;\n', '        nextTimeLocks[reserveWallet] = nextTime.add(getlockedLockStage(reserveWallet));\n', '        \n', '        require(token.transfer(reserveWallet, payment), "TokenLock: transfer failed"); \n', '        \n', '        emit Distributed(reserveWallet, payment);\n', '       \n', '    }\n', '}']