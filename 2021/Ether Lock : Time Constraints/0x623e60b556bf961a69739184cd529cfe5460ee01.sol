['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-27\n', '*/\n', '\n', '//SPDX-License-Identifier: Unlicense\n', 'pragma solidity 0.8.4;\n', '\n', '//ERC20 functions for fallback tokens recovery\n', 'abstract contract IERC20 {\n', '    function balanceOf(address _owner)\n', '        external\n', '        virtual\n', '        returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) external virtual;\n', "    // can not 'returns (bool success);' because of USDT\n", '    // and other tokens that not follow ERC20 spec fully.\n', '}\n', '\n', '//Uniqly presale contract\n', 'contract UniqFanadisePresale {\n', '    // presale target - close presale when reached\n', '    uint256 public immutable presaleLimit;\n', '\n', '    // minimum pay-in per user\n', '    uint256 public immutable minPerUser;\n', '\n', '    // maximum pay-in per user\n', '    uint256 public immutable maxPerUser;\n', '\n', '    // timestamp ending presale\n', '    uint256 public immutable presaleEnd;\n', '\n', '    // failsafe time - fail if not properly closed after presaleEnd\n', '    uint256 constant public failSafeTime = 2 weeks;\n', '\n', '    // owner address - will receive ETH if success\n', '    address public owner;\n', '\n', '    //constructor\n', '    constructor(\n', '        uint256 _presaleLimit, //maximum amount to be collected\n', '        uint256 _minPerUser, //minimum buy-in per user\n', '        uint256 _maxPerUser, //maximum buy-in per user\n', '        uint256 _presaleEnd, //unix timestamp of presale round end\n', '        address _owner //privileged address\n', '    ) {\n', '        presaleLimit = _presaleLimit;\n', '        minPerUser = _minPerUser;\n', '        maxPerUser = _maxPerUser;\n', '        presaleEnd = _presaleEnd;\n', '        owner = _owner;\n', '    }\n', '\n', '    //flags need for logic (false is default)\n', '    bool public presaleEnded;\n', '    bool public presaleFailed;\n', '    bool public presaleStarted;\n', '\n', '    // list of user balances (zero is default)\n', '    mapping(address => uint256) private balances;\n', '\n', '    // join presale - just send ETH to contract,\n', '    // remember to check GAS LIMIT > 70000!\n', '    receive() external payable {\n', '        // only if not ended\n', '        require(presaleStarted, "Presale not started");\n', '        require(!presaleEnded, "Presale ended");\n', '        // only if within time limit\n', '        require(block.timestamp < presaleEnd, "Presale time\'s up");\n', '\n', '        // record new user balance if possible\n', '        uint256 amount = msg.value + balances[msg.sender];\n', '        require(amount >= minPerUser, "Below buy-in");\n', '        require(amount <= maxPerUser, "Over buy-in");\n', '        balances[msg.sender] = amount;\n', '\n', '        // end presale if reached limit\n', '        if (collected() >= presaleLimit) {\n', '            presaleEnded = true;\n', '        }\n', '    }\n', '\n', '    function start() external {\n', '        require(msg.sender == owner, "Only for Owner");\n', '        presaleStarted = true;\n', '    }\n', '\n', '    // check balance of any user\n', '    function balanceOf(address user) external view returns (uint256) {\n', '        return balances[user];\n', '    }\n', '\n', '    // return balance of caller\n', '    function balanceOf() external view returns (uint256) {\n', '        return balances[msg.sender];\n', '    }\n', '\n', '    // total ETH on this contract\n', '    function collected() public view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    // withdraw ETH from contract\n', '    // can be used by user and owner\n', '    // return false if nothing to do\n', '    function withdraw() external returns (bool) {\n', '        if (!presaleEnded) {\n', '            // end and fail presale if failsafe time passed\n', '            if (block.timestamp > presaleEnd + failSafeTime) {\n', '                presaleEnded = true;\n', '                presaleFailed = true;\n', "                // don't return true, you can withdraw in this call\n", '            }\n', '        }\n', '        // owner withdraw - presale succeed ?\n', '        else if (msg.sender == owner && !presaleFailed) {\n', '            send(owner, address(this).balance);\n', '            return true;\n', '        }\n', '\n', '        // presale failed, withdraw to calling user\n', '        if (presaleFailed) {\n', '            uint256 amount = balances[msg.sender];\n', '            balances[msg.sender] = 0;\n', '            send(msg.sender, amount);\n', '            return true;\n', '        }\n', '\n', '        // did nothing\n', '        return false;\n', '    }\n', '\n', '    //send ETH from contract to address or contract\n', '    function send(address user, uint256 amount) private {\n', '        bool success = false;\n', '        (success, ) = address(user).call{value: amount}("");\n', '        require(success, "ETH send failed");\n', '    }\n', '\n', '    // withdraw any ERC20 token send accidentally on this contract address to contract owner\n', '    function withdrawAnyERC20(IERC20 token) external {\n', '        uint256 amount = token.balanceOf(address(this));\n', '        require(amount > 0, "No tokens to withdraw");\n', '        token.transfer(owner, amount);\n', '    }\n', '\n', '    // change ownership in two steps to be sure about owner address\n', '    address public newOwner;\n', '\n', '    // only current owner can delegate new one\n', '    function giveOwnership(address _newOwner) external {\n', '        require(msg.sender == owner, "Only for Owner");\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    // new owner need to accept ownership\n', '    function acceptOwnership() external {\n', '        require(msg.sender == newOwner, "Ure not New Owner");\n', '        newOwner = address(0x0);\n', '        owner = msg.sender;\n', '    }\n', '}']