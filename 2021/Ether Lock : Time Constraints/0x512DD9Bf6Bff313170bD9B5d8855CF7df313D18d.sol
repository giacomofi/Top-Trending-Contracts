['pragma solidity ^0.7.4;\n', '// "SPDX-License-Identifier: Apache License 2.0"\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', '\n', 'import "./IReservoir.sol";\n', '\n', '/**\n', ' *  Based on Sushi MasterChef:\n', ' *  https://github.com/sushiswap/sushiswap/blob/1e4db47fa313f84cd242e17a4972ec1e9755609a/contracts/MasterChef.sol\n', ' *\n', ' * SRS:\n', ' * 1. Staking length 1 month.\n', ' * 2. 0.3% daily staking.\n', ' * 3. Body tokens are locked till the end of farm.\n', ' * 4. Only 1 token in staking.\n', ' */\n', 'contract FarmingPool {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // Info of each user.\n', '    struct UserInfo {\n', '        uint256 amount;     // How many LP tokens the user has provided.\n', '        uint256 rewardDebt; // Reward debt. See explanation below.\n', '        //\n', '        // We do some fancy math here. Basically, any point in time, the amount of tokens\n', '        // entitled to a user but is pending to be distributed is:\n', '        //\n', '        //   pending reward = (user.amount * pool.accTokensPerShare) - user.rewardDebt\n', '        //\n', "        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n", "        //   1. The pool's `accTokensPerShare` (and `lastReward`) gets updated.\n", '        //   2. User receives the pending reward sent to his/her address.\n', "        //   3. User's `amount` gets updated.\n", "        //   4. User's `rewardDebt` gets updated.\n", '    }\n', '\n', '    // Info of each pool.\n', '    struct PoolInfo {\n', '        IERC20 lpToken;            // Address of LP token contract.\n', '        uint256 allocPoint;        // How many allocation points assigned to this pool. Tokens to distribute per second.\n', '        uint256 lastReward;        // Last timestamp that tokens distribution occurs.\n', '        uint256 accTokensPerShare; // Accumulated tokens per share, times MULTIPLIER. See below.\n', '    }\n', '\n', '    // 10**18 multiplier.\n', '    uint256 private constant DECIMALS_MLTPLR = 1e18;\n', '\n', '    // Max pools total supply: 100,000,000.\n', '    uint256 private constant MAX_POOLS_SUPPLY = 1e8 * DECIMALS_MLTPLR;\n', '\n', '    // The REWARD TOKEN\n', '    IERC20 public token;\n', '\n', '    // Info of each pool.\n', '    PoolInfo[] public poolInfo;\n', '    // Info of each user that stakes LP tokens.\n', '    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\n', '    // Total allocation points. Must be the sum of all allocation points in all pools.\n', '    uint256 public totalAllocPoint;\n', '    // The timestamp when token mining starts.\n', '    uint256 public start;\n', '    uint256 public end;\n', '    address public owner;\n', '    uint256 public lpSupplyState;\n', '\n', '    // Token reservoir\n', '    IReservoir public tokenReservoir;\n', '\n', '    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '\n', '    constructor(\n', '        IERC20 _token,\n', '        uint256 _startTimestamp,\n', '        uint256[1] memory _allocPoints,\n', '        IERC20[1] memory _lpTokens\n', '    ) {\n', '        token = _token;\n', '        start = _startTimestamp;\n', '        end = start.add(2629746);\n', '        owner = msg.sender;\n', '\n', '        // add pools\n', '        _addPool(_allocPoints[0], _lpTokens[0]);\n', '    }\n', '\n', '    // Initialize tokenReservoir after creation (only once)\n', '    function initializeTokenReservoir(IReservoir _tokenReservoir) external {\n', '        require(tokenReservoir == IReservoir(0), "TokenReservoir has already been initialized");\n', '        tokenReservoir = _tokenReservoir;\n', '    }\n', '\n', '    function poolLength() external view returns (uint256) {\n', '        return poolInfo.length;\n', '    }\n', '\n', '    // Return reward multiplier over the given _from to _to timestamp.\n', '    function getMultiplier(uint256 _from, uint256 _to) public view returns (uint256) {\n', '        uint256 curFrom = (_from < start) ? start : _from;\n', '        uint256 curTo = (_to > end) ? end : _to;\n', '        return curTo.sub(curFrom);\n', '    }\n', '\n', '    // View function to see pending tokens on frontend.\n', '    function pendingTokens(uint256 _pid, address _user) external view returns (uint256) {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][_user];\n', '        uint256 accTokensPerShare = pool.accTokensPerShare;\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '        if (block.timestamp > pool.lastReward && lpSupply != 0) {\n', '            uint256 tokenReward = getMultiplier(pool.lastReward, block.timestamp).mul(rewardPerSecond(lpSupply));\n', '            tokenReward = _availableTokens(tokenReward); // amount available for transfer\n', '            accTokensPerShare = accTokensPerShare.add(tokenReward.mul(DECIMALS_MLTPLR).div(lpSupply));\n', '        }\n', '        return user.amount.mul(accTokensPerShare).div(DECIMALS_MLTPLR).sub(user.rewardDebt);\n', '    }\n', '\n', '    // Update reward variables for all pools. Safe gas costs: always 2 pools.\n', '    function updatePools() public {\n', '        uint256 length = poolInfo.length;\n', '        for (uint256 pid = 0; pid < length; ++pid) {\n', '            _updatePool(pid);\n', '        }\n', '    }\n', '\n', '    // Deposit LP tokens to FarmingPool for token allocation.\n', '    function deposit(uint256 _pid, uint256 _amount) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        updatePools(); // safe gas costs: always 1 pool\n', '        if (user.amount > 0) {\n', '            uint256 pending = user.amount.mul(pool.accTokensPerShare).div(DECIMALS_MLTPLR).sub(user.rewardDebt);\n', '            if(pending > 0) {\n', '                _safeTokenTransfer(msg.sender, pending);\n', '            }\n', '        }\n', '        if(_amount > 0) {\n', '            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n', '            user.amount = user.amount.add(_amount);\n', '            lpSupplyState += _amount;\n', '        }\n', '        user.rewardDebt = user.amount.mul(pool.accTokensPerShare).div(DECIMALS_MLTPLR);\n', '        emit Deposit(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    // Withdraw LP tokens from FarmingPool.\n', '    function withdraw(uint256 _pid, uint256 _amount) public {\n', '        require(block.timestamp > end, "Too early to withdraw");\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        require(user.amount >= _amount, "withdraw: not good");\n', '        updatePools(); // safe gas costs: always 1 pool\n', '        uint256 pending = user.amount.mul(pool.accTokensPerShare).div(DECIMALS_MLTPLR).sub(user.rewardDebt);\n', '        if(pending > 0) {\n', '            _safeTokenTransfer(msg.sender, pending);\n', '        }\n', '        if(_amount > 0) {\n', '            user.amount = user.amount.sub(_amount);\n', '            pool.lpToken.safeTransfer(address(msg.sender), _amount);\n', '            lpSupplyState -= _amount;\n', '        }\n', '        user.rewardDebt = user.amount.mul(pool.accTokensPerShare).div(DECIMALS_MLTPLR);\n', '        emit Withdraw(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw(uint256 _pid) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        uint256 amount = user.amount;\n', '        user.amount = 0;\n', '        user.rewardDebt = 0;\n', '        lpSupplyState -= amount;\n', '        pool.lpToken.safeTransfer(address(msg.sender), amount);\n', '        emit EmergencyWithdraw(msg.sender, _pid, amount);\n', '    }\n', '\n', '    // Return available tokens on token reservoir.\n', '    function _availableTokens(uint256 requestedTokens) internal view returns (uint256) {\n', '        uint256 reservoirBalance = token.balanceOf(address(tokenReservoir));\n', '        uint256 tokensAvailable = (requestedTokens > reservoirBalance)\n', '            ? reservoirBalance\n', '            : requestedTokens;\n', '\n', '        return tokensAvailable;\n', '    }\n', '\n', '    // Update reward variables of the given pool to be up-to-date.\n', '    function _updatePool(uint256 _pid) internal {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        if (block.timestamp <= pool.lastReward) {\n', '            return;\n', '        }\n', '        uint256 lpSupply = lpSupplyState;\n', '        if (lpSupply == 0) {\n', '            pool.lastReward = block.timestamp;\n', '            return;\n', '        }\n', '        uint256 tokenReward = getMultiplier(pool.lastReward, block.timestamp).mul(rewardPerSecond(lpSupply));\n', '        tokenReward = tokenReservoir.drip(tokenReward); // transfer tokens from tokenReservoir\n', '        pool.accTokensPerShare = pool.accTokensPerShare.add(tokenReward.div(lpSupply));\n', '        pool.accTokensPerShare = pool.accTokensPerShare.add(tokenReward.mul(DECIMALS_MLTPLR).div(lpSupply));\n', '        pool.lastReward = block.timestamp;\n', '    }\n', '    \n', '    function rewardPerSecond(uint256 lpSupply) pure internal returns(uint256) {\n', '        // 333 - for 0.3% per day.\n', '        // 86400 - number of seconds in 1 day.\n', '        return lpSupply.div(334).div(86400);\n', '    }\n', '\n', '    // Safe token transfer function, just in case if rounding error causes pool to not have enough tokens.\n', '    function _safeTokenTransfer(address _to, uint256 _amount) internal {\n', '        uint256 tokenBal = token.balanceOf(address(this));\n', '        if (_amount > tokenBal) {\n', '            token.transfer(_to, tokenBal);\n', '        } else {\n', '            token.transfer(_to, _amount);\n', '        }\n', '    }\n', '\n', '        // Add a new lp to the pool.\n', '    function _addPool(uint256 _allocPoint, IERC20 _lpToken) internal {\n', '        uint256 lastReward = block.timestamp > start ? block.timestamp : start;\n', '        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n', '        poolInfo.push(PoolInfo({\n', '            lpToken: _lpToken,\n', '            allocPoint: _allocPoint,\n', '            lastReward: lastReward,\n', '            accTokensPerShare: 0\n', '        }));\n', '    }\n', '    \n', '    function purge(uint256 amount) external {\n', '        require(msg.sender == owner, "Only owner can call");\n', '        token.transfer(owner, amount);\n', '    }\n', '}']