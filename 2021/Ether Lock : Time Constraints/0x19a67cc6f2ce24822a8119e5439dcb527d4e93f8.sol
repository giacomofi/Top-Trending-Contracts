['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-16\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', '\n', 'interface BSKToken {\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', 'abstract contract RewardContract {\n', '    function getBalance() external view virtual returns (uint256);\n', '    function giveReward(address recipient, uint256 amount) external virtual returns (bool);\n', '}\n', '\n', 'contract BSKTStaker is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    BSKToken public immutable _bskToken;    \t\t        // BSKT contract\n', '    RewardContract public _rewardContract;                  // reward contract\n', '\n', '    mapping (address => StakerInfo) private _stakeMap;      // map for stakers\n', '\n', "    address[] private _stakers;                             // staker's array\n", '    \n', '    uint256 private _totalStakedAmount = 0;                 // total staked amount\n', '    uint256 private _minStakeAmount = 10000e18;             // min stakable amount\n', '    \n', '    uint256 private _rewardPortion = 10;                    // reward portion 10%\n', '    \n', '    struct StakerInfo {\n', '        uint256 stakedAmount;\n', '        uint256 rewardAmount;\n', '        uint256 lastClaimTimestamp;\n', '    }\n', '    \n', '    // Events\n', '    event Staked(address staker, uint256 amount);\n', '    event Unstaked(address staker, uint256 amount);\n', '    event Claim(address staker, uint256 amount);\n', '    \n', '    constructor (BSKToken bskToken) public {\n', '        _bskToken = bskToken;\n', '        \n', '    }\n', '    \n', '    function stake(uint256 amount) public {\n', '        require(\n', '            amount >= _minStakeAmount,\n', '            "BSKTStaker: stake amount is less than min stake amount."\n', '        );\n', '\n', '        uint256 initialBalance = _bskToken.balanceOf(address(this));\n', '        \n', '        require(\n', '            _bskToken.transferFrom(\n', '                _msgSender(),\n', '                address(this),\n', '                amount\n', '            ),\n', '            "BSKTStaker: stake failed."\n', '        );\n', '\n', '        uint256 realStakedAmount = _bskToken.balanceOf(address(this)).sub(initialBalance);\n', '        uint256 currentTimestamp = uint256(now);\n', '\n', '        if(_stakeMap[_msgSender()].stakedAmount == 0)\n', '            _stakers.push(_msgSender());\n', '        else\n', '            _stakeMap[_msgSender()].rewardAmount = calcReward(_msgSender(), currentTimestamp);\n', '        _stakeMap[_msgSender()].lastClaimTimestamp = currentTimestamp;\n', '            \n', '        _stakeMap[_msgSender()].stakedAmount = _stakeMap[_msgSender()].stakedAmount.add(realStakedAmount);\n', '        _totalStakedAmount = _totalStakedAmount.add(realStakedAmount);\n', '        \n', '        emit Staked(_msgSender(), realStakedAmount);\n', '    }\n', '    \n', '    function unstake(uint256 amount) public {\n', '        require(\n', '            _stakeMap[_msgSender()].stakedAmount >= amount,\n', '            "BSKTStaker: unstake amount exceededs the staked amount."\n', '        );\n', '\n', '        uint256 currentTimestamp = uint256(now);\n', '        _stakeMap[_msgSender()].rewardAmount = calcReward(_msgSender(), currentTimestamp);\n', '        _stakeMap[_msgSender()].lastClaimTimestamp = currentTimestamp;\n', '        _stakeMap[_msgSender()].stakedAmount = _stakeMap[_msgSender()].stakedAmount.sub(amount);\n', '        _totalStakedAmount = _totalStakedAmount.sub(amount);\n', '\n', '        require(\n', '            _bskToken.transfer(\n', '                _msgSender(),\n', '                amount\n', '            ),\n', '            "BSKTStaker: unstake failed."\n', '        );\n', '        \n', '        if(_stakeMap[_msgSender()].stakedAmount == 0) {\n', '            for(uint i=0; i<_stakers.length; i++) {\n', '                if(_stakers[i] == _msgSender()) {\n', '                    _stakers[i] = _stakers[_stakers.length-1];\n', '                    _stakers.pop();\n', '                    break;\n', '                }\n', '            }\n', '        }\n', '        emit Unstaked(_msgSender(), amount);\n', '    }\n', '    \n', '    function claim() public {\n', '        uint256 currentTimestamp = uint256(now);\n', '        uint256 rewardAmount = calcReward(_msgSender(), currentTimestamp);\n', '        _stakeMap[_msgSender()].lastClaimTimestamp = currentTimestamp;\n', '        _stakeMap[_msgSender()].rewardAmount = 0;\n', '        \n', '        require(\n', '            _rewardContract.giveReward(_msgSender(), rewardAmount),\n', '            "BSKTStaker: claim failed."\n', '        );\n', '        \n', '\t    emit Claim(_msgSender(), rewardAmount);\n', '    }\n', '    \n', '    function endStake() external {\n', '        unstake(_stakeMap[_msgSender()].stakedAmount);\n', '        claim();\n', '    }\n', '    \n', '    function calcReward(address account, uint256 currentTimestamp) internal view returns (uint256) {\n', '        if(_totalStakedAmount == 0)\n', '            return 0;\n', '        uint256 rewardPoolBalance = _rewardContract.getBalance();\n', '        uint256 passTime = currentTimestamp.sub(_stakeMap[account].lastClaimTimestamp);\n', '        uint256 rewardAmountForStakers = rewardPoolBalance.mul(_rewardPortion).div(100);\n', '        uint256 rewardAmount = rewardAmountForStakers.mul(passTime).div(86400).mul(_stakeMap[account].stakedAmount).div(_totalStakedAmount);\n', '        return _stakeMap[account].rewardAmount.add(rewardAmount);\n', '    }\n', '    \n', '    /**\n', '     * Get store wallet\n', '     */\n', '    function getRewardContract() external view returns (address) {\n', '        return address(_rewardContract);\n', '    }\n', '     \n', '    /**\n', '     * Get total staked amount\n', '     */\n', '    function getTotalStakedAmount() external view returns (uint256) {\n', '        return _totalStakedAmount;\n', '    }\n', '    \n', '    /**\n', '     * Get reward amount of staker\n', '     */\n', '    function getReward(address account) external view returns (uint256) {\n', '        return calcReward(account, now);\n', '    }\n', '    \n', '    /**\n', '     * Get reward pool balance (LAVA)\n', '     */\n', '    function getRewardPoolBalance() external view returns (uint256) {\n', '        return _rewardContract.getBalance();\n', '    }\n', '    \n', '    /**\n', '     * Get last claim timestamp\n', '     */\n', '    function getLastClaimTimestamp() external view returns (uint256) {\n', '        return _stakeMap[_msgSender()].lastClaimTimestamp;\n', '    }\n', '    \n', '    /**\n', '     * Get staked amount of staker\n', '     */\n', '    function getStakedAmount(address staker) external view returns (uint256) {\n', '        return _stakeMap[staker].stakedAmount;\n', '    }\n', '    \n', '    /**\n', '     * Get min stake amount\n', '     */\n', '    function getMinStakeAmount() external view returns (uint256) {\n', '        return _minStakeAmount;\n', '    }\n', '    \n', '    /**\n', '     * Get rewards portion\n', '     */\n', '    function getRewardPortion() external view returns (uint256) {\n', '        return _rewardPortion;\n', '    }\n', '    \n', '    /**\n', '     * Get staker count\n', '     */\n', '    function getStakerCount() external view returns (uint256) {\n', '        return _stakers.length;\n', '    }\n', '\n', '    /**\n', '     * Get staked rank\n', '     */\n', '    function getStakedRank(address account) external view returns (uint256) {\n', '        uint256 rank = 1;\n', '        uint256 senderStakedAmount = _stakeMap[account].stakedAmount;\n', '        \n', '        for(uint i=0; i<_stakers.length; i++) {\n', '            if(_stakers[i] != account && senderStakedAmount < _stakeMap[_stakers[i]].stakedAmount)\n', '                rank = rank.add(1);\n', '        }\n', '        return rank;\n', '    }\n', '    \n', '    /**\n', '     * Set store wallet contract address\n', '     */\n', '    function setRewardContract(RewardContract rewardContract) external onlyOwner returns (bool) {\n', "        require(address(rewardContract) != address(0), 'BSKTStaker: reward contract address should not be zero address.');\n", '\n', '        _rewardContract = rewardContract;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Set rewards portion in store balance. \n', '     */\n', '    function setRewardPortion(uint256 rewardPortion) external onlyOwner returns (bool) {\n', "        require(rewardPortion >= 10 && rewardPortion <= 100, 'BSKTStaker: reward portion should be in 10 ~ 100.');\n", '\n', '        _rewardPortion = rewardPortion;\n', '        return true;\n', '    }\n', '}']