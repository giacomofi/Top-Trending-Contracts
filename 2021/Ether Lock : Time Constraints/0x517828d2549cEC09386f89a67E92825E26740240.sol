['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-30\n', '*/\n', '\n', 'pragma solidity 0.6.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', '    @title Interface for handler that handles generic deposits and deposit executions.\n', '    @author ChainSafe Systems.\n', ' */\n', 'interface IGenericHandler {\n', '    /**\n', '        @notice Correlates {resourceID} with {contractAddress}, {depositFunctionSig}, and {executeFunctionSig}.\n', '        @param resourceID ResourceID to be used when making deposits.\n', '        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\n', '        @param depositFunctionSig Function signature of method to be called in {contractAddress} when a deposit is made.\n', '        @param depositFunctionDepositerOffset Depositer address position offset in the metadata, in bytes.\n', '        @param executeFunctionSig Function signature of method to be called in {contractAddress} when a deposit is executed.\n', '     */\n', '    function setResource(\n', '        bytes32 resourceID,\n', '        address contractAddress,\n', '        bytes4 depositFunctionSig,\n', '        uint depositFunctionDepositerOffset,\n', '        bytes4 executeFunctionSig) external;\n', '}\n', '\n', '/**\n', '    @title Handles generic deposits and deposit executions.\n', '    @author ChainSafe Systems.\n', '    @notice This contract is intended to be used with the Bridge contract.\n', ' */\n', 'contract GenericHandler is IGenericHandler {\n', '    address public _bridgeAddress;\n', '\n', '    struct DepositRecord {\n', '        uint8   _destinationChainID;\n', '        address _depositer;\n', '        bytes32 _resourceID;\n', '        bytes   _metaData;\n', '    }\n', '\n', '    // depositNonce => Deposit Record\n', '    mapping (uint8 => mapping(uint64 => DepositRecord)) public _depositRecords;\n', '\n', '    // resourceID => contract address\n', '    mapping (bytes32 => address) public _resourceIDToContractAddress;\n', '\n', '    // contract address => resourceID\n', '    mapping (address => bytes32) public _contractAddressToResourceID;\n', '\n', '    // contract address => deposit function signature\n', '    mapping (address => bytes4) public _contractAddressToDepositFunctionSignature;\n', '\n', '    // contract address => depositer address position offset in the metadata\n', '    mapping (address => uint256) public _contractAddressToDepositFunctionDepositerOffset;\n', ' \n', '    // contract address => execute proposal function signature\n', '    mapping (address => bytes4) public _contractAddressToExecuteFunctionSignature;\n', '\n', '    // token contract address => is whitelisted\n', '    mapping (address => bool) public _contractWhitelist;\n', '\n', '    modifier onlyBridge() {\n', '        _onlyBridge();\n', '        _;\n', '    }\n', '\n', '    function _onlyBridge() private {\n', '        require(msg.sender == _bridgeAddress, "sender must be bridge contract");\n', '    }\n', '\n', '    /**\n', '        @param bridgeAddress Contract address of previously deployed Bridge.\n', '        @param initialResourceIDs Resource IDs used to identify a specific contract address.\n', '        These are the Resource IDs this contract will initially support.\n', '        @param initialContractAddresses These are the addresses the {initialResourceIDs} will point to, and are the contracts that will be\n', '        called to perform deposit and execution calls.\n', '        @param initialDepositFunctionSignatures These are the function signatures {initialContractAddresses} will point to,\n', '        and are the function that will be called when executing {deposit}\n', '        @param initialDepositFunctionDepositerOffsets These are the offsets of depositer positions, inside of metadata used to call\n', '        {initialContractAddresses} when executing {deposit}\n', '        @param initialExecuteFunctionSignatures These are the function signatures {initialContractAddresses} will point to,\n', '        and are the function that will be called when executing {executeProposal}\n', '\n', '        @dev {initialResourceIDs}, {initialContractAddresses}, {initialDepositFunctionSignatures},\n', '        and {initialExecuteFunctionSignatures} must all have the same length. Also,\n', '        values must be ordered in the way that that index x of any mentioned array\n', '        must be intended for value x of any other array, e.g. {initialContractAddresses}[0]\n', '        is the intended address for {initialDepositFunctionSignatures}[0].\n', '     */\n', '    constructor(\n', '        address          bridgeAddress,\n', '        bytes32[] memory initialResourceIDs,\n', '        address[] memory initialContractAddresses,\n', '        bytes4[]  memory initialDepositFunctionSignatures,\n', '        uint256[] memory initialDepositFunctionDepositerOffsets,\n', '        bytes4[]  memory initialExecuteFunctionSignatures\n', '    ) public {\n', '        require(initialResourceIDs.length == initialContractAddresses.length,\n', '            "initialResourceIDs and initialContractAddresses len mismatch");\n', '\n', '        require(initialContractAddresses.length == initialDepositFunctionSignatures.length,\n', '            "provided contract addresses and function signatures len mismatch");\n', '\n', '        require(initialDepositFunctionSignatures.length == initialExecuteFunctionSignatures.length,\n', '            "provided deposit and execute function signatures len mismatch");\n', '\n', '        require(initialDepositFunctionDepositerOffsets.length == initialExecuteFunctionSignatures.length,\n', '            "provided depositer offsets and function signatures len mismatch");\n', '\n', '        _bridgeAddress = bridgeAddress;\n', '\n', '        for (uint256 i = 0; i < initialResourceIDs.length; i++) {\n', '            _setResource(\n', '                initialResourceIDs[i],\n', '                initialContractAddresses[i],\n', '                initialDepositFunctionSignatures[i],\n', '                initialDepositFunctionDepositerOffsets[i],\n', '                initialExecuteFunctionSignatures[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '        @param depositNonce This ID will have been generated by the Bridge contract.\n', '        @param destId ID of chain deposit will be bridged to.\n', '        @return DepositRecord which consists of:\n', '        - _destinationChainID ChainID deposited tokens are intended to end up on.\n', '        - _resourceID ResourceID used when {deposit} was executed.\n', '        - _depositer Address that initially called {deposit} in the Bridge contract.\n', '        - _metaData Data to be passed to method executed in corresponding {resourceID} contract.\n', '    */\n', '    function getDepositRecord(uint64 depositNonce, uint8 destId) external view returns (DepositRecord memory) {\n', '        return _depositRecords[destId][depositNonce];\n', '    }\n', '\n', '    /**\n', '        @notice First verifies {_resourceIDToContractAddress}[{resourceID}] and\n', '        {_contractAddressToResourceID}[{contractAddress}] are not already set,\n', '        then sets {_resourceIDToContractAddress} with {contractAddress},\n', '        {_contractAddressToResourceID} with {resourceID},\n', '        {_contractAddressToDepositFunctionSignature} with {depositFunctionSig},\n', '        {_contractAddressToDepositFunctionDepositerOffset} with {depositFunctionDepositerOffset},\n', '        {_contractAddressToExecuteFunctionSignature} with {executeFunctionSig},\n', '        and {_contractWhitelist} to true for {contractAddress}.\n', '        @param resourceID ResourceID to be used when making deposits.\n', '        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\n', '        @param depositFunctionSig Function signature of method to be called in {contractAddress} when a deposit is made.\n', '        @param depositFunctionDepositerOffset Depositer address position offset in the metadata, in bytes.\n', '        @param executeFunctionSig Function signature of method to be called in {contractAddress} when a deposit is executed.\n', '     */\n', '    function setResource(\n', '        bytes32 resourceID,\n', '        address contractAddress,\n', '        bytes4 depositFunctionSig,\n', '        uint256 depositFunctionDepositerOffset,\n', '        bytes4 executeFunctionSig\n', '    ) external onlyBridge override {\n', '\n', '        _setResource(resourceID, contractAddress, depositFunctionSig, depositFunctionDepositerOffset, executeFunctionSig);\n', '    }\n', '\n', '    /**\n', '        @notice A deposit is initiatied by making a deposit in the Bridge contract.\n', '        @param destinationChainID Chain ID deposit is expected to be bridged to.\n', '        @param depositNonce This value is generated as an ID by the Bridge contract.\n', '        @param depositer Address of the account making deposit in the Bridge contract.\n', '        @param data Consists of: {resourceID}, {lenMetaData}, and {metaData} all padded to 32 bytes.\n', '        @notice Data passed into the function should be constructed as follows:\n', '        len(data)                              uint256     bytes  0  - 32\n', '        data                                   bytes       bytes  64 - END\n', '        @notice {contractAddress} is required to be whitelisted\n', '        @notice If {_contractAddressToDepositFunctionSignature}[{contractAddress}] is set,\n', '        {metaData} is expected to consist of needed function arguments.\n', '     */\n', '    function deposit(bytes32 resourceID, uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) external onlyBridge {\n', '        uint256      lenMetadata;\n', '        bytes memory metadata;\n', '\n', '        lenMetadata = abi.decode(data, (uint256));\n', '        metadata = bytes(data[32:32 + lenMetadata]);\n', '\n', '        address contractAddress = _resourceIDToContractAddress[resourceID];\n', '        uint256 depositerOffset = _contractAddressToDepositFunctionDepositerOffset[contractAddress];\n', '        if (depositerOffset > 0) {\n', '            uint256 metadataDepositer;\n', '            // Skipping 32 bytes of length prefix and depositerOffset bytes.\n', '            assembly {\n', '                metadataDepositer := mload(add(add(metadata, 32), depositerOffset))\n', '            }\n', '            // metadataDepositer contains 0xdepositerAddressdepositerAddressdeposite************************\n', '            // Shift it 12 bytes right:   0x000000000000000000000000depositerAddressdepositerAddressdeposite\n', "            require(depositer == address(metadataDepositer >> 96), 'incorrect depositer in the data');\n", '        }\n', '\n', '        require(_contractWhitelist[contractAddress], "provided contractAddress is not whitelisted");\n', '\n', '        bytes4 sig = _contractAddressToDepositFunctionSignature[contractAddress];\n', '        if (sig != bytes4(0)) {\n', '            bytes memory callData = abi.encodePacked(sig, metadata);\n', '            (bool success,) = contractAddress.call(callData);\n', '            require(success, "call to contractAddress failed");\n', '        }\n', '\n', '        _depositRecords[destinationChainID][depositNonce] = DepositRecord(\n', '            destinationChainID,\n', '            depositer,\n', '            resourceID,\n', '            metadata\n', '        );\n', '    }\n', '\n', '    /**\n', '        @notice Proposal execution should be initiated when a proposal is finalized in the Bridge contract.\n', '        @param data Consists of {resourceID}, {lenMetaData}, and {metaData}.\n', '        @notice Data passed into the function should be constructed as follows:\n', '        len(data)                              uint256     bytes  0  - 32\n', '        data                                   bytes       bytes  32 - END\n', '        @notice {contractAddress} is required to be whitelisted\n', '        @notice If {_contractAddressToExecuteFunctionSignature}[{contractAddress}] is set,\n', '        {metaData} is expected to consist of needed function arguments.\n', '     */\n', '    function executeProposal(bytes32 resourceID, bytes calldata data) external onlyBridge {\n', '        uint256      lenMetadata;\n', '        bytes memory metaData;\n', '\n', '        lenMetadata = abi.decode(data, (uint256)); \n', '        metaData = bytes(data[32:32 + lenMetadata]);\n', '\n', '        address contractAddress = _resourceIDToContractAddress[resourceID];\n', '        require(_contractWhitelist[contractAddress], "provided contractAddress is not whitelisted");\n', '\n', '        bytes4 sig = _contractAddressToExecuteFunctionSignature[contractAddress];\n', '        if (sig != bytes4(0)) {\n', '            bytes memory callData = abi.encodePacked(sig, metaData);\n', '            (bool success,) = contractAddress.call(callData);\n', '            require(success, "delegatecall to contractAddress failed");\n', '        }\n', '    }\n', '\n', '    function _setResource(\n', '        bytes32 resourceID,\n', '        address contractAddress,\n', '        bytes4 depositFunctionSig,\n', '        uint256 depositFunctionDepositerOffset,\n', '        bytes4 executeFunctionSig\n', '    ) internal {\n', '        _resourceIDToContractAddress[resourceID] = contractAddress;\n', '        _contractAddressToResourceID[contractAddress] = resourceID;\n', '        _contractAddressToDepositFunctionSignature[contractAddress] = depositFunctionSig;\n', '        _contractAddressToDepositFunctionDepositerOffset[contractAddress] = depositFunctionDepositerOffset;\n', '        _contractAddressToExecuteFunctionSignature[contractAddress] = executeFunctionSig;\n', '\n', '        _contractWhitelist[contractAddress] = true;\n', '    }\n', '\n', '    /**\n', '        @notice Used to update the _bridgeAddress.\n', '        @param newBridgeAddress Address of the updated _bridgeAddress.\n', '     */\n', '    function updateBridgeAddress(address newBridgeAddress) external onlyBridge {\n', '        require(_bridgeAddress != newBridgeAddress, "the updated address is the same with the old");\n', '\n', '        _bridgeAddress = newBridgeAddress;\n', '    }\n', '\n', '}']