['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-26\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.4;\n', '\n', '// Interfaces for contract interaction\n', 'interface INterfaces {\n', '    function balanceOf(address) external returns (uint256);\n', '\n', '    function transfer(address, uint256) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address,\n', '        address,\n', '        uint256\n', '    ) external returns (bool);\n', '\n', '    function allowance(address, address) external returns (uint256);\n', '\n', '    //usdc\n', '    function transferWithAuthorization(\n', '        address from,\n', '        address to,\n', '        uint256 value,\n', '        uint256 validAfter,\n', '        uint256 validBefore,\n', '        bytes32 nonce,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', '// USDT is not ERC-20 compliant, not returning true on transfers\n', 'interface IUsdt {\n', '    function transfer(address, uint256) external;\n', '\n', '    function transferFrom(\n', '        address,\n', '        address,\n', '        uint256\n', '    ) external;\n', '}\n', '\n', '// BigShortBets.com presale contract - via StableCoins and ETH\n', '//\n', '// USE ONLY OWN WALLET (Metamask, Trezor, Ledger...)\n', '// DO NOT SEND FROM EXCHANGES OR ANY SERVICES\n', '//\n', '// Use ONLY ETH network, ERC20 tokens (Not Binance/Tron/whatever!)\n', '//\n', '// Set approval to contract address or use USDC authorization first\n', '//\n', '// DO NOT SEND STABLE TOKENS DIRECTLY - IT WILL NOT COUNT THAT!\n', '//\n', '// send ONLY round number of USD(c|t)/DAI!\n', '// ie 20, 500, 2000 NOT 20.1, 500.5, 2000.3\n', '// contract will ignore decimals\n', '//\n', '// Need 150k gas limit\n', '// use proper pay* function\n', 'contract BigShortBetsPresale2 {\n', '    // max USD per user\n', '    uint256 private immutable _maxUsd;\n', '    // soft limit USD total\n', '    uint256 private immutable _limitUsd;\n', '    // max ETH per user\n', '    uint256 private immutable _maxEth;\n', '    // soft limit ETH total\n', '    uint256 private immutable _limitEth;\n', '    // contract starts accepting transfers\n', '    uint256 private immutable _dateStart;\n', '    // hard time limit\n', '    uint256 private immutable _dateEnd;\n', '\n', '    // total collected USD\n', '    uint256 private _usdCollected;\n', '\n', '    uint256 private constant DECIMALS_DAI = 18;\n', '    uint256 private constant DECIMALS_USDC = 6;\n', '    uint256 private constant DECIMALS_USDT = 6;\n', '\n', '    // addresses of tokens\n', '    address private immutable usdt;\n', '    address private immutable usdc;\n', '    address private immutable dai;\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    bool private _presaleEnded;\n', '\n', '    // deposited per user\n', '    mapping(address => uint256) private _usdBalance;\n', '    mapping(address => uint256) private _ethBalance;\n', '\n', '    // deposited per tokens\n', '    mapping(address => uint256) private _deposited;\n', '\n', '    // will be set after presale\n', '    uint256 private _tokensPerEth;\n', '\n', '    string private constant ERROR_ANS = "Approval not set!";\n', '\n', '    event AcceptedUSD(address indexed user, uint256 amount);\n', '    event AcceptedETH(address indexed user, uint256 amount);\n', '\n', '    constructor(\n', '        address _owner,\n', '        uint256 maxUsd,\n', '        uint256 limitUsd,\n', '        uint256 maxEth,\n', '        uint256 limitEth,\n', '        uint256 startDate,\n', '        uint256 endDate,\n', '        address _usdt,\n', '        address _usdc,\n', '        address _dai\n', '    ) {\n', '        owner = _owner;\n', '        _maxUsd = maxUsd;\n', '        _limitUsd = limitUsd;\n', '        _maxEth = maxEth;\n', '        _limitEth = limitEth;\n', '        _dateStart = startDate;\n', '        _dateEnd = endDate;\n', '        usdt = _usdt;\n', '        usdc = _usdc;\n', '        dai = _dai;\n', '\n', '        /**\n', '        mainnet:\n', '        usdt=0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '        usdc=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '        dai=0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '        */\n', '    }\n', '\n', '    //pay in using USDC\n', '    //need prepare and sign approval first\n', '    //not included in dapp\n', '    function payUsdcByAuthorization(\n', '        address from,\n', '        address to,\n', '        uint256 value,\n', '        uint256 validAfter,\n', '        uint256 validBefore,\n', '        bytes32 nonce,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external {\n', '        require(to == address(this), "Wrong authorization address");\n', '        // should throw on any error\n', '        INterfaces(usdc).transferWithAuthorization(\n', '            from,\n', '            to,\n', '            value,\n', '            validAfter,\n', '            validBefore,\n', '            nonce,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        // not msg.sender, approval can be sent by anyone\n', '        _pay(from, value, DECIMALS_USDC);\n', '        _deposited[usdc] += value;\n', '    }\n', '\n', '    //pay in using USDC\n', '    //use approve/transferFrom\n', '    function payUSDC(uint256 amount) external {\n', '        require(\n', '            INterfaces(usdc).allowance(msg.sender, address(this)) >= amount,\n', '            ERROR_ANS\n', '        );\n', '        require(\n', '            INterfaces(usdc).transferFrom(msg.sender, address(this), amount),\n', '            "USDC transfer failed"\n', '        );\n', '        _pay(msg.sender, amount, DECIMALS_USDC);\n', '        _deposited[usdc] += amount;\n', '    }\n', '\n', '    //pay in using USDT\n', '    //need set approval first\n', '    function payUSDT(uint256 amount) external {\n', '        require(\n', '            INterfaces(usdt).allowance(msg.sender, address(this)) >= amount,\n', '            ERROR_ANS\n', '        );\n', '        IUsdt(usdt).transferFrom(msg.sender, address(this), amount);\n', '        _pay(msg.sender, amount, DECIMALS_USDT);\n', '        _deposited[usdt] += amount;\n', '    }\n', '\n', '    //pay in using DAI\n', '    //need set approval first\n', '    function payDAI(uint256 amount) external {\n', '        require(\n', '            INterfaces(dai).allowance(msg.sender, address(this)) >= amount,\n', '            ERROR_ANS\n', '        );\n', '        require(\n', '            INterfaces(dai).transferFrom(msg.sender, address(this), amount),\n', '            "DAI transfer failed"\n', '        );\n', '        _pay(msg.sender, amount, DECIMALS_DAI);\n', '        _deposited[dai] += amount;\n', '    }\n', '\n', '    //direct ETH send will not back\n', '    //\n', '    //accept ETH\n', '\n', '    // takes about 50k gas\n', '    receive() external payable {\n', '        _payEth(msg.sender, msg.value);\n', '    }\n', '\n', '    // takes about 35k gas\n', '    function payETH() external payable {\n', '        _payEth(msg.sender, msg.value);\n', '    }\n', '\n', '    function _payEth(address user, uint256 amount) internal notEnded {\n', '        uint256 amt = _ethBalance[user] + amount;\n', '        require(amt <= _maxEth, "ETH per user reached");\n', '        _ethBalance[user] += amt;\n', '        emit AcceptedETH(user, amount);\n', '    }\n', '\n', '    function _pay(\n', '        address user,\n', '        uint256 amount,\n', '        uint256 decimals\n', '    ) internal notEnded {\n', '        uint256 usd = amount / (10**decimals);\n', '        _usdBalance[user] += usd;\n', '        require(_usdBalance[user] <= _maxUsd, "USD amount too high");\n', '        _usdCollected += usd;\n', '        emit AcceptedUSD(user, usd);\n', '    }\n', '\n', '    //\n', '    // external readers\n', '    //\n', '    function USDcollected() external view returns (uint256) {\n', '        return _usdCollected;\n', '    }\n', '\n', '    function ETHcollected() external view returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function USDmax() external view returns (uint256) {\n', '        return _maxUsd;\n', '    }\n', '\n', '    function USDlimit() external view returns (uint256) {\n', '        return _limitUsd;\n', '    }\n', '\n', '    function ETHmax() external view returns (uint256) {\n', '        return _maxEth;\n', '    }\n', '\n', '    function ETHlimit() external view returns (uint256) {\n', '        return _limitEth;\n', '    }\n', '\n', '    function dateStart() external view returns (uint256) {\n', '        return _dateStart;\n', '    }\n', '\n', '    function dateEnd() external view returns (uint256) {\n', '        return _dateEnd;\n', '    }\n', '\n', '    function tokensBoughtOf(address user) external view returns (uint256 amt) {\n', '        require(_tokensPerEth > 0, "Tokens/ETH ratio not set yet");\n', '        amt = (_usdBalance[user] * 95) / 100;\n', '        amt += _ethBalance[user] * _tokensPerEth;\n', '        return amt;\n', '    }\n', '\n', '    function usdDepositOf(address user) external view returns (uint256) {\n', '        return _usdBalance[user];\n', '    }\n', '\n', '    function ethDepositOf(address user) external view returns (uint256) {\n', '        return _ethBalance[user];\n', '    }\n', '\n', '    modifier notEnded() {\n', '        require(!_presaleEnded, "Presale ended");\n', '        require(\n', '            block.timestamp > _dateStart && block.timestamp < _dateEnd,\n', '            "Too soon or too late"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Only for contract Owner");\n', '        _;\n', '    }\n', '\n', '    modifier timeIsUp() {\n', '        require(block.timestamp > _dateEnd, "SOON");\n', '        _;\n', '    }\n', '\n', '    function endPresale() external onlyOwner {\n', '        require(\n', '            _usdCollected > _limitUsd || address(this).balance > _limitEth,\n', '            "Limit not reached"\n', '        );\n', '        _presaleEnded = true;\n', '    }\n', '\n', '    function setTokensPerEth(uint256 ratio) external onlyOwner {\n', '        require(_tokensPerEth == 0, "Ratio already set");\n', '        _tokensPerEth = ratio;\n', '    }\n', '\n', '    // take out all stables and ETH\n', '    function takeAll() external onlyOwner timeIsUp {\n', '        _presaleEnded = true; //just to save gas for ppl that want buy too late\n', '        uint256 amt = INterfaces(usdt).balanceOf(address(this));\n', '        if (amt > 0) {\n', '            IUsdt(usdt).transfer(owner, amt);\n', '        }\n', '        amt = INterfaces(usdc).balanceOf(address(this));\n', '        if (amt > 0) {\n', '            INterfaces(usdc).transfer(owner, amt);\n', '        }\n', '        amt = INterfaces(dai).balanceOf(address(this));\n', '        if (amt > 0) {\n', '            INterfaces(dai).transfer(owner, amt);\n', '        }\n', '        amt = address(this).balance;\n', '        if (amt > 0) {\n', '            payable(owner).transfer(amt);\n', '        }\n', '    }\n', '\n', '    // we can recover any ERC20 token send in wrong way... for price!\n', '    function recoverErc20(address token) external onlyOwner {\n', '        uint256 amt = INterfaces(token).balanceOf(address(this));\n', '        // do not take deposits\n', '        amt -= _deposited[token];\n', '        if (amt > 0) {\n', '            INterfaces(token).transfer(owner, amt);\n', '        }\n', '    }\n', '\n', '    // should not be needed, but...\n', '    function recoverEth() external onlyOwner timeIsUp {\n', '        payable(owner).transfer(address(this).balance);\n', '    }\n', '\n', '    function changeOwner(address _newOwner) external onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() external {\n', '        require(\n', '            msg.sender != address(0) && msg.sender == newOwner,\n', '            "Only NewOwner"\n', '        );\n', '        newOwner = address(0);\n', '        owner = msg.sender;\n', '    }\n', '}\n', '\n', '// rav3n_pl was here']