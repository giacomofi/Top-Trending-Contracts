['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-22\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function sync() external;\n', '}\n', '\n', 'interface UniswapRouter {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);\n', '    function addLiquidityETH(address token,uint amountTokenDesired,uint amountTokenMin,uint amountETHMin,address to,uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin, address to, uint deadline) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] memory path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IPVault {\n', '    function deposit(uint256 amount) external;\n', '    function claimReward(uint256 amount) external;\n', '    function claimRewardAll() external;\n', '    function withdraw(uint256 amount) external;\n', '}\n', '\n', 'interface YCrvGauge {\n', '    function deposit(uint256 amount) external;\n', '    function withdraw(uint256 amount) external;\n', '    function integrate_fraction(address account) external view returns (uint256);\n', '    function user_checkpoint(address account) external returns (bool);\n', '    function crv_token() external view returns (address);\n', '    function controller() external view returns (address);\n', '    function period() external view returns (uint256);\n', '    function period_timestamp(uint256 amount) external view returns (uint256);\n', '    function integrate_inv_supply(uint256 amount) external view returns (uint256);\n', '    function integrate_inv_supply_of(address account) external view returns (uint256);\n', '    function inflation_rate() external view returns (uint256);\n', '    function future_epoch_time() external view returns (uint256);\n', '    function working_balances(address account) external view returns (uint256);\n', '    function working_supply() external view returns (uint256);\n', '}\n', '\n', 'interface Controller {\n', '    function gauge_relative_weight(address account, uint256 time) external view returns (uint256);\n', '}\n', '\n', 'interface CRV20 {\n', '    function rate() external view returns (uint256);\n', '}\n', '\n', 'interface TokenMinter {\n', '    function mint(address account) external;\n', '    function minted(address account, address guage) external view returns (uint256);\n', '}\n', '\n', 'interface IUniswapV2ERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', 'contract auto_pvault {\n', '\n', '    IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    UniswapRouter constant UNIROUTER = UniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '    IUniswapV2ERC20 constant LPT = IUniswapV2ERC20(0xBe9Ba93515e87C7Bd3A0CEbB9f61AAabE7A77Dd3);\n', '    YCrvGauge constant YCRVGAUGE = YCrvGauge(0xFA712EE4788C042e2B7BB55E6cb8ec569C4530c1);\n', '    TokenMinter constant TOKENMINTER = TokenMinter(0xd061D61a4d941c39E5453435B6345Dc261C2fcE0);\n', '    IERC20 constant CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\n', '\n', '    IERC20 public token0;\n', '    IERC20 public token1;\n', '    IPVault public pvault;\n', '\n', '    address public feeAddress;\n', '    address public treasury;\n', '    address public gov;\n', '    address[] internal stakeholders;\n', '\n', '    string public vaultName;\n', '    uint32 constant TOTALRATE = 10000;\n', '    uint32 public feeRate;\n', '    uint32 public rewardUserRate = 7000;\n', '    uint32 public rewardTreasuryRate = 3000;\n', '    uint32 public gasRewardTreasuryRate = 7000;\n', '    uint32 public pvault_rate = 2000;\n', '    uint256 constant WEEK = 604800;\n', '    uint256 public address_array_len;\n', '    uint256 constant TOTALWETHRATE = 10000000000;\n', '    uint256 constant TOTALUSERWETHSHARE = 5384615385;\n', '    uint256 public timestamp_block;\n', '    uint256 public max;\n', '    uint256 public finalP;\n', '    uint256 public finalW;\n', '    uint256 public finalLPT;\n', '    uint256 public delayDuration = 1 days;\n', '\n', '    event yCRVDeposited(address indexed user, uint amount);\n', '    event AllRewardsClaimed(address indexed user, uint amount, uint amount2);\n', '    event WithdrawnAndAllRewardsClaimed(address indexed user, uint amount, uint amount2, uint amount3);\n', '    event AutoCompoundedCRV2PVAULT(address indexed user, uint amount);\n', '    event MassAutoCompoundedCRV2PVAULT(address indexed user, uint amount);\n', '\n', '    struct User {\n', '        uint256 rewardedBalancePerUser; // CRV\n', '        uint256 lastTimestampPerUser; \n', '        uint256 depositBalancePerUser;  // in yCRV\n', '        uint256 accDepositBalancePerUser; // in yCRV\n', '        uint256 lpTokenUserReward; // LP Token\n', "        uint256 userRewardProportion; // Proportion entitled to based on user's deposit in relation to total deposits\n", '        uint256 massClaimReward;\n', '        uint256 rewardedPYLON;\n', '    }\n', '\n', '    struct Global {\n', '        uint256 lastTotalTimestamp;\n', '        uint256 accTotalReward;\n', '        uint256 totalDeposit;\n', '        uint256 accTotalDeposit;\n', '        uint256 totalDepositForAPY;\n', '        uint256 lpTokenReward;\n', '        uint256 userCount;\n', '        uint256 lpTotalDeposit;\n', '        uint256 lastMassDrainTimestamp;\n', '        uint256 totalPYLON;\n', '        bool isEligibleI;\n', '    }\n', '\n', '    struct vals {\n', '        uint256 pylonAmount;\n', '        uint256 wethUser;\n', '        uint256 lpAmount;  \n', '        uint256 wethSent;\n', '        uint256 pylonSent;\n', '        uint256 pylonNeeded;\n', '        uint256 wethNeeded;\n', '        uint256 crvNeeded4Reward;\n', '        uint256 gasRewardTreasury;\n', '        uint256 finalLPTsent;\n', '        uint256 crv4LP;\n', '        uint256 crvFromGauge;\n', '        uint256 crv4pylonLP;\n', '        uint256 crv4wethLP;\n', '    }\n', '\n', '    // gas price is in wei\n', '    struct vespiangas {\n', '        uint getRewardGas;\n', '        uint getRewardGasPrice;\n', '    }\n', '\n', '    mapping(address => User) public user_; \n', '    mapping(uint256 => Global) public global_;\n', '    mapping(uint256 => vals) public vals_;\n', '    mapping(uint256 => vespiangas) public gas_;\n', '\n', '    constructor (address _token0, address _token1, address _feeAddress, address _pvault, string memory name, address _treasury) payable {\n', '        token0 = IERC20(_token0);\n', '        token1 = IERC20(_token1);\n', '        feeAddress = _feeAddress;\n', '        pvault = IPVault(_pvault);\n', '        vaultName = name;\n', '        gov = msg.sender;\n', '        treasury = _treasury;\n', '        token0.approve(address(YCRVGAUGE), type(uint).max);\n', '        CRV.approve(address(UNIROUTER), type(uint).max);\n', '        CRV.approve(address(this), type(uint).max);\n', '        WETH.approve(address(UNIROUTER), type(uint).max);\n', '        token1.approve(address(UNIROUTER), type(uint).max);\n', '        token1.approve(address(this), type(uint).max);\n', '        WETH.approve(address(this), type(uint).max);\n', '        WETH.approve(address(LPT), type(uint).max);\n', '        token1.approve(address(LPT), type(uint).max);\n', '        LPT.approve(address(this), type(uint).max);\n', '    }\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == gov, "!governance");\n', '        _;\n', '    }\n', '\n', '    function isStakeholder(address _address) public view returns(bool, uint256) {\n', '        for (uint256 s = 0; s < stakeholders.length; s += 1){\n', '            if (_address == stakeholders[s]) return (true, s);\n', '        }\n', '        return (false, 0);\n', '    }\n', '\n', '    function isMassDrainEligible() internal returns (bool){\n', '        \n', '        bool result;\n', '        \n', '        // if first time calling this function via massAutoCompoundCRV2PVAULT then global_[0].lastMassDrainTimestamp\n', "        // will be assigned as the current timestamp and return false since 24 hours likely hasn't passed.\n", '        if (global_[0].lastMassDrainTimestamp == 0) {\n', '            global_[0].lastMassDrainTimestamp = block.timestamp;\n', '            result = false;\n', '        }\n', '        else if (global_[0].lastMassDrainTimestamp + delayDuration > block.timestamp) {\n', "            result = false; // last time was called + 24 hours is larger than current time, so 24 hours hasn't passed\n", '        }\n', '        else {\n', '            result = true;\n', '        }\n', '        global_[0].isEligibleI = result;\n', '        return (result);\n', '    }\n', '\n', '    function isEligibleExternal() external returns (bool){\n', '        \n', '        bool result;\n', '        \n', '        // if first time calling this function via massAutoCompoundCRV2PVAULT then global_[0].lastMassDrainTimestamp\n', "        // will be assigned as the current timestamp and return false since 24 hours likely hasn't passed.\n", '        if (global_[0].lastMassDrainTimestamp == 0) {\n', '            global_[0].lastMassDrainTimestamp = block.timestamp;\n', '            result = false;\n', '        }\n', '        else if (global_[0].lastMassDrainTimestamp + delayDuration > block.timestamp) {\n', "            result = false; // last time was called + 24 hours is larger than current time, so 24 hours hasn't passed\n", '        }\n', '        else {\n', '            result = true;\n', '        }\n', '        global_[0].isEligibleI = result;\n', '        return (result);\n', '    }\n', '    \n', "    // don't need to call this on main net test if the isEligibleExternal function is called first\n", '    function setMassTS() external {\n', '        if (global_[0].lastMassDrainTimestamp == 0) {\n', '            global_[0].lastMassDrainTimestamp = block.timestamp;\n', '        }\n', '    }\n', '\n', '    function addStakeholder(address _stakeholder) public {\n', '        (bool _isStakeholder, ) = isStakeholder(_stakeholder);\n', '        if(!_isStakeholder) stakeholders.push(_stakeholder);\n', '    }\n', '\n', '    function removeStakeholder(address _stakeholder) public {\n', '        (bool _isStakeholder, uint256 s) = isStakeholder(_stakeholder);\n', '        if(_isStakeholder){\n', '            stakeholders[s] = stakeholders[stakeholders.length - 1];\n', '            stakeholders.pop();\n', '        }\n', '    }\n', '\n', '    modifier updateBalance(address userAddress) {\n', '        uint lastTimestamp = user_[userAddress].lastTimestampPerUser;\n', '        uint totalTimestamp = global_[0].lastTotalTimestamp;\n', '        if (lastTimestamp > 0) {\n', '            user_[userAddress].accDepositBalancePerUser += user_[userAddress].depositBalancePerUser * (block.timestamp - lastTimestamp);\n', '        }\n', '\n', '        if (totalTimestamp > 0) {\n', '            global_[0].accTotalDeposit += global_[0].totalDeposit * (block.timestamp - totalTimestamp);\n', '        }\n', '        user_[userAddress].lastTimestampPerUser = block.timestamp;\n', '        global_[0].lastTotalTimestamp = block.timestamp;\n', '        _;\n', '    }\n', '\n', '    modifier updateBalanceAllUsers() {\n', '\n', '        uint totalTimestamp = global_[0].lastTotalTimestamp;\n', '\n', '        // userCount is updated when someone deposits or withdraws\n', '        for (uint i=0; i < global_[0].userCount ; i += 1){\n', '\n', '            address ua = stakeholders[i];\n', '\n', '            uint lastTimestamp = user_[ua].lastTimestampPerUser;\n', '\n', '            if (lastTimestamp > 0) {\n', '                user_[ua].accDepositBalancePerUser += user_[ua].depositBalancePerUser * (block.timestamp - lastTimestamp);\n', '            }\n', '\n', '            user_[ua].lastTimestampPerUser = block.timestamp;\n', '        }\n', '\n', '        if (totalTimestamp > 0) {\n', '            global_[0].accTotalDeposit += global_[0].totalDeposit * (block.timestamp - totalTimestamp);\n', '        }\n', '        global_[0].lastTotalTimestamp = block.timestamp; \n', '        _;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        if (a > b) {\n', '            return b;\n', '        }\n', '        else {\n', '            return a;\n', '        }\n', '    }\n', '\n', '    function setGovernance(address _gov)\n', '        external\n', '        onlyGov\n', '    {\n', '        gov = _gov;\n', '    }\n', '\n', '    function setToken0(address _token)\n', '        external\n', '        onlyGov\n', '    {\n', '        token0 = IERC20(_token);\n', '    }\n', '\n', '    function setToken1(address _token)\n', '        external\n', '        onlyGov\n', '    {\n', '        token1 = IERC20(_token);\n', '    }\n', '\n', '    function setTreasury(address _treasury)\n', '        external\n', '        onlyGov\n', '    {\n', '        treasury = _treasury;\n', '    }\n', '\n', '    function setUserRate(uint32 _rewardUserRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        rewardUserRate = _rewardUserRate;\n', '    }\n', '\n', '    function setTreasuryRate(uint32 _rewardTreasuryRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        rewardTreasuryRate = _rewardTreasuryRate;\n', '    }\n', '\n', '    function setFeeAddress(address _feeAddress)\n', '        external\n', '        onlyGov\n', '    {\n', '        feeAddress = _feeAddress;\n', '    }\n', '\n', '    function setFeeRate(uint32 _feeRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        feeRate = _feeRate;\n', '    }\n', '\n', '    function setVaultName(string memory name)\n', '        external\n', '        onlyGov\n', '    {\n', '        vaultName = name;\n', '    }\n', '\n', '    function getRewardI() internal {\n', '\n', '        uint256 rewardAmountForCRVToken = CRV.balanceOf(address(this));\n', '        TOKENMINTER.mint(address(YCRVGAUGE));\n', '        rewardAmountForCRVToken = CRV.balanceOf(address(this)) - rewardAmountForCRVToken;\n', '        uint256 rewardCRVTokenAmountForUsers = rewardAmountForCRVToken * rewardUserRate / TOTALRATE;\n', '        uint256 rewardCRVTokenAmountForTreasury = rewardAmountForCRVToken - rewardCRVTokenAmountForUsers; // 30% of reward goes to treasur\n', '\n', '        uint256 rewardPylonTokenAmountForUsers = token1.balanceOf(address(this));\n', '        \n', '        // apportion respective amounts to be made into ETH-PYLON LP Token\n', '        uint256 AmountForUsersCRV2PYLON = rewardCRVTokenAmountForUsers / 2; // 50% of the 70% will be converted to Pylon\n', '        uint256 amountForUsersCRV2WETH = rewardCRVTokenAmountForUsers / 2; // other 50% of the 70% will be converted to WET\n', '        \n', '        // combine the 50% CRV for user and 30% CRV for treasury so that only one call is made to convert CRV to WETH, will apportion returned WETH correctly below\n', '        uint256 totalCrv2WethReward = amountForUsersCRV2WETH + rewardCRVTokenAmountForTreasury;\n', '\n', '        address[] memory tokens = new address[](3);\n', '        address[] memory tokens1 = new address[](2);\n', '\n', '        tokens[0] = address(CRV);\n', '        tokens[1] = address(WETH);\n', '        tokens[2] = address(token1);\n', '        tokens1[0] = address(CRV);\n', '        tokens1[1] = address(WETH);\n', '\n', '        if (rewardCRVTokenAmountForUsers > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(AmountForUsersCRV2PYLON, 0, tokens, address(this), type(uint).max);\n', '        }\n', '\n', '        uint256 wethBalance = WETH.balanceOf(address(this));\n', '        if (totalCrv2WethReward > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(totalCrv2WethReward, 0, tokens1, address(this), type(uint).max);\n', '        }\n', '\n', '        wethBalance = WETH.balanceOf(address(this)) - wethBalance;\n', '\n', '        // lpWETH gets set to the proportion of WETH to go to users (that will be used in LP token creation)\n', '        uint256 lpWETH = wethBalance * TOTALUSERWETHSHARE / TOTALWETHRATE; // rougly 54% of WETH returned from CRV 2 WETH swap will go to LP token creation\n', '        vals_[0].wethUser = lpWETH;\n', '        uint256 treasuryWETH = wethBalance - lpWETH; // remaining ~46% of CRV 2 WETH swap goes to treasury\n', '\n', '        // Pylon amount to be combined with WETH to make LP Token\n', '        vals_[0].pylonAmount += token1.balanceOf(address(this)) - rewardPylonTokenAmountForUsers;\n', '\n', '        // Transfer reward to Treasury\n', '        if (treasuryWETH > 0) {\n', '            WETH.transfer(treasury, treasuryWETH);\n', '        }\n', '\n', '        addLiquidityAndStakeI();\n', '\n', '    }\n', '\n', '    function assessGasV2() internal {\n', '        \n', '        address[] memory tokens1 = new address[](2);\n', '        tokens1[0] = address(CRV);\n', '        tokens1[1] = address(WETH);\n', '\n', '        uint256 wethBalance = WETH.balanceOf(address(this));\n', '        uint256 crvRewardNeeded4swap = vals_[0].crvNeeded4Reward;\n', '        if (crvRewardNeeded4swap > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(crvRewardNeeded4swap, 0, tokens1, address(this), type(uint).max);\n', '        }\n', '\n', '        wethBalance = WETH.balanceOf(address(this)) - wethBalance;\n', '\n', '        uint256 gasRewardTreasury = wethBalance * gasRewardTreasuryRate / TOTALRATE;\n', '        vals_[0].gasRewardTreasury = gasRewardTreasury; // will combine with weth reward for treasury in getRewardAllI()\n', '        \n', '        uint256 userMassGasReward  = wethBalance - gasRewardTreasury;\n', '        user_[msg.sender].massClaimReward = userMassGasReward;\n', '\n', '        // Transfer gas reward to user\n', '        if (userMassGasReward > 0) {\n', '            WETH.transfer(msg.sender, userMassGasReward);\n', '        }\n', '\n', '        // Transfer gas Reward to Treasury\n', '        if (gasRewardTreasury > 0) {\n', '            WETH.transfer(treasury, gasRewardTreasury);\n', '        }\n', '    }\n', '    \n', '    function getRewardAll() internal {\n', '\n', '        TOKENMINTER.mint(address(YCRVGAUGE));\n', '        uint256 rewardAmountForCRVToken = CRV.balanceOf(address(this));\n', '        vals_[0].crvFromGauge = rewardAmountForCRVToken;\n', '\n', "        uint256 numUsers = global_[0].userCount - 1; // subtracting 1 since the user calling shouldn't be included in calculation\n", '        \n', '        uint256 getRewardGasWei = 479470 * numUsers * tx.gasprice;\n', '        gas_[0].getRewardGas = getRewardGasWei;\n', '        //gas_[0].getRewardGasPrice = tx.gasprice;\n', '\n', '        address[] memory tokens = new address[](3);\n', '        address[] memory tokens1 = new address[](2);\n', '\n', '        tokens[0] = address(CRV);\n', '        tokens[1] = address(WETH);\n', '        tokens[2] = address(token1);\n', '        tokens1[0] = address(CRV);\n', '        tokens1[1] = address(WETH);\n', '        \n', '        uint256 crv_needed = UNIROUTER.getAmountsIn(getRewardGasWei, tokens1)[0];\n', '        vals_[0].crvNeeded4Reward = crv_needed;\n', '\n', '        uint256 rewardCRVTokenAmountForTreasury = rewardAmountForCRVToken * rewardTreasuryRate / TOTALRATE; // 30% of reward goes to treasur\n', '        uint256 rewardCRVTokenAmountForUsers = rewardAmountForCRVToken - rewardCRVTokenAmountForTreasury;\n', '        \n', '        require(rewardCRVTokenAmountForUsers > crv_needed, "CRV reward from gauge not yet big enough for mass autocompound");\n', '        rewardCRVTokenAmountForUsers = rewardCRVTokenAmountForUsers - crv_needed; // subtract out CRV needed for gasReward\n', '        vals_[0].crv4LP = rewardCRVTokenAmountForUsers;\n', '        \n', '        if (rewardCRVTokenAmountForUsers > 0){\n', '            assessGasV2(); \n', '        }\n', '\n', '        uint256 rewardPylonTokenAmountForUsers = token1.balanceOf(address(this));\n', '        \n', '        // apportion respective amounts to be made into ETH-PYLON LP Token\n', '        uint256 AmountForUsersCRV2PYLON = rewardCRVTokenAmountForUsers / 2; // 50% of the 70% will be converted to Pylon\n', '        vals_[0].crv4pylonLP = AmountForUsersCRV2PYLON;\n', '        uint256 amountForUsersCRV2WETH = rewardCRVTokenAmountForUsers / 2; // other 50% of the 70% will be converted to WET\n', '        vals_[0].crv4wethLP = amountForUsersCRV2WETH;\n', '        \n', '        \n', '        // combine the 50% CRV for user and 30% CRV for treasury so that only one call is made to convert CRV to WETH, will apportion returned WETH correctly below\n', '        uint256 totalCrv2WethReward = amountForUsersCRV2WETH + rewardCRVTokenAmountForTreasury; \n', '\n', '        if (rewardCRVTokenAmountForUsers > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(AmountForUsersCRV2PYLON, 0, tokens, address(this), type(uint).max);\n', '        }\n', '\n', '        uint256 wethBalance = WETH.balanceOf(address(this));\n', '        if (totalCrv2WethReward > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(totalCrv2WethReward, 0, tokens1, address(this), type(uint).max);\n', '        }\n', '\n', '        wethBalance = WETH.balanceOf(address(this)) - wethBalance;\n', '\n', '        // lpWETH gets set to the proportion of WETH to go to users (that will be used in LP token creation)\n', '        uint256 lpWETH = wethBalance * TOTALUSERWETHSHARE / TOTALWETHRATE; // rougly 54% of WETH returned from CRV 2 WETH swap will go to LP token creation\n', '        vals_[0].wethUser = lpWETH;\n', '        uint256 treasuryWETH = wethBalance - lpWETH; // remaining ~46% of CRV 2 WETH swap goes to treasury\n', '\n', '        // Pylon amount to be combined with WETH to make LP Token\n', '        vals_[0].pylonAmount = token1.balanceOf(address(this)) - rewardPylonTokenAmountForUsers;\n', '\n', '        addLiquidityAndStakeI(); // make LP token\n', '\n', '        // Transfer reward to Treasury\n', '        if (treasuryWETH > 0) {\n', '            WETH.transfer(treasury, treasuryWETH);\n', '        }\n', '    }\n', '\n', '    function addLiquidityAndStakeI() internal {\n', '        \n', '        uint pylonSent;\n', '        uint wethSent;\n', '        uint lpTotalReward;\n', '\n', '        // approving again; will test removing these as constructor should be doing this...\n', '        WETH.approve(address(LPT), type(uint).max);\n', '        token1.approve(address(LPT), type(uint).max);\n', '        \n', '        finalP = vals_[0].pylonAmount;\n', '        finalW = vals_[0].wethUser;\n', '        \n', '        // Need 50/50 PYLON/WETH for LP Token\n', '        if (finalP > finalW){\n', '            finalP = finalW;\n', '        }\n', '        if (finalW > finalP){\n', '            finalW = finalP;\n', '        }\n', '\n', '        // makes PYLON-ETH LP Token and sends to contract\n', '        (pylonSent, wethSent, lpTotalReward) = UNIROUTER.addLiquidity(address(token1), address(WETH), finalP, finalW, 0,  0, address(this), block.timestamp); \n', '\n', '        global_[0].lpTokenReward = LPT.balanceOf(address(this));\n', '    }\n', '\n', '    function _depositYCRV(uint amount) internal updateBalance(msg.sender) {\n', '\n', '        uint feeAmount = amount * feeRate / TOTALRATE;\n', '        uint realAmount = amount - feeAmount;\n', '\n', '        if (feeAmount > 0) {\n', '            token0.transferFrom(msg.sender, feeAddress, feeAmount);\n', '        }\n', '        \n', '        if (realAmount > 0) {\n', '            token0.transferFrom(msg.sender, address(this), realAmount);\n', '            YCRVGAUGE.deposit(realAmount);\n', '            user_[msg.sender].depositBalancePerUser += realAmount;\n', '            global_[0].totalDeposit += realAmount;\n', '            global_[0].totalDepositForAPY += realAmount;\n', '            emit yCRVDeposited(msg.sender, realAmount);\n', '        }\n', '    }\n', '\n', '    // need to reset accounts when switching on metamask and remix\n', '    function depositYCRV(uint amount) external {\n', '        require(amount > 0, "deposit must be greater than 0");\n', '        // check if user has deposited before, if not then will add to stakeholder list, otherwise does nothing\n', '        addStakeholder(msg.sender);\n', '        global_[0].userCount = stakeholders.length; // update this before updateBalance modifier is applied to _deposit\n', '        _depositYCRV(amount);\n', '    }\n', '\n', '    function updateUserPylonReward() internal {\n', '\n', '        // grab total pylon reward from pvault\n', '        pvault.claimRewardAll();\n', '        uint256 PYLON = token1.balanceOf(address(this));\n', '        global_[0].totalPYLON += PYLON;\n', '\n', "        // loop through stakeholders array and update each user's pylon reward\n", '        for (uint i=0; i < global_[0].userCount ; i += 1) {\n', '\n', '            address ua = stakeholders[i];\n', '            user_[ua].rewardedPYLON += PYLON * user_[ua].accDepositBalancePerUser / global_[0].accTotalDeposit;\n', '        }\n', '    }\n', '\n', '    // same as withdrawAndClaimAllRewards except leaves the yCRV deposited in the gauge\n', '    function ClaimAllRewards() external updateBalance(msg.sender) {\n', '        \n', '        // LPT Withdrawl from PVAULT\n', '        uint lpDepositBalance = user_[msg.sender].lpTokenUserReward; \n', '        uint amountWithdrawForLPT = LPT.balanceOf(address(this));\n', "        pvault.withdraw(lpDepositBalance); // assumes that this contract's address is sent to pvault so that the transfer below must happen\n", '        amountWithdrawForLPT = LPT.balanceOf(address(this)) - amountWithdrawForLPT;\n', '        LPT.transfer(msg.sender, amountWithdrawForLPT); // assumes that \n', '\n', '        user_[msg.sender].lpTokenUserReward = user_[msg.sender].lpTokenUserReward - amountWithdrawForLPT; // should be 0 after thi\n', '        global_[0].lpTotalDeposit -= amountWithdrawForLPT;\n', '\n', '        // PYLON Withdrawl from PVAULT\n', '        updateUserPylonReward();\n', '        uint256 amountWithdrawForPYLON = user_[msg.sender].rewardedPYLON; \n', '        global_[0].totalPYLON -= amountWithdrawForPYLON;\n', '\n', '        token1.transfer(msg.sender, amountWithdrawForPYLON);\n', '\n', '        emit AllRewardsClaimed(msg.sender, amountWithdrawForLPT, amountWithdrawForPYLON);\n', '    }\n', '\n', "    // need to test assumption that this contract's address is being used here rather than sending on msg.sender to the pvault contract; I think its the former\n", '    function _withdrawAndClaimAllRewards() internal updateBalance(msg.sender) {\n', '        \n', '        uint ycrvDepositBalance = user_[msg.sender].depositBalancePerUser;\n', '        uint amountWithdrawForYCRV = token0.balanceOf(address(this));\n', '        YCRVGAUGE.withdraw(ycrvDepositBalance);\n', '        amountWithdrawForYCRV = token0.balanceOf(address(this)) - amountWithdrawForYCRV;\n', '        token0.transfer(msg.sender, amountWithdrawForYCRV);\n', '        \n', '        user_[msg.sender].depositBalancePerUser = ycrvDepositBalance - amountWithdrawForYCRV;\n', '        global_[0].totalDeposit -= amountWithdrawForYCRV;\n', '\n', '        // LPT Withdrawl from PVAULT\n', '        uint lpDepositBalance = user_[msg.sender].lpTokenUserReward; \n', '        uint amountWithdrawForLPT = LPT.balanceOf(address(this));\n', "        pvault.withdraw(lpDepositBalance); // assumes that this contract's address is sent to pvault so that the transfer below must happen\n", '        amountWithdrawForLPT = LPT.balanceOf(address(this)) - amountWithdrawForLPT;\n', '        LPT.transfer(msg.sender, amountWithdrawForLPT); // assumes that \n', '\n', '        user_[msg.sender].lpTokenUserReward = user_[msg.sender].lpTokenUserReward - amountWithdrawForLPT; // should be 0 after thi\n', '        global_[0].lpTotalDeposit -= amountWithdrawForLPT;\n', '\n', '        // PYLON Withdrawl from PVAULT\n', '        updateUserPylonReward();\n', '        uint256 amountWithdrawForPYLON = user_[msg.sender].rewardedPYLON; \n', '        global_[0].totalPYLON -= amountWithdrawForPYLON;\n', '\n', '        token1.transfer(msg.sender, amountWithdrawForPYLON);\n', '\n', '        emit WithdrawnAndAllRewardsClaimed(msg.sender, amountWithdrawForYCRV, amountWithdrawForLPT, amountWithdrawForPYLON);\n', '    }\n', '\n', '    function withdrawAndClaimAllRewards() external {\n', '        removeStakeholder(msg.sender);\n', '        global_[0].userCount = stakeholders.length; //need to make sure that stakeholders array is actually getting updated properly\n', '        _withdrawAndClaimAllRewards();\n', '    }\n', '    \n', '    function autoCompoundCRV2PVAULT() external updateBalance(msg.sender) {\n', '        getRewardI(); \n', '\n', '        require(global_[0].userCount > 0, "no users have deposited");\n', '        uint256 LPTReward = global_[0].lpTokenReward;\n', '        require(LPTReward > 0, "can\'t deposit 0 LP token into pvault");\n', '        \n', "        uint256 userLPTReward = LPTReward * user_[msg.sender].accDepositBalancePerUser / global_[0].accTotalDeposit; // adjust for User's share before depositing on their behalf\n", '        user_[msg.sender].lpTokenUserReward = userLPTReward; // will need to decrement this in the PVWithdraw function\n', '\n', '        // do pvault deposit here\n', '        if (userLPTReward > LPTReward) {\n', '            userLPTReward = LPTReward;\n', '        }\n', '        if (userLPTReward > 0) {\n', '            \n', '            LPT.approve(address(this), type(uint).max);\n', '            LPT.approve(address(pvault), type(uint).max);\n', '\n', '            pvault.deposit(userLPTReward);\n', '            global_[0].lpTotalDeposit += userLPTReward; // keep track of total LP deposited by this contract\n', '\n', '            emit AutoCompoundedCRV2PVAULT(msg.sender, userLPTReward);\n', '        }      \n', '    }\n', '\n', '    // only using for testing for now\n', '    function alterMassTS() external {\n', '        global_[0].lastMassDrainTimestamp -= delayDuration;\n', '    }\n', '\n', '    function updateUserLPTReward() internal {\n', '\n', '        uint256 LPTReward = global_[0].lpTokenReward;\n', '\n', '        for (uint i=0; i < global_[0].userCount ; i += 1) {\n', '\n', '            address ua = stakeholders[i];\n', '            uint256 userLPTReward = LPTReward * user_[ua].accDepositBalancePerUser / global_[0].accTotalDeposit;\n', '            user_[ua].lpTokenUserReward  += userLPTReward;\n', '        }\n', '    }\n', '\n', '    function massAutoCompoundCRV2PVAULT() external updateBalanceAllUsers() {\n', '        \n', '        isMassDrainEligible(); // check that 24 hours has passed since last call \n', '        require(global_[0].isEligibleI == true, "24 hours has not yet passed since last mass drain");\n', '        require(global_[0].userCount > 1, "2 or more users need to have deposited - use claimReward instead");\n', '\n', '        getRewardAll();  \n', '\n', '        uint256 LPTReward = global_[0].lpTokenReward; \n', '        require(LPTReward > 0, "can\'t deposit 0 LP token into pvault");\n', '\n', "        updateUserLPTReward(); // update all user's share of LP Token reward\n", '\n', '        LPT.approve(address(this), type(uint).max); \n', '        LPT.approve(address(pvault), type(uint).max); \n', '\n', '        pvault.deposit(LPTReward); \n', '\n', '        global_[0].lpTotalDeposit += LPTReward; // keep track of total LP deposited by this contract\n', '            \n', '        global_[0].lastMassDrainTimestamp = block.timestamp;\n', '        emit MassAutoCompoundedCRV2PVAULT(msg.sender, LPTReward);\n', '    }\n', '\n', '    function seize(address token, address to) external onlyGov {\n', '        require(IERC20(token) != token1, "main tokens");\n', '        if (token != address(0)) {\n', '            uint amount = IERC20(token).balanceOf(address(this));\n', '            IERC20(token).transfer(to, amount);\n', '        }\n', '        else {\n', '            uint amount = address(this).balance;\n', '            payable(to).transfer(amount);\n', '        }\n', '    }\n', '        \n', '    fallback () external payable { }\n', '    receive () external payable {}\n', '}']