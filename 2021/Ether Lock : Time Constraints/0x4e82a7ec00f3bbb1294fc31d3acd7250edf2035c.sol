['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-15\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.7.4;\n', '\n', '\n', 'contract Context {\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    \n', '    function totalSupply() external view returns (uint256);\n', '\n', '    \n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '   \n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    \n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '  \n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '   \n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '   \n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    \n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    \n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '    \n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    \n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '   \n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '  \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '   \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    \n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    \n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    \n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '   \n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    \n', '    function isContract(address account) internal view returns (bool) {\n', '       \n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    \n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    \n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '   \n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    \n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', ' \n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        \n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    \n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    \n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        \n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    \n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    \n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        \n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    \n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    \n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    \n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    \n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Panzerprotocol is Context, IERC20, Ownable {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    string private constant NAME = "Panzerprotocol.io";\n', '    string private constant SYMBOL = "PNZR";\n', '    uint8 private constant DECIMALS = 18;\n', '\n', '    mapping(address => uint256) private rewards;\n', '    mapping(address => uint256) private actual;\n', '    mapping(address => mapping(address => uint256)) private allowances;\n', '\n', '    mapping(address => bool) private excludedFromFees;\n', '    mapping(address => bool) private excludedFromRewards;\n', '    address[] private rewardExcluded;\n', '\n', '    uint256 private constant MAX = ~uint256(0);\n', '    uint256 private constant ACTUAL_TOTAL = 111_000_000 * 1e18;\n', '    uint256 private rewardsTotal = (MAX - (MAX % ACTUAL_TOTAL));\n', '    uint256 private holderFeeTotal;\n', '    uint256 private marketingFeeTotal;\n', '    uint256 private lpFeeTotal;\n', '    \n', '\n', '    uint256 public taxPercentage = 3;\n', '    uint256 public holderTaxAlloc = 10;\n', '    uint256 public marketingTaxAlloc = 10;\n', '    uint256 public lpTaxAlloc = 10;\n', '    uint256 public totalTaxAlloc = marketingTaxAlloc.add(holderTaxAlloc).add(lpTaxAlloc);\n', '\n', '    address public marketingAddress;\n', '    address public lpStakingAddress;\n', '    \n', '\n', '    constructor(address _marketingAddress) {\n', '        rewards[_marketingAddress] = rewardsTotal;\n', '        emit Transfer(address(0), _marketingAddress, ACTUAL_TOTAL);\n', '\n', '        marketingAddress = _marketingAddress;\n', '\n', '        excludeFromRewards(_msgSender());\n', '        excludeFromFees(_marketingAddress);\n', '\n', '        if (_marketingAddress != _msgSender()) {\n', '            excludeFromRewards(_marketingAddress);\n', '            excludeFromFees(_msgSender());\n', '\n', '\n', '        }\n', '\n', '        excludeFromFees(address(0x000000000000000000000000000000000000dEaD));\n', '    }\n', '\n', '    function name() external pure returns (string memory) {\n', '        return NAME;\n', '    }\n', '\n', '    function symbol() external pure returns (string memory) {\n', '        return SYMBOL;\n', '    }\n', '\n', '    function decimals() external pure returns (uint8) {\n', '        return DECIMALS;\n', '    }\n', '\n', '    function totalSupply() external pure override returns (uint256) {\n', '        return ACTUAL_TOTAL;\n', '    }\n', '\n', '    function balanceOf(address _account) public view override returns (uint256) {\n', '        if (excludedFromRewards[_account]) {\n', '            return actual[_account];\n', '        }\n', '        return tokenWithRewards(rewards[_account]);\n', '    }\n', '\n', '    function transfer(address _recipient, uint256 _amount) public override returns (bool) {\n', '        _transfer(_msgSender(), _recipient, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view override returns (uint256) {\n', '        return allowances[_owner][_spender];\n', '    }\n', '\n', '    function approve(address _spender, uint256 _amount) public override returns (bool) {\n', '        _approve(_msgSender(), _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address _sender,\n', '        address _recipient,\n', '        uint256 _amount\n', '    ) public override returns (bool) {\n', '        _transfer(_sender, _recipient, _amount);\n', '\n', '        _approve(\n', '        _sender,\n', '            _msgSender(),\n', '            allowances[_sender][_msgSender()].sub(_amount, "ERC20: transfer amount exceeds allowance")\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address _spender, uint256 _addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), _spender, allowances[_msgSender()][_spender].add(_addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address _spender, uint256 _subtractedValue) public virtual returns (bool) {\n', '        _approve(\n', '            _msgSender(),\n', '            _spender,\n', '            allowances[_msgSender()][_spender].sub(_subtractedValue, "ERC20: decreased allowance below zero")\n', '        );\n', '        return true;\n', '    }\n', '\n', '    function isExcludedFromRewards(address _account) external view returns (bool) {\n', '        return excludedFromRewards[_account];\n', '    }\n', '\n', '    function isExcludedFromFees(address _account) external view returns (bool) {\n', '        return excludedFromFees[_account];\n', '    }\n', '\n', '    function totalFees() external view returns (uint256) {\n', '        return holderFeeTotal.add(marketingFeeTotal).add(lpFeeTotal);\n', '    }\n', '\n', '    function totalHolderFees() external view returns (uint256) {\n', '        return holderFeeTotal;\n', '    }\n', '\n', '    function totalMarketingFees() external view returns (uint256) {\n', '        return marketingFeeTotal;\n', '    }\n', '\n', '    function totalLpFees() external view returns (uint256) {\n', '        return lpFeeTotal;\n', '    }\n', '\n', '   \n', '\n', '    function distribute(uint256 _actualAmount) public {\n', '        address sender = _msgSender();\n', '        require(!excludedFromRewards[sender], "Excluded addresses cannot call this function");\n', '\n', '        (uint256 rewardAmount, , , , ) = _getValues(_actualAmount);\n', '        rewards[sender] = rewards[sender].sub(rewardAmount);\n', '        rewardsTotal = rewardsTotal.sub(rewardAmount);\n', '        holderFeeTotal = holderFeeTotal.add(_actualAmount);\n', '    }\n', '\n', '    function excludeFromFees(address _account) public onlyOwner() {\n', '        require(!excludedFromFees[_account], "Account is already excluded from fee");\n', '        excludedFromFees[_account] = true;\n', '    }\n', '\n', '    function includeInFees(address _account) public onlyOwner() {\n', '        require(excludedFromFees[_account], "Account is already included in fee");\n', '        excludedFromFees[_account] = false;\n', '    }\n', '\n', '    function excludeFromRewards(address _account) public onlyOwner() {\n', '        require(!excludedFromRewards[_account], "Account is already excluded from reward");\n', '\n', '        if (rewards[_account] > 0) {\n', '            actual[_account] = tokenWithRewards(rewards[_account]);\n', '        }\n', '\n', '        excludedFromRewards[_account] = true;\n', '        rewardExcluded.push(_account);\n', '    }\n', '\n', '    function includeInRewards(address _account) public onlyOwner() {\n', '        require(excludedFromRewards[_account], "Account is already included in rewards");\n', '\n', '        for (uint256 i = 0; i < rewardExcluded.length; i++) {\n', '            if (rewardExcluded[i] == _account) {\n', '                rewardExcluded[i] = rewardExcluded[rewardExcluded.length - 1];\n', '                actual[_account] = 0;\n', '                excludedFromRewards[_account] = false;\n', '                rewardExcluded.pop();\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _approve(\n', '        address _owner,\n', '        address _spender,\n', '        uint256 _amount\n', '    ) private {\n', '        require(_owner != address(0), "ERC20: approve from the zero address");\n', '        require(_spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        allowances[_owner][_spender] = _amount;\n', '        emit Approval(_owner, _spender, _amount);\n', '    }\n', '\n', '    function _transfer(\n', '        address _sender,\n', '        address _recipient,\n', '        uint256 _amount\n', '    ) private {\n', '        require(_sender != address(0), "ERC20: transfer from the zero address");\n', '        require(_recipient != address(0), "ERC20: transfer to the zero address");\n', '        require(_amount > 0, "Transfer amount must be greater than zero");\n', '\n', '        uint256 currentTaxPercentage = taxPercentage;\n', '        if (excludedFromFees[_sender] || excludedFromFees[_recipient]) {\n', '            taxPercentage = 0;\n', '        } else {\n', '            uint256 fee = _getFee(_amount);\n', '            uint256 marketingFee = _getMarketingFee(fee);\n', '            uint256 lpFee = _getLpFee(fee);\n', '\n', '            _updateMarketingFee(marketingFee);\n', '            _updateLpFee(lpFee);\n', '            \n', '        }\n', '\n', '        if (excludedFromRewards[_sender] && !excludedFromRewards[_recipient]) {\n', '            _transferWithoutSenderRewards(_sender, _recipient, _amount);\n', '        } else if (!excludedFromRewards[_sender] && excludedFromRewards[_recipient]) {\n', '            _transferWithRecipientRewards(_sender, _recipient, _amount);\n', '        } else if (!excludedFromRewards[_sender] && !excludedFromRewards[_recipient]) {\n', '            _transferWithRewards(_sender, _recipient, _amount);\n', '        } else if (excludedFromRewards[_sender] && excludedFromRewards[_recipient]) {\n', '            _transferWithoutRewards(_sender, _recipient, _amount);\n', '        } else {\n', '            _transferWithRewards(_sender, _recipient, _amount);\n', '        }\n', '\n', '        if (currentTaxPercentage != taxPercentage) {\n', '            taxPercentage = currentTaxPercentage;\n', '        }\n', '    }\n', '\n', '    function _transferWithRewards(\n', '        address _sender,\n', '        address _recipient,\n', '        uint256 _actualAmount\n', '    ) private {\n', '        (\n', '            uint256 rewardAmount,\n', '            uint256 rewardTransferAmount,\n', '            uint256 rewardFee,\n', '            uint256 actualTransferAmount,\n', '            uint256 actualFee\n', '        ) = _getValues(_actualAmount);\n', '\n', '        rewards[_sender] = rewards[_sender].sub(rewardAmount);\n', '        rewards[_recipient] = rewards[_recipient].add(rewardTransferAmount);\n', '        _updateHolderFee(rewardFee, actualFee);\n', '        emit Transfer(_sender, _recipient, actualTransferAmount);\n', '    }\n', '\n', '    function _transferWithRecipientRewards(\n', '        address _sender,\n', '        address _recipient,\n', '        uint256 _actualAmount\n', '    ) private {\n', '        (\n', '            uint256 rewardAmount,\n', '            uint256 rewardTransferAmount,\n', '            uint256 rewardFee,\n', '            uint256 actualTransferAmount,\n', '            uint256 actualFee\n', '        ) = _getValues(_actualAmount);\n', '\n', '        rewards[_sender] = rewards[_sender].sub(rewardAmount);\n', '        actual[_recipient] = actual[_recipient].add(actualTransferAmount);\n', '        rewards[_recipient] = rewards[_recipient].add(rewardTransferAmount);\n', '        _updateHolderFee(rewardFee, actualFee);\n', '        emit Transfer(_sender, _recipient, actualTransferAmount);\n', '    }\n', '\n', '    function _transferWithoutSenderRewards(\n', '        address _sender,\n', '        address _recipient,\n', '        uint256 _actualAmount\n', '    ) private {\n', '        (\n', '            uint256 rewardAmount,\n', '            uint256 rewardTransferAmount,\n', '            uint256 rewardFee,\n', '            uint256 actualTransferAmount,\n', '            uint256 actualFee\n', '        ) = _getValues(_actualAmount);\n', '\n', '        actual[_sender] = actual[_sender].sub(_actualAmount);\n', '        rewards[_sender] = rewards[_sender].sub(rewardAmount);\n', '        rewards[_recipient] = rewards[_recipient].add(rewardTransferAmount);\n', '        _updateHolderFee(rewardFee, actualFee);\n', '        emit Transfer(_sender, _recipient, actualTransferAmount);\n', '    }\n', '\n', '    function _transferWithoutRewards(\n', '        address _sender,\n', '        address _recipient,\n', '        uint256 _actualAmount\n', '    ) private {\n', '        (\n', '            uint256 rewardAmount,\n', '            uint256 rewardTransferAmount,\n', '            uint256 rewardFee,\n', '            uint256 actualTransferAmount,\n', '            uint256 actualFee\n', '        ) = _getValues(_actualAmount);\n', '\n', '        actual[_sender] = actual[_sender].sub(_actualAmount);\n', '        rewards[_sender] = rewards[_sender].sub(rewardAmount);\n', '        actual[_recipient] = actual[_recipient].add(actualTransferAmount);\n', '        rewards[_recipient] = rewards[_recipient].add(rewardTransferAmount);\n', '        _updateHolderFee(rewardFee, actualFee);\n', '        emit Transfer(_sender, _recipient, actualTransferAmount);\n', '    }\n', '\n', '    function _updateHolderFee(uint256 _rewardFee, uint256 _actualFee) private {\n', '        rewardsTotal = rewardsTotal.sub(_rewardFee);\n', '        holderFeeTotal = holderFeeTotal.add(_actualFee);\n', '    }\n', '\n', '    function _updateMarketingFee(uint256 _marketingFee) private {\n', '        if (marketingAddress == address(0)) {\n', '            return;\n', '        }\n', '\n', '        uint256 rewardsRate = _getRewardsRate();\n', '        uint256 rewardMarketingFee = _marketingFee.mul(rewardsRate);\n', '        marketingFeeTotal = marketingFeeTotal.add(_marketingFee);\n', '\n', '        rewards[marketingAddress] = rewards[marketingAddress].add(rewardMarketingFee);\n', '        if (excludedFromRewards[marketingAddress]) {\n', '            actual[marketingAddress] = actual[marketingAddress].add(_marketingFee);\n', '        }\n', '    }\n', '\n', '    function _updateLpFee(uint256 _lpFee) private {\n', '        if (lpStakingAddress == address(0)) {\n', '            return;\n', '        }\n', '\n', '        uint256 rewardsRate = _getRewardsRate();\n', '        uint256 rewardLpFee = _lpFee.mul(rewardsRate);\n', '        lpFeeTotal = lpFeeTotal.add(_lpFee);\n', '\n', '        rewards[lpStakingAddress] = rewards[lpStakingAddress].add(rewardLpFee);\n', '        if (excludedFromRewards[lpStakingAddress]) {\n', '            actual[lpStakingAddress] = actual[lpStakingAddress].add(_lpFee);\n', '        }\n', '    }\n', '\n', '\n', '\n', '    function rewardsFromToken(uint256 _actualAmount, bool _deductTransferFee) public view returns (uint256) {\n', '        require(_actualAmount <= ACTUAL_TOTAL, "Amount must be less than supply");\n', '        if (!_deductTransferFee) {\n', '            (uint256 rewardAmount, , , , ) = _getValues(_actualAmount);\n', '            return rewardAmount;\n', '        } else {\n', '            (, uint256 rewardTransferAmount, , , ) = _getValues(_actualAmount);\n', '            return rewardTransferAmount;\n', '        }\n', '    }\n', '\n', '    function tokenWithRewards(uint256 _rewardAmount) public view returns (uint256) {\n', '        require(_rewardAmount <= rewardsTotal, "Amount must be less than total rewards");\n', '        uint256 rewardsRate = _getRewardsRate();\n', '        return _rewardAmount.div(rewardsRate);\n', '    }\n', '\n', '    function _getValues(uint256 _actualAmount)\n', '        private\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        (uint256 actualTransferAmount, uint256 actualFee) = _getActualValues(_actualAmount);\n', '        uint256 rewardsRate = _getRewardsRate();\n', '        (\n', '            uint256 rewardAmount,\n', '            uint256 rewardTransferAmount,\n', '            uint256 rewardFee\n', '        ) = _getRewardValues(_actualAmount, actualFee, rewardsRate);\n', '\n', '        return (rewardAmount, rewardTransferAmount, rewardFee, actualTransferAmount, actualFee);\n', '    }\n', '\n', '    function _getActualValues(uint256 _actualAmount) private view returns (uint256, uint256) {\n', '        uint256 actualFee = _getFee(_actualAmount);\n', '        uint256 actualHolderFee = _getHolderFee(actualFee);\n', '        uint256 actualTransferAmount = _actualAmount.sub(actualFee);\n', '        return (actualTransferAmount, actualHolderFee);\n', '    }\n', '\n', '    function _getRewardValues(\n', '        uint256 _actualAmount,\n', '        uint256 _actualHolderFee,\n', '        uint256 _rewardsRate\n', '    )\n', '        private\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        uint256 actualFee = _getFee(_actualAmount).mul(_rewardsRate);\n', '        uint256 rewardAmount = _actualAmount.mul(_rewardsRate);\n', '        uint256 rewardTransferAmount = rewardAmount.sub(actualFee);\n', '        uint256 rewardFee = _actualHolderFee.mul(_rewardsRate);\n', '        return (rewardAmount, rewardTransferAmount, rewardFee);\n', '    }\n', '\n', '    function _getRewardsRate() private view returns (uint256) {\n', '        (uint256 rewardsSupply, uint256 actualSupply) = _getCurrentSupply();\n', '        return rewardsSupply.div(actualSupply);\n', '    }\n', '\n', '    function _getCurrentSupply() private view returns (uint256, uint256) {\n', '        uint256 rewardsSupply = rewardsTotal;\n', '        uint256 actualSupply = ACTUAL_TOTAL;\n', '\n', '        for (uint256 i = 0; i < rewardExcluded.length; i++) {\n', '            if (rewards[rewardExcluded[i]] > rewardsSupply || actual[rewardExcluded[i]] > actualSupply) {\n', '                return (rewardsTotal, ACTUAL_TOTAL);\n', '            }\n', '\n', '            rewardsSupply = rewardsSupply.sub(rewards[rewardExcluded[i]]);\n', '            actualSupply = actualSupply.sub(actual[rewardExcluded[i]]);\n', '        }\n', '\n', '        if (rewardsSupply < rewardsTotal.div(ACTUAL_TOTAL)) {\n', '            return (rewardsTotal, ACTUAL_TOTAL);\n', '        }\n', '\n', '        return (rewardsSupply, actualSupply);\n', '    }\n', '\n', '    function _getFee(uint256 _amount) private view returns (uint256) {\n', '        return _amount.mul(taxPercentage).div(100);\n', '    }\n', '\n', '    function _getHolderFee(uint256 _tax) private view returns (uint256) {\n', '        return _tax.mul(holderTaxAlloc).div(totalTaxAlloc);\n', '    }\n', '\n', '    function _getMarketingFee(uint256 _tax) private view returns (uint256) {\n', '        return _tax.mul(marketingTaxAlloc).div(totalTaxAlloc);\n', '    }\n', '\n', '    function _getLpFee(uint256 _tax) private view returns (uint256) {\n', '        return _tax.mul(lpTaxAlloc).div(totalTaxAlloc);\n', '    }\n', '\n', '\n', '    function setTaxPercentage(uint256 _taxPercentage) external onlyOwner {\n', '        require(_taxPercentage >= 1 && _taxPercentage <= 10, "Value is outside of range 1-10");\n', '        taxPercentage = _taxPercentage;\n', '    }\n', '\n', '    function setTaxAllocations(\n', '        uint256 _holderTaxAlloc,\n', '        uint256 _marketingTaxAlloc,\n', '        uint256 _lpTaxAlloc\n', '        \n', '    ) external onlyOwner {\n', '        totalTaxAlloc = _holderTaxAlloc.add(_marketingTaxAlloc).add(_lpTaxAlloc);\n', '\n', '        require(_holderTaxAlloc >= 5 && _holderTaxAlloc <= 10, "_holderTaxAlloc is outside of range 5-10");\n', '        require(_lpTaxAlloc >= 5 && _lpTaxAlloc <= 10, "_lpTaxAlloc is outside of range 5-10");\n', '       \n', '\n', '        holderTaxAlloc = _holderTaxAlloc;\n', '        marketingTaxAlloc = _marketingTaxAlloc;\n', '        lpTaxAlloc = _lpTaxAlloc;\n', '        \n', '    }\n', '\n', '    function setMarketingAddress(address _marketingAddress) external onlyOwner {\n', '        marketingAddress = _marketingAddress;\n', '    }\n', '\n', '    function setLpStakingAddress(address _lpStakingAddress) external onlyOwner {\n', '        lpStakingAddress = _lpStakingAddress;\n', '    }\n', '\n', '    \n', '}']