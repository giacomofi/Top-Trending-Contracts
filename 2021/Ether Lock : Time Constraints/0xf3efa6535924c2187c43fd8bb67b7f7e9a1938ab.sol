['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-24\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.12;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '  event OwnershipRenounced(address indexed previousOwner);\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to relinquish control of the contract.\n', '   */\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipRenounced(owner);\n', '    owner = address(0);\n', '  }\n', '}\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', '/*\n', '* @dev Get the current price of ETH/USD in a buyTokens function of a deployed solidity smart contract\n', '*/\n', 'interface AggregatorInterface {\n', '  function latestAnswer() external view returns (int256);\n', '  function latestTimestamp() external view returns (uint256);\n', '  function latestRound() external view returns (uint256);\n', '  function getAnswer(uint256 roundId) external view returns (int256);\n', '  function getTimestamp(uint256 roundId) external view returns (uint256);\n', '\n', '  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n', '  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n', '}\n', '\n', '\n', '/*\n', '* @title  1CC Global Financial System, build in Ethereum Network\n', '* @dev    A financial system built on smart contract technology. Open to all, transparent to all.\n', '*         The worlds first decentralized, community support fund\n', '*/\n', 'contract OneCoinGlobal is Ownable {\n', '    \n', '    IERC20 public investToken;\n', '    AggregatorInterface internal ethPriceFeed;\n', '\n', '    using SafeMath for uint256;\n', '\n', '    struct PlayerDeposit {\n', '        uint256 id;\n', '        uint256 amount;\n', '        uint256 total_withdraw;\n', '        uint256 time;\n', '        uint256 period;\n', '        uint256 expire;\n', '        uint8 status;\n', '        uint8 is_crowd;\n', '    }\n', '\n', '    struct Player {\n', '        address referral;\n', '        uint8 is_crowd;\n', '        uint256 level_id;\n', '        uint256 dividends;\n', '        uint256 eth_dividends;\n', '        uint256 referral_bonus;\n', '        uint256 match_bonus;\n', '        uint256 holder_full_bonus;\n', '        uint256 holder_single_bonus;\n', '        uint256 total_invested;\n', '        uint256 total_redeem;\n', '        uint256 total_withdrawn;\n', '        uint256 last_payout;\n', '        PlayerDeposit[] deposits;\n', '        address[] referrals;\n', '    }\n', '    \n', '    struct PlayerTotal {\n', '        uint256 total_match_invested;\n', '        uint256 total_dividends;\n', '        uint256 total_referral_bonus;\n', '        uint256 total_match_bonus;\n', '        uint256 total_holder_full_bonus;\n', '        uint256 total_holder_single_bonus;\n', '        uint256 total_eth_dividends;\n', '    }\n', '    \n', '    /* invest contract address and decimal (Mainnet network) */\n', '    address public invest_token_address = 0x94E042C6fD31bb391FC27c0091785728D9bCD149;\n', '    \n', '    /* chainlink ETH/USD proxy address (Mainnet network) */\n', '    address public ethusd_proxy_address = 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;\n', '    \n', '    uint256 public invest_token_decimal = 18;\n', '    uint256 public invest_eth_decimal = 8;\n', '    \n', '    uint256 public total_investors;\n', '    uint256 public total_invested;\n', '    uint256 public total_withdrawn;\n', '    uint256 public total_redeem;\n', '    uint256 public total_referral_bonus;\n', '    uint256 public total_match_bonus;\n', '    uint256 public total_dividends;\n', '    uint256 public total_eth_dividends;\n', '    uint256 public total_holder_full_bonus;\n', '    uint256 public total_holder_single_bonus;\n', '    uint256 public total_platform_bonus;\n', '    \n', '    /* Current corwded shareholder number */\n', '    uint256 public total_crowded_num; \n', '    \n', '    /* Total shareholder join limit number */\n', '    uint256 constant public SHAREHOLDER_LIMIT_NUM = 30;\n', '    \n', '    /* Shareholder bonus rate */\n', '    uint256 constant public shareholder_full_bonus_rate = 5;\n', '    uint256 constant public shareholder_single_bonus_rate = 3;\n', '\n', '    /* Referral bonuses data  define*/\n', '    uint8[] public referral_bonuses = [10,8,6,4,2,1,1,1,1,1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];\n', '    \n', '    /* Invest period and profit parameter definition */\n', '    uint256[] public invest_period_months =      [1,   2,   3,    6,    12,   18];     //period months\n', "    uint256[] public invest_period_month_rates = [800, 900, 1000, 1100, 1200, 1200];   //Ten thousand of month' rate\n", '    \n', '    /* yield reduce project section config, item1: total yield, item2: reduce rate */\n', '    uint256[] public yield_reduce_section1 = [2000000, 30];\n', '    uint256[] public yield_reduce_section2 = [5000000, 30];\n', '    uint256[] public yield_reduce_section3 = [9000000, 30];\n', '    \n', '    /* Team level data definition */\n', '    uint256[] public team_level_ids =     [1,2,3,4,5,6];\n', '    uint256[] public team_level_amounts = [10000,30000,50000,100000,200000,500000];\n', '    uint256[] public team_level_bonuses = [2,4,6,8,10,11];\n', '\n', '    /* invest coin usd price */ \n', '    uint256 public invest_coin_usd_price = 1;\n', '    \n', '    /* invest reward eth rate â€° */\n', '    uint256 public invest_reward_eth_month_rate = 25;\n', '    \n', '    /* ETH min withdraw amount: 0.1 ETH */\n', '    uint256 public eth_min_withdraw_num = 1 * (10 ** 17);\n', '    \n', '    /* user invest min amount */\n', '    uint256 constant public INVEST_MIN_AMOUNT = 100;\n', '    /* user invest max amount */\n', '    uint256 constant public INVEST_MAX_AMOUNT = 10000;\n', '    /* user crowd limit amount */\n', '    uint256 constant public CROWD_LIMIT_AMOUNT = 15000;\n', '    /* user crowd period(month) */\n', '    uint256 constant public crowd_period_month = 18;\n', '\n', '    /* Platform bonus address */\n', '    address public platform_bonus_address = 0xb42a4bed3C53a7aC9551670dF0AF36956c7b87F1;\n', '    /* Platform bonus rate percent(%) */\n', '    uint256 constant public platform_bonus_rate = 5;\n', '    \n', '    /* Mapping data list define */\n', '    mapping(address => Player) public players;\n', '    mapping(address => PlayerTotal) public playerTotals;\n', '    mapping(uint256 => address) public addrmap;\n', '    address[] public shareholders;\n', '    \n', '    event Deposit(address indexed addr, uint256 amount, uint256 month);\n', '    event Withdraw(address indexed addr, uint256 amount);\n', '    event ReferralPayout(address indexed addr, uint256 amount, uint8 level);\n', '    event Crowd(address indexed addr, uint256 amount);\n', '    event DepositRedeem(uint256 invest_id);\n', '\n', '    constructor() public {\n', '        \n', '        /* Create invest token instace  */\n', '        investToken = IERC20(invest_token_address);\n', '        \n', '        /* Create eth price feed in chainlink */\n', '        ethPriceFeed = AggregatorInterface(ethusd_proxy_address);\n', '        \n', '    }\n', '    \n', '    /* Function to receive Ether. msg.data must be empty */\n', '    receive() external payable {}\n', '\n', '    /* Fallback function is called when msg.data is not empty */ \n', '    fallback() external payable {}\n', '\n', '    function getBalance() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    /*\n', '    * @dev user do deposit action,grant the referrs bonus,grant the shareholder bonus,grant the match bonus\n', '    */\n', '    function deposit(address _referral, uint256 _amount, uint256 _month) \n', '        external \n', '        payable \n', '    {\n', '\n', '        require(_amount >= INVEST_MIN_AMOUNT, "Minimal deposit: 100 1CC");\n', '        require(_amount <= INVEST_MAX_AMOUNT, "Maxinum deposit: 10000 1CC");\n', '        //require(_amount % 100 == 0, "Invest amount must be multiple of 100");\n', '        \n', '        Player storage player = players[msg.sender];\n', '        require(player.deposits.length < 2000, "Max 2000 deposits per address");\n', '        \n', '        /* format token amount  */\n', '        uint256 token_decimals = 10 ** invest_token_decimal;\n', '        uint256 token_amount = _amount * token_decimals;\n', '        \n', '        /* Transfer user address token to contract address*/\n', '        require(investToken.transferFrom(msg.sender, address(this), token_amount), "transferFrom failed");\n', '\n', '        _setReferral(msg.sender, _referral);\n', '        \n', '        /* update total investor count */\n', '        if(player.deposits.length == 0){\n', '            total_investors += 1;\n', '            addrmap[total_investors] = msg.sender;\n', '        }\n', '        \n', '        /* get the period total time (total secones) */\n', '        uint256 period_time = _month * 30 * 86400;\n', '        \n', '        uint256 _id = player.deposits.length + 1;\n', '        player.deposits.push(PlayerDeposit({\n', '            id: _id,\n', '            amount: _amount,\n', '            total_withdraw: 0,\n', '            time: uint256(block.timestamp),\n', '            period: _month,\n', '            expire:uint256(block.timestamp).add(period_time),\n', '            status: 0,\n', '            is_crowd: 0\n', '        }));\n', '\n', '        player.total_invested += _amount;\n', '        total_invested += _amount;\n', '\n', '        /* update user referral and match invested amount*/\n', '        _updateReferralMatchInvestedAmount(msg.sender, _amount, 1);\n', '\n', '        emit Deposit(msg.sender, _amount, _month);\n', '    }\n', '    \n', '    \n', '    /*\n', '    * @dev user do crowd action, to join shareholder\n', '    */\n', '    function crowd(address _referral, uint256 _amount) \n', '        payable\n', '        external \n', '    {\n', '\n', '        require(_amount == CROWD_LIMIT_AMOUNT, "Crowd limit: 15000 1CC");\n', '        require(total_crowded_num <= SHAREHOLDER_LIMIT_NUM, "Maximum shareholders: 30");\n', '        \n', '        Player storage player = players[msg.sender];\n', '        require(player.is_crowd == 0, "Already a shareholder");\n', '        \n', '        /* format token amount  */\n', '        uint256 token_amount = _getTokenAmount(_amount,invest_token_decimal);\n', '        \n', '        /* Transfer user address token to contract address*/\n', '        require(investToken.transferFrom(msg.sender, address(this), token_amount), "transferFrom failed");\n', '\n', '        _setReferral(msg.sender, _referral);\n', '        \n', '        /* get the period total time (total secones) */\n', '        uint256 _month = crowd_period_month;\n', '        uint256 period_time = _month.mul(30).mul(86400);\n', '        \n', '        /* update total investor count */\n', '        if(player.deposits.length == 0){\n', '            total_investors += 1;\n', '            addrmap[total_investors] = msg.sender;\n', '        }\n', '        \n', '        uint256 _id = player.deposits.length + 1;\n', '        player.deposits.push(PlayerDeposit({\n', '            id: _id,\n', '            amount: _amount,\n', '            total_withdraw: 0,\n', '            time: uint256(block.timestamp),\n', '            period: _month,\n', '            expire: uint256(block.timestamp).add(period_time),\n', '            status: 0,\n', '            is_crowd: 1\n', '        }));\n', '\n', '        /* set the player of shareholders roles */\n', '        player.is_crowd = 1;\n', '        total_crowded_num += 1;\n', '        \n', '        /* push user to shareholder list*/\n', '        shareholders.push(msg.sender);\n', '\n', '        player.total_invested += _amount;\n', '        total_invested += _amount;\n', '\n', '        /* update user referral and match invested amount*/\n', '        _updateReferralMatchInvestedAmount(msg.sender, _amount, 1);\n', '\n', '        emit Crowd(msg.sender, _amount);\n', '    }\n', '    \n', '    /*\n', '    * @dev user do withdraw action, tranfer the total profit to user account, grant rereferral bonus, grant match bonus, grant shareholder bonus\n', '    */\n', '    function withdraw() \n', '        payable \n', '        external \n', '    {\n', '        \n', '        /* update user dividend data */\n', '        _payout(msg.sender);\n', '        \n', '        Player storage player = players[msg.sender];\n', '\n', '        uint256 _amount = player.dividends + player.referral_bonus + player.match_bonus + player.holder_full_bonus + player.holder_single_bonus;\n', '        uint256 _eth_amount = player.eth_dividends;\n', '        \n', '        require(_amount > 0, "Insufficient balance");\n', '        \n', '        /* format deposit token amount  */\n', '        uint256 token_amount = _amount;\n', '        \n', '        /* process token transfer action */\n', '        require(investToken.approve(address(this), token_amount), "approve failed");\n', '        require(investToken.transferFrom(address(this), msg.sender, token_amount), "transferFrom failed");\n', '        \n', '        /* eth dividends must greater than min withdraw num */\n', '        if(_eth_amount >= eth_min_withdraw_num && address(this).balance >= _eth_amount){\n', '            msg.sender.transfer(_eth_amount);\n', '            playerTotals[msg.sender].total_eth_dividends += player.eth_dividends;\n', '            total_eth_dividends += player.eth_dividends;\n', '            player.eth_dividends = 0;\n', '        }\n', '\n', '        /* Grant referral bonus */\n', '        _referralPayout(msg.sender, token_amount);\n', '        \n', '        /* Grant shareholder full node bonus */\n', '        _shareHoldersFullNodePayout(token_amount);\n', '        \n', '        /* Grant shareholder single node bonus */\n', '        _shareHoldersSingleNodePayout(msg.sender, token_amount);\n', '        \n', '        /* Grant team match bonus*/\n', '        _matchPayout(msg.sender, token_amount);\n', '\n', '        /* Update user total payout data */\n', '        _updatePlayerTotalPayout(msg.sender, token_amount);\n', '        \n', '        emit Withdraw(msg.sender, token_amount);\n', '    }\n', '    \n', '    \n', '    /*\n', "    * @dev user do deposit redeem action,transfer the expire deposit's amount to user account\n", '    */\n', '    function depositRedeem(uint256 _invest_id) \n', '        payable \n', '        external \n', '    {\n', '        Player storage player = players[msg.sender];\n', '        \n', '        require(player.deposits.length >= _invest_id && _invest_id > 0, "Valid deposit id");\n', '        uint256 _index = _invest_id - 1;\n', '        require(player.deposits[_index].expire < block.timestamp, "Invest not expired");\n', '        require(player.deposits[_index].status == 0, "Invest is redeemed");\n', '        \n', '        /* formt deposit token amount */\n', '        uint256 _amount = player.deposits[_index].amount;\n', '        uint256 token_amount = _getTokenAmount(_amount,invest_token_decimal);\n', '        \n', '        /* process token transfer action*/\n', '        //require(investToken.approve(address(this), 0), "approve failed");\n', '        require(investToken.approve(address(this), token_amount), "approve failed");\n', '        require(investToken.transferFrom(address(this), msg.sender, token_amount), "transferFrom failed");\n', '        \n', '        /* update deposit status in redeem */\n', '        player.deposits[_index].status = 1;\n', '\n', '        /* user quit crowd, cancel the shareholders role */\n', '        if(player.deposits[_index].is_crowd == 1){\n', '            player.is_crowd = 0;\n', '            total_crowded_num -= 1;\n', '            \n', '            /* remove user to shareholder list*/\n', '            _removeShareholders(msg.sender);\n', '        }\n', '\n', '        /* update user token balance*/\n', '        player.total_invested -= _amount;\n', '        \n', '        /* update total invested/redeem amount */\n', '        total_invested -= _amount;\n', '        total_redeem += _amount;\n', '        \n', '        /* update user referral and match invested amount*/\n', '        _updateReferralMatchInvestedAmount(msg.sender, _amount, -1);\n', '\n', '        emit DepositRedeem(_invest_id);\n', '    }\n', '     \n', '    /*\n', '    * @dev Update Referral Match invest amount, total investor number, map investor address index\n', '    */\n', '    function _updateReferralMatchInvestedAmount(address _addr,uint256 _amount,int8 op) \n', '        private\n', '    {\n', '        if(op > 0){\n', '            playerTotals[_addr].total_match_invested += _amount;\n', '            \n', '            address ref = players[_addr].referral;\n', '            while(true){\n', '                if(ref == address(0)) break;\n', '                \n', '                playerTotals[ref].total_match_invested += _amount;\n', '                ref = players[ref].referral;\n', '            }\n', '        }else{\n', '            playerTotals[_addr].total_match_invested -= _amount;\n', '            \n', '            address ref = players[_addr].referral;\n', '            while(true){\n', '                if(ref == address(0)) break;\n', '                \n', '                playerTotals[ref].total_match_invested -= _amount;\n', '                ref = players[ref].referral;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /*\n', '    * @dev Update user total payout data\n', '    */\n', '    function _updatePlayerTotalPayout(address _addr,uint256 token_amount) \n', '        private\n', '    {\n', '        \n', '        Player storage player = players[_addr];\n', '        PlayerTotal storage playerTotal = playerTotals[_addr];\n', '        \n', '        /* update user Withdraw total amount*/\n', '        player.total_withdrawn += token_amount;\n', '        \n', '        playerTotal.total_dividends += player.dividends;\n', '        playerTotal.total_referral_bonus += player.referral_bonus;\n', '        playerTotal.total_match_bonus += player.match_bonus;\n', '        playerTotal.total_holder_full_bonus += player.holder_full_bonus;\n', '        playerTotal.total_holder_single_bonus += player.holder_single_bonus;\n', '        \n', '        /* update platform total data*/\n', '        total_withdrawn += token_amount;\n', '        total_dividends += player.dividends;\n', '        total_referral_bonus += player.referral_bonus;\n', '        total_match_bonus += player.match_bonus;\n', '        total_holder_full_bonus += player.holder_full_bonus;\n', '        total_holder_single_bonus += player.holder_single_bonus; \n', '        uint256 _platform_bonus = (token_amount * platform_bonus_rate / 100);\n', '        total_platform_bonus += _platform_bonus;\n', '        \n', '        /* update platform address bonus*/\n', '        players[platform_bonus_address].match_bonus += _platform_bonus;\n', '        \n', '        /* reset user bonus data */\n', '        player.dividends = 0;\n', '        player.referral_bonus = 0;\n', '        player.match_bonus = 0;\n', '        player.holder_full_bonus = 0;\n', '        player.holder_single_bonus = 0;\n', '    }\n', '    \n', '    \n', '    /*\n', '    * @dev update user referral data\n', '    */\n', '    function _setReferral(address _addr, address _referral) \n', '        private \n', '    {\n', '        /* if user referral is not set */\n', '        if(players[_addr].referral == address(0) && _referral != _addr) {\n', '            \n', '            players[_addr].referral = _referral;\n', '\n', '            /* update user referral address list*/\n', '            players[_referral].referrals.push(_addr);\n', '        }\n', '    }\n', '    \n', '    \n', '    /*\n', '    * @dev Grant user referral bonus in user withdraw\n', '    */\n', '    function _referralPayout(address _addr, uint256 _amount) \n', '        private\n', '    {\n', '        address ref = players[_addr].referral;\n', '        uint256 _day_payout = _payoutOfDay(_addr);\n', '        if(_day_payout == 0) return;\n', '        \n', '        for(uint8 i = 0; i < referral_bonuses.length; i++) {\n', '        \n', '            if(ref == address(0)) break;\n', '\n', '            uint256 _ref_day_payout = _payoutOfDay(ref);\n', '            uint256 _token_amount = _amount;\n', '            \n', '            /* user bonus double burn */\n', '            if(_ref_day_payout * 2 < _day_payout){\n', '                _token_amount = _token_amount * (_ref_day_payout * 2) / _day_payout;\n', '            }\n', '            \n', '            uint256 bonus = _token_amount * referral_bonuses[i] / 100;\n', '            players[ref].referral_bonus += bonus;\n', '            \n', '            //emit ReferralPayout(ref, bonus, (i+1));\n', '            \n', '            ref = players[ref].referral;\n', '        }\n', '    }\n', '    \n', '    /*\n', '    * @dev  Grant shareholder full node bonus in user withdraw\n', '    */\n', '    function _shareHoldersFullNodePayout(uint256 _amount)\n', '        private\n', '    {\n', '        if(total_crowded_num == 0) return;\n', '        \n', '        uint256 bonus = _amount * shareholder_full_bonus_rate / 100 / total_crowded_num;\n', '        for(uint8 i = 0; i < shareholders.length; i++) {\n', '            address _addr = shareholders[i];\n', '            players[_addr].holder_full_bonus += bonus;\n', '        }\n', '    }\n', '    \n', '    \n', '    /*\n', '    * @dev  Grant shareholder single node bonus in user withdraw\n', '    */\n', '    function _shareHoldersSingleNodePayout(address _addr,uint256 _amount)\n', '        private\n', '    {\n', '        uint256 bonus = _amount * shareholder_single_bonus_rate / 100;\n', '        address ref = players[_addr].referral;\n', '        \n', '        while(true){\n', '            \n', '            if(ref == address(0)) break;\n', '            \n', '            if(players[ref].is_crowd == 1){\n', '                players[ref].holder_single_bonus += bonus;\n', '                break;\n', '            }\n', '            ref = players[ref].referral;\n', '        }\n', '    }\n', '\n', '    /*\n', '    * @dev Grant Match bonus in user withdraw\n', '    */\n', '    function _matchPayout(address _addr,uint256 _amount) \n', '        private\n', '    {\n', '        /* update player team level */\n', '        _upgradePlayerTeamLevel(_addr);\n', '        uint256 last_level_id = players[_addr].level_id;\n', '        \n', '        /* player is max team level, quit */\n', '        if(last_level_id == team_level_ids[team_level_ids.length-1]) return;\n', '        \n', '        address ref = players[_addr].referral;\n', '        \n', '        while(true){\n', '            \n', '            if(ref == address(0)) break;\n', '            \n', '            /* upgrade player team level id*/\n', '            _upgradePlayerTeamLevel(ref);\n', '            \n', '            if(players[ref].level_id > last_level_id){\n', '                \n', '                uint256 last_level_bonus = 0;\n', '                if(last_level_id > 0){\n', '                    last_level_bonus = team_level_bonuses[last_level_id-1];\n', '                }\n', '                uint256 cur_level_bonus = team_level_bonuses[players[ref].level_id-1];\n', '                uint256 bonus_amount = _amount * (cur_level_bonus - last_level_bonus) / 100;\n', '                players[ref].match_bonus += bonus_amount;\n', '                \n', '                last_level_id = players[ref].level_id;\n', '                \n', '                /* referral is max team level, quit */\n', '                if(last_level_id == team_level_ids[team_level_ids.length-1]) \n', '                    break;\n', '            }\n', '            ref = players[ref].referral;\n', '        }\n', '    }\n', '    \n', '    /*\n', '    * @dev upgrade player team level id\n', '    */    \n', '    function _upgradePlayerTeamLevel(address _addr) \n', '        private\n', '    {\n', '        /* get community total invested*/\n', '        uint256 community_total_invested = _getCommunityTotalInvested(_addr);\n', '        \n', '        uint256 level_id = 0;\n', '        for(uint8 i=0; i < team_level_ids.length; i++){\n', '            if(community_total_invested >= team_level_amounts[i]){\n', '                level_id = team_level_ids[i];\n', '            }\n', '        }\n', '        players[_addr].level_id = level_id;\n', '    }\n', '    \n', '    /*\n', '    * @dev Get community total invested\n', '    */\n', '    function _getCommunityTotalInvested(address _addr) \n', '        view\n', '        private\n', '        returns(uint256 value)\n', '    {\n', '        address[] memory referrals = players[_addr].referrals;\n', '        \n', '        uint256 nodes_max_invested = 0;\n', '        uint256 nodes_total_invested = 0;\n', '        for(uint256 i=0;i<referrals.length;i++){\n', '            address ref = referrals[i];\n', '            nodes_total_invested += playerTotals[ref].total_match_invested;\n', '            if(playerTotals[ref].total_match_invested > nodes_max_invested){\n', '                nodes_max_invested = playerTotals[ref].total_match_invested;\n', '            }\n', '        }\n', '        return (nodes_total_invested - nodes_max_invested);\n', '    }\n', '\n', '    /*\n', '    * @dev user withdraw, user devidends data update\n', '    */\n', '    function _payout(address _addr) \n', '        private \n', '    {\n', '        uint256 payout = this.payoutOf(_addr);\n', '        uint256 payout_eth = this.payoutEthOf(_addr);\n', '        if(payout > 0) {\n', '            \n', '            _updateTotalPayout(_addr);\n', '            \n', '            players[_addr].last_payout = uint256(block.timestamp);\n', '            players[_addr].dividends += payout;\n', '            players[_addr].eth_dividends += payout_eth;\n', '        }\n', '    }\n', '    \n', '    /*\n', '    * @dev format token amount with token decimal\n', '    */\n', '    function _getTokenAmount(uint256 _amount,uint256 _token_decimal) \n', '        pure\n', '        private\n', '        returns(uint256 token_amount)\n', '    {\n', '        uint256 token_decimals = 10 ** _token_decimal;\n', '        token_amount = _amount * token_decimals;   \n', '        return token_amount;\n', '    }\n', '    \n', '\n', '    /*\n', '    * @dev update user total withdraw data\n', '    */\n', '    function _updateTotalPayout(address _addr)\n', '        private\n', '    {\n', '        Player storage player = players[_addr];\n', '\n', '        for(uint256 i = 0; i < player.deposits.length; i++) {\n', '            \n', '            PlayerDeposit storage dep = player.deposits[i];\n', '\n', '            uint256 from = player.last_payout > dep.time ? player.last_payout : dep.time;\n', '            uint256 to = block.timestamp > dep.expire ? dep.expire : uint256(block.timestamp);\n', '\n', '            if(from < to && dep.status == 0) {\n', '                uint256 _day_payout = _getInvestDayPayoutOf(dep.amount,dep.period);\n', '                player.deposits[i].total_withdraw += _day_payout * (to - from) / 86400;\n', '            }\n', '        }\n', '    }\n', '    \n', '    /*\n', '    * @dev get the invest period rate, if total yield reached reduce limit, invest day rate will be reduce\n', '    */\n', '    function _getInvestDayPayoutOf(uint256 _amount, uint256 _month) \n', '        view \n', '        private \n', '        returns(uint256 value)\n', '    {\n', '        /* get invest period base rate*/\n', '        uint256 period_month_rate = invest_period_month_rates[0];\n', '        \n', '        for(uint256 i = 0; i < invest_period_months.length; i++) {\n', '            if(invest_period_months[i] == _month){\n', '                period_month_rate = invest_period_month_rates[i];\n', '                break;\n', '            }\n', '        }\n', '        \n', '        /* format amount with token decimal */\n', '        uint256 token_amount = _getTokenAmount(_amount, invest_token_decimal);\n', '        value = token_amount * period_month_rate / 30 / 10000;\n', '        \n', '        if(value > 0){\n', '            \n', '            /* total yield reached 2,000,000,start first reduce */\n', '            if(total_withdrawn >= _getTokenAmount(yield_reduce_section1[0], invest_token_decimal)){\n', '                value = value * (100 - yield_reduce_section1[1]) / 100;\n', '            }\n', '            /* total yield reached 5,000,000,start second reduce */\n', '            if(total_withdrawn >= _getTokenAmount(yield_reduce_section2[0], invest_token_decimal)){\n', '                value = value * (100 - yield_reduce_section2[1]) / 100;\n', '            }\n', '            /* total yield reached 9,000,000,start third reduce */\n', '            if(total_withdrawn >= _getTokenAmount(yield_reduce_section3[0], invest_token_decimal)){\n', '                value = value * (100 - yield_reduce_section3[1]) / 100;\n', '            }\n', '        }\n', '        return value;\n', '    }\n', '    \n', '    /*\n', '    * @dev get user deposit day total pending profit\n', '    * @return user pending payout amount\n', '    */\n', '    function payoutOf(address _addr) \n', '        view \n', '        external \n', '        returns(uint256 value)\n', '    {\n', '        Player storage player = players[_addr];\n', '\n', '        for(uint256 i = 0; i < player.deposits.length; i++) {\n', '            PlayerDeposit storage dep = player.deposits[i];\n', '            \n', '            uint256 from = player.last_payout > dep.time ? player.last_payout : dep.time;\n', '            uint256 to = block.timestamp > dep.expire ? dep.expire : uint256(block.timestamp);\n', '            \n', '            if(from < to && dep.status == 0) {\n', '                uint256 _day_payout = _getInvestDayPayoutOf(dep.amount,dep.period);\n', '                value += _day_payout * (to - from) / 86400;\n', '            }\n', '        }\n', '        return value;\n', '    }\n', '    \n', '    /*\n', '    * @dev get user deposit day total pending eth profit\n', '    * @return user pending payout eth amount\n', '    */\n', '    function payoutEthOf(address _addr) \n', '        view \n', '        external \n', '        returns(uint256 value)\n', '    {\n', '        Player storage player = players[_addr];\n', '        uint256 eth_usd_price = getEthLatestPrice();\n', '        \n', '        for(uint256 i = 0; i < player.deposits.length; i++) {\n', '            PlayerDeposit storage dep = player.deposits[i];\n', '            \n', '            uint256 from = player.last_payout > dep.time ? player.last_payout : dep.time;\n', '            uint256 to = block.timestamp > dep.expire ? dep.expire : uint256(block.timestamp);\n', '            \n', '            if(from < to && dep.status == 0) {\n', '                uint256 token_amount = _getTokenAmount(dep.amount, invest_token_decimal);\n', '                uint256 _day_eth_payout = (token_amount * invest_reward_eth_month_rate / 1000 / 30) * (invest_coin_usd_price * (10**8)) / eth_usd_price ;\n', '                value += _day_eth_payout * (to - from) / 86400;\n', '            }\n', '        }\n', '        return value;\n', '    }\n', '\n', '    /*\n', '    * @dev get user deposit day total pending profit\n', '    * @return user pending payout amount\n', '    */\n', '    function _payoutOfDay(address _addr) \n', '        view\n', '        private \n', '        returns(uint256 value)\n', '    {\n', '        Player storage player = players[_addr];\n', '\n', '        for(uint256 i = 0; i < player.deposits.length; i++) {\n', '            PlayerDeposit storage dep = player.deposits[i];\n', '            \n', '            //uint256 from = player.last_payout > dep.time ? player.last_payout : dep.time;\n', '            //uint256 to = block.timestamp > dep.expire ? dep.expire : uint256(block.timestamp);\n', '            \n', '            if(dep.status == 0) {\n', '                uint256 _day_payout = _getInvestDayPayoutOf(dep.amount, dep.period);\n', '                value += _day_payout;\n', '            }\n', '        }\n', '        return value;\n', '    }\n', '    \n', '  \n', '    /*\n', '    * @dev Remove shareholders of the special address\n', '    */\n', '    function _removeShareholders(address _addr) private {\n', '        for (uint index = 0; index < shareholders.length; index++) {\n', '            if(shareholders[index] == _addr){\n', '                for (uint i = index; i < shareholders.length-1; i++) {\n', '                    shareholders[i] = shareholders[i+1];\n', '                }\n', '                delete shareholders[shareholders.length-1];\n', '                break;\n', '            }\n', '        }\n', '    }\n', '    \n', '\n', '    /*\n', '    * @dev get contract data info \n', '    * @return total invested,total investor number,total withdraw,total referral bonus\n', '    */\n', '    function contractInfo() \n', '        view \n', '        external \n', '        returns(uint256 _total_invested, uint256 _total_investors, uint256 _total_withdrawn, uint256 _total_dividends, uint256 _total_referral_bonus, uint256 _total_platform_bonus, uint256 _total_crowded_num,uint256[] memory _invest_periods,uint256 _crowd_limit_amount,uint256 _crowd_period_month,uint256 _eth_min_withdraw_num,uint256 _total_holder_bonus,uint256 _total_eth_dividends,uint256 _total_match_bonus) \n', '    {\n', '        return (\n', '            total_invested, \n', '            total_investors, \n', '            total_withdrawn, \n', '            total_dividends, \n', '            total_referral_bonus, \n', '            total_platform_bonus, \n', '            total_crowded_num, \n', '            invest_period_months, \n', '            CROWD_LIMIT_AMOUNT, \n', '            crowd_period_month,\n', '            eth_min_withdraw_num,\n', '            total_holder_full_bonus + total_holder_single_bonus,\n', '            total_eth_dividends,\n', '            total_match_bonus\n', '        );\n', '    }\n', '    \n', '    /*\n', '    * @dev get user info\n', '    * @return pending withdraw amount,referral,rreferral num etc.\n', '    */\n', '    function userInfo(address _addr)\n', '        view \n', '        external \n', '        returns(address _referral, uint256 _referral_num, uint256 _is_crowd, uint256 _dividends, uint256 _eth_dividends, uint256 _referral_bonus, uint256 _match_bonus, uint256 _holder_single_bonus, uint256 _holder_full_bonus,uint256 _last_payout) \n', '    {\n', '        Player storage player = players[_addr];\n', '        return (\n', '            player.referral,\n', '            player.referrals.length,\n', '            player.is_crowd,\n', '            player.dividends,\n', '            player.eth_dividends,\n', '            player.referral_bonus,\n', '            player.match_bonus,\n', '            player.holder_single_bonus,\n', '            player.holder_full_bonus,\n', '            player.last_payout\n', '        );\n', '    }\n', '    \n', '    /*\n', '    * @dev get user info\n', '    * @return pending withdraw amount,referral bonus, total deposited, total withdrawn etc.\n', '    */\n', '    function userInfoTotals(address _addr) \n', '        view \n', '        external \n', '        returns(uint256 _total_invested, uint256 _total_withdrawn, uint256 _total_community_invested, uint256 _total_match_invested, uint256 _total_dividends, uint256 _total_referral_bonus, uint256 _total_match_bonus, uint256 _total_holder_full_bonus, uint256 _total_holder_single_bonus, uint256 _total_math_invested,uint256 _total_eth_dividends) \n', '    {\n', '        Player storage player = players[_addr];\n', '        PlayerTotal storage playerTotal = playerTotals[_addr];\n', '        \n', '        /* get community total invested*/\n', '        uint256 total_community_invested = _getCommunityTotalInvested(_addr);\n', '        \n', '        return (\n', '            player.total_invested,\n', '            player.total_withdrawn,\n', '            //player.total_redeem,\n', '            total_community_invested,\n', '            playerTotal.total_match_invested,\n', '            playerTotal.total_dividends,\n', '            playerTotal.total_referral_bonus,\n', '            playerTotal.total_match_bonus,\n', '            playerTotal.total_holder_full_bonus,\n', '            playerTotal.total_holder_single_bonus,\n', '            playerTotal.total_match_invested,\n', '            playerTotal.total_eth_dividends\n', '        );\n', '    }\n', '    \n', '    /*\n', '    * @dev get user investment list\n', '    */\n', '    function getInvestList(address _addr) \n', '        view \n', '        external \n', '        returns(uint256[] memory ids,uint256[] memory times, uint256[] memory amounts, uint256[] memory withdraws,uint256[] memory endTimes,uint256[] memory statuses) \n', '    {\n', '        Player storage player = players[_addr];\n', '        uint256[] memory _ids = new uint256[](player.deposits.length);\n', '        uint256[] memory _times = new uint256[](player.deposits.length);\n', '        uint256[] memory _endTimes = new uint256[](player.deposits.length);\n', '        uint256[] memory _amounts = new uint256[](player.deposits.length);\n', '        uint256[] memory _withdraws = new uint256[](player.deposits.length);\n', '        uint256[] memory _statuses = new uint256[](player.deposits.length);\n', '        for(uint256 i = 0; i < player.deposits.length; i++) {\n', '            PlayerDeposit storage dep = player.deposits[i];\n', '            _ids[i] = dep.id;\n', '            _amounts[i] = dep.amount;\n', '            _withdraws[i] = dep.total_withdraw;\n', '            _times[i] = dep.time;\n', '            _endTimes[i] = dep.expire;\n', '            _statuses[i] = dep.status;\n', '        }\n', '        return (\n', '            _ids,\n', '            _times,\n', '            _amounts,\n', '            _withdraws,\n', '            _endTimes,\n', '            _statuses\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * @dev get the eth/usd lastest price\n', '     * @return the eth/usd latest price, price decimal: 8\n', '     */\n', '    function getEthLatestPrice() \n', '        public \n', '        view \n', '        returns (uint256) \n', '    {\n', '        int256 price= ethPriceFeed.latestAnswer();\n', '        return uint256(price);\n', '    }\n', '    \n', '}']