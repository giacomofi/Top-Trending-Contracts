['# @version 0.2.12\n', '"""\n', '@title Root-Chain Gauge\n', '@author Curve Finance\n', '@license MIT\n', '@notice Calculates total allocated weekly CRV emission\n', '        mints and sends across a sidechain bridge\n', '"""\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', '\n', 'interface CRV20:\n', '    def start_epoch_time_write() -> uint256: nonpayable\n', '    def rate() -> uint256: view\n', '\n', 'interface Controller:\n', '    def period() -> int128: view\n', '    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\n', '    def checkpoint(): nonpayable\n', '    def checkpoint_gauge(addr: address): nonpayable\n', '\n', 'interface Minter:\n', '    def token() -> address: view\n', '    def controller() -> address: view\n', '    def minted(user: address, gauge: address) -> uint256: view\n', '    def mint(gauge: address): nonpayable\n', '\n', '\n', 'event PeriodEmission:\n', '    period_start: uint256\n', '    mint_amount: uint256\n', '\n', 'event CommitOwnership:\n', '    admin: address\n', '\n', 'event ApplyOwnership:\n', '    admin: address\n', '\n', '\n', 'WEEK: constant(uint256) = 604800\n', 'YEAR: constant(uint256) = 86400 * 365\n', 'RATE_DENOMINATOR: constant(uint256) = 10 ** 18\n', 'RATE_REDUCTION_COEFFICIENT: constant(uint256) = 1189207115002721024  # 2 ** (1/4) * 1e18\n', 'RATE_REDUCTION_TIME: constant(uint256) = YEAR\n', 'XDAI_BRIDGE: constant(address) = 0x88ad09518695c6c3712AC10a214bE5109a655671\n', '\n', '\n', 'minter: public(address)\n', 'crv_token: public(address)\n', 'controller: public(address)\n', 'start_epoch_time: public(uint256)\n', '\n', 'period: public(uint256)\n', 'emissions: public(uint256)\n', 'inflation_rate: public(uint256)\n', '\n', 'admin: public(address)\n', 'future_admin: public(address)  # Can and will be a smart contract\n', 'checkpoint_admin: public(address)\n', 'is_killed: public(bool)\n', '\n', '\n', '@external\n', 'def __init__(_minter: address, _admin: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _minter Minter contract address\n', '    @param _admin Admin who can kill the gauge\n', '    """\n', '\n', '    crv_token: address = Minter(_minter).token()\n', '\n', '    self.minter = _minter\n', '    self.admin = _admin\n', '    self.crv_token = crv_token\n', '    self.controller = Minter(_minter).controller()\n', '\n', '    # because we calculate the rate locally, this gauge cannot\n', '    # be used prior to the start of the first emission period\n', '    rate: uint256 = CRV20(crv_token).rate()\n', '    assert rate != 0\n', '    self.inflation_rate = rate\n', '\n', '    self.period = block.timestamp / WEEK - 1\n', '    self.start_epoch_time = CRV20(crv_token).start_epoch_time_write()\n', '\n', '    ERC20(crv_token).approve(XDAI_BRIDGE, MAX_UINT256)\n', '\n', '\n', '@external\n', 'def checkpoint() -> bool:\n', '    """\n', '    @notice Mint all allocated CRV emissions and transfer across the bridge\n', '    @dev Should be called once per week, after the new epoch period has begun\n', '    """\n', '    assert self.checkpoint_admin in [ZERO_ADDRESS, msg.sender]\n', '    last_period: uint256 = self.period\n', '    current_period: uint256 = block.timestamp / WEEK - 1\n', '\n', '    if last_period < current_period:\n', '        controller: address = self.controller\n', '        Controller(controller).checkpoint_gauge(self)\n', '\n', '        rate: uint256 = self.inflation_rate\n', '        new_emissions: uint256 = 0\n', '        last_period += 1\n', '        next_epoch_time: uint256 = self.start_epoch_time + RATE_REDUCTION_TIME\n', '        for i in range(last_period, last_period + 255):\n', '            if i > current_period:\n', '                break\n', '            period_time: uint256 = i * WEEK\n', '            period_emission: uint256 = 0\n', '            gauge_weight: uint256 = Controller(controller).gauge_relative_weight(self, i * WEEK)\n', '\n', '            if next_epoch_time >= period_time and next_epoch_time < period_time + WEEK:\n', '                # If the period crosses an epoch, we calculate a reduction in the rate\n', '                # using the same formula as used in `ERC20CRV`. We perform the calculation\n', '                # locally instead of calling to `ERC20CRV.rate()` because we are generating\n', '                # the emissions for the upcoming week, so there is a possibility the new\n', '                # rate has not yet been applied.\n', '                period_emission = gauge_weight * rate * (next_epoch_time - period_time) / 10**18\n', '                rate = rate * RATE_DENOMINATOR / RATE_REDUCTION_COEFFICIENT\n', '                period_emission += gauge_weight * rate * (period_time + WEEK - next_epoch_time) / 10**18\n', '\n', '                self.inflation_rate = rate\n', '                self.start_epoch_time = next_epoch_time\n', '                next_epoch_time += RATE_REDUCTION_TIME\n', '            else:\n', '                period_emission = gauge_weight * rate * WEEK / 10**18\n', '\n', '            log PeriodEmission(period_time, period_emission)\n', '            new_emissions += period_emission\n', '\n', '        self.period = current_period\n', '        self.emissions += new_emissions\n', '        if new_emissions > 0 and not self.is_killed:\n', '            Minter(self.minter).mint(self)\n', '            raw_call(\n', '                XDAI_BRIDGE,\n', '                concat(\n', '                    method_id("relayTokens(address,address,uint256)"),\n', '                    convert(self.crv_token, bytes32),\n', '                    convert(self, bytes32),\n', '                    convert(new_emissions, bytes32),\n', '                )\n', '            )\n', '\n', '    return True\n', '\n', '\n', '@view\n', '@external\n', 'def future_epoch_time() -> uint256:\n', '    return self.start_epoch_time + YEAR\n', '\n', '\n', '@view\n', '@external\n', 'def user_checkpoint(addr: address) -> bool:\n', '    return True\n', '\n', '\n', '@view\n', '@external\n', 'def integrate_fraction(addr: address) -> uint256:\n', '    assert addr == self, "Gauge can only mint for itself"\n', '    return self.emissions\n', '\n', '\n', '@external\n', 'def set_killed(_is_killed: bool):\n', '    """\n', '    @notice Set the killed status for this contract\n', '    @dev When killed, the gauge always yields a rate of 0 and so cannot mint CRV\n', '    @param _is_killed Killed status to set\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '\n', '    self.is_killed = _is_killed\n', '\n', '\n', '@external\n', 'def commit_transfer_ownership(addr: address):\n', '    """\n', '    @notice Transfer ownership of GaugeController to `addr`\n', '    @param addr Address to have ownership transferred to\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '\n', '    self.future_admin = addr\n', '    log CommitOwnership(addr)\n', '\n', '\n', '@external\n', 'def accept_transfer_ownership():\n', '    """\n', '    @notice Accept a pending ownership transfer\n', '    """\n', '    _admin: address = self.future_admin\n', '    assert msg.sender == _admin  # dev: future admin only\n', '\n', '    self.admin = _admin\n', '    log ApplyOwnership(_admin)\n', '\n', '\n', '@external\n', 'def set_checkpoint_admin(_admin: address):\n', '    """\n', '    @notice Set the checkpoint admin address\n', '    @dev Setting to ZERO_ADDRESS allows anyone to call `checkpoint`\n', '    @param _admin Address of the checkpoint admin\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '\n', '    self.checkpoint_admin = _admin']