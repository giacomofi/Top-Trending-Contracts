['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'pragma abicoder v2;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', '\n', '\n', 'interface OracleInterface{\n', '    function latestAnswer() external view returns (int256);\n', '}\n', '\n', 'interface tellorInterface{\n', '     function getLastNewValueById(uint _requestId) external view returns(uint,bool);\n', '}\n', '\n', 'interface uniswapInterface{\n', '     function getAmountsOut(uint amountIn, address[] memory path)\n', '        external view returns (uint[] memory amounts);\n', '}\n', 'interface Token{\n', '    function decimals() external view returns(uint256);\n', '}\n', 'contract OracleWrapperInverse is Ownable{\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    //Mainnet\n', '    address public tellerContractAddress=0x0Ba45A8b5d5575935B8158a88C631E9F9C95a2e5;\n', '    address public UniswapV2Router02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '    address public usdtContractAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '    \n', '    struct TellorInfo{\n', '        uint256 id;\n', '        uint256 tellorPSR;\n', '    }\n', '    uint256 tellorId=1;\n', '    mapping(string=>address) public typeOneMapping;  // chainlink\n', '    string[] typeOneArray;\n', '    mapping(string=> TellorInfo) public typeTwomapping; // tellor\n', '    string[] typeTwoArray;\n', '    mapping(string=> address) public typeThreemapping; // uniswap\n', '    string[] typeThreeArray;\n', '\n', '    function updateTellerContractAddress(address newAddress) public onlyOwner{\n', '        tellerContractAddress = newAddress;\n', '    }\n', '    \n', '    function addTypeOneMapping(string memory currencySymbol, address chainlinkAddress) external onlyOwner{\n', '        typeOneMapping[currencySymbol]=chainlinkAddress;\n', '        if(!checkAddressIfExists(typeOneArray,currencySymbol)){\n', '            typeOneArray.push(currencySymbol);\n', '        }\n', '    }\n', '    \n', '    function addTypeTwoMapping(string memory currencySymbol, uint256 tellorPSR) external onlyOwner{\n', '        TellorInfo memory tInfo= TellorInfo({\n', '            id:tellorId,\n', '            tellorPSR:tellorPSR\n', '        });\n', '        typeTwomapping[currencySymbol]=tInfo;\n', '        tellorId++;\n', '        if(!checkAddressIfExists(typeTwoArray,currencySymbol)){\n', '            typeTwoArray.push(currencySymbol);\n', '        }\n', '    }\n', '    \n', '    function addTypeThreeMapping(string memory currencySymbol, address tokenContractAddress) external onlyOwner{\n', '        typeThreemapping[currencySymbol]=tokenContractAddress;\n', '        if(!checkAddressIfExists(typeThreeArray,currencySymbol)){\n', '            typeThreeArray.push(currencySymbol);\n', '        }\n', '    }\n', '    function checkAddressIfExists(string[] memory arr, string memory currencySymbol) internal pure returns(bool){\n', '        for(uint256 i=0;i<arr.length;i++){\n', '            if((keccak256(abi.encodePacked(arr[i]))) == (keccak256(abi.encodePacked(currencySymbol)))){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    function getPrice(string memory currencySymbol,\n', '        uint256 oracleType) external view returns (uint256){\n', '        //oracletype 1 - chainlink and  for teller --2, uniswap---3\n', '        if(oracleType == 1){\n', '            require(typeOneMapping[currencySymbol]!=address(0), "please enter valid currency");\n', '            OracleInterface oObj = OracleInterface(typeOneMapping[currencySymbol]);\n', '            return uint256(oObj.latestAnswer());\n', '        }\n', '        else if(oracleType ==2){\n', '            require(typeTwomapping[currencySymbol].id!=0, "please enter valid currency");\n', '            tellorInterface tObj = tellorInterface(tellerContractAddress);\n', '            uint256 actualFiatPrice;\n', '            bool statusTellor;\n', '            (actualFiatPrice,statusTellor) = tObj.getLastNewValueById(typeTwomapping[currencySymbol].tellorPSR);\n', '            return uint256(actualFiatPrice);\n', '        }else{\n', '            require(typeThreemapping[currencySymbol]!=address(0), "please enter valid currency");\n', '            uniswapInterface uObj = uniswapInterface(UniswapV2Router02);\n', '            address[] memory path = new address[](2);\n', '            path[0] = typeThreemapping[currencySymbol];\n', '            path[1] = usdtContractAddress;\n', '            uint[] memory values=uObj.getAmountsOut(10**(Token(typeThreemapping[currencySymbol]).decimals()),path);\n', '            uint256 usdtDecimals=Token(usdtContractAddress).decimals();\n', '            if(usdtDecimals==8){\n', '                return uint256(values[1]);\n', '            }else{\n', '                return uint256(values[1].mul(10**(8-usdtDecimals)));\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getTypeOneArray() external view returns(string[] memory){\n', '        return typeOneArray;\n', '    }\n', '    \n', '    function getTypeTwoArray() external view returns(string[] memory){\n', '        return typeTwoArray;\n', '    }\n', '    function getTypeThreeArray() external view returns(string[] memory){\n', '        return typeThreeArray;\n', '    }\n', '    function updateUniswapV2Router02(address _UniswapV2Router02) external onlyOwner{\n', '        UniswapV2Router02=_UniswapV2Router02;\n', '    }\n', '    function updateUSDTContractAddress(address _usdtContractAddress) external onlyOwner{\n', '        usdtContractAddress=_usdtContractAddress;\n', '    }\n', '}']