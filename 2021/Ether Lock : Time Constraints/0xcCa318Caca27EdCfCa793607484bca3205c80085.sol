['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./Snapshot.sol";\n', 'import "./BasePool.sol";\n', '\n', 'contract PairFarmPool is BasePool, Snapshot, Ownable, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    /* 状态 0开放充提 1关闭充提  */\n', '    uint256 public status;\n', '\n', '    event Deposit(address indexed user, uint256 amount); // 抵押本金\n', '    event Withdaw(address indexed user, uint256 amount); // 提现本金\n', '    event GetReward(address indexed user, uint256 periodId, uint256 amount); // 根据周期ID提取奖励\n', '    event Deduction(address indexed user, IERC20 token, uint256 amount); // 强制退款时扣除手续费\n', '    event SetStatus(uint256 indexed status); // 设置状态\n', '    event WithdrawToken(IERC20 token, uint256 amount); // 管理员从合约提现代币\n', '\n', '    constructor(IERC20 _depositToken, IERC20 _rewardToken) {\n', '        depositToken = _depositToken;\n', '        rewardToken = _rewardToken;\n', '    }\n', '\n', '    /* 设置状态 */\n', '    function setStatus(uint256 _status, uint256 reward)\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        status = _status;\n', '        emit SetStatus(_status);\n', '\n', '        /* 开放存取且奖励大于0时结束当期 */\n', '        if (_status == 0 && reward > 0) {\n', '            _snapshot(reward);\n', '        }\n', '    }\n', '\n', '    /* 更新某期奖励 增加奖励补救预留补救接口 一般用不着 */\n', '    function setTotalReward(uint256 periodId, uint256 reward)\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        _setTotalReward(periodId, reward);\n', '    }\n', '\n', '    /* 管理员提现代币 */\n', '    function withdrawToken(IERC20 token, uint256 amount) public onlyOwner {\n', '        token.safeTransfer(msg.sender, amount);\n', '        emit WithdrawToken(token, amount);\n', '    }\n', '\n', '    // 强制提币\n', '    function forceWithdaw(\n', '        address user, // 用户账户\n', '        uint256 amount, // 总金额\n', '        uint256[] memory periodIds, // 期数ID\n', '        uint256 depositTokenDeduction, // 扣除的本金\n', '        uint256 rewardTokenDeduction // 每期扣除的奖励代币\n', '    ) public virtual onlyOwner {\n', '        /* 扣除奖励并提取 */\n', '        for (uint256 i = 0; i < periodIds.length; i++) {\n', '            uint256 rewardReceived = _rewardReceivedAt(user, periodIds[i]);\n', '            _updateRewardReceivedAt(\n', '                user,\n', '                periodIds[i],\n', '                rewardReceived.add(rewardTokenDeduction)\n', '            );\n', '            _getReward(user, periodIds[i]);\n', '            emit Deduction(user, rewardToken, rewardTokenDeduction);\n', '        }\n', '        if (amount > 0) {\n', '            require(amount > depositTokenDeduction);\n', '            /* 扣除本金并提取 */\n', '            _totalSupply = _totalSupply.sub(depositTokenDeduction);\n', '            _balances[msg.sender] = _balances[msg.sender].sub(\n', '                depositTokenDeduction\n', '            );\n', '            _withdaw(user, amount.sub(depositTokenDeduction));\n', '            emit Deduction(user, depositToken, depositTokenDeduction);\n', '        }\n', '    }\n', '\n', '    // 存款\n', '    function deposit(uint256 amount) public virtual {\n', '        require(status == 0, "PairFarmPool: Not in deposit status");\n', '        _beforeUpdateUserBalance(msg.sender); // 先更新快照信息\n', '        depositToken.safeTransferFrom(msg.sender, address(this), amount); // 将代币转入钱包\n', '        _totalSupply = _totalSupply.add(amount); // 更新总余额\n', '        _balances[msg.sender] = _balances[msg.sender].add(amount); // 更新用户余额\n', '        emit Deposit(msg.sender, amount);\n', '    }\n', '\n', '    // 提现代币 amount 为0则只提取奖励   periodIds 为空数组则只提取本金\n', '    function withdaw(uint256 amount, uint256[] memory periodIds)\n', '        public\n', '        virtual\n', '        nonReentrant\n', '    {\n', '        require(status == 0, "PairFarmPool: Not in withdrawal status");\n', '        require(\n', '            amount > 0 || periodIds.length > 0,\n', '            "PairFarmPool: Withdrawal params is wrong"\n', '        );\n', '        if (periodIds.length > 0) {\n', '            _getRewards(periodIds);\n', '        }\n', '        if (amount > 0) {\n', '            _withdaw(msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    /* 一次提取多期奖励 */\n', '    function _getRewards(uint256[] memory periodIds) private {\n', '        for (uint256 i = 0; i < periodIds.length; i++) {\n', '            _getReward(msg.sender, periodIds[i]);\n', '        }\n', '    }\n', '\n', '    // 内部方法 提现奖励\n', '    function _getReward(address user, uint256 periodId) private {\n', '        require(\n', '            periodId <= currentSnapshotId(),\n', '            "PairFarmPool: The reward for the current period has not been settled yet"\n', '        );\n', '        (uint256 totalSupply, uint256 totalReward) = snapshotInfoAt(periodId);\n', '        (uint256 balance, uint256 rewardReceived) = _userInfoAt(user, periodId);\n', '        /* 指定期数用户总奖励 */\n', '        uint256 amount = balance.mul(totalReward).div(totalSupply);\n', '        /* 条件: 已经领取的奖励小于总奖励 */\n', '        require(\n', '            rewardReceived < amount,\n', '            "PairFarmPool: The reward has been withdrawn"\n', '        );\n', '        uint256 rewardToBeReceived = amount.sub(rewardReceived); // 计算待领取奖励\n', '        _updateRewardReceivedAt(user, periodId, amount); // 更新已提取奖励\n', '        rewardToken.safeTransfer(user, rewardToBeReceived); // 发送代币\n', '        emit GetReward(user, periodId, rewardToBeReceived);\n', '    }\n', '\n', '    // 内部方法 提现代币\n', '    function _withdaw(address user, uint256 amount) private {\n', '        _beforeUpdateUserBalance(user); // 先更新快照信息\n', '        depositToken.safeTransfer(user, amount);\n', '        _totalSupply = _totalSupply.sub(amount); // 更新总余额\n', '        _balances[user] = _balances[user].sub(amount); // 更新用户余额\n', '        emit Withdaw(user, amount);\n', '    }\n', '}']