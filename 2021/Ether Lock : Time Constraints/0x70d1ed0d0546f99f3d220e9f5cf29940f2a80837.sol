['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-06\n', '*/\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/src/common/libs/Decimals.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '/**\n', ' * Library for emulating calculations involving decimals.\n', ' */\n', 'library Decimals {\n', '\tusing SafeMath for uint256;\n', '\tuint120 private constant BASIS_VAKUE = 1000000000000000000;\n', '\n', '\t/**\n', '\t * @dev Returns the ratio of the first argument to the second argument.\n', '\t * @param _a Numerator.\n', '\t * @param _b Fraction.\n', '\t * @return Calculated ratio.\n', '\t */\n', '\tfunction outOf(uint256 _a, uint256 _b)\n', '\t\tinternal\n', '\t\tpure\n', '\t\treturns (uint256 result)\n', '\t{\n', '\t\tif (_a == 0) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\tuint256 a = _a.mul(BASIS_VAKUE);\n', '\t\tif (a < _b) {\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t\treturn (a.div(_b));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns multiplied the number by 10^18.\n', '\t * @param _a Numerical value to be multiplied.\n', '\t * @return Multiplied value.\n', '\t */\n', '\tfunction mulBasis(uint256 _a) internal pure returns (uint256) {\n', '\t\treturn _a.mul(BASIS_VAKUE);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns divisioned the number by 10^18.\n', '\t * This function can use it to restore the number of digits in the result of `outOf`.\n', '\t * @param _a Numerical value to be divisioned.\n', '\t * @return Divisioned value.\n', '\t */\n', '\tfunction divBasis(uint256 _a) internal pure returns (uint256) {\n', '\t\treturn _a.div(BASIS_VAKUE);\n', '\t}\n', '}\n', '\n', '// File: contracts/interface/IAddressConfig.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', 'pragma solidity >=0.5.17;\n', '\n', 'interface IAddressConfig {\n', '\tfunction token() external view returns (address);\n', '\n', '\tfunction allocator() external view returns (address);\n', '\n', '\tfunction allocatorStorage() external view returns (address);\n', '\n', '\tfunction withdraw() external view returns (address);\n', '\n', '\tfunction withdrawStorage() external view returns (address);\n', '\n', '\tfunction marketFactory() external view returns (address);\n', '\n', '\tfunction marketGroup() external view returns (address);\n', '\n', '\tfunction propertyFactory() external view returns (address);\n', '\n', '\tfunction propertyGroup() external view returns (address);\n', '\n', '\tfunction metricsGroup() external view returns (address);\n', '\n', '\tfunction metricsFactory() external view returns (address);\n', '\n', '\tfunction policy() external view returns (address);\n', '\n', '\tfunction policyFactory() external view returns (address);\n', '\n', '\tfunction policySet() external view returns (address);\n', '\n', '\tfunction policyGroup() external view returns (address);\n', '\n', '\tfunction lockup() external view returns (address);\n', '\n', '\tfunction lockupStorage() external view returns (address);\n', '\n', '\tfunction voteTimes() external view returns (address);\n', '\n', '\tfunction voteTimesStorage() external view returns (address);\n', '\n', '\tfunction voteCounter() external view returns (address);\n', '\n', '\tfunction voteCounterStorage() external view returns (address);\n', '\n', '\tfunction setAllocator(address _addr) external;\n', '\n', '\tfunction setAllocatorStorage(address _addr) external;\n', '\n', '\tfunction setWithdraw(address _addr) external;\n', '\n', '\tfunction setWithdrawStorage(address _addr) external;\n', '\n', '\tfunction setMarketFactory(address _addr) external;\n', '\n', '\tfunction setMarketGroup(address _addr) external;\n', '\n', '\tfunction setPropertyFactory(address _addr) external;\n', '\n', '\tfunction setPropertyGroup(address _addr) external;\n', '\n', '\tfunction setMetricsFactory(address _addr) external;\n', '\n', '\tfunction setMetricsGroup(address _addr) external;\n', '\n', '\tfunction setPolicyFactory(address _addr) external;\n', '\n', '\tfunction setPolicyGroup(address _addr) external;\n', '\n', '\tfunction setPolicySet(address _addr) external;\n', '\n', '\tfunction setPolicy(address _addr) external;\n', '\n', '\tfunction setToken(address _addr) external;\n', '\n', '\tfunction setLockup(address _addr) external;\n', '\n', '\tfunction setLockupStorage(address _addr) external;\n', '\n', '\tfunction setVoteTimes(address _addr) external;\n', '\n', '\tfunction setVoteTimesStorage(address _addr) external;\n', '\n', '\tfunction setVoteCounter(address _addr) external;\n', '\n', '\tfunction setVoteCounterStorage(address _addr) external;\n', '}\n', '\n', '// File: contracts/src/common/config/UsingConfig.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '/**\n', ' * Module for using AddressConfig contracts.\n', ' */\n', 'contract UsingConfig {\n', '\taddress private _config;\n', '\n', '\t/**\n', '\t * Initialize the argument as AddressConfig address.\n', '\t */\n', '\tconstructor(address _addressConfig) public {\n', '\t\t_config = _addressConfig;\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the latest AddressConfig instance.\n', '\t */\n', '\tfunction config() internal view returns (IAddressConfig) {\n', '\t\treturn IAddressConfig(_config);\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the latest AddressConfig address.\n', '\t */\n', '\tfunction configAddress() external view returns (address) {\n', '\t\treturn _config;\n', '\t}\n', '}\n', '\n', '// File: contracts/interface/IUsingStorage.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', 'pragma solidity >=0.5.17;\n', '\n', 'interface IUsingStorage {\n', '\tfunction getStorageAddress() external view returns (address);\n', '\n', '\tfunction createStorage() external;\n', '\n', '\tfunction setStorage(address _storageAddress) external;\n', '\n', '\tfunction changeOwner(address newOwner) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/src/common/storage/EternalStorage.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '/**\n', ' * Module for persisting states.\n', ' * Stores a map for `uint256`, `string`, `address`, `bytes32`, `bool`, and `int256` type with `bytes32` type as a key.\n', ' */\n', 'contract EternalStorage {\n', '\taddress private currentOwner = msg.sender;\n', '\n', '\tmapping(bytes32 => uint256) private uIntStorage;\n', '\tmapping(bytes32 => string) private stringStorage;\n', '\tmapping(bytes32 => address) private addressStorage;\n', '\tmapping(bytes32 => bytes32) private bytesStorage;\n', '\tmapping(bytes32 => bool) private boolStorage;\n', '\tmapping(bytes32 => int256) private intStorage;\n', '\n', '\t/**\n', '\t * Modifiers to validate that only the owner can execute.\n', '\t */\n', '\tmodifier onlyCurrentOwner() {\n', '\t\trequire(msg.sender == currentOwner, "not current owner");\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Transfer the owner.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction changeOwner(address _newOwner) external {\n', '\t\trequire(msg.sender == currentOwner, "not current owner");\n', '\t\tcurrentOwner = _newOwner;\n', '\t}\n', '\n', '\t// *** Getter Methods ***\n', '\n', '\t/**\n', '\t * Returns the value of the `uint256` type that mapped to the given key.\n', '\t */\n', '\tfunction getUint(bytes32 _key) external view returns (uint256) {\n', '\t\treturn uIntStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the value of the `string` type that mapped to the given key.\n', '\t */\n', '\tfunction getString(bytes32 _key) external view returns (string memory) {\n', '\t\treturn stringStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the value of the `address` type that mapped to the given key.\n', '\t */\n', '\tfunction getAddress(bytes32 _key) external view returns (address) {\n', '\t\treturn addressStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the value of the `bytes32` type that mapped to the given key.\n', '\t */\n', '\tfunction getBytes(bytes32 _key) external view returns (bytes32) {\n', '\t\treturn bytesStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the value of the `bool` type that mapped to the given key.\n', '\t */\n', '\tfunction getBool(bytes32 _key) external view returns (bool) {\n', '\t\treturn boolStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the value of the `int256` type that mapped to the given key.\n', '\t */\n', '\tfunction getInt(bytes32 _key) external view returns (int256) {\n', '\t\treturn intStorage[_key];\n', '\t}\n', '\n', '\t// *** Setter Methods ***\n', '\n', '\t/**\n', '\t * Maps a value of `uint256` type to a given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction setUint(bytes32 _key, uint256 _value) external onlyCurrentOwner {\n', '\t\tuIntStorage[_key] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * Maps a value of `string` type to a given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction setString(bytes32 _key, string calldata _value)\n', '\t\texternal\n', '\t\tonlyCurrentOwner\n', '\t{\n', '\t\tstringStorage[_key] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * Maps a value of `address` type to a given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction setAddress(bytes32 _key, address _value)\n', '\t\texternal\n', '\t\tonlyCurrentOwner\n', '\t{\n', '\t\taddressStorage[_key] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * Maps a value of `bytes32` type to a given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction setBytes(bytes32 _key, bytes32 _value) external onlyCurrentOwner {\n', '\t\tbytesStorage[_key] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * Maps a value of `bool` type to a given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction setBool(bytes32 _key, bool _value) external onlyCurrentOwner {\n', '\t\tboolStorage[_key] = _value;\n', '\t}\n', '\n', '\t/**\n', '\t * Maps a value of `int256` type to a given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction setInt(bytes32 _key, int256 _value) external onlyCurrentOwner {\n', '\t\tintStorage[_key] = _value;\n', '\t}\n', '\n', '\t// *** Delete Methods ***\n', '\n', '\t/**\n', '\t * Deletes the value of the `uint256` type that mapped to the given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction deleteUint(bytes32 _key) external onlyCurrentOwner {\n', '\t\tdelete uIntStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Deletes the value of the `string` type that mapped to the given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction deleteString(bytes32 _key) external onlyCurrentOwner {\n', '\t\tdelete stringStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Deletes the value of the `address` type that mapped to the given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction deleteAddress(bytes32 _key) external onlyCurrentOwner {\n', '\t\tdelete addressStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Deletes the value of the `bytes32` type that mapped to the given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction deleteBytes(bytes32 _key) external onlyCurrentOwner {\n', '\t\tdelete bytesStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Deletes the value of the `bool` type that mapped to the given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction deleteBool(bytes32 _key) external onlyCurrentOwner {\n', '\t\tdelete boolStorage[_key];\n', '\t}\n', '\n', '\t/**\n', '\t * Deletes the value of the `int256` type that mapped to the given key.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction deleteInt(bytes32 _key) external onlyCurrentOwner {\n', '\t\tdelete intStorage[_key];\n', '\t}\n', '}\n', '\n', '// File: contracts/src/common/storage/UsingStorage.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '/**\n', ' * Module for contrast handling EternalStorage.\n', ' */\n', 'contract UsingStorage is Ownable, IUsingStorage {\n', '\taddress private _storage;\n', '\n', '\t/**\n', '\t * Modifier to verify that EternalStorage is set.\n', '\t */\n', '\tmodifier hasStorage() {\n', '\t\trequire(_storage != address(0), "storage is not set");\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the set EternalStorage instance.\n', '\t */\n', '\tfunction eternalStorage()\n', '\t\tinternal\n', '\t\tview\n', '\t\thasStorage\n', '\t\treturns (EternalStorage)\n', '\t{\n', '\t\treturn EternalStorage(_storage);\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the set EternalStorage address.\n', '\t */\n', '\tfunction getStorageAddress() external view hasStorage returns (address) {\n', '\t\treturn _storage;\n', '\t}\n', '\n', '\t/**\n', '\t * Create a new EternalStorage contract.\n', '\t * This function call will fail if the EternalStorage contract is already set.\n', '\t * Also, only the owner can execute it.\n', '\t */\n', '\tfunction createStorage() external onlyOwner {\n', '\t\trequire(_storage == address(0), "storage is set");\n', '\t\tEternalStorage tmp = new EternalStorage();\n', '\t\t_storage = address(tmp);\n', '\t}\n', '\n', '\t/**\n', '\t * Assigns the EternalStorage contract that has already been created.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction setStorage(address _storageAddress) external onlyOwner {\n', '\t\t_storage = _storageAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * Delegates the owner of the current EternalStorage contract.\n', '\t * Only the owner can execute this function.\n', '\t */\n', '\tfunction changeOwner(address newOwner) external onlyOwner {\n', '\t\tEternalStorage(_storage).changeOwner(newOwner);\n', '\t}\n', '}\n', '\n', '// File: contracts/src/lockup/LockupStorage.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', 'contract LockupStorage is UsingStorage {\n', '\tusing SafeMath for uint256;\n', '\n', '\tuint256 private constant BASIS = 100000000000000000000000000000000;\n', '\n', '\t//AllValue\n', '\tfunction setStorageAllValue(uint256 _value) internal {\n', '\t\tbytes32 key = getStorageAllValueKey();\n', '\t\teternalStorage().setUint(key, _value);\n', '\t}\n', '\n', '\tfunction getStorageAllValue() public view returns (uint256) {\n', '\t\tbytes32 key = getStorageAllValueKey();\n', '\t\treturn eternalStorage().getUint(key);\n', '\t}\n', '\n', '\tfunction getStorageAllValueKey() private pure returns (bytes32) {\n', '\t\treturn keccak256(abi.encodePacked("_allValue"));\n', '\t}\n', '\n', '\t//Value\n', '\tfunction setStorageValue(\n', '\t\taddress _property,\n', '\t\taddress _sender,\n', '\t\tuint256 _value\n', '\t) internal {\n', '\t\tbytes32 key = getStorageValueKey(_property, _sender);\n', '\t\teternalStorage().setUint(key, _value);\n', '\t}\n', '\n', '\tfunction getStorageValue(address _property, address _sender)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\tbytes32 key = getStorageValueKey(_property, _sender);\n', '\t\treturn eternalStorage().getUint(key);\n', '\t}\n', '\n', '\tfunction getStorageValueKey(address _property, address _sender)\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("_value", _property, _sender));\n', '\t}\n', '\n', '\t//PropertyValue\n', '\tfunction setStoragePropertyValue(address _property, uint256 _value)\n', '\t\tinternal\n', '\t{\n', '\t\tbytes32 key = getStoragePropertyValueKey(_property);\n', '\t\teternalStorage().setUint(key, _value);\n', '\t}\n', '\n', '\tfunction getStoragePropertyValue(address _property)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\tbytes32 key = getStoragePropertyValueKey(_property);\n', '\t\treturn eternalStorage().getUint(key);\n', '\t}\n', '\n', '\tfunction getStoragePropertyValueKey(address _property)\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("_propertyValue", _property));\n', '\t}\n', '\n', '\t//InterestPrice\n', '\tfunction setStorageInterestPrice(address _property, uint256 _value)\n', '\t\tinternal\n', '\t{\n', '\t\t// The previously used function\n', '\t\t// This function is only used in testing\n', '\t\teternalStorage().setUint(getStorageInterestPriceKey(_property), _value);\n', '\t}\n', '\n', '\tfunction getStorageInterestPrice(address _property)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn eternalStorage().getUint(getStorageInterestPriceKey(_property));\n', '\t}\n', '\n', '\tfunction getStorageInterestPriceKey(address _property)\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("_interestTotals", _property));\n', '\t}\n', '\n', '\t//LastInterestPrice\n', '\tfunction setStorageLastInterestPrice(\n', '\t\taddress _property,\n', '\t\taddress _user,\n', '\t\tuint256 _value\n', '\t) internal {\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageLastInterestPriceKey(_property, _user),\n', '\t\t\t_value\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastInterestPrice(address _property, address _user)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStorageLastInterestPriceKey(_property, _user)\n', '\t\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastInterestPriceKey(address _property, address _user)\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn\n', '\t\t\tkeccak256(\n', '\t\t\t\tabi.encodePacked("_lastLastInterestPrice", _property, _user)\n', '\t\t\t);\n', '\t}\n', '\n', '\t//LastSameRewardsAmountAndBlock\n', '\tfunction setStorageLastSameRewardsAmountAndBlock(\n', '\t\tuint256 _amount,\n', '\t\tuint256 _block\n', '\t) internal {\n', '\t\tuint256 record = _amount.mul(BASIS).add(_block);\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageLastSameRewardsAmountAndBlockKey(),\n', '\t\t\trecord\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastSameRewardsAmountAndBlock()\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256 _amount, uint256 _block)\n', '\t{\n', '\t\tuint256 record =\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStorageLastSameRewardsAmountAndBlockKey()\n', '\t\t\t);\n', '\t\tuint256 amount = record.div(BASIS);\n', '\t\tuint256 blockNumber = record.sub(amount.mul(BASIS));\n', '\t\treturn (amount, blockNumber);\n', '\t}\n', '\n', '\tfunction getStorageLastSameRewardsAmountAndBlockKey()\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("_LastSameRewardsAmountAndBlock"));\n', '\t}\n', '\n', '\t//CumulativeGlobalRewards\n', '\tfunction setStorageCumulativeGlobalRewards(uint256 _value) internal {\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageCumulativeGlobalRewardsKey(),\n', '\t\t\t_value\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageCumulativeGlobalRewards() public view returns (uint256) {\n', '\t\treturn eternalStorage().getUint(getStorageCumulativeGlobalRewardsKey());\n', '\t}\n', '\n', '\tfunction getStorageCumulativeGlobalRewardsKey()\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("_cumulativeGlobalRewards"));\n', '\t}\n', '\n', '\t//PendingWithdrawal\n', '\tfunction setStoragePendingInterestWithdrawal(\n', '\t\taddress _property,\n', '\t\taddress _user,\n', '\t\tuint256 _value\n', '\t) internal {\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStoragePendingInterestWithdrawalKey(_property, _user),\n', '\t\t\t_value\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStoragePendingInterestWithdrawal(\n', '\t\taddress _property,\n', '\t\taddress _user\n', '\t) public view returns (uint256) {\n', '\t\treturn\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStoragePendingInterestWithdrawalKey(_property, _user)\n', '\t\t\t);\n', '\t}\n', '\n', '\tfunction getStoragePendingInterestWithdrawalKey(\n', '\t\taddress _property,\n', '\t\taddress _user\n', '\t) private pure returns (bytes32) {\n', '\t\treturn\n', '\t\t\tkeccak256(\n', '\t\t\t\tabi.encodePacked("_pendingInterestWithdrawal", _property, _user)\n', '\t\t\t);\n', '\t}\n', '\n', '\t//DIP4GenesisBlock\n', '\tfunction setStorageDIP4GenesisBlock(uint256 _block) internal {\n', '\t\teternalStorage().setUint(getStorageDIP4GenesisBlockKey(), _block);\n', '\t}\n', '\n', '\tfunction getStorageDIP4GenesisBlock() public view returns (uint256) {\n', '\t\treturn eternalStorage().getUint(getStorageDIP4GenesisBlockKey());\n', '\t}\n', '\n', '\tfunction getStorageDIP4GenesisBlockKey() private pure returns (bytes32) {\n', '\t\treturn keccak256(abi.encodePacked("_dip4GenesisBlock"));\n', '\t}\n', '\n', '\t//lastStakedInterestPrice\n', '\tfunction setStorageLastStakedInterestPrice(\n', '\t\taddress _property,\n', '\t\taddress _user,\n', '\t\tuint256 _value\n', '\t) internal {\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageLastStakedInterestPriceKey(_property, _user),\n', '\t\t\t_value\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastStakedInterestPrice(address _property, address _user)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStorageLastStakedInterestPriceKey(_property, _user)\n', '\t\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastStakedInterestPriceKey(\n', '\t\taddress _property,\n', '\t\taddress _user\n', '\t) private pure returns (bytes32) {\n', '\t\treturn\n', '\t\t\tkeccak256(\n', '\t\t\t\tabi.encodePacked("_lastStakedInterestPrice", _property, _user)\n', '\t\t\t);\n', '\t}\n', '\n', '\t//lastStakesChangedCumulativeReward\n', '\tfunction setStorageLastStakesChangedCumulativeReward(uint256 _value)\n', '\t\tinternal\n', '\t{\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageLastStakesChangedCumulativeRewardKey(),\n', '\t\t\t_value\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastStakesChangedCumulativeReward()\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStorageLastStakesChangedCumulativeRewardKey()\n', '\t\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastStakesChangedCumulativeRewardKey()\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn\n', '\t\t\tkeccak256(abi.encodePacked("_lastStakesChangedCumulativeReward"));\n', '\t}\n', '\n', '\t//LastCumulativeHoldersRewardPrice\n', '\tfunction setStorageLastCumulativeHoldersRewardPrice(uint256 _holders)\n', '\t\tinternal\n', '\t{\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageLastCumulativeHoldersRewardPriceKey(),\n', '\t\t\t_holders\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastCumulativeHoldersRewardPrice()\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStorageLastCumulativeHoldersRewardPriceKey()\n', '\t\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastCumulativeHoldersRewardPriceKey()\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("0lastCumulativeHoldersRewardPrice"));\n', '\t}\n', '\n', '\t//LastCumulativeInterestPrice\n', '\tfunction setStorageLastCumulativeInterestPrice(uint256 _interest) internal {\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageLastCumulativeInterestPriceKey(),\n', '\t\t\t_interest\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastCumulativeInterestPrice()\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStorageLastCumulativeInterestPriceKey()\n', '\t\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastCumulativeInterestPriceKey()\n', '\t\tprivate\n', '\t\tpure\n', '\t\treturns (bytes32)\n', '\t{\n', '\t\treturn keccak256(abi.encodePacked("0lastCumulativeInterestPrice"));\n', '\t}\n', '\n', '\t//LastCumulativeHoldersRewardAmountPerProperty\n', '\tfunction setStorageLastCumulativeHoldersRewardAmountPerProperty(\n', '\t\taddress _property,\n', '\t\tuint256 _value\n', '\t) internal {\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageLastCumulativeHoldersRewardAmountPerPropertyKey(\n', '\t\t\t\t_property\n', '\t\t\t),\n', '\t\t\t_value\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastCumulativeHoldersRewardAmountPerProperty(\n', '\t\taddress _property\n', '\t) public view returns (uint256) {\n', '\t\treturn\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStorageLastCumulativeHoldersRewardAmountPerPropertyKey(\n', '\t\t\t\t\t_property\n', '\t\t\t\t)\n', '\t\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastCumulativeHoldersRewardAmountPerPropertyKey(\n', '\t\taddress _property\n', '\t) private pure returns (bytes32) {\n', '\t\treturn\n', '\t\t\tkeccak256(\n', '\t\t\t\tabi.encodePacked(\n', '\t\t\t\t\t"0lastCumulativeHoldersRewardAmountPerProperty",\n', '\t\t\t\t\t_property\n', '\t\t\t\t)\n', '\t\t\t);\n', '\t}\n', '\n', '\t//LastCumulativeHoldersRewardPricePerProperty\n', '\tfunction setStorageLastCumulativeHoldersRewardPricePerProperty(\n', '\t\taddress _property,\n', '\t\tuint256 _price\n', '\t) internal {\n', '\t\teternalStorage().setUint(\n', '\t\t\tgetStorageLastCumulativeHoldersRewardPricePerPropertyKey(_property),\n', '\t\t\t_price\n', '\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastCumulativeHoldersRewardPricePerProperty(\n', '\t\taddress _property\n', '\t) public view returns (uint256) {\n', '\t\treturn\n', '\t\t\teternalStorage().getUint(\n', '\t\t\t\tgetStorageLastCumulativeHoldersRewardPricePerPropertyKey(\n', '\t\t\t\t\t_property\n', '\t\t\t\t)\n', '\t\t\t);\n', '\t}\n', '\n', '\tfunction getStorageLastCumulativeHoldersRewardPricePerPropertyKey(\n', '\t\taddress _property\n', '\t) private pure returns (bytes32) {\n', '\t\treturn\n', '\t\t\tkeccak256(\n', '\t\t\t\tabi.encodePacked(\n', '\t\t\t\t\t"0lastCumulativeHoldersRewardPricePerProperty",\n', '\t\t\t\t\t_property\n', '\t\t\t\t)\n', '\t\t\t);\n', '\t}\n', '}\n', '\n', '// File: contracts/interface/IDevMinter.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', 'pragma solidity >=0.5.17;\n', '\n', 'interface IDevMinter {\n', '\tfunction mint(address account, uint256 amount) external returns (bool);\n', '\n', '\tfunction renounceMinter() external;\n', '}\n', '\n', '// File: contracts/interface/IProperty.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', 'pragma solidity >=0.5.17;\n', '\n', 'interface IProperty {\n', '\tfunction author() external view returns (address);\n', '\n', '\tfunction changeAuthor(address _nextAuthor) external;\n', '\n', '\tfunction changeName(string calldata _name) external;\n', '\n', '\tfunction changeSymbol(string calldata _symbol) external;\n', '\n', '\tfunction withdraw(address _sender, uint256 _value) external;\n', '}\n', '\n', '// File: contracts/interface/IPolicy.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', 'pragma solidity >=0.5.17;\n', '\n', 'interface IPolicy {\n', '\tfunction rewards(uint256 _lockups, uint256 _assets)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256);\n', '\n', '\tfunction holdersShare(uint256 _amount, uint256 _lockups)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256);\n', '\n', '\tfunction authenticationFee(uint256 _assets, uint256 _propertyAssets)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256);\n', '\n', '\tfunction marketApproval(uint256 _agree, uint256 _opposite)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (bool);\n', '\n', '\tfunction policyApproval(uint256 _agree, uint256 _opposite)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (bool);\n', '\n', '\tfunction marketVotingBlocks() external view returns (uint256);\n', '\n', '\tfunction policyVotingBlocks() external view returns (uint256);\n', '\n', '\tfunction shareOfTreasury(uint256 _supply) external view returns (uint256);\n', '\n', '\tfunction treasury() external view returns (address);\n', '}\n', '\n', '// File: contracts/interface/IAllocator.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', 'pragma solidity >=0.5.17;\n', '\n', 'interface IAllocator {\n', '\tfunction beforeBalanceChange(\n', '\t\taddress _property,\n', '\t\taddress _from,\n', '\t\taddress _to\n', '\t) external;\n', '\n', '\tfunction calculateMaxRewardsPerBlock() external view returns (uint256);\n', '}\n', '\n', '// File: contracts/interface/ILockup.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', 'pragma solidity >=0.5.17;\n', '\n', 'interface ILockup {\n', '\tfunction lockup(\n', '\t\taddress _from,\n', '\t\taddress _property,\n', '\t\tuint256 _value\n', '\t) external;\n', '\n', '\tfunction update() external;\n', '\n', '\tfunction withdraw(address _property, uint256 _amount) external;\n', '\n', '\tfunction calculateCumulativeRewardPrices()\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (\n', '\t\t\tuint256 _reward,\n', '\t\t\tuint256 _holders,\n', '\t\t\tuint256 _interest\n', '\t\t);\n', '\n', '\tfunction calculateCumulativeHoldersRewardAmount(address _property)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256);\n', '\n', '\tfunction getPropertyValue(address _property)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256);\n', '\n', '\tfunction getAllValue() external view returns (uint256);\n', '\n', '\tfunction getValue(address _property, address _sender)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256);\n', '\n', '\tfunction calculateWithdrawableInterestAmount(\n', '\t\taddress _property,\n', '\t\taddress _user\n', '\t) external view returns (uint256);\n', '\n', '\tfunction devMinter() external view returns (address);\n', '}\n', '\n', '// File: contracts/interface/IMetricsGroup.sol\n', '\n', '// SPDX-License-Identifier: MPL-2.0\n', 'pragma solidity >=0.5.17;\n', '\n', 'interface IMetricsGroup {\n', '\tfunction addGroup(address _addr) external;\n', '\n', '\tfunction removeGroup(address _addr) external;\n', '\n', '\tfunction isGroup(address _addr) external view returns (bool);\n', '\n', '\tfunction totalIssuedMetrics() external view returns (uint256);\n', '\n', '\tfunction hasAssets(address _property) external view returns (bool);\n', '\n', '\tfunction getMetricsCountPerProperty(address _property)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256);\n', '}\n', '\n', '// File: contracts/src/lockup/Lockup.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '// prettier-ignore\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * A contract that manages the staking of DEV tokens and calculates rewards.\n', ' * Staking and the following mechanism determines that reward calculation.\n', ' *\n', ' * Variables:\n', ' * -`M`: Maximum mint amount per block determined by Allocator contract\n', ' * -`B`: Number of blocks during staking\n', ' * -`P`: Total number of staking locked up in a Property contract\n', ' * -`S`: Total number of staking locked up in all Property contracts\n', ' * -`U`: Number of staking per account locked up in a Property contract\n', ' *\n', ' * Formula:\n', ' * Staking Rewards = M * B * (P / S) * (U / P)\n', ' *\n', ' * Note:\n', ' * -`M`, `P` and `S` vary from block to block, and the variation cannot be predicted.\n', ' * -`B` is added every time the Ethereum block is created.\n', ' * - Only `U` and `B` are predictable variables.\n', ' * - As `M`, `P` and `S` cannot be observed from a staker, the "cumulative sum" is often used to calculate ratio variation with history.\n', ' * - Reward withdrawal always withdraws the total withdrawable amount.\n', ' *\n', ' * Scenario:\n', ' * - Assume `M` is fixed at 500\n', " * - Alice stakes 100 DEV on Property-A (Alice's staking state on Property-A: `M`=500, `B`=0, `P`=100, `S`=100, `U`=100)\n", " * - After 10 blocks, Bob stakes 60 DEV on Property-B (Alice's staking state on Property-A: `M`=500, `B`=10, `P`=100, `S`=160, `U`=100)\n", " * - After 10 blocks, Carol stakes 40 DEV on Property-A (Alice's staking state on Property-A: `M`=500, `B`=20, `P`=140, `S`=200, `U`=100)\n", ' * - After 10 blocks, Alice withdraws Property-A staking reward. The reward at this time is 5000 DEV (10 blocks * 500 DEV) + 3125 DEV (10 blocks * 62.5% * 500 DEV) + 2500 DEV (10 blocks * 50% * 500 DEV).\n', ' */\n', 'contract Lockup is ILockup, UsingConfig, LockupStorage {\n', '\tusing SafeMath for uint256;\n', '\tusing Decimals for uint256;\n', '\taddress public devMinter;\n', '\tstruct RewardPrices {\n', '\t\tuint256 reward;\n', '\t\tuint256 holders;\n', '\t\tuint256 interest;\n', '\t}\n', '\tevent Lockedup(address _from, address _property, uint256 _value);\n', '\n', '\t/**\n', '\t * Initialize the passed address as AddressConfig address and Devminter.\n', '\t */\n', '\tconstructor(address _config, address _devMinter)\n', '\t\tpublic\n', '\t\tUsingConfig(_config)\n', '\t{\n', '\t\tdevMinter = _devMinter;\n', '\t}\n', '\n', '\t/**\n', '\t * Adds staking.\n', '\t * Only the Dev contract can execute this function.\n', '\t */\n', '\tfunction lockup(\n', '\t\taddress _from,\n', '\t\taddress _property,\n', '\t\tuint256 _value\n', '\t) external {\n', '\t\t/**\n', '\t\t * Validates the sender is Dev contract.\n', '\t\t */\n', '\t\trequire(msg.sender == config().token(), "this is illegal address");\n', '\n', '\t\t/**\n', '\t\t * Validates _value is not 0.\n', '\t\t */\n', '\t\trequire(_value != 0, "illegal lockup value");\n', '\n', '\t\t/**\n', '\t\t * Validates the passed Property has greater than 1 asset.\n', '\t\t */\n', '\t\trequire(\n', '\t\t\tIMetricsGroup(config().metricsGroup()).hasAssets(_property),\n', '\t\t\t"unable to stake to unauthenticated property"\n', '\t\t);\n', '\n', '\t\t/**\n', '\t\t * Since the reward per block that can be withdrawn will change with the addition of staking,\n', '\t\t * saves the undrawn withdrawable reward before addition it.\n', '\t\t */\n', '\t\tRewardPrices memory prices =\n', '\t\t\tupdatePendingInterestWithdrawal(_property, _from);\n', '\n', '\t\t/**\n', '\t\t * Saves variables that should change due to the addition of staking.\n', '\t\t */\n', '\t\tupdateValues(true, _from, _property, _value, prices);\n', '\t\temit Lockedup(_from, _property, _value);\n', '\t}\n', '\n', '\t/**\n', '\t * Withdraw staking.\n', '\t * Releases staking, withdraw rewards, and transfer the staked and withdraw rewards amount to the sender.\n', '\t */\n', '\tfunction withdraw(address _property, uint256 _amount) external {\n', '\t\t/**\n', '\t\t * Validates the sender is staking to the target Property.\n', '\t\t */\n', '\t\trequire(\n', '\t\t\thasValue(_property, msg.sender, _amount),\n', '\t\t\t"insufficient tokens staked"\n', '\t\t);\n', '\n', '\t\t/**\n', '\t\t * Withdraws the staking reward\n', '\t\t */\n', '\t\tRewardPrices memory prices = _withdrawInterest(_property);\n', '\n', '\t\t/**\n', '\t\t * Transfer the staked amount to the sender.\n', '\t\t */\n', '\t\tif (_amount != 0) {\n', '\t\t\tIProperty(_property).withdraw(msg.sender, _amount);\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t * Saves variables that should change due to the canceling staking..\n', '\t\t */\n', '\t\tupdateValues(false, msg.sender, _property, _amount, prices);\n', '\t}\n', '\n', '\t/**\n', '\t * Store staking states as a snapshot.\n', '\t */\n', '\tfunction beforeStakesChanged(\n', '\t\taddress _property,\n', '\t\taddress _user,\n', '\t\tRewardPrices memory _prices\n', '\t) private {\n', '\t\t/**\n', '\t\t * Gets latest cumulative holders reward for the passed Property.\n', '\t\t */\n', '\t\tuint256 cHoldersReward =\n', '\t\t\t_calculateCumulativeHoldersRewardAmount(_prices.holders, _property);\n', '\n', '\t\t/**\n', '\t\t * Store each value.\n', '\t\t */\n', '\t\tsetStorageLastStakedInterestPrice(_property, _user, _prices.interest);\n', '\t\tsetStorageLastStakesChangedCumulativeReward(_prices.reward);\n', '\t\tsetStorageLastCumulativeHoldersRewardPrice(_prices.holders);\n', '\t\tsetStorageLastCumulativeInterestPrice(_prices.interest);\n', '\t\tsetStorageLastCumulativeHoldersRewardAmountPerProperty(\n', '\t\t\t_property,\n', '\t\t\tcHoldersReward\n', '\t\t);\n', '\t\tsetStorageLastCumulativeHoldersRewardPricePerProperty(\n', '\t\t\t_property,\n', '\t\t\t_prices.holders\n', '\t\t);\n', '\t}\n', '\n', '\t/**\n', '\t * Gets latest value of cumulative sum of the reward amount, cumulative sum of the holders reward per stake, and cumulative sum of the stakers reward per stake.\n', '\t */\n', '\tfunction calculateCumulativeRewardPrices()\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (\n', '\t\t\tuint256 _reward,\n', '\t\t\tuint256 _holders,\n', '\t\t\tuint256 _interest\n', '\t\t)\n', '\t{\n', '\t\tuint256 lastReward = getStorageLastStakesChangedCumulativeReward();\n', '\t\tuint256 lastHoldersPrice = getStorageLastCumulativeHoldersRewardPrice();\n', '\t\tuint256 lastInterestPrice = getStorageLastCumulativeInterestPrice();\n', '\t\tuint256 allStakes = getStorageAllValue();\n', '\n', '\t\t/**\n', '\t\t * Gets latest cumulative sum of the reward amount.\n', '\t\t */\n', '\t\t(uint256 reward, ) = dry();\n', '\t\tuint256 mReward = reward.mulBasis();\n', '\n', '\t\t/**\n', '\t\t * Calculates reward unit price per staking.\n', '\t\t * Later, the last cumulative sum of the reward amount is subtracted because to add the last recorded holder/staking reward.\n', '\t\t */\n', '\t\tuint256 price =\n', '\t\t\tallStakes > 0 ? mReward.sub(lastReward).div(allStakes) : 0;\n', '\n', '\t\t/**\n', '\t\t * Calculates the holders reward out of the total reward amount.\n', '\t\t */\n', '\t\tuint256 holdersShare =\n', '\t\t\tIPolicy(config().policy()).holdersShare(price, allStakes);\n', '\n', '\t\t/**\n', '\t\t * Calculates and returns each reward.\n', '\t\t */\n', '\t\tuint256 holdersPrice = holdersShare.add(lastHoldersPrice);\n', '\t\tuint256 interestPrice = price.sub(holdersShare).add(lastInterestPrice);\n', '\t\treturn (mReward, holdersPrice, interestPrice);\n', '\t}\n', '\n', '\t/**\n', '\t * Calculates cumulative sum of the holders reward per Property.\n', '\t * To save computing resources, it receives the latest holder rewards from a caller.\n', '\t */\n', '\tfunction _calculateCumulativeHoldersRewardAmount(\n', '\t\tuint256 _reward,\n', '\t\taddress _property\n', '\t) private view returns (uint256) {\n', '\t\t(uint256 cHoldersReward, uint256 lastReward) =\n', '\t\t\t(\n', '\t\t\t\tgetStorageLastCumulativeHoldersRewardAmountPerProperty(\n', '\t\t\t\t\t_property\n', '\t\t\t\t),\n', '\t\t\t\tgetStorageLastCumulativeHoldersRewardPricePerProperty(_property)\n', '\t\t\t);\n', '\n', '\t\t/**\n', '\t\t * `cHoldersReward` contains the calculation of `lastReward`, so subtract it here.\n', '\t\t */\n', '\t\tuint256 additionalHoldersReward =\n', '\t\t\t_reward.sub(lastReward).mul(getStoragePropertyValue(_property));\n', '\n', '\t\t/**\n', '\t\t * Calculates and returns the cumulative sum of the holder reward by adds the last recorded holder reward and the latest holder reward.\n', '\t\t */\n', '\t\treturn cHoldersReward.add(additionalHoldersReward);\n', '\t}\n', '\n', '\t/**\n', '\t * Calculates cumulative sum of the holders reward per Property.\n', '\t */\n', '\tfunction calculateCumulativeHoldersRewardAmount(address _property)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\t(, uint256 holders, ) = calculateCumulativeRewardPrices();\n', '\t\treturn _calculateCumulativeHoldersRewardAmount(holders, _property);\n', '\t}\n', '\n', '\t/**\n', '\t * Updates cumulative sum of the maximum mint amount calculated by Allocator contract, the latest maximum mint amount per block,\n', '\t * and the last recorded block number.\n', '\t * The cumulative sum of the maximum mint amount is always added.\n', '\t * By recording that value when the staker last stakes, the difference from the when the staker stakes can be calculated.\n', '\t */\n', '\tfunction update() public {\n', '\t\t/**\n', '\t\t * Gets the cumulative sum of the maximum mint amount and the maximum mint number per block.\n', '\t\t */\n', '\t\t(uint256 _nextRewards, uint256 _amount) = dry();\n', '\n', '\t\t/**\n', '\t\t * Records each value and the latest block number.\n', '\t\t */\n', '\t\tsetStorageCumulativeGlobalRewards(_nextRewards);\n', '\t\tsetStorageLastSameRewardsAmountAndBlock(_amount, block.number);\n', '\t}\n', '\n', '\t/**\n', '\t * Referring to the values recorded in each storage to returns the latest cumulative sum of the maximum mint amount and the latest maximum mint amount per block.\n', '\t */\n', '\tfunction dry()\n', '\t\tprivate\n', '\t\tview\n', '\t\treturns (uint256 _nextRewards, uint256 _amount)\n', '\t{\n', '\t\t/**\n', '\t\t * Gets the latest mint amount per block from Allocator contract.\n', '\t\t */\n', '\t\tuint256 rewardsAmount =\n', '\t\t\tIAllocator(config().allocator()).calculateMaxRewardsPerBlock();\n', '\n', '\t\t/**\n', '\t\t * Gets the maximum mint amount per block, and the last recorded block number from `LastSameRewardsAmountAndBlock` storage.\n', '\t\t */\n', '\t\t(uint256 lastAmount, uint256 lastBlock) =\n', '\t\t\tgetStorageLastSameRewardsAmountAndBlock();\n', '\n', '\t\t/**\n', '\t\t * If the recorded maximum mint amount per block and the result of the Allocator contract are different,\n', '\t\t * the result of the Allocator contract takes precedence as a maximum mint amount per block.\n', '\t\t */\n', '\t\tuint256 lastMaxRewards =\n', '\t\t\tlastAmount == rewardsAmount ? rewardsAmount : lastAmount;\n', '\n', '\t\t/**\n', '\t\t * Calculates the difference between the latest block number and the last recorded block number.\n', '\t\t */\n', '\t\tuint256 blocks = lastBlock > 0 ? block.number.sub(lastBlock) : 0;\n', '\n', '\t\t/**\n', '\t\t * Adds the calculated new cumulative maximum mint amount to the recorded cumulative maximum mint amount.\n', '\t\t */\n', '\t\tuint256 additionalRewards = lastMaxRewards.mul(blocks);\n', '\t\tuint256 nextRewards =\n', '\t\t\tgetStorageCumulativeGlobalRewards().add(additionalRewards);\n', '\n', '\t\t/**\n', '\t\t * Returns the latest theoretical cumulative sum of maximum mint amount and maximum mint amount per block.\n', '\t\t */\n', '\t\treturn (nextRewards, rewardsAmount);\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the staker reward as interest.\n', '\t */\n', '\tfunction _calculateInterestAmount(address _property, address _user)\n', '\t\tprivate\n', '\t\tview\n', '\t\treturns (\n', '\t\t\tuint256 _amount,\n', '\t\t\tuint256 _interestPrice,\n', '\t\t\tRewardPrices memory _prices\n', '\t\t)\n', '\t{\n', '\t\t/**\n', '\t\t * Get the amount the user is staking for the Property.\n', '\t\t */\n', '\t\tuint256 lockedUpPerAccount = getStorageValue(_property, _user);\n', '\n', '\t\t/**\n', '\t\t * Gets the cumulative sum of the interest price recorded the last time you withdrew.\n', '\t\t */\n', '\t\tuint256 lastInterest =\n', '\t\t\tgetStorageLastStakedInterestPrice(_property, _user);\n', '\n', '\t\t/**\n', '\t\t * Gets the latest cumulative sum of the interest price.\n', '\t\t */\n', '\t\t(uint256 reward, uint256 holders, uint256 interest) =\n', '\t\t\tcalculateCumulativeRewardPrices();\n', '\n', '\t\t/**\n', '\t\t * Calculates and returns the latest withdrawable reward amount from the difference.\n', '\t\t */\n', '\t\tuint256 result =\n', '\t\t\tinterest >= lastInterest\n', '\t\t\t\t? interest.sub(lastInterest).mul(lockedUpPerAccount).divBasis()\n', '\t\t\t\t: 0;\n', '\t\treturn (result, interest, RewardPrices(reward, holders, interest));\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the total rewards currently available for withdrawal. (For calling from inside the contract)\n', '\t */\n', '\tfunction _calculateWithdrawableInterestAmount(\n', '\t\taddress _property,\n', '\t\taddress _user\n', '\t) private view returns (uint256 _amount, RewardPrices memory _prices) {\n', '\t\t/**\n', '\t\t * If the passed Property has not authenticated, returns always 0.\n', '\t\t */\n', '\t\tif (\n', '\t\t\tIMetricsGroup(config().metricsGroup()).hasAssets(_property) == false\n', '\t\t) {\n', '\t\t\treturn (0, RewardPrices(0, 0, 0));\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t * Gets the reward amount in saved without withdrawal.\n', '\t\t */\n', '\t\tuint256 pending = getStoragePendingInterestWithdrawal(_property, _user);\n', '\n', '\t\t/**\n', '\t\t * Gets the reward amount of before DIP4.\n', '\t\t */\n', '\t\tuint256 legacy = __legacyWithdrawableInterestAmount(_property, _user);\n', '\n', '\t\t/**\n', '\t\t * Gets the latest withdrawal reward amount.\n', '\t\t */\n', '\t\t(uint256 amount, , RewardPrices memory prices) =\n', '\t\t\t_calculateInterestAmount(_property, _user);\n', '\n', '\t\t/**\n', '\t\t * Returns the sum of all values.\n', '\t\t */\n', '\t\tuint256 withdrawableAmount = amount.add(pending).add(legacy);\n', '\t\treturn (withdrawableAmount, prices);\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the total rewards currently available for withdrawal. (For calling from external of the contract)\n', '\t */\n', '\tfunction calculateWithdrawableInterestAmount(\n', '\t\taddress _property,\n', '\t\taddress _user\n', '\t) public view returns (uint256) {\n', '\t\t(uint256 amount, ) =\n', '\t\t\t_calculateWithdrawableInterestAmount(_property, _user);\n', '\t\treturn amount;\n', '\t}\n', '\n', '\t/**\n', '\t * Withdraws staking reward as an interest.\n', '\t */\n', '\tfunction _withdrawInterest(address _property)\n', '\t\tprivate\n', '\t\treturns (RewardPrices memory _prices)\n', '\t{\n', '\t\t/**\n', '\t\t * Gets the withdrawable amount.\n', '\t\t */\n', '\t\t(uint256 value, RewardPrices memory prices) =\n', '\t\t\t_calculateWithdrawableInterestAmount(_property, msg.sender);\n', '\n', '\t\t/**\n', '\t\t * Sets the unwithdrawn reward amount to 0.\n', '\t\t */\n', '\t\tsetStoragePendingInterestWithdrawal(_property, msg.sender, 0);\n', '\n', '\t\t/**\n', '\t\t * Updates the staking status to avoid double rewards.\n', '\t\t */\n', '\t\tsetStorageLastStakedInterestPrice(\n', '\t\t\t_property,\n', '\t\t\tmsg.sender,\n', '\t\t\tprices.interest\n', '\t\t);\n', '\t\t__updateLegacyWithdrawableInterestAmount(_property, msg.sender);\n', '\n', '\t\t/**\n', '\t\t * Mints the reward.\n', '\t\t */\n', '\t\trequire(\n', '\t\t\tIDevMinter(devMinter).mint(msg.sender, value),\n', '\t\t\t"dev mint failed"\n', '\t\t);\n', '\n', '\t\t/**\n', '\t\t * Since the total supply of tokens has changed, updates the latest maximum mint amount.\n', '\t\t */\n', '\t\tupdate();\n', '\n', '\t\treturn prices;\n', '\t}\n', '\n', '\t/**\n', '\t * Status updates with the addition or release of staking.\n', '\t */\n', '\tfunction updateValues(\n', '\t\tbool _addition,\n', '\t\taddress _account,\n', '\t\taddress _property,\n', '\t\tuint256 _value,\n', '\t\tRewardPrices memory _prices\n', '\t) private {\n', '\t\tbeforeStakesChanged(_property, _account, _prices);\n', '\t\t/**\n', '\t\t * If added staking:\n', '\t\t */\n', '\t\tif (_addition) {\n', '\t\t\t/**\n', '\t\t\t * Updates the current staking amount of the protocol total.\n', '\t\t\t */\n', '\t\t\taddAllValue(_value);\n', '\n', '\t\t\t/**\n', '\t\t\t * Updates the current staking amount of the Property.\n', '\t\t\t */\n', '\t\t\taddPropertyValue(_property, _value);\n', '\n', '\t\t\t/**\n', "\t\t\t * Updates the user's current staking amount in the Property.\n", '\t\t\t */\n', '\t\t\taddValue(_property, _account, _value);\n', '\n', '\t\t\t/**\n', '\t\t\t * If released staking:\n', '\t\t\t */\n', '\t\t} else {\n', '\t\t\t/**\n', '\t\t\t * Updates the current staking amount of the protocol total.\n', '\t\t\t */\n', '\t\t\tsubAllValue(_value);\n', '\n', '\t\t\t/**\n', '\t\t\t * Updates the current staking amount of the Property.\n', '\t\t\t */\n', '\t\t\tsubPropertyValue(_property, _value);\n', '\n', '\t\t\t/**\n', '\t\t\t * Updates the current staking amount of the Property.\n', '\t\t\t */\n', '\t\t\tsubValue(_property, _account, _value);\n', '\t\t}\n', '\n', '\t\t/**\n', '\t\t * Since each staking amount has changed, updates the latest maximum mint amount.\n', '\t\t */\n', '\t\tupdate();\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the staking amount of the protocol total.\n', '\t */\n', '\tfunction getAllValue() external view returns (uint256) {\n', '\t\treturn getStorageAllValue();\n', '\t}\n', '\n', '\t/**\n', '\t * Adds the staking amount of the protocol total.\n', '\t */\n', '\tfunction addAllValue(uint256 _value) private {\n', '\t\tuint256 value = getStorageAllValue();\n', '\t\tvalue = value.add(_value);\n', '\t\tsetStorageAllValue(value);\n', '\t}\n', '\n', '\t/**\n', '\t * Subtracts the staking amount of the protocol total.\n', '\t */\n', '\tfunction subAllValue(uint256 _value) private {\n', '\t\tuint256 value = getStorageAllValue();\n', '\t\tvalue = value.sub(_value);\n', '\t\tsetStorageAllValue(value);\n', '\t}\n', '\n', '\t/**\n', "\t * Returns the user's staking amount in the Property.\n", '\t */\n', '\tfunction getValue(address _property, address _sender)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn getStorageValue(_property, _sender);\n', '\t}\n', '\n', '\t/**\n', "\t * Adds the user's staking amount in the Property.\n", '\t */\n', '\tfunction addValue(\n', '\t\taddress _property,\n', '\t\taddress _sender,\n', '\t\tuint256 _value\n', '\t) private {\n', '\t\tuint256 value = getStorageValue(_property, _sender);\n', '\t\tvalue = value.add(_value);\n', '\t\tsetStorageValue(_property, _sender, value);\n', '\t}\n', '\n', '\t/**\n', "\t * Subtracts the user's staking amount in the Property.\n", '\t */\n', '\tfunction subValue(\n', '\t\taddress _property,\n', '\t\taddress _sender,\n', '\t\tuint256 _value\n', '\t) private {\n', '\t\tuint256 value = getStorageValue(_property, _sender);\n', '\t\tvalue = value.sub(_value);\n', '\t\tsetStorageValue(_property, _sender, value);\n', '\t}\n', '\n', '\t/**\n', '\t * Returns whether the user is staking in the Property.\n', '\t */\n', '\tfunction hasValue(\n', '\t\taddress _property,\n', '\t\taddress _sender,\n', '\t\tuint256 _amount\n', '\t) private view returns (bool) {\n', '\t\tuint256 value = getStorageValue(_property, _sender);\n', '\t\treturn value >= _amount;\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the staking amount of the Property.\n', '\t */\n', '\tfunction getPropertyValue(address _property)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256)\n', '\t{\n', '\t\treturn getStoragePropertyValue(_property);\n', '\t}\n', '\n', '\t/**\n', '\t * Adds the staking amount of the Property.\n', '\t */\n', '\tfunction addPropertyValue(address _property, uint256 _value) private {\n', '\t\tuint256 value = getStoragePropertyValue(_property);\n', '\t\tvalue = value.add(_value);\n', '\t\tsetStoragePropertyValue(_property, value);\n', '\t}\n', '\n', '\t/**\n', '\t * Subtracts the staking amount of the Property.\n', '\t */\n', '\tfunction subPropertyValue(address _property, uint256 _value) private {\n', '\t\tuint256 value = getStoragePropertyValue(_property);\n', '\t\tuint256 nextValue = value.sub(_value);\n', '\t\tsetStoragePropertyValue(_property, nextValue);\n', '\t}\n', '\n', '\t/**\n', '\t * Saves the latest reward amount as an undrawn amount.\n', '\t */\n', '\tfunction updatePendingInterestWithdrawal(address _property, address _user)\n', '\t\tprivate\n', '\t\treturns (RewardPrices memory _prices)\n', '\t{\n', '\t\t/**\n', '\t\t * Gets the latest reward amount.\n', '\t\t */\n', '\t\t(uint256 withdrawableAmount, RewardPrices memory prices) =\n', '\t\t\t_calculateWithdrawableInterestAmount(_property, _user);\n', '\n', '\t\t/**\n', '\t\t * Saves the amount to `PendingInterestWithdrawal` storage.\n', '\t\t */\n', '\t\tsetStoragePendingInterestWithdrawal(\n', '\t\t\t_property,\n', '\t\t\t_user,\n', '\t\t\twithdrawableAmount\n', '\t\t);\n', '\n', '\t\t/**\n', '\t\t * Updates the reward amount of before DIP4 to prevent further addition it.\n', '\t\t */\n', '\t\t__updateLegacyWithdrawableInterestAmount(_property, _user);\n', '\n', '\t\treturn prices;\n', '\t}\n', '\n', '\t/**\n', '\t * Returns the reward amount of the calculation model before DIP4.\n', '\t * It can be calculated by subtracting "the last cumulative sum of reward unit price" from\n', '\t * "the current cumulative sum of reward unit price," and multiplying by the staking amount.\n', '\t */\n', '\tfunction __legacyWithdrawableInterestAmount(\n', '\t\taddress _property,\n', '\t\taddress _user\n', '\t) private view returns (uint256) {\n', '\t\tuint256 _last = getStorageLastInterestPrice(_property, _user);\n', '\t\tuint256 price = getStorageInterestPrice(_property);\n', '\t\tuint256 priceGap = price.sub(_last);\n', '\t\tuint256 lockedUpValue = getStorageValue(_property, _user);\n', '\t\tuint256 value = priceGap.mul(lockedUpValue);\n', '\t\treturn value.divBasis();\n', '\t}\n', '\n', '\t/**\n', '\t * Updates and treats the reward of before DIP4 as already received.\n', '\t */\n', '\tfunction __updateLegacyWithdrawableInterestAmount(\n', '\t\taddress _property,\n', '\t\taddress _user\n', '\t) private {\n', '\t\tuint256 interestPrice = getStorageInterestPrice(_property);\n', '\t\tif (getStorageLastInterestPrice(_property, _user) != interestPrice) {\n', '\t\t\tsetStorageLastInterestPrice(_property, _user, interestPrice);\n', '\t\t}\n', '\t}\n', '}']