['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-21\n', '*/\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'contract Ownable {\n', '\n', '\n', '  mapping (address=>bool) owners;\n', '\n', '  event AddOwner(address newOwner,string name);\n', '  event RemoveOwner(address owner);\n', '\n', '   constructor() public {\n', '    owners[msg.sender] = true;\n', '  }\n', '\n', '\n', '  modifier onlyOwners(){\n', '    require(owners[msg.sender] == true );\n', '    _;\n', '  }\n', '\n', '  function addOwner(address _newOwner,string memory newOwnerName) public onlyOwners{\n', '    require(owners[_newOwner] == false);\n', '    owners[_newOwner] = true;\n', '    emit AddOwner(_newOwner,newOwnerName);\n', '  }\n', '\n', '\n', '  function removeOwner(address _owner) public onlyOwners{\n', "    require(_owner != msg.sender);  // can't remove your self\n", '    owners[_owner] = false;\n', '    emit RemoveOwner(_owner);\n', '  }\n', '\n', '  function isOwner(address _owner) public view returns(bool){\n', '    return owners[_owner];\n', '  }\n', '\n', '}\n', '\n', ' contract ERC20 {\n', '\n', '  \t  function totalSupply() public view returns (uint256);\n', '      function balanceOf(address tokenOwner) public view returns (uint256 balance);\n', '      function allowance(address tokenOwner, address spender) public view returns (uint256 remaining);\n', '\n', '      function transfer(address to, uint256 tokens) public returns (bool success);\n', '       \n', '      function approve(address spender, uint256 tokens) public returns (bool success);\n', '      function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\n', '      function decimals() public view returns(uint256);\n', '      \n', '      function createKYCData(bytes32 _KycData1, bytes32 _kycData2,address  _wallet) public returns(uint256);\n', '\t  function haveKYC(address _addr) public view returns(bool);\n', '\t  function getKYCData(address _wallet) public view returns(bytes32 _data1,bytes32 _data2);\n', '\t  \n', '\t       // For WSZO only\n', '       function deposit(uint256 _amount) public;\n', '       function withdraw(uint256 _amount) public;\n', '       // SZO Only\n', '       function intTransfer(address _from, address _to, uint256 _value) external  returns(bool);\n', '\t  \n', ' }\n', '\n', '\n', 'contract POOLS{\n', '    function getMaxDepositContract(address _addr) public view returns(uint256 _max);\n', '    function getAllDepositIdx(address _addr) public view returns(uint256[] memory _idx);\n', '    function getDepositDataIdx(uint256 idx) public view returns(uint256[] memory _data);\n', '}\n', '\n', 'contract SZOCalcReward{\n', '    function getReward(uint256 _time,uint256 _amount) public view returns(uint256);\n', '}\n', '\n', 'contract SZORewardPools is Ownable{\n', '    \n', '    uint256 public version = 3;\n', '    mapping (address => uint256) public lastTimeClaim;\n', '    mapping (address => uint256) public poolsRewardIdx;\n', '    mapping (address => bool) public poolsRewardActive;\n', '    \n', '    address[] public pools; \n', '    \n', '    ERC20 szoToken;\n', '    ERC20 wszoToken;\n', '    \n', ' \n', '    bool  public  pauseReward;\n', '    address public newPools;\n', '\n', '    SZOCalcReward public calReward;\n', '    SZOCalcReward public SPReward;\n', '    \n', '    \n', '    constructor() public{\n', '        szoToken = ERC20(0x6086b52Cab4522b4B0E8aF9C3b2c5b8994C36ba6); \n', '        wszoToken = ERC20(0x5538Ac3ce36e73bB851921f2a804b4657b5307bf);\n', '\n', '        setPoolRewardAddr(0xE29659A35260B87264eBf1155dD03B7DE17d9B26); // DAI\n', '        setPoolRewardAddr(0x1C69D1829A5970d85bCe8dD4A4f7f568DB492c81); // USDT\n', '        setPoolRewardAddr(0x93347FFA6020a3904790220E84f38594F35bac7D); // USDC\n', '        \n', '        calReward = SZOCalcReward(0xCd02b50a0BEA9DE3f7dd2D898820842D2eC33D59); // call reward\n', '        SPReward = SZOCalcReward(0xdAD2b958A445d9e57dD86ff2dc57Ed0DEEf10671);  // 2x Reward\n', '        \n', '        szoToken.approve(0x5538Ac3ce36e73bB851921f2a804b4657b5307bf,30000000 ether);\n', '        \n', '\n', '    }\n', '    \n', '    function setRewardCal(address _addr) public onlyOwners{\n', '        calReward = SZOCalcReward(_addr);\n', '    }\n', '    \n', '    function setSPRewardCal(address _addr) public onlyOwners{\n', '        SPReward = SZOCalcReward(_addr);\n', '    }\n', '    \n', '    function addWSZO(uint256 _amount) public onlyOwners{\n', '         wszoToken.deposit(_amount);\n', '    }\n', '    \n', '    function removeWSZO(uint256 _amount) public onlyOwners{\n', '        wszoToken.withdraw(_amount);\n', '    }\n', '    \n', '    function setPauseReward() public onlyOwners{\n', '        pauseReward = true;\n', '    }\n', '    \n', '    function moveToNewRewardPools(address _newAddr) public onlyOwners{\n', '        require(pauseReward == true,"Please Pause before move to new pools");\n', '        \n', '        bytes32 _data1;\n', '        bytes32 _data2;\n', '        \n', '        (_data1,_data2) = szoToken.getKYCData(address(this));\n', '        \n', '        if(szoToken.haveKYC(_newAddr)  == false){\n', '          szoToken.createKYCData(_data1,_data2,_newAddr);    \n', '        }\n', '        \n', '        uint256 amount = szoToken.balanceOf(address(this));\n', '        newPools = _newAddr;\n', '        szoToken.transfer(_newAddr,amount);\n', '        amount = wszoToken.balanceOf(address(this));\n', '        wszoToken.transfer(_newAddr,amount);\n', '        \n', '    }\n', '    \n', '    \n', '    function setPoolRewardAddr(address _addr)public onlyOwners{\n', '            if(poolsRewardIdx[_addr] == 0){\n', '                uint256 idx = pools.push(_addr);\n', '                poolsRewardIdx[_addr] = idx;\n', '                poolsRewardActive[_addr] = true;\n', '            }    \n', '    }\n', '    \n', '    function setActivePools(address _addr,bool _act) public onlyOwners{\n', '        poolsRewardActive[_addr] =  _act;\n', '    }\n', '\n', '    \n', '    function getReward(address _contract,address _wallet) public view returns(uint256){\n', '        if(poolsRewardActive[_contract] == false) return 0;\n', '        \n', '        POOLS  pool = POOLS(_contract);\n', '        uint256 maxIdx = pool.getMaxDepositContract(_wallet);\n', '        uint256[] memory idxs = new uint256[](maxIdx);\n', '        idxs = pool.getAllDepositIdx(_wallet);\n', '        uint256 totalReward;\n', '        uint256 lastClaim = lastTimeClaim[_wallet];\n', '        uint256[] memory _data = new uint256[](2);\n', '        uint256 _reward;\n', '        \n', '        for(uint256 i=0;i<maxIdx;i++){\n', '            _data = pool.getDepositDataIdx(idxs[i]-1);\n', '            if(_data[0] > 0){\n', '                if(_data[1] > lastClaim){\n', '                    _reward =  calReward.getReward(now - _data[1],_data[0]); \n', '                }\n', '                else\n', '                {\n', '                    _reward =  calReward.getReward(now - lastClaim,_data[0]); \n', '                }\n', '                totalReward += _reward;\n', '            }\n', '        }\n', '        \n', '        return totalReward;\n', '    }\n', '    \n', '    \n', '    function getRewardSP(address _contract,address _wallet) public view returns(uint256){\n', '        if(poolsRewardActive[_contract] == false) return 0;\n', '        \n', '        POOLS  pool = POOLS(_contract);\n', '        uint256 maxIdx = pool.getMaxDepositContract(_wallet);\n', '        uint256[] memory idxs = new uint256[](maxIdx);\n', '        idxs = pool.getAllDepositIdx(_wallet);\n', '        uint256 totalReward;\n', '        uint256[] memory _data = new uint256[](2);\n', '        uint256 _reward;\n', '        \n', '        uint256 lastClaim = lastTimeClaim[_wallet];\n', '        \n', '        \n', '        for(uint256 i=0;i<maxIdx;i++){\n', '            _data = pool.getDepositDataIdx(idxs[i]-1);\n', '            if(_data[0] > 0){\n', '                if(_data[1] > lastClaim )\n', '                    _reward =  SPReward.getReward(_data[1],_data[0]); \n', '                else\n', '                    _reward =  SPReward.getReward(lastClaim,_data[0]); \n', '                totalReward += _reward;\n', '            }\n', '        }\n', '        \n', '        return totalReward;\n', '    }\n', '    \n', '    function summarySZOReward(address _addr) public view returns(uint256 sumBalance,uint256[] memory _pool,uint256[] memory _poolSP){\n', '         _pool = new uint256[](pools.length);\n', '         _poolSP = new uint256[](pools.length);\n', '         \n', '         for(uint256 i=0;i<pools.length;i++){\n', '                _pool[i] = getReward(pools[i],_addr);\n', '                _poolSP[i] = getRewardSP(pools[i],_addr);\n', '                 sumBalance += _pool[i] + _poolSP[i];\n', '             }\n', '    }\n', '     \n', '\n', '    function claimWSZOReward(address _wallet) public returns(uint256 _claim){\n', '        require(msg.sender == _wallet || owners[msg.sender] == true,"No permission to claim reward");\n', '        require(pauseReward == false,"REWARD PAUSE TO CLAIM");\n', '        \n', '        (_claim,,) = summarySZOReward(_wallet);\n', '        lastTimeClaim[_wallet] = now;\n', '        if(_claim > wszoToken.balanceOf(address(this))) _claim = wszoToken.balanceOf(address(this));\n', '        \n', '        wszoToken.transfer(_wallet,_claim);\n', '    }\n', '    \n', '    function claimReward(address _wallet) public  returns(uint256 _claim){\n', '        require(msg.sender == _wallet || owners[msg.sender] == true,"No permission to claim reward");\n', '        require(pauseReward == false,"REWARD PAUSE TO CLAIM");\n', '        \n', '        (_claim,,) = summarySZOReward(_wallet);\n', '        lastTimeClaim[_wallet] = now;\n', '\n', '        if(_claim > szoToken.balanceOf(address(this))) _claim = szoToken.balanceOf(address(this));\n', '\n', '        szoToken.transfer(_wallet,_claim);\n', '       \n', '        return _claim;\n', '    }\n', '}']