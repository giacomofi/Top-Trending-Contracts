['pragma solidity =0.5.17;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./CarefulMath.sol";\n', '\n', 'import "./ISablier.sol";\n', 'import "./Types.sol";\n', '\n', '/**\n', ' * @title Sablier\n', ' * @author Sablier\n', ' * @notice Money streaming.\n', ' */\n', 'contract Sablier is ISablier, ReentrancyGuard, CarefulMath {\n', '    using SafeERC20 for IERC20;\n', '\n', '    /*** Storage Properties ***/\n', '\n', '    /**\n', '     * @notice Counter for new stream ids.\n', '     */\n', '    uint256 public nextStreamId;\n', '\n', '    /**\n', '     * @notice The stream objects identifiable by their unsigned integer ids.\n', '     */\n', '    mapping(uint256 => Types.Stream) private streams;\n', '\n', '    /*** Modifiers ***/\n', '\n', '    /**\n', '     * @dev Throws if the caller is not the sender of the recipient of the stream.\n', '     */\n', '    modifier onlySenderOrRecipient(uint256 streamId) {\n', '        require(\n', '            msg.sender == streams[streamId].sender || msg.sender == streams[streamId].recipient,\n', '            "caller is not the sender or the recipient of the stream"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if the provided id does not point to a valid stream.\n', '     */\n', '    modifier streamExists(uint256 streamId) {\n', '        require(streams[streamId].isEntity, "stream does not exist");\n', '        _;\n', '    }\n', '\n', '    /*** Contract Logic Starts Here */\n', '\n', '    constructor() public {\n', '        nextStreamId = 100000;\n', '    }\n', '\n', '    /*** View Functions ***/\n', '\n', '    /**\n', '     * @notice Returns the stream with all its properties.\n', '     * @dev Throws if the id does not point to a valid stream.\n', '     * @param streamId The id of the stream to query.\n', '     * @return The stream object.\n', '     */\n', '    function getStream(uint256 streamId)\n', '        external\n', '        view\n', '        streamExists(streamId)\n', '        returns (\n', '            address sender,\n', '            address recipient,\n', '            uint256 deposit,\n', '            address tokenAddress,\n', '            uint256 startTime,\n', '            uint256 stopTime,\n', '            uint256 remainingBalance,\n', '            uint256 ratePerSecond\n', '        )\n', '    {\n', '        sender = streams[streamId].sender;\n', '        recipient = streams[streamId].recipient;\n', '        deposit = streams[streamId].deposit;\n', '        tokenAddress = streams[streamId].tokenAddress;\n', '        startTime = streams[streamId].startTime;\n', '        stopTime = streams[streamId].stopTime;\n', '        remainingBalance = streams[streamId].remainingBalance;\n', '        ratePerSecond = streams[streamId].ratePerSecond;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns either the delta in seconds between `block.timestamp` and `startTime` or\n', '     *  between `stopTime` and `startTime, whichever is smaller. If `block.timestamp` is before\n', '     *  `startTime`, it returns 0.\n', '     * @dev Throws if the id does not point to a valid stream.\n', '     * @param streamId The id of the stream for which to query the delta.\n', '     * @return The time delta in seconds.\n', '     */\n', '    function deltaOf(uint256 streamId) public view streamExists(streamId) returns (uint256 delta) {\n', '        Types.Stream memory stream = streams[streamId];\n', '        if (block.timestamp <= stream.startTime) return 0;\n', '        if (block.timestamp < stream.stopTime) return block.timestamp - stream.startTime;\n', '        return stream.stopTime - stream.startTime;\n', '    }\n', '\n', '    struct BalanceOfLocalVars {\n', '        MathError mathErr;\n', '        uint256 recipientBalance;\n', '        uint256 withdrawalAmount;\n', '        uint256 senderBalance;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the available funds for the given stream id and address.\n', '     * @dev Throws if the id does not point to a valid stream.\n', '     * @param streamId The id of the stream for which to query the balance.\n', '     * @param who The address for which to query the balance.\n', '     * @return The total funds allocated to `who` as uint256.\n', '     */\n', '    function balanceOf(uint256 streamId, address who) public view streamExists(streamId) returns (uint256 balance) {\n', '        Types.Stream memory stream = streams[streamId];\n', '        BalanceOfLocalVars memory vars;\n', '\n', '        uint256 delta = deltaOf(streamId);\n', '        (vars.mathErr, vars.recipientBalance) = mulUInt(delta, stream.ratePerSecond);\n', '        require(vars.mathErr == MathError.NO_ERROR, "recipient balance calculation error");\n', '\n', '        /*\n', '         * If the stream `balance` does not equal `deposit`, it means there have been withdrawals.\n', '         * We have to subtract the total amount withdrawn from the amount of money that has been\n', '         * streamed until now.\n', '         */\n', '        if (stream.deposit > stream.remainingBalance) {\n', '            (vars.mathErr, vars.withdrawalAmount) = subUInt(stream.deposit, stream.remainingBalance);\n', '            assert(vars.mathErr == MathError.NO_ERROR);\n', '            (vars.mathErr, vars.recipientBalance) = subUInt(vars.recipientBalance, vars.withdrawalAmount);\n', '            /* `withdrawalAmount` cannot and should not be bigger than `recipientBalance`. */\n', '            assert(vars.mathErr == MathError.NO_ERROR);\n', '        }\n', '\n', '        if (who == stream.recipient) return vars.recipientBalance;\n', '        if (who == stream.sender) {\n', '            (vars.mathErr, vars.senderBalance) = subUInt(stream.remainingBalance, vars.recipientBalance);\n', '            /* `recipientBalance` cannot and should not be bigger than `remainingBalance`. */\n', '            assert(vars.mathErr == MathError.NO_ERROR);\n', '            return vars.senderBalance;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /*** Public Effects & Interactions Functions ***/\n', '\n', '    struct CreateStreamLocalVars {\n', '        MathError mathErr;\n', '        uint256 duration;\n', '        uint256 ratePerSecond;\n', '    }\n', '\n', '    /**\n', '     * @notice Creates a new stream funded by `msg.sender` and paid towards `recipient`.\n', '     * @dev Throws if the recipient is the zero address, the contract itself or the caller.\n', '     *  Throws if the deposit is 0.\n', '     *  Throws if the start time is before `block.timestamp`.\n', '     *  Throws if the stop time is before the start time.\n', '     *  Throws if the duration calculation has a math error.\n', '     *  Throws if the deposit is smaller than the duration.\n', '     *  Throws if the deposit is not a multiple of the duration.\n', '     *  Throws if the rate calculation has a math error.\n', '     *  Throws if the next stream id calculation has a math error.\n', '     *  Throws if the contract is not allowed to transfer enough tokens.\n', '     *  Throws if there is a token transfer failure.\n', '     * @param recipient The address towards which the money is streamed.\n', '     * @param deposit The amount of money to be streamed.\n', '     * @param tokenAddress The ERC20 token to use as streaming currency.\n', '     * @param startTime The unix timestamp for when the stream starts.\n', '     * @param stopTime The unix timestamp for when the stream stops.\n', '     * @return The uint256 id of the newly created stream.\n', '     */\n', '    function createStream(address recipient, uint256 deposit, address tokenAddress, uint256 startTime, uint256 stopTime)\n', '        public\n', '        returns (uint256)\n', '    {\n', '        require(recipient != address(0x00), "stream to the zero address");\n', '        require(recipient != address(this), "stream to the contract itself");\n', '        require(recipient != msg.sender, "stream to the caller");\n', '        require(deposit > 0, "deposit is zero");\n', '        require(startTime >= block.timestamp, "start time before block.timestamp");\n', '        require(stopTime > startTime, "stop time before the start time");\n', '\n', '        CreateStreamLocalVars memory vars;\n', '        (vars.mathErr, vars.duration) = subUInt(stopTime, startTime);\n', '        /* `subUInt` can only return MathError.INTEGER_UNDERFLOW but we know `stopTime` is higher than `startTime`. */\n', '        assert(vars.mathErr == MathError.NO_ERROR);\n', '\n', '        /* Without this, the rate per second would be zero. */\n', '        require(deposit >= vars.duration, "deposit smaller than time delta");\n', '\n', '        /* This condition avoids dealing with remainders */\n', '        require(deposit % vars.duration == 0, "deposit not multiple of time delta");\n', '\n', '        (vars.mathErr, vars.ratePerSecond) = divUInt(deposit, vars.duration);\n', '        /* `divUInt` can only return MathError.DIVISION_BY_ZERO but we know `duration` is not zero. */\n', '        assert(vars.mathErr == MathError.NO_ERROR);\n', '\n', '        /* Create and store the stream object. */\n', '        uint256 streamId = nextStreamId;\n', '        streams[streamId] = Types.Stream({\n', '            remainingBalance: deposit,\n', '            deposit: deposit,\n', '            isEntity: true,\n', '            ratePerSecond: vars.ratePerSecond,\n', '            recipient: recipient,\n', '            sender: msg.sender,\n', '            startTime: startTime,\n', '            stopTime: stopTime,\n', '            tokenAddress: tokenAddress\n', '        });\n', '\n', '        /* Increment the next stream id. */\n', '        (vars.mathErr, nextStreamId) = addUInt(nextStreamId, uint256(1));\n', '        require(vars.mathErr == MathError.NO_ERROR, "next stream id calculation error");\n', '\n', '        IERC20(tokenAddress).safeTransferFrom(msg.sender, address(this), deposit);\n', '        emit CreateStream(streamId, msg.sender, recipient, deposit, tokenAddress, startTime, stopTime);\n', '        return streamId;\n', '    }\n', '\n', '    /**\n', "     * @notice Withdraws from the contract to the recipient's account.\n", '     * @dev Throws if the id does not point to a valid stream.\n', '     *  Throws if the caller is not the sender or the recipient of the stream.\n', '     *  Throws if the amount exceeds the available balance.\n', '     *  Throws if there is a token transfer failure.\n', '     * @param streamId The id of the stream to withdraw tokens from.\n', '     * @param amount The amount of tokens to withdraw.\n', '     */\n', '    function withdrawFromStream(uint256 streamId, uint256 amount)\n', '        external\n', '        nonReentrant\n', '        streamExists(streamId)\n', '        onlySenderOrRecipient(streamId)\n', '        returns (bool)\n', '    {\n', '        require(amount > 0, "amount is zero");\n', '        Types.Stream memory stream = streams[streamId];\n', '\n', '        uint256 balance = balanceOf(streamId, stream.recipient);\n', '        require(balance >= amount, "amount exceeds the available balance");\n', '\n', '        MathError mathErr;\n', '        (mathErr, streams[streamId].remainingBalance) = subUInt(stream.remainingBalance, amount);\n', '        /**\n', '         * `subUInt` can only return MathError.INTEGER_UNDERFLOW but we know that `remainingBalance` is at least\n', '         * as big as `amount`.\n', '         */\n', '        assert(mathErr == MathError.NO_ERROR);\n', '\n', '        if (streams[streamId].remainingBalance == 0) delete streams[streamId];\n', '\n', '        IERC20(stream.tokenAddress).safeTransfer(stream.recipient, amount);\n', '        emit WithdrawFromStream(streamId, stream.recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Cancels the stream and transfers the tokens back on a pro rata basis.\n', '     * @dev Throws if the id does not point to a valid stream.\n', '     *  Throws if the caller is not the sender or the recipient of the stream.\n', '     *  Throws if there is a token transfer failure.\n', '     * @param streamId The id of the stream to cancel.\n', '     * @return bool true=success, otherwise false.\n', '     */\n', '    function cancelStream(uint256 streamId)\n', '        external\n', '        nonReentrant\n', '        streamExists(streamId)\n', '        onlySenderOrRecipient(streamId)\n', '        returns (bool)\n', '    {\n', '        Types.Stream memory stream = streams[streamId];\n', '        uint256 senderBalance = balanceOf(streamId, stream.sender);\n', '        uint256 recipientBalance = balanceOf(streamId, stream.recipient);\n', '\n', '        delete streams[streamId];\n', '\n', '        IERC20 token = IERC20(stream.tokenAddress);\n', '        if (recipientBalance > 0) token.safeTransfer(stream.recipient, recipientBalance);\n', '        if (senderBalance > 0) token.safeTransfer(stream.sender, senderBalance);\n', '\n', '        emit CancelStream(streamId, stream.sender, stream.recipient, senderBalance, recipientBalance);\n', '        return true;\n', '    }\n', '}']