['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./StrongPoolInterface.sol";\n', '\n', 'contract ServiceV9 {\n', '  event Requested(address indexed miner);\n', '  event Claimed(address indexed miner, uint256 reward);\n', '\n', '  using SafeMath for uint256;\n', '  bool public initDone;\n', '  address public admin;\n', '  address public pendingAdmin;\n', '  address public superAdmin;\n', '  address public pendingSuperAdmin;\n', '  address public serviceAdmin;\n', '  address public parameterAdmin;\n', '  address payable public feeCollector;\n', '\n', '  IERC20 public strongToken;\n', '  StrongPoolInterface public strongPool;\n', '\n', '  uint256 public rewardPerBlockNumerator;\n', '  uint256 public rewardPerBlockDenominator;\n', '\n', '  uint256 public naasRewardPerBlockNumerator;\n', '  uint256 public naasRewardPerBlockDenominator;\n', '\n', '  uint256 public claimingFeeNumerator;\n', '  uint256 public claimingFeeDenominator;\n', '\n', '  uint256 public requestingFeeInWei;\n', '\n', '  uint256 public strongFeeInWei;\n', '\n', '  uint256 public recurringFeeInWei;\n', '  uint256 public recurringNaaSFeeInWei;\n', '  uint256 public recurringPaymentCycleInBlocks;\n', '\n', '  uint256 public rewardBalance;\n', '\n', '  mapping(address => uint256) public entityBlockLastClaimedOn;\n', '\n', '  address[] public entities;\n', '  mapping(address => uint256) public entityIndex;\n', '  mapping(address => bool) public entityActive;\n', '  mapping(address => bool) public requestPending;\n', '  mapping(address => bool) public entityIsNaaS;\n', '  mapping(address => uint256) public paidOnBlock;\n', '  uint256 public activeEntities;\n', '\n', '  string public desciption;\n', '\n', '  uint256 public claimingFeeInWei;\n', '\n', '  uint256 public naasRequestingFeeInWei;\n', '\n', '  uint256 public naasStrongFeeInWei;\n', '\n', '  bool public removedTokens;\n', '\n', '  mapping(address => uint256) public traunch;\n', '\n', '  uint256 public currentTraunch;\n', '\n', '  mapping(bytes => bool) public entityNodeIsActive;\n', '  mapping(bytes => bool) public entityNodeIsBYON;\n', '  mapping(bytes => uint256) public entityNodeTraunch;\n', '  mapping(bytes => uint256) public entityNodePaidOnBlock;\n', '  mapping(bytes => uint256) public entityNodeClaimedOnBlock;\n', '  mapping(address => uint128) public entityNodeCount;\n', '\n', '  event Paid(address indexed entity, uint128 nodeId, bool isBYON, bool isRenewal, uint256 upToBlockNumber);\n', '  event Migrated(address indexed from, address indexed to, uint128 fromNodeId, uint128 toNodeId, bool isBYON);\n', '\n', '  function init(\n', '    address strongTokenAddress,\n', '    address strongPoolAddress,\n', '    address adminAddress,\n', '    address superAdminAddress,\n', '    uint256 rewardPerBlockNumeratorValue,\n', '    uint256 rewardPerBlockDenominatorValue,\n', '    uint256 naasRewardPerBlockNumeratorValue,\n', '    uint256 naasRewardPerBlockDenominatorValue,\n', '    uint256 requestingFeeInWeiValue,\n', '    uint256 strongFeeInWeiValue,\n', '    uint256 recurringFeeInWeiValue,\n', '    uint256 recurringNaaSFeeInWeiValue,\n', '    uint256 recurringPaymentCycleInBlocksValue,\n', '    uint256 claimingFeeNumeratorValue,\n', '    uint256 claimingFeeDenominatorValue,\n', '    string memory desc\n', '  ) public {\n', "    require(!initDone, 'init done');\n", '    strongToken = IERC20(strongTokenAddress);\n', '    strongPool = StrongPoolInterface(strongPoolAddress);\n', '    admin = adminAddress;\n', '    superAdmin = superAdminAddress;\n', '    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\n', '    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\n', '    naasRewardPerBlockNumerator = naasRewardPerBlockNumeratorValue;\n', '    naasRewardPerBlockDenominator = naasRewardPerBlockDenominatorValue;\n', '    requestingFeeInWei = requestingFeeInWeiValue;\n', '    strongFeeInWei = strongFeeInWeiValue;\n', '    recurringFeeInWei = recurringFeeInWeiValue;\n', '    recurringNaaSFeeInWei = recurringNaaSFeeInWeiValue;\n', '    claimingFeeNumerator = claimingFeeNumeratorValue;\n', '    claimingFeeDenominator = claimingFeeDenominatorValue;\n', '    recurringPaymentCycleInBlocks = recurringPaymentCycleInBlocksValue;\n', '    desciption = desc;\n', '    initDone = true;\n', '  }\n', '\n', '  // ADMIN\n', '  // *************************************************************************************\n', '\n', '  function updateServiceAdmin(address newServiceAdmin) public {\n', '    require(msg.sender == superAdmin);\n', '    serviceAdmin = newServiceAdmin;\n', '  }\n', '\n', '  function updateParameterAdmin(address newParameterAdmin) public {\n', "    require(newParameterAdmin != address(0), 'zero');\n", '    require(msg.sender == superAdmin);\n', '    parameterAdmin = newParameterAdmin;\n', '  }\n', '\n', '  function updateFeeCollector(address payable newFeeCollector) public {\n', "    require(newFeeCollector != address(0), 'zero');\n", '    require(msg.sender == superAdmin);\n', '    feeCollector = newFeeCollector;\n', '  }\n', '\n', '  function setPendingAdmin(address newPendingAdmin) public {\n', "    require(msg.sender == admin, 'not admin');\n", '    pendingAdmin = newPendingAdmin;\n', '  }\n', '\n', '  function acceptAdmin() public {\n', "    require(msg.sender == pendingAdmin && msg.sender != address(0), 'not pendingAdmin');\n", '    admin = pendingAdmin;\n', '    pendingAdmin = address(0);\n', '  }\n', '\n', '  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\n', "    require(msg.sender == superAdmin, 'not superAdmin');\n", '    pendingSuperAdmin = newPendingSuperAdmin;\n', '  }\n', '\n', '  function acceptSuperAdmin() public {\n', "    require(msg.sender == pendingSuperAdmin && msg.sender != address(0), 'not pendingSuperAdmin');\n", '    superAdmin = pendingSuperAdmin;\n', '    pendingSuperAdmin = address(0);\n', '  }\n', '\n', '  // ENTITIES\n', '  // *************************************************************************************\n', '\n', '  function getEntities() public view returns (address[] memory) {\n', '    return entities;\n', '  }\n', '\n', '  function isEntityActive(address entity) public view returns (bool) {\n', '    return entityActive[entity];\n', '  }\n', '\n', '  // TRAUNCH\n', '  // *************************************************************************************\n', '\n', '  function updateCurrentTraunch(uint256 value) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", '    currentTraunch = value;\n', '  }\n', '\n', '  function getTraunch(address entity) public view returns (uint256) {\n', '    return traunch[entity];\n', '  }\n', '\n', '  // REWARD\n', '  // *************************************************************************************\n', '\n', '  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", "    require(denominator != 0, 'invalid value');\n", '    rewardPerBlockNumerator = numerator;\n', '    rewardPerBlockDenominator = denominator;\n', '  }\n', '\n', '  function updateNaaSRewardPerBlock(uint256 numerator, uint256 denominator) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", "    require(denominator != 0, 'invalid value');\n", '    naasRewardPerBlockNumerator = numerator;\n', '    naasRewardPerBlockDenominator = denominator;\n', '  }\n', '\n', '  function deposit(uint256 amount) public {\n', "    require(msg.sender == superAdmin, 'not an admin');\n", "    require(amount > 0, 'zero');\n", '    strongToken.transferFrom(msg.sender, address(this), amount);\n', '    rewardBalance = rewardBalance.add(amount);\n', '  }\n', '\n', '  function withdraw(address destination, uint256 amount) public {\n', "    require(msg.sender == superAdmin, 'not an admin');\n", "    require(amount > 0, 'zero');\n", "    require(rewardBalance >= amount, 'not enough');\n", '    strongToken.transfer(destination, amount);\n', '    rewardBalance = rewardBalance.sub(amount);\n', '  }\n', '\n', '  function removeTokens() public {\n', "    require(!removedTokens, 'already removed');\n", "    require(msg.sender == superAdmin, 'not an admin');\n", '    // removing 2500 STRONG tokens sent in this tx: 0xe27640beda32a5e49aad3b6692790b9d380ed25da0cf8dca7fd5f3258efa600a\n', '    strongToken.transfer(superAdmin, 2500000000000000000000);\n', '    removedTokens = true;\n', '  }\n', '\n', '  // FEES\n', '  // *************************************************************************************\n', '\n', '  function updateRequestingFee(uint256 feeInWei) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", '    requestingFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateStrongFee(uint256 feeInWei) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", '    strongFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateNaasRequestingFee(uint256 feeInWei) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", '    naasRequestingFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateNaasStrongFee(uint256 feeInWei) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", '    naasStrongFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", "    require(denominator != 0, 'invalid value');\n", '    claimingFeeNumerator = numerator;\n', '    claimingFeeDenominator = denominator;\n', '  }\n', '\n', '  function updateRecurringFee(uint256 feeInWei) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", '    recurringFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateRecurringNaaSFee(uint256 feeInWei) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", '    recurringNaaSFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateRecurringPaymentCycleInBlocks(uint256 blocks) public {\n', "    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin, 'not an admin');\n", "    require(blocks > 0, 'zero');\n", '    recurringPaymentCycleInBlocks = blocks;\n', '  }\n', '\n', '  // CORE\n', '  // *************************************************************************************\n', '\n', '  function requestAccess(bool isNaaS) public payable {\n', '    uint256 rFee;\n', '    uint256 sFee;\n', '\n', '    if (hasLegacyNode(msg.sender)) {\n', '      migrateLegacyNode(msg.sender);\n', '    }\n', '\n', '    uint128 nodeId = entityNodeCount[msg.sender] + 1;\n', '    bytes memory id = getNodeId(msg.sender, nodeId);\n', '\n', '    if (isNaaS) {\n', '      rFee = naasRequestingFeeInWei;\n', '      sFee = naasStrongFeeInWei;\n', '      activeEntities = activeEntities.add(1);\n', '    } else {\n', '      rFee = requestingFeeInWei;\n', '      sFee = strongFeeInWei;\n', '      entityNodeIsBYON[id] = true;\n', '    }\n', '\n', "    require(msg.value == rFee, 'invalid fee');\n", '\n', '    entityNodePaidOnBlock[id] = block.number;\n', '    entityNodeTraunch[id] = currentTraunch;\n', '    entityNodeClaimedOnBlock[id] = block.number;\n', '    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\n', '\n', '    feeCollector.transfer(msg.value);\n', '    strongToken.transferFrom(msg.sender, address(this), sFee);\n', '    strongToken.transfer(feeCollector, sFee);\n', '\n', '    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], false, entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks));\n', '  }\n', '\n', '  function setEntityActiveStatus(address entity, bool status) public {\n', "    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, 'not admin');\n", '    uint256 index = entityIndex[entity];\n', "    require(entities[index] == entity, 'invalid entity');\n", "    require(entityActive[entity] != status, 'already set');\n", '    entityActive[entity] = status;\n', '    if (status) {\n', '      activeEntities = activeEntities.add(1);\n', '      entityBlockLastClaimedOn[entity] = block.number;\n', '    } else {\n', '      activeEntities = activeEntities.sub(1);\n', '      entityBlockLastClaimedOn[entity] = 0;\n', '    }\n', '  }\n', '\n', '  function setTraunch(address entity, uint256 value) public {\n', "    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, 'not admin');\n", '\n', '    traunch[entity] = value;\n', '  }\n', '\n', '  function payFee(uint128 nodeId) public payable {\n', '    bytes memory id = getNodeId(msg.sender, nodeId);\n', '\n', '    if (hasLegacyNode(msg.sender)) {\n', '      migrateLegacyNode(msg.sender);\n', '    }\n', '\n', "    require(doesNodeExist(msg.sender, nodeId), 'doesnt exist');\n", '\n', '    if (entityNodeIsBYON[id]) {\n', "      require(msg.value == recurringFeeInWei, 'invalid fee');\n", '    } else {\n', "      require(msg.value == recurringNaaSFeeInWei, 'invalid fee');\n", '    }\n', '\n', '    feeCollector.transfer(msg.value);\n', '    entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\n', '\n', '    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\n', '  }\n', '\n', '  function getReward(address entity, uint128 nodeId) public view returns (uint256) {\n', '    return getRewardByBlock(entity, nodeId, block.number);\n', '  }\n', '\n', '  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) public view returns (uint256) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '\n', '    if (hasLegacyNode(entity)) {\n', '      return getRewardByBlockLegacy(entity, blockNumber);\n', '    }\n', '\n', '    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\n', '\n', '    if (blockNumber > block.number) return 0;\n', '    if (blockLastClaimedOn == 0) return 0;\n', '    if (blockNumber < blockLastClaimedOn) return 0;\n', '    if (activeEntities == 0) return 0;\n', '    if (entityNodeIsBYON[id] && !entityNodeIsActive[id]) return 0;\n', '\n', '    uint256 blockResult = blockNumber.sub(blockLastClaimedOn);\n', '    uint256 rewardNumerator;\n', '    uint256 rewardDenominator;\n', '\n', '    if (entityNodeIsBYON[id]) {\n', '      rewardNumerator = rewardPerBlockNumerator;\n', '      rewardDenominator = rewardPerBlockDenominator;\n', '    } else {\n', '      rewardNumerator = naasRewardPerBlockNumerator;\n', '      rewardDenominator = naasRewardPerBlockDenominator;\n', '    }\n', '\n', '    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\n', '\n', '    return rewardPerBlockResult.div(activeEntities);\n', '  }\n', '\n', '  function getRewardByBlockLegacy(address entity, uint256 blockNumber) public view returns (uint256) {\n', '    if (blockNumber > block.number) return 0;\n', '    if (entityBlockLastClaimedOn[entity] == 0) return 0;\n', '    if (blockNumber < entityBlockLastClaimedOn[entity]) return 0;\n', '    if (activeEntities == 0) return 0;\n', '    uint256 blockResult = blockNumber.sub(entityBlockLastClaimedOn[entity]);\n', '    uint256 rewardNumerator;\n', '    uint256 rewardDenominator;\n', '    if (entityIsNaaS[entity]) {\n', '      rewardNumerator = naasRewardPerBlockNumerator;\n', '      rewardDenominator = naasRewardPerBlockDenominator;\n', '    } else {\n', '      rewardNumerator = rewardPerBlockNumerator;\n', '      rewardDenominator = rewardPerBlockDenominator;\n', '    }\n', '    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\n', '\n', '    return rewardPerBlockResult.div(activeEntities);\n', '  }\n', '\n', '  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) public payable {\n', '    bytes memory id = getNodeId(msg.sender, nodeId);\n', '\n', '    if (hasLegacyNode(msg.sender)) {\n', '      migrateLegacyNode(msg.sender);\n', '    }\n', '\n', '    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\n', '    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\n', '\n', "    require(blockLastClaimedOn != 0, 'never claimed');\n", "    require(blockNumber <= block.number, 'invalid block');\n", "    require(blockNumber > blockLastClaimedOn, 'too soon');\n", "    require(!entityNodeIsBYON[id] || entityNodeIsActive[id], 'not active');\n", '\n', '    if (\n', '      (!entityNodeIsBYON[id] && recurringNaaSFeeInWei != 0) || (entityNodeIsBYON[id] && recurringFeeInWei != 0)\n', '    ) {\n', "      require(blockNumber < blockLastPaidOn.add(recurringPaymentCycleInBlocks), 'pay fee');\n", '    }\n', '\n', '    uint256 reward = getRewardByBlock(msg.sender, nodeId, blockNumber);\n', "    require(reward > 0, 'no reward');\n", '\n', '    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\n', "    require(msg.value == fee, 'invalid fee');\n", '\n', '    feeCollector.transfer(msg.value);\n', '\n', '    if (toStrongPool) {\n', '      strongToken.approve(address(strongPool), reward);\n', '      strongPool.mineFor(msg.sender, reward);\n', '    } else {\n', '      strongToken.transfer(msg.sender, reward);\n', '    }\n', '\n', '    rewardBalance = rewardBalance.sub(reward);\n', '    entityNodeClaimedOnBlock[id] = blockNumber;\n', '    emit Claimed(msg.sender, reward);\n', '  }\n', '\n', '  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\n', '    uint256 rewardsAll = 0;\n', '\n', '    for (uint128 i = 1; i <= entityNodeCount[entity]; i++) {\n', '      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber > 0 ? blockNumber : block.number));\n', '    }\n', '\n', '    return rewardsAll;\n', '  }\n', '\n', '  function doesNodeExist(address entity, uint128 nodeId) public view returns (bool) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodePaidOnBlock[id] > 0;\n', '  }\n', '\n', '  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\n', '    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\n', '    return abi.encodePacked(entity, id);\n', '  }\n', '\n', '  function getNodePaidOn(address entity, uint128 nodeId) public view returns (uint256) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodePaidOnBlock[id];\n', '  }\n', '\n', '  function getNodeFee(address entity, uint128 nodeId) public view returns (uint256) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\n', '  }\n', '\n', '  function isNodeActive(address entity, uint128 nodeId) public view returns (bool) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodeIsActive[id] || !entityNodeIsBYON[id];\n', '  }\n', '\n', '  function isNodeBYON(address entity, uint128 nodeId) public view returns (bool) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodeIsBYON[id];\n', '  }\n', '\n', '  function hasLegacyNode(address entity) public view returns (bool) {\n', '    return entityActive[entity] && entityNodeCount[entity] == 0;\n', '  }\n', '\n', '  function approveBYONNode(address entity, uint128 nodeId) public {\n', "    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, 'not admin');\n", '\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    entityNodeIsActive[id] = true;\n', '    entityNodeClaimedOnBlock[id] = block.number;\n', '    activeEntities = activeEntities.add(1);\n', '  }\n', '\n', '  function suspendBYONNode(address entity, uint128 nodeId) public {\n', "    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, 'not admin');\n", '\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    entityNodeIsActive[id] = false;\n', '    activeEntities = activeEntities.sub(1);\n', '  }\n', '\n', '  function setNodeIsActive(address entity, uint128 nodeId, bool isActive) public {\n', "    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, 'not admin');\n", '    bytes memory id = getNodeId(entity, nodeId);\n', '\n', '    if (isActive && !entityNodeIsActive[id]) {\n', '      activeEntities = activeEntities.add(1);\n', '      entityNodeClaimedOnBlock[id] = block.number;\n', '    }\n', '\n', '    if (!isActive && entityNodeIsActive[id]) {\n', '      activeEntities = activeEntities.sub(1);\n', '    }\n', '\n', '    entityNodeIsActive[id] = isActive;\n', '  }\n', '\n', '  function setNodeIsNaaS(address entity, uint128 nodeId, bool isNaaS) public {\n', "    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin, 'not admin');\n", '    bytes memory id = getNodeId(entity, nodeId);\n', '\n', '    entityNodeIsBYON[id] = !isNaaS;\n', '  }\n', '\n', '  function migrateLegacyNode(address entity) private {\n', '    bytes memory id = getNodeId(entity, 1);\n', '    entityNodeClaimedOnBlock[id] = entityBlockLastClaimedOn[entity];\n', '    entityNodePaidOnBlock[id] = paidOnBlock[entity];\n', '    entityNodeTraunch[id] = traunch[entity];\n', '    entityNodeIsBYON[id] = !entityIsNaaS[entity];\n', '    if (entityNodeIsBYON[id]) {\n', '      entityNodeIsActive[id] = true;\n', '    }\n', '    entityNodeCount[msg.sender] = 1;\n', '  }\n', '\n', '  function migrateNode(uint128 nodeId, address to) public {\n', '    if (hasLegacyNode(msg.sender)) {\n', '      migrateLegacyNode(msg.sender);\n', '    }\n', '\n', "    require(doesNodeExist(msg.sender, nodeId), 'doesnt exist');\n", '\n', '    uint128 toNodeId = entityNodeCount[to] + 1;\n', '    bytes memory fromId = getNodeId(msg.sender, nodeId);\n', '    bytes memory toId = getNodeId(to, toNodeId);\n', '\n', '    // move node to another address\n', '    entityNodeIsActive[toId] = entityNodeIsActive[fromId];\n', '    entityNodeIsBYON[toId] = entityNodeIsBYON[fromId];\n', '    entityNodePaidOnBlock[toId] = entityNodePaidOnBlock[fromId];\n', '    entityNodeClaimedOnBlock[toId] = entityNodeClaimedOnBlock[fromId];\n', '    entityNodeTraunch[toId] = entityNodeTraunch[fromId];\n', '    entityNodeCount[to] = entityNodeCount[to] + 1;\n', '\n', '    // deactivate node\n', '    entityNodeIsActive[fromId] = false;\n', '    entityNodePaidOnBlock[fromId] = 0;\n', '    entityNodeClaimedOnBlock[fromId] = 0;\n', '    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] - 1;\n', '\n', '    emit Migrated(msg.sender, to, nodeId, toNodeId, entityNodeIsBYON[fromId]);\n', '  }\n', '}']