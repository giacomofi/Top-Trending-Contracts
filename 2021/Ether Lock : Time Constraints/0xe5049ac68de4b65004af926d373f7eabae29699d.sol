['// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity ^0.6.12;\n', '\n', 'import "./multiOwnable.sol";\n', 'import "./munchTokenETH.sol";\n', '\n', 'contract munchEthBridge is Multiownable {\n', '    MUNCH private token;\n', '\n', '    mapping(address => uint256) public tokensSent;\n', '    mapping(address => uint256) public tokensRecieved;\n', '    mapping(address => uint256) public tokensRecievedButNotSent;\n', ' \n', '    constructor (address payable _token) public {\n', '        token = MUNCH(_token);\n', '    }\n', ' \n', '    uint256 amountToSent;\n', '    bool transferStatus;\n', '    \n', '    bool avoidReentrancy = false;\n', ' \n', '    function sendTokens(uint256 amount) public {\n', '        require(msg.sender != address(0), "Zero account");\n', '        require(amount > 0,"Amount of tokens should be more than 0");\n', '        require(token.balanceOf(msg.sender) >= amount,"Not enough balance");\n', '        \n', '        transferStatus = token.transferFrom(msg.sender, address(this), amount);\n', '        if (transferStatus == true) {\n', '            tokensRecieved[msg.sender] += amount;\n', '        }\n', '    }\n', ' \n', '    function writeTransaction(address user, uint256 amount) public onlyManyOwners {\n', '        require(user != address(0), "Zero account");\n', '        require(amount > 0,"Amount of tokens should be more than 0");\n', '        require(!avoidReentrancy);\n', '        \n', '        avoidReentrancy = true;\n', '        tokensRecievedButNotSent[user] += amount;\n', '        avoidReentrancy = false;\n', '    }\n', '\n', '    function recieveTokens(uint256[] memory commissions) public payable {\n', '        if (tokensRecievedButNotSent[msg.sender] != 0) {\n', '            require(commissions.length == owners.length, "The number of commissions and owners does not match");\n', '            uint256 sum;\n', '            for(uint i = 0; i < commissions.length; i++) {\n', '                sum += commissions[i];\n', '            }\n', '            require(msg.value >= sum, "Not enough ETH (The amount of ETH is less than the amount of commissions.)");\n', '            require(msg.value >= owners.length * 150000 * 10**9, "Not enough ETH (The amount of ETH is less than the internal commission.)");\n', '        \n', '            for (uint i = 0; i < owners.length; i++) {\n', '                address payable owner = payable(owners[i]);\n', '                uint256 commission = commissions[i];\n', '                owner.transfer(commission);\n', '            }\n', '            \n', '            amountToSent = tokensRecievedButNotSent[msg.sender] - tokensSent[msg.sender];\n', '            token.transfer(msg.sender, amountToSent);\n', '            tokensSent[msg.sender] += amountToSent;\n', '        }\n', '    }\n', ' \n', '    function withdrawTokens(uint256 amount, address reciever) public onlyManyOwners {\n', '        require(amount > 0,"Amount of tokens should be more than 0");\n', '        require(reciever != address(0), "Zero account");\n', '        require(token.balanceOf(address(this)) >= amount,"Not enough balance");\n', '        \n', '        token.transfer(reciever, amount);\n', '    }\n', '    \n', '    function withdrawEther(uint256 amount, address payable reciever) public onlyManyOwners {\n', '        require(amount > 0,"Amount of tokens should be more than 0");\n', '        require(reciever != address(0), "Zero account");\n', '        require(address(this).balance >= amount,"Not enough balance");\n', '\n', '        reciever.transfer(amount);\n', '    }\n', '}']