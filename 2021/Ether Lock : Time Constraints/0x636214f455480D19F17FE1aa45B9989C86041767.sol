['// Copyright (C) 2020 Centrifuge\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity >=0.5.15 <0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./auth.sol";\n', 'import "./math.sol";\n', 'import "./fixed_point.sol";\n', '\n', 'interface ERC20Like {\n', '    function balanceOf(address) external view returns (uint);\n', '    function transferFrom(address, address, uint) external returns (bool);\n', '    function mint(address, uint) external;\n', '    function burn(address, uint) external;\n', '    function totalSupply() external view returns (uint);\n', '    function approve(address usr, uint amount) external;\n', '}\n', '\n', 'interface ReserveLike {\n', '    function deposit(uint amount) external;\n', '    function payout(uint amount) external;\n', '    function totalBalanceAvailable() external returns (uint);\n', '}\n', '\n', 'interface EpochTickerLike {\n', '    function currentEpoch() external view returns (uint);\n', '    function lastEpochExecuted() external view returns(uint);\n', '}\n', '\n', 'contract Tranche is Math, Auth, FixedPoint {\n', '    mapping(uint => Epoch) public epochs;\n', '\n', '    struct Epoch {\n', '        // denominated in 10^27\n', '        // percentage ONE == 100%\n', '        Fixed27 redeemFulfillment;\n', '        // denominated in 10^27\n', '        // percentage ONE == 100%\n', '        Fixed27 supplyFulfillment;\n', '        // tokenPrice after end of epoch\n', '        Fixed27 tokenPrice;\n', '    }\n', '\n', '    struct UserOrder {\n', '        uint orderedInEpoch;\n', '        uint supplyCurrencyAmount;\n', '        uint redeemTokenAmount;\n', '    }\n', '\n', '    mapping(address => UserOrder) public users;\n', '\n', '    uint public  totalSupply;\n', '    uint public  totalRedeem;\n', '\n', '    ERC20Like public currency;\n', '    ERC20Like public token;\n', '    ReserveLike public reserve;\n', '    EpochTickerLike public epochTicker;\n', '\n', '    // additional requested currency if the reserve could not fulfill a tranche request\n', '    uint public requestedCurrency;\n', '    address self;\n', '\n', '    bool public waitingForUpdate = false;\n', '\n', '    modifier orderAllowed(address usr) {\n', '        require((users[usr].supplyCurrencyAmount == 0 && users[usr].redeemTokenAmount == 0)\n', '        || users[usr].orderedInEpoch == epochTicker.currentEpoch(), "disburse required");\n', '        _;\n', '    }\n', '\n', '    constructor(address currency_, address token_) public {\n', '        wards[msg.sender] = 1;\n', '        token = ERC20Like(token_);\n', '        currency = ERC20Like(currency_);\n', '        self = address(this);\n', '    }\n', '\n', '    function balance() external view returns (uint) {\n', '        return currency.balanceOf(self);\n', '    }\n', '\n', '    function tokenSupply() external view returns (uint) {\n', '        return token.totalSupply();\n', '    }\n', '\n', '    function depend(bytes32 contractName, address addr) public auth {\n', '        if (contractName == "token") {token = ERC20Like(addr);}\n', '        else if (contractName == "currency") {currency = ERC20Like(addr);}\n', '        else if (contractName == "reserve") {reserve = ReserveLike(addr);}\n', '        else if (contractName == "epochTicker") {epochTicker = EpochTickerLike(addr);}\n', '        else revert();\n', '    }\n', '\n', '    // supplyOrder function can be used to place or revoke an supply\n', '    function supplyOrder(address usr, uint newSupplyAmount) public auth orderAllowed(usr) {\n', '        users[usr].orderedInEpoch = epochTicker.currentEpoch();\n', '\n', '        uint currentSupplyAmount = users[usr].supplyCurrencyAmount;\n', '\n', '        users[usr].supplyCurrencyAmount = newSupplyAmount;\n', '\n', '        totalSupply = safeAdd(safeTotalSub(totalSupply, currentSupplyAmount), newSupplyAmount);\n', '\n', '        if (newSupplyAmount > currentSupplyAmount) {\n', '            uint delta = safeSub(newSupplyAmount, currentSupplyAmount);\n', '            require(currency.transferFrom(usr, self, delta), "currency-transfer-failed");\n', '            return;\n', '        }\n', '        uint delta = safeSub(currentSupplyAmount, newSupplyAmount);\n', '        if (delta > 0) {\n', '            _safeTransfer(currency, usr, delta);\n', '        }\n', '    }\n', '\n', '    // redeemOrder function can be used to place or revoke a redeem\n', '    function redeemOrder(address usr, uint newRedeemAmount) public auth orderAllowed(usr) {\n', '        users[usr].orderedInEpoch = epochTicker.currentEpoch();\n', '\n', '        uint currentRedeemAmount = users[usr].redeemTokenAmount;\n', '        users[usr].redeemTokenAmount = newRedeemAmount;\n', '        totalRedeem = safeAdd(safeTotalSub(totalRedeem, currentRedeemAmount), newRedeemAmount);\n', '\n', '        if (newRedeemAmount > currentRedeemAmount) {\n', '            uint delta = safeSub(newRedeemAmount, currentRedeemAmount);\n', '            require(token.transferFrom(usr, self, delta), "token-transfer-failed");\n', '            return;\n', '        }\n', '\n', '        uint delta = safeSub(currentRedeemAmount, newRedeemAmount);\n', '        if (delta > 0) {\n', '            _safeTransfer(token, usr, delta);\n', '        }\n', '    }\n', '\n', '    function calcDisburse(address usr) public view returns(uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n', '        return calcDisburse(usr, epochTicker.lastEpochExecuted());\n', '    }\n', '\n', '    ///  calculates the current disburse of a user starting from the ordered epoch until endEpoch\n', '    function calcDisburse(address usr, uint endEpoch) public view returns(uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n', '        uint epochIdx = users[usr].orderedInEpoch;\n', '        uint lastEpochExecuted = epochTicker.lastEpochExecuted();\n', '\n', '        // no disburse possible in this epoch\n', '        if (users[usr].orderedInEpoch == epochTicker.currentEpoch()) {\n', '            return (payoutCurrencyAmount, payoutTokenAmount, users[usr].supplyCurrencyAmount, users[usr].redeemTokenAmount);\n', '        }\n', '\n', '        if (endEpoch > lastEpochExecuted) {\n', '            // it is only possible to disburse epochs which are already over\n', '            endEpoch = lastEpochExecuted;\n', '        }\n', '\n', '        remainingSupplyCurrency = users[usr].supplyCurrencyAmount;\n', '        remainingRedeemToken = users[usr].redeemTokenAmount;\n', '        uint amount = 0;\n', '\n', '        // calculates disburse amounts as long as remaining tokens or currency is left or the end epoch is reached\n', '        while(epochIdx <= endEpoch && (remainingSupplyCurrency != 0 || remainingRedeemToken != 0 )){\n', '            if(remainingSupplyCurrency != 0) {\n', '                amount = rmul(remainingSupplyCurrency, epochs[epochIdx].supplyFulfillment.value);\n', '                // supply currency payout in token\n', '                if (amount != 0) {\n', '                    payoutTokenAmount = safeAdd(payoutTokenAmount, safeDiv(safeMul(amount, ONE), epochs[epochIdx].tokenPrice.value));\n', '                    remainingSupplyCurrency = safeSub(remainingSupplyCurrency, amount);\n', '                }\n', '            }\n', '\n', '            if(remainingRedeemToken != 0) {\n', '                amount = rmul(remainingRedeemToken, epochs[epochIdx].redeemFulfillment.value);\n', '                // redeem token payout in currency\n', '                if (amount != 0) {\n', '                    payoutCurrencyAmount = safeAdd(payoutCurrencyAmount, rmul(amount, epochs[epochIdx].tokenPrice.value));\n', '                    remainingRedeemToken = safeSub(remainingRedeemToken, amount);\n', '                }\n', '            }\n', '            epochIdx = safeAdd(epochIdx, 1);\n', '        }\n', '\n', '        return (payoutCurrencyAmount, payoutTokenAmount, remainingSupplyCurrency, remainingRedeemToken);\n', '    }\n', '\n', '    // the disburse function can be used after an epoch is over to receive currency and tokens\n', '    function disburse(address usr) public auth returns (uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n', '        return disburse(usr, epochTicker.lastEpochExecuted());\n', '    }\n', '\n', '    function _safeTransfer(ERC20Like erc20, address usr, uint amount) internal returns(uint) {\n', '        uint max = erc20.balanceOf(self);\n', '        if(amount > max) {\n', '            amount = max;\n', '        }\n', '        require(erc20.transferFrom(self, usr, amount), "token-transfer-failed");\n', '        return amount;\n', '    }\n', '\n', '    // the disburse function can be used after an epoch is over to receive currency and tokens\n', '    function disburse(address usr,  uint endEpoch) public auth returns (uint payoutCurrencyAmount, uint payoutTokenAmount, uint remainingSupplyCurrency, uint remainingRedeemToken) {\n', '        require(users[usr].orderedInEpoch <= epochTicker.lastEpochExecuted(), "epoch-not-executed-yet");\n', '\n', '        uint lastEpochExecuted = epochTicker.lastEpochExecuted();\n', '\n', '        if (endEpoch > lastEpochExecuted) {\n', '            // it is only possible to disburse epochs which are already over\n', '            endEpoch = lastEpochExecuted;\n', '        }\n', '\n', '        (payoutCurrencyAmount, payoutTokenAmount,\n', '        remainingSupplyCurrency, remainingRedeemToken) = calcDisburse(usr, endEpoch);\n', '        users[usr].supplyCurrencyAmount = remainingSupplyCurrency;\n', '        users[usr].redeemTokenAmount = remainingRedeemToken;\n', '        // if lastEpochExecuted is disbursed, orderInEpoch is at the current epoch again\n', '        // which allows to change the order. This is only possible if all previous epochs are disbursed\n', '        users[usr].orderedInEpoch = safeAdd(endEpoch, 1);\n', '\n', '\n', '        if (payoutCurrencyAmount > 0) {\n', '            payoutCurrencyAmount = _safeTransfer(currency, usr, payoutCurrencyAmount);\n', '        }\n', '\n', '        if (payoutTokenAmount > 0) {\n', '            payoutTokenAmount = _safeTransfer(token, usr, payoutTokenAmount);\n', '        }\n', '        return (payoutCurrencyAmount, payoutTokenAmount, remainingSupplyCurrency, remainingRedeemToken);\n', '    }\n', '\n', '\n', '    // called by epoch coordinator in epoch execute method\n', '    function epochUpdate(uint epochID, uint supplyFulfillment_, uint redeemFulfillment_, uint tokenPrice_, uint epochSupplyOrderCurrency, uint epochRedeemOrderCurrency) public auth {\n', '        require(waitingForUpdate == true);\n', '        waitingForUpdate = false;\n', '\n', '        epochs[epochID].supplyFulfillment.value = supplyFulfillment_;\n', '        epochs[epochID].redeemFulfillment.value = redeemFulfillment_;\n', '        epochs[epochID].tokenPrice.value = tokenPrice_;\n', '\n', '        // currency needs to be converted to tokenAmount with current token price\n', '        uint redeemInToken = 0;\n', '        uint supplyInToken = 0;\n', '        if(tokenPrice_ > 0) {\n', '            supplyInToken = rdiv(epochSupplyOrderCurrency, tokenPrice_);\n', '            redeemInToken = safeDiv(safeMul(epochRedeemOrderCurrency, ONE), tokenPrice_);\n', '        }\n', '\n', '        // calculates the delta between supply and redeem for tokens and burn or mint them\n', '        adjustTokenBalance(epochID, supplyInToken, redeemInToken);\n', '        // calculates the delta between supply and redeem for currency and deposit or get them from the reserve\n', '        adjustCurrencyBalance(epochID, epochSupplyOrderCurrency, epochRedeemOrderCurrency);\n', '\n', '        // the unfulfilled orders (1-fulfillment) is automatically ordered\n', '        totalSupply = safeAdd(safeTotalSub(totalSupply, epochSupplyOrderCurrency), rmul(epochSupplyOrderCurrency, safeSub(ONE, epochs[epochID].supplyFulfillment.value)));\n', '        totalRedeem = safeAdd(safeTotalSub(totalRedeem, redeemInToken), rmul(redeemInToken, safeSub(ONE, epochs[epochID].redeemFulfillment.value)));\n', '    }\n', '    function closeEpoch() public auth returns (uint totalSupplyCurrency_, uint totalRedeemToken_) {\n', '        require(waitingForUpdate == false);\n', '        waitingForUpdate = true;\n', '        return (totalSupply, totalRedeem);\n', '    }\n', '\n', '    function safeBurn(uint tokenAmount) internal {\n', '        uint max = token.balanceOf(self);\n', '        if(tokenAmount > max) {\n', '            tokenAmount = max;\n', '        }\n', '        token.burn(self, tokenAmount);\n', '    }\n', '\n', '    function safePayout(uint currencyAmount) internal returns(uint payoutAmount) {\n', '        uint max = reserve.totalBalanceAvailable();\n', '\n', '        if(currencyAmount > max) {\n', "            // currently reserve can't fulfill the entire request\n", '            currencyAmount = max;\n', '        }\n', '        reserve.payout(currencyAmount);\n', '        return currencyAmount;\n', '    }\n', '\n', '    function payoutRequestedCurrency() public {\n', '        if(requestedCurrency > 0) {\n', '            uint payoutAmount = safePayout(requestedCurrency);\n', '            requestedCurrency = safeSub(requestedCurrency, payoutAmount);\n', '        }\n', '    }\n', '    // adjust token balance after epoch execution -> min/burn tokens\n', '    function adjustTokenBalance(uint epochID, uint epochSupplyToken, uint epochRedeemToken) internal {\n', '        // mint token amount for supply\n', '\n', '        uint mintAmount = 0;\n', '        if (epochs[epochID].tokenPrice.value > 0) {\n', '            mintAmount = rmul(epochSupplyToken, epochs[epochID].supplyFulfillment.value);\n', '        }\n', '\n', '        // burn token amount for redeem\n', '        uint burnAmount = rmul(epochRedeemToken, epochs[epochID].redeemFulfillment.value);\n', '        // burn tokens that are not needed for disbursement\n', '        if (burnAmount > mintAmount) {\n', '            uint diff = safeSub(burnAmount, mintAmount);\n', '            safeBurn(diff);\n', '            return;\n', '        }\n', '        // mint tokens that are required for disbursement\n', '        uint diff = safeSub(mintAmount, burnAmount);\n', '        if (diff > 0) {\n', '            token.mint(self, diff);\n', '        }\n', '    }\n', '\n', '    // additional minting of tokens produces a dilution of all token holders\n', '    // interface is required for adapters\n', '    function mint(address usr, uint amount) public auth {\n', '        token.mint(usr, amount);\n', '    }\n', '\n', '    // adjust currency balance after epoch execution -> receive/send currency from/to reserve\n', '    function adjustCurrencyBalance(uint epochID, uint epochSupply, uint epochRedeem) internal {\n', '        // currency that was supplied in this epoch\n', '        uint currencySupplied = rmul(epochSupply, epochs[epochID].supplyFulfillment.value);\n', '        // currency required for redemption\n', '        uint currencyRequired = rmul(epochRedeem, epochs[epochID].redeemFulfillment.value);\n', '\n', '        if (currencySupplied > currencyRequired) {\n', '            // send surplus currency to reserve\n', '            uint diff = safeSub(currencySupplied, currencyRequired);\n', '            currency.approve(address(reserve), diff);\n', '            reserve.deposit(diff);\n', '            return;\n', '        }\n', '        uint diff = safeSub(currencyRequired, currencySupplied);\n', '        if (diff > 0) {\n', '            // get missing currency from reserve\n', '            uint payoutAmount = safePayout(diff);\n', '            if(payoutAmount < diff) {\n', "                // reserve couldn't fulfill the entire request\n", '                requestedCurrency = safeAdd(requestedCurrency, safeSub(diff, payoutAmount));\n', '            }\n', '        }\n', '    }\n', '\n', '    // recovery transfer can be used by governance to recover funds if tokens are stuck\n', '    function authTransfer(address erc20, address usr, uint amount) public auth {\n', '        ERC20Like(erc20).transferFrom(self, usr, amount);\n', '    }\n', '\n', '    // due to rounding in token & currency conversions currency & token balances might be off by 1 wei with the totalSupply/totalRedeem amounts.\n', '    // in order to prevent an underflow error, 0 is returned when amount to be subtracted is bigger then the total value.\n', '    function safeTotalSub(uint total, uint amount) internal returns (uint) {\n', '        if (total < amount) {\n', '            return 0;\n', '        }\n', '        return safeSub(total, amount);\n', '    }\n', '}']