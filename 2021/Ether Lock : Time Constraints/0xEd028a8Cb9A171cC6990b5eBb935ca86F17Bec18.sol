['pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' *\n', '*/\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '\n', '  address payable public owner;\n', '\n', '  event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address payable _newOwner) public onlyOwner {\n', '    owner = _newOwner;\n', '    emit OwnershipTransferred(msg.sender, _newOwner);\n', '  }\n', '}\n', '\n', 'interface IERC20 {\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '  function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', '\n', 'contract Presale is Owned {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  bool public isPresaleOpen;\n', '\n', '  IERC20 public token;\n', '  uint256 public constant TOKEN_DECIMALS = 18;\n', '  uint256 public constant tokenRatePerEth = 400;\n', '  uint256 public constant minEthLimit = 0.1 ether;\n', '  uint256 public constant maxEthLimit = 1.5 ether;\n', '  uint256 public constant maxEthLimitTotal = 10 ether;\n', '  uint256 private constant RATE = 10 ** (18 - TOKEN_DECIMALS);\n', '\n', '  mapping(address => uint256) public usersInvestments;\n', '  uint256 public investmentsTotal;\n', '\n', '  constructor(address _tokenAddress) public {\n', '    owner = msg.sender;\n', '    token = IERC20(_tokenAddress);\n', '  }\n', '\n', '  function startPresale() external onlyOwner {\n', '    require(!isPresaleOpen, "Open");\n', '    isPresaleOpen = true;\n', '  }\n', '\n', '  function closePresale() external onlyOwner {\n', '    require(isPresaleOpen, "Closed");\n', '    isPresaleOpen = false;\n', '  }\n', '\n', '  function drainUnsoldTokens() external onlyOwner {\n', '    require(!isPresaleOpen, "Not until its closed");\n', '    uint256 balance = token.balanceOf(address(this));\n', '    token.transfer(owner, balance);\n', '  }\n', '\n', '  function getTokensPerEth(uint256 amount) public pure returns (uint256) {\n', '    return amount.mul(tokenRatePerEth).div(RATE);\n', '  }\n', '\n', '  function purchase() external payable {\n', '    require(isPresaleOpen, "Presale closed.");\n', '    require(\n', '      usersInvestments[msg.sender].add(msg.value) <= maxEthLimit\n', '      && usersInvestments[msg.sender].add(msg.value) >= minEthLimit,\n', '      "User limit!"\n', '    );\n', '    require(\n', '      investmentsTotal.add(msg.value) <= maxEthLimitTotal,\n', '      "Total limit!"\n', '    );\n', '    \n', '    uint256 tokenAmount = getTokensPerEth(msg.value);\n', '\n', '    usersInvestments[msg.sender] = usersInvestments[msg.sender].add(msg.value);\n', '    investmentsTotal = investmentsTotal.add(msg.value);\n', '\n', '    require(token.transfer(msg.sender, tokenAmount), "Tokens transfer failed!");\n', '\n', '    (bool success, ) = owner.call{ value: msg.value }("");\n', '    require(success, "Address: unable to send value, recipient may have reverted");\n', '  }\n', '}']