['// SPDX-License-Identifier: AGPL-3.0-or-later\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "Ownable.sol";\n', 'import "SafeMath.sol";\n', 'import "AbstractStakingContract.sol";\n', '\n', '/**\n', ' * @notice Contract acts as delegate for sub-stakers\n', ' **/\n', 'contract PoolingStakingContractV2 is InitializableStakingContract, Ownable {\n', '    using SafeMath for uint256;\n', '    using Address for address payable;\n', '    using SafeERC20 for NuCypherToken;\n', '\n', '    event TokensDeposited(\n', '        address indexed sender,\n', '        uint256 value,\n', '        uint256 depositedTokens\n', '    );\n', '    event TokensWithdrawn(\n', '        address indexed sender,\n', '        uint256 value,\n', '        uint256 depositedTokens\n', '    );\n', '    event ETHWithdrawn(address indexed sender, uint256 value);\n', '    event WorkerOwnerSet(address indexed sender, address indexed workerOwner);\n', '\n', '    struct Delegator {\n', '        uint256 depositedTokens;\n', '        uint256 withdrawnReward;\n', '        uint256 withdrawnETH;\n', '    }\n', '\n', '    /**\n', '     * Defines base fraction and precision of worker fraction.\n', '     * E.g., for a value of 10000, a worker fraction of 100 represents 1% of reward (100/10000)\n', '     */\n', '    uint256 public constant BASIS_FRACTION = 10000;\n', '\n', '    StakingEscrow public escrow;\n', '    address public workerOwner;\n', '\n', '    uint256 public totalDepositedTokens;\n', '    uint256 public totalWithdrawnReward;\n', '    uint256 public totalWithdrawnETH;\n', '\n', '    uint256 workerFraction;\n', '    uint256 public workerWithdrawnReward;\n', '\n', '    mapping(address => Delegator) public delegators;\n', '\n', '    /**\n', '     * @notice Initialize function for using with OpenZeppelin proxy\n', '     * @param _workerFraction Share of token reward that worker node owner will get.\n', '     * Use value up to BASIS_FRACTION (10000), if _workerFraction = BASIS_FRACTION -> means 100% reward as commission.\n', '     * For example, 100 worker fraction is 1% of reward\n', '     * @param _router StakingInterfaceRouter address\n', '     * @param _workerOwner Owner of worker node, only this address can withdraw worker commission\n', '     */\n', '    function initialize(\n', '        uint256 _workerFraction,\n', '        StakingInterfaceRouter _router,\n', '        address _workerOwner\n', '    ) external initializer {\n', '        require(_workerOwner != address(0) && _workerFraction <= BASIS_FRACTION);\n', '        InitializableStakingContract.initialize(_router);\n', '        _transferOwnership(msg.sender);\n', '        escrow = _router.target().escrow();\n', '        workerFraction = _workerFraction;\n', '        workerOwner = _workerOwner;\n', '        emit WorkerOwnerSet(msg.sender, _workerOwner);\n', '    }\n', '\n', '    /**\n', '     * @notice withdrawAll() is allowed\n', '     */\n', '    function isWithdrawAllAllowed() public view returns (bool) {\n', '        // no tokens in StakingEscrow contract which belong to pool\n', '        return escrow.getAllTokens(address(this)) == 0;\n', '    }\n', '\n', '    /**\n', '     * @notice deposit() is allowed\n', '     */\n', '    function isDepositAllowed() public view returns (bool) {\n', '        // tokens which directly belong to pool\n', '        uint256 freeTokens = token.balanceOf(address(this));\n', '\n', '        // no sub-stakes and no earned reward\n', '        return isWithdrawAllAllowed() && freeTokens == totalDepositedTokens;\n', '    }\n', '\n', '    /**\n', '     * @notice Set worker owner address\n', '     */\n', '    function setWorkerOwner(address _workerOwner) external onlyOwner {\n', '        workerOwner = _workerOwner;\n', '        emit WorkerOwnerSet(msg.sender, _workerOwner);\n', '    }\n', '\n', '    /**\n', "     * @notice Calculate worker's fraction depending on deposited tokens\n", '     * Override to implement dynamic worker fraction.\n', '     */\n', '    function getWorkerFraction() public view virtual returns (uint256) {\n', '        return workerFraction;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer tokens as delegator\n', '     * @param _value Amount of tokens to transfer\n', '     */\n', '    function depositTokens(uint256 _value) external {\n', '        require(isDepositAllowed(), "Deposit must be enabled");\n', '        require(_value > 0, "Value must be not empty");\n', '        totalDepositedTokens = totalDepositedTokens.add(_value);\n', '        Delegator storage delegator = delegators[msg.sender];\n', '        delegator.depositedTokens = delegator.depositedTokens.add(_value);\n', '        token.safeTransferFrom(msg.sender, address(this), _value);\n', '        emit TokensDeposited(msg.sender, _value, delegator.depositedTokens);\n', '    }\n', '\n', '    /**\n', '     * @notice Get available reward for all delegators and owner\n', '     */\n', '    function getAvailableReward() public view returns (uint256) {\n', '        // locked + unlocked tokens in StakingEscrow contract which belong to pool\n', '        uint256 stakedTokens = escrow.getAllTokens(address(this));\n', '        // tokens which directly belong to pool\n', '        uint256 freeTokens = token.balanceOf(address(this));\n', '        // tokens in excess of the initially deposited\n', '        uint256 reward = stakedTokens.add(freeTokens).sub(totalDepositedTokens);\n', '        // check how many of reward tokens belong directly to pool\n', '        if (reward > freeTokens) {\n', '            return freeTokens;\n', '        }\n', '        return reward;\n', '    }\n', '\n', '    /**\n', '     * @notice Get cumulative reward.\n', '     * Available and withdrawn reward together to use in delegator/owner reward calculations\n', '     */\n', '    function getCumulativeReward() public view returns (uint256) {\n', '        return getAvailableReward().add(totalWithdrawnReward);\n', '    }\n', '\n', '    /**\n', '     * @notice Get available reward in tokens for worker node owner\n', '     */\n', '    function getAvailableWorkerReward() public view returns (uint256) {\n', '        // total current and historical reward\n', '        uint256 reward = getCumulativeReward();\n', '\n', '        // calculate total reward for worker including historical reward\n', '        uint256 maxAllowableReward;\n', '        // usual case\n', '        if (totalDepositedTokens != 0) {\n', '            uint256 fraction = getWorkerFraction();\n', '            maxAllowableReward = reward.mul(fraction).div(BASIS_FRACTION);\n', '        // special case when there are no delegators\n', '        } else {\n', '            maxAllowableReward = reward;\n', '        }\n', '\n', '        // check that worker has any new reward\n', '        if (maxAllowableReward > workerWithdrawnReward) {\n', '            return maxAllowableReward - workerWithdrawnReward;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Get available reward in tokens for delegator\n', '     */\n', '    function getAvailableDelegatorReward(address _delegator) public view returns (uint256) {\n', '        // special case when there are no delegators\n', '        if (totalDepositedTokens == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // total current and historical reward\n', '        uint256 reward = getCumulativeReward();\n', '        Delegator storage delegator = delegators[_delegator];\n', '        uint256 fraction = getWorkerFraction();\n', '\n', '        // calculate total reward for delegator including historical reward\n', '        // excluding worker share\n', '        uint256 maxAllowableReward = reward.mul(delegator.depositedTokens).mul(BASIS_FRACTION - fraction).div(\n', '            totalDepositedTokens.mul(BASIS_FRACTION)\n', '        );\n', '\n', '        // check that worker has any new reward\n', '        if (maxAllowableReward > delegator.withdrawnReward) {\n', '            return maxAllowableReward - delegator.withdrawnReward;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraw reward in tokens to worker node owner\n', '     */\n', '    function withdrawWorkerReward() external {\n', '        require(msg.sender == workerOwner);\n', '        uint256 balance = token.balanceOf(address(this));\n', '        uint256 availableReward = getAvailableWorkerReward();\n', '\n', '        if (availableReward > balance) {\n', '            availableReward = balance;\n', '        }\n', '        require(\n', '            availableReward > 0,\n', '            "There is no available reward to withdraw"\n', '        );\n', '        workerWithdrawnReward = workerWithdrawnReward.add(availableReward);\n', '        totalWithdrawnReward = totalWithdrawnReward.add(availableReward);\n', '\n', '        token.safeTransfer(msg.sender, availableReward);\n', '        emit TokensWithdrawn(msg.sender, availableReward, 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraw reward to delegator\n', '     * @param _value Amount of tokens to withdraw\n', '     */\n', '    function withdrawTokens(uint256 _value) public override {\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require(_value <= balance, "Not enough tokens in the contract");\n', '\n', '        Delegator storage delegator = delegators[msg.sender];\n', '        uint256 availableReward = getAvailableDelegatorReward(msg.sender);\n', '\n', '        require( _value <= availableReward, "Requested amount of tokens exceeded allowed portion");\n', '        delegator.withdrawnReward = delegator.withdrawnReward.add(_value);\n', '        totalWithdrawnReward = totalWithdrawnReward.add(_value);\n', '\n', '        token.safeTransfer(msg.sender, _value);\n', '        emit TokensWithdrawn(msg.sender, _value, delegator.depositedTokens);\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraw reward, deposit and fee to delegator\n', '     */\n', '    function withdrawAll() public {\n', '        require(isWithdrawAllAllowed(), "Withdraw deposit and reward must be enabled");\n', '        uint256 balance = token.balanceOf(address(this));\n', '\n', '        Delegator storage delegator = delegators[msg.sender];\n', '        uint256 availableReward = getAvailableDelegatorReward(msg.sender);\n', '        uint256 value = availableReward.add(delegator.depositedTokens);\n', '        require(value <= balance, "Not enough tokens in the contract");\n', '\n', '        // TODO remove double reading: availableReward and availableWorkerReward use same calls to external contracts\n', '        uint256 availableWorkerReward = getAvailableWorkerReward();\n', '\n', '        // potentially could be less then due reward\n', '        uint256 availableETH = getAvailableDelegatorETH(msg.sender);\n', '\n', '        // prevent losing reward for worker after calculations\n', '        uint256 workerReward = availableWorkerReward.mul(delegator.depositedTokens).div(totalDepositedTokens);\n', '        if (workerReward > 0) {\n', '            require(value.add(workerReward) <= balance, "Not enough tokens in the contract");\n', '            token.safeTransfer(workerOwner, workerReward);\n', '            emit TokensWithdrawn(workerOwner, workerReward, 0);\n', '        }\n', '\n', '        uint256 withdrawnToDecrease = workerWithdrawnReward.mul(delegator.depositedTokens).div(totalDepositedTokens);\n', '\n', '        workerWithdrawnReward = workerWithdrawnReward.sub(withdrawnToDecrease);\n', '        totalWithdrawnReward = totalWithdrawnReward.sub(withdrawnToDecrease).sub(delegator.withdrawnReward);\n', '        totalDepositedTokens = totalDepositedTokens.sub(delegator.depositedTokens);\n', '\n', '        delegator.withdrawnReward = 0;\n', '        delegator.depositedTokens = 0;\n', '\n', '        token.safeTransfer(msg.sender, value);\n', '        emit TokensWithdrawn(msg.sender, value, 0);\n', '\n', '        totalWithdrawnETH = totalWithdrawnETH.sub(delegator.withdrawnETH);\n', '        delegator.withdrawnETH = 0;\n', '        if (availableETH > 0) {\n', '            emit ETHWithdrawn(msg.sender, availableETH);\n', '            msg.sender.sendValue(availableETH);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Get available ether for delegator\n', '     */\n', '    function getAvailableDelegatorETH(address _delegator) public view returns (uint256) {\n', '        Delegator storage delegator = delegators[_delegator];\n', '        uint256 balance = address(this).balance;\n', '        // ETH balance + already withdrawn\n', '        balance = balance.add(totalWithdrawnETH);\n', '        uint256 maxAllowableETH = balance.mul(delegator.depositedTokens).div(totalDepositedTokens);\n', '\n', '        uint256 availableETH = maxAllowableETH.sub(delegator.withdrawnETH);\n', '        if (availableETH > balance) {\n', '            availableETH = balance;\n', '        }\n', '        return availableETH;\n', '    }\n', '\n', '    /**\n', '     * @notice Withdraw available amount of ETH to delegator\n', '     */\n', '    function withdrawETH() public override {\n', '        Delegator storage delegator = delegators[msg.sender];\n', '        uint256 availableETH = getAvailableDelegatorETH(msg.sender);\n', '        require(availableETH > 0, "There is no available ETH to withdraw");\n', '        delegator.withdrawnETH = delegator.withdrawnETH.add(availableETH);\n', '\n', '        totalWithdrawnETH = totalWithdrawnETH.add(availableETH);\n', '        emit ETHWithdrawn(msg.sender, availableETH);\n', '        msg.sender.sendValue(availableETH);\n', '    }\n', '\n', '    /**\n', '     * @notice Calling fallback function is allowed only for the owner\n', '     */\n', '    function isFallbackAllowed() public override view returns (bool) {\n', '        return msg.sender == owner();\n', '    }\n', '}']