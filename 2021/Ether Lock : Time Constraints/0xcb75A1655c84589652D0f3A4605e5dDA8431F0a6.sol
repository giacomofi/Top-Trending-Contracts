['# @version 0.2.8\n', '"""\n', '@title Voting Escrow\n', '@author Curve Finance\n', '@license MIT\n', '@notice Votes have a weight depending on time, so that users are\n', '        committed to the future of (whatever they are voting for)\n', '@dev Vote weight decays linearly over time. Lock time cannot be\n', '     more than `MAXTIME` (3 years).\n', '"""\n', '\n', '# ====================================================================\n', '# |     ______                   _______                             |\n', '# |    / _____________ __  __   / ____(_____  ____ _____  ________   |\n', '# |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\n', '# |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\n', '# | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\n', '# |                                                                  |\n', '# ====================================================================\n', '# =============================== veFXS ==============================\n', '# ====================================================================\n', '# Frax Finance: https://github.com/FraxFinance\n', '\n', '# Original idea and credit:\n', "# Curve Finance's veCRV\n", '# https://resources.curve.fi/faq/vote-locking-boost\n', '# https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy\n', '# veFXS is basically a line-for-line fork\n', '\n', '# Frax Reviewer(s) / Contributor(s)\n', '# Travis Moore: https://github.com/FortisFortuna\n', '# Jason Huan: https://github.com/jasonhuan\n', '# Sam Kazemian: https://github.com/samkazemian\n', '\n', '# Voting escrow to have time-weighted votes\n', '# Votes have a weight depending on time, so that users are committed\n', '# to the future of (whatever they are voting for).\n', '# The weight in this implementation is linear, and lock cannot be more than maxtime:\n', '# w ^\n', '# 1 +        /\n', '#   |      /\n', '#   |    /\n', '#   |  /\n', '#   |/\n', '# 0 +--------+------> time\n', '#       maxtime (3 years?)\n', '\n', 'struct Point:\n', '    bias: int128\n', '    slope: int128  # - dweight / dt\n', '    ts: uint256\n', '    blk: uint256  # block\n', '# We cannot really do block numbers per se b/c slope is per time, not per block\n', '# and per block could be fairly bad b/c Ethereum changes blocktimes.\n', '# What we can do is to extrapolate ***At functions\n', '\n', 'struct LockedBalance:\n', '    amount: int128\n', '    end: uint256\n', '\n', '\n', 'interface ERC20:\n', '    def decimals() -> uint256: view\n', '    def name() -> String[64]: view\n', '    def symbol() -> String[32]: view\n', '    def transfer(to: address, amount: uint256) -> bool: nonpayable\n', '    def transferFrom(spender: address, to: address, amount: uint256) -> bool: nonpayable\n', '\n', '\n', '# Interface for checking whether address belongs to a whitelisted\n', '# type of a smart wallet.\n', '# When new types are added - the whole contract is changed\n', '# The check() method is modifying to be able to use caching\n', '# for individual wallet addresses\n', 'interface SmartWalletChecker:\n', '    def check(addr: address) -> bool: nonpayable\n', '\n', 'DEPOSIT_FOR_TYPE: constant(int128) = 0\n', 'CREATE_LOCK_TYPE: constant(int128) = 1\n', 'INCREASE_LOCK_AMOUNT: constant(int128) = 2\n', 'INCREASE_UNLOCK_TIME: constant(int128) = 3\n', '\n', '\n', 'event CommitOwnership:\n', '    admin: address\n', '\n', 'event ApplyOwnership:\n', '    admin: address\n', '\n', 'event Deposit:\n', '    provider: indexed(address)\n', '    value: uint256\n', '    locktime: indexed(uint256)\n', '    type: int128\n', '    ts: uint256\n', '\n', 'event Withdraw:\n', '    provider: indexed(address)\n', '    value: uint256\n', '    ts: uint256\n', '\n', 'event Supply:\n', '    prevSupply: uint256\n', '    supply: uint256\n', '\n', '\n', 'WEEK: constant(uint256) = 7 * 86400  # all future times are rounded by week\n', 'MAXTIME: constant(uint256) = 3 * 365 * 86400  # 3 years\n', 'MULTIPLIER: constant(uint256) = 10 ** 18\n', '\n', 'token: public(address)\n', 'supply: public(uint256)\n', '\n', 'locked: public(HashMap[address, LockedBalance])\n', '\n', 'epoch: public(uint256)\n', 'point_history: public(Point[100000000000000000000000000000])  # epoch -> unsigned point\n', 'user_point_history: public(HashMap[address, Point[1000000000]])  # user -> Point[user_epoch]\n', 'user_point_epoch: public(HashMap[address, uint256])\n', 'slope_changes: public(HashMap[uint256, int128])  # time -> signed slope change\n', '\n', "# Aragon's view methods for compatibility\n", 'controller: public(address)\n', 'transfersEnabled: public(bool)\n', '\n', '# Emergency Unlock\n', 'emergencyUnlockActive: public(bool)\n', '\n', '# ERC20 related\n', 'name: public(String[64])\n', 'symbol: public(String[32])\n', 'version: public(String[32])\n', 'decimals: public(uint256)\n', '\n', '# Checker for whitelisted (smart contract) wallets which are allowed to deposit\n', '# The goal is to prevent tokenizing the escrow\n', 'future_smart_wallet_checker: public(address)\n', 'smart_wallet_checker: public(address)\n', '\n', 'admin: public(address)  # Can and will be a smart contract\n', 'future_admin: public(address)\n', '\n', '\n', '@external\n', 'def __init__(token_addr: address, _name: String[64], _symbol: String[32], _version: String[32]):\n', '    """\n', '    @notice Contract constructor\n', '    @param token_addr `ERC20CRV` token address\n', '    @param _name Token name\n', '    @param _symbol Token symbol\n', '    @param _version Contract version - required for Aragon compatibility\n', '    """\n', '    self.admin = msg.sender\n', '    self.token = token_addr\n', '    self.point_history[0].blk = block.number\n', '    self.point_history[0].ts = block.timestamp\n', '    self.controller = msg.sender\n', '    self.transfersEnabled = True\n', '\n', '    _decimals: uint256 = ERC20(token_addr).decimals()\n', '    assert _decimals <= 255\n', '    self.decimals = _decimals\n', '\n', '    self.name = _name\n', '    self.symbol = _symbol\n', '    self.version = _version\n', '\n', '\n', '@external\n', 'def commit_transfer_ownership(addr: address):\n', '    """\n', '    @notice Transfer ownership of VotingEscrow contract to `addr`\n', '    @param addr Address to have ownership transferred to\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '    self.future_admin = addr\n', '    log CommitOwnership(addr)\n', '\n', '\n', '@external\n', 'def apply_transfer_ownership():\n', '    """\n', '    @notice Apply ownership transfer\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '    _admin: address = self.future_admin\n', '    assert _admin != ZERO_ADDRESS  # dev: admin not set\n', '    self.admin = _admin\n', '    log ApplyOwnership(_admin)\n', '\n', '\n', '@external\n', 'def commit_smart_wallet_checker(addr: address):\n', '    """\n', '    @notice Set an external contract to check for approved smart contract wallets\n', '    @param addr Address of Smart contract checker\n', '    """\n', '    assert msg.sender == self.admin\n', '    self.future_smart_wallet_checker = addr\n', '\n', '\n', '@external\n', 'def apply_smart_wallet_checker():\n', '    """\n', '    @notice Apply setting external contract to check approved smart contract wallets\n', '    """\n', '    assert msg.sender == self.admin\n', '    self.smart_wallet_checker = self.future_smart_wallet_checker\n', '\n', '@external\n', 'def toggleEmergencyUnlock():\n', '    """\n', '    @dev Used to allow early withdrawals of veFXS back into FXS\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '    self.emergencyUnlockActive = not (self.emergencyUnlockActive)\n', '\n', '@internal\n', 'def assert_not_contract(addr: address):\n', '    """\n', '    @notice Check if the call is from a whitelisted smart contract, revert if not\n', '    @param addr Address to be checked\n', '    """\n', '    if addr != tx.origin:\n', '        checker: address = self.smart_wallet_checker\n', '        if checker != ZERO_ADDRESS:\n', '            if SmartWalletChecker(checker).check(addr):\n', '                return\n', '        raise "Smart contract depositors not allowed"\n', '\n', '\n', '@external\n', '@view\n', 'def get_last_user_slope(addr: address) -> int128:\n', '    """\n', '    @notice Get the most recently recorded rate of voting power decrease for `addr`\n', '    @param addr Address of the user wallet\n', '    @return Value of the slope\n', '    """\n', '    uepoch: uint256 = self.user_point_epoch[addr]\n', '    return self.user_point_history[addr][uepoch].slope\n', '\n', '\n', '@external\n', '@view\n', 'def user_point_history__ts(_addr: address, _idx: uint256) -> uint256:\n', '    """\n', '    @notice Get the timestamp for checkpoint `_idx` for `_addr`\n', '    @param _addr User wallet address\n', '    @param _idx User epoch number\n', '    @return Epoch time of the checkpoint\n', '    """\n', '    return self.user_point_history[_addr][_idx].ts\n', '\n', '\n', '@external\n', '@view\n', 'def locked__end(_addr: address) -> uint256:\n', '    """\n', "    @notice Get timestamp when `_addr`'s lock finishes\n", '    @param _addr User wallet\n', '    @return Epoch time of the lock end\n', '    """\n', '    return self.locked[_addr].end\n', '\n', '\n', '@internal\n', 'def _checkpoint(addr: address, old_locked: LockedBalance, new_locked: LockedBalance):\n', '    """\n', '    @notice Record global and per-user data to checkpoint\n', "    @param addr User's wallet address. No user checkpoint if 0x0\n", '    @param old_locked Pevious locked amount / end lock time for the user\n', '    @param new_locked New locked amount / end lock time for the user\n', '    """\n', '    u_old: Point = empty(Point)\n', '    u_new: Point = empty(Point)\n', '    old_dslope: int128 = 0\n', '    new_dslope: int128 = 0\n', '    _epoch: uint256 = self.epoch\n', '\n', '    if addr != ZERO_ADDRESS:\n', '        # Calculate slopes and biases\n', '        # Kept at zero when they have to\n', '        if old_locked.end > block.timestamp and old_locked.amount > 0:\n', '            u_old.slope = old_locked.amount / MAXTIME\n', '            u_old.bias = u_old.slope * convert(old_locked.end - block.timestamp, int128)\n', '        if new_locked.end > block.timestamp and new_locked.amount > 0:\n', '            u_new.slope = new_locked.amount / MAXTIME\n', '            u_new.bias = u_new.slope * convert(new_locked.end - block.timestamp, int128)\n', '\n', '        # Read values of scheduled changes in the slope\n', '        # old_locked.end can be in the past and in the future\n', '        # new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n', '        old_dslope = self.slope_changes[old_locked.end]\n', '        if new_locked.end != 0:\n', '            if new_locked.end == old_locked.end:\n', '                new_dslope = old_dslope\n', '            else:\n', '                new_dslope = self.slope_changes[new_locked.end]\n', '\n', '    last_point: Point = Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number})\n', '    if _epoch > 0:\n', '        last_point = self.point_history[_epoch]\n', '    last_checkpoint: uint256 = last_point.ts\n', '    # initial_last_point is used for extrapolation to calculate block number\n', '    # (approximately, for *At methods) and save them\n', '    # as we cannot figure that out exactly from inside the contract\n', '    initial_last_point: Point = last_point\n', '    block_slope: uint256 = 0  # dblock/dt\n', '    if block.timestamp > last_point.ts:\n', '        block_slope = MULTIPLIER * (block.number - last_point.blk) / (block.timestamp - last_point.ts)\n', '    # If last point is already recorded in this block, slope=0\n', "    # But that's ok b/c we know the block in such case\n", '\n', '    # Go over weeks to fill history and calculate what the current point is\n', '    t_i: uint256 = (last_checkpoint / WEEK) * WEEK\n', '    for i in range(255):\n', "        # Hopefully it won't happen that this won't get used in 5 years!\n", '        # If it does, users will be able to withdraw but vote weight will be broken\n', '        t_i += WEEK\n', '        d_slope: int128 = 0\n', '        if t_i > block.timestamp:\n', '            t_i = block.timestamp\n', '        else:\n', '            d_slope = self.slope_changes[t_i]\n', '        last_point.bias -= last_point.slope * convert(t_i - last_checkpoint, int128)\n', '        last_point.slope += d_slope\n', '        if last_point.bias < 0:  # This can happen\n', '            last_point.bias = 0\n', '        if last_point.slope < 0:  # This cannot happen - just in case\n', '            last_point.slope = 0\n', '        last_checkpoint = t_i\n', '        last_point.ts = t_i\n', '        last_point.blk = initial_last_point.blk + block_slope * (t_i - initial_last_point.ts) / MULTIPLIER\n', '        _epoch += 1\n', '        if t_i == block.timestamp:\n', '            last_point.blk = block.number\n', '            break\n', '        else:\n', '            self.point_history[_epoch] = last_point\n', '\n', '    self.epoch = _epoch\n', '    # Now point_history is filled until t=now\n', '\n', '    if addr != ZERO_ADDRESS:\n', '        # If last point was in this block, the slope change has been applied already\n', '        # But in such case we have 0 slope(s)\n', '        last_point.slope += (u_new.slope - u_old.slope)\n', '        last_point.bias += (u_new.bias - u_old.bias)\n', '        if last_point.slope < 0:\n', '            last_point.slope = 0\n', '        if last_point.bias < 0:\n', '            last_point.bias = 0\n', '\n', '    # Record the changed point into history\n', '    self.point_history[_epoch] = last_point\n', '\n', '    if addr != ZERO_ADDRESS:\n', '        # Schedule the slope changes (slope is going down)\n', '        # We subtract new_user_slope from [new_locked.end]\n', '        # and add old_user_slope to [old_locked.end]\n', '        if old_locked.end > block.timestamp:\n', '            # old_dslope was <something> - u_old.slope, so we cancel that\n', '            old_dslope += u_old.slope\n', '            if new_locked.end == old_locked.end:\n', '                old_dslope -= u_new.slope  # It was a new deposit, not extension\n', '            self.slope_changes[old_locked.end] = old_dslope\n', '\n', '        if new_locked.end > block.timestamp:\n', '            if new_locked.end > old_locked.end:\n', '                new_dslope -= u_new.slope  # old slope disappeared at this point\n', '                self.slope_changes[new_locked.end] = new_dslope\n', '            # else: we recorded it already in old_dslope\n', '\n', '        # Now handle user history\n', '        user_epoch: uint256 = self.user_point_epoch[addr] + 1\n', '\n', '        self.user_point_epoch[addr] = user_epoch\n', '        u_new.ts = block.timestamp\n', '        u_new.blk = block.number\n', '        self.user_point_history[addr][user_epoch] = u_new\n', '\n', '\n', '@internal\n', 'def _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\n', '    """\n', '    @notice Deposit and lock tokens for a user\n', "    @param _addr User's wallet address\n", '    @param _value Amount to deposit\n', '    @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n', '    @param locked_balance Previous locked amount / timestamp\n', '    """\n', '    _locked: LockedBalance = locked_balance\n', '    supply_before: uint256 = self.supply\n', '\n', '    self.supply = supply_before + _value\n', '    old_locked: LockedBalance = _locked\n', '    # Adding to existing lock, or if a lock is expired - creating a new one\n', '    _locked.amount += convert(_value, int128)\n', '    if unlock_time != 0:\n', '        _locked.end = unlock_time\n', '    self.locked[_addr] = _locked\n', '\n', '    # Possibilities:\n', '    # Both old_locked.end could be current or expired (>/< block.timestamp)\n', '    # value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n', '    # _locked.end > block.timestamp (always)\n', '    self._checkpoint(_addr, old_locked, _locked)\n', '\n', '    if _value != 0:\n', '        assert ERC20(self.token).transferFrom(_addr, self, _value)\n', '\n', '    log Deposit(_addr, _value, _locked.end, type, block.timestamp)\n', '    log Supply(supply_before, supply_before + _value)\n', '\n', '\n', '@external\n', 'def checkpoint():\n', '    """\n', '    @notice Record global data to checkpoint\n', '    """\n', '    self._checkpoint(ZERO_ADDRESS, empty(LockedBalance), empty(LockedBalance))\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def deposit_for(_addr: address, _value: uint256):\n', '    """\n', '    @notice Deposit `_value` tokens for `_addr` and add to the lock\n', '    @dev Anyone (even a smart contract) can deposit for someone else, but\n', '         cannot extend their locktime and deposit for a brand new user\n', "    @param _addr User's wallet address\n", "    @param _value Amount to add to user's lock\n", '    """\n', '    _locked: LockedBalance = self.locked[_addr]\n', '\n', '    assert _value > 0  # dev: need non-zero value\n', '    assert _locked.amount > 0, "No existing lock found"\n', '    assert _locked.end > block.timestamp, "Cannot add to expired lock. Withdraw"\n', '\n', '    self._deposit_for(_addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def create_lock(_value: uint256, _unlock_time: uint256):\n', '    """\n', '    @notice Deposit `_value` tokens for `msg.sender` and lock until `_unlock_time`\n', '    @param _value Amount to deposit\n', '    @param _unlock_time Epoch time when tokens unlock, rounded down to whole weeks\n', '    """\n', '    self.assert_not_contract(msg.sender)\n', '    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n', '    _locked: LockedBalance = self.locked[msg.sender]\n', '\n', '    assert _value > 0  # dev: need non-zero value\n', '    assert _locked.amount == 0, "Withdraw old tokens first"\n', '    assert unlock_time > block.timestamp, "Can only lock until time in the future"\n', '    assert unlock_time <= block.timestamp + MAXTIME, "Voting lock can be 3 years max"\n', '\n', '    self._deposit_for(msg.sender, _value, unlock_time, _locked, CREATE_LOCK_TYPE)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def increase_amount(_value: uint256):\n', '    """\n', '    @notice Deposit `_value` additional tokens for `msg.sender`\n', '            without modifying the unlock time\n', '    @param _value Amount of tokens to deposit and add to the lock\n', '    """\n', '    self.assert_not_contract(msg.sender)\n', '    _locked: LockedBalance = self.locked[msg.sender]\n', '\n', '    assert _value > 0  # dev: need non-zero value\n', '    assert _locked.amount > 0, "No existing lock found"\n', '    assert _locked.end > block.timestamp, "Cannot add to expired lock. Withdraw"\n', '\n', '    self._deposit_for(msg.sender, _value, 0, _locked, INCREASE_LOCK_AMOUNT)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def increase_unlock_time(_unlock_time: uint256):\n', '    """\n', '    @notice Extend the unlock time for `msg.sender` to `_unlock_time`\n', '    @param _unlock_time New epoch time for unlocking\n', '    """\n', '    self.assert_not_contract(msg.sender)\n', '    _locked: LockedBalance = self.locked[msg.sender]\n', '    unlock_time: uint256 = (_unlock_time / WEEK) * WEEK  # Locktime is rounded down to weeks\n', '\n', '    assert _locked.end > block.timestamp, "Lock expired"\n', '    assert _locked.amount > 0, "Nothing is locked"\n', '    assert unlock_time > _locked.end, "Can only increase lock duration"\n', '    assert unlock_time <= block.timestamp + MAXTIME, "Voting lock can be 3 years max"\n', '\n', '    self._deposit_for(msg.sender, 0, unlock_time, _locked, INCREASE_UNLOCK_TIME)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def withdraw():\n', '    """\n', '    @notice Withdraw all tokens for `msg.sender`\n', '    @dev Only possible if the lock has expired\n', '    """\n', '    _locked: LockedBalance = self.locked[msg.sender]\n', '    assert ((block.timestamp >= _locked.end) or (self.emergencyUnlockActive)), "The lock didn\'t expire"\n', '    value: uint256 = convert(_locked.amount, uint256)\n', '\n', '    old_locked: LockedBalance = _locked\n', '    _locked.end = 0\n', '    _locked.amount = 0\n', '    self.locked[msg.sender] = _locked\n', '    supply_before: uint256 = self.supply\n', '    self.supply = supply_before - value\n', '\n', '    # old_locked can have either expired <= timestamp or zero end\n', '    # _locked has only 0 end\n', '    # Both can have >= 0 amount\n', '    self._checkpoint(msg.sender, old_locked, _locked)\n', '\n', '    assert ERC20(self.token).transfer(msg.sender, value)\n', '\n', '    log Withdraw(msg.sender, value, block.timestamp)\n', '    log Supply(supply_before, supply_before - value)\n', '\n', '\n', '# The following ERC20/minime-compatible methods are not real balanceOf and supply!\n', "# They measure the weights for the purpose of voting, so they don't represent\n", '# real coins.\n', '\n', '@internal\n', '@view\n', 'def find_block_epoch(_block: uint256, max_epoch: uint256) -> uint256:\n', '    """\n', '    @notice Binary search to estimate timestamp for block number\n', '    @param _block Block to find\n', "    @param max_epoch Don't go beyond this epoch\n", '    @return Approximate timestamp for block\n', '    """\n', '    # Binary search\n', '    _min: uint256 = 0\n', '    _max: uint256 = max_epoch\n', '    for i in range(128):  # Will be always enough for 128-bit numbers\n', '        if _min >= _max:\n', '            break\n', '        _mid: uint256 = (_min + _max + 1) / 2\n', '        if self.point_history[_mid].blk <= _block:\n', '            _min = _mid\n', '        else:\n', '            _max = _mid - 1\n', '    return _min\n', '\n', '\n', '@external\n', '@view\n', 'def balanceOf(addr: address, _t: uint256 = block.timestamp) -> uint256:\n', '    """\n', '    @notice Get the current voting power for `msg.sender`\n', '    @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n', '    @param addr User wallet address\n', '    @param _t Epoch time to return voting power at\n', '    @return User voting power\n', '    """\n', '    _epoch: uint256 = self.user_point_epoch[addr]\n', '    if _epoch == 0:\n', '        return 0\n', '    else:\n', '        last_point: Point = self.user_point_history[addr][_epoch]\n', '        last_point.bias -= last_point.slope * convert(_t - last_point.ts, int128)\n', '        if last_point.bias < 0:\n', '            last_point.bias = 0\n', '        return convert(last_point.bias, uint256)\n', '\n', '\n', '@external\n', '@view\n', 'def balanceOfAt(addr: address, _block: uint256) -> uint256:\n', '    """\n', '    @notice Measure voting power of `addr` at block height `_block`\n', '    @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n', "    @param addr User's wallet address\n", '    @param _block Block to calculate the voting power at\n', '    @return Voting power\n', '    """\n', '    # Copying and pasting totalSupply code because Vyper cannot pass by\n', '    # reference yet\n', '    assert _block <= block.number\n', '\n', '    # Binary search\n', '    _min: uint256 = 0\n', '    _max: uint256 = self.user_point_epoch[addr]\n', '    for i in range(128):  # Will be always enough for 128-bit numbers\n', '        if _min >= _max:\n', '            break\n', '        _mid: uint256 = (_min + _max + 1) / 2\n', '        if self.user_point_history[addr][_mid].blk <= _block:\n', '            _min = _mid\n', '        else:\n', '            _max = _mid - 1\n', '\n', '    upoint: Point = self.user_point_history[addr][_min]\n', '\n', '    max_epoch: uint256 = self.epoch\n', '    _epoch: uint256 = self.find_block_epoch(_block, max_epoch)\n', '    point_0: Point = self.point_history[_epoch]\n', '    d_block: uint256 = 0\n', '    d_t: uint256 = 0\n', '    if _epoch < max_epoch:\n', '        point_1: Point = self.point_history[_epoch + 1]\n', '        d_block = point_1.blk - point_0.blk\n', '        d_t = point_1.ts - point_0.ts\n', '    else:\n', '        d_block = block.number - point_0.blk\n', '        d_t = block.timestamp - point_0.ts\n', '    block_time: uint256 = point_0.ts\n', '    if d_block != 0:\n', '        block_time += d_t * (_block - point_0.blk) / d_block\n', '\n', '    upoint.bias -= upoint.slope * convert(block_time - upoint.ts, int128)\n', '    if upoint.bias >= 0:\n', '        return convert(upoint.bias, uint256)\n', '    else:\n', '        return 0\n', '\n', '\n', '@internal\n', '@view\n', 'def supply_at(point: Point, t: uint256) -> uint256:\n', '    """\n', '    @notice Calculate total voting power at some point in the past\n', '    @param point The point (bias/slope) to start search from\n', '    @param t Time to calculate the total voting power at\n', '    @return Total voting power at that time\n', '    """\n', '    last_point: Point = point\n', '    t_i: uint256 = (last_point.ts / WEEK) * WEEK\n', '    for i in range(255):\n', '        t_i += WEEK\n', '        d_slope: int128 = 0\n', '        if t_i > t:\n', '            t_i = t\n', '        else:\n', '            d_slope = self.slope_changes[t_i]\n', '        last_point.bias -= last_point.slope * convert(t_i - last_point.ts, int128)\n', '        if t_i == t:\n', '            break\n', '        last_point.slope += d_slope\n', '        last_point.ts = t_i\n', '\n', '    if last_point.bias < 0:\n', '        last_point.bias = 0\n', '    return convert(last_point.bias, uint256)\n', '\n', '\n', '@external\n', '@view\n', 'def totalSupply(t: uint256 = block.timestamp) -> uint256:\n', '    """\n', '    @notice Calculate total voting power\n', '    @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n', '    @return Total voting power\n', '    """\n', '    _epoch: uint256 = self.epoch\n', '    last_point: Point = self.point_history[_epoch]\n', '    return self.supply_at(last_point, t)\n', '\n', '\n', '@external\n', '@view\n', 'def totalSupplyAt(_block: uint256) -> uint256:\n', '    """\n', '    @notice Calculate total voting power at some point in the past\n', '    @param _block Block to calculate the total voting power at\n', '    @return Total voting power at `_block`\n', '    """\n', '    assert _block <= block.number\n', '    _epoch: uint256 = self.epoch\n', '    target_epoch: uint256 = self.find_block_epoch(_block, _epoch)\n', '\n', '    point: Point = self.point_history[target_epoch]\n', '    dt: uint256 = 0\n', '    if target_epoch < _epoch:\n', '        point_next: Point = self.point_history[target_epoch + 1]\n', '        if point.blk != point_next.blk:\n', '            dt = (_block - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk)\n', '    else:\n', '        if point.blk != block.number:\n', '            dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk)\n', '    # Now dt contains info on how far are we beyond point\n', '\n', '    return self.supply_at(point, point.ts + dt)\n', '\n', '# Dummy methods for compatibility with Aragon\n', '\n', '@external\n', 'def changeController(_newController: address):\n', '    """\n', '    @dev Dummy method required for Aragon compatibility\n', '    """\n', '    assert msg.sender == self.controller\n', '    self.controller = _newController']