['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '//pragma experimental ABIEncoderV2;\n', '\n', 'import "./SToken.sol";\n', 'import "./Governable.sol";\n', '\n', 'import "./TransferHelper.sol";\n', '\n', '\n', 'interface Minter {\n', '    event Minted(address indexed recipient, address reward_contract, uint minted);\n', '\n', '    function token() external view returns (address);\n', '    function controller() external view returns (address);\n', '    function minted(address, address) external view returns (uint);\n', '    function allowed_to_mint_for(address, address) external view returns (bool);\n', '    \n', '    function mint(address gauge) external;\n', '    function mint_many(address[8] calldata gauges) external;\n', '    function mint_for(address gauge, address _for) external;\n', '    function toggle_approve_mint(address minting_user) external;\n', '}\n', '\n', 'interface LiquidityGauge {\n', '    event Deposit(address indexed provider, uint value);\n', '    event Withdraw(address indexed provider, uint value);\n', '    event UpdateLiquidityLimit(address user, uint original_balance, uint original_supply, uint working_balance, uint working_supply);\n', '\n', '    function user_checkpoint (address addr) external returns (bool);\n', '    function claimable_tokens(address addr) external view returns (uint);\n', '    function claimable_reward(address addr) external view returns (uint);\n', '    function integrate_checkpoint()         external view returns (uint);\n', '\n', '    function kick(address addr) external;\n', '    function set_approve_deposit(address addr, bool can_deposit) external;\n', '    function deposit(uint _value) external;\n', '    function deposit(uint _value, address addr) external;\n', '    function withdraw(uint _value) external;\n', '    function withdraw(uint _value, bool claim_rewards) external;\n', '    function claim_rewards() external;\n', '    function claim_rewards(address addr) external;\n', '\n', '    function minter()                       external view returns (address);\n', '    function crv_token()                    external view returns (address);\n', '    function lp_token()                     external view returns (address);\n', '    function controller()                   external view returns (address);\n', '    function voting_escrow()                external view returns (address);\n', '    function balanceOf(address)             external view returns (uint);\n', '    function totalSupply()                  external view returns (uint);\n', '    function future_epoch_time()            external view returns (uint);\n', '    function approved_to_deposit(address, address)   external view returns (bool);\n', '    function working_balances(address)      external view returns (uint);\n', '    function working_supply()               external view returns (uint);\n', '    function period()                       external view returns (int128);\n', '    function period_timestamp(uint)         external view returns (uint);\n', '    function integrate_inv_supply(uint)     external view returns (uint);\n', '    function integrate_inv_supply_of(address) external view returns (uint);\n', '    function integrate_checkpoint_of(address) external view returns (uint);\n', '    function integrate_fraction(address)    external view returns (uint);\n', '    function inflation_rate()               external view returns (uint);\n', '    function reward_contract()              external view returns (address);\n', '    function rewarded_token()               external view returns (address);\n', '    function reward_integral()              external view returns (uint);\n', '    function reward_integral_for(address)   external view returns (uint);\n', '    function rewards_for(address)           external view returns (uint);\n', '    function claimed_rewards_for(address)   external view returns (uint);\n', '}\n', '\n', 'interface IStakingRewards {\n', '    // Views\n', '    function lastTimeRewardApplicable() external view returns (uint256);\n', '    function rewardPerToken() external view returns (uint256);\n', '    function rewards(address account) external view returns (uint256);\n', '    function earned(address account) external view returns (uint256);\n', '    function getRewardForDuration() external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    // Mutative\n', '    function stake(uint256 amount) external;\n', '    function withdraw(uint256 amount) external;\n', '    function getReward() external;\n', '    function exit() external;\n', '    // Events\n', '    event RewardAdded(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '}\n', '\n', 'interface IStakingRewards2 is IStakingRewards {\n', '\tfunction totalMinted() external view returns (uint);\n', '\tfunction weightOfGauge(address gauge) external view returns (uint);\n', '\tfunction stakingPerLPT(address gauge) external view returns (uint);\n', '\t\n', '\tfunction stakeTimeOf(address account) external view returns (uint);\n', '\tfunction stakeAgeOf(address account) external view returns (uint);\n', '\tfunction factorOf(address account) external view returns (uint);\n', '\n', '\tfunction spendTimeOf(address account) external view returns (uint);\n', '\tfunction spendAgeOf(address account) external view returns (uint);\n', '\tfunction coinAgeOf(address account) external view returns (uint);\n', '\t\n', '    function spendCoinAge(address account, uint coinAge) external returns (uint);\n', '    \n', '    event SpentCoinAge(address indexed gauge, address indexed account, uint coinAge);\n', '}\n', '\n', 'contract SSimpleGauge is LiquidityGauge, Configurable {\n', '    using SafeMath for uint;\n', '    using TransferHelper for address;\n', '\n', '    address override public minter;\n', '    address override public crv_token;\n', '    address override public lp_token;\n', '    address override public controller;\n', '    address override public voting_escrow;\n', '    mapping(address => uint) override public balanceOf;\n', '    uint override public totalSupply;\n', '    uint override public future_epoch_time;\n', '    \n', '    // caller -> recipient -> can deposit?\n', '    mapping(address => mapping(address => bool)) override public approved_to_deposit;\n', '    \n', '    mapping(address => uint) override public working_balances;\n', '    uint override public working_supply;\n', '    \n', '    // The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\n', '    // All values are kept in units of being multiplied by 1e18\n', '    int128 override public period;\n', '    uint256[100000000000000000000000000000] override public period_timestamp;\n', '    \n', '    // 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\n', '    uint256[100000000000000000000000000000] override public integrate_inv_supply;  // bump epoch when rate() changes\n', '    \n', '    // 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\n', '    mapping(address => uint) override public integrate_inv_supply_of;\n', '    mapping(address => uint) override public integrate_checkpoint_of;\n', '    \n', '    // ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n', '    // Units: rate * t = already number of coins per address to issue\n', '    mapping(address => uint) override public integrate_fraction;\n', '    \n', '    uint override public inflation_rate;\n', '    \n', '    // For tracking external rewards\n', '    address override public reward_contract;\n', '    address override public rewarded_token;\n', '    \n', '    uint override public reward_integral;\n', '    mapping(address => uint) override public reward_integral_for;\n', '    mapping(address => uint) override public rewards_for;\n', '    mapping(address => uint) override public claimed_rewards_for;\n', '    \n', '\n', '\tuint public span;\n', '\tuint public end;\n', '\n', '\tfunction initialize(address governor, address _minter, address _lp_token) public initializer {\n', '\t    super.initialize(governor);\n', '\t    \n', '\t    minter      = _minter;\n', '\t    crv_token   = Minter(_minter).token();\n', '\t    lp_token    = _lp_token;\n', '\t    IERC20(lp_token).totalSupply();          // just check\n', '\t}\n', '    \n', '    function setSpan(uint _span, bool isLinear) virtual external governance {\n', '        span = _span;\n', '        if(isLinear)\n', '            end = now + _span;\n', '        else\n', '            end = 0;\n', '    }\n', '    \n', '    function kick(address addr) virtual override external {\n', '        _checkpoint(addr, true);\n', '    }\n', '    \n', '    function set_approve_deposit(address addr, bool can_deposit) virtual override external {\n', '        approved_to_deposit[addr][msg.sender] = can_deposit;\n', '    }\n', '    \n', '    function deposit(uint amount) virtual override external {\n', '        deposit(amount, msg.sender);\n', '    }\n', '    function deposit(uint amount, address addr) virtual override public {\n', "        require(addr == msg.sender || approved_to_deposit[msg.sender][addr], 'Not approved');\n", '\n', '        _checkpoint(addr, true);\n', '        \n', '        _deposit(addr, amount);\n', '        \n', '        balanceOf[addr] = balanceOf[addr].add(amount);\n', '        totalSupply = totalSupply.add(amount);\n', '        \n', '        emit Deposit(addr, amount);\n', '    }\n', '    function _deposit(address addr, uint amount) virtual internal {\n', '        lp_token.safeTransferFrom(addr, address(this), amount);\n', '    }\n', '    \n', '    function withdraw() virtual  external {\n', '        withdraw(balanceOf[msg.sender], true);\n', '    }\n', '    function withdraw(uint amount) virtual override external {\n', '        withdraw(amount, true);\n', '    }\n', '    function withdraw(uint amount, bool claim_rewards) virtual override public {\n', '        _checkpoint(msg.sender, claim_rewards);\n', '        \n', '        totalSupply = totalSupply.sub(amount);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\n', '        \n', '        _withdraw(msg.sender, amount);\n', '        \n', '        emit Withdraw(msg.sender, amount);\n', '    }\n', '    function _withdraw(address to, uint amount) virtual internal {\n', '        lp_token.safeTransfer(to, amount);\n', '    }\n', '    \n', '    function claimable_reward(address) virtual override public view returns (uint) {\n', '        return 0;\n', '    }\n', '\n', '    function claim_rewards() virtual override public {\n', '        return claim_rewards(msg.sender);\n', '    }\n', '    function claim_rewards(address) virtual override public {\n', '        return;\n', '    }\n', '    function _checkpoint_rewards(address, bool) virtual internal {\n', '        return;\n', '    }\n', '    \n', '    function claimable_tokens(address addr) virtual override public view returns (uint amount) {\n', '        if(span == 0 || totalSupply == 0)\n', '            return 0;\n', '        \n', '        amount = SMinter(minter).quotas(address(this));\n', '        amount = amount.mul(balanceOf[addr]).div(totalSupply);\n', '        \n', '        uint lasttime = integrate_checkpoint_of[addr];\n', '        if(end == 0) {                                                         // isNonLinear, endless\n', '            if(now.sub(lasttime) < span)\n', '                amount = amount.mul(now.sub(lasttime)).div(span);\n', '        }else if(now < end)\n', '            amount = amount.mul(now.sub(lasttime)).div(end.sub(lasttime));\n', '        else if(lasttime >= end)\n', '            amount = 0;\n', '    }\n', '    \n', '    function _checkpoint(address addr, uint amount) virtual internal {\n', '        if(amount > 0) {\n', '            integrate_fraction[addr] = integrate_fraction[addr].add(amount);\n', '            \n', "            address teamAddr = address(config['teamAddr']);\n", "            uint teamRatio = config['teamRatio'];\n", '            if(teamAddr != address(0) && teamRatio != 0)\n', '                integrate_fraction[teamAddr] = integrate_fraction[teamAddr].add(amount.mul(teamRatio).div(1 ether));\n', '        }\n', '    }\n', '\n', '    function _checkpoint(address addr, bool _claim_rewards) virtual internal {\n', '        uint amount = claimable_tokens(addr);\n', '        _checkpoint(addr, amount);\n', '        _checkpoint_rewards(addr, _claim_rewards);\n', '    \n', '        integrate_checkpoint_of[addr] = now;\n', '    }\n', '    \n', '    function user_checkpoint(address addr) virtual override external returns (bool) {\n', '        _checkpoint(addr, true);\n', '        return true;\n', '    }\n', '\n', '    function integrate_checkpoint() override external view returns (uint) {\n', '        return now;\n', '    }\n', '} \n', '\n', 'contract SExactGauge is LiquidityGauge, Configurable {\n', '    using SafeMath for uint;\n', '    using TransferHelper for address;\n', '    \n', "    bytes32 internal constant _devAddr_         = 'devAddr';\n", "    bytes32 internal constant _devRatio_        = 'devRatio';\n", "    bytes32 internal constant _ecoAddr_         = 'ecoAddr';\n", "    bytes32 internal constant _ecoRatio_        = 'ecoRatio';\n", "    bytes32 internal constant _claim_rewards_   = 'claim_rewards';\n", '    \n', '    address override public minter;\n', '    address override public crv_token;\n', '    address override public lp_token;\n', '    address override public controller;\n', '    address override public voting_escrow;\n', '    mapping(address => uint) override public balanceOf;\n', '    uint override public totalSupply;\n', '    uint override public future_epoch_time;\n', '    \n', '    // caller -> recipient -> can deposit?\n', '    mapping(address => mapping(address => bool)) override public approved_to_deposit;\n', '    \n', '    mapping(address => uint) override public working_balances;\n', '    uint override public working_supply;\n', '    \n', '    // The goal is to be able to calculate ∫(rate * balance / totalSupply dt) from 0 till checkpoint\n', '    // All values are kept in units of being multiplied by 1e18\n', '    int128 override public period;\n', '    uint256[100000000000000000000000000000] override public period_timestamp;\n', '    \n', '    // 1e18 * ∫(rate(t) / totalSupply(t) dt) from 0 till checkpoint\n', '    uint256[100000000000000000000000000000] override public integrate_inv_supply;  // bump epoch when rate() changes\n', '    \n', '    // 1e18 * ∫(rate(t) / totalSupply(t) dt) from (last_action) till checkpoint\n', '    mapping(address => uint) override public integrate_inv_supply_of;\n', '    mapping(address => uint) override public integrate_checkpoint_of;\n', '    \n', '    // ∫(balance * rate(t) / totalSupply(t) dt) from 0 till checkpoint\n', '    // Units: rate * t = already number of coins per address to issue\n', '    mapping(address => uint) override public integrate_fraction;\n', '    \n', '    uint override public inflation_rate;\n', '    \n', '    // For tracking external rewards\n', '    address override public reward_contract;\n', '    address override public rewarded_token;\n', '    \n', '    mapping(address => uint) public reward_integral_;                             // rewarded_token => reward_integral\n', '    mapping(address => mapping(address => uint)) public reward_integral_for_;     // recipient => rewarded_token => reward_integral_for\n', '    mapping(address => mapping(address => uint)) public rewards_for_; \n', '    mapping(address => mapping(address => uint)) public claimed_rewards_for_; \n', '\n', '\tuint public span;\n', '\tuint public end;\n', '\tmapping(address => uint) public sumMiningPerOf;\n', '\tuint public sumMiningPer;\n', '\tuint internal bufReward;                            // obsoleted, instead of integrate_fraction[address(0)]\n', '\tuint public lasttime;                               // repetition of integrate_checkpoint()\n', '\t\n', '\tfunction initialize(address governor, address _minter, address _lp_token) public virtual initializer {\n', '\t    super.initialize(governor);\n', '\t    \n', '\t    minter      = _minter;\n', '\t    crv_token   = Minter(_minter).token();\n', '\t    lp_token    = _lp_token;\n', '\t    IERC20(lp_token).totalSupply();                 // just check\n', '\t    config[_claim_rewards_] = 1;\n', '\t}\n', '    \n', '    function setSpan(uint _span, bool isLinear) virtual external governance {\n', '        span = _span;\n', '        if(isLinear)\n', '            end = now + _span;\n', '        else\n', '            end = 0;\n', '            \n', '        if(lasttime == 0)\n', '            lasttime = now;\n', '    }\n', '    \n', '    function kick(address addr) virtual override external {\n', '        _checkpoint(addr, true);\n', '    }\n', '    \n', '    function set_approve_deposit(address addr, bool can_deposit) virtual override external {\n', '        approved_to_deposit[addr][msg.sender] = can_deposit;\n', '    }\n', '    \n', '    function deposit(uint amount) virtual override external {\n', '        deposit(amount, msg.sender);\n', '    }\n', '    function deposit(uint amount, address addr) virtual override public {\n', "        require(addr == msg.sender || approved_to_deposit[msg.sender][addr], 'Not approved');\n", '\n', '        _checkpoint(addr, config[_claim_rewards_] == 0 ? false : true);\n', '        \n', '        _deposit(addr, amount);\n', '\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(amount);\n', '        totalSupply = totalSupply.add(amount);\n', '        \n', '        emit Deposit(msg.sender, amount);\n', '    }\n', '    function _deposit(address addr, uint amount) virtual internal {\n', '        lp_token.safeTransferFrom(addr, address(this), amount);\n', '    }\n', '    \n', '    function withdraw() virtual external {\n', '        withdraw(balanceOf[msg.sender]);\n', '    }\n', '    function withdraw(uint amount) virtual override public {\n', '        withdraw(amount, config[_claim_rewards_] == 0 ? false : true);\n', '    }\n', '    function withdraw(uint amount, bool _claim_rewards) virtual override public {\n', '        _checkpoint(msg.sender, _claim_rewards);\n', '        \n', '        totalSupply = totalSupply.sub(amount);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\n', '        \n', '        _withdraw(msg.sender, amount);\n', '        \n', '        emit Withdraw(msg.sender, amount);\n', '    }\n', '    function _withdraw(address to, uint amount) virtual internal {\n', '        lp_token.safeTransfer(to, amount);\n', '    }\n', '    \n', '    function claimable_reward(address addr) virtual override public view returns (uint) {\n', '        addr;\n', '        return 0;\n', '    }\n', '\n', '    function claim_rewards() virtual override public {\n', '        return claim_rewards(msg.sender);\n', '    }\n', '    function claim_rewards(address) virtual override public {\n', '        return;\n', '    }\n', '    function _checkpoint_rewards(address, bool) virtual internal {\n', '        return;\n', '    }\n', '    \n', '    function claimable_tokens(address addr) virtual override public view returns (uint r) {\n', '        r = integrate_fraction[addr].sub(Minter(minter).minted(addr, address(this)));\n', '        r = r.add(_claimable_last(addr, claimableDelta(), sumMiningPer, sumMiningPerOf[addr]));\n', '    }\n', '    \n', '    function _claimable_last(address addr, uint delta, uint sumPer, uint lastSumPer) virtual internal view returns (uint amount) {\n', '        if(span == 0 || totalSupply == 0)\n', '            return 0;\n', '        \n', '        amount = sumPer.sub(lastSumPer);\n', '        amount = amount.add(delta.mul(1 ether).div(totalSupply));\n', '        amount = amount.mul(balanceOf[addr]).div(1 ether);\n', '    }\n', '    function claimableDelta() virtual public view returns(uint amount) {\n', '        if(span == 0 || totalSupply == 0)\n', '            return 0;\n', '        \n', '        //amount = SMinter(minter).quotas(address(this)).sub(bufReward);\n', '        amount = SMinter(minter).quotas(address(this)).add(Minter(minter).minted(address(0), address(this))).sub(integrate_fraction[address(0)]);\n', '\n', '        if(end == 0) {                                                         // isNonLinear, endless\n', '            if(now.sub(lasttime) < span)\n', '                amount = amount.mul(now.sub(lasttime)).div(span);\n', '        }else if(now < end)\n', '            amount = amount.mul(now.sub(lasttime)).div(end.sub(lasttime));\n', '        else if(lasttime >= end)\n', '            amount = 0;\n', '    }\n', '\n', '    function _checkpoint(address addr, uint amount) virtual internal {\n', '        if(amount > 0) {\n', '            integrate_fraction[addr] = integrate_fraction[addr].add(amount);\n', '            \n', '            addr = address(config[_devAddr_]);\n', '            uint ratio = config[_devRatio_];\n', '            if(addr != address(0) && ratio != 0)\n', '                integrate_fraction[addr] = integrate_fraction[addr].add(amount.mul(ratio).div(1 ether));\n', '\n', '            addr = address(config[_ecoAddr_]);\n', '            ratio = config[_ecoRatio_];\n', '            if(addr != address(0) && ratio != 0)\n', '                integrate_fraction[addr] = integrate_fraction[addr].add(amount.mul(ratio).div(1 ether));\n', '        }\n', '    }\n', '    \n', '    function _checkpoint(address addr, bool _claim_rewards) virtual internal {\n', '        if(span == 0 || totalSupply == 0)\n', '            return;\n', '        \n', '        uint delta = claimableDelta();\n', '        uint amount = _claimable_last(addr, delta, sumMiningPer, sumMiningPerOf[addr]);\n', '        \n', '        //if(delta != amount)\n', '        //    bufReward = bufReward.add(delta).sub(amount);\n', '        if(delta > 0) {\n', '            integrate_fraction[address(0)] = integrate_fraction[address(0)].add(delta);     // total checked\n', '            sumMiningPer = sumMiningPer.add(delta.mul(1 ether).div(totalSupply));\n', '        }\n', '        if(sumMiningPerOf[addr] != sumMiningPer)\n', '            sumMiningPerOf[addr] = sumMiningPer;\n', '        lasttime = now;\n', '\n', '        _checkpoint(addr, amount);\n', '        _checkpoint_rewards(addr, _claim_rewards);\n', '    }\n', '\n', '    function user_checkpoint(address addr) virtual override external returns (bool) {\n', '        _checkpoint(addr, config[_claim_rewards_] == 0 ? false : true);\n', '        return true;\n', '    }\n', '\n', '    function integrate_checkpoint() override external view returns (uint) {\n', '        return lasttime;\n', '    }\n', '    \n', '    function reward_integral() virtual override external view returns (uint) {\n', '        return reward_integral_[rewarded_token];\n', '    }\n', '    \n', '    function reward_integral_for(address addr) virtual override external view returns (uint) {\n', '        return reward_integral_for_[addr][rewarded_token];\n', '    }\n', '    \n', '    function rewards_for(address addr) virtual override external view returns (uint) {\n', '        return rewards_for_[addr][rewarded_token];\n', '    }\n', '    \n', '    function claimed_rewards_for(address addr) virtual override external view returns (uint) {\n', '        return claimed_rewards_for_[addr][rewarded_token];\n', '    }\n', '} \n', '\n', '\n', 'contract SNestGauge is SExactGauge {\n', '\taddress[] public rewards;\n', '\t//mapping(address => mapping(address =>uint)) internal sumRewardPerOf_;      // recipient => rewarded_token => can sumRewardPerOf            // obsolete, instead of reward_integral_\n', '\t//mapping(address => uint) internal sumRewardPer_;                           // rewarded_token => can sumRewardPerOf                         // obsolete, instead of reward_integral_for_\n', '\n', '\tfunction initialize(address governor, address _minter, address _lp_token, address _nestGauge, address[] memory _moreRewards) public initializer {\n', '\t    super.initialize(governor, _minter, _lp_token);\n', '\t    \n', '\t    reward_contract = _nestGauge;\n', '\t    rewarded_token  = LiquidityGauge(_nestGauge).crv_token();\n', '\t    rewards         = _moreRewards;\n', '\t    rewards.push(rewarded_token);\n', '\t    address rewarded_token2 = LiquidityGauge(_nestGauge).rewarded_token();\n', '\t    if(rewarded_token2 != address(0))\n', '    \t    rewards.push(rewarded_token2);\n', '\t    \n', '\t    LiquidityGauge(_nestGauge).integrate_checkpoint();      // just check\n', '\t    for(uint i=0; i<_moreRewards.length; i++)\n', '\t        IERC20(_moreRewards[i]).totalSupply();              // just check\n', '\t}\n', '    \n', '    function _deposit(address from, uint amount) virtual override internal {\n', '        super._deposit(from, amount);                           // lp_token.safeTransferFrom(from, address(this), amount);\n', '        lp_token.safeApprove(reward_contract, amount);\n', '        LiquidityGauge(reward_contract).deposit(amount);\n', '    }\n', '\n', '    function _withdraw(address to, uint amount) virtual override internal {\n', '        LiquidityGauge(reward_contract).withdraw(amount);\n', '        super._withdraw(to, amount);                            // lp_token.safeTransfer(to, amount);\n', '    }\n', '    \n', '    function claim_rewards(address to) virtual override public {\n', '        if(span == 0 || totalSupply == 0)\n', '            return;\n', '        \n', '        _checkpoint_rewards(to, true);\n', '        \n', '        for(uint i=0; i<rewards.length; i++) {\n', '            uint amount = rewards_for_[to][rewards[i]].sub(claimed_rewards_for_[to][rewards[i]]);\n', '            if(amount > 0) {\n', '                rewards[i].safeTransfer(to, amount);\n', '                claimed_rewards_for_[to][rewards[i]] = rewards_for_[to][rewards[i]];\n', '            }\n', '        }\n', '    }\n', '\n', '    function _checkpoint_rewards(address addr, bool _claim_rewards) virtual override internal {\n', '        if(span == 0 || totalSupply == 0)\n', '            return;\n', '        \n', '        uint[] memory drs = new uint[](rewards.length);\n', '        \n', '        if(_claim_rewards) {\n', '            for(uint i=0; i<drs.length; i++)\n', '                drs[i] = IERC20(rewards[i]).balanceOf(address(this));\n', '                \n', '            Minter(LiquidityGauge(reward_contract).minter()).mint(reward_contract);\n', '            LiquidityGauge(reward_contract).claim_rewards();\n', '            \n', '            for(uint i=0; i<drs.length; i++)\n', '                drs[i] = IERC20(rewards[i]).balanceOf(address(this)).sub(drs[i]);\n', '        }\n', '\n', '        for(uint i=0; i<drs.length; i++) {\n', '            uint amount = _claimable_last(addr, drs[i], reward_integral_[rewards[i]], reward_integral_for_[addr][rewards[i]]);\n', '            if(amount > 0)\n', '                rewards_for_[addr][rewards[i]] = rewards_for_[addr][rewards[i]].add(amount);\n', '            \n', '            if(drs[i] > 0)\n', '                reward_integral_[rewards[i]] = reward_integral_[rewards[i]].add(drs[i].mul(1 ether).div(totalSupply));\n', '            if(reward_integral_for_[addr][rewards[i]] != reward_integral_[rewards[i]])\n', '                reward_integral_for_[addr][rewards[i]] = reward_integral_[rewards[i]];\n', '        }\n', '    }\n', '\n', '    function claimable_reward(address addr) virtual override public view returns (uint r) {\n', '        //uint delta = LiquidityGauge(reward_contract).claimable_tokens(address(this));     // Error: Mutable call in static context\n', '        uint delta = LiquidityGauge(reward_contract).integrate_fraction(address(this)).sub(Minter(LiquidityGauge(reward_contract).minter()).minted(address(this), reward_contract));\n', '        r = _claimable_last(addr, delta, reward_integral_[rewarded_token], reward_integral_for_[addr][rewarded_token]);\n', '        r = r.add(rewards_for_[addr][rewarded_token].sub(claimed_rewards_for_[addr][rewarded_token]));\n', '    }\n', '    \n', '    function claimable_reward2(address addr) virtual public view returns (uint r) {\n', '        uint delta = LiquidityGauge(reward_contract).claimable_reward(address(this)).sub(LiquidityGauge(reward_contract).claimed_rewards_for(address(this)));\n', '        address reward2 = LiquidityGauge(reward_contract).rewarded_token();\n', '        r = _claimable_last(addr, delta, reward_integral_[reward2], reward_integral_for_[addr][reward2]);\n', '        r = r.add(rewards_for_[addr][reward2].sub(claimed_rewards_for_[addr][reward2]));\n', '    }    \n', '\n', '    function claimable_reward(address addr, address reward) virtual public view returns (uint r) {\n', '        r = _claimable_last(addr, 0, reward_integral_[reward], reward_integral_for_[addr][reward]);\n', '        r = r.add(rewards_for_[addr][reward].sub(claimed_rewards_for_[addr][reward]));\n', '    }\n', '    \n', '    function claimed_rewards_for2(address addr) virtual public view returns (uint) {\n', '        return claimed_rewards_for_[addr][LiquidityGauge(reward_contract).rewarded_token()];\n', '    }\n', '    \n', '    function rewards_for2(address addr) virtual public view returns (uint) {\n', '        return rewards_for_[addr][LiquidityGauge(reward_contract).rewarded_token()];\n', '    }\n', '    \n', '}\n', '\n', '\n', 'contract SMinter is Minter, Configurable {\n', '    using SafeMath for uint;\n', '    using Address for address payable;\n', '    using TransferHelper for address;\n', '    \n', "\tbytes32 internal constant _allowContract_   = 'allowContract';\n", "\tbytes32 internal constant _allowlist_       = 'allowlist';\n", "\tbytes32 internal constant _blocklist_       = 'blocklist';\n", '\n', '    address override public token;\n', '    address override public controller;\n', '    mapping(address => mapping(address => uint)) override public minted;                    // user => reward_contract => value\n', '    mapping(address => mapping(address => bool)) override public allowed_to_mint_for;       // minter => user => can mint?\n', '    mapping(address => uint) public quotas;                                                 // reward_contract => quota;\n', '\n', '    function initialize(address governor, address token_) public initializer {\n', '        super.initialize(governor);\n', '        token = token_;\n', '    }\n', '    \n', '    function setGaugeQuota(address gauge, uint quota) public governance {\n', '       quotas[gauge] = quota;\n', '    }\n', '    \n', '    function crossChain(address bridge, uint amount) external governance {\n', '        token.safeTransfer(bridge, amount);\n', '        emit CrossChain(bridge, amount);\n', '    }\n', '    event CrossChain(address indexed bridge, uint amount);\n', '    \n', '    function mint(address gauge) virtual override public {\n', '        mint_for(gauge, msg.sender);   \n', '    }\n', '    \n', '    function mint_many(address[8] calldata gauges) virtual override external {\n', '        for(uint i=0; i<gauges.length; i++)\n', '            mint(gauges[i]);\n', '    }\n', '    \n', '    function mint_many(address[] calldata gauges) virtual external {\n', '        for(uint i=0; i<gauges.length; i++)\n', '            mint(gauges[i]);\n', '    }\n', '    \n', '    function mint_for(address gauge, address _for) virtual override public {\n', "        require(_for == msg.sender || allowed_to_mint_for[msg.sender][_for], 'Not approved');\n", "        require(quotas[gauge] > 0, 'No quota');\n", '        \n', "        require(getConfig(_blocklist_, msg.sender) == 0, 'In blocklist');\n", '        bool isContract = msg.sender.isContract();\n', "        require(!isContract || config[_allowContract_] != 0 || getConfig(_allowlist_, msg.sender) != 0, 'No allowContract');\n", '\n', '        LiquidityGauge(gauge).user_checkpoint(_for);\n', '        uint total_mint = LiquidityGauge(gauge).integrate_fraction(_for);\n', '        uint to_mint = total_mint.sub(minted[_for][gauge]);\n', '    \n', '        if(to_mint != 0) {\n', '            quotas[gauge] = quotas[gauge].sub(to_mint);\n', '            token.safeTransfer(_for, to_mint);\n', '            minted[_for][gauge] = total_mint;\n', '            minted[address(0)][gauge] = minted[address(0)][gauge].add(to_mint);         // total minted of gauge\n', '    \n', '            emit Minted(_for, gauge, total_mint);\n', '        }\n', '    }\n', '    \n', '    function toggle_approve_mint(address minting_user) virtual override external {\n', '        allowed_to_mint_for[minting_user][msg.sender] = !allowed_to_mint_for[minting_user][msg.sender];\n', '    }\n', '}\n', '\n', '/*\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '*/']