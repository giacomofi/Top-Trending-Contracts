['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-05\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', 'contract Manager is Ownable {\n', '    \n', '    address[] managers;\n', '\n', '    modifier onlyManagers() {\n', '        bool exist = false;\n', '        if(owner == msg.sender) {\n', '            exist = true;\n', '        } else {\n', '            uint index = 0;\n', '            (exist, index) = existManager(msg.sender);\n', '        }\n', '        require(exist);\n', '        _;\n', '    }\n', '    \n', '    function getManagers() public view returns (address[] memory){\n', '        return managers;\n', '    }\n', '    \n', '    function existManager(address _to) private view returns (bool, uint) {\n', '        for (uint i = 0 ; i < managers.length; i++) {\n', '            if (managers[i] == _to) {\n', '                return (true, i);\n', '            }\n', '        }\n', '        return (false, 0);\n', '    }\n', '    function addManager(address _to) onlyOwner public {\n', '        bool exist = false;\n', '        uint index = 0;\n', '        (exist, index) = existManager(_to);\n', '        \n', '        require(!exist);\n', '        \n', '        managers.push(_to);\n', '    }\n', '    function deleteManager(address _to) onlyOwner public {\n', '        bool exist = false;\n', '        uint index = 0;\n', '        (exist, index) = existManager(_to);\n', '        \n', '        require(exist);\n', '   \n', '        uint lastElementIndex = managers.length - 1; \n', '        managers[index] = managers[lastElementIndex];\n', '\n', '        delete managers[managers.length - 1];\n', '        managers.length--;\n', '    }\n', '\n', '}\n', '\n', 'contract Pausable is Manager {\n', '    event Pause();\n', '    event Unpause();\n', '\n', '    bool public paused = false;\n', '\n', '    modifier whenNotPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    modifier whenPaused() {\n', '        require(paused);\n', '        _;\n', '    }\n', '\n', '    function pause() onlyManagers whenNotPaused public {\n', '        paused = true;\n', '        emit Pause();\n', '    }\n', '\n', '    function unpause() onlyManagers whenPaused public {\n', '        paused = false;\n', '        emit Unpause();\n', '    }\n', '}\n', '\n', 'contract ERC20 {\n', '    function totalSupply() public view returns (uint256);\n', '    function balanceOf(address who) public view returns (uint256);\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', 'contract Token is ERC20, Pausable {\n', '\n', '    struct sUserInfo {\n', '        uint256 balance;\n', '        bool lock;\n', '        mapping(address => uint256) allowed;\n', '    }\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    uint256 public totalSupply;\n', '\n', '  \n', '\n', '    mapping(address => sUserInfo) user;\n', '\n', '    event Mint(uint256 value);\n', '    event Burn(uint256 value);\n', '\n', '   \n', '    \n', '    function () public payable {\n', '        revert();\n', '    }\n', '    \n', '    function validTransfer(address _from, address _to, uint256 _value, bool _lockCheck) internal view returns (bool) {\n', '        require(_to != address(this));\n', '        require(_to != address(0));\n', '        require(user[_from].balance >= _value);\n', '        if(_lockCheck) {\n', '            require(user[_from].lock == false);\n', '        }\n', '    }\n', '\n', '    function lock(address _owner) public onlyManagers returns (bool) {\n', '        require(user[_owner].lock == false);\n', '       \n', '        user[_owner].lock = true;\n', '        return true;\n', '    }\n', '    function unlock(address _owner) public onlyManagers returns (bool) {\n', '        require(user[_owner].lock == true);\n', '        user[_owner].lock = false;\n', '       return true;\n', '    }\n', ' \n', '    function burn(uint256 _value) public onlyOwner returns (bool) {\n', '        require(_value <= user[msg.sender].balance);\n', '        user[msg.sender].balance = user[msg.sender].balance.sub(_value);\n', '        totalSupply = totalSupply.sub(_value);\n', '        emit Burn(_value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n', '        require(_value == 0 || user[msg.sender].allowed[_spender] == 0); \n', '        user[msg.sender].allowed[_spender] = _value; \n', '        emit Approval(msg.sender, _spender, _value);\n', '        return true;\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        validTransfer(_from, _to, _value, true);\n', '        require(_value <=  user[_from].allowed[msg.sender]);\n', '\n', '        user[_from].balance = user[_from].balance.sub(_value);\n', '        user[_to].balance = user[_to].balance.add(_value);\n', '\n', '        user[_from].allowed[msg.sender] = user[_from].allowed[msg.sender].sub(_value);\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n', '        validTransfer(msg.sender, _to, _value, true);\n', '\n', '        user[msg.sender].balance = user[msg.sender].balance.sub(_value);\n', '        user[_to].balance = user[_to].balance.add(_value);\n', '\n', '        emit Transfer(msg.sender, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    \n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupply;\n', '    }\n', '    function balanceOf(address _owner) public view returns (uint256) {\n', '        return user[_owner].balance;\n', '    }\n', '    function lockState(address _owner) public view returns (bool) {\n', '        return user[_owner].lock;\n', '    }\n', '    function allowance(address _owner, address _spender) public view returns (uint256) {\n', '        return user[_owner].allowed[_spender];\n', '    }\n', '    \n', '}\n', '\n', 'contract LockBalance is Manager {\n', '    \n', '\n', '    struct sLockInfo {\n', '        uint256[] lockBalanceStandard;\n', '        uint256[] endTime;\n', '    }\n', '    \n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => sLockInfo) lockUser;\n', ' \n', '    event Lock(address indexed from, uint256 value, uint256 endTime);\n', '    \n', '    function setLockUser(address _to, uint256 _value, uint256 _endTime) onlyManagers public {\n', '        require(_endTime > now); \n', '        require(_value > 0); \n', '        lockUser[_to].lockBalanceStandard.push(_value);\n', '        lockUser[_to].endTime.push(_endTime);\n', '\n', '        emit Lock(_to, _value, _endTime);\n', '    }\n', '    function setLockUsers(address[] _to, uint256[] _value, uint256[] _endTime) onlyManagers public {  \n', '        \n', '        for(uint256 i = 0; i < _to.length; i++){\n', '            if(lockUser[_to[i]].endTime.length != 0) {\n', '                lockUser[_to[i]].endTime.length = 0;    \n', '            }\n', '            if(lockUser[_to[i]].lockBalanceStandard.length != 0) {\n', '                lockUser[_to[i]].lockBalanceStandard.length = 0;\n', '            }\n', '        }\n', '        addLockUsers(_to, _value, _endTime);\n', '    }\n', '    \n', '    function addLockUsers(address[] _to, uint256[] _value, uint256[] _endTime) onlyManagers public {  \n', '        require(_to.length > 0);\n', '        require(_to.length == _value.length);\n', '        require(_to.length == _endTime.length);\n', '      \n', '        for(uint256 i = 0; i < _to.length; i++){\n', '            setLockUser(_to[i], _value[i], _endTime[i]);\n', '        }\n', '    }\n', '    \n', '  \n', '    function lockBalanceIndividual(address _owner, uint _index) internal view returns (uint256) {\n', '        if(now < lockUser[_owner].endTime[_index]) {\n', '            return lockUser[_owner].lockBalanceStandard[_index];\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    function clearLockUserInfo(address _holder) onlyManagers public {\n', '        lockUser[_holder].endTime.length = 0;\n', '        lockUser[_holder].lockBalanceStandard.length = 0;\n', '    }\n', '    function deleteLockUserInfoIdx(address _holder, uint256 idx) onlyManagers public {\n', '        require(idx < lockUser[_holder].endTime.length);\n', '\n', '        if (idx != lockUser[_holder].endTime.length - 1) {\n', '            lockUser[_holder].endTime[idx] = lockUser[_holder].endTime[lockUser[_holder].endTime.length - 1];\n', '            lockUser[_holder].lockBalanceStandard[idx] = lockUser[_holder].lockBalanceStandard[lockUser[_holder].lockBalanceStandard.length - 1];\n', '        }\n', '        lockUser[_holder].endTime.length--;\n', '        lockUser[_holder].lockBalanceStandard.length--;\n', '        \n', '    }\n', '    function _deleteLockUserInfo(address _to, uint256 _endTime) internal {\n', '\n', '        bool isExists = false;\n', '        uint256 index = 0;\n', '        for(uint256 i = 0; i < lockUser[_to].endTime.length; i++) {\n', '            if(lockUser[_to].endTime[i] == _endTime) {\n', '                isExists = true;\n', '                index = i;\n', '                break;\n', '            }\n', '        }\n', '        require(isExists);\n', '\n', '        deleteLockUserInfoIdx(_to, index);\n', '    }\n', '    function deleteLockUserInfos(address _to, uint256[] _endTime) onlyManagers public {\n', '        for(uint256 i = 0; i < _endTime.length; i++){\n', '            _deleteLockUserInfo(_to, _endTime[i]);\n', '        }\n', '    }\n', '\n', '    function lockUserInfo(address _owner, uint256 idx) public view returns (uint256, uint256) {\n', '        return (\n', '            lockUser[_owner].lockBalanceStandard[idx],\n', '        lockUser[_owner].endTime[idx]);\n', '    }\n', '    function lockUserInfo(address _owner) public view returns (uint256[], uint256[]) {\n', '        \n', '        return (\n', '        lockUser[_owner].lockBalanceStandard,\n', '        lockUser[_owner].endTime);\n', '    }\n', '    function lockBalanceAll(address _owner) public view returns (uint256) {\n', '        uint256 lockBalance = 0;\n', '        for(uint256 i = 0; i < lockUser[_owner].lockBalanceStandard.length; i++){\n', '            lockBalance = lockBalance.add(lockBalanceIndividual(_owner, i));\n', '        }\n', '        return lockBalance;\n', '    }\n', '    \n', '}\n', '\n', 'contract GDGToken is Token, LockBalance {\n', '\n', '    constructor(string memory name_, string memory symbol_, uint8 decimals_, uint256 supply_) public {\n', '        name = name_;\n', '        symbol = symbol_;\n', '        decimals = decimals_;\n', '        uint256 initialSupply = supply_;\n', '        totalSupply = initialSupply * 10 ** uint(decimals);\n', '        user[owner].balance = totalSupply;\n', '        emit Transfer(address(0), owner, totalSupply);\n', '    }\n', '\n', '    bool public finishMint = false; \n', '    bool public finishRestore = false; \n', '    \n', '    function isFinishMint() public onlyOwner { \n', '        finishMint = true; \n', '    }\n', '    function isFinishRestore() public onlyOwner { \n', '        finishRestore = true; \n', '    }     \n', '  \n', '    function validTransfer(address _from, address _to, uint256 _value, bool _lockCheck) internal view returns (bool) {\n', '        super.validTransfer(_from, _to, _value, _lockCheck);\n', '        if(_lockCheck) {\n', '            require(_value <= useBalanceOf(_from));\n', '        }\n', '    }\n', '\n', '    function transferWithtLockUser(address _to, uint256 _amount, uint256[] _lockAmount, uint256[] _endTime) onlyManagers public {  \n', '        require(_lockAmount.length > 0);\n', '        require(_lockAmount.length == _endTime.length);\n', '        \n', '        transfer(_to, _amount);\n', '        \n', '        for(uint256 i = 0; i < _lockAmount.length; i++){\n', '            setLockUser(_to, _lockAmount[i], _endTime[i]);\n', '        }\n', '        \n', '    }\n', ' \n', '    function mint(uint256 _value) public onlyOwner returns (bool) {\n', '        require(!finishMint);\n', '        require(_value > 0);\n', '        user[msg.sender].balance = user[msg.sender].balance.add(_value);\n', '        totalSupply = totalSupply.add(_value);\n', '        emit Transfer(address(0), msg.sender, _value);\n', '        return true;\n', '    }\n', ' \n', '    function transferRestore(address _from, address _to, uint256 _value) public onlyOwner returns (bool) {\n', '        require(!finishRestore);\n', '\n', '        require(_to != address(this));\n', '        require(_to != address(0));\n', '        require(user[_from].balance >= _value);\n', '        \n', '        user[_from].balance = user[_from].balance.sub(_value);\n', '        user[_to].balance = user[_to].balance.add(_value);\n', '\n', '        emit Transfer(_from, _to, _value);\n', '        return true;\n', '    }\n', '    function useBalanceOf(address _owner) public view returns (uint256) {\n', '        return balanceOf(_owner).sub(lockBalanceAll(_owner));\n', '    }\n', '  \n', '\n', '}']