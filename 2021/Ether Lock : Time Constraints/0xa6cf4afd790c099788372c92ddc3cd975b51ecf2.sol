['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-05\n', '*/\n', '\n', '// File: contracts/interface/IXPool.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'interface IXPool {\n', '    // XPToken\n', '    event Approval(address indexed src, address indexed dst, uint256 amt);\n', '    event Transfer(address indexed src, address indexed dst, uint256 amt);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address whom) external view returns (uint256);\n', '\n', '    function allowance(address src, address dst)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address dst, uint256 amt) external returns (bool);\n', '\n', '    function transfer(address dst, uint256 amt) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address src,\n', '        address dst,\n', '        uint256 amt\n', '    ) external returns (bool);\n', '\n', '    // Swap\n', '    function swapExactAmountIn(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        address tokenOut,\n', '        uint256 minAmountOut,\n', '        uint256 maxPrice\n', '    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n', '\n', '    function swapExactAmountOut(\n', '        address tokenIn,\n', '        uint256 maxAmountIn,\n', '        address tokenOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 maxPrice\n', '    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n', '\n', '    // Referral\n', '    function swapExactAmountInRefer(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        address tokenOut,\n', '        uint256 minAmountOut,\n', '        uint256 maxPrice,\n', '        address referrer\n', '    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n', '\n', '    function swapExactAmountOutRefer(\n', '        address tokenIn,\n', '        uint256 maxAmountIn,\n', '        address tokenOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 maxPrice,\n', '        address referrer\n', '    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n', '\n', '    // Pool Data\n', '    function isBound(address token) external view returns (bool);\n', '\n', '    function getFinalTokens() external view returns (address[] memory tokens);\n', '\n', '    function getBalance(address token) external view returns (uint256);\n', '\n', '    function swapFee() external view returns (uint256);\n', '\n', '    function exitFee() external view returns (uint256);\n', '\n', '    function finalized() external view returns (uint256);\n', '\n', '    function controller() external view returns (uint256);\n', '\n', '    function xconfig() external view returns (uint256);\n', '\n', '    function getDenormalizedWeight(address) external view returns (uint256);\n', '\n', '    function getTotalDenormalizedWeight() external view returns (uint256);\n', '\n', '    function getVersion() external view returns (bytes32);\n', '\n', '    function calcInGivenOut(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 _swapFee\n', '    ) external pure returns (uint256 tokenAmountIn);\n', '\n', '    function calcOutGivenIn(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 tokenAmountIn,\n', '        uint256 _swapFee\n', '    ) external pure returns (uint256 tokenAmountOut);\n', '\n', '    // Pool Managment\n', '    function setController(address _controller) external;\n', '\n', '    function setExitFee(uint256 newFee) external;\n', '\n', '    function finalize(uint256 _swapFee) external;\n', '\n', '    function bind(address token, uint256 denorm) external;\n', '\n', '    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\n', '        external;\n', '\n', '    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n', '        external;\n', '\n', '    function joinswapExternAmountIn(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        uint256 minPoolAmountOut\n', '    ) external returns (uint256 poolAmountOut);\n', '\n', '    function exitswapPoolAmountIn(\n', '        address tokenOut,\n', '        uint256 poolAmountIn,\n', '        uint256 minAmountOut\n', '    ) external returns (uint256 tokenAmountOut);\n', '\n', '    // Pool Governance\n', '    function updateSafu(address safu, uint256 fee) external;\n', '\n', '    function updateFarm(bool isFarm) external;\n', '}\n', '\n', '// File: contracts/interface/IXFactory.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', 'interface IXFactory {\n', '    function newXPool() external returns (IXPool);\n', '}\n', '\n', '// File: contracts/interface/IXConfig.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'interface IXConfig {\n', '    function getCore() external view returns (address);\n', '\n', '    function getSAFU() external view returns (address);\n', '\n', '    function isFarmPool(address pool) external view returns (bool);\n', '\n', '    function getMaxExitFee() external view returns (uint256);\n', '\n', '    function getSafuFee() external view returns (uint256);\n', '\n', '    function getSwapProxy() external view returns (address);\n', '\n', '    function ethAddress() external pure returns (address);\n', '\n', '    function hasPool(address[] calldata tokens, uint256[] calldata denorms)\n', '        external\n', '        view\n', '        returns (bool exist, bytes32 sig);\n', '\n', '    // add by XSwapProxy\n', '    function addPoolSig(bytes32 sig) external;\n', '\n', '    // remove by XSwapProxy\n', '    function removePoolSig(bytes32 sig) external;\n', '}\n', '\n', '// File: contracts/interface/IERC20.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    ) external returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        external\n', '        view\n', '        returns (uint256 remaining);\n', '}\n', '\n', '// File: contracts/lib/XNum.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'library XNum {\n', '    uint256 public constant BONE = 10**18;\n', '    uint256 public constant MIN_BPOW_BASE = 1 wei;\n', '    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n', '    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n', '\n', '    function btoi(uint256 a) internal pure returns (uint256) {\n', '        return a / BONE;\n', '    }\n', '\n', '    function bfloor(uint256 a) internal pure returns (uint256) {\n', '        return btoi(a) * BONE;\n', '    }\n', '\n', '    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ERR_ADD_OVERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        (uint256 c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint256 c1 = c0 + (BONE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint256 c2 = c1 / BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint256 c0 = a * BONE;\n', '        require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint256 c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint256 c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    // DSMath.wpow\n', '    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n', '        uint256 z = n % 2 != 0 ? a : BONE;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            a = bmul(a, a);\n', '\n', '            if (n % 2 != 0) {\n', '                z = bmul(z, a);\n', '            }\n', '        }\n', '        return z;\n', '    }\n', '\n', '    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n', '    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n', '    // of approximation of b^0.w\n', '    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n', '        require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");\n', '        require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");\n', '\n', '        uint256 whole = bfloor(exp);\n', '        uint256 remain = bsub(exp, whole);\n', '\n', '        uint256 wholePow = bpowi(base, btoi(whole));\n', '\n', '        if (remain == 0) {\n', '            return wholePow;\n', '        }\n', '\n', '        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n', '        return bmul(wholePow, partialResult);\n', '    }\n', '\n', '    function bpowApprox(\n', '        uint256 base,\n', '        uint256 exp,\n', '        uint256 precision\n', '    ) internal pure returns (uint256) {\n', '        // term 0:\n', '        uint256 a = exp;\n', '        (uint256 x, bool xneg) = bsubSign(base, BONE);\n', '        uint256 term = BONE;\n', '        uint256 sum = term;\n', '        bool negative = false;\n', '\n', '        // term(k) = numer / denom\n', '        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\n', '        // each iteration, multiply previous term by (a-(k-1)) * x / k\n', '        // continue until term is less than precision\n', '        for (uint256 i = 1; term >= precision; i++) {\n', '            uint256 bigK = i * BONE;\n', '            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n', '            term = bmul(term, bmul(c, x));\n', '            term = bdiv(term, bigK);\n', '            if (term == 0) break;\n', '\n', '            if (xneg) negative = !negative;\n', '            if (cneg) negative = !negative;\n', '            if (negative) {\n', '                sum = bsub(sum, term);\n', '            } else {\n', '                sum = badd(sum, term);\n', '            }\n', '        }\n', '\n', '        return sum;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Address.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/Address.sol\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash =\n', '            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            codehash := extcodehash(account)\n', '        }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account)\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(\n', '            address(this).balance >= amount,\n', '            "Address: insufficient balance"\n', '        );\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount).gas(9100)("");\n', '        require(\n', '            success,\n', '            "Address: unable to send value, recipient may have reverted"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/lib/SafeERC20.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/token/ERC20/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transfer.selector, to, value)\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n', '        );\n', '    }\n', '\n', '    function safeApprove(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require(\n', '            (value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.approve.selector, spender, value)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(\n', '                abi.decode(returndata, (bool)),\n', '                "SafeERC20: ERC20 operation did not succeed"\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ReentrancyGuard.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/ReentrancyGuard.sol\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' *\n', ' * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n', ' * metering changes introduced in the Istanbul hardfork.\n', ' */\n', 'contract ReentrancyGuard {\n', '    bool private _notEntered;\n', '\n', '    constructor() internal {\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '\n', '// File: contracts/XSwapProxyV1.sol\n', '\n', 'pragma solidity 0.5.17;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// WETH9\n', 'interface IWETH {\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address, uint256) external returns (bool);\n', '\n', '    function transfer(address to, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    function deposit() external payable;\n', '\n', '    function withdraw(uint256 amount) external;\n', '}\n', '\n', 'contract XSwapProxyV1 is ReentrancyGuard {\n', '    using XNum for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    uint256 public constant MAX = 2**256 - 1;\n', '    uint256 public constant BONE = 10**18;\n', '    uint256 public constant MIN_BOUND_TOKENS = 2;\n', '    uint256 public constant MAX_BOUND_TOKENS = 8;\n', '\n', '    uint256 public constant MIN_BATCH_SWAPS = 1;\n', '    uint256 public constant MAX_BATCH_SWAPS = 4;\n', '\n', '    // WETH9\n', '    IWETH weth;\n', '\n', '    IXConfig public xconfig;\n', '\n', '    constructor(address _weth, address _xconfig) public {\n', '        weth = IWETH(_weth);\n', '        xconfig = IXConfig(_xconfig);\n', '    }\n', '\n', '    function() external payable {}\n', '\n', '    // Batch Swap\n', '    struct Swap {\n', '        address pool;\n', '        uint256 tokenInParam; // tokenInAmount / maxAmountIn\n', '        uint256 tokenOutParam; // minAmountOut / tokenAmountOut\n', '        uint256 maxPrice;\n', '    }\n', '\n', '    function batchSwapExactIn(\n', '        Swap[] memory swaps,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 totalAmountIn,\n', '        uint256 minTotalAmountOut\n', '    ) public payable returns (uint256 totalAmountOut) {\n', '        return\n', '            batchSwapExactInRefer(\n', '                swaps,\n', '                tokenIn,\n', '                tokenOut,\n', '                totalAmountIn,\n', '                minTotalAmountOut,\n', '                address(0x0)\n', '            );\n', '    }\n', '\n', '    function batchSwapExactInRefer(\n', '        Swap[] memory swaps,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 totalAmountIn,\n', '        uint256 minTotalAmountOut,\n', '        address referrer\n', '    ) public payable nonReentrant returns (uint256 totalAmountOut) {\n', '        require(\n', '            swaps.length >= MIN_BATCH_SWAPS && swaps.length <= MAX_BATCH_SWAPS,\n', '            "ERR_BATCH_COUNT"\n', '        );\n', '\n', '        IERC20 TI = IERC20(tokenIn);\n', '        IERC20 TO = IERC20(tokenOut);\n', '\n', '        transferFromAllTo(TI, totalAmountIn, address(this));\n', '\n', '        uint256 actualTotalIn = 0;\n', '        for (uint256 i = 0; i < swaps.length; i++) {\n', '            Swap memory swap = swaps[i];\n', '            IXPool pool = IXPool(swap.pool);\n', '\n', '            if (TI.allowance(address(this), swap.pool) < totalAmountIn) {\n', '                TI.safeApprove(swap.pool, 0);\n', '                TI.safeApprove(swap.pool, MAX);\n', '            }\n', '\n', '            (uint256 tokenAmountOut, ) =\n', '                pool.swapExactAmountInRefer(\n', '                    tokenIn,\n', '                    swap.tokenInParam,\n', '                    tokenOut,\n', '                    swap.tokenOutParam,\n', '                    swap.maxPrice,\n', '                    referrer\n', '                );\n', '\n', '            actualTotalIn = actualTotalIn.badd(swap.tokenInParam);\n', '            totalAmountOut = tokenAmountOut.badd(totalAmountOut);\n', '        }\n', '        require(actualTotalIn <= totalAmountIn, "ERR_ACTUAL_IN");\n', '        require(totalAmountOut >= minTotalAmountOut, "ERR_LIMIT_OUT");\n', '\n', '        transferAll(TO, totalAmountOut);\n', '        transferAll(TI, getBalance(tokenIn));\n', '        return totalAmountOut;\n', '    }\n', '\n', '    function batchSwapExactOut(\n', '        Swap[] memory swaps,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 maxTotalAmountIn\n', '    ) public payable returns (uint256 totalAmountIn) {\n', '        return\n', '            batchSwapExactOutRefer(\n', '                swaps,\n', '                tokenIn,\n', '                tokenOut,\n', '                maxTotalAmountIn,\n', '                address(0x0)\n', '            );\n', '    }\n', '\n', '    function batchSwapExactOutRefer(\n', '        Swap[] memory swaps,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 maxTotalAmountIn,\n', '        address referrer\n', '    ) public payable nonReentrant returns (uint256 totalAmountIn) {\n', '        require(\n', '            swaps.length >= MIN_BATCH_SWAPS && swaps.length <= MAX_BATCH_SWAPS,\n', '            "ERR_BATCH_COUNT"\n', '        );\n', '\n', '        IERC20 TI = IERC20(tokenIn);\n', '        IERC20 TO = IERC20(tokenOut);\n', '\n', '        transferFromAllTo(TI, maxTotalAmountIn, address(this));\n', '\n', '        for (uint256 i = 0; i < swaps.length; i++) {\n', '            Swap memory swap = swaps[i];\n', '            IXPool pool = IXPool(swap.pool);\n', '\n', '            if (TI.allowance(address(this), swap.pool) < maxTotalAmountIn) {\n', '                TI.safeApprove(swap.pool, 0);\n', '                TI.safeApprove(swap.pool, MAX);\n', '            }\n', '\n', '            (uint256 tokenAmountIn, ) =\n', '                pool.swapExactAmountOutRefer(\n', '                    tokenIn,\n', '                    swap.tokenInParam,\n', '                    tokenOut,\n', '                    swap.tokenOutParam,\n', '                    swap.maxPrice,\n', '                    referrer\n', '                );\n', '            totalAmountIn = tokenAmountIn.badd(totalAmountIn);\n', '        }\n', '        require(totalAmountIn <= maxTotalAmountIn, "ERR_LIMIT_IN");\n', '\n', '        transferAll(TO, getBalance(tokenOut));\n', '        transferAll(TI, getBalance(tokenIn));\n', '    }\n', '\n', '    // Multihop Swap\n', '    struct MSwap {\n', '        address pool;\n', '        address tokenIn;\n', '        address tokenOut;\n', '        uint256 swapAmount; // tokenInAmount / tokenOutAmount\n', '        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n', '        uint256 maxPrice;\n', '    }\n', '\n', '    function multihopBatchSwapExactIn(\n', '        MSwap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 totalAmountIn,\n', '        uint256 minTotalAmountOut\n', '    ) public payable returns (uint256 totalAmountOut) {\n', '        return\n', '            multihopBatchSwapExactInRefer(\n', '                swapSequences,\n', '                tokenIn,\n', '                tokenOut,\n', '                totalAmountIn,\n', '                minTotalAmountOut,\n', '                address(0x0)\n', '            );\n', '    }\n', '\n', '    function multihopBatchSwapExactInRefer(\n', '        MSwap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 totalAmountIn,\n', '        uint256 minTotalAmountOut,\n', '        address referrer\n', '    ) public payable nonReentrant returns (uint256 totalAmountOut) {\n', '        require(\n', '            swapSequences.length >= MIN_BATCH_SWAPS &&\n', '                swapSequences.length <= MAX_BATCH_SWAPS,\n', '            "ERR_BATCH_COUNT"\n', '        );\n', '\n', '        transferFromAllTo(IERC20(tokenIn), totalAmountIn, address(this));\n', '\n', '        uint256 actualTotalIn = 0;\n', '        for (uint256 i = 0; i < swapSequences.length; i++) {\n', '            require(tokenIn == swapSequences[i][0].tokenIn, "ERR_NOT_MATCH");\n', '            actualTotalIn = actualTotalIn.badd(swapSequences[i][0].swapAmount);\n', '\n', '            uint256 tokenAmountOut = 0;\n', '            for (uint256 k = 0; k < swapSequences[i].length; k++) {\n', '                MSwap memory swap = swapSequences[i][k];\n', '\n', '                IERC20 SwapTokenIn = IERC20(swap.tokenIn);\n', '                if (k == 1) {\n', '                    // Makes sure that on the second swap the output of the first was used\n', '                    // so there is not intermediate token leftover\n', '                    swap.swapAmount = tokenAmountOut;\n', '                }\n', '\n', '                IXPool pool = IXPool(swap.pool);\n', '                if (\n', '                    SwapTokenIn.allowance(address(this), swap.pool) <\n', '                    totalAmountIn\n', '                ) {\n', '                    SwapTokenIn.safeApprove(swap.pool, 0);\n', '                    SwapTokenIn.safeApprove(swap.pool, MAX);\n', '                }\n', '\n', '                (tokenAmountOut, ) = pool.swapExactAmountInRefer(\n', '                    swap.tokenIn,\n', '                    swap.swapAmount,\n', '                    swap.tokenOut,\n', '                    swap.limitReturnAmount,\n', '                    swap.maxPrice,\n', '                    referrer\n', '                );\n', '            }\n', '            // This takes the amountOut of the last swap\n', '            totalAmountOut = tokenAmountOut.badd(totalAmountOut);\n', '        }\n', '\n', '        require(actualTotalIn <= totalAmountIn, "ERR_ACTUAL_IN");\n', '        require(totalAmountOut >= minTotalAmountOut, "ERR_LIMIT_OUT");\n', '\n', '        transferAll(IERC20(tokenOut), totalAmountOut);\n', '        transferAll(IERC20(tokenIn), getBalance(tokenIn));\n', '    }\n', '\n', '    function multihopBatchSwapExactOut(\n', '        MSwap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 maxTotalAmountIn\n', '    ) public payable returns (uint256 totalAmountIn) {\n', '        return\n', '            multihopBatchSwapExactOutRefer(\n', '                swapSequences,\n', '                tokenIn,\n', '                tokenOut,\n', '                maxTotalAmountIn,\n', '                address(0x0)\n', '            );\n', '    }\n', '\n', '    function multihopBatchSwapExactOutRefer(\n', '        MSwap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 maxTotalAmountIn,\n', '        address referrer\n', '    ) public payable nonReentrant returns (uint256 totalAmountIn) {\n', '        require(\n', '            swapSequences.length >= MIN_BATCH_SWAPS &&\n', '                swapSequences.length <= MAX_BATCH_SWAPS,\n', '            "ERR_BATCH_COUNT"\n', '        );\n', '\n', '        transferFromAllTo(IERC20(tokenIn), maxTotalAmountIn, address(this));\n', '\n', '        for (uint256 i = 0; i < swapSequences.length; i++) {\n', '            require(tokenIn == swapSequences[i][0].tokenIn, "ERR_NOT_MATCH");\n', '\n', '            uint256 tokenAmountInFirstSwap;\n', '            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n', '            if (swapSequences[i].length == 1) {\n', '                MSwap memory swap = swapSequences[i][0];\n', '                IERC20 SwapTokenIn = IERC20(swap.tokenIn);\n', '\n', '                IXPool pool = IXPool(swap.pool);\n', '                if (\n', '                    SwapTokenIn.allowance(address(this), swap.pool) <\n', '                    maxTotalAmountIn\n', '                ) {\n', '                    SwapTokenIn.safeApprove(swap.pool, 0);\n', '                    SwapTokenIn.safeApprove(swap.pool, MAX);\n', '                }\n', '\n', '                (tokenAmountInFirstSwap, ) = pool.swapExactAmountOutRefer(\n', '                    swap.tokenIn,\n', '                    swap.limitReturnAmount,\n', '                    swap.tokenOut,\n', '                    swap.swapAmount,\n', '                    swap.maxPrice,\n', '                    referrer\n', '                );\n', '            } else {\n', '                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n', '                // of token C. But first we need to buy B with A so we can then buy C with B\n', "                // To get the exact amount of C we then first need to calculate how much B we'll need:\n", '                uint256 intermediateTokenAmount;\n', '                // This would be token B as described above\n', '                MSwap memory secondSwap = swapSequences[i][1];\n', '                IXPool poolSecondSwap = IXPool(secondSwap.pool);\n', '                intermediateTokenAmount = poolSecondSwap.calcInGivenOut(\n', '                    poolSecondSwap.getBalance(secondSwap.tokenIn),\n', '                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenIn),\n', '                    poolSecondSwap.getBalance(secondSwap.tokenOut),\n', '                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenOut),\n', '                    secondSwap.swapAmount,\n', '                    poolSecondSwap.swapFee()\n', '                );\n', '\n', '                //// Buy intermediateTokenAmount of token B with A in the first pool\n', '                MSwap memory firstSwap = swapSequences[i][0];\n', '                IERC20 FirstSwapTokenIn = IERC20(firstSwap.tokenIn);\n', '                IXPool poolFirstSwap = IXPool(firstSwap.pool);\n', '                if (\n', '                    FirstSwapTokenIn.allowance(address(this), firstSwap.pool) <\n', '                    MAX\n', '                ) {\n', '                    FirstSwapTokenIn.safeApprove(firstSwap.pool, 0);\n', '                    FirstSwapTokenIn.safeApprove(firstSwap.pool, MAX);\n', '                }\n', '\n', '                (tokenAmountInFirstSwap, ) = poolFirstSwap.swapExactAmountOut(\n', '                    firstSwap.tokenIn,\n', '                    firstSwap.limitReturnAmount,\n', '                    firstSwap.tokenOut,\n', '                    intermediateTokenAmount, // This is the amount of token B we need\n', '                    firstSwap.maxPrice\n', '                );\n', '\n', '                //// Buy the final amount of token C desired\n', '                IERC20 SecondSwapTokenIn = IERC20(secondSwap.tokenIn);\n', '                if (\n', '                    SecondSwapTokenIn.allowance(\n', '                        address(this),\n', '                        secondSwap.pool\n', '                    ) < MAX\n', '                ) {\n', '                    SecondSwapTokenIn.safeApprove(secondSwap.pool, 0);\n', '                    SecondSwapTokenIn.safeApprove(secondSwap.pool, MAX);\n', '                }\n', '\n', '                poolSecondSwap.swapExactAmountOut(\n', '                    secondSwap.tokenIn,\n', '                    secondSwap.limitReturnAmount,\n', '                    secondSwap.tokenOut,\n', '                    secondSwap.swapAmount,\n', '                    secondSwap.maxPrice\n', '                );\n', '            }\n', '            totalAmountIn = tokenAmountInFirstSwap.badd(totalAmountIn);\n', '        }\n', '\n', '        require(totalAmountIn <= maxTotalAmountIn, "ERR_LIMIT_IN");\n', '\n', '        transferAll(IERC20(tokenOut), getBalance(tokenOut));\n', '        transferAll(IERC20(tokenIn), getBalance(tokenIn));\n', '    }\n', '\n', '    // Pool Management\n', '    function create(\n', '        address factoryAddress,\n', '        address[] calldata tokens,\n', '        uint256[] calldata balances,\n', '        uint256[] calldata denorms,\n', '        uint256 swapFee,\n', '        uint256 exitFee\n', '    ) external payable nonReentrant returns (address) {\n', '        require(tokens.length == balances.length, "ERR_LENGTH_MISMATCH");\n', '        require(tokens.length == denorms.length, "ERR_LENGTH_MISMATCH");\n', '        require(tokens.length >= MIN_BOUND_TOKENS, "ERR_MIN_TOKENS");\n', '        require(tokens.length <= MAX_BOUND_TOKENS, "ERR_MAX_TOKENS");\n', '\n', '        // check pool exist\n', '        (bool exist, bytes32 sig) = xconfig.hasPool(tokens, denorms);\n', '        require(!exist, "ERR_POOL_EXISTS");\n', '\n', '        // create new pool\n', '        IXPool pool = IXFactory(factoryAddress).newXPool();\n', '        bool hasETH = false;\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            if (\n', '                transferFromAllTo(IERC20(tokens[i]), balances[i], address(pool))\n', '            ) {\n', '                hasETH = true;\n', '                pool.bind(address(weth), denorms[i]);\n', '            } else {\n', '                pool.bind(tokens[i], denorms[i]);\n', '            }\n', '        }\n', '        require(msg.value == 0 || hasETH, "ERR_INVALID_PAY");\n', '        pool.setExitFee(exitFee);\n', '        pool.finalize(swapFee);\n', '\n', '        xconfig.addPoolSig(sig);\n', '        pool.transfer(msg.sender, pool.balanceOf(address(this)));\n', '\n', '        return address(pool);\n', '    }\n', '\n', '    function joinPool(\n', '        address poolAddress,\n', '        uint256 poolAmountOut,\n', '        uint256[] calldata maxAmountsIn\n', '    ) external payable nonReentrant {\n', '        IXPool pool = IXPool(poolAddress);\n', '\n', '        address[] memory tokens = pool.getFinalTokens();\n', '        require(maxAmountsIn.length == tokens.length, "ERR_LENGTH_MISMATCH");\n', '\n', '        bool hasEth = false;\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            if (msg.value > 0 && tokens[i] == address(weth)) {\n', '                transferFromAllAndApprove(\n', '                    xconfig.ethAddress(),\n', '                    maxAmountsIn[i],\n', '                    poolAddress\n', '                );\n', '                hasEth = true;\n', '            } else {\n', '                transferFromAllAndApprove(\n', '                    tokens[i],\n', '                    maxAmountsIn[i],\n', '                    poolAddress\n', '                );\n', '            }\n', '        }\n', '        require(msg.value == 0 || hasEth, "ERR_INVALID_PAY");\n', '        pool.joinPool(poolAmountOut, maxAmountsIn);\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            if (hasEth) {\n', '                transferAll(\n', '                    IERC20(xconfig.ethAddress()),\n', '                    getBalance(xconfig.ethAddress())\n', '                );\n', '            } else {\n', '                transferAll(IERC20(tokens[i]), getBalance(tokens[i]));\n', '            }\n', '        }\n', '        pool.transfer(msg.sender, pool.balanceOf(address(this)));\n', '    }\n', '\n', '    function joinswapExternAmountIn(\n', '        address poolAddress,\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        uint256 minPoolAmountOut\n', '    ) external payable nonReentrant {\n', '        IXPool pool = IXPool(poolAddress);\n', '\n', '        bool hasEth = false;\n', '        if (transferFromAllAndApprove(tokenIn, tokenAmountIn, poolAddress)) {\n', '            hasEth = true;\n', '        }\n', '        require(msg.value == 0 || hasEth, "ERR_INVALID_PAY");\n', '\n', '        if (hasEth) {\n', '            uint256 poolAmountOut =\n', '                pool.joinswapExternAmountIn(\n', '                    address(weth),\n', '                    tokenAmountIn,\n', '                    minPoolAmountOut\n', '                );\n', '            pool.transfer(msg.sender, poolAmountOut);\n', '        } else {\n', '            uint256 poolAmountOut =\n', '                pool.joinswapExternAmountIn(\n', '                    tokenIn,\n', '                    tokenAmountIn,\n', '                    minPoolAmountOut\n', '                );\n', '            pool.transfer(msg.sender, poolAmountOut);\n', '        }\n', '    }\n', '\n', '    // Internal\n', '    function getBalance(address token) internal view returns (uint256) {\n', '        if (token == xconfig.ethAddress()) {\n', '            return weth.balanceOf(address(this));\n', '        }\n', '        return IERC20(token).balanceOf(address(this));\n', '    }\n', '\n', '    function transferAll(IERC20 token, uint256 amount) internal returns (bool) {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        if (address(token) == xconfig.ethAddress()) {\n', '            weth.withdraw(amount);\n', '            (bool xfer, ) = msg.sender.call.value(amount).gas(9100)("");\n', '            require(xfer, "ERR_ETH_FAILED");\n', '        } else {\n', '            token.safeTransfer(msg.sender, amount);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function transferFromAllTo(\n', '        IERC20 token,\n', '        uint256 amount,\n', '        address to\n', '    ) internal returns (bool hasETH) {\n', '        hasETH = false;\n', '        if (address(token) == xconfig.ethAddress()) {\n', '            require(amount == msg.value, "ERR_TOKEN_AMOUNT");\n', '            weth.deposit.value(amount)();\n', '            weth.transfer(to, amount);\n', '            hasETH = true;\n', '        } else {\n', '            token.safeTransferFrom(msg.sender, to, amount);\n', '        }\n', '    }\n', '\n', '    function transferFromAllAndApprove(\n', '        address token,\n', '        uint256 amount,\n', '        address spender\n', '    ) internal returns (bool hasETH) {\n', '        hasETH = false;\n', '        if (token == xconfig.ethAddress()) {\n', '            require(amount == msg.value, "ERR_TOKEN_AMOUNT");\n', '            weth.deposit.value(amount)();\n', '            if (weth.allowance(address(this), spender) < amount) {\n', '                IERC20(address(weth)).safeApprove(spender, 0);\n', '                IERC20(address(weth)).safeApprove(spender, amount);\n', '            }\n', '            hasETH = true;\n', '        } else {\n', '            IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n', '            if (IERC20(token).allowance(address(this), spender) < amount) {\n', '                IERC20(token).safeApprove(spender, 0);\n', '                IERC20(token).safeApprove(spender, amount);\n', '            }\n', '        }\n', '    }\n', '}']