['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC20.sol";\n', '\n', '\n', 'contract NekoCoin is ERC20 {\n', '\n', '    struct CatImgs {\n', '        uint256 _tail;\n', '        mapping (uint256 => string) _list;\n', '    }\n', '    \n', '    uint256 private _total_cat_imgs;\n', '    address owner;\n', '\n', '    address public_listing;\n', '    address swap_fund;\n', '    address reserve;\n', '    address founders;\n', '    address vitalik;\n', '    \n', '    uint256 remain_ecosystem_fund;\n', '    uint256 mining_reward_amount;\n', '    \n', '    mapping (address => CatImgs) private _my_cat_img_list; // address -> List[img_hash]\n', '    mapping (string => uint256) private _total_cat_img_set; // img_hash -> img_index\n', '    mapping (uint256 => string) private _total_cat_img_list; // index -> img_hash\n', '    mapping (address => bool) private _ban_list;\n', '\n', '    event ImgAdded(address from, uint256 img_index, uint256 uploader_img_index);\n', '    event Ban(address indexed banned);\n', '    event RewardUpdate(uint256 reward_amount);\n', '\n', '    constructor() ERC20("Nekocoin", "NEKO")\n', '    {\n', '        owner = msg.sender;\n', '        _total_cat_imgs = 0;\n', '        \n', '        uint256 T = 10 ** 12;\n', '        uint256 d = 10 ** uint(decimals());\n', '\n', '        mining_reward_amount = 50 * d;\n', '        \n', '        // public listing\n', '        public_listing = address(0x3DC64Fa16D702ca27775909BD4854F588C7F7447);\n', '        _mint(public_listing, (100*T) * d ); \n', '\n', '        // swap_fund\n', '        swap_fund = address(0x6f32D91F08112E71C4A84DDb1fC04F72940D77a5);\n', '        _mint(swap_fund, (100*T) * d ); \n', '        \n', '        // Ecosystem Fund\n', '        // ecosystem_fund = address(0x492097ea00C166a839d049bC6e685e6327D40717);\n', '        // _mint(ecosystem_fund, (15*T) * d );\n', '        remain_ecosystem_fund = (150*T) * d;\n', '        \n', '        //Reserve\n', '        reserve = address(0x33b0f66B09B6B5751E1b49BD70eFC8cF6217b2b0);\n', '        _mint(reserve, (150*T) * d );\n', '\n', '        //Founders\n', '        founders = address(0x9bBc0266168673a90219Fa11A693a663E5593ca0);\n', '        _mint(founders, (100*T) * d );\n', '        \n', '        //Vitalik Buterin\n', '        vitalik = address(0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B);\n', '        _mint(vitalik, (400*T) * d );\n', '    }\n', '    \n', '\n', '    function is_exist_hash(string memory img_hash) public view returns (bool) {\n', '        // return true if img has is already exist, else return false.\n', '        if(_total_cat_img_set[img_hash] == uint256(0x0))\n', '            return false;\n', '        return true;\n', '    }\n', '\n', '    function get_cat_hash(uint256 index) public view returns (string memory) {\n', '        // return img hash from specific index\n', '        return _total_cat_img_list[index];\n', '    }\n', '\n', '    function total_cat_img() public view returns (uint256) {    \n', '         // returns total number of img hash\n', '        return _total_cat_imgs;\n', '    }\n', '\n', '    function get_my_cat_img_count() public view returns (uint256) {\n', '        return _my_cat_img_list[msg.sender]._tail;\n', '    }\n', '\n', '    function get_my_cat_img_hash(uint256 index) public view returns (string memory) {\n', '        return _my_cat_img_list[msg.sender]._list[index];\n', '    }\n', '\n', '    function get_remain_ecosystem_fund() public view returns (uint256) {\n', '        \n', '        return remain_ecosystem_fund;\n', '    }\n', '\n', '    function store_cat_img(string memory img_hash) public returns (uint256) {\n', '\n', '        uint256 my_cat_img_idx; \n', '\n', '        if(_ban_list[msg.sender] == true)\n', '            revert("ban user");\n', '        if(is_exist_hash(img_hash) == true)\n', '            revert("already uploaded");\n', '        if(bytes(img_hash).length != 32)\n', '            revert("invalid hash");\n', '\n', '        // store _total_cat_img_set & _total_cat_img_set\n', '        _total_cat_img_list[_total_cat_imgs] = img_hash;\n', '        _total_cat_img_set[img_hash] = _total_cat_imgs;\n', '        _total_cat_imgs++;\n', '        \n', '        // store  _my_cat_img_list        \n', '        my_cat_img_idx = _my_cat_img_list[msg.sender]._tail;\n', '        _my_cat_img_list[msg.sender]._list[my_cat_img_idx] = img_hash;\n', '        _my_cat_img_list[msg.sender]._tail++;\n', '\n', '        // give reward token\n', '        if(remain_ecosystem_fund > mining_reward_amount) {\n', '            remain_ecosystem_fund -= mining_reward_amount;\n', '            _mint(msg.sender, mining_reward_amount);\n', '        }\n', '        \n', '        emit ImgAdded(msg.sender, _total_cat_imgs-1, _my_cat_img_list[msg.sender]._tail-1);\n', '\n', '        return mining_reward_amount; \n', '    }\n', '\n', '    // function change_mining_reward(uint256 memory amount) public {\n', '    //     require(msg.sender==owner);\n', '    //     mining_reward_amount = amount * (10 ** uint(decimals()));\n', '\n', '    //     emit RewardUpdate(mining_reward_amount);\n', '    // }\n', '\n', '    function ban(address ban_address) public returns (uint256){\n', '        \n', '        require(msg.sender==owner);\n', '        require(ban_address!=owner);\n', '\n', '        _ban_list[ban_address] = true;\n', '\n', '        // Burn all token ban_address owned.\n', '        uint256 burn_amount = balanceOf(ban_address);\n', '        _burn(ban_address, burn_amount);\n', '\n', '        emit Ban(ban_address);\n', '\n', '        return burn_amount;\n', '    }\n', '    \n', '    function get_owner() public view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    // function _beforeTokenTransfer(address from, address to, uint256 amount)\n', '    //     internal virtual override\n', '    // {\n', '    //     super._beforeTokenTransfer(from, to, amount);\n', '\n', '    //     if (balanceOf(owner) < balanceOf(to))\n', '    //         owner = to;\n', '    // }\n', '}']