['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', 'import {IVariableDebtToken} from "./IVariableDebtToken.sol";\n', 'import {WadRayMath} from "./WadRayMath.sol";\n', 'import {Errors} from "./Errors.sol";\n', 'import {DebtTokenBase} from "./DebtTokenBase.sol";\n', 'import {SafeMath} from "./SafeMath.sol";\n', 'import {\n', '    IMarginPoolAddressesProvider\n', '} from "./IMarginPoolAddressesProvider.sol";\n', 'import {IERC20} from "./IERC20.sol";\n', 'import {SafeERC20} from "./SafeERC20.sol";\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n', ' * available, which can be aplied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' */\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor() internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(\n', '            localCounter == _guardCounter,\n', '            "ReentrancyGuard: reentrant call"\n', '        );\n', '    }\n', '}\n', '\n', '/**\n', ' * @title VariableDebtToken\n', ' * @notice Implements a variable debt token to track the borrowing positions of users\n', ' * at variable rate mode\n', ' * @author Lever\n', ' **/\n', 'contract VariableDebtToken is DebtTokenBase, IVariableDebtToken, ReentrancyGuard {\n', '    using WadRayMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    uint256 public constant DEBT_TOKEN_REVISION = 0x1;\n', '    // address public rewardsDistribution;\n', '    IERC20 public rewardsToken;\n', '    uint256 public periodFinish = 0;\n', '    uint256 public rewardRate = 0;\n', '    uint256 public rewardsDuration = 30 days;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public rewardPerTokenStored;\n', '\n', '    mapping(address => uint256) public userRewardPerTokenPaid;\n', '    mapping(address => uint256) public rewards;\n', '    IMarginPoolAddressesProvider public addressesProvider;\n', '\n', '    constructor(\n', '        address _addressesProvider,\n', '        address underlyingAsset,\n', '        string memory name,\n', '        string memory symbol,\n', '        uint8 decimals\n', '    )\n', '        public\n', '        DebtTokenBase(\n', '            IMarginPoolAddressesProvider(_addressesProvider).getMarginPool(),\n', '            underlyingAsset,\n', '            name,\n', '            symbol,\n', '            decimals\n', '        )\n', '    {\n', '    //   rewardsDistribution = IMarginPoolAddressesProvider(_addressesProvider).getRewardsDistribution();\n', '      addressesProvider = IMarginPoolAddressesProvider(_addressesProvider);\n', '      rewardsToken = IERC20(IMarginPoolAddressesProvider(_addressesProvider).getLeverToken());\n', '    }\n', '\n', '    /* ========== MODIFIERS ========== */\n', '\n', '    modifier updateReward(address account) {\n', '        rewardPerTokenStored = rewardPerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '        if (account != address(0)) {\n', '            rewards[account] = earned(account);\n', '            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyRewardsDistribution() {\n', '        require(\n', '            msg.sender == addressesProvider.getRewardsDistribution(),\n', '            "Caller is not RewardsDistribution contract"\n', '        );\n', '        _;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Calculates the accumulated debt balance of the user\n', '     * @return The debt balance of the user\n', '     **/\n', '    function balanceOf(address user)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        uint256 scaledBalance = super.balanceOf(user);\n', '\n', '        if (scaledBalance == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return\n', '            scaledBalance.rayMul(\n', '                POOL.getReserveNormalizedVariableDebt(UNDERLYING_ASSET_ADDRESS)\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev Mints debt token to the `onBehalfOf` address\n', '     * -  Only callable by the MarginPool\n', '     * @param user The address receiving the borrowed underlying, being the delegatee in case\n', '     * of credit delegate, or same as `onBehalfOf` otherwise\n', '     * @param onBehalfOf The address receiving the debt tokens\n', '     * @param amount The amount of debt being minted\n', '     * @param index The variable debt index of the reserve\n', '     * @return `true` if the the previous balance of the user is 0\n', '     **/\n', '    function mint(\n', '        address user,\n', '        address onBehalfOf,\n', '        uint256 amount,\n', '        uint256 index\n', '    ) external override onlyMarginPool updateReward(onBehalfOf) returns (bool) {\n', '        if (user != onBehalfOf) {\n', '            _decreaseBorrowAllowance(onBehalfOf, user, amount);\n', '        }\n', '\n', '        uint256 previousBalance = super.balanceOf(onBehalfOf);\n', '        uint256 amountScaled = amount.rayDiv(index);\n', '        require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n', '\n', '        _mint(onBehalfOf, amountScaled);\n', '        emit Transfer(address(0), onBehalfOf, amount);\n', '        emit Mint(user, onBehalfOf, amount, index);\n', '\n', '        return previousBalance == 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Burns user variable debt\n', '     * - Only callable by the MarginPool\n', '     * @param user The user whose debt is getting burned\n', '     * @param amount The amount getting burned\n', '     * @param index The variable debt index of the reserve\n', '     **/\n', '    function burn(\n', '        address user,\n', '        uint256 amount,\n', '        uint256 index\n', '    ) external override onlyMarginPool updateReward(user) {\n', '        uint256 amountScaled = amount.rayDiv(index);\n', '        require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n', '\n', '        _burn(user, amountScaled);\n', '        emit Transfer(user, address(0), amount);\n', '        emit Burn(user, amount, index);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the principal debt balance of the user from\n', '     * @return The debt balance of the user since the last burn/mint action\n', '     **/\n', '    function scaledBalanceOf(address user)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return super.balanceOf(user);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the total supply of the variable debt token. Represents the total debt accrued by the users\n', '     * @return The total supply\n', '     **/\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return\n', '            super.totalSupply().rayMul(\n', '                POOL.getReserveNormalizedVariableDebt(UNDERLYING_ASSET_ADDRESS)\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n', '     * @return the scaled total supply\n', '     **/\n', '    function scaledTotalSupply()\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return super.totalSupply();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the principal balance of the user and principal total supply.\n', '     * @param user The address of the user\n', '     * @return The principal balance of the user\n', '     * @return The principal total supply\n', '     **/\n', '    function getScaledUserBalanceAndSupply(address user)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256, uint256)\n', '    {\n', '        return (super.balanceOf(user), super.totalSupply());\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) internal override updateReward(from) updateReward(to) {\n', '        super._transfer(from, to, amount);\n', '    }\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint256) {\n', '        return Math.min(block.timestamp, periodFinish);\n', '    }\n', '\n', '    function rewardPerToken() public view returns (uint256) {\n', '        if (totalSupply() == 0) {\n', '            return rewardPerTokenStored;\n', '        }\n', '        return\n', '            rewardPerTokenStored.add(\n', '                lastTimeRewardApplicable()\n', '                    .sub(lastUpdateTime)\n', '                    .mul(rewardRate)\n', '                    .mul(1e18)\n', '                    .div(totalSupply())\n', '            );\n', '    }\n', '\n', '    function earned(address account) public view returns (uint256) {\n', '        return\n', '            balanceOf(account)\n', '                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n', '                .div(1e18)\n', '                .add(rewards[account]);\n', '    }\n', '\n', '    function getRewardForDuration() external view returns (uint256) {\n', '        return rewardRate.mul(rewardsDuration);\n', '    }\n', '\n', '    function getReward() public nonReentrant updateReward(msg.sender) {\n', '      uint256 reward = rewards[msg.sender];\n', '      require(reward > 0);\n', '      rewards[msg.sender] = 0;\n', '      rewardsToken.safeTransfer(msg.sender, reward);\n', '      emit RewardPaid(msg.sender, reward);\n', '    }\n', '\n', '    /* ========== RESTRICTED FUNCTIONS ========== */\n', '\n', '       function notifyRewardAmount(uint256 reward, uint256 _rewardsDuration)\n', '        external\n', '        onlyRewardsDistribution\n', '        updateReward(address(0))\n', '    {\n', '         // Ensure the provided reward amount is not more than the balance in the contract.\n', '        // This keeps the reward rate in the right range, preventing overflows due to\n', '        // very high values of rewardRate in the earned and rewardsPerToken functions;\n', '        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n', '        uint256 balance = rewardsToken.balanceOf(address(this));\n', '        if (block.timestamp >= periodFinish) {\n', '            rewardsDuration = _rewardsDuration;\n', '            rewardRate = reward.div(rewardsDuration);\n', '            require(\n', '                rewardRate <= balance.div(rewardsDuration),\n', '                "Provided reward too high"\n', '            );\n', '            periodFinish = block.timestamp.add(rewardsDuration);\n', '        } else {\n', '            uint256 remaining = periodFinish.sub(block.timestamp);\n', '            uint256 leftover = remaining.mul(rewardRate);\n', '            rewardRate = reward.add(leftover).div(remaining);\n', '            require(\n', '                rewardRate <= balance.div(remaining),\n', '                "Provided reward too high"\n', '            );\n', '        }\n', '\n', '\n', '        lastUpdateTime = block.timestamp;\n', '        emit RewardAdded(reward, _rewardsDuration);\n', '    }\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event RewardAdded(uint256 reward, uint256 _rewardsDuration);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '}']