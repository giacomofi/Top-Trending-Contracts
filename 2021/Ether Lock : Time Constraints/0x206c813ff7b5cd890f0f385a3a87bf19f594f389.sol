['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./StrongPoolInterface.sol";\n', 'import "./IERC1155Preset.sol";\n', 'import "./StrongNFTBonusInterface.sol";\n', 'import "./rewards.sol";\n', '\n', 'contract ServiceV12 {\n', '  event Requested(address indexed miner);\n', '  event Claimed(address indexed miner, uint256 reward);\n', '\n', '  using SafeMath for uint256;\n', '  bool public initDone;\n', '  address public admin;\n', '  address public pendingAdmin;\n', '  address public superAdmin;\n', '  address public pendingSuperAdmin;\n', '  address public serviceAdmin;\n', '  address public parameterAdmin;\n', '  address payable public feeCollector;\n', '\n', '  IERC20 public strongToken;\n', '  StrongPoolInterface public strongPool;\n', '\n', '  uint256 public rewardPerBlockNumerator;\n', '  uint256 public rewardPerBlockDenominator;\n', '\n', '  uint256 public naasRewardPerBlockNumerator;\n', '  uint256 public naasRewardPerBlockDenominator;\n', '\n', '  uint256 public claimingFeeNumerator;\n', '  uint256 public claimingFeeDenominator;\n', '\n', '  uint256 public requestingFeeInWei;\n', '\n', '  uint256 public strongFeeInWei;\n', '\n', '  uint256 public recurringFeeInWei;\n', '  uint256 public recurringNaaSFeeInWei;\n', '  uint256 public recurringPaymentCycleInBlocks;\n', '\n', '  uint256 public rewardBalance;\n', '\n', '  mapping(address => uint256) public entityBlockLastClaimedOn;\n', '\n', '  address[] public entities;\n', '  mapping(address => uint256) public entityIndex;\n', '  mapping(address => bool) public entityActive;\n', '  mapping(address => bool) public requestPending;\n', '  mapping(address => bool) public entityIsNaaS;\n', '  mapping(address => uint256) public paidOnBlock;\n', '  uint256 public activeEntities;\n', '\n', '  string public desciption;\n', '\n', '  uint256 public claimingFeeInWei;\n', '\n', '  uint256 public naasRequestingFeeInWei;\n', '\n', '  uint256 public naasStrongFeeInWei;\n', '\n', '  bool public removedTokens;\n', '\n', '  mapping(address => uint256) public traunch;\n', '\n', '  uint256 public currentTraunch;\n', '\n', '  mapping(bytes => bool) public entityNodeIsActive;\n', '  mapping(bytes => bool) public entityNodeIsBYON;\n', '  mapping(bytes => uint256) public entityNodeTraunch;\n', '  mapping(bytes => uint256) public entityNodePaidOnBlock;\n', '  mapping(bytes => uint256) public entityNodeClaimedOnBlock;\n', '  mapping(address => uint128) public entityNodeCount;\n', '\n', '  event Paid(address indexed entity, uint128 nodeId, bool isBYON, bool isRenewal, uint256 upToBlockNumber);\n', '  event Migrated(address indexed from, address indexed to, uint128 fromNodeId, uint128 toNodeId, bool isBYON);\n', '\n', '  uint256 public rewardPerBlockNumeratorNew;\n', '  uint256 public rewardPerBlockDenominatorNew;\n', '  uint256 public naasRewardPerBlockNumeratorNew;\n', '  uint256 public naasRewardPerBlockDenominatorNew;\n', '  uint256 public rewardPerBlockNewEffectiveBlock;\n', '\n', '  StrongNFTBonusInterface public strongNFTBonus;\n', '\n', '  uint256 public gracePeriodInBlocks;\n', '\n', '  function init(\n', '    address strongTokenAddress,\n', '    address strongPoolAddress,\n', '    address adminAddress,\n', '    address superAdminAddress,\n', '    uint256 rewardPerBlockNumeratorValue,\n', '    uint256 rewardPerBlockDenominatorValue,\n', '    uint256 naasRewardPerBlockNumeratorValue,\n', '    uint256 naasRewardPerBlockDenominatorValue,\n', '    uint256 requestingFeeInWeiValue,\n', '    uint256 strongFeeInWeiValue,\n', '    uint256 recurringFeeInWeiValue,\n', '    uint256 recurringNaaSFeeInWeiValue,\n', '    uint256 recurringPaymentCycleInBlocksValue,\n', '    uint256 claimingFeeNumeratorValue,\n', '    uint256 claimingFeeDenominatorValue,\n', '    string memory desc\n', '  ) public {\n', '    require(!initDone, "init done");\n', '    strongToken = IERC20(strongTokenAddress);\n', '    strongPool = StrongPoolInterface(strongPoolAddress);\n', '    admin = adminAddress;\n', '    superAdmin = superAdminAddress;\n', '    rewardPerBlockNumerator = rewardPerBlockNumeratorValue;\n', '    rewardPerBlockDenominator = rewardPerBlockDenominatorValue;\n', '    naasRewardPerBlockNumerator = naasRewardPerBlockNumeratorValue;\n', '    naasRewardPerBlockDenominator = naasRewardPerBlockDenominatorValue;\n', '    requestingFeeInWei = requestingFeeInWeiValue;\n', '    strongFeeInWei = strongFeeInWeiValue;\n', '    recurringFeeInWei = recurringFeeInWeiValue;\n', '    recurringNaaSFeeInWei = recurringNaaSFeeInWeiValue;\n', '    claimingFeeNumerator = claimingFeeNumeratorValue;\n', '    claimingFeeDenominator = claimingFeeDenominatorValue;\n', '    recurringPaymentCycleInBlocks = recurringPaymentCycleInBlocksValue;\n', '    desciption = desc;\n', '    initDone = true;\n', '  }\n', '\n', '  function updateServiceAdmin(address newServiceAdmin) public {\n', '    require(msg.sender == superAdmin);\n', '    serviceAdmin = newServiceAdmin;\n', '  }\n', '\n', '  function updateParameterAdmin(address newParameterAdmin) public {\n', '    require(newParameterAdmin != address(0));\n', '    require(msg.sender == superAdmin);\n', '    parameterAdmin = newParameterAdmin;\n', '  }\n', '\n', '  function updateFeeCollector(address payable newFeeCollector) public {\n', '    require(newFeeCollector != address(0));\n', '    require(msg.sender == superAdmin);\n', '    feeCollector = newFeeCollector;\n', '  }\n', '\n', '  function setPendingAdmin(address newPendingAdmin) public {\n', '    require(msg.sender == admin);\n', '    pendingAdmin = newPendingAdmin;\n', '  }\n', '\n', '  function acceptAdmin() public {\n', '    require(msg.sender == pendingAdmin && msg.sender != address(0), "not pendingAdmin");\n', '    admin = pendingAdmin;\n', '    pendingAdmin = address(0);\n', '  }\n', '\n', '  function setPendingSuperAdmin(address newPendingSuperAdmin) public {\n', '    require(msg.sender == superAdmin, "not superAdmin");\n', '    pendingSuperAdmin = newPendingSuperAdmin;\n', '  }\n', '\n', '  function acceptSuperAdmin() public {\n', '    require(msg.sender == pendingSuperAdmin && msg.sender != address(0), "not pendingSuperAdmin");\n', '    superAdmin = pendingSuperAdmin;\n', '    pendingSuperAdmin = address(0);\n', '  }\n', '\n', '  function isEntityActive(address entity) public view returns (bool) {\n', '    return entityActive[entity] || (doesNodeExist(entity, 1) && !hasNodeExpired(entity, 1));\n', '  }\n', '\n', '  function updateRewardPerBlock(uint256 numerator, uint256 denominator) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    require(denominator != 0);\n', '    rewardPerBlockNumerator = numerator;\n', '    rewardPerBlockDenominator = denominator;\n', '  }\n', '\n', '  function updateNaaSRewardPerBlock(uint256 numerator, uint256 denominator) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    require(denominator != 0);\n', '    naasRewardPerBlockNumerator = numerator;\n', '    naasRewardPerBlockDenominator = denominator;\n', '  }\n', '\n', '  function updateRewardPerBlockNew(\n', '    uint256 numerator,\n', '    uint256 denominator,\n', '    uint256 numeratorNass,\n', '    uint256 denominatorNass,\n', '    uint256 effectiveBlock\n', '  ) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '\n', '    rewardPerBlockNumeratorNew = numerator;\n', '    rewardPerBlockDenominatorNew = denominator;\n', '    naasRewardPerBlockNumeratorNew = numeratorNass;\n', '    naasRewardPerBlockDenominatorNew = denominatorNass;\n', '    rewardPerBlockNewEffectiveBlock = effectiveBlock != 0 ? effectiveBlock : block.number;\n', '  }\n', '\n', '  function deposit(uint256 amount) public {\n', '    require(msg.sender == superAdmin);\n', '    require(amount > 0);\n', '    strongToken.transferFrom(msg.sender, address(this), amount);\n', '    rewardBalance = rewardBalance.add(amount);\n', '  }\n', '\n', '  function withdraw(address destination, uint256 amount) public {\n', '    require(msg.sender == superAdmin);\n', '    require(amount > 0);\n', '    require(rewardBalance >= amount, "not enough");\n', '    strongToken.transfer(destination, amount);\n', '    rewardBalance = rewardBalance.sub(amount);\n', '  }\n', '\n', '  function updateRequestingFee(uint256 feeInWei) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    requestingFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateStrongFee(uint256 feeInWei) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    strongFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateNaasRequestingFee(uint256 feeInWei) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    naasRequestingFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateNaasStrongFee(uint256 feeInWei) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    naasStrongFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateClaimingFee(uint256 numerator, uint256 denominator) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    require(denominator != 0);\n', '    claimingFeeNumerator = numerator;\n', '    claimingFeeDenominator = denominator;\n', '  }\n', '\n', '  function updateRecurringFee(uint256 feeInWei) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    recurringFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateRecurringNaaSFee(uint256 feeInWei) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    recurringNaaSFeeInWei = feeInWei;\n', '  }\n', '\n', '  function updateRecurringPaymentCycleInBlocks(uint256 blocks) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    require(blocks > 0);\n', '    recurringPaymentCycleInBlocks = blocks;\n', '  }\n', '\n', '  function updateGracePeriodInBlocks(uint256 blocks) public {\n', '    require(msg.sender == admin || msg.sender == parameterAdmin || msg.sender == superAdmin);\n', '    require(blocks > 0);\n', '    gracePeriodInBlocks = blocks;\n', '  }\n', '\n', '  function requestAccess(bool isNaaS) public payable {\n', '    uint256 rFee;\n', '    uint256 sFee;\n', '\n', '    if (hasLegacyNode(msg.sender)) {\n', '      migrateLegacyNode(msg.sender);\n', '    }\n', '\n', '    uint128 nodeId = entityNodeCount[msg.sender] + 1;\n', '    bytes memory id = getNodeId(msg.sender, nodeId);\n', '\n', '    if (isNaaS) {\n', '      rFee = naasRequestingFeeInWei;\n', '      sFee = naasStrongFeeInWei;\n', '      activeEntities = activeEntities.add(1);\n', '    } else {\n', '      rFee = requestingFeeInWei;\n', '      sFee = strongFeeInWei;\n', '      entityNodeIsBYON[id] = true;\n', '    }\n', '\n', '    require(msg.value == rFee, "invalid fee");\n', '\n', '    entityNodePaidOnBlock[id] = block.number;\n', '    entityNodeClaimedOnBlock[id] = block.number;\n', '    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] + 1;\n', '\n', '    feeCollector.transfer(msg.value);\n', '    strongToken.transferFrom(msg.sender, address(this), sFee);\n', '    strongToken.transfer(feeCollector, sFee);\n', '\n', '    emit Paid(msg.sender, nodeId, entityNodeIsBYON[id], false, entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks));\n', '  }\n', '\n', '  function setEntityActiveStatus(address entity, bool status) public {\n', '    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\n', '    uint256 index = entityIndex[entity];\n', '    require(entities[index] == entity, "invalid entity");\n', '    require(entityActive[entity] != status, "already set");\n', '    entityActive[entity] = status;\n', '    if (status) {\n', '      activeEntities = activeEntities.add(1);\n', '      entityBlockLastClaimedOn[entity] = block.number;\n', '    } else {\n', '      activeEntities = activeEntities.sub(1);\n', '      entityBlockLastClaimedOn[entity] = 0;\n', '    }\n', '  }\n', '\n', '  function payFee(uint128 nodeId) public payable {\n', '    address sender = msg.sender == address(this) ? tx.origin : msg.sender;\n', '    bytes memory id = getNodeId(sender, nodeId);\n', '\n', '    if (hasLegacyNode(sender)) {\n', '      migrateLegacyNode(sender);\n', '    }\n', '\n', '    bool isExpired = hasNodeExpired(sender, nodeId);\n', '\n', '    require(doesNodeExist(sender, nodeId), "doesnt exist");\n', '    require(isExpired == false || msg.sender == address(this), "too late");\n', '\n', '    if (isExpired) {\n', '      return;\n', '    }\n', '\n', '    if (entityNodeIsBYON[id]) {\n', '      require(msg.value == recurringFeeInWei, "invalid fee");\n', '    } else {\n', '      require(msg.value == recurringNaaSFeeInWei, "invalid fee");\n', '    }\n', '\n', '    feeCollector.transfer(msg.value);\n', '    entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\n', '\n', '    emit Paid(sender, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\n', '  }\n', '\n', '  function getReward(address entity, uint128 nodeId) public view returns (uint256) {\n', '    return getRewardByBlock(entity, nodeId, block.number);\n', '  }\n', '\n', '  function getRewardByBlock(address entity, uint128 nodeId, uint256 blockNumber) public view returns (uint256) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '\n', '    if (hasLegacyNode(entity)) {\n', '      return getRewardByBlockLegacy(entity, blockNumber);\n', '    }\n', '\n', '    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\n', '\n', '    if (blockNumber > block.number) return 0;\n', '    if (blockLastClaimedOn == 0) return 0;\n', '    if (blockNumber < blockLastClaimedOn) return 0;\n', '    if (activeEntities == 0) return 0;\n', '    if (entityNodeIsBYON[id] && !entityNodeIsActive[id]) return 0;\n', '\n', '    uint256 rewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumerator : naasRewardPerBlockNumerator;\n', '    uint256 rewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominator : naasRewardPerBlockDenominator;\n', '    uint256 newRewardNumerator = entityNodeIsBYON[id] ? rewardPerBlockNumeratorNew : naasRewardPerBlockNumeratorNew;\n', '    uint256 newRewardDenominator = entityNodeIsBYON[id] ? rewardPerBlockDenominatorNew : naasRewardPerBlockDenominatorNew;\n', '\n', '    uint256 bonus = address(strongNFTBonus) != address(0)\n', '    ? strongNFTBonus.getBonus(entity, nodeId, blockLastClaimedOn, blockNumber)\n', '    : 0;\n', '\n', '    uint256[2] memory rewardBlocks = rewards.blocks(blockLastClaimedOn, rewardPerBlockNewEffectiveBlock, blockNumber);\n', '    uint256 rewardOld = rewardDenominator > 0 ? rewardBlocks[0].mul(rewardNumerator).div(rewardDenominator) : 0;\n', '    uint256 rewardNew = newRewardDenominator > 0 ? rewardBlocks[1].mul(newRewardNumerator).div(newRewardDenominator) : 0;\n', '\n', '    return rewardOld.add(rewardNew).add(bonus);\n', '  }\n', '\n', '  function getRewardByBlockLegacy(address entity, uint256 blockNumber) public view returns (uint256) {\n', '    if (blockNumber > block.number) return 0;\n', '    if (entityBlockLastClaimedOn[entity] == 0) return 0;\n', '    if (blockNumber < entityBlockLastClaimedOn[entity]) return 0;\n', '    if (activeEntities == 0) return 0;\n', '    uint256 blockResult = blockNumber.sub(entityBlockLastClaimedOn[entity]);\n', '    uint256 rewardNumerator;\n', '    uint256 rewardDenominator;\n', '    if (entityIsNaaS[entity]) {\n', '      rewardNumerator = naasRewardPerBlockNumerator;\n', '      rewardDenominator = naasRewardPerBlockDenominator;\n', '    } else {\n', '      rewardNumerator = rewardPerBlockNumerator;\n', '      rewardDenominator = rewardPerBlockDenominator;\n', '    }\n', '    uint256 rewardPerBlockResult = blockResult.mul(rewardNumerator).div(rewardDenominator);\n', '\n', '    return rewardPerBlockResult;\n', '  }\n', '\n', '  function claim(uint128 nodeId, uint256 blockNumber, bool toStrongPool) public payable {\n', '    address sender = msg.sender == address(this) || msg.sender == address(strongNFTBonus) ? tx.origin : msg.sender;\n', '    bytes memory id = getNodeId(sender, nodeId);\n', '\n', '    if (hasLegacyNode(sender)) {\n', '      migrateLegacyNode(sender);\n', '    }\n', '\n', '    uint256 blockLastClaimedOn = entityNodeClaimedOnBlock[id] != 0 ? entityNodeClaimedOnBlock[id] : entityNodePaidOnBlock[id];\n', '    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\n', '\n', '    require(blockLastClaimedOn != 0, "never claimed");\n', '    require(blockNumber <= block.number, "invalid block");\n', '    require(blockNumber > blockLastClaimedOn, "too soon");\n', '    require(!entityNodeIsBYON[id] || entityNodeIsActive[id], "not active");\n', '\n', '    if (\n', '      (!entityNodeIsBYON[id] && recurringNaaSFeeInWei != 0) || (entityNodeIsBYON[id] && recurringFeeInWei != 0)\n', '    ) {\n', '      require(blockNumber < blockLastPaidOn.add(recurringPaymentCycleInBlocks), "pay fee");\n', '    }\n', '\n', '    uint256 reward = getRewardByBlock(sender, nodeId, blockNumber);\n', '    require(reward > 0, "no reward");\n', '\n', '    uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\n', '    require(msg.value >= fee, "invalid fee");\n', '\n', '    feeCollector.transfer(msg.value);\n', '\n', '    if (toStrongPool) {\n', '      strongToken.approve(address(strongPool), reward);\n', '      strongPool.mineFor(sender, reward);\n', '    } else {\n', '      strongToken.transfer(sender, reward);\n', '    }\n', '\n', '    rewardBalance = rewardBalance.sub(reward);\n', '    entityNodeClaimedOnBlock[id] = blockNumber;\n', '    emit Claimed(sender, reward);\n', '  }\n', '\n', '  function getRewardAll(address entity, uint256 blockNumber) public view returns (uint256) {\n', '    uint256 rewardsAll = 0;\n', '\n', '    for (uint128 i = 1; i <= entityNodeCount[entity]; i++) {\n', '      rewardsAll = rewardsAll.add(getRewardByBlock(entity, i, blockNumber > 0 ? blockNumber : block.number));\n', '    }\n', '\n', '    return rewardsAll;\n', '  }\n', '\n', '  function doesNodeExist(address entity, uint128 nodeId) public view returns (bool) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodePaidOnBlock[id] > 0;\n', '  }\n', '\n', '  function hasNodeExpired(address entity, uint128 nodeId) public view returns (bool) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    uint256 blockLastPaidOn = entityNodePaidOnBlock[id];\n', '    return block.number > blockLastPaidOn.add(recurringPaymentCycleInBlocks).add(gracePeriodInBlocks);\n', '  }\n', '\n', '  function getNodeId(address entity, uint128 nodeId) public view returns (bytes memory) {\n', '    uint128 id = nodeId != 0 ? nodeId : entityNodeCount[entity] + 1;\n', '    return abi.encodePacked(entity, id);\n', '  }\n', '\n', '  function getNodePaidOn(address entity, uint128 nodeId) public view returns (uint256) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodePaidOnBlock[id];\n', '  }\n', '\n', '  function getNodeFee(address entity, uint128 nodeId) public view returns (uint256) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\n', '  }\n', '\n', '  function isNodeActive(address entity, uint128 nodeId) public view returns (bool) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodeIsActive[id] || !entityNodeIsBYON[id];\n', '  }\n', '\n', '  function isNodeBYON(address entity, uint128 nodeId) public view returns (bool) {\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    return entityNodeIsBYON[id];\n', '  }\n', '\n', '  function hasLegacyNode(address entity) public view returns (bool) {\n', '    return entityActive[entity] && entityNodeCount[entity] == 0;\n', '  }\n', '\n', '  function approveBYONNode(address entity, uint128 nodeId) public {\n', '    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\n', '\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    entityNodeIsActive[id] = true;\n', '    entityNodeClaimedOnBlock[id] = block.number;\n', '    activeEntities = activeEntities.add(1);\n', '  }\n', '\n', '  function suspendBYONNode(address entity, uint128 nodeId) public {\n', '    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\n', '\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '    entityNodeIsActive[id] = false;\n', '    activeEntities = activeEntities.sub(1);\n', '  }\n', '\n', '  function setNodeIsActive(address entity, uint128 nodeId, bool isActive) public {\n', '    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '\n', '    if (isActive && !entityNodeIsActive[id]) {\n', '      activeEntities = activeEntities.add(1);\n', '      entityNodeClaimedOnBlock[id] = block.number;\n', '    }\n', '\n', '    if (!isActive && entityNodeIsActive[id]) {\n', '      activeEntities = activeEntities.sub(1);\n', '    }\n', '\n', '    entityNodeIsActive[id] = isActive;\n', '  }\n', '\n', '  function setNodeIsNaaS(address entity, uint128 nodeId, bool isNaaS) public {\n', '    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\n', '    bytes memory id = getNodeId(entity, nodeId);\n', '\n', '    entityNodeIsBYON[id] = !isNaaS;\n', '  }\n', '\n', '  function migrateLegacyNode(address entity) private {\n', '    bytes memory id = getNodeId(entity, 1);\n', '    entityNodeClaimedOnBlock[id] = entityBlockLastClaimedOn[entity];\n', '    entityNodePaidOnBlock[id] = paidOnBlock[entity];\n', '    entityNodeIsBYON[id] = !entityIsNaaS[entity];\n', '    if (entityNodeIsBYON[id]) {\n', '      entityNodeIsActive[id] = true;\n', '    }\n', '    entityNodeCount[msg.sender] = 1;\n', '  }\n', '\n', '  function migrateNode(uint128 nodeId, address to) public {\n', '    if (hasLegacyNode(msg.sender)) {\n', '      migrateLegacyNode(msg.sender);\n', '    }\n', '\n', '    if (hasLegacyNode(to)) {\n', '      migrateLegacyNode(to);\n', '    }\n', '\n', '    require(doesNodeExist(msg.sender, nodeId), "doesnt exist");\n', '\n', '    uint128 toNodeId = entityNodeCount[to] + 1;\n', '    bytes memory fromId = getNodeId(msg.sender, nodeId);\n', '    bytes memory toId = getNodeId(to, toNodeId);\n', '\n', '    // move node to another address\n', '    entityNodeIsActive[toId] = entityNodeIsActive[fromId];\n', '    entityNodeIsBYON[toId] = entityNodeIsBYON[fromId];\n', '    entityNodePaidOnBlock[toId] = entityNodePaidOnBlock[fromId];\n', '    entityNodeClaimedOnBlock[toId] = entityNodeClaimedOnBlock[fromId];\n', '    entityNodeCount[to] = entityNodeCount[to] + 1;\n', '\n', '    // deactivate node\n', '    entityNodeIsActive[fromId] = false;\n', '    entityNodePaidOnBlock[fromId] = 0;\n', '    entityNodeClaimedOnBlock[fromId] = 0;\n', '    entityNodeCount[msg.sender] = entityNodeCount[msg.sender] - 1;\n', '\n', '    emit Migrated(msg.sender, to, nodeId, toNodeId, entityNodeIsBYON[fromId]);\n', '  }\n', '\n', '  function claimAll(uint256 blockNumber, bool toStrongPool) public payable {\n', '    for (uint16 i = 1; i <= entityNodeCount[msg.sender]; i++) {\n', '      uint256 reward = getRewardByBlock(msg.sender, i, blockNumber);\n', '      uint256 fee = reward.mul(claimingFeeNumerator).div(claimingFeeDenominator);\n', '      this.claim{value : fee}(i, blockNumber, toStrongPool);\n', '    }\n', '  }\n', '\n', '  function payAll() public payable {\n', '    for (uint16 i = 1; i <= entityNodeCount[msg.sender]; i++) {\n', '      bytes memory id = getNodeId(msg.sender, i);\n', '      uint256 fee = entityNodeIsBYON[id] ? recurringFeeInWei : recurringNaaSFeeInWei;\n', '      this.payFee{value : fee}(i);\n', '    }\n', '  }\n', '\n', '  function addNFTBonusContract(address _contract) public {\n', '    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\n', '\n', '    strongNFTBonus = StrongNFTBonusInterface(_contract);\n', '  }\n', '\n', '  function payFeeAdmin(address entity, uint128[] memory nodes) public {\n', '    require(msg.sender == admin || msg.sender == serviceAdmin || msg.sender == superAdmin);\n', '\n', '    for (uint256 i = 0; i < nodes.length; i++) {\n', '      uint128 nodeId = nodes[i];\n', '      bytes memory id = getNodeId(entity, nodeId);\n', '      entityNodePaidOnBlock[id] = entityNodePaidOnBlock[id].add(recurringPaymentCycleInBlocks);\n', '\n', '      emit Paid(entity, nodeId, entityNodeIsBYON[id], true, entityNodePaidOnBlock[id]);\n', '    }\n', '  }\n', '\n', '}']