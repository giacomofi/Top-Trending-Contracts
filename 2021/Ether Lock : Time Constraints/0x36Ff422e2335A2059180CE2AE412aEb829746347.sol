['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'pragma abicoder v2;\n', '\n', 'import "./ReentrancyGuard.sol";\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./InlineInterface.sol";\n', '\n', 'contract InlineMain is Ownable,ReentrancyGuard{\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    address public databaseContractAddress=0x96A0F13597D7DAB5952Cdcf8C8Ca09eAc97a0a75;\n', '    \n', '    function stakeTokens(uint256 amount) external nonReentrant{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        require(amount>=dContract.getMinLPvalue(),"Please enter more amount.");\n', '        require((dContract.getTokenStakedAmount().add(amount))<=dContract.getMaxLPLimit(),"Max limit has reached.");\n', '        \n', '        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amount);\n', '        \n', '        uint256 currentTimeStamp=block.timestamp;\n', '        \n', '        if(!dContract.getIsStakeMapping(msg.sender)){\n', '            dContract.updateUserStakedAddress(msg.sender);\n', '            dContract.updateIsStakeMapping(msg.sender,true);\n', '        }\n', '        dContract.updateTokensStaked(msg.sender,dContract.getTokensStaked(msg.sender).add(amount));\n', '        dContract.updateActualAmountStakedByUser(msg.sender,dContract.getActualAmountStakedByUser(msg.sender).add(amount));\n', '        dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount().add(amount));\n', '        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amount));\n', '        if(dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp>currentTimeStamp){\n', '            dContract.updateLockingPeriodForLPMapping(msg.sender,(dContract.getLockingPeriodForLPMapping(msg.sender).amountLocked).add(amount),\n', '                                                        dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp);\n', '        }else{\n', '            dContract.updateLockingPeriodForLPMapping(msg.sender,amount,currentTimeStamp.add(30 days));\n', '        }\n', '        dContract.emitLPEvent(0,msg.sender,amount,currentTimeStamp);\n', '    }\n', '     function unStakeTokens(uint256 amount) external nonReentrant{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 currentTimeStamp=block.timestamp;\n', '        if(dContract.getLockingPeriodForLPMapping(msg.sender).lockedTimeStamp>currentTimeStamp){\n', '            require(dContract.getTokensStaked(msg.sender).sub(dContract.getLockingPeriodForLPMapping(msg.sender).amountLocked) >= amount, "You can not retrive LP token with this amount");\n', '        }else{\n', '            require(dContract.getTokensStaked(msg.sender)>=amount, "You can not retrive LP token with this amount");\n', '        }\n', '        dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,amount);\n', '        dContract.updateTokensStaked(msg.sender,dContract.getTokensStaked(msg.sender).sub(amount));\n', '        if(amount>dContract.getActualAmountStakedByUser(msg.sender)){\n', '            dContract.updateActualAmountStakedByUser(msg.sender,0);\n', '        }else{\n', '            dContract.updateActualAmountStakedByUser(msg.sender,dContract.getActualAmountStakedByUser(msg.sender).sub(amount));\n', '        }\n', '        dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount().sub(amount));\n', '        dContract.emitLPEvent(1,msg.sender,amount,currentTimeStamp);\n', '    }\n', '    \n', '    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\n', '        databaseContractAddress=_databaseContractAddress;\n', '    }\n', '    \n', '}']