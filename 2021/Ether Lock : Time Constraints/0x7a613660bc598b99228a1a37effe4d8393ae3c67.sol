['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', 'import "./ERC721.sol";\n', 'import "./Ownable.sol";\n', 'import "./Counters.sol";\n', '\n', 'interface ClaimContract {\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '}\n', '\n', '\n', 'contract Apes is ERC721, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    using Strings for uint256;\n', '    using EnumerableSet for EnumerableSet.UintSet;    \n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '\n', '    // Hash of all 8888 apes\n', '    string public constant PROVENANCE_HASH = "1a6595d8f3c2c97b66a34e35dbe9bc0e83edfdca1d93193145d8904775671cc3";\n', '\n', '    // Sale starts at \n', '    uint256 public constant SALE_START_TIMESTAMP = 1619190000;\n', '\n', '    // Sale ends 7 days later\n', '    uint256 public constant REVEAL_TIMESTAMP = SALE_START_TIMESTAMP + (86400 * 7);\n', '\n', '    // 8888 Apes\n', '    uint256 public constant MAX_NFT_SUPPLY = 8888;\n', '\n', '    // 25% Airdrop!\n', '    uint256 public constant MAX_CLAIMABLE_SUPPLY = 2222;\n', '\n', '    // Flat price 0.1 ETH\n', '    uint256 public constant FLAT_PRICE = 100000000000000000;\n', '\n', '    // Whitelisted NFT project\n', '    EnumerableSet.AddressSet private _claimableContracts;\n', '\n', '    // If token is minted by owning a NFT    \n', '    EnumerableSet.UintSet private _claimedTokenIds;\n', '\n', '    // You can only claim one Ape per owner\n', '    mapping (address => bool) private _claimedTokenOwners;\n', '\n', '    uint256 public startingIndexBlock;\n', '\n', '    uint256 public startingIndex;\n', '\n', '    /*\n', "     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n", "     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n", "     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n", "     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n", '     *\n', '     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n', '     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n', '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '\n', '    /*\n', "     *     bytes4(keccak256('name()')) == 0x06fdde03\n", "     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n", '     *\n', '     *     => 0x06fdde03 ^ 0x95d89b41 == 0x93254542\n', '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x93254542;\n', '\n', '    /*\n', "     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n", "     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n", "     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n", '     *\n', '     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n', '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '\n', '    constructor (string memory name, string memory symbol, string memory baseUri) ERC721(name, symbol) {        \n', '        _setBaseURI(baseUri);\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '    }\n', '\n', '    function setBaseURI(string memory baseURI) public onlyOwner {\n', '        _setBaseURI(baseURI);\n', '    }\n', '\n', '    function getNFTPrice() public view returns (uint256) {\n', '        require(block.timestamp >= SALE_START_TIMESTAMP, "Sale has not started");\n', '        require(totalSupply() < MAX_NFT_SUPPLY, "Sale has already ended");\n', '        return FLAT_PRICE;\n', '    }\n', '\n', '    function totalClaimedSupply() public view returns (uint256) {              \n', '        return _claimedTokenIds.length();\n', '    }\n', '\n', '    function addClaimableContracts(address[] memory contractAddresses) public onlyOwner {\n', '        for (uint i = 0; i < contractAddresses.length; i++) {\n', '            _claimableContracts.add(contractAddresses[i]);\n', '        }\n', '    }\n', '\n', '    function removeClaimableContract(address contractAddress) public onlyOwner {\n', '        _claimableContracts.remove(contractAddress);\n', '    }\n', '\n', '    function claimableContractsLength() public view returns (uint256) {\n', '        return _claimableContracts.length();\n', '    }\n', '\n', '    function claimableContractAt(uint256 index) public view returns (address) {\n', '        return _claimableContracts.at(index);\n', '    }\n', '\n', '    function claimNFT(address contractAddress) public {\n', '        require(block.timestamp < REVEAL_TIMESTAMP, "Reveal date has passed");\n', '        require(totalSupply() < MAX_NFT_SUPPLY, "Sale has already ended");\n', '        require(totalClaimedSupply() < MAX_CLAIMABLE_SUPPLY, "All claimable tokens have been claimed");  \n', '        require(!isClaimedOwner(msg.sender), "Owner has already claimed a token");        \n', '        require(isNFTOwner(contractAddress, msg.sender), "Caller does not own token for passed contract");\n', '\n', '        uint mintIndex = totalSupply();\n', '        _claimedTokenIds.add(mintIndex);\n', '        _claimedTokenOwners[msg.sender] = true;\n', '        _safeMint(msg.sender, mintIndex);\n', '    }\n', '\n', '    function isNFTOwner(address contractAddress, address owner) public view returns (bool) {\n', '        require(_claimableContracts.contains(contractAddress), "Contract is not eligible yet");\n', '        return ClaimContract(contractAddress).balanceOf(owner) > 0;\n', '    }\n', '\n', '    function isClaimedOwner(address owner) public view returns (bool) {\n', '        return _claimedTokenOwners[owner];\n', '    }\n', '\n', '    function isClaimedNFT(uint256 index) public view returns (bool) {\n', '        return _claimedTokenIds.contains(index);\n', '    }\n', '\n', '    function mintNFT(uint256 numberOfNfts) public payable {\n', '        require(totalSupply() < MAX_NFT_SUPPLY, "Sale has already ended");\n', '        require(numberOfNfts > 0, "Number of NFT must be > 0");\n', '        require(numberOfNfts <= 50, "Number of NFT must not be > 50");\n', '        require(totalSupply().add(numberOfNfts) <= MAX_NFT_SUPPLY, "Exceeds total number of NFT");\n', '        require(getNFTPrice().mul(numberOfNfts) == msg.value, "Ether value sent is not correct");\n', '\n', '        for (uint i = 0; i < numberOfNfts; i++) {\n', '            uint mintIndex = totalSupply();\n', '            _safeMint(msg.sender, mintIndex);\n', '        }\n', '\n', '        /**\n', '        * Source of randomness. Theoretical miner withhold manipulation possible but should be sufficient in a pragmatic sense\n', '        */\n', '        if (startingIndexBlock == 0 && (totalSupply() == MAX_NFT_SUPPLY || block.timestamp >= REVEAL_TIMESTAMP)) {\n', '            startingIndexBlock = block.number;\n', '        }\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Finalize starting index\n', '     */\n', '    function finalizeStartingIndex() public {\n', '        require(startingIndex == 0, "Starting index is already set");\n', '        require(startingIndexBlock != 0, "Starting index block must be set");\n', '        \n', '        startingIndex = uint(blockhash(startingIndexBlock)) % MAX_NFT_SUPPLY;\n', '        // Just a sanity case in the worst case if this function is called late (EVM only stores last 256 block hashes)\n', '        if (block.number.sub(startingIndexBlock) > 255) {\n', '            startingIndex = uint(blockhash(block.number-1)) % MAX_NFT_SUPPLY;\n', '        }\n', '        // Prevent default sequence\n', '        if (startingIndex == 0) {\n', '            startingIndex = startingIndex.add(1);\n', '        }\n', '    }\n', '\n', '    function withdraw() onlyOwner public {\n', '        uint balance = address(this).balance;\n', '        msg.sender.transfer(balance);\n', '    }\n', '}']