['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-11\n', '*/\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'contract GebMath {\n', '    uint256 public constant RAY = 10 ** 27;\n', '    uint256 public constant WAD = 10 ** 18;\n', '\n', '    function ray(uint x) public pure returns (uint z) {\n', '        z = multiply(x, 10 ** 9);\n', '    }\n', '    function rad(uint x) public pure returns (uint z) {\n', '        z = multiply(x, 10 ** 27);\n', '    }\n', '    function minimum(uint x, uint y) public pure returns (uint z) {\n', '        z = (x <= y) ? x : y;\n', '    }\n', '    function addition(uint x, uint y) public pure returns (uint z) {\n', '        z = x + y;\n', '        require(z >= x, "uint-uint-add-overflow");\n', '    }\n', '    function subtract(uint x, uint y) public pure returns (uint z) {\n', '        z = x - y;\n', '        require(z <= x, "uint-uint-sub-underflow");\n', '    }\n', '    function multiply(uint x, uint y) public pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "uint-uint-mul-overflow");\n', '    }\n', '    function rmultiply(uint x, uint y) public pure returns (uint z) {\n', '        z = multiply(x, y) / RAY;\n', '    }\n', '    function rdivide(uint x, uint y) public pure returns (uint z) {\n', '        z = multiply(x, RAY) / y;\n', '    }\n', '    function wdivide(uint x, uint y) public pure returns (uint z) {\n', '        z = multiply(x, WAD) / y;\n', '    }\n', '    function wmultiply(uint x, uint y) public pure returns (uint z) {\n', '        z = multiply(x, y) / WAD;\n', '    }\n', '    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\n', '        assembly {\n', '            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n', '            default {\n', '                switch mod(n, 2) case 0 { z := base } default { z := x }\n', '                let half := div(base, 2)  // for rounding.\n', '                for { n := div(n, 2) } n { n := div(n,2) } {\n', '                    let xx := mul(x, x)\n', '                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n', '                    let xxRound := add(xx, half)\n', '                    if lt(xxRound, xx) { revert(0,0) }\n', '                    x := div(xxRound, base)\n', '                    if mod(n,2) {\n', '                        let zx := mul(z, x)\n', '                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n', '                        let zxRound := add(zx, half)\n', '                        if lt(zxRound, zx) { revert(0,0) }\n', '                        z := div(zxRound, base)\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract StabilityFeeTreasuryLike {\n', '    function getAllowance(address) virtual external view returns (uint, uint);\n', '    function systemCoin() virtual external view returns (address);\n', '    function pullFunds(address, address, uint) virtual external;\n', '    function setTotalAllowance(address, uint256) external virtual;\n', '    function setPerBlockAllowance(address, uint256) external virtual;    \n', '}\n', '\n', 'contract MandatoryFixedTreasuryReimbursement is GebMath {\n', '    // --- Auth ---\n', '    mapping (address => uint) public authorizedAccounts;\n', '    /**\n', '     * @notice Add auth to an account\n', '     * @param account Account to add auth to\n', '     */\n', '    function addAuthorization(address account) virtual external isAuthorized {\n', '        authorizedAccounts[account] = 1;\n', '        emit AddAuthorization(account);\n', '    }\n', '    /**\n', '     * @notice Remove auth from an account\n', '     * @param account Account to remove auth from\n', '     */\n', '    function removeAuthorization(address account) virtual external isAuthorized {\n', '        authorizedAccounts[account] = 0;\n', '        emit RemoveAuthorization(account);\n', '    }\n', '    /**\n', '    * @notice Checks whether msg.sender can call an authed function\n', '    **/\n', '    modifier isAuthorized {\n', '        require(authorizedAccounts[msg.sender] == 1, "MandatoryFixedTreasuryReimbursement/account-not-authorized");\n', '        _;\n', '    }\n', '\n', '    // --- Variables ---\n', '    // The fixed reward sent by the treasury to a fee receiver\n', '    uint256 public fixedReward;               // [wad]\n', '    // SF treasury\n', '    StabilityFeeTreasuryLike public treasury;\n', '\n', '    // --- Events ---\n', '    event AddAuthorization(address account);\n', '    event RemoveAuthorization(address account);\n', '    event ModifyParameters(\n', '      bytes32 parameter,\n', '      address addr\n', '    );\n', '    event ModifyParameters(\n', '      bytes32 parameter,\n', '      uint256 val\n', '    );\n', '    event RewardCaller(address indexed finalFeeReceiver, uint256 fixedReward);\n', '\n', '    constructor(address treasury_, uint256 fixedReward_) public {\n', '        require(fixedReward_ > 0, "MandatoryFixedTreasuryReimbursement/null-reward");\n', '        require(treasury_ != address(0), "MandatoryFixedTreasuryReimbursement/null-treasury");\n', '\n', '        authorizedAccounts[msg.sender] = 1;\n', '\n', '        treasury    = StabilityFeeTreasuryLike(treasury_);\n', '        fixedReward = fixedReward_;\n', '\n', '        emit AddAuthorization(msg.sender);\n', '        emit ModifyParameters("treasury", treasury_);\n', '        emit ModifyParameters("fixedReward", fixedReward);\n', '    }\n', '\n', '    // --- Boolean Logic ---\n', '    function both(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := and(x, y)}\n', '    }\n', '\n', '    // --- Treasury Utils ---\n', '    /*\n', '    * @notify Return the amount of SF that the treasury can transfer in one transaction when called by this contract\n', '    */\n', '    function treasuryAllowance() public view returns (uint256) {\n', '        (uint total, uint perBlock) = treasury.getAllowance(address(this));\n', '        return minimum(total, perBlock);\n', '    }\n', '    /*\n', '    * @notify Get the actual reward to be sent by taking the minimum between the fixed reward and the amount that can be sent by the treasury\n', '    */\n', '    function getCallerReward() public view returns (uint256 reward) {\n', '        reward = minimum(fixedReward, treasuryAllowance() / RAY);\n', '    }\n', '    /*\n', '    * @notice Send a SF reward to a fee receiver by calling the treasury\n', '    * @param proposedFeeReceiver The address that will receive the reward (unless null in which case msg.sender will receive it)\n', '    */\n', '    function rewardCaller(address proposedFeeReceiver) internal {\n', '        // If the receiver is the treasury itself or if the treasury is null or if the reward is zero, revert\n', '        require(address(treasury) != proposedFeeReceiver, "MandatoryFixedTreasuryReimbursement/reward-receiver-cannot-be-treasury");\n', '        require(both(address(treasury) != address(0), fixedReward > 0), "MandatoryFixedTreasuryReimbursement/invalid-treasury-or-reward");\n', '\n', '        // Determine the actual fee receiver and reward them\n', '        address finalFeeReceiver = (proposedFeeReceiver == address(0)) ? msg.sender : proposedFeeReceiver;\n', '        uint256 finalReward      = getCallerReward();\n', '        treasury.pullFunds(finalFeeReceiver, treasury.systemCoin(), finalReward);\n', '\n', '        emit RewardCaller(finalFeeReceiver, finalReward);\n', '    }\n', '}\n', '\n', 'abstract contract AccountingEngineLike {\n', '    function debtPoppers(uint256) virtual public view returns (address);\n', '}\n', '\n', 'contract DebtPopperRewards is MandatoryFixedTreasuryReimbursement {\n', '    // --- Variables ---\n', '    // When the next reward period starts\n', '    uint256 public rewardPeriodStart;                    // [unix timestamp]\n', '    // Delay between two consecutive reward periods\n', '    uint256 public interPeriodDelay;                     // [seconds]\n', '    // Time (after a block of debt is popped) after which no reward can be given anymore\n', '    uint256 public rewardTimeline;                       // [seconds]\n', '    // Amount of pops that can be rewarded per period\n', '    uint256 public maxPerPeriodPops;\n', '    // Timestamp from which the contract accepts requests for rewarding debt poppers\n', '    uint256 public rewardStartTime;\n', '\n', '    // Whether a debt block has been popped\n', '    mapping(uint256 => bool)    public rewardedPop;      // [unix timestamp => bool]\n', '    // Amount of pops that were rewarded in each period\n', '    mapping(uint256 => uint256) public rewardsPerPeriod; // [unix timestamp => wad]\n', '\n', '    // Accounting engine contract\n', '    AccountingEngineLike        public accountingEngine;\n', '\n', '    // --- Events ---\n', '    event SetRewardPeriodStart(uint256 rewardPeriodStart);\n', '    event RewardForPop(uint256 slotTimestamp, uint256 reward);\n', '\n', '    constructor(\n', '        address accountingEngine_,\n', '        address treasury_,\n', '        uint256 rewardPeriodStart_,\n', '        uint256 interPeriodDelay_,\n', '        uint256 rewardTimeline_,\n', '        uint256 fixedReward_,\n', '        uint256 maxPerPeriodPops_,\n', '        uint256 rewardStartTime_\n', '    ) public MandatoryFixedTreasuryReimbursement(treasury_, fixedReward_) {\n', '        require(rewardPeriodStart_ >= now, "DebtPopperRewards/invalid-reward-period-start");\n', '        require(interPeriodDelay_ > 0, "DebtPopperRewards/invalid-inter-period-delay");\n', '        require(rewardTimeline_ > 0, "DebtPopperRewards/invalid-harvest-timeline");\n', '        require(maxPerPeriodPops_ > 0, "DebtPopperRewards/invalid-max-per-period-pops");\n', '        require(accountingEngine_ != address(0), "DebtPopperRewards/null-accounting-engine");\n', '\n', '        accountingEngine   = AccountingEngineLike(accountingEngine_);\n', '\n', '        rewardPeriodStart  = rewardPeriodStart_;\n', '        interPeriodDelay   = interPeriodDelay_;\n', '        rewardTimeline     = rewardTimeline_;\n', '        fixedReward        = fixedReward_;\n', '        maxPerPeriodPops   = maxPerPeriodPops_;\n', '        rewardStartTime    = rewardStartTime_;\n', '\n', '        emit ModifyParameters("accountingEngine", accountingEngine_);\n', '        emit ModifyParameters("interPeriodDelay", interPeriodDelay);\n', '        emit ModifyParameters("rewardTimeline", rewardTimeline);\n', '        emit ModifyParameters("rewardStartTime", rewardStartTime);\n', '        emit ModifyParameters("maxPerPeriodPops", maxPerPeriodPops);\n', '\n', '        emit SetRewardPeriodStart(rewardPeriodStart);\n', '    }\n', '\n', '    // --- Administration ---\n', '    /*\n', '    * @notify Modify a uint256 parameter\n', '    * @param parameter The parameter name\n', '    * @param val The new value for the parameter\n', '    */\n', '    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\n', '        require(val > 0, "DebtPopperRewards/invalid-value");\n', '        if (parameter == "interPeriodDelay") {\n', '          interPeriodDelay = val;\n', '        }\n', '        else if (parameter == "rewardTimeline") {\n', '          rewardTimeline = val;\n', '        }\n', '        else if (parameter == "fixedReward") {\n', '          require(val > 0, "DebtPopperRewards/null-reward");\n', '          fixedReward = val;\n', '        }\n', '        else if (parameter == "maxPerPeriodPops") {\n', '          maxPerPeriodPops = val;\n', '        }\n', '        else if (parameter == "rewardPeriodStart") {\n', '          require(val > now, "DebtPopperRewards/invalid-reward-period-start");\n', '          rewardPeriodStart = val;\n', '        }\n', '        else revert("DebtPopperRewards/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, val);\n', '    }\n', '    /*\n', '    * @notify Set a new treasury address\n', '    * @param parameter The parameter name\n', '    * @param addr The new address for the parameter\n', '    */\n', '    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n', '        require(addr != address(0), "DebtPopperRewards/null-address");\n', '        if (parameter == "treasury") treasury = StabilityFeeTreasuryLike(addr);\n', '        else revert("DebtPopperRewards/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, addr);\n', '    }\n', '\n', '    /*\n', '    * @notify Get rewarded for popping a debt slot from the AccountingEngine debt queue\n', '    * @oaran slotTimestamp The time of the popped slot\n', '    * @param feeReceiver The address that will receive the reward for popping\n', '    */\n', '    function getRewardForPop(uint256 slotTimestamp, address feeReceiver) external {\n', '        // Perform checks\n', '        require(slotTimestamp >= rewardStartTime, "DebtPopperRewards/slot-time-before-reward-start");\n', '        require(slotTimestamp < now, "DebtPopperRewards/slot-cannot-be-in-the-future");\n', '        require(now >= rewardPeriodStart, "DebtPopperRewards/wait-more");\n', '        require(addition(slotTimestamp, rewardTimeline) >= now, "DebtPopperRewards/missed-reward-window");\n', '        require(accountingEngine.debtPoppers(slotTimestamp) == msg.sender, "DebtPopperRewards/not-debt-popper");\n', '        require(!rewardedPop[slotTimestamp], "DebtPopperRewards/pop-already-rewarded");\n', '        require(getCallerReward() >= fixedReward, "DebtPopperRewards/invalid-available-reward");\n', '\n', '        // Update state\n', '        rewardedPop[slotTimestamp]          = true;\n', '        rewardsPerPeriod[rewardPeriodStart] = addition(rewardsPerPeriod[rewardPeriodStart], 1);\n', '\n', '        // If we offered rewards for too many pops, enforce a delay since rewards are available again\n', '        if (rewardsPerPeriod[rewardPeriodStart] >= maxPerPeriodPops) {\n', '          rewardPeriodStart = addition(now, interPeriodDelay);\n', '          emit SetRewardPeriodStart(rewardPeriodStart);\n', '        }\n', '\n', '        emit RewardForPop(slotTimestamp, fixedReward);\n', '\n', '        // Give the reward\n', '        rewardCaller(feeReceiver);\n', '    }\n', '}']