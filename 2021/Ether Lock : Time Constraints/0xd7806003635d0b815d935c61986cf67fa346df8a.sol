['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-10\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.0;\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        (bool success, ) = recipient.call{value: amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '    function functionCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.call{value: value}(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '    function functionStaticCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '    function functionDelegateCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(\n', '        bool success,\n', '        bytes memory returndata,\n', '        string memory errorMessage\n', '    ) private pure returns (bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '  \n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  \n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '  \n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender) + value;\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        unchecked {\n', '            uint256 oldAllowance = token.allowance(address(this), spender);\n', '            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n', '            uint256 newAllowance = oldAllowance - value;\n', '            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '        }\n', '    }\n', '\n', '  \n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '      \n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Whitelist is Ownable {\n', '\n', ' // 1 => whitelisted; 0 => NOT whitelisted\n', '  mapping (address => uint8) public whitelistedMap;\n', '\n', ' // true => whitelist is activated; false => whitelist is deactivated\n', '  bool public WhitelistStatus;\n', '  \n', '  event WhitelistStatusChanged(bool indexed Status);\n', '\n', '  constructor() {\n', '    WhitelistStatus = true;\n', '  }\n', '\n', '  modifier Whitelisted() {\n', "    require(whitelistedMap[msg.sender] == 1 || WhitelistStatus == false, 'You are not whitelisted');\n", '  _;}\n', '\n', '  function whitelistAddress(address[] calldata AddressList)\n', '    public\n', '    onlyOwner\n', '  {\n', '    uint j;\n', '    for (j = 0; j < AddressList.length; ++j)\n', '    {\n', '    whitelistedMap[AddressList[j]] = 1;\n', '    }\n', '  }\n', '\n', '  function blacklistAddress(address[] calldata AdressList)\n', '    public\n', '    onlyOwner\n', '    \n', '  {\n', '    uint j;\n', '    for (j = 0; j < AdressList.length; ++j)\n', '    {\n', '    whitelistedMap[AdressList[j]] = 2;\n', '    }\n', '  }\n', '\n', '  function changeWhitelistStatus()\n', '    public\n', '    onlyOwner\n', '  {\n', '    if (WhitelistStatus == true){\n', '      WhitelistStatus = false;\n', '      emit WhitelistStatusChanged(false);\n', '    }else{\n', '      WhitelistStatus = true;\n', '      emit WhitelistStatusChanged(true);\n', '    }\n', '  }\n', '}\n', '\n', 'contract IFOV3 is Whitelist{\n', '    using SafeERC20 for IERC20;\n', '\n', '    // The LP token used\n', '    IERC20 public lpToken;\n', '\n', '    // The offering token\n', '    IERC20 public offeringToken;\n', '\n', '    // Number of pools\n', '    uint8 public constant numberPools = 3;\n', '\n', '    uint public HarvestDelay;\n', '\n', '    // The block number when IFO starts\n', '    uint256 public startBlock;\n', '\n', '    // The block number when IFO ends\n', '    uint256 public endBlock;\n', '\n', '    PoolCharacteristics[numberPools] private _poolInformation;\n', '\n', '    mapping(address => mapping(uint8 => uint256)) private amountPool;\n', '\n', '    struct PoolCharacteristics {\n', '        uint256 offeringAmountPool; \n', '        uint256 priceA; \n', '        uint256 priceB; \n', '        uint256 totalAmountPool; \n', '    }\n', '\n', '    event AdminWithdraw(uint256 amountLP, uint256 amountOfferingToken, uint256 amountWei);\n', '\n', '    event AdminTokenRecovery(address tokenAddress, uint256 amountTokens);\n', '\n', '    event Deposit(address indexed user, uint256 amount, uint8 indexed pid);\n', '\n', '    event Harvest(address indexed user, uint256 offeringAmount, uint256 excessAmount, uint8 indexed pid);\n', '\n', '    event NewStartAndEndBlocks(uint256 startBlock, uint256 endBlock);\n', '\n', '    event PoolParametersSet(uint256 offeringAmountPool, uint priceA_, uint priceB_, uint8 pid);\n', '\n', '    modifier TimeLock() {\n', "        require(block.number > endBlock + 90000, 'Admin must wait before calling this function');\n", '    _;}\n', '\n', '    constructor(\n', '        IERC20 _lpToken,\n', '        IERC20 _offeringToken,\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint _harvestdelay\n', '    ) {\n', '        lpToken = _lpToken;\n', '        offeringToken = _offeringToken;\n', '        startBlock = _startBlock;\n', '        endBlock = _endBlock;\n', '        HarvestDelay = _harvestdelay;\n', '    }\n', '\n', '    function depositPool(uint256 _amount, uint8 _pid) external {\n', '\n', '        require(_pid < numberPools, "Non valid pool id");\n', '\n', '        require(_poolInformation[_pid].offeringAmountPool > 0, "Pool not set");\n', '\n', '        require(block.number > startBlock, "Too early");\n', '\n', '        require(block.number < endBlock, "Too late");\n', '\n', '        require(_amount > 0, "Amount must be > 0");\n', '\n', '\n', '        if(_pid == 0){\n', '          require(\n', '            _poolInformation[_pid].offeringAmountPool >= (_poolInformation[_pid].totalAmountPool + (_amount)) * (_poolInformation[_pid].priceA),\n', "            'not enough Offering Tokens left in Pool1');\n", '        }\n', '\n', '        lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n', '\n', '        amountPool[msg.sender][_pid] += _amount;\n', '\n', '        _poolInformation[_pid].totalAmountPool += _amount;\n', '\n', '        emit Deposit(msg.sender, _amount, _pid);\n', '    }\n', '\n', '    function harvestPool(uint8 _pid) external {\n', '\n', '        require(block.number > endBlock + HarvestDelay, "Too early to harvest");\n', '\n', '        require(_pid < numberPools, "Non valid pool id");\n', '\n', '        require(amountPool[msg.sender][_pid] > 0, "Did not participate");\n', '\n', '        if(whitelistedMap[msg.sender] != 1 && WhitelistStatus == true){\n', '          uint amount = amountPool[msg.sender][_pid];\n', '          amountPool[msg.sender][_pid] = 0;\n', '          lpToken.safeTransfer(address(msg.sender), amount);\n', '          emit Harvest(msg.sender, 0, amount, _pid);\n', '        }else{\n', '\n', '          uint256 offeringTokenAmount;\n', '          uint256 refundingTokenAmount;\n', '\n', '          (offeringTokenAmount, refundingTokenAmount) = _calculateOfferingAndRefundingAmountsPool(\n', '            msg.sender,\n', '            _pid\n', '          );\n', '\n', '          amountPool[msg.sender][_pid] = 0;\n', '\n', '          if (offeringTokenAmount > 0) {\n', '            offeringToken.safeTransfer(address(msg.sender), offeringTokenAmount);\n', '          }\n', '\n', '          if (refundingTokenAmount > 0) {\n', '            lpToken.safeTransfer(address(msg.sender), refundingTokenAmount);\n', '          }\n', '\n', '          emit Harvest(msg.sender, offeringTokenAmount, refundingTokenAmount, _pid);\n', '        }\n', '    }\n', '\n', '    function finalWithdraw(uint256 _lpAmount, uint256 _offerAmount, uint256 _weiAmount) external  onlyOwner TimeLock {\n', '        require(_lpAmount <= lpToken.balanceOf(address(this)), "Not enough LP tokens");\n', '        require(_offerAmount <= offeringToken.balanceOf(address(this)), "Not enough offering token");\n', '\n', '        if (_lpAmount > 0) {\n', '            lpToken.safeTransfer(address(msg.sender), _lpAmount);\n', '        }\n', '\n', '        if (_offerAmount > 0) {\n', '            offeringToken.safeTransfer(address(msg.sender), _offerAmount);\n', '        }\n', '\n', '        if (_weiAmount > 0){\n', '            payable(address(msg.sender)).transfer(_weiAmount);\n', '        }\n', '\n', '        emit AdminWithdraw(_lpAmount, _offerAmount, _weiAmount);\n', '    }\n', '\n', '    function recoverWrongTokens(address _tokenAddress, uint256 _tokenAmount) external onlyOwner {\n', '        require(_tokenAddress != address(lpToken), "Cannot be LP token");\n', '        require(_tokenAddress != address(offeringToken), "Cannot be offering token");\n', '\n', '        IERC20(_tokenAddress).safeTransfer(address(msg.sender), _tokenAmount);\n', '\n', '        emit AdminTokenRecovery(_tokenAddress, _tokenAmount);\n', '    }\n', '    function setPool(\n', '        uint256 _offeringAmountPool,\n', '        uint256 _priceA,\n', '        uint _priceB,\n', '        uint8 _pid\n', '    ) external  onlyOwner TimeLock {\n', '        require(_pid < numberPools, "Pool does not exist");\n', '\n', '        _poolInformation[_pid].offeringAmountPool = _offeringAmountPool;\n', '        _poolInformation[_pid].priceA = _priceA;\n', '        _poolInformation[_pid].priceB = _priceB;\n', '\n', '        uint sum = 0;\n', '        for (uint j = 0; j < numberPools; j++){\n', '            sum += _poolInformation[j].offeringAmountPool;\n', '        }\n', '        require(sum <= offeringToken.balanceOf(address(this)),\n', "        'cant offer more than balance');\n", '\n', '        emit PoolParametersSet(_offeringAmountPool, _priceA, _priceB, _pid);\n', '    }\n', '\n', '    function updateStartAndEndBlocks(uint256 _startBlock, uint256 _endBlock) external onlyOwner TimeLock {\n', '        require(_startBlock < _endBlock, "New startBlock must be lower than new endBlock");\n', '        require(block.number < _startBlock, "New startBlock must be higher than current block");\n', '        for(uint j = 0; j < numberPools; j++){\n', '            _poolInformation[j].totalAmountPool = 0;\n', '        }\n', '        startBlock = _startBlock;\n', '        endBlock = _endBlock;\n', '\n', '        emit NewStartAndEndBlocks(_startBlock, _endBlock);\n', '    }\n', '\n', '    function viewPoolInformation(uint256 _pid)\n', '        external\n', '        view\n', '        \n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        return (\n', '            _poolInformation[_pid].offeringAmountPool,\n', '            _poolInformation[_pid].priceA,\n', '            _poolInformation[_pid].priceB,\n', '            _poolInformation[_pid].totalAmountPool\n', '        );\n', '    }\n', '\n', '    function viewUserAllocationPools(address _user, uint8[] calldata _pids)\n', '        external\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        uint256[] memory allocationPools = new uint256[](_pids.length);\n', '        for (uint8 i = 0; i < _pids.length; i++) {\n', '            allocationPools[i] = _getUserAllocationPool(_user, _pids[i]);\n', '        }\n', '        return allocationPools;\n', '    }\n', '\n', '    function viewUserAmount(address _user, uint8[] calldata _pids)\n', '        external\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        uint256[] memory amountPools = new uint256[](_pids.length);\n', '\n', '        for (uint8 i = 0; i < numberPools; i++) {\n', '            amountPools[i] = amountPool[_user][i];\n', '        }\n', '        return (amountPools);\n', '    }\n', '    function viewUserOfferingAndRefundingAmountsForPools(address _user, uint8[] calldata _pids)\n', '        external\n', '        view\n', '        returns (uint256[2][] memory)\n', '    {\n', '        uint256[2][] memory amountPools = new uint256[2][](_pids.length);\n', '\n', '        for (uint8 i = 0; i < _pids.length; i++) {\n', '            uint256 userOfferingAmountPool;\n', '            uint256 userRefundingAmountPool;\n', '\n', '            if (_poolInformation[_pids[i]].offeringAmountPool > 0) {\n', '                (\n', '                    userOfferingAmountPool,\n', '                    userRefundingAmountPool\n', '                ) = _calculateOfferingAndRefundingAmountsPool(_user, _pids[i]);\n', '            }\n', '\n', '            amountPools[i] = [userOfferingAmountPool, userRefundingAmountPool];\n', '        }\n', '        return amountPools;\n', '    }\n', '    function _calculateOfferingAndRefundingAmountsPool(address _user, uint8 _pid)\n', '        internal\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '      if(amountPool[_user][_pid] == 0){\n', '        return(0, 0);\n', '      }\n', '\n', '      uint256 userOfferingAmount;\n', '      uint256 userRefundingAmount;\n', '      if (_pid == 0){\n', '        userOfferingAmount = amountPool[_user][0] * (_poolInformation[0].priceA);\n', '        return (userOfferingAmount, 0);\n', '      }\n', '\n', '      uint256 allocation = _getUserAllocationPool(_user, _pid);\n', '      if (_pid == 2){\n', '        userOfferingAmount = _poolInformation[2].offeringAmountPool * (allocation) / (1e12);\n', '        return (userOfferingAmount, 0);\n', '      }\n', '      if (_poolInformation[1].totalAmountPool * (_poolInformation[1].priceA) > _poolInformation[1].offeringAmountPool){\n', '        userOfferingAmount = _poolInformation[1].offeringAmountPool * (allocation) / (1e12);\n', '      }else{\n', '        userOfferingAmount = amountPool[_user][1] * (_poolInformation[1].priceA);\n', '        return(userOfferingAmount, 0);\n', '      }\n', '      if (_poolInformation[1].totalAmountPool * (_poolInformation[1].priceB) <= _poolInformation[1].offeringAmountPool){\n', '        return (userOfferingAmount, 0);\n', '      }else{\n', '        uint notcompensatedAmount = _poolInformation[1].totalAmountPool - (_poolInformation[1].offeringAmountPool / (_poolInformation[1].priceB));\n', '        userRefundingAmount = allocation * (notcompensatedAmount) / (1e12);\n', '        return (userOfferingAmount, userRefundingAmount);\n', '      }\n', '    }\n', '\n', '    function _getUserAllocationPool(address _user, uint8 _pid) internal view returns (uint256) {\n', '        if (_poolInformation[_pid].totalAmountPool > 0) {\n', '            return amountPool[_user][_pid] * (1e12) / _poolInformation[_pid].totalAmountPool;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '    function SetHarvestDelay(uint _HarvestDelay) external onlyOwner {\n', "        require( _HarvestDelay < 90000, 'max delay is 90000 blocks');\n", '        HarvestDelay = _HarvestDelay;\n', '    }\n', '    fallback() external payable{}\n', '}']