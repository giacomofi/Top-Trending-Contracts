['// SPDX-License-Identifier: MIT\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', '\n', 'import "./ABDKMath64x64.sol";\n', 'import "./IAssimilator.sol";\n', 'import "./IOracle.sol";\n', '\n', 'contract XsgdToUsdAssimilator is IAssimilator {\n', '    using ABDKMath64x64 for int128;\n', '    using ABDKMath64x64 for uint256;\n', '\n', '    using SafeMath for uint256;\n', '\n', '    IERC20 private constant usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n', '\n', '    IOracle private constant oracle = IOracle(0xe25277fF4bbF9081C75Ab0EB13B4A13a721f3E13);\n', '    IERC20 private constant xsgd = IERC20(0x70e8dE73cE538DA2bEEd35d14187F6959a8ecA96);\n', '\n', '    // solhint-disable-next-line\n', '    constructor() {}\n', '\n', '    function getRate() public view override returns (uint256) {\n', '        (, int256 price, , , ) = oracle.latestRoundData();\n', '        return uint256(price);\n', '    }\n', '\n', '    // takes raw xsgd amount, transfers it in, calculates corresponding numeraire amount and returns it\n', '    function intakeRawAndGetBalance(uint256 _amount) external override returns (int128 amount_, int128 balance_) {\n', '        bool _transferSuccess = xsgd.transferFrom(msg.sender, address(this), _amount);\n', '\n', '        require(_transferSuccess, "Curve/XSGD-transfer-from-failed");\n', '\n', '        uint256 _balance = xsgd.balanceOf(address(this));\n', '\n', '        uint256 _rate = getRate();\n', '\n', '        balance_ = ((_balance * _rate) / 1e8).divu(1e6);\n', '\n', '        amount_ = ((_amount * _rate) / 1e8).divu(1e6);\n', '    }\n', '\n', '    // takes raw xsgd amount, transfers it in, calculates corresponding numeraire amount and returns it\n', '    function intakeRaw(uint256 _amount) external override returns (int128 amount_) {\n', '        bool _transferSuccess = xsgd.transferFrom(msg.sender, address(this), _amount);\n', '\n', '        require(_transferSuccess, "Curve/XSGD-transfer-from-failed");\n', '\n', '        uint256 _rate = getRate();\n', '\n', '        amount_ = ((_amount * _rate) / 1e8).divu(1e6);\n', '    }\n', '\n', '    // takes a numeraire amount, calculates the raw amount of xsgd, transfers it in and returns the corresponding raw amount\n', '    function intakeNumeraire(int128 _amount) external override returns (uint256 amount_) {\n', '        uint256 _rate = getRate();\n', '\n', '        amount_ = (_amount.mulu(1e6) * 1e8) / _rate;\n', '\n', '        bool _transferSuccess = xsgd.transferFrom(msg.sender, address(this), amount_);\n', '\n', '        require(_transferSuccess, "Curve/XSGD-transfer-from-failed");\n', '    }\n', '\n', '    // takes a numeraire amount, calculates the raw amount of xsgd, transfers it in and returns the corresponding raw amount\n', '    function intakeNumeraireLPRatio(\n', '        uint256 _baseWeight,\n', '        uint256 _quoteWeight,\n', '        address _addr,\n', '        int128 _amount\n', '    ) external override returns (uint256 amount_) {\n', '        uint256 _xsgdBal = xsgd.balanceOf(_addr);\n', '\n', '        if (_xsgdBal <= 0) return 0;\n', '\n', '        // 1e6\n', '        _xsgdBal = _xsgdBal.mul(1e18).div(_baseWeight);\n', '\n', '        // 1e6\n', '        uint256 _usdcBal = usdc.balanceOf(_addr).mul(1e18).div(_quoteWeight);\n', '\n', '        // Rate is in 1e6\n', '        uint256 _rate = _usdcBal.mul(1e6).div(_xsgdBal);\n', '\n', '        amount_ = (_amount.mulu(1e6) * 1e6) / _rate;\n', '\n', '        bool _transferSuccess = xsgd.transferFrom(msg.sender, address(this), amount_);\n', '\n', '        require(_transferSuccess, "Curve/XSGD-transfer-failed");\n', '    }\n', '\n', '    // takes a raw amount of xsgd and transfers it out, returns numeraire value of the raw amount\n', '    function outputRawAndGetBalance(address _dst, uint256 _amount)\n', '        external\n', '        override\n', '        returns (int128 amount_, int128 balance_)\n', '    {\n', '        uint256 _rate = getRate();\n', '\n', '        uint256 _xsgdAmount = ((_amount) * _rate) / 1e8;\n', '\n', '        bool _transferSuccess = xsgd.transfer(_dst, _xsgdAmount);\n', '\n', '        require(_transferSuccess, "Curve/XSGD-transfer-failed");\n', '\n', '        uint256 _balance = xsgd.balanceOf(address(this));\n', '\n', '        amount_ = _xsgdAmount.divu(1e6);\n', '\n', '        balance_ = ((_balance * _rate) / 1e8).divu(1e6);\n', '    }\n', '\n', '    // takes a raw amount of xsgd and transfers it out, returns numeraire value of the raw amount\n', '    function outputRaw(address _dst, uint256 _amount) external override returns (int128 amount_) {\n', '        uint256 _rate = getRate();\n', '\n', '        uint256 _xsgdAmount = (_amount * _rate) / 1e8;\n', '\n', '        bool _transferSuccess = xsgd.transfer(_dst, _xsgdAmount);\n', '\n', '        require(_transferSuccess, "Curve/XSGD-transfer-failed");\n', '\n', '        amount_ = _xsgdAmount.divu(1e6);\n', '    }\n', '\n', '    // takes a numeraire value of xsgd, figures out the raw amount, transfers raw amount out, and returns raw amount\n', '    function outputNumeraire(address _dst, int128 _amount) external override returns (uint256 amount_) {\n', '        uint256 _rate = getRate();\n', '\n', '        amount_ = (_amount.mulu(1e6) * 1e8) / _rate;\n', '\n', '        bool _transferSuccess = xsgd.transfer(_dst, amount_);\n', '\n', '        require(_transferSuccess, "Curve/XSGD-transfer-failed");\n', '    }\n', '\n', '    // takes a numeraire amount and returns the raw amount\n', '    function viewRawAmount(int128 _amount) external view override returns (uint256 amount_) {\n', '        uint256 _rate = getRate();\n', '\n', '        amount_ = (_amount.mulu(1e6) * 1e8) / _rate;\n', '    }\n', '\n', '    function viewRawAmountLPRatio(\n', '        uint256 _baseWeight,\n', '        uint256 _quoteWeight,\n', '        address _addr,\n', '        int128 _amount\n', '    ) external view override returns (uint256 amount_) {\n', '        uint256 _xsgdBal = xsgd.balanceOf(_addr);\n', '\n', '        if (_xsgdBal <= 0) return 0;\n', '\n', '        // 1e6\n', '        _xsgdBal = _xsgdBal.mul(1e18).div(_baseWeight);\n', '\n', '        // 1e6\n', '        uint256 _usdcBal = usdc.balanceOf(_addr).mul(1e18).div(_quoteWeight);\n', '\n', '        // Rate is in 1e6\n', '        uint256 _rate = _usdcBal.mul(1e6).div(_xsgdBal);\n', '\n', '        amount_ = (_amount.mulu(1e6) * 1e6) / _rate;\n', '    }\n', '\n', '    // takes a raw amount and returns the numeraire amount\n', '    function viewNumeraireAmount(uint256 _amount) external view override returns (int128 amount_) {\n', '        uint256 _rate = getRate();\n', '\n', '        amount_ = ((_amount * _rate) / 1e8).divu(1e6);\n', '    }\n', '\n', '    // views the numeraire value of the current balance of the reserve, in this case xsgd\n', '    function viewNumeraireBalance(address _addr) external view override returns (int128 balance_) {\n', '        uint256 _rate = getRate();\n', '\n', '        uint256 _balance = xsgd.balanceOf(_addr);\n', '\n', '        if (_balance <= 0) return ABDKMath64x64.fromUInt(0);\n', '\n', '        balance_ = ((_balance * _rate) / 1e8).divu(1e6);\n', '    }\n', '\n', '    // views the numeraire value of the current balance of the reserve, in this case xsgd\n', '    function viewNumeraireAmountAndBalance(address _addr, uint256 _amount)\n', '        external\n', '        view\n', '        override\n', '        returns (int128 amount_, int128 balance_)\n', '    {\n', '        uint256 _rate = getRate();\n', '\n', '        amount_ = ((_amount * _rate) / 1e8).divu(1e6);\n', '\n', '        uint256 _balance = xsgd.balanceOf(_addr);\n', '\n', '        balance_ = ((_balance * _rate) / 1e8).divu(1e6);\n', '    }\n', '\n', '    // views the numeraire value of the current balance of the reserve, in this case xsgd\n', '    // instead of calculating with chainlink\'s "rate" it\'ll be determined by the existing\n', '    // token ratio\n', '    // Mainly to protect LP from losing\n', '    function viewNumeraireBalanceLPRatio(\n', '        uint256 _baseWeight,\n', '        uint256 _quoteWeight,\n', '        address _addr\n', '    ) external view override returns (int128 balance_) {\n', '        uint256 _xsgdBal = xsgd.balanceOf(_addr);\n', '\n', '        if (_xsgdBal <= 0) return ABDKMath64x64.fromUInt(0);\n', '\n', '        uint256 _usdcBal = usdc.balanceOf(_addr).mul(1e18).div(_quoteWeight);\n', '\n', '        // Rate is in 1e6\n', '        uint256 _rate = _usdcBal.mul(1e18).div(_xsgdBal.mul(1e18).div(_baseWeight));\n', '\n', '        balance_ = ((_xsgdBal * _rate) / 1e6).divu(1e18);\n', '    }\n', '}']