['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-22\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.1;\n', '\n', 'library SafeMath {\n', '    \n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', '            uint256 c = a + b;\n', '            if (c < a) return (false, 0);\n', '            return (true, c);\n', '        }\n', '    }\n', '\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', '            if (b > a) return (false, 0);\n', '            return (true, a - b);\n', '        }\n', '    }\n', '\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', "            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "            // benefit is lost if 'b' is also tested.\n", '            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '            if (a == 0) return (true, 0);\n', '            uint256 c = a * b;\n', '            if (c / a != b) return (false, 0);\n', '            return (true, c);\n', '        }\n', '    }\n', '\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', '            if (b == 0) return (false, 0);\n', '            return (true, a / b);\n', '        }\n', '    }\n', '\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        unchecked {\n', '            if (b == 0) return (false, 0);\n', '            return (true, a % b);\n', '        }\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a + b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a - b;\n', '    }\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a * b;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a % b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        unchecked {\n', '            require(b <= a, errorMessage);\n', '            return a - b;\n', '        }\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        unchecked {\n', '            require(b > 0, errorMessage);\n', '            return a / b;\n', '        }\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        unchecked {\n', '            require(b > 0, errorMessage);\n', '            return a % b;\n', '        }\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint balance);\n', '    function transfer(address to, uint amount) external returns (bool);\n', '    \n', '    function allowance(address account, address from) external view returns (uint256);\n', '    function approve(address from, uint amount) external returns (bool);\n', '    function transferFrom(address from, address to, uint amount) external returns (bool);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed account, address indexed from, uint amount);\n', '}\n', '\n', 'contract TokenWraper {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    IERC20 public _token = IERC20(0x847287E3586dD4Fe7217a050580DdCDC83c73470);\n', '\n', '    uint256 private _totalSupply;\n', '    mapping(address => uint256) private _balances;\n', '\n', '    function totalSupply() public view returns(uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view returns(uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function _save(uint256 amount) internal {\n', '        _token.transferFrom(msg.sender, address(this), amount);\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[msg.sender] = _balances[msg.sender].add(amount);\n', '    }\n', '\n', '    function _withdraw(uint256 amount) internal {\n', '        _token.transfer(msg.sender, amount);\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '    }\n', '\n', '    function _removeReward(address founder, uint256 amount) internal {\n', '        _token.transfer(msg.sender, amount);\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _balances[founder] = _balances[founder].sub(amount);\n', '    }\n', '}\n', '\n', 'contract Saving is TokenWraper {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    address public founder;\n', '    uint256 public timeLock = 3 days; // return unix epoch\n', '    uint256 public yearly = 365 days;\n', '    uint256 public percentRewardYearly; // % yearly\n', '    mapping(address => uint256) private savedAmount;\n', '    mapping(address => uint256) private savedTimestamp;\n', '    mapping(address => uint256) public claimRewardAmount;\n', '    mapping(address => uint256) public lockedUntil;\n', '    \n', '    IERC20 public token = IERC20(0x847287E3586dD4Fe7217a050580DdCDC83c73470);\n', '    \n', '    event Saved(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '    \n', '    modifier isFounder() {\n', '        require(msg.sender == founder);\n', '        _;\n', '    }\n', '    \n', '    constructor(uint256 _percentRewardYearly) {\n', '        percentRewardYearly = _percentRewardYearly;\n', '        founder = msg.sender;\n', '    }\n', '    \n', '    function setNewFounder(address newAddress) public isFounder {\n', '        founder = newAddress;\n', '    }\n', '    \n', '    function setPercentRewardYearly(uint256 _percent) public isFounder {\n', '        percentRewardYearly = _percent;\n', '    }\n', '\n', '    function changeOwnership(address _account) public {\n', '        founder = _account;\n', '    }\n', '    \n', '    function rewardBalance() public view returns(uint256) {\n', '        return balanceOf(founder);\n', '    }\n', '    \n', '    function _rewardEarnedPerSecond(address account) public view returns(uint256) {\n', '        if(account == founder) {\n', '            return 0;\n', '        }\n', '        uint256 _savedAmount = savedAmount[account];\n', '        uint256 _expectedRewardYearly = _savedAmount.mul(percentRewardYearly);\n', '        _expectedRewardYearly = _expectedRewardYearly.div(100);\n', '        uint256 _reward = _expectedRewardYearly.div(yearly);\n', '        return _reward;\n', '    }\n', '    \n', '    function rewardEarned(address account) public view returns(uint256) {\n', '        uint256 _currentTime = block.timestamp;\n', '        uint256 _rangeTime = _currentTime.sub(savedTimestamp[account]);\n', '        uint256 _rewardEarned;\n', '        if(_rangeTime >= timeLock) {\n', '            _rewardEarned = _rewardEarnedPerSecond(account).mul(timeLock);\n', '        }else {\n', '            _rewardEarned = _rewardEarnedPerSecond(account).mul(_rangeTime);\n', '        }\n', '        if(claimRewardAmount[account] != 0) {\n', '            _rewardEarned = _rewardEarned.sub(claimRewardAmount[account]);\n', '        }\n', '        return _rewardEarned;\n', '    }\n', '    \n', '    function save(uint256 _amount) public {\n', '        require(_amount > 0, "Cannot save 0");\n', '        super._save(_amount);\n', '        uint256 _currentTime = block.timestamp;\n', '        savedAmount[msg.sender] = _amount;\n', '        claimRewardAmount[msg.sender] = 0;\n', '        savedTimestamp[msg.sender] = _currentTime;\n', '        lockedUntil[msg.sender] = _currentTime.add(timeLock);\n', '        emit Saved(msg.sender, _amount);\n', '    }\n', '    \n', '    function withdraw(uint256 _amount) public {\n', '        require(msg.sender != founder, "Founder not allowed to withdraw");\n', '        require(lockedUntil[msg.sender] > 0, "No user found.");\n', '        require(lockedUntil[msg.sender] < block.timestamp, "Not unlocked yet.");\n', '        require(_amount > 0, "Cannot withdraw 0");\n', '        super._withdraw(_amount);\n', '        emit Withdrawn(msg.sender, _amount);\n', '    }\n', '    \n', '    function getReward() public {\n', '        uint256 _rewardEarned = rewardEarned(msg.sender);\n', '        require(_rewardEarned > 0, "Doesn\'t have a reward.");\n', '        require(rewardBalance() > _rewardEarned, "Reward balance not enough.");\n', '        super._removeReward(founder, _rewardEarned);\n', '        claimRewardAmount[msg.sender] = claimRewardAmount[msg.sender].add(_rewardEarned);\n', '        if(lockedUntil[msg.sender] < block.timestamp) {\n', '            savedAmount[msg.sender] = 0;\n', '            claimRewardAmount[msg.sender] = 0;\n', '        }\n', '        emit RewardPaid(msg.sender, _rewardEarned);\n', '    }\n', '}']