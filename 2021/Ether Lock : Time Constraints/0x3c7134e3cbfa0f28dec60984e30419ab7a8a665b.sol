['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', 'pragma solidity 0.5.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y > 0, "ds-math-div-overflow");\n', '        z = x / y;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', 'interface ILendingPoolCore {\n', '    function getReserveAvailableLiquidity(address _reserve)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getReserveCurrentLiquidityRate(address _reserve)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getReserveCurrentVariableBorrowRate(address _reserve)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface ICToken {\n', '    function supplyRatePerBlock() external view returns (uint256);\n', '\n', '    function borrowRatePerBlock() external view returns (uint256);\n', '\n', '    function getCash() external view returns (uint256);\n', '\n', '    function comptroller() external view returns (address);\n', '\n', '    function exchangeRateCurrent() external returns (uint256);\n', '}\n', '\n', 'interface IiToken {\n', '    function getCash() external view returns (uint256);\n', '\n', '    function supplyRatePerBlock() external view returns (uint256);\n', '\n', '    function borrowRatePerBlock() external view returns (uint256);\n', '}\n', '\n', 'interface IUSR {\n', '    function totalUnderlying() external returns (uint256);\n', '\n', '    function balanceOfUnderlying(address owner) external returns (uint256);\n', '\n', '    function underlyingToken() external view returns (address);\n', '}\n', '\n', 'interface IDFProtocolView {\n', '    function getColStatus()\n', '        external\n', '        view\n', '        returns (address[] memory, uint256[] memory);\n', '}\n', '\n', 'interface IComptroller {\n', '    function compSpeeds(address _cToken) external view returns (uint256);\n', '\n', '    function getCompAddress() external view returns (address);\n', '}\n', '\n', 'interface IDToken {\n', '    function token() external view returns (address);\n', '\n', '    function getBaseData()\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function getHandlerInfo()\n', '        external\n', '        returns (\n', '            address[] memory,\n', '            uint256[] memory,\n', '            uint256[] memory\n', '        );\n', '\n', '    function swapModel() external view returns (address);\n', '}\n', '\n', 'interface ISwapModel {\n', '    function getSwapAmount(\n', '        address _tokenA,\n', '        address _tokenB,\n', '        uint256 _amount\n', '    ) external view returns (uint256);\n', '}\n', '\n', 'interface IDTokenController {\n', '    function getDToken(address _token) external view returns (address);\n', '}\n', '\n', 'interface IHandler {\n', '    function dTokenController() external view returns (address);\n', '\n', '    function cTokens(address _token) external view returns (address);\n', '\n', '    function iTokens(address _token) external view returns (address);\n', '\n', '    function aaveLendingPoolCore() external view returns (address);\n', '\n', '    function USR() external view returns (address);\n', '\n', '    function iToken() external view returns (address);\n', '}\n', '\n', 'contract DTokenCommonData {\n', '    using SafeMath for uint256;\n', '    bool private initialized;\n', '    address public owner;\n', '    uint256 constant ONE = 1e18;\n', '    uint256 constant doubleScale = 1e36;\n', '    uint256 constant BlocksPerDay = 4 * 60 * 24;\n', '    uint256 constant DaysPerYear = 365;\n', '\n', '    mapping(address => bytes4) public handlers;\n', '    mapping(address => bool) public farmings;\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender, "onlyOwner: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    constructor() public {\n', '        initialize();\n', '    }\n', '\n', '    function initialize() public {\n', '        require(!initialized, "initialize: Already initialized!");\n', '        owner = msg.sender;\n', '        initialized = true;\n', '    }\n', '\n', '    function rpow(uint256 x, uint256 n, uint256 base) public pure returns (uint256 z) {\n', '        assembly {\n', '            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n', '            default {\n', '                switch mod(n, 2) case 0 { z := base } default { z := x }\n', '                let half := div(base, 2)  // for rounding.\n', '\n', '                for { n := div(n, 2) } n { n := div(n,2) } {\n', '                    let xx := mul(x, x)\n', '                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n', '                    let xxRound := add(xx, half)\n', '                    if lt(xxRound, xx) { revert(0,0) }\n', '                    x := div(xxRound, base)\n', '                    if mod(n,2) {\n', '                        let zx := mul(z, x)\n', '                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n', '                        let zxRound := add(zx, half)\n', '                        if lt(zxRound, zx) { revert(0,0) }\n', '                        z := div(zxRound, base)\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function setHandler(address _handler, bytes4 _sig) external onlyOwner {\n', '        handlers[_handler] = _sig;\n', '    }\n', '\n', '    function setHandlers(address[] calldata _handlers, bytes4[] calldata _sigs)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(\n', '            _handlers.length == _sigs.length && _handlers.length > 0,\n', '            "setHandlers: handlers & indexs should not have 0 or different lengths"\n', '        );\n', '        for (uint256 i = 0; i < _handlers.length; i++)\n', '            handlers[_handlers[i]] = _sigs[i];\n', '    }\n', '\n', '    function setFarming(address _handler, bool _farming) external onlyOwner {\n', '        farmings[_handler] = _farming;\n', '    }\n', '\n', '    function setFarmings(address[] calldata _handlers, bool[] calldata _farmings) external onlyOwner {\n', '        require(\n', '            _handlers.length == _farmings.length && _handlers.length > 0,\n', '            "setFarmings: handlers & indexs should not have 0 or different lengths"\n', '        );\n', '        for (uint256 i = 0; i < _handlers.length; i++)\n', '            farmings[_handlers[i]] = _farmings[i];\n', '    }\n', '\n', '    function getDTokenApys(address[] calldata _dTokens)\n', '        external\n', '        returns (uint256[] memory)\n', '    {\n', '        uint256[] memory _apys = new uint256[](_dTokens.length);\n', '        for (uint256 i = 0; i < _dTokens.length; i++)\n', '            _apys[i] = getDTokenApy(_dTokens[i]);\n', '        return _apys;\n', '    }\n', '\n', '    struct DTokenApyLocalVars {\n', '        uint256 tokenBalance;\n', '        uint256[] balances;\n', '        uint256[] supplyApys;\n', '        uint256[] borrowApys;\n', '        uint256[] otherSupplyApys;\n', '    }\n', '\n', '    function getDTokenApy(address _dToken) public returns (uint256) {\n', '        DTokenDataLocalVars memory _dTokenApy;\n', '        (\n', '            _dTokenApy.tokenBalance,\n', '            ,\n', '            ,\n', '            _dTokenApy.balances,\n', '            ,\n', '            _dTokenApy.supplyApys,\n', '            ,\n', '            _dTokenApy.otherSupplyApys\n', '        ) = getDTokenData(_dToken);\n', '        if (_dTokenApy.tokenBalance == 0) return 0;\n', '        uint256 _apy;\n', '        for (uint256 i = 0; i < _dTokenApy.balances.length; i++)\n', '            _apy = _dTokenApy.supplyApys[i]\n', '                .add(_dTokenApy.otherSupplyApys[i])\n', '                .mul(_dTokenApy.balances[i])\n', '                .div(_dTokenApy.tokenBalance)\n', '                .add(_apy);\n', '\n', '        return _apy;\n', '    }\n', '\n', '    struct DTokenDataLocalVars {\n', '        address token;\n', '        uint256 tokenBalance;\n', '        address[] handlers;\n', '        uint256[] balances;\n', '        uint256[] cashs;\n', '        uint256[] supplyApys;\n', '        uint256[] borrowApys;\n', '        uint256[] otherSupplyApys;\n', '    }\n', '\n', '    function getDTokenData(address _dToken)\n', '        public\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            address[] memory,\n', '            uint256[] memory,\n', '            uint256[] memory,\n', '            uint256[] memory,\n', '            uint256[] memory,\n', '            uint256[] memory\n', '        )\n', '    {\n', '        DTokenDataLocalVars memory _dTokenData;\n', '        (, , , , uint256 _tokenBalance) = IDToken(_dToken).getBaseData();\n', '        _dTokenData.token = IDToken(_dToken).token();\n', '        (_dTokenData.handlers, _dTokenData.balances, ) = IDToken(_dToken)\n', '            .getHandlerInfo();\n', '        _dTokenData.cashs = new uint256[](_dTokenData.handlers.length);\n', '        _dTokenData.supplyApys = new uint256[](_dTokenData.handlers.length);\n', '        _dTokenData.borrowApys = new uint256[](_dTokenData.handlers.length);\n', '        _dTokenData.otherSupplyApys = new uint256[](\n', '            _dTokenData.handlers.length\n', '        );\n', '        for (uint256 i = 0; i < _dTokenData.handlers.length; i++)\n', '            (\n', '                _dTokenData.cashs[i],\n', '                _dTokenData.supplyApys[i],\n', '                _dTokenData.borrowApys[i],\n', '                _dTokenData.otherSupplyApys[i]\n', '            ) = getHandlerData(_dTokenData.handlers[i], _dTokenData.token);\n', '\n', '        return (\n', '            _tokenBalance,\n', '            IERC20(_dToken).totalSupply(),\n', '            _dTokenData.handlers,\n', '            _dTokenData.balances,\n', '            _dTokenData.cashs,\n', '            _dTokenData.supplyApys,\n', '            _dTokenData.borrowApys,\n', '            _dTokenData.otherSupplyApys\n', '        );\n', '    }\n', '\n', '    function getHandlerData(address _handler, address _token)\n', '        public\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        (, bytes memory _data) = address(this).call(\n', '            abi.encodeWithSelector(handlers[_handler], _handler, _token)\n', '        );\n', '        (\n', '            uint256 _cash,\n', '\n', '            uint256 _supplyApy,\n', '            uint256 _borrowApy,\n', '            uint256 _otherSupplyApy\n', '        ) = abi.decode(_data, (uint256, uint256, uint256, uint256));\n', '        return (_cash, _supplyApy, _borrowApy, _otherSupplyApy);\n', '    }\n', '\n', '    function InternalData(address _handler, address _token)\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        return (IERC20(_token).balanceOf(_handler), 0, 0, 0);\n', '    }\n', '\n', '    function CompoundData(address _handler, address _token)\n', '        public\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        ICToken _cToken = ICToken(IHandler(_handler).cTokens(_token));\n', '        return (\n', '            _cToken.getCash(),\n', '            rpow(\n', '                (_cToken.supplyRatePerBlock() * BlocksPerDay + ONE),\n', '                DaysPerYear,\n', '                ONE\n', '            ) - ONE,\n', '            rpow(\n', '                (_cToken.borrowRatePerBlock() * BlocksPerDay + ONE),\n', '                DaysPerYear,\n', '                ONE\n', '            ) - ONE,\n', '            getCompApy(_handler, _token)\n', '        );\n', '    }\n', '\n', '    function AaveData(address _handler, address _token)\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        ILendingPoolCore lendingPoolCore = ILendingPoolCore(\n', '            IHandler(_handler).aaveLendingPoolCore()\n', '        );\n', '        return (\n', '            lendingPoolCore.getReserveAvailableLiquidity(_token),\n', '            lendingPoolCore.getReserveCurrentLiquidityRate(_token) / 10**9,\n', '            lendingPoolCore.getReserveCurrentVariableBorrowRate(_token) / 10**9,\n', '            0\n', '        );\n', '    }\n', '\n', '    function USRData(address _handler, address _token)\n', '        public\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        _token;\n', '        return (\n', '            IUSR(IHandler(_handler).USR()).totalUnderlying(),\n', '            getUSRInterestRate(_handler),\n', '            0,\n', '            0\n', '        );\n', '    }\n', '\n', '    function DForceLendingData(address _handler, address _token)\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        IiToken _iToken = IiToken(IHandler(_handler).iTokens(_token));\n', '        return (\n', '            _iToken.getCash(),\n', '            rpow(\n', '                (_iToken.supplyRatePerBlock() * BlocksPerDay + ONE),\n', '                DaysPerYear,\n', '                ONE\n', '            ) - ONE,\n', '            rpow(\n', '                (_iToken.borrowRatePerBlock() * BlocksPerDay + ONE),\n', '                DaysPerYear,\n', '                ONE\n', '            ) - ONE,\n', '            0\n', '        );\n', '    }\n', '\n', '    function DForceLendingSingleData(address _handler, address _token)\n', '        public\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        _token;\n', '        IiToken _iToken = IiToken(IHandler(_handler).iToken());\n', '        return (\n', '            _iToken.getCash(),\n', '            rpow(\n', '                (_iToken.supplyRatePerBlock() * BlocksPerDay + ONE),\n', '                DaysPerYear,\n', '                ONE\n', '            ) - ONE,\n', '            rpow(\n', '                (_iToken.borrowRatePerBlock() * BlocksPerDay + ONE),\n', '                DaysPerYear,\n', '                ONE\n', '            ) - ONE,\n', '            0\n', '        );\n', '    }\n', '\n', '    function getCompApy(address _handler, address _token)\n', '        public\n', '        returns (uint256)\n', '    {\n', '        if (!farmings[_handler]) return 0;\n', '        address _cToken = IHandler(_handler).cTokens(_token);\n', '        IComptroller _comptroller = IComptroller(\n', '            ICToken(_cToken).comptroller()\n', '        );\n', '        IDToken _dToken = IDToken(\n', '            IDTokenController(IHandler(_handler).dTokenController()).getDToken(\n', '                _token\n', '            )\n', '        );\n', '        uint256 _tokenAmount = ISwapModel(_dToken.swapModel()).getSwapAmount(\n', '            _comptroller.getCompAddress(),\n', '            _dToken.token(),\n', '            ONE\n', '        );\n', '        _tokenAmount = _comptroller.compSpeeds(_cToken).mul(_tokenAmount).div(\n', '            ONE\n', '        );\n', '\n', '        uint256 _tokenTotalAmountDoubleScale = IERC20(_cToken)\n', '            .totalSupply()\n', '            .mul(ICToken(_cToken).exchangeRateCurrent());\n', '        if (_tokenTotalAmountDoubleScale == 0) return 0;\n', '\n', '        uint256 _compApy = _tokenAmount.mul(doubleScale).div(\n', '            _tokenTotalAmountDoubleScale\n', '        );\n', '        return rpow((_compApy * 45 * 6 * 24 + ONE), DaysPerYear, ONE) - ONE;\n', '    }\n', '\n', '    function getUSRInterestRate(address _handler) public returns (uint256) {\n', '        uint256 _principal = IUSR(IHandler(_handler).USR()).totalUnderlying();\n', '\n', '        return\n', '            _principal > 0\n', '                ? getUSDxAnnualInterest(_handler).mul(ONE).div(_principal)\n', '                : 0;\n', '    }\n', '\n', '    function getUSDxAnnualInterest(address _handler) public returns (uint256) {\n', '        IDTokenController _dTokenController = IDTokenController(\n', '            IHandler(_handler).dTokenController()\n', '        );\n', '\n', '        (address[] memory _tokens, uint256[] memory _amounts) = IDFProtocolView(\n', '            0x097Dd22173f0e382daE42baAEb9bDBC9fdf3396F\n', '        )\n', '            .getColStatus();\n', '        address _dToken;\n', '        uint256 _decimals;\n', '        uint256 _annualInterest;\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            _dToken = _dTokenController.getDToken(_tokens[i]);\n', '            if (_dToken == address(0)) continue;\n', '\n', '            _decimals = uint256(IERC20(_tokens[i]).decimals());\n', '            _amounts[i] = _decimals > 18\n', '                ? _amounts[i] / 10**(_decimals - 18)\n', '                : _amounts[i] * 10**(18 - _decimals);\n', '            _annualInterest = _annualInterest.add(\n', '                _amounts[i].mul(getDTokenApy(_dToken)).div(ONE)\n', '            );\n', '        }\n', '\n', '        return _annualInterest;\n', '    }\n', '\n', '    function test(address _handler)\n', '        public\n', '        returns (\n', '            uint256,\n', '            address[] memory,\n', '            address[] memory,\n', '            uint256[] memory,\n', '            uint256[] memory\n', '        )\n', '    {\n', '        IDTokenController _dTokenController = IDTokenController(\n', '            IHandler(_handler).dTokenController()\n', '        );\n', '\n', '        (address[] memory _tokens, uint256[] memory _amounts) = IDFProtocolView(\n', '            0x097Dd22173f0e382daE42baAEb9bDBC9fdf3396F\n', '        )\n', '            .getColStatus();\n', '        address[] memory _dTokens = new address[](_tokens.length);\n', '        uint256[] memory _decimals = new uint256[](_tokens.length);\n', '        uint256 _annualInterest;\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            _dTokens[i] = _dTokenController.getDToken(_tokens[i]);\n', '            if (_dTokens[i] == address(0)) continue;\n', '\n', '            _decimals[i] = uint256(IERC20(_tokens[i]).decimals());\n', '            _amounts[i] = _decimals[i] > 18\n', '                ? _amounts[i] / 10**(_decimals[i] - 18)\n', '                : _amounts[i] * 10**(18 - _decimals[i]);\n', '            _annualInterest = _annualInterest.add(\n', '                _amounts[i].mul(getDTokenApy(_dTokens[i])).div(ONE)\n', '            );\n', '        }\n', '\n', '        return (_annualInterest, _tokens, _dTokens, _decimals, _amounts);\n', '    }\n', '}']