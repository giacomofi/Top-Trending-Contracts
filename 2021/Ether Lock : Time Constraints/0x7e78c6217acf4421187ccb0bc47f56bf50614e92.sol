['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// File: contracts\\liquidity-mining\\ILiquidityMiningFactory.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface ILiquidityMiningFactory {\n', '\n', '    event ExtensionCloned(address indexed);\n', '\n', '    function feePercentageInfo() external view returns (uint256, address);\n', '    function liquidityMiningDefaultExtension() external view returns(address);\n', '    function cloneLiquidityMiningDefaultExtension() external returns(address);\n', '    function getLiquidityFarmTokenCollectionURI() external view returns (string memory);\n', '    function getLiquidityFarmTokenURI() external view returns (string memory);\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\LiquidityMiningData.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'struct LiquidityMiningSetupConfiguration {\n', '    bool add;\n', '    uint256 index;\n', '    LiquidityMiningSetup data;\n', '}\n', '\n', '// liquidity mining setup struct\n', 'struct LiquidityMiningSetup {\n', '    address ammPlugin; // amm plugin address used for this setup (eg. uniswap amm plugin address).\n', '    uint256 objectId; // items object id for the liquidity pool token.\n', '    address liquidityPoolTokenAddress; // address of the liquidity pool token\n', '    address mainTokenAddress; // eg. buidl address.\n', '    uint256 startBlock; // liquidity mining setup start block (used only if free is false).\n', '    uint256 endBlock; // liquidity mining setup end block (used only if free is false).\n', '    uint256 rewardPerBlock; // liquidity mining setup reward per single block.\n', '    uint256 currentRewardPerBlock; // liquidity mining setup current reward per single block.\n', '    uint256 totalSupply; // current liquidity added in this setup (used only if free is true).\n', '    uint256 lastBlockUpdate; // number of the block where an update was triggered.\n', '    uint256 maximumLiquidity; // maximum liquidity stakeable in the contract (used only if free is false).\n', '    uint256 currentStakedLiquidity; // currently staked liquidity (used only if free is false).\n', '    bool free; // if the setup is a free liquidity mining setup or a locked one.\n', "    uint256 renewTimes; // if the locked setup is renewable or if it's one time (used only if free is false).\n", '    uint256 penaltyFee; // fee paid when the user exits a still active locked liquidity mining setup (used only if free is false).\n', '    bool involvingETH; // if the setup involves ETH or not.\n', '}\n', '\n', '// position struct\n', 'struct LiquidityMiningPosition {\n', '    address uniqueOwner; // address representing the extension address, address(0) if objectId is populated.\n', '    uint256 setupIndex; // the setup index.\n', '    uint256 setupStartBlock; // liquidity mining setup start block (used only if free is false).\n', '    uint256 setupEndBlock; // liquidity mining setup end block (used only if free is false).\n', '    bool free; // if the setup is a free liquidity mining setup or a locked one.\n', '    // LiquidityPoolData liquidityPoolData; // amm liquidity pool data.\n', '    uint256 liquidityPoolTokenAmount;\n', '    uint256 reward; // position reward.\n', '    uint256 lockedRewardPerBlock; // position locked reward per block.\n', '    uint256 creationBlock; // block when this position was created.\n', '}\n', '\n', '// stake data struct\n', 'struct LiquidityMiningPositionRequest {\n', '    uint256 setupIndex; // index of the chosen setup.\n', '    uint256 amount; // amount of main token.\n', '    bool amountIsLiquidityPool; //true if user wants to directly share the liquidity pool token amount, false to add liquidity to AMM\n', '    address positionOwner; // position extension or address(0) [msg.sender].\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\ILiquidityMiningExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface ILiquidityMiningExtension {\n', '\n', '    function init(bool byMint, address host) external;\n', '\n', '    function setHost(address host) external;\n', '\n', '    function data() external view returns(address liquidityMiningContract, bool byMint, address host, address rewardTokenAddress);\n', '\n', '    function transferTo(uint256 amount, address recipient) external;\n', '    function backToYou(uint256 amount) external payable;\n', '\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) external;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\IAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IAMM {\n', '\n', '    event NewLiquidityPoolAddress(address indexed);\n', '\n', '    function info() external view returns(string memory name, uint256 version);\n', '\n', '    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\n', '\n', '    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\n', '    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function safeApprove(address spender, uint256 amount) external;\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\IEthItemOrchestrator.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IEthItemOrchestrator {\n', '    function createNative(bytes calldata modelInitPayload, string calldata ens)\n', '        external\n', '        returns (address newNativeAddress, bytes memory modelInitCallResponse);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\IERC1155.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC1155 {\n', '\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\IEthItemInteroperableInterface.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'interface IEthItemInteroperableInterface is IERC20 {\n', '\n', '    function mainInterface() external view returns (address);\n', '\n', '    function objectId() external view returns (uint256);\n', '\n', '    function mint(address owner, uint256 amount) external;\n', '\n', '    function burn(address owner, uint256 amount) external;\n', '\n', '    function permitNonce(address sender) external view returns(uint256);\n', '\n', '    function permit(address owner, address spender, uint value, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    function interoperableInterfaceVersion() external pure returns(uint256 ethItemInteroperableInterfaceVersion);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\IEthItem.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', '\n', 'interface IEthItem is IERC1155 {\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function totalSupply(uint256 objectId) external view returns (uint256);\n', '\n', '    function name(uint256 objectId) external view returns (string memory);\n', '\n', '    function symbol(uint256 objectId) external view returns (string memory);\n', '\n', '    function decimals(uint256 objectId) external view returns (uint256);\n', '\n', '    function uri(uint256 objectId) external view returns (string memory);\n', '\n', '    function mainInterfaceVersion() external pure returns(uint256 ethItemInteroperableVersion);\n', '\n', '    function toInteroperableInterfaceAmount(uint256 objectId, uint256 ethItemAmount) external view returns (uint256 interoperableInterfaceAmount);\n', '\n', '    function toMainInterfaceAmount(uint256 objectId, uint256 erc20WrapperAmount) external view returns (uint256 mainInterfaceAmount);\n', '\n', '    function interoperableInterfaceModel() external view returns (address, uint256);\n', '\n', '    function asInteroperable(uint256 objectId) external view returns (IEthItemInteroperableInterface);\n', '\n', '    function emitTransferSingleEvent(address sender, address from, address to, uint256 objectId, uint256 amount) external;\n', '\n', '    function mint(uint256 amount, string calldata partialUri)\n', '        external\n', '        returns (uint256, address);\n', '\n', '    function burn(\n', '        uint256 objectId,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function burnBatch(\n', '        uint256[] calldata objectIds,\n', '        uint256[] calldata amounts\n', '    ) external;\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\INativeV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'interface INativeV1 is IEthItem {\n', '\n', '    function init(string calldata name, string calldata symbol, bool hasDecimals, string calldata collectionUri, address extensionAddress, bytes calldata extensionInitPayload) external returns(bytes memory extensionInitCallResponse);\n', '    function extension() external view returns (address extensionAddress);\n', '    function canMint(address operator) external view returns (bool result);\n', '    function isEditable(uint256 objectId) external view returns (bool result);\n', '    function releaseExtension() external;\n', '    function uri() external view returns (string memory);\n', '    function decimals() external view returns (uint256);\n', '    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri, bool editable) external returns (uint256 objectId, address tokenAddress);\n', '    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri) external returns (uint256 objectId, address tokenAddress);\n', '    function mint(uint256 objectId, uint256 amount) external;\n', '    function makeReadOnly(uint256 objectId) external;\n', '    function setUri(string calldata newUri) external;\n', '    function setUri(uint256 objectId, string calldata newUri) external;\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\ERC1155Receiver.sol\n', '\n', '// File: contracts/usd-v2/util/ERC1155Receiver.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'abstract contract ERC1155Receiver {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor() {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '        _registerInterface(\n', '            ERC1155Receiver(0).onERC1155Received.selector ^\n', '            ERC1155Receiver(0).onERC1155BatchReceived.selector\n', '        );\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    function _registerInterface(bytes4 interfaceId) internal virtual {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        virtual\n', '        returns(bytes4);\n', '\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        virtual\n', '        returns(bytes4);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\ILiquidityMining.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface ILiquidityMining {\n', '\n', '    function _rewardTokenAddress() external view returns(address);\n', '    function setups() external view returns (LiquidityMiningSetup[] memory);\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) external;\n', '    \n', '}\n', '\n', '// File: contracts\\liquidity-mining\\LiquidityMining.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract LiquidityMining is ILiquidityMining, ERC1155Receiver {\n', '\n', '    uint256 public constant ONE_HUNDRED = 10000;\n', '\n', '    // event that tracks liquidity mining contracts deployed\n', '    event RewardToken(address indexed rewardTokenAddress);\n', '    // new liquidity mining position event\n', '    event Transfer(uint256 indexed positionId, address indexed from, address indexed to);\n', '    // event that tracks involved tokens for this contract\n', '    event SetupToken(address indexed mainToken, address indexed involvedToken);\n', '    // event that tracks farm tokens\n', '    event FarmToken(uint256 indexed objectId, address indexed liquidityPoolToken, uint256 setupIndex, uint256 endBlock);\n', '\n', '    // factory address that will create clones of this contract\n', '    address public _factory;\n', '    // address of the extension of this contract\n', '    address public _extension;\n', '    // address of the reward token\n', '    address public override _rewardTokenAddress;\n', '    // liquidity farm token collection\n', '    address public _liquidityFarmTokenCollection;\n', '    // array containing all the currently available liquidity mining setups\n', '    LiquidityMiningSetup[] private _setups;\n', '    // mapping containing all the positions\n', '    mapping(uint256 => LiquidityMiningPosition) public _positions;\n', '    // mapping containing the reward per token per setup per block\n', '    mapping(uint256 => mapping(uint256 => uint256)) public _rewardPerTokenPerSetupPerBlock;\n', '    // mapping containing all the blocks where an update has been triggered\n', '    mapping(uint256 => uint256[]) public _setupUpdateBlocks;\n', '    // mapping containing whether a liquidity mining position has been redeemed or not\n', '    mapping(uint256 => bool) public _positionRedeemed;\n', '    // mapping containing whether a liquidity mining position has been partially reedemed or not\n', '    mapping(uint256 => uint256) public _partiallyRedeemed;\n', '    // mapping containing whether a locked setup has ended or not and has been used for the rebalance\n', '    mapping(uint256 => bool) public _finishedLockedSetups;\n', '    // mapping containing object id to setup index\n', '    mapping(uint256 => uint256) private _objectIdSetup;\n', '    // pinned setup index\n', '    bool public _hasPinned;\n', '    uint256 public _pinnedSetupIndex;\n', '\n', '    /** Modifiers. */\n', '\n', '    /** @dev byExtension modifier used to check for unauthorized changes. */\n', '    modifier byExtension() {\n', '        require(msg.sender == _extension, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** @dev byPositionOwner modifier used to check for unauthorized accesses. */\n', '    modifier byPositionOwner(uint256 positionId) {\n', '        require(_positions[positionId].uniqueOwner == msg.sender, "Not owned");\n', '        _;\n', '    }\n', '\n', '    /** Public extension methods. */\n', '\n', '    /** @dev initializes the liquidity mining contract.\n', '      * @param extension extension address.\n', '      * @param extensionInitData lm extension init payload.\n', '      * @param orchestrator address of the eth item orchestrator.\n', '      * @param rewardTokenAddress address of the reward token.\n', '      * @param liquidityMiningSetupsBytes array containing all the liquidity mining setups as bytes.\n', "      * @param setPinned true if we're setting a pinned setup during initialization, false otherwise.\n", '      * @param pinnedIndex index of the pinned setup.\n', '      * @return extensionReturnCall result of the extension initialization function, if it was called.  \n', '     */\n', '    function init(address extension, bytes memory extensionInitData, address orchestrator, address rewardTokenAddress, bytes memory liquidityMiningSetupsBytes, bool setPinned, uint256 pinnedIndex) public returns(bytes memory extensionReturnCall) {\n', '        require(_factory == address(0), "Already initialized");\n', '        require((_extension = extension) != address(0), "extension");\n', '        _factory = msg.sender;\n', '        emit RewardToken(_rewardTokenAddress = rewardTokenAddress);\n', '        if (keccak256(extensionInitData) != keccak256("")) {\n', '            extensionReturnCall = _call(_extension, extensionInitData);\n', '        }\n', '        (_liquidityFarmTokenCollection,) = IEthItemOrchestrator(orchestrator).createNative(abi.encodeWithSignature("init(string,string,bool,string,address,bytes)", "Covenants Farming", "cFARM", false, ILiquidityMiningFactory(_factory).getLiquidityFarmTokenCollectionURI(), address(this), ""), "");\n', '        _initLiquidityMiningSetups(liquidityMiningSetupsBytes, setPinned, pinnedIndex);\n', '    }\n', '\n', '    /** @dev allows this contract to receive eth. */\n', '    receive() external payable { }\n', '\n', '    /** @dev returns the liquidity mining setups.\n', '      * @return array containing all the liquidity mining setups.\n', '     */\n', '    function setups() view public override returns (LiquidityMiningSetup[] memory) {\n', '        return _setups;\n', '    }\n', '\n', '    /** @dev returns the liquidity mining position associated with the input id.\n', '      * @param id liquidity mining position id.\n', '      * @return liquidity mining position stored at the given id.\n', '     */\n', '    function position(uint256 id) public view returns(LiquidityMiningPosition memory) {\n', '        return _positions[id];\n', '    }\n', '\n', '    /** @dev returns the reward per token for the setup index at the given block number.\n', '      * @param setupIndex index of the setup.\n', '      * @param blockNumber block that wants to be inspected.\n', '      * @return reward per token.\n', '     */\n', '    function rewardPerToken(uint256 setupIndex, uint256 blockNumber) public view returns(uint256) {\n', '        return _rewardPerTokenPerSetupPerBlock[setupIndex][blockNumber];\n', '    }\n', '\n', '    /** @dev allows the extension to set the liquidity mining setups.\n', '      * @param liquidityMiningSetups liquidity mining setups to set.\n', "      * @param setPinned if we're updating the pinned setup or not.\n", '      * @param pinnedIndex new pinned setup index.\n', '      */\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) public override byExtension {\n', '        for (uint256 i = 0; i < liquidityMiningSetups.length; i++) {\n', '            _setOrAddLiquidityMiningSetup(liquidityMiningSetups[i].data, liquidityMiningSetups[i].add, liquidityMiningSetups[i].index);\n', '        }\n', '        _pinnedSetup(clearPinned, setPinned, pinnedIndex);\n', '        // rebalance the pinned setup\n', '        rebalancePinnedSetup();\n', '    }\n', '\n', '    /** Public methods. */\n', '\n', '    /** @dev function called by external users to open a new liquidity mining position.\n', '      * @param request Liquidity Mining input data.\n', '    */\n', '    function openPosition(LiquidityMiningPositionRequest memory request) public payable returns(uint256 positionId) {\n', '        require(request.setupIndex < _setups.length, "Invalid setup index");\n', '        // retrieve the setup\n', '        LiquidityMiningSetup storage chosenSetup = _setups[request.setupIndex];\n', '        require(chosenSetup.free || (block.number >= chosenSetup.startBlock && block.number <= chosenSetup.endBlock), "Setup not available");\n', '        (IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount, bool involvingETH) = _transferToMeAndCheckAllowance(chosenSetup, request);\n', '        // retrieve the unique owner\n', '        address uniqueOwner = (request.positionOwner != address(0)) ? request.positionOwner : msg.sender;\n', '        LiquidityPoolData memory liquidityPoolData = LiquidityPoolData(\n', '            chosenSetup.liquidityPoolTokenAddress,\n', '            request.amountIsLiquidityPool ? liquidityPoolAmount : mainTokenAmount,\n', '            chosenSetup.mainTokenAddress,\n', '            request.amountIsLiquidityPool,\n', '            involvingETH,\n', '            address(this)\n', '        );\n', '\n', '        if (!liquidityPoolData.amountIsLiquidityPool) {\n', '            // retrieve the poolTokenAmount from the amm\n', '            if(liquidityPoolData.involvingETH) {\n', '                (liquidityPoolData.amount,,) = amm.addLiquidity{value : msg.value}(liquidityPoolData);\n', '            } else {\n', '                (liquidityPoolData.amount,,) = amm.addLiquidity(liquidityPoolData);\n', '            }\n', '            liquidityPoolData.amountIsLiquidityPool = true;\n', '        } else {\n', '            require(msg.value == 0, "ETH not involved");\n', '        }\n', '        // create the position id\n', '        positionId = uint256(keccak256(abi.encode(uniqueOwner, request.setupIndex, block.number)));\n', '        // calculate the reward\n', '        uint256 reward;\n', '        uint256 lockedRewardPerBlock;\n', '        if (!chosenSetup.free) {\n', '            (reward, lockedRewardPerBlock) = calculateLockedLiquidityMiningSetupReward(request.setupIndex, mainTokenAmount, false, 0);\n', '            require(reward > 0 && lockedRewardPerBlock > 0, "Insufficient staked amount");\n', '            ILiquidityMiningExtension(_extension).transferTo(reward, address(this));\n', '            chosenSetup.currentRewardPerBlock += lockedRewardPerBlock;\n', '            chosenSetup.currentStakedLiquidity += mainTokenAmount;\n', '            _mintLiquidity(uniqueOwner, liquidityPoolData.amount, request.setupIndex);\n', '        }\n', '        _positions[positionId] = LiquidityMiningPosition({\n', '            uniqueOwner: uniqueOwner,\n', '            setupIndex : request.setupIndex,\n', '            setupStartBlock : chosenSetup.startBlock,\n', '            setupEndBlock : chosenSetup.endBlock,\n', '            free : chosenSetup.free,\n', '            liquidityPoolTokenAmount: liquidityPoolData.amount,\n', '            reward: reward,\n', '            lockedRewardPerBlock: lockedRewardPerBlock,\n', '            creationBlock: block.number\n', '        });\n', '        if (chosenSetup.free) {\n', '            _rebalanceRewardPerToken(request.setupIndex, liquidityPoolData.amount, false);\n', '        } else {\n', '            if (_hasPinned && _setups[_pinnedSetupIndex].free) {\n', '                _rebalanceRewardPerBlock(_pinnedSetupIndex, (chosenSetup.rewardPerBlock * (mainTokenAmount * 1e18 / chosenSetup.maximumLiquidity)) / 1e18, false);\n', '            }\n', '        }\n', '\n', '        emit Transfer(positionId, address(0), uniqueOwner);\n', '    }\n', '\n', '    /** @dev adds liquidity to the liquidity mining position at the given positionId using the given lpData.\n', '      * @param positionId id of the liquidity mining position.\n', '      * @param request update position request.\n', '      */\n', '    function addLiquidity(uint256 positionId, LiquidityMiningPositionRequest memory request) public payable byPositionOwner(positionId) {\n', '        // retrieve liquidity mining position\n', '        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\n', '        // check if liquidity mining position is valid\n', '        require(liquidityMiningPosition.free || liquidityMiningPosition.setupEndBlock >= block.number, "Invalid add liquidity");\n', '        LiquidityMiningSetup memory chosenSetup = _setups[liquidityMiningPosition.setupIndex];\n', '        (IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount, bool involvingETH) = _transferToMeAndCheckAllowance(chosenSetup, request);\n', '\n', '        LiquidityPoolData memory liquidityPoolData = LiquidityPoolData(\n', '            chosenSetup.liquidityPoolTokenAddress,\n', '            request.amountIsLiquidityPool ? liquidityPoolAmount : mainTokenAmount,\n', '            chosenSetup.mainTokenAddress,\n', '            request.amountIsLiquidityPool,\n', '            involvingETH,\n', '            address(this)\n', '        );\n', '\n', '        if (!liquidityPoolData.amountIsLiquidityPool) {\n', '            // retrieve the poolTokenAmount from the amm\n', '            if(liquidityPoolData.involvingETH) {\n', '                (liquidityPoolData.amount,,) = amm.addLiquidity{value : msg.value}(liquidityPoolData);\n', '            } else {\n', '                (liquidityPoolData.amount,,) = amm.addLiquidity(liquidityPoolData);\n', '            }\n', '            liquidityPoolData.amountIsLiquidityPool = true;\n', '        } else {\n', '            require(msg.value == 0, "ETH not involved");\n', '        }\n', '        // if free we must rebalance and snapshot the state\n', '        if (liquidityMiningPosition.free) {\n', '            // rebalance the reward per token\n', '            _rebalanceRewardPerToken(liquidityMiningPosition.setupIndex, 0, false);\n', '        } else {\n', '            // mint more item corresponding to the new liquidity\n', '            _mintLiquidity(liquidityMiningPosition.uniqueOwner, liquidityPoolData.amount, liquidityMiningPosition.setupIndex);\n', '        }\n', '        // calculate reward before adding liquidity pool data to the position\n', '        (uint256 newReward, uint256 newLockedRewardPerBlock) = liquidityMiningPosition.free ? (calculateFreeLiquidityMiningSetupReward(positionId, false), 0) : calculateLockedLiquidityMiningSetupReward(liquidityMiningPosition.setupIndex, mainTokenAmount, false, 0);\n', '        // update the liquidity pool token amount\n', '        liquidityMiningPosition.liquidityPoolTokenAmount += liquidityPoolData.amount;\n', '        if (!liquidityMiningPosition.free) {\n', '            // transfer the reward in advance to this contract\n', '            ILiquidityMiningExtension(_extension).transferTo(newReward, address(this));\n', '            // update the position reward, locked reward per block and the liquidity pool token amount\n', '            liquidityMiningPosition.reward += newReward;\n', '            liquidityMiningPosition.lockedRewardPerBlock += newLockedRewardPerBlock;\n', '            _setups[liquidityMiningPosition.setupIndex].currentRewardPerBlock += newLockedRewardPerBlock;\n', '            // rebalance the pinned reward per block\n', '            if (_hasPinned && _setups[_pinnedSetupIndex].free) {\n', '                _rebalanceRewardPerBlock(_pinnedSetupIndex, (chosenSetup.rewardPerBlock * (mainTokenAmount * 1e18 / chosenSetup.maximumLiquidity)) / 1e18, false);\n', '            }\n', '        } else {\n', '            if (newReward > 0) {\n', '                // transfer the reward\n', '                ILiquidityMiningExtension(_extension).transferTo(newReward, msg.sender);\n', '            }\n', '            // update the creation block to avoid blocks before the new add liquidity\n', '            liquidityMiningPosition.creationBlock = block.number;\n', '            // rebalance the reward per token\n', '            _rebalanceRewardPerToken(liquidityMiningPosition.setupIndex, liquidityPoolData.amount, false);\n', '        }\n', '    }\n', '\n', '    /** @dev this function allows a wallet to update the extension of the given liquidity mining position.\n', '      * @param to address of the new extension.\n', '      * @param positionId id of the liquidity mining position.\n', '     */\n', '    function transfer(address to, uint256 positionId) public byPositionOwner(positionId) {\n', '        // retrieve liquidity mining position\n', '        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\n', '        require(\n', '            to != address(0) &&\n', '            liquidityMiningPosition.setupStartBlock == _setups[liquidityMiningPosition.setupIndex].startBlock &&\n', '            liquidityMiningPosition.setupEndBlock == _setups[liquidityMiningPosition.setupIndex].endBlock,\n', '            "Invalid position"\n', '        );\n', '        liquidityMiningPosition.uniqueOwner = to;\n', '        emit Transfer(positionId, msg.sender, to);\n', '    }\n', '\n', '    /** @dev this function allows a extension to unlock its locked liquidity mining position receiving back its tokens or the lpt amount.\n', '      * @param positionId liquidity mining position id.\n', '      * @param unwrapPair if the caller wants to unwrap his pair from the liquidity pool token or not.\n', '      */\n', '    function unlock(uint256 positionId, bool unwrapPair) public payable byPositionOwner(positionId) {\n', '        // retrieve liquidity mining position\n', '        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\n', '        // require(liquidityMiningPosition.liquidityPoolData.liquidityPoolAddress != address(0), "Invalid position");\n', '        require(!liquidityMiningPosition.free && liquidityMiningPosition.setupEndBlock >= block.number, "Invalid unlock");\n', '        require(!_positionRedeemed[positionId], "Already redeemed");\n', '        uint256 rewardToGiveBack = _partiallyRedeemed[positionId];\n', '        // must pay a penalty fee\n', '        rewardToGiveBack += _setups[liquidityMiningPosition.setupIndex].penaltyFee == 0 ? 0 : (liquidityMiningPosition.reward * ((_setups[liquidityMiningPosition.setupIndex].penaltyFee * 1e18) / ONE_HUNDRED) / 1e18);\n', '        if (rewardToGiveBack > 0) {\n', '            // has partially redeemed, must pay a penalty fee\n', '            if(_rewardTokenAddress != address(0)) {\n', '                _safeTransferFrom(_rewardTokenAddress, msg.sender, address(this), rewardToGiveBack);\n', '                _safeApprove(_rewardTokenAddress, _extension, rewardToGiveBack);\n', '                ILiquidityMiningExtension(_extension).backToYou(rewardToGiveBack);\n', '            } else {\n', '                require(msg.value == rewardToGiveBack, "Invalid sent amount");\n', '                ILiquidityMiningExtension(_extension).backToYou{value : rewardToGiveBack}(rewardToGiveBack);\n', '            }\n', '        }\n', '        _burnLiquidity(_setups[liquidityMiningPosition.setupIndex].objectId, liquidityMiningPosition.liquidityPoolTokenAmount);\n', '        _removeLiquidity(positionId, _setups[liquidityMiningPosition.setupIndex].objectId, liquidityMiningPosition.setupIndex, unwrapPair, liquidityMiningPosition.liquidityPoolTokenAmount, true);\n', '    }\n', '\n', '    /** @dev this function allows a user to withdraw the reward.\n', '      * @param positionId liquidity mining position id.\n', '     */\n', '    function withdrawReward(uint256 positionId) public byPositionOwner(positionId) {\n', '        // retrieve liquidity mining position\n', '        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\n', '        // check if liquidity mining position is valid\n', '        // require(liquidityMiningPosition.liquidityPoolData.liquidityPoolAddress != address(0), "Invalid position");\n', '        uint256 reward = liquidityMiningPosition.reward;\n', '        if (!liquidityMiningPosition.free) {\n', '            // check if reward is available\n', '            require(liquidityMiningPosition.reward > 0, "No reward");\n', "            // check if it's a partial reward or not\n", '            if (liquidityMiningPosition.setupEndBlock >= block.number) {\n', '            // calculate the reward from the liquidity mining position creation block to the current block multiplied by the reward per block\n', '                (reward,) = calculateLockedLiquidityMiningSetupReward(0, 0, true, positionId);\n', '            }\n', '            require(reward <= liquidityMiningPosition.reward, "Reward is bigger than expected");\n', '            // remove the partial reward from the liquidity mining position total reward\n', '            liquidityMiningPosition.reward = liquidityMiningPosition.reward - reward;\n', '        } else {\n', '            // rebalance setup\n', '            _rebalanceRewardPerToken(liquidityMiningPosition.setupIndex, 0, true);\n', '            reward = calculateFreeLiquidityMiningSetupReward(positionId, false);\n', '            require(reward > 0, "No reward?");\n', '        }\n', '        // transfer the reward\n', '        if (reward > 0) {\n', '            if(!liquidityMiningPosition.free) {\n', '                _rewardTokenAddress != address(0) ? _safeTransfer(_rewardTokenAddress, liquidityMiningPosition.uniqueOwner, reward) : payable(liquidityMiningPosition.uniqueOwner).transfer(reward);\n', '            } else {\n', '                ILiquidityMiningExtension(_extension).transferTo(reward, liquidityMiningPosition.uniqueOwner);\n', '            }\n', '        }\n', '        if (liquidityMiningPosition.free) {\n', '            // update the creation block for the free position\n', '            liquidityMiningPosition.creationBlock = block.number;\n', '        } else {\n', '            if (liquidityMiningPosition.reward == 0) {\n', '                // close the locked position after withdrawing all the reward\n', '                _positions[positionId] = _positions[0x0];\n', '            } else {\n', '                // set the partially redeemed amount\n', '                _partiallyRedeemed[positionId] = reward;\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @dev allows the withdrawal of the liquidity from a position or from the item tokens.\n', '      * @param positionId id of the position.\n', '      * @param objectId object id of the item token to burn.\n', '      * @param unwrapPair if the liquidity pool tokens will be unwrapped or not.\n', '      * @param removedLiquidity amount of liquidity to remove.\n', '     */\n', '    function withdrawLiquidity(uint256 positionId, uint256 objectId, bool unwrapPair, uint256 removedLiquidity) public {\n', '        // retrieve liquidity mining position\n', '        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\n', '        uint256 setupIndex = objectId != 0 ? getObjectIdSetupIndex(objectId) : liquidityMiningPosition.setupIndex;\n', '        require(positionId != 0 || (_setups[setupIndex].objectId == objectId || _finishedLockedSetups[objectId]), "Invalid position");\n', '        // current owned liquidity\n', '        require(\n', '            (\n', '                liquidityMiningPosition.free && \n', '                removedLiquidity <= liquidityMiningPosition.liquidityPoolTokenAmount &&\n', '                !_positionRedeemed[positionId]\n', '                // && liquidityMiningPosition.liquidityPoolData.liquidityPoolAddress != address(0)\n', '            ) || (positionId == 0 && INativeV1(_liquidityFarmTokenCollection).balanceOf(msg.sender, objectId) >= removedLiquidity), "Invalid withdraw");\n', '        // check if liquidity mining position is valid\n', '        require(liquidityMiningPosition.free || (_setups[setupIndex].endBlock <= block.number || _finishedLockedSetups[objectId]), "Invalid withdraw");\n', '        // burn the liquidity in the locked setup\n', '        if (positionId == 0) {\n', '            _burnLiquidity(objectId, removedLiquidity);\n', '        } else {\n', '            _positionRedeemed[positionId] = removedLiquidity == liquidityMiningPosition.liquidityPoolTokenAmount;\n', '            withdrawReward(positionId);\n', '            _setups[liquidityMiningPosition.setupIndex].totalSupply -= removedLiquidity;\n', '        }\n', '        _removeLiquidity(positionId, objectId, setupIndex, unwrapPair, removedLiquidity, false);\n', '    }\n', '\n', '    /** @dev this function allows any user to rebalance the pinned setup. */\n', '    function rebalancePinnedSetup() public {\n', '        // if (!_hasPinned || !_setups[_pinnedSetupIndex].free) return;\n', '        uint256 amount;\n', '        for (uint256 i = 0; i < _setups.length; i++) {\n', '            if (_setups[i].free) continue;\n', "            // this is a locked setup that it's currently active or it's a new one\n", '            if (block.number >= _setups[i].startBlock && block.number < _setups[i].endBlock) {\n', '                // the amount to add to the pinned is given by the difference between the reward per block and currently locked one\n', '                // in the case of a new setup, the currentRewardPerBlock is 0 so the difference is the whole rewardPerBlock\n', '                amount += _setups[i].rewardPerBlock - ((_setups[i].rewardPerBlock * (_setups[i].currentStakedLiquidity * 1e18 / _setups[i].maximumLiquidity)) / 1e18);\n', '            // this is a locked setup that has expired\n', '            } else if (block.number >= _setups[i].endBlock) {\n', '                _finishedLockedSetups[_setups[i].objectId] = true;\n', '                // check if the setup is renewable\n', '                if (_setups[i].renewTimes > 0) {\n', '                    _setups[i].renewTimes -= 1;\n', '                    // if it is, we renew it and add the reward per block\n', '                    _renewSetup(i);\n', '                    amount += _setups[i].rewardPerBlock;\n', '                }\n', '            }\n', '        }\n', '        if (_hasPinned && _setups[_pinnedSetupIndex].free) {\n', '            _setups[_pinnedSetupIndex].rewardPerBlock = _setups[_pinnedSetupIndex].currentRewardPerBlock;\n', '            _rebalanceRewardPerBlock(_pinnedSetupIndex, amount, true);\n', '        }\n', '    }\n', '\n', '    /** @dev function used to calculate the reward in a locked liquidity mining setup.\n', '      * @param setupIndex liquidity mining setup index.\n', '      * @param mainTokenAmount amount of main token.\n', "      * @param isPartial if we're calculating a partial reward.\n", '      * @param positionId id of the position (used for the partial reward).\n', '      * @return reward total reward for the liquidity mining position extension.\n', '      * @return relativeRewardPerBlock returned for the pinned free setup balancing.\n', '     */\n', '    function calculateLockedLiquidityMiningSetupReward(uint256 setupIndex, uint256 mainTokenAmount, bool isPartial, uint256 positionId) public view returns(uint256 reward, uint256 relativeRewardPerBlock) {\n', '        if (isPartial) {\n', '            // retrieve the position\n', '            LiquidityMiningPosition memory liquidityMiningPosition = _positions[positionId];\n', '            // calculate the reward\n', '            reward = (block.number >= liquidityMiningPosition.setupEndBlock) ? liquidityMiningPosition.reward : ((block.number - liquidityMiningPosition.creationBlock) * liquidityMiningPosition.lockedRewardPerBlock);\n', '        } else {\n', '            LiquidityMiningSetup memory setup = _setups[setupIndex];\n', '            // check if main token amount is less than the stakeable liquidity\n', '            require(mainTokenAmount <= setup.maximumLiquidity - setup.currentStakedLiquidity, "Invalid liquidity");\n', '            uint256 remainingBlocks = block.number > setup.endBlock ? 0 : setup.endBlock - block.number;\n', '            // get amount of remaining blocks\n', '            require(remainingBlocks > 0, "Setup ended");\n', '            // get total reward still available (= 0 if rewardPerBlock = 0)\n', '            require(setup.rewardPerBlock * remainingBlocks > 0, "No rewards");\n', '            // calculate relativeRewardPerBlock\n', '            relativeRewardPerBlock = (setup.rewardPerBlock * ((mainTokenAmount * 1e18) / setup.maximumLiquidity)) / 1e18;\n', '            // check if rewardPerBlock is greater than 0\n', '            require(relativeRewardPerBlock > 0, "Invalid rpb");\n', '            // calculate reward by multiplying relative reward per block and the remaining blocks\n', '            reward = relativeRewardPerBlock * remainingBlocks;\n', '            // check if the reward is still available\n', '        }\n', '    }\n', '\n', '    /** @dev function used to calculate the reward in a free liquidity mining setup.\n', '      * @param positionId liquidity mining position id.\n', '      * @return reward total reward for the liquidity mining position extension.\n', '     */\n', '    function calculateFreeLiquidityMiningSetupReward(uint256 positionId, bool isExt) public view returns(uint256 reward) {\n', '        LiquidityMiningPosition memory liquidityMiningPosition = _positions[positionId];\n', '        for (uint256 i = 0; i < _setupUpdateBlocks[liquidityMiningPosition.setupIndex].length; i++) {\n', '            if (liquidityMiningPosition.creationBlock < _setupUpdateBlocks[liquidityMiningPosition.setupIndex][i]) {\n', '                reward += (_rewardPerTokenPerSetupPerBlock[liquidityMiningPosition.setupIndex][_setupUpdateBlocks[liquidityMiningPosition.setupIndex][i]] * liquidityMiningPosition.liquidityPoolTokenAmount) / 1e18;\n', '            }\n', '        }\n', '        if (isExt) {\n', '            uint256 rpt = (((block.number - _setups[liquidityMiningPosition.setupIndex].lastBlockUpdate + 1) * _setups[liquidityMiningPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[liquidityMiningPosition.setupIndex].totalSupply;\n', '            reward += (rpt * liquidityMiningPosition.liquidityPoolTokenAmount) / 1e18;\n', '        }\n', '    }\n', '\n', '    /** @dev returns the setup index for the given objectId.\n', '      * @param objectId farm token object id.\n', '      * @return setupIndex index of the setup.\n', '     */\n', '    function getObjectIdSetupIndex(uint256 objectId) public view returns (uint256 setupIndex) {\n', '        require(address(INativeV1(_liquidityFarmTokenCollection).asInteroperable(objectId)) != address(0), "Invalid objectId");\n', '        setupIndex = _objectIdSetup[objectId];\n', '    }\n', '\n', '    /** Private methods. */\n', '\n', '    /** @dev initializes the liquidity mining setups during the contract initialization.\n', '      * @param liquidityMiningSetupsBytes array of liquidity mining setups as bytes.\n', '      * @param setPinned if we are setting the pinned setup or not.\n', '      * @param pinnedIndex the pinned setup index.\n', '     */\n', '    function _initLiquidityMiningSetups(bytes memory liquidityMiningSetupsBytes, bool setPinned, uint256 pinnedIndex) private {\n', '        LiquidityMiningSetup[] memory liquidityMiningSetups = abi.decode(liquidityMiningSetupsBytes, (LiquidityMiningSetup[]));\n', '        require(liquidityMiningSetups.length > 0, "Invalid length");\n', '        for(uint256 i = 0; i < liquidityMiningSetups.length; i++) {\n', '            _setOrAddLiquidityMiningSetup(liquidityMiningSetups[i], true, 0);\n', '        }\n', '        _pinnedSetup(false, setPinned, pinnedIndex);\n', '        // rebalance the pinned setup\n', '        rebalancePinnedSetup();\n', '    }\n', '\n', '    /** @dev helper method that given a liquidity mining setup adds it to the _setups array or updates it.\n', '      * @param data new or updated liquidity mining setup.\n', '      * @param add if we are adding the setup or updating it.\n', '      * @param index liquidity mining setup index.\n', '     */\n', '    function _setOrAddLiquidityMiningSetup(LiquidityMiningSetup memory data, bool add, uint256 index) private {\n', '        LiquidityMiningSetup memory liquidityMiningSetup = add ? data : _setups[index];\n', '        require(\n', '            data.ammPlugin != address(0) &&\n', '            (\n', '                (data.free && data.liquidityPoolTokenAddress != address(0)) ||\n', '                (!data.free && data.liquidityPoolTokenAddress != address(0) && data.startBlock < data.endBlock)\n', '            ),\n', '            "Invalid setup configuration"\n', '        );\n', '        require(!add || liquidityMiningSetup.ammPlugin != address(0), "Invalid setup index");\n', '        address mainTokenAddress = add ? data.mainTokenAddress : liquidityMiningSetup.mainTokenAddress;\n', '        address ammPlugin = add ? data.ammPlugin : liquidityMiningSetup.ammPlugin;\n', '        (,,address[] memory tokenAddresses) = IAMM(ammPlugin).byLiquidityPool(data.liquidityPoolTokenAddress);\n', '        bool found = false;\n', '        for(uint256 z = 0; z < tokenAddresses.length; z++) {\n', '            if(tokenAddresses[z] == mainTokenAddress) {\n', '                found = true;\n', '            } else {\n', '                emit SetupToken(mainTokenAddress, tokenAddresses[z]);\n', '            }\n', '        }\n', '        require(found, "No main token");\n', '        if (add) {\n', '            data.totalSupply = 0;\n', '            data.currentRewardPerBlock = data.free ? data.rewardPerBlock : 0;\n', '            // adding new liquidity mining setup\n', '            _setups.push(data);\n', '        } else {\n', '            if (liquidityMiningSetup.free) {\n', '                // update free liquidity mining setup reward per block\n', '                if (data.rewardPerBlock - liquidityMiningSetup.rewardPerBlock < 0) {\n', '                    _rebalanceRewardPerBlock(index, liquidityMiningSetup.rewardPerBlock - data.rewardPerBlock, false);\n', '                } else {\n', '                    _rebalanceRewardPerBlock(index, data.rewardPerBlock - liquidityMiningSetup.rewardPerBlock, true);\n', '                }\n', '                _setups[index].rewardPerBlock = data.rewardPerBlock;\n', '                _setups[index].currentRewardPerBlock = data.rewardPerBlock;\n', '            } else {\n', '                // update locked liquidity mining setup\n', '                _setups[index].rewardPerBlock = data.rewardPerBlock > 0 ? data.rewardPerBlock : _setups[index].rewardPerBlock;\n', '                _setups[index].renewTimes = data.renewTimes;\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @dev helper function used to update or set the pinned free setup.\n', "      * @param clearPinned if we're clearing the pinned setup or not.\n", "      * @param setPinned if we're setting the pinned setup or not.\n", '      * @param pinnedIndex new pinned setup index.\n', '     */\n', '    function _pinnedSetup(bool clearPinned, bool setPinned, uint256 pinnedIndex) private {\n', "        // if we're clearing the pinned setup we must also remove the excess reward per block\n", '        if (clearPinned && _hasPinned) {\n', '            _hasPinned = false;\n', '            _rebalanceRewardPerToken(_pinnedSetupIndex, 0, false);\n', '            _setups[_pinnedSetupIndex].rewardPerBlock = _setups[_pinnedSetupIndex].currentRewardPerBlock;\n', '        }\n', "        // check if we're updating the pinned setup\n", '        if (!clearPinned && setPinned) {\n', '            require(_setups[pinnedIndex].free, "Invalid pinned free setup");\n', '            uint256 oldBalancedRewardPerBlock;\n', '            // check if we already have a free pinned setup\n', '            if (_hasPinned && _setups[_pinnedSetupIndex].free) {\n', '                // calculate the old balanced reward by subtracting from the current pinned reward per block the starting reward per block (aka currentRewardPerBlock)\n', '                oldBalancedRewardPerBlock = _setups[_pinnedSetupIndex].rewardPerBlock - _setups[_pinnedSetupIndex].currentRewardPerBlock;\n', '                // remove it from the current pinned setup\n', '                _rebalanceRewardPerBlock(_pinnedSetupIndex, oldBalancedRewardPerBlock, false);\n', '            }\n', '            // update pinned setup index\n', '            _hasPinned = true;\n', '            _pinnedSetupIndex = pinnedIndex;\n', '        }\n', '    }\n', '\n', '    /** @dev this function performs the transfer of the tokens that will be staked, interacting with the AMM plugin.\n', '      * @param setup the chosen setup.\n', '      * @param request new open position request.\n', '      * @return amm AMM plugin interface.\n', '      * @return liquidityPoolAmount amount of liquidity pool token.\n', '      * @return mainTokenAmount amount of main token staked.\n', '      * @return involvingETH if the inputed flag is consistent.\n', '     */\n', '    function _transferToMeAndCheckAllowance(LiquidityMiningSetup memory setup, LiquidityMiningPositionRequest memory request) private returns(IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount, bool involvingETH) {\n', '        require(request.amount > 0, "No amount");\n', '        involvingETH = request.amountIsLiquidityPool && setup.involvingETH;\n', '        // retrieve the values\n', '        amm = IAMM(setup.ammPlugin);\n', '        liquidityPoolAmount = request.amountIsLiquidityPool ? request.amount : 0;\n', '        mainTokenAmount = request.amountIsLiquidityPool ? 0 : request.amount;\n', '        address[] memory tokens;\n', '        uint256[] memory tokenAmounts;\n', '        // if liquidity pool token amount is provided, the position is opened by liquidity pool token amount\n', '        if(request.amountIsLiquidityPool) {\n', '            _safeTransferFrom(setup.liquidityPoolTokenAddress, msg.sender, address(this), liquidityPoolAmount);\n', '            (tokenAmounts, tokens) = amm.byLiquidityPoolAmount(setup.liquidityPoolTokenAddress, liquidityPoolAmount);\n', '        } else {\n', '            // else it is opened by the tokens amounts\n', '            (liquidityPoolAmount, tokenAmounts, tokens) = amm.byTokenAmount(setup.liquidityPoolTokenAddress, setup.mainTokenAddress, mainTokenAmount);\n', '        }\n', '\n', '        // check if the eth is involved in the request\n', '        address ethAddress = address(0); \n', '        if(setup.involvingETH) {\n', '            (ethAddress,,) = amm.data();\n', '        }\n', '        // iterate the tokens and perform the transferFrom and the approve\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            if(tokens[i] == setup.mainTokenAddress) {\n', '                mainTokenAmount = tokenAmounts[i];\n', '                if(request.amountIsLiquidityPool) {\n', '                    break;\n', '                }\n', '            }\n', '            if(request.amountIsLiquidityPool) {\n', '                continue;\n', '            }\n', '            if(setup.involvingETH && ethAddress == tokens[i]) {\n', '                involvingETH = true;\n', '                require(msg.value == tokenAmounts[i], "Incorrect eth value");\n', '            } else {\n', '                _safeTransferFrom(tokens[i], msg.sender, address(this), tokenAmounts[i]);\n', '                _safeApprove(tokens[i], setup.ammPlugin, tokenAmounts[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @dev mints a new PositionToken inside the collection for the given wallet.\n', '      * @param uniqueOwner liquidityMiningPosition token extension.\n', '      * @param amount amount of to mint for a farm token.\n', '      * @param setupIndex index of the setup.\n', '      * @return objectId new liquidityMiningPosition token object id.\n', '     */\n', '    function _mintLiquidity(address uniqueOwner, uint256 amount, uint256 setupIndex) private returns(uint256 objectId) {\n', '        if (_setups[setupIndex].objectId == 0) {\n', '            (objectId,) = INativeV1(_liquidityFarmTokenCollection).mint(amount, string(abi.encodePacked("Farming LP ", _toString(_setups[setupIndex].liquidityPoolTokenAddress))), "fLP", ILiquidityMiningFactory(_factory).getLiquidityFarmTokenURI(), true);\n', '            emit FarmToken(objectId, _setups[setupIndex].liquidityPoolTokenAddress, setupIndex, _setups[setupIndex].endBlock);\n', '            _objectIdSetup[objectId] = setupIndex;\n', '            _setups[setupIndex].objectId = objectId;\n', '        } else {\n', '            INativeV1(_liquidityFarmTokenCollection).mint(_setups[setupIndex].objectId, amount);\n', '        }\n', '        INativeV1(_liquidityFarmTokenCollection).safeTransferFrom(address(this), uniqueOwner, _setups[setupIndex].objectId, amount, "");\n', '    }\n', '\n', '    function _toString(address _addr) internal pure returns(string memory) {\n', '        bytes32 value = bytes32(uint256(_addr));\n', '        bytes memory alphabet = "0123456789abcdef";\n', '\n', '        bytes memory str = new bytes(42);\n', "        str[0] = '0';\n", "        str[1] = 'x';\n", '        for (uint i = 0; i < 20; i++) {\n', '            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\n', '            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\n', '        }\n', '        return string(str);\n', '    }\n', '\n', '    /** @dev burns a farm token from the collection.\n', '      * @param objectId object id where to burn liquidity.\n', '      * @param amount amount of liquidity to burn.\n', '      */\n', '    function _burnLiquidity(uint256 objectId, uint256 amount) private {\n', '        INativeV1 tokenCollection = INativeV1(_liquidityFarmTokenCollection);\n', '        // transfer the liquidity mining farm token to this contract\n', '        tokenCollection.safeTransferFrom(msg.sender, address(this), objectId, amount, "");\n', '        // burn the liquidity mining farm token\n', '        tokenCollection.burn(objectId, amount);\n', '    }\n', '\n', '    /** @dev helper function used to remove liquidity from a free position or to burn item liquidity tokens and retrieve their content.\n', '      * @param positionId id of the position.\n', '      * @param objectId object id related to the item liquidity tokens to burn.\n', '      * @param setupIndex index of the setup related to the item liquidity tokens.\n', '      * @param unwrapPair whether to unwrap the liquidity pool tokens or not.\n', "      * @param isUnlock if we're removing liquidity from an unlock method or not.\n", '     */\n', '    function _removeLiquidity(uint256 positionId, uint256 objectId, uint256 setupIndex, bool unwrapPair, uint256 removedLiquidity, bool isUnlock) private {\n', '        LiquidityMiningPosition storage liquidityMiningPosition = _positions[positionId];\n', '        LiquidityPoolData memory lpData = LiquidityPoolData(\n', '            _setups[setupIndex].liquidityPoolTokenAddress,\n', '            removedLiquidity,\n', '            _setups[setupIndex].mainTokenAddress,\n', '            true,\n', '            _setups[setupIndex].involvingETH,\n', '            msg.sender\n', '        );\n', '        uint256 remainingLiquidity;\n', '        // we are removing liquidity using the setup items\n', '        if (positionId != 0) {\n', '            // update the setup index\n', '            setupIndex = liquidityMiningPosition.setupIndex;\n', '            remainingLiquidity = liquidityMiningPosition.liquidityPoolTokenAmount - removedLiquidity;\n', '        }\n', '        // retrieve fee stuff\n', '        (uint256 exitFeePercentage, address exitFeeWallet) = ILiquidityMiningFactory(_factory).feePercentageInfo();\n', '        // pay the fees!\n', '        if (exitFeePercentage > 0) {\n', '            uint256 fee = (lpData.amount * ((exitFeePercentage * 1e18) / ONE_HUNDRED)) / 1e18;\n', '            _safeTransfer(_setups[setupIndex].liquidityPoolTokenAddress, exitFeeWallet, fee);\n', '            lpData.amount = lpData.amount - fee;\n', '        }\n', '        // check if the user wants to unwrap its pair or not\n', '        if (unwrapPair) {\n', '            // remove liquidity using AMM\n', '            address ammPlugin = _setups[setupIndex].ammPlugin;\n', '            _safeApprove(lpData.liquidityPoolAddress, ammPlugin, lpData.amount);\n', '            (, uint256[] memory amounts,) = IAMM(ammPlugin).removeLiquidity(lpData);\n', '            require(amounts[0] > 0 && amounts[1] > 0, "Insufficient amount");\n', '            if (isUnlock) {\n', '                _setups[setupIndex].currentStakedLiquidity -= amounts[0];\n', '            }\n', '        } else {\n', '            // send back the liquidity pool token amount without the fee\n', '            _safeTransfer(lpData.liquidityPoolAddress, lpData.receiver, lpData.amount);\n', '        }\n', '        // rebalance the setup if not free\n', '        if (!_setups[setupIndex].free && !_finishedLockedSetups[objectId]) {\n', '            // check if the setup has been updated or not\n', '            if (objectId == _setups[setupIndex].objectId) {\n', "                // check if it's finished (this is a withdraw) or not (a unlock)\n", '                if (!isUnlock) {\n', "                    // the locked setup must be considered finished only if it's not renewable\n", '                    _finishedLockedSetups[objectId] = _setups[setupIndex].renewTimes == 0;\n', '                    if (_hasPinned && _setups[_pinnedSetupIndex].free) {\n', '                        _rebalanceRewardPerBlock(\n', '                            _pinnedSetupIndex, \n', '                            _setups[setupIndex].rewardPerBlock - ((_setups[setupIndex].rewardPerBlock * (_setups[setupIndex].currentStakedLiquidity * 1e18 / _setups[setupIndex].maximumLiquidity)) / 1e18),\n', '                            false\n', '                        );\n', '                    }\n', '                    if (_setups[setupIndex].renewTimes > 0) {\n', '                        _setups[setupIndex].renewTimes -= 1;\n', '                        // renew the setup if renewable\n', '                        _renewSetup(setupIndex);\n', '                    }\n', '                } else {\n', '                    // this is an unlock, so we just need to provide back the reward per block\n', '                    if (_hasPinned && _setups[_pinnedSetupIndex].free) {\n', '                        _rebalanceRewardPerBlock(\n', '                            _pinnedSetupIndex, \n', '                            _setups[setupIndex].rewardPerBlock * ((removedLiquidity * 1e18 / _setups[setupIndex].maximumLiquidity) / 1e18), \n', '                            true\n', '                        );\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        if (positionId != 0) {\n', '            // delete the liquidity mining position after the withdraw\n', '            if (remainingLiquidity == 0) {\n', '                _positions[positionId] = _positions[0x0];\n', '            } else {\n', '                // update the creation block and amount\n', '                liquidityMiningPosition.creationBlock = block.number;\n', '                liquidityMiningPosition.liquidityPoolTokenAmount = remainingLiquidity;\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @dev Renews the setup with the given index.\n', '      * @param setupIndex index of the setup to renew.\n', '     */\n', '    function _renewSetup(uint256 setupIndex) private {\n', '        uint256 duration = _setups[setupIndex].endBlock - _setups[setupIndex].startBlock;\n', '        _setups[setupIndex].startBlock = block.number + 1;\n', '        _setups[setupIndex].endBlock = block.number + 1 + duration;\n', '        _setups[setupIndex].currentRewardPerBlock = 0;\n', '        _setups[setupIndex].currentStakedLiquidity = 0;\n', '        _setups[setupIndex].objectId = 0;\n', '    }\n', '\n', '    /** @dev function used to rebalance the reward per block in the given free liquidity mining setup.\n', '      * @param setupIndex setup to rebalance.\n', '      * @param lockedRewardPerBlock new liquidity mining position locked reward per block that must be subtracted from the given free liquidity mining setup reward per block.\n', '      * @param fromExit if the rebalance is caused by an exit from the locked liquidity mining position or not.\n', '      */\n', '    function _rebalanceRewardPerBlock(uint256 setupIndex, uint256 lockedRewardPerBlock, bool fromExit) private {\n', '        LiquidityMiningSetup storage setup = _setups[setupIndex];\n', '        _rebalanceRewardPerToken(setupIndex, 0, fromExit);\n', '        fromExit ? setup.rewardPerBlock += lockedRewardPerBlock : setup.rewardPerBlock -= lockedRewardPerBlock;\n', '    }\n', '\n', '    /** @dev function used to rebalance the reward per token in a free liquidity mining setup.\n', '      * @param setupIndex index of the setup to rebalance.\n', '      * @param liquidityPoolTokenAmount amount of liquidity pool token being added.\n', '      * @param fromExit if the rebalance is caused by an exit from the free liquidity mining position or not.\n', '     */\n', '    function _rebalanceRewardPerToken(uint256 setupIndex, uint256 liquidityPoolTokenAmount, bool fromExit) private {\n', '        LiquidityMiningSetup storage setup = _setups[setupIndex];\n', '        if(setup.lastBlockUpdate > 0 && setup.totalSupply > 0) {\n', '            // add the block to the setup update blocks\n', '            _setupUpdateBlocks[setupIndex].push(block.number);\n', '            // update the reward token\n', '            _rewardPerTokenPerSetupPerBlock[setupIndex][block.number] = (((block.number - setup.lastBlockUpdate) * setup.rewardPerBlock) * 1e18) / setup.totalSupply;\n', '        }\n', '        // update the last block update variable\n', '        setup.lastBlockUpdate = block.number;\n', '        // update total supply in the setup AFTER the reward calculation - to let previous liquidity mining position holders to calculate the correct value\n', '        fromExit ? setup.totalSupply -= liquidityPoolTokenAmount : setup.totalSupply += liquidityPoolTokenAmount;\n', '    }\n', '\n', '    /** @dev function used to safely approve ERC20 transfers.\n', '      * @param erc20TokenAddress address of the token to approve.\n', '      * @param to receiver of the approval.\n', '      * @param value amount to approve for.\n', '     */\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    /** @dev function used to safe transfer ERC20 tokens.\n', '      * @param erc20TokenAddress address of the token to transfer.\n', '      * @param to receiver of the tokens.\n', '      * @param value amount of tokens to transfer.\n', '     */\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    /** @dev this function safely transfers the given ERC20 value from an address to another.\n', '      * @param erc20TokenAddress erc20 token address.\n', '      * @param from address from.\n', '      * @param to address to.\n', '      * @param value amount to transfer.\n', '     */\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    /** @dev calls the contract at the given location using the given payload and returns the returnData.\n', '      * @param location location to call.\n', '      * @param payload call payload.\n', '      * @return returnData call return data.\n', '     */\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '\n', '    /** @dev function used to receive batch of erc1155 tokens. */\n', '    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public view override returns(bytes4) {\n', '        require(_liquidityFarmTokenCollection == msg.sender, "Invalid sender");\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '\n', '    /** @dev function used to receive erc1155 tokens. */\n', '    function onERC1155Received(address, address, uint256, uint256, bytes memory) public view override returns(bytes4) {\n', '        require(_liquidityFarmTokenCollection == msg.sender, "Invalid sender");\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '}']