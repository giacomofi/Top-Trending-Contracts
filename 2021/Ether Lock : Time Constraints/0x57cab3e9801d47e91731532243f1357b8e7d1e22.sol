['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-14\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library EnumerableSet {\n', '    struct Set {\n', '        bytes32[] _values;\n', '        mapping(bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) {\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            set._values[toDeleteIndex] = lastvalue;\n', '\n', '            set._indexes[lastvalue] = toDeleteIndex + 1;\n', '\n', '            set._values.pop();\n', '\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _contains(Set storage set, bytes32 value)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '    function _at(Set storage set, uint256 index)\n', '        private\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        require(\n', '            set._values.length > index,\n', '            "EnumerableSet: index out of bounds"\n', '        );\n', '        return set._values[index];\n', '    }\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    function add(AddressSet storage set, address value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return _add(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    function remove(AddressSet storage set, address value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return _remove(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    function contains(AddressSet storage set, address value)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return _contains(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '    function at(AddressSet storage set, uint256 index)\n', '        internal\n', '        view\n', '        returns (address)\n', '    {\n', '        return address(uint256(_at(set._inner, index)));\n', '    }\n', '\n', '    // UintSet\n', '\n', '    struct UintSet {\n', '        Set _inner;\n', '    }\n', '\n', '    function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(value));\n', '    }\n', '\n', '    function remove(UintSet storage set, uint256 value)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return _remove(set._inner, bytes32(value));\n', '    }\n', '\n', '    function contains(UintSet storage set, uint256 value)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        return _contains(set._inner, bytes32(value));\n', '    }\n', '\n', '    function length(UintSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '    function at(UintSet storage set, uint256 index)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return uint256(_at(set._inner, index));\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    // ERC20 Optional Views\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    // Views\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    // Mutative functions\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    // Events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'contract PleStaking {\n', '    using SafeMath for uint256;\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '    event RewardsTransferred(address holder, uint256 amount);\n', '\n', '    IERC20 public tokenContract;\n', '\n', '    address public tokenFeeAddress;\n', '\n', '    // reward rate 40.00% per year\n', '    uint256 public constant rewardRate = 4000;\n', '    uint256 public constant rewardInterval = 365 days;\n', '\n', '    // staking fee 1.50 percent\n', '    uint256 public constant stakingFeeRate = 150;\n', '\n', '    // unstaking fee 0.50 percent\n', '    uint256 public constant unstakingFeeRate = 50;\n', '\n', '    uint256 public totalClaimedRewards = 0;\n', '\n', '    EnumerableSet.AddressSet private holders;\n', '\n', '    mapping(address => uint256) public depositedTokens;\n', '    mapping(address => uint256) public stakingTime;\n', '    mapping(address => uint256) public lastClaimedTime;\n', '    mapping(address => uint256) public totalEarnedTokens;\n', '\n', '    constructor(address _tokenAddress, address _tokenFeeAddress) public {\n', '        tokenContract = IERC20(_tokenAddress);\n', '        tokenFeeAddress = _tokenFeeAddress;\n', '    }\n', '\n', '    function getBalance() private view returns (uint256) {\n', '        return tokenContract.balanceOf(address(this));\n', '    }\n', '\n', '    function getRewardToken() private view returns (uint256) {\n', '        uint256 totalDepositedAmount = 0;\n', '        uint256 length = getNumberOfHolders();\n', '        for (uint256 i = 0; i < length; i = i.add(1)) {\n', '            uint256 depositedAmount = depositedTokens[holders.at(i)];\n', '            totalDepositedAmount = totalDepositedAmount.add(depositedAmount);\n', '        }\n', '\n', '        return tokenContract.balanceOf(address(this)).sub(totalDepositedAmount);\n', '    }\n', '\n', '    function distributeToken(address account) private {\n', '        uint256 pendingDivs = getPendingDivs(account);\n', '        if (pendingDivs > 0) {\n', '            tokenContract.balanceOf(address(this)).sub(pendingDivs);\n', '            tokenContract.balanceOf(account).add(pendingDivs);\n', '            require(\n', '                tokenContract.transfer(account, pendingDivs),\n', '                "Could not transfer tokens."\n', '            );\n', '            totalEarnedTokens[account] = totalEarnedTokens[account].add(\n', '                pendingDivs\n', '            );\n', '            totalClaimedRewards = totalClaimedRewards.add(pendingDivs);\n', '            emit RewardsTransferred(account, pendingDivs);\n', '        }\n', '       lastClaimedTime[account] = now;\n', '    }\n', '  \n', '   \n', '    function getPendingDivs(address _holder) public view returns (uint256) {\n', '        if (!holders.contains(_holder)) return 0;\n', '        if (depositedTokens[_holder] == 0) return 0;\n', '        if (getRewardToken() == 0) return 0;\n', '\n', '        uint256 timeDiff = now.sub(lastClaimedTime[_holder]);\n', '        uint256 stakedAmount = depositedTokens[_holder];\n', '        \n', '        uint256 pendingDivs = stakedAmount.mul(timeDiff).mul(rewardRate).div(rewardInterval).div(1e4);\n', '\n', '        return pendingDivs;\n', '    }\n', '\n', '    function getNumberOfHolders() public view returns (uint256) {\n', '        return holders.length();\n', '    }\n', '\n', '    function stake(uint256 amountToStake) public {\n', '        require(amountToStake > 0, "Cannot deposit 0 Tokens");\n', '        require(\n', '            tokenContract.transferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                amountToStake\n', '            ),\n', '            "Insufficient Token Allowance"\n', '        );\n', '        \n', '      \n', '\n', '        uint256 fee = amountToStake.mul(stakingFeeRate).div(1e4);\n', '        uint256 amountAfterFee = amountToStake.sub(fee);\n', '\n', '        require(\n', '            tokenContract.transfer(tokenFeeAddress, fee),\n', '            "Could not transfer deposit fee."\n', '        );\n', '\n', '        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(\n', '            amountAfterFee\n', '        );\n', '\n', '        if (!holders.contains(msg.sender)) {\n', '            holders.add(msg.sender);\n', '            stakingTime[msg.sender] = now;\n', '            lastClaimedTime[msg.sender] = now;\n', '        }\n', '    }\n', '\n', '    function unstake(uint256 amountToWithdraw) public {\n', '        require(\n', '            depositedTokens[msg.sender] >= amountToWithdraw,\n', '            "Invalid amount to withdraw"\n', '        );\n', '        \n', '     \n', '        \n', '        uint256 fee = amountToWithdraw.mul(unstakingFeeRate).div(1e4);\n', '        uint256 amountAfterFee = amountToWithdraw.sub(fee);\n', '        require(\n', '            tokenContract.transfer(tokenFeeAddress, fee),\n', '            "Could not transfer unstaking fee."\n', '        );\n', '        require(\n', '            tokenContract.transfer(msg.sender, amountAfterFee),\n', '            "Could not transfer tokens."\n', '        );\n', '\n', '        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(\n', '            amountToWithdraw\n', '        );\n', '\n', '        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0) {\n', '            holders.remove(msg.sender);\n', '        }\n', '    }\n', '\n', '    function claimDivs() public {\n', '        distributeToken(msg.sender);\n', '    }\n', '\n', '    function getStakersList(uint256 startIndex, uint256 endIndex)\n', '        public\n', '        view\n', '        returns (\n', '            address[] memory stakers,\n', '            uint256[] memory stakingTimestamps,\n', '            uint256[] memory lastClaimedTimeStamps,\n', '            uint256[] memory stakedTokens\n', '        )\n', '    {\n', '        require(startIndex < endIndex);\n', '\n', '        uint256 length = endIndex.sub(startIndex);\n', '        address[] memory _stakers = new address[](length);\n', '        uint256[] memory _stakingTimestamps = new uint256[](length);\n', '        uint256[] memory _lastClaimedTimeStamps = new uint256[](length);\n', '        uint256[] memory _stakedTokens = new uint256[](length);\n', '\n', '        for (uint256 i = startIndex; i < endIndex; i = i.add(1)) {\n', '            address staker = holders.at(i);\n', '            uint256 listIndex = i.sub(startIndex);\n', '            _stakers[listIndex] = staker;\n', '            _stakingTimestamps[listIndex] = stakingTime[staker];\n', '            _lastClaimedTimeStamps[listIndex] = lastClaimedTime[staker];\n', '            _stakedTokens[listIndex] = depositedTokens[staker];\n', '        }\n', '\n', '        return (\n', '            _stakers,\n', '            _stakingTimestamps,\n', '            _lastClaimedTimeStamps,\n', '            _stakedTokens\n', '        );\n', '    }\n', '}']