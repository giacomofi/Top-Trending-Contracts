['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'import "SafeMath.sol";\n', 'import "ZeroCopySink.sol";\n', 'import "ZeroCopySource.sol";\n', 'import "IERC721.sol";\n', 'import "IERC721Enumerable.sol";\n', 'import "IERC721Metadata.sol";\n', 'import "IPolyNFTLockProxy.sol";\n', '\n', 'contract PolyNFTQuery {\n', '    using SafeMath for uint;\n', '\n', '    function getAndCheckTokenUrl(address asset, address user, uint tokenId) public view returns (bool, string memory) {\n', '        string memory url = "";\n', '        address owner = IERC721(asset).ownerOf(tokenId);\n', '        if (user != owner || user == address(0)) {\n', '            return (false, url);\n', '        }\n', '\n', '        url = IERC721Metadata(asset).tokenURI(tokenId);\n', '        return (true, url);\n', '    }\n', '\n', '    // getTokensByIndex index start from 0\n', '    function getOwnerTokensByIndex(address asset, address owner, uint start, uint length) public view returns (bool, bytes memory) {\n', '        bytes memory buff;\n', '        if (length == 0 || length > 10) {\n', '            return (false, buff);\n', '        }\n', '\n', '        uint total = IERC721(asset).balanceOf(owner);\n', '        if (total == 0 || start >= total) {\n', '            return (false, buff);\n', '        }        \n', '        uint end = _calcEndIndex(start, length, total);\n', '\n', '        IERC721Metadata meta = IERC721Metadata(asset);\n', '        IERC721Enumerable enu = IERC721Enumerable(asset);\n', '        for (uint index = start; index <= end; index++) {\n', '            uint tokenId = enu.tokenOfOwnerByIndex(owner, index);\n', '            string memory url = meta.tokenURI(tokenId);\n', '            buff = _serializeProfile(buff, tokenId, url);\n', '        }\n', '        return (true, buff);\n', '    }\n', '\n', '    // getTokensByIndex index start from 0\n', '    function getTokensByIds(address asset, bytes calldata args) public view returns (bool, bytes memory) {\n', '        uint off = 0;\n', '        uint tokenId = 0;\n', '        uint length = 0;\n', '        bytes memory buff;\n', '\n', '        (length, off) = ZeroCopySource.NextUint256(args, off);\n', '        if (length == 0 || length > 10) {\n', '            return (false, buff);\n', '        }\n', '\n', '        IERC721Metadata meta = IERC721Metadata(asset);\n', '        for (uint index = 0; index < length; index++) {\n', '            (tokenId, off) = ZeroCopySource.NextUint256(args, off);\n', '            string memory url = meta.tokenURI(tokenId);\n', '            buff = _serializeProfile(buff, tokenId, url);\n', '        }\n', '        return (true, buff);\n', '    }\n', '\n', '    function getFilterTokensByIndex(address asset, address ignore, uint start, uint length) public view returns (bool, bytes memory) {\n', '        bytes memory buff;\n', '        if (length == 0 || length > 10) {\n', '            return (false, buff);\n', '        }\n', '\n', '        IERC721Metadata meta = IERC721Metadata(asset);\n', '        IERC721Enumerable enu = IERC721Enumerable(asset);\n', '        IERC721 erc = IERC721(asset);\n', '        \n', '        uint256 total = enu.totalSupply();\n', '        if (total == 0 || start >= total) {\n', '            return (false, buff);\n', '        }\n', '\n', '        uint end = _calcEndIndex(start, length, total);\n', '        while(start <= end && end < total) {\n', '            uint tokenId = enu.tokenByIndex(start);\n', '            start = start + 1;\n', '            address owner = erc.ownerOf(tokenId);\n', '            if (owner == ignore) {\n', '                end = end + 1;\n', '                continue;\n', '            }\n', '            string memory url = meta.tokenURI(tokenId);\n', '            buff = _serializeProfile(buff, tokenId, url);\n', '        }\n', '        return (true, buff);\n', '    }\n', '\n', '    function _serializeProfile(bytes memory buff, uint tokenId, string memory url) internal pure returns (bytes memory) {\n', '        buff = abi.encodePacked(\n', '            buff,\n', '            ZeroCopySink.WriteUint256(tokenId),\n', '            ZeroCopySink.WriteVarBytes(bytes(url))\n', '        );\n', '        return buff;\n', '    }\n', '\n', '    function _calcEndIndex(uint start, uint length, uint total) internal pure returns (uint) {\n', '        uint end = start + length - 1;\n', '        if (end >= total) {\n', '            end = total - 1;\n', '        }\n', '        return end;\n', '    }\n', '}']