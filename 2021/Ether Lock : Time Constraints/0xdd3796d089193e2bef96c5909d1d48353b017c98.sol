['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-16\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity =0.6.11;\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        require(y > 0);\n', '        z = x / y;\n', '    }\n', '\n', '    function min(uint x, uint y) internal pure returns (uint z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function max(uint x, uint y) internal pure returns (uint z) {\n', '        return x >= y ? x : y;\n', '    }\n', '    function imin(int x, int y) internal pure returns (int z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    function imax(int x, int y) internal pure returns (int z) {\n', '        return x >= y ? x : y;\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '    uint constant RAY = 10 ** 27;\n', '\n', '    //rounds to zero if x*y < WAD / 2\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '    //rounds to zero if x*y < RAY / 2\n', '    function rmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '    //rounds to zero if x*y < WAD / 2\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '    //rounds to zero if x*y < RAY / 2\n', '    function rdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '    // This famous algorithm is called "exponentiation by squaring"\n', '    // and calculates x^n with x as fixed-point and n as regular unsigned.\n', '    //\n', "    // It's O(log n), instead of O(n) for naive repeated multiplication.\n", '    //\n', '    // These facts are why it works:\n', '    //\n', '    //  If n is even, then x^n = (x^2)^(n/2).\n', '    //  If n is odd,  then x^n = x * x^(n-1),\n', '    //   and applying the equation for even x gives\n', '    //    x^n = x * (x^2)^((n-1) / 2).\n', '    //\n', '    //  Also, EVM division is flooring and\n', '    //    floor[(n-1) / 2] = floor[n / 2].\n', '    //\n', '    function rpow(uint x, uint n) internal pure returns (uint z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rmul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rmul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'library TransferHelper {\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::safeApprove: approve failed'\n", '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::safeTransfer: transfer failed'\n", '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::transferFrom: transferFrom failed'\n", '        );\n', '    }\n', '\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', "        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n", '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    \n', '    /* Remove tranfer functionality for hodler token\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    */\n', '}\n', '\n', 'contract HodlerERC20 is IERC20 {\n', '    using SafeMath for uint;\n', '\n', '    string public override name;\n', '    string public override symbol;\n', '    uint8 public override decimals;\n', '    uint public override totalSupply;\n', '    uint public totalWithdraw;\n', '    mapping(address => uint) public override balanceOf;\n', '    //mapping(address => mapping(address => uint)) public override allowance;\n', '\n', '    function _mint(address to, uint value) internal {\n', '        totalSupply = totalSupply.add(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint value) internal {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    function _burnCurve(address from, uint value) internal {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        totalWithdraw = totalWithdraw.add(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    /* Remove tranfer functionality for hodler token\n', '    function _approve(address owner, address spender, uint value) private {\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint value) private {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint value) external override returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint value) external override returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint value) external override returns (bool) {\n', '        if (allowance[from][msg.sender] != uint(-1)) {\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        }\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '    */\n', '}\n', '\n', 'contract Hodler is HodlerERC20{\n', '  using SafeMath for uint256;\n', '\n', '  bool public initialized;\n', '  address public asset;\n', '  uint256 public start_amount;\n', '  uint256 public min_percent;\n', '  uint256 public max_percent;\n', '  \n', '  bool public started;\n', '  uint256 public start_time;\n', '  bool public ended;\n', '  mapping(address => uint256) public end_time;\n', ' \n', '  event Deposit(address indexed from, uint256 amount);\n', '  event Withdraw(address indexed from, uint256 asset_value, uint256 token_value, bool started);\n', '\n', '  uint256 private unlocked = 1;\n', '  modifier lock() {\n', "      require(unlocked == 1, 'Hodler: LOCKED');\n", '      unlocked = 0;\n', '      _;\n', '      unlocked = 1;\n', '  }\n', '\n', '  function initialize(address _asset, uint256 _amount, uint256 _min, uint256 _max) public {\n', '      require(initialized == false, "Hodler_initialize: already initialized");\n', '      initialized = true;\n', '      asset = _asset;\n', '      start_amount = _amount;\n', '      min_percent = _min;\n', '      max_percent = _max;\n', '      string memory _name = IERC20(asset).name();\n', '      name = append("Hodler ", _name);\n', '      string memory _symbol = IERC20(asset).symbol();\n', '      symbol = append("hodl", _symbol);\n', '      decimals = IERC20(asset).decimals();\n', '  }\n', '\n', '  function deposit(uint256 amount) public lock {\n', '      require(amount > 0, "Hodler_Deposit: zero asset deposit"); \n', '      require(ended == false, "Hodler_Deposit: game ended");\n', '      require(started == false, "Hodler_Deposit: game started");\n', '      if (totalSupply.add(amount) >= start_amount) {\n', '          require(totalSupply.add(amount) < start_amount.mul(2), "Hodler_Deposit: final deposit out of range");\n', '          started = true;\n', '          start_time = block.timestamp;\n', '      }\n', '      TransferHelper.safeTransferFrom(asset, msg.sender, address(this), amount); \n', '      _mint(msg.sender, amount);\n', '      Deposit(msg.sender, amount);\n', '  }\n', '\n', '  function withdraw(uint256 token_amount) public lock {\n', '      require(token_amount > 0, "Hodler_withdraw: zero token withdraw"); \n', '      require(ended == false, "Hodler_withdraw: game ended");\n', '      uint256 asset_withdraw;\n', '      if (started != true) {\n', '          asset_withdraw = token_amount;\n', '          _burn(msg.sender, token_amount);\n', '      } else {\n', '          asset_withdraw = calculateAssetOut(token_amount);\n', '          if (totalWithdraw.add(token_amount) == totalSupply) {\n', '              ended = true;\n', '          }  \n', '          require(asset_withdraw > 0, "Hodler_withdraw: zero asset withdraw");\n', '          _burnCurve(msg.sender, token_amount);\n', '          if (balanceOf[msg.sender] == 0) {end_time[msg.sender] = block.timestamp;}\n', '      }\n', '      TransferHelper.safeTransfer(asset, msg.sender, asset_withdraw);\n', '      Withdraw(msg.sender, asset_withdraw, token_amount, started);\n', '  }\n', '\n', '  function calculateAssetOut(uint256 token_amount) public view returns (uint256) {\n', '      uint256 rounding = totalSupply;\n', '      /*\n', '       1. Calc perc_assets_out_new = 40 * totalWithdraw/totalSupply + 80 \n', '          -> At min this is 40 * 0 + 80 = 80% \n', '          -> At max this is 40 * 1 + 80 = 120% \n', '      */\n', '      uint256 difference = max_percent.sub(min_percent);\n', '      uint256 perc_assets_out_old = difference.mul(rounding).mul(totalWithdraw).div(totalSupply).add(min_percent.mul(rounding));\n', '      uint256 new_totalWithdraw = totalWithdraw.add(token_amount);\n', '      uint256 perc_assets_out_new = difference.mul(rounding).mul(new_totalWithdraw).div(totalSupply).add(min_percent.mul(rounding));\n', '      /* \n', '        2. Calc mean percent difference -> perc_new - perc_old / 2 + perc_old\n', '          -> at 120 perc_new and 100 perc_old = (120 - 100) / 2 + 100 = 110% \n', '          -> at 100 perc_new and 80 perc_old = (100 - 80) / 2 + 80 = 90%\n', '      */\n', '      uint256 mean_perc = (perc_assets_out_new.sub(perc_assets_out_old)).div(2).add(perc_assets_out_old);\n', '      /* \n', '        3. Calc assets out -> token_amount * mean_perc_diff / 100\n', '          -> at mean_perc_diff 110% = 110 * token_amount / 100\n', '      */\n', '      uint256 assets_out = mean_perc.mul(token_amount).div(rounding.mul(100));\n', '      if (new_totalWithdraw == totalSupply) {\n', '          IERC20 weth = IERC20(asset);\n', '          assets_out = weth.balanceOf(address(this));\n', '      }\n', '      return assets_out;\n', '  }\n', '\n', '  function append(string memory a, string memory b) internal pure returns (string memory) {\n', '      return string(abi.encodePacked(a, b));\n', '  }\n', '}']