['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\LiquidityMiningData.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'struct LiquidityMiningSetupConfiguration {\n', '    bool add;\n', '    uint256 index;\n', '    LiquidityMiningSetup data;\n', '}\n', '\n', '// liquidity mining setup struct\n', 'struct LiquidityMiningSetup {\n', '    address ammPlugin; // amm plugin address used for this setup (eg. uniswap amm plugin address).\n', '    uint256 objectId; // items object id for the liquidity pool token.\n', '    address liquidityPoolTokenAddress; // address of the liquidity pool token\n', '    address mainTokenAddress; // eg. buidl address.\n', '    uint256 startBlock; // liquidity mining setup start block (used only if free is false).\n', '    uint256 endBlock; // liquidity mining setup end block (used only if free is false).\n', '    uint256 rewardPerBlock; // liquidity mining setup reward per single block.\n', '    uint256 currentRewardPerBlock; // liquidity mining setup current reward per single block.\n', '    uint256 totalSupply; // current liquidity added in this setup (used only if free is true).\n', '    uint256 lastBlockUpdate; // number of the block where an update was triggered.\n', '    uint256 maximumLiquidity; // maximum liquidity stakeable in the contract (used only if free is false).\n', '    uint256 currentStakedLiquidity; // currently staked liquidity (used only if free is false).\n', '    bool free; // if the setup is a free liquidity mining setup or a locked one.\n', "    uint256 renewTimes; // if the locked setup is renewable or if it's one time (used only if free is false).\n", '    uint256 penaltyFee; // fee paid when the user exits a still active locked liquidity mining setup (used only if free is false).\n', '    bool involvingETH; // if the setup involves ETH or not.\n', '}\n', '\n', '// position struct\n', 'struct LiquidityMiningPosition {\n', '    address uniqueOwner; // address representing the extension address, address(0) if objectId is populated.\n', '    uint256 setupIndex; // the setup index.\n', '    uint256 setupStartBlock; // liquidity mining setup start block (used only if free is false).\n', '    uint256 setupEndBlock; // liquidity mining setup end block (used only if free is false).\n', '    bool free; // if the setup is a free liquidity mining setup or a locked one.\n', '    // LiquidityPoolData liquidityPoolData; // amm liquidity pool data.\n', '    uint256 liquidityPoolTokenAmount;\n', '    uint256 reward; // position reward.\n', '    uint256 lockedRewardPerBlock; // position locked reward per block.\n', '    uint256 creationBlock; // block when this position was created.\n', '}\n', '\n', '// stake data struct\n', 'struct LiquidityMiningPositionRequest {\n', '    uint256 setupIndex; // index of the chosen setup.\n', '    uint256 amount; // amount of main token.\n', '    bool amountIsLiquidityPool; //true if user wants to directly share the liquidity pool token amount, false to add liquidity to AMM\n', '    address positionOwner; // position extension or address(0) [msg.sender].\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\ILiquidityMiningExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface ILiquidityMiningExtension {\n', '\n', '    function init(bool byMint, address host) external;\n', '\n', '    function setHost(address host) external;\n', '\n', '    function data() external view returns(address liquidityMiningContract, bool byMint, address host, address rewardTokenAddress);\n', '\n', '    function transferTo(uint256 amount, address recipient) external;\n', '    function backToYou(uint256 amount) external payable;\n', '\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) external;\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\ILiquidityMining.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface ILiquidityMining {\n', '\n', '    function _rewardTokenAddress() external view returns(address);\n', '    function setups() external view returns (LiquidityMiningSetup[] memory);\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) external;\n', '    \n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function safeApprove(address spender, uint256 amount) external;\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\util\\IERC20Mintable.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20Mintable {\n', '    function mint(address wallet, uint256 amount) external returns (bool);\n', '    function burn(address wallet, uint256 amount) external returns (bool);\n', '}\n', '\n', '// File: contracts\\liquidity-mining\\LiquidityMiningExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract LiquidityMiningExtension is ILiquidityMiningExtension {\n', '\n', '    // wallet who has control on the extension\n', '    address internal _host;\n', '\n', '    // mapping that contains all the liquidity mining contract linked to this extension\n', '    address internal _liquidityMiningContract;\n', '\n', '    // the reward token address linked to this liquidity mining contract\n', '    address internal _rewardTokenAddress;\n', '\n', '    // whether the token is by mint or by reserve\n', '    bool internal _byMint;\n', '\n', '    /** MODIFIERS */\n', '\n', '    /** @dev liquidityMiningOnly modifier used to check for unauthorized transfers. */\n', '    modifier liquidityMiningOnly() {\n', '        require(msg.sender == _liquidityMiningContract, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** @dev hostOnly modifier used to check for unauthorized edits. */\n', '    modifier hostOnly() {\n', '        require(msg.sender == _host, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** PUBLIC METHODS */\n', '\n', '    receive() external payable {\n', '        require(_liquidityMiningContract != address(0) && _rewardTokenAddress == address(0), "ETH not allowed");\n', '    }\n', '\n', '    function init(bool byMint, address host) public virtual override {\n', '        require(_liquidityMiningContract == address(0), "Already init");\n', '        _rewardTokenAddress = ILiquidityMining(_liquidityMiningContract = msg.sender)._rewardTokenAddress();\n', '        _byMint = byMint;\n', '        _host = host;\n', '    }\n', '\n', '    function setHost(address host) public virtual override hostOnly {\n', '        _host = host;\n', '    }\n', '\n', '    function data() view public virtual override returns(address liquidityMiningContract, bool byMint, address host, address rewardTokenAddress) {\n', '        return (_liquidityMiningContract, _byMint, _host, _rewardTokenAddress);\n', '    }\n', '\n', '    /** @dev transfers the input amount to the caller liquidity mining contract.\n', '      * @param amount amount of erc20 to transfer or mint.\n', '     */\n', '    function transferTo(uint256 amount, address recipient) public virtual override liquidityMiningOnly {\n', '        if(_rewardTokenAddress != address(0)) {\n', '            return _byMint ? _mintAndTransfer(_rewardTokenAddress, recipient, amount) : _safeTransfer(_rewardTokenAddress, recipient, amount);\n', '        }\n', '        payable(recipient).transfer(amount);\n', '    }\n', '\n', '    /** @dev transfers the input amount from the caller liquidity mining contract to the extension.\n', '      * @param amount amount of erc20 to transfer back or burn.\n', '     */\n', '    function backToYou(uint256 amount) payable public virtual override liquidityMiningOnly {\n', '        if(_rewardTokenAddress != address(0)) {\n', '            _safeTransferFrom(_rewardTokenAddress, msg.sender, address(this), amount);\n', '            if(_byMint) {\n', '                _burn(_rewardTokenAddress, amount);\n', '            }\n', '        } else {\n', '            require(msg.value == amount, "invalid sent amount");\n', '        }\n', '    }\n', '\n', '    /** @dev this function calls the liquidity mining contract with the given address and sets the given liquidity mining setups.\n', '      * @param liquidityMiningSetups array containing all the liquidity mining setups.\n', "      * @param setPinned if we're updating the pinned setup or not.\n", '      * @param pinnedIndex new pinned setup index.\n', '     */\n', '    function setLiquidityMiningSetups(LiquidityMiningSetupConfiguration[] memory liquidityMiningSetups, bool clearPinned, bool setPinned, uint256 pinnedIndex) public virtual override hostOnly {\n', '        ILiquidityMining(_liquidityMiningContract).setLiquidityMiningSetups(liquidityMiningSetups, clearPinned, setPinned, pinnedIndex);\n', '    }\n', '\n', '    /** INTERNAL METHODS */\n', '\n', '    function _mintAndTransfer(address erc20TokenAddress, address recipient, uint256 value) internal virtual {\n', '        IERC20Mintable(erc20TokenAddress).mint(recipient, value);\n', '    }\n', '\n', '    function _burn(address erc20TokenAddress, uint256 value) internal virtual {\n', '        IERC20Mintable(erc20TokenAddress).burn(msg.sender, value);\n', '    }\n', '\n', '    /** @dev function used to safely approve ERC20 transfers.\n', '      * @param erc20TokenAddress address of the token to approve.\n', '      * @param to receiver of the approval.\n', '      * @param value amount to approve for.\n', '     */\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    /** @dev function used to safe transfer ERC20 tokens.\n', '      * @param erc20TokenAddress address of the token to transfer.\n', '      * @param to receiver of the tokens.\n', '      * @param value amount of tokens to transfer.\n', '     */\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    /** @dev this function safely transfers the given ERC20 value from an address to another.\n', '      * @param erc20TokenAddress erc20 token address.\n', '      * @param from address from.\n', '      * @param to address to.\n', '      * @param value amount to transfer.\n', '     */\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '}']