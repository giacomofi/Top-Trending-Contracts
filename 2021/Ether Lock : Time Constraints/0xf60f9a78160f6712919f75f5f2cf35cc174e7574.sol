['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-04\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'interface IReferral {\n', '    function setReferrer(address farmer, address referrer) external;\n', '    function getReferrer(address farmer) external view returns (address);\n', '    function isValidReferrer(address referrer) external view returns (bool);\n', '    function rndSeed(uint256 rnd) external view returns (address, bool);\n', '}\n', '\n', 'contract LiquidityTransformer {\n', '    uint256 public constant SECONDS_PER_DAY = 1 days;\n', "    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '\n', '    uint256 public constant TOTAL_RESERVE_DAYS = 50;\n', '    uint256 public constant RESERVE_ETH_UNIT = 100 finney;\n', '\n', '    struct DailyState {\n', '        mapping(address => uint256) userAmount;\n', '        mapping(address => uint256) referrerAmount;\n', '        uint256 totalAmount;\n', '        uint256 userCount;\n', '    }\n', '\n', '    struct DailyConfig{\n', '        uint256 twap;\n', '        uint256 dt;\n', '    }\n', '\n', '    DailyState[TOTAL_RESERVE_DAYS] public reserveDays;\n', '    DailyConfig[TOTAL_RESERVE_DAYS] public configDays;\n', '\n', '    uint256 public totalScrap;\n', '    uint256 public launchTime;\n', '\n', '    IReferral public iReferral;\n', '    mapping(address => bool) private operator;\n', '\n', '    event Reserved(uint256 indexed day, address indexed user, address indexed referer, uint256 amount);\n', '    event Recovered(address indexed token, uint256 amount);\n', '    event Launched(uint256 time);\n', '\n', '    constructor() public {\n', '        operator[msg.sender] = true;\n', '\n', '        for (uint256 i=0; i<TOTAL_RESERVE_DAYS; i++) {\n', '            reserveDays[i] = DailyState(0,0);\n', '            configDays[i] = DailyConfig(0,0);\n', '        }\n', '    }\n', '\n', '    modifier onlyOperator{\n', '        require(operator[msg.sender]);\n', '        _;\n', '    }\n', '\n', '    function _condition(uint256 _lteDay, uint256 _lteAmount) internal view returns (bool) {\n', "        require(msg.value >= _lteAmount, 'DAO: the actual amount below LTE Amount');\n", "        require(msg.value >= RESERVE_ETH_UNIT, 'DAO: LTE Amount below minimum');\n", '\n', "        require(_lteDay < TOTAL_RESERVE_DAYS, 'DAO: incorrect LTE day');\n", '        DailyConfig memory cfg = configDays[_lteDay];\n', "        require(cfg.twap == 0, 'DAO: closed');\n", '\n', '        return true;\n', '    }\n', '\n', '    function firstReserveRand(uint256 _lteAmount, uint256 rand) external payable {\n', "        require(!iReferral.isValidReferrer(msg.sender), 'DAO: not first');\n", '        require(_condition(currentDay(), _lteAmount));\n', '\n', '        (address _referrerAddress, ) = iReferral.rndSeed(rand);\n', '        iReferral.setReferrer(msg.sender, _referrerAddress);\n', '\n', '        // use the current day as the LTE day for the first reserve\n', '        _reserve(currentDay(), msg.sender);\n', '    }\n', '\n', '    function firstReserve(uint256 _lteAmount, address _referrerAddress) external payable {\n', "        require(!iReferral.isValidReferrer(msg.sender), 'DAO: not first');\n", '        require(_condition(currentDay(), _lteAmount));\n', '\n', '        iReferral.setReferrer(msg.sender, _referrerAddress);\n', '\n', '        // use the current day as the LTE day for the first reserve\n', '        _reserve(currentDay(), msg.sender);\n', '    }\n', '\n', '    function reserve(uint256 _lteDay, uint256 _lteAmount) external payable {\n', "        require(iReferral.isValidReferrer(msg.sender), 'DAO: the caller should be a referer');\n", '        require(_condition(_lteDay, _lteAmount));\n', '\n', '        _reserve(_lteDay, msg.sender);\n', '    }\n', '\n', '    function reserveFor(uint256 _lteDay, uint256 _lteAmount, address _beneficiaryAddress) external payable {\n', "        require(iReferral.isValidReferrer(msg.sender), 'DAO: the caller should be a referer');\n", '        require(_condition(_lteDay, _lteAmount));\n', '\n', "        require(_beneficiaryAddress != address(0), 'DAO: cannot be 0');\n", '        if (!iReferral.isValidReferrer(_beneficiaryAddress)) {\n', '            iReferral.setReferrer(_beneficiaryAddress, msg.sender);\n', '        }\n', '\n', '        _reserve(_lteDay, _beneficiaryAddress);\n', '    }\n', '\n', '    function _reserve(uint256 _lteDay, address _userAddress) internal {\n', '        uint256 _scrap = msg.value % RESERVE_ETH_UNIT;\n', '        uint256 _availableAmount = msg.value - _scrap;\n', '        totalScrap += _scrap;\n', '\n', '        address _referrerAddress = iReferral.getReferrer(_userAddress);\n', '\n', '        DailyState storage day = reserveDays[_lteDay];\n', '\n', '        if (day.userAmount[_userAddress] == 0) {\n', '            day.userCount++;\n', '        }\n', '\n', '        day.userAmount[_userAddress] += _availableAmount;\n', '        day.referrerAmount[_referrerAddress] += _availableAmount;\n', '        day.totalAmount += _availableAmount;\n', '\n', '        emit Reserved(_lteDay, _userAddress, _referrerAddress, _availableAmount);\n', '    }\n', '\n', '    function userAmount(address account, uint256 day) external view returns (uint256) {\n', '        return reserveDays[day].userAmount[account];\n', '    }\n', '\n', '    function referrerAmount(address account, uint256 day) external view returns (uint256) {\n', '        return reserveDays[day].referrerAmount[account];\n', '    }\n', '\n', '    function userTotalAmount(address account) external view returns (uint256) {\n', '        uint256 _totalAmount = 0;\n', '        for(uint256 i=0; i<TOTAL_RESERVE_DAYS; i++){\n', '            _totalAmount += reserveDays[i].userAmount[account];\n', '        }\n', '        return _totalAmount;\n', '    }\n', '\n', '    function referrerTotalAmount(address account) external view returns (uint256) {\n', '        uint256 _totalAmount = 0;\n', '        for(uint256 i=0; i<TOTAL_RESERVE_DAYS; i++){\n', '            _totalAmount += reserveDays[i].referrerAmount[account];\n', '        }\n', '        return _totalAmount;\n', '    }\n', '\n', '    function currentDay() public view returns (uint256) {\n', '        return now >= launchTime ? (now - launchTime) / SECONDS_PER_DAY : 0;\n', '    }\n', '\n', '    function _safeTransfer(address token, address to, uint value) private {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'UniswapV2: TRANSFER_FAILED');\n", '    }\n', '\n', '    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOperator {\n', '        _safeTransfer(tokenAddress, msg.sender, tokenAmount);\n', '        emit Recovered(tokenAddress, tokenAmount);\n', '    }\n', '\n', '    function withdrawLTE(uint256 amount) external onlyOperator {\n', '        msg.sender.transfer(amount);\n', '    }\n', '\n', '    function launch(uint256 time) external onlyOperator {\n', '        require(launchTime == 0);\n', '        require(time >= now);\n', '        launchTime = time;\n', '\n', '        emit Launched(launchTime);\n', '    }\n', '\n', '    function update(uint256[TOTAL_RESERVE_DAYS] calldata dts) external onlyOperator {\n', '        for (uint256 i=0; i<TOTAL_RESERVE_DAYS; i++) {\n', '            configDays[i].dt = dts[i];\n', '        }\n', '    }\n', '\n', '    function twapOracle(uint256 day, uint256 twap) external onlyOperator {\n', '        require(day < TOTAL_RESERVE_DAYS);\n', '        DailyConfig storage cfg = configDays[day];\n', '        cfg.twap = twap;\n', '    }\n', '\n', '    function setReferral(address _iReferral) external onlyOperator {\n', '        require(_iReferral != address(0));\n', '        iReferral = IReferral(_iReferral);\n', '    }\n', '\n', '    function setOperator(address payable op, bool flag) external onlyOperator {\n', '        require(op != address(0));\n', "        require(op != msg.sender, '!self');\n", '        operator[op] = flag;\n', '    }\n', '}']