['pragma solidity 0.5.17;\n', '\n', '\n', '\n', 'import "./LPTokenWrapper.sol";\n', '\n', '\n', 'contract StakingPool is LPTokenWrapper, IRewardDistributionRecipient {\n', '    IERC20 public constant rewardToken = IERC20(0x1820e4eB3031D27cb30b3040DA17A7697Ee72d23);\n', '\n', '    string public desc;\n', '\n', '    uint256 public DURATION;\n', '    uint256 public starttime;\n', '\n', '    uint256 public periodFinish = 0;\n', '    uint256 public rewardRate = 0;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public rewardPerTokenStored;\n', '    mapping(address => uint256) public userRewardPerTokenPaid;\n', '    mapping(address => uint256) public rewards;\n', '\n', '    event RewardAdded(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '\n', '    constructor(address _lpToken, string memory _desc, uint256 _starttime) public LPTokenWrapper(_lpToken) {\n', '        rewardDistribution = msg.sender;\n', '        desc = _desc;\n', '        starttime = _starttime;\n', '    }\n', '\n', '    function setStartTime(uint256 _starttime) external onlyOwner {\n', '        require(block.timestamp < starttime, "started");\n', '        starttime = _starttime;\n', '    }\n', '\n', '    modifier checkStart(){\n', '        require(block.timestamp >= starttime, "not started");\n', '        _;\n', '    }\n', '\n', '    modifier updateReward(address account) {\n', '        rewardPerTokenStored = rewardPerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '        if (account != address(0)) {\n', '            rewards[account] = earned(account);\n', '            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n', '        }\n', '        _;\n', '    }\n', '\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint256) {\n', '        return Math.min(block.timestamp, periodFinish);\n', '    }\n', '\n', '    function rewardPerToken() public view returns (uint256) {\n', '        if (totalSupply() == 0) {\n', '            return rewardPerTokenStored;\n', '        }\n', '        return\n', '            rewardPerTokenStored.add(\n', '                lastTimeRewardApplicable()\n', '                    .sub(lastUpdateTime)\n', '                    .mul(rewardRate)\n', '                    .mul(1e18)\n', '                    .div(totalSupply())\n', '            );\n', '    }\n', '\n', '    function earned(address account) public view returns (uint256) {\n', '        return\n', '            balanceOf(account)\n', '                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n', '                .div(1e18)\n', '                .add(rewards[account]);\n', '    }\n', '\n', '    function stake(uint256 amount) public updateReward(msg.sender) checkStart {\n', '        require(amount > 0, "Cannot stake 0");\n', '        super.stake(amount);\n', '        emit Staked(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint256 amount) public updateReward(msg.sender) checkStart {\n', '        require(amount > 0, "Cannot withdraw 0");\n', '        super.withdraw(amount);\n', '        emit Withdrawn(msg.sender, amount);\n', '    }\n', '\n', '    function exit() external {\n', '        withdraw(balanceOf(msg.sender));\n', '        getReward();\n', '    }\n', '\n', '    function getReward() public updateReward(msg.sender) checkStart {\n', '        uint256 reward = earned(msg.sender);\n', '        if (reward > 0) {\n', '            rewards[msg.sender] = 0;\n', '            rewardToken.safeTransfer(msg.sender, reward);\n', '            emit RewardPaid(msg.sender, reward);\n', '        }\n', '    }\n', '\n', '    function notifyRewardAmount(uint256 _reward, uint256 _duration) external onlyRewardDistribution updateReward(address(0)) {\n', '        require(_duration != 0, "Duration must not be 0");\n', '        require(_reward != 0, "Reward must not be 0");\n', '\n', '        rewardToken.safeTransferFrom(msg.sender, address(this), _reward);\n', '        DURATION = _duration;\n', '        if (block.timestamp > starttime) {\n', '            if (block.timestamp >= periodFinish) {\n', '                rewardRate = _reward.div(_duration);\n', '            } else {\n', '                uint256 remaining = periodFinish.sub(block.timestamp);\n', '                uint256 leftover = remaining.mul(rewardRate);\n', '                rewardRate = _reward.add(leftover).div(_duration);\n', '            }\n', '            lastUpdateTime = block.timestamp;\n', '            periodFinish = block.timestamp.add(_duration);\n', '            emit RewardAdded(_reward);\n', '        } else {\n', '            rewardRate = _reward.div(_duration);\n', '            lastUpdateTime = starttime;\n', '            periodFinish = starttime.add(_duration);\n', '            emit RewardAdded(_reward);\n', '        }\n', '    }\n', '}']