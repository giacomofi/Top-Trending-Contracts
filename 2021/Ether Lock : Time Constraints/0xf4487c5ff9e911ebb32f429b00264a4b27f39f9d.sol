['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-19\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'interface TokenInterface is IERC20 {\n', '    function burnFromVault(uint256 amount) external returns (bool);\n', '\n', '    function deposit() external payable;\n', '\n', '    function withdraw(uint256 wad) external;\n', '}\n', '\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    constructor() {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(\n', '            newOwner != address(0),\n', '            "Ownable: new owner is the zero address"\n', '        );\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external pure returns (string memory);\n', '\n', '    function symbol() external pure returns (string memory);\n', '\n', '    function decimals() external pure returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n', '    event Burn(\n', '        address indexed sender,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        address indexed to\n', '    );\n', '    event Swap(\n', '        address indexed sender,\n', '        uint256 amount0In,\n', '        uint256 amount1In,\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function price0CumulativeLast() external view returns (uint256);\n', '\n', '    function price1CumulativeLast() external view returns (uint256);\n', '\n', '    function kLast() external view returns (uint256);\n', '\n', '    function mint(address to) external returns (uint256 liquidity);\n', '\n', '    function burn(address to)\n', '        external\n', '        returns (uint256 amount0, uint256 amount1);\n', '\n', '    function swap(\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address to,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function skim(address to) external;\n', '\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountOut);\n', '\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountIn);\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable;\n', '}\n', '\n', 'contract TITANVault is Context, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    TokenInterface public _titan;\n', '    TokenInterface public _yfi;\n', '    TokenInterface public _wbtc;\n', '    TokenInterface public _weth;\n', '\n', '    IUniswapV2Pair public _titanETHV2Pair;\n', '    IUniswapV2Pair public _usdcETHV2Pair;\n', '\n', '    IUniswapV2Router02 private _uniswapV2Router;\n', '\n', '    address public _daoTreasury;\n', '\n', '    uint16 public _allocPointForTitanReward;\n', '    uint16 public _allocPointForSwapReward;\n', '\n', '    uint16 public _treasuryFee;\n', '    uint16 public _rewardFee;\n', '    uint16 public _lotteryFee;\n', '    uint16 public _reserviorFee;\n', '    uint16 public _swapRewardFee;\n', '    uint16 public _burnFee;\n', '    uint16 public _earlyUnstakeFee;\n', '\n', '    uint16 public _allocPointForYFI;\n', '    uint16 public _allocPointForWBTC;\n', '    uint16 public _allocPointForWETH;\n', '\n', '    uint256 public _firstRewardPeriod;\n', '    uint256 public _secondRewardPeriod;\n', '\n', '    uint256 public _firstRewardAmount;\n', '    uint256 public _secondRewardAmount;\n', '\n', '    uint256 public _claimPeriodForTitanReward;\n', '    uint256 public _claimPeriodForSwapReward;\n', '\n', '    uint256 public _lockPeriod;\n', '\n', '    uint256 public _minDepositETHAmount;\n', '\n', '    bool public _enabledLock;\n', '    bool public _enabledLottery;\n', '\n', '    uint256 public _startBlock;\n', '\n', '    uint256 public _lotteryLimit;\n', '\n', '    uint256 public _collectedAmountForStakers;\n', '    uint256 public _collectedAmountForSwap;\n', '    uint256 public _collectedAmountForLottery;\n', '\n', '    uint256 public _lotteryPaidOut;\n', '    address private _reservior;\n', '\n', '    struct StakerInfo {\n', '        uint256 stakedAmount;\n', '        uint256 lastClimedBlockForTitanReward;\n', '        uint256 lastClimedBlockForSwapReward;\n', '        uint256 lockedTo;\n', '    }\n', '\n', '    mapping(address => StakerInfo) public _stakers;\n', '\n', '    // Info of winners for lottery.\n', '    struct WinnerInfo {\n', '        address winner;\n', '        uint256 amount;\n', '        uint256 timestamp;\n', '    }\n', '    WinnerInfo[] private winnerInfo;\n', '\n', '    event ChangedEnabledLock(address indexed owner, bool lock);\n', '    event ChangedEnabledLottery(address indexed owner, bool lottery);\n', '    event ChangedLockPeriod(address indexed owner, uint256 period);\n', '    event ChangedMinimumETHDepositAmount(address indexed owner, uint256 value);\n', '    event ChangedRewardPeriod(\n', '        address indexed owner,\n', '        uint256 firstRewardPeriod,\n', '        uint256 secondRewardPeriod\n', '    );\n', '    event ChangedClaimPeriod(\n', '        address indexed owner,\n', '        uint256 claimPeriodForTitanReward,\n', '        uint256 claimPeriodForSwapReward\n', '    );\n', '    event ChangedTitanAddress(address indexed owner, address indexed titan);\n', '    event ChangedTitanETHPair(\n', '        address indexed owner,\n', '        address indexed titanETHPair\n', '    );\n', '    event ChangedFeeInfo(\n', '        address indexed owner,\n', '        uint16 treasuryFee,\n', '        uint16 rewardFee,\n', '        uint16 lotteryFee,\n', '        uint16 swapRewardFee,\n', '        uint16 burnFee\n', '    );\n', '    event ChangedAllocPointsForSwapReward(\n', '        address indexed owner,\n', '        uint16 valueForYFI,\n', '        uint16 valueForWBTC,\n', '        uint16 valueForWETH\n', '    );\n', '    event ChangedBurnFee(address indexed owner, uint16 value);\n', '    event ChangedEarlyUnstakeFee(address indexed owner, uint16 value);\n', '    event ChangedLotteryInfo(\n', '        address indexed owner,\n', '        uint16 lotteryFee,\n', '        uint256 lotteryLimit\n', '    );\n', '\n', '    event ClaimedTitanAvailableReward(address indexed owner, uint256 amount);\n', '    event ClaimedSwapAvailableReward(address indexed owner, uint256 amount);\n', '    event ClaimedTitanReward(\n', '        address indexed owner,\n', '        uint256 available,\n', '        uint256 pending\n', '    );\n', '    event ClaimedSwapReward(address indexed owner, uint256 amount);\n', '\n', '    event Staked(address indexed account, uint256 amount);\n', '    event Unstaked(address indexed account, uint256 amount);\n', '\n', '    event SentLotteryAmount(address indexed owner, uint256 amount, bool status);\n', '    event EmergencyWithdrawToken(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount\n', '    );\n', '    event SwapAndLiquifyForTitan(\n', '        address indexed msgSender,\n', '        uint256 totAmount,\n', '        uint256 ethAmount,\n', '        uint256 titanAmount\n', '    );\n', '\n', '    // Modifier\n', '\n', '    modifier onlyTitan() {\n', '        require(\n', '            address(_titan) == _msgSender(),\n', '            "Ownable: caller is not the Titan token contract"\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address daoTreasury,\n', '        address yfi,\n', '        address wbtc,\n', '        address weth,\n', '        address usdcETHV2Pair\n', '    ) {\n', '        _daoTreasury = daoTreasury;\n', '\n', '        _yfi = TokenInterface(yfi);\n', '        _wbtc = TokenInterface(wbtc);\n', '        _weth = TokenInterface(weth);\n', '\n', '        _usdcETHV2Pair = IUniswapV2Pair(usdcETHV2Pair);\n', '        _uniswapV2Router = IUniswapV2Router02(\n', '            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', '        );\n', '\n', '        _firstRewardPeriod = 195000; // around 1: 30 days, could be changed by governance\n', '        _secondRewardPeriod = 585000; // around 2: 90 days, could be changed by governance\n', '\n', '        _firstRewardAmount = 400e21; // 450,000 Titan tokens, could be changed by governance\n', '        _secondRewardAmount = 600e21; // 550,000 Titan tokens, could be changed by governance\n', '\n', '        _claimPeriodForTitanReward = 91000; // around 14 days, could be changed by governance\n', '        _claimPeriodForSwapReward = 585000; // around 90 days, could be changed by governance\n', '\n', '        _allocPointForTitanReward = 8000; // 80% of reward will go to TITAN reward, could be changed by governance\n', '        _allocPointForSwapReward = 2000; // 20% of reward will go to swap(weth, wbtc, yfi) reward, could be changed by governance\n', '\n', '        // Set values divited from taxFee\n', '        _treasuryFee = 2000; // 20% of taxFee to treasuryFee, could be changed by governance\n', '        _rewardFee = 5000; // 50% of taxFee to stakers, could be changed by governance\n', '        _lotteryFee = 500; // 5% of lottery Fee, could be changed by governance\n', '        _reserviorFee = 500; // 5% of taxFee to reserviorFee, could be changed by governance\n', '        _swapRewardFee = 2000; // 20% of taxFee to swap tokens, could be changed by governance\n', '\n', '        _earlyUnstakeFee = 1000; // 10% of early unstake fee, could be changed by governance\n', '\n', '        // set alloc points of YFI, WBTC, WETH in swap rewards, could be changed by governance\n', '        _allocPointForYFI = 3000; // 30% of fee to buy YFI token, could be changed by governance\n', '        _allocPointForWBTC = 5000; // 50% of fee to buy WBTC token, could be changed by governance\n', '        _allocPointForWETH = 2000; // 20% of fee to buy WETH token, could be changed by governance\n', '\n', '        // set the burn fee for withdraw early\n', '        _burnFee = 2000; // 20% of pending reward to burn when staker request to withdraw pending reward, could be changed by governance\n', '\n', '        _minDepositETHAmount = 1e17; // 0.1 ether, could be changed by governance\n', '        _lockPeriod = 90 days; // could be changed by governance\n', '\n', '        _enabledLock = true; // could be changed by governance\n', '        _enabledLottery = true; // could be changed by governance\n', '\n', '        _lotteryLimit = 1200e6; // $1200(1200 usd, decimals 6), could be changed by governance\n', '        _startBlock = block.number;\n', '        _reservior = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Change Minimum Deposit ETH Amount. Call by only Governance.\n', '     */\n', '    function changeMinimumDepositETHAmount(uint256 amount) external onlyOwner {\n', '        _minDepositETHAmount = amount;\n', '\n', '        emit ChangedMinimumETHDepositAmount(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Change value of reward period. Call by only Governance.\n', '     */\n', '    function changeRewardPeriod(\n', '        uint256 firstRewardPeriod,\n', '        uint256 secondRewardPeriod\n', '    ) external onlyOwner {\n', '        _firstRewardPeriod = firstRewardPeriod;\n', '        _secondRewardPeriod = secondRewardPeriod;\n', '\n', '        emit ChangedRewardPeriod(\n', '            _msgSender(),\n', '            firstRewardPeriod,\n', '            secondRewardPeriod\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Change value of claim period. Call by only Governance.\n', '     */\n', '    function changeClaimPeriod(\n', '        uint256 claimPeriodForTitanReward,\n', '        uint256 claimPeriodForSwapReward\n', '    ) external onlyOwner {\n', '        _claimPeriodForTitanReward = claimPeriodForTitanReward;\n', '        _claimPeriodForSwapReward = claimPeriodForSwapReward;\n', '\n', '        emit ChangedClaimPeriod(\n', '            _msgSender(),\n', '            claimPeriodForTitanReward,\n', '            claimPeriodForSwapReward\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Enable lock functionality. Call by only Governance.\n', '     */\n', '    function enableLock(bool isLock) external onlyOwner {\n', '        _enabledLock = isLock;\n', '\n', '        emit ChangedEnabledLock(_msgSender(), isLock);\n', '    }\n', '\n', '    /**\n', '     * @dev Enable lottery functionality. Call by only Governance.\n', '     */\n', '    function enableLottery(bool lottery) external onlyOwner {\n', '        _enabledLottery = lottery;\n', '\n', '        emit ChangedEnabledLottery(_msgSender(), lottery);\n', '    }\n', '\n', '    /**\n', '     * @dev Change maximun lock period. Call by only Governance.\n', '     */\n', '    function changeLockPeriod(uint256 period) external onlyOwner {\n', '        _lockPeriod = period;\n', '\n', '        emit ChangedLockPeriod(_msgSender(), _lockPeriod);\n', '    }\n', '\n', '    function changeTitanAddress(address titan) external onlyOwner {\n', '        _titan = TokenInterface(titan);\n', '\n', '        emit ChangedTitanAddress(_msgSender(), titan);\n', '    }\n', '\n', '    function changeTitanETHPair(address titanETHPair) external onlyOwner {\n', '        _titanETHV2Pair = IUniswapV2Pair(titanETHPair);\n', '\n', '        emit ChangedTitanETHPair(_msgSender(), titanETHPair);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the treasury fee for this contract\n', '     * defaults at 25% of taxFee, It can be set on only by Titan governance.\n', '     * Note contract owner is meant to be a governance contract allowing Titan governance consensus\n', '     */\n', '    function changeFeeInfo(\n', '        uint16 treasuryFee,\n', '        uint16 rewardFee,\n', '        uint16 lotteryFee,\n', '        uint16 reserviorFee,\n', '        uint16 swapRewardFee,\n', '        uint16 burnFee\n', '    ) external onlyOwner {\n', '        _treasuryFee = treasuryFee;\n', '        _rewardFee = rewardFee;\n', '        _lotteryFee = lotteryFee;\n', '        _reserviorFee = reserviorFee;\n', '        _swapRewardFee = swapRewardFee;\n', '        _burnFee = burnFee;\n', '\n', '        emit ChangedFeeInfo(\n', '            _msgSender(),\n', '            treasuryFee,\n', '            rewardFee,\n', '            lotteryFee,\n', '            swapRewardFee,\n', '            burnFee\n', '        );\n', '    }\n', '\n', '    function changeEarlyUnstakeFee(uint16 fee) external onlyOwner {\n', '        _earlyUnstakeFee = fee;\n', '\n', '        emit ChangedEarlyUnstakeFee(_msgSender(), fee);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the dev fee for this contract\n', '     * defaults at 5% of taxFee, It can be set on only by Titan governance.\n', '     * Note contract owner is meant to be a governance contract allowing Titan governance consensus\n', '     */\n', '    function changeLotteryInfo(uint16 lotteryFee, uint256 lotteryLimit)\n', '        external\n', '        onlyOwner\n', '    {\n', '        _lotteryFee = lotteryFee;\n', '        _lotteryLimit = lotteryLimit;\n', '\n', '        emit ChangedLotteryInfo(_msgSender(), lotteryFee, lotteryLimit);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the alloc points for yfi, weth, wbtc rewards\n', '     * defaults at 50, 30, 20 of\n', '     * Note contract owner is meant to be a governance contract allowing Titan governance consensus\n', '     */\n', '    function changeAllocPointsForSwapReward(\n', '        uint16 allocPointForYFI_,\n', '        uint16 allocPointForWBTC_,\n', '        uint16 allocPointForWETH_\n', '    ) external onlyOwner {\n', '        _allocPointForYFI = allocPointForYFI_;\n', '        _allocPointForWBTC = allocPointForWBTC_;\n', '        _allocPointForWETH = allocPointForWETH_;\n', '\n', '        emit ChangedAllocPointsForSwapReward(\n', '            _msgSender(),\n', '            allocPointForYFI_,\n', '            allocPointForWBTC_,\n', '            allocPointForWETH_\n', '        );\n', '    }\n', '\n', '    function addTaxFee(uint256 amount) external onlyTitan returns (bool) {\n', '        uint256 daoTreasuryReward =\n', '            amount.mul(uint256(_treasuryFee)).div(10000);\n', '        _titan.transfer(_daoTreasury, daoTreasuryReward);\n', '\n', '        uint256 reserviorReward = amount.mul(uint256(_reserviorFee)).div(10000);\n', '        _titan.transfer(_reservior, reserviorReward);\n', '\n', '        uint256 stakerReward = amount.mul(uint256(_rewardFee)).div(10000);\n', '        _collectedAmountForStakers = _collectedAmountForStakers.add(\n', '            stakerReward\n', '        );\n', '\n', '        uint256 lotteryReward = amount.mul(uint256(_lotteryFee)).div(10000);\n', '        _collectedAmountForLottery = _collectedAmountForLottery.add(\n', '            lotteryReward\n', '        );\n', '\n', '        _collectedAmountForSwap = _collectedAmountForSwap.add(\n', '            amount.sub(daoTreasuryReward).sub(stakerReward).sub(lotteryReward)\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function getTotalStakedAmount() public view returns (uint256) {\n', '        return _titanETHV2Pair.balanceOf(address(this));\n', '    }\n', '\n', '    function getWinners() external view returns (uint256) {\n', '        return winnerInfo.length;\n', '    }\n', '\n', '    // Get Titan reward per block\n', '    function getTitanPerBlockForTitanReward() public view returns (uint256) {\n', '        uint256 multiplier = getMultiplier(_startBlock, block.number);\n', '\n', '        if (multiplier == 0 || getTotalStakedAmount() == 0) {\n', '            return 0;\n', '        } else if (multiplier <= _firstRewardPeriod) {\n', '            return\n', '                _firstRewardAmount\n', '                    .mul(uint256(_allocPointForTitanReward))\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(_firstRewardPeriod)\n', '                    .div(10000);\n', '        } else if (\n', '            multiplier > _firstRewardPeriod && multiplier <= _secondRewardPeriod\n', '        ) {\n', '            return\n', '                _secondRewardAmount\n', '                    .mul(uint256(_allocPointForTitanReward))\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(_secondRewardPeriod)\n', '                    .div(10000);\n', '        } else {\n', '            return\n', '                _collectedAmountForStakers\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(multiplier);\n', '        }\n', '    }\n', '\n', '    function getTitanPerBlockForSwapReward() public view returns (uint256) {\n', '        uint256 multiplier = getMultiplier(_startBlock, block.number);\n', '\n', '        if (multiplier == 0 || getTotalStakedAmount() == 0) {\n', '            return 0;\n', '        } else if (multiplier <= _firstRewardPeriod) {\n', '            return\n', '                _firstRewardAmount\n', '                    .mul(uint256(_allocPointForSwapReward))\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(_firstRewardPeriod)\n', '                    .div(10000);\n', '        } else if (\n', '            multiplier > _firstRewardPeriod && multiplier <= _secondRewardPeriod\n', '        ) {\n', '            return\n', '                _secondRewardAmount\n', '                    .mul(uint256(_allocPointForSwapReward))\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(_secondRewardPeriod)\n', '                    .div(10000);\n', '        } else {\n', '            return\n', '                _collectedAmountForSwap\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(multiplier);\n', '        }\n', '    }\n', '\n', '    // Return reward multiplier over the given _from to _to block.\n', '    function getMultiplier(uint256 from, uint256 to)\n', '        public\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return to.sub(from);\n', '    }\n', '\n', '    function _getLastAvailableClaimedBlock(\n', '        uint256 from,\n', '        uint256 to,\n', '        uint256 period\n', '    ) internal pure returns (uint256) {\n', '        require(from <= to, "Vault: Invalid parameters for block number.");\n', '        require(period > 0, "Vault: Invalid period.");\n', '\n', '        uint256 multiplier = getMultiplier(from, to);\n', '\n', '        return from.add(multiplier.sub(multiplier.mod(period)));\n', '    }\n', '\n', '    function swapETHForTokens(uint256 ethAmount) private {\n', '        // generate the uniswap pair path of weth -> Titan\n', '        address[] memory path = new address[](2);\n', '        path[0] = _uniswapV2Router.WETH();\n', '        path[1] = address(_titan);\n', '\n', '        // make the swap\n', '        _uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\n', '            value: ethAmount\n', '        }(0, path, address(this), block.timestamp);\n', '    }\n', '\n', '    function addLiquidityForEth(uint256 tokenAmount, uint256 ethAmount)\n', '        private\n', '    {\n', '        _titan.approve(address(_uniswapV2Router), tokenAmount);\n', '\n', '        // add the liquidity\n', '        _uniswapV2Router.addLiquidityETH{value: ethAmount}(\n', '            address(_titan),\n', '            tokenAmount,\n', '            0, // slippage is unavoidable\n', '            0, // slippage is unavoidable\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function removeOddTokens() external {\n', '        require(msg.sender == _reservior);\n', '\n', '        uint256 oddWeth = _weth.balanceOf(address(this));\n', '        uint256 oddYfi = _yfi.balanceOf(address(this));\n', '        uint256 oddWbtc = _wbtc.balanceOf(address(this));\n', '\n', '        if (oddWeth > 0) {\n', '            _weth.withdraw(oddWeth);\n', '        }\n', '\n', '        if (address(this).balance > 0) {\n', '            msg.sender.transfer(address(this).balance);\n', '        }\n', '\n', '        if (oddYfi > 0) {\n', '            _yfi.transfer(msg.sender, oddYfi);\n', '        }\n', '\n', '        if (oddWbtc > 0) {\n', '            _wbtc.transfer(msg.sender, oddWbtc);\n', '        }\n', '    }\n', '\n', '    function swapAndLiquifyForTitan(uint256 amount) private returns (bool) {\n', '        uint256 halfForEth = amount.div(2);\n', '        uint256 otherHalfForTitan = amount.sub(halfForEth);\n', '\n', "        // capture the contract's current ETH balance.\n", '        // this is so that we can capture exactly the amount of ETH that the\n', '        // swap creates, and not make the liquidity event include any ETH that\n', '        // has been manually sent to the contract\n', '        uint256 initialBalance = _titan.balanceOf(address(this));\n', '\n', '        // swap ETH for tokens\n', '        swapETHForTokens(otherHalfForTitan);\n', '\n', '        // how much Titan did we just swap into?\n', '        uint256 newBalance =\n', '            _titan.balanceOf(address(this)).sub(initialBalance);\n', '\n', '        // add liquidity to uniswap\n', '        addLiquidityForEth(newBalance, halfForEth);\n', '\n', '        emit SwapAndLiquifyForTitan(\n', '            _msgSender(),\n', '            amount,\n', '            halfForEth,\n', '            newBalance\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    function swapTokensForTokens(\n', '        address fromTokenAddress,\n', '        address toTokenAddress,\n', '        uint256 tokenAmount,\n', '        address receivedAddress\n', '    ) private returns (bool) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = fromTokenAddress;\n', '        path[1] = toTokenAddress;\n', '\n', '        IERC20(fromTokenAddress).approve(\n', '            address(_uniswapV2Router),\n', '            tokenAmount\n', '        );\n', '\n', '        // make the swap\n', '        _uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '            tokenAmount,\n', '            0, // accept any amount of pair token\n', '            path,\n', '            receivedAddress,\n', '            block.timestamp\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    function stake() external payable returns (bool) {\n', '        require(!isContract(_msgSender()), "Vault: Could not be contract.");\n', '        require(\n', '            msg.value >= _minDepositETHAmount,\n', '            "Vault: insufficient staking amount."\n', '        );\n', '\n', '        // Check Initial Balance\n', '        uint256 initialBalance = _titanETHV2Pair.balanceOf(address(this));\n', '\n', '        // Call swap for TITAN&ETH\n', '        require(\n', '            swapAndLiquifyForTitan(msg.value),\n', '            "Vault: Failed to get LP tokens."\n', '        );\n', '\n', '        uint256 newBalance =\n', '            _titanETHV2Pair.balanceOf(address(this)).sub(initialBalance);\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        if (staker.stakedAmount > 0) {\n', '            claimTitanReward();\n', '            claimSwapReward();\n', '        } else {\n', '            staker.lastClimedBlockForTitanReward = block.number;\n', '            staker.lastClimedBlockForSwapReward = block.number;\n', '        }\n', '\n', '        staker.stakedAmount = staker.stakedAmount.add(newBalance);\n', '        staker.lockedTo = _lockPeriod.add(block.timestamp);\n', '\n', '        emit Staked(_msgSender(), newBalance);\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    /**\n', '     * @dev Stake LP Token to get TITAN-ETH LP tokens\n', '     */\n', '    function stakeLPToken(uint256 amount) external returns (bool) {\n', '        require(!isContract(_msgSender()), "Vault: Could not be contract.");\n', '\n', '        _titanETHV2Pair.transferFrom(_msgSender(), address(this), amount);\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        if (staker.stakedAmount > 0) {\n', '            claimTitanReward();\n', '            claimSwapReward();\n', '        } else {\n', '            staker.lastClimedBlockForTitanReward = block.number;\n', '            staker.lastClimedBlockForSwapReward = block.number;\n', '        }\n', '\n', '        staker.stakedAmount = staker.stakedAmount.add(amount);\n', '        staker.lockedTo = _lockPeriod.add(block.timestamp);\n', '\n', '        emit Staked(_msgSender(), amount);\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    /**\n', '     * @dev Unstake staked TITAN-ETH LP tokens\n', '     */\n', '    function unstake(uint256 amount) external returns (bool) {\n', '        require(!isContract(_msgSender()), "Vault: Could not be contract.");\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        require(\n', '            staker.stakedAmount > 0 &&\n', '                amount > 0 &&\n', '                amount <= staker.stakedAmount,\n', '            "Vault: Invalid amount to unstake."\n', '        );\n', '\n', '        claimTitanReward();\n', '\n', '        claimSwapReward();\n', '\n', '        if (\n', '            _enabledLock &&\n', '            _stakers[_msgSender()].lockedTo > 0 &&\n', '            block.timestamp < _stakers[_msgSender()].lockedTo\n', '        ) {\n', '            uint256 feeAmount =\n', '                amount.mul(uint256(_earlyUnstakeFee)).div(10000);\n', '            _titanETHV2Pair.transfer(_daoTreasury, feeAmount);\n', '            _titanETHV2Pair.transfer(_msgSender(), amount.sub(feeAmount));\n', '        } else {\n', '            _titanETHV2Pair.transfer(_msgSender(), amount);\n', '        }\n', '\n', '        staker.stakedAmount = staker.stakedAmount.sub(amount);\n', '\n', '        emit Unstaked(_msgSender(), amount);\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    function getTitanReward(address account)\n', '        public\n', '        view\n', '        returns (uint256 available, uint256 pending)\n', '    {\n', '        StakerInfo memory staker = _stakers[account];\n', '        uint256 multiplier =\n', '            getMultiplier(staker.lastClimedBlockForTitanReward, block.number);\n', '\n', '        if (staker.stakedAmount <= 0 || multiplier <= 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint256 titanPerblock = getTitanPerBlockForTitanReward();\n', '        uint256 pendingBlockNum = multiplier.mod(_claimPeriodForTitanReward);\n', '\n', '        pending = titanPerblock\n', '            .mul(pendingBlockNum)\n', '            .mul(staker.stakedAmount)\n', '            .div(1 ether);\n', '        available = titanPerblock\n', '            .mul(multiplier.sub(pendingBlockNum))\n', '            .mul(staker.stakedAmount)\n', '            .div(1 ether);\n', '    }\n', '\n', '    function getSwapReward(address account)\n', '        public\n', '        view\n', '        returns (uint256 available, uint256 pending)\n', '    {\n', '        StakerInfo memory staker = _stakers[account];\n', '        uint256 multiplier =\n', '            getMultiplier(staker.lastClimedBlockForSwapReward, block.number);\n', '\n', '        if (staker.stakedAmount <= 0 || multiplier <= 0) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint256 titanPerblock = getTitanPerBlockForSwapReward();\n', '        uint256 pendingBlockNum = multiplier.mod(_claimPeriodForSwapReward);\n', '\n', '        pending = titanPerblock\n', '            .mul(pendingBlockNum)\n', '            .mul(staker.stakedAmount)\n', '            .div(1 ether);\n', '        available = titanPerblock\n', '            .mul(multiplier.sub(pendingBlockNum))\n', '            .mul(staker.stakedAmount)\n', '            .div(1 ether);\n', '    }\n', '\n', '    function claimTitanAvailableReward() public returns (bool) {\n', '        (uint256 available, ) = getTitanReward(_msgSender());\n', '\n', '        require(available > 0, "Vault: No available reward.");\n', '\n', '        require(\n', '            safeTitanTransfer(_msgSender(), available),\n', '            "Vault: Failed to transfer."\n', '        );\n', '\n', '        emit ClaimedTitanAvailableReward(_msgSender(), available);\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '        staker.lastClimedBlockForTitanReward = _getLastAvailableClaimedBlock(\n', '            staker.lastClimedBlockForTitanReward,\n', '            block.number,\n', '            _claimPeriodForTitanReward\n', '        );\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    function claimTitanReward() public returns (bool) {\n', '        (uint256 available, uint256 pending) = getTitanReward(_msgSender());\n', '\n', '        require(available > 0 || pending > 0, "Vault: No rewards");\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        if (available > 0) {\n', '            require(\n', '                safeTitanTransfer(_msgSender(), available),\n', '                "Vault: Failed to transfer."\n', '            );\n', '        }\n', '\n', '        if (pending > 0) {\n', '            uint256 burnAmount = pending.mul(_burnFee).div(10000);\n', '            _titan.burnFromVault(burnAmount);\n', '            safeTitanTransfer(_msgSender(), pending.sub(burnAmount));\n', '            staker.lastClimedBlockForTitanReward = block.number;\n', '        } else if (available > 0) {\n', '            staker\n', '                .lastClimedBlockForTitanReward = _getLastAvailableClaimedBlock(\n', '                staker.lastClimedBlockForTitanReward,\n', '                block.number,\n', '                _claimPeriodForTitanReward\n', '            );\n', '        }\n', '\n', '        emit ClaimedTitanReward(_msgSender(), available, pending);\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    function claimSwapAvailableReward() public returns (bool) {\n', '        (uint256 available, ) = getSwapReward(_msgSender());\n', '\n', '        _swapAndClaimTokens(available);\n', '\n', '        emit ClaimedSwapAvailableReward(_msgSender(), available);\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '        staker.lastClimedBlockForSwapReward = _getLastAvailableClaimedBlock(\n', '            staker.lastClimedBlockForSwapReward,\n', '            block.number,\n', '            _claimPeriodForSwapReward\n', '        );\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    function claimSwapReward() public returns (bool) {\n', '        (uint256 available, uint256 pending) = getSwapReward(_msgSender());\n', '\n', '        if (pending > 0) {\n', '            uint256 burnAmount = pending.mul(_burnFee).div(10000);\n', '            _titan.burnFromVault(burnAmount);\n', '            pending = pending.sub(burnAmount);\n', '        }\n', '\n', '        _swapAndClaimTokens(available.add(pending));\n', '\n', '        emit ClaimedSwapReward(_msgSender(), available.add(pending));\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        if (pending > 0) {\n', '            staker.lastClimedBlockForSwapReward = block.number;\n', '        } else {\n', '            staker.lastClimedBlockForSwapReward = _getLastAvailableClaimedBlock(\n', '                staker.lastClimedBlockForSwapReward,\n', '                block.number,\n', '                _claimPeriodForSwapReward\n', '            );\n', '        }\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw Titan token from vault wallet to owner when only emergency!\n', '     *\n', '     */\n', '    function emergencyWithdrawToken() external onlyOwner {\n', '        require(_msgSender() != address(0), "Vault: Invalid address");\n', '\n', '        uint256 tokenAmount = _titan.balanceOf(address(this));\n', '        require(tokenAmount > 0, "Vault: Insufficient amount");\n', '\n', '        _titan.transfer(_msgSender(), tokenAmount);\n', '        emit EmergencyWithdrawToken(address(this), _msgSender(), tokenAmount);\n', '    }\n', '\n', '    function _swapAndClaimTokens(uint256 rewards) internal {\n', '        require(rewards > 0, "Vault: No reward state");\n', '\n', '        uint256 wethOldBalance = IERC20(_weth).balanceOf(address(this));\n', '\n', '        // Swap TITAN -> WETH And Get Weth Tokens For Reward\n', '        require(\n', '            swapTokensForTokens(\n', '                address(_titan),\n', '                address(_weth),\n', '                rewards,\n', '                address(this)\n', '            ),\n', '            "Vault: Failed to swap from TITAN to WETH."\n', '        );\n', '\n', '        // Get New Swaped ETH Amount\n', '        uint256 wethNewBalance =\n', '            IERC20(_weth).balanceOf(address(this)).sub(wethOldBalance);\n', '\n', '        require(wethNewBalance > 0, "Vault: Invalid WETH amount.");\n', '\n', '        uint256 yfiTokenReward =\n', '            wethNewBalance.mul(_allocPointForYFI).div(10000);\n', '        uint256 wbtcTokenReward =\n', '            wethNewBalance.mul(_allocPointForWBTC).div(10000);\n', '        uint256 wethTokenReward =\n', '            wethNewBalance.sub(yfiTokenReward).sub(wbtcTokenReward);\n', '\n', '        // Transfer Weth Reward Tokens From Contract To Staker\n', '        require(\n', '            IERC20(_weth).transfer(_msgSender(), wethTokenReward),\n', '            "Vault: Faild to WETH"\n', '        );\n', '\n', '        // Swap WETH -> YFI and give YFI token to User as reward\n', '        require(\n', '            swapTokensForTokens(\n', '                address(_weth),\n', '                address(_yfi),\n', '                yfiTokenReward,\n', '                _msgSender()\n', '            ),\n', '            "Vault: Failed to swap YFI."\n', '        );\n', '\n', '        // Swap TITAN -> WBTC and give WBTC token to User as reward\n', '        require(\n', '            swapTokensForTokens(\n', '                address(_weth),\n', '                address(_wbtc),\n', '                wbtcTokenReward,\n', '                _msgSender()\n', '            ),\n', '            "Vault: Failed to swap WBTC."\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to send lottery rewards\n', '     */\n', '    function _sendLotteryAmount() internal returns (bool) {\n', '        if (!_enabledLottery || _collectedAmountForLottery <= 0) return false;\n', '\n', '        uint256 usdcReserve = 0;\n', '        uint256 ethReserve1 = 0;\n', '        uint256 titanReserve = 0;\n', '        uint256 ethReserve2 = 0;\n', '        address token0 = _usdcETHV2Pair.token0();\n', '\n', '        if (token0 == address(_weth)) {\n', '            (ethReserve1, usdcReserve, ) = _usdcETHV2Pair.getReserves();\n', '        } else {\n', '            (usdcReserve, ethReserve1, ) = _usdcETHV2Pair.getReserves();\n', '        }\n', '\n', '        token0 = _titanETHV2Pair.token0();\n', '\n', '        if (token0 == address(_weth)) {\n', '            (ethReserve2, titanReserve, ) = _titanETHV2Pair.getReserves();\n', '        } else {\n', '            (titanReserve, ethReserve2, ) = _titanETHV2Pair.getReserves();\n', '        }\n', '\n', '        if (ethReserve1 <= 0 || titanReserve <= 0) return false;\n', '\n', '        uint256 titanPrice =\n', '            usdcReserve.mul(1 ether).div(ethReserve1).mul(ethReserve2).div(\n', '                titanReserve\n', '            );\n', '        uint256 lotteryValue =\n', '            titanPrice.mul(_collectedAmountForLottery).div(1 ether);\n', '\n', '        if (lotteryValue > 0 && lotteryValue >= _lotteryLimit) {\n', '            uint256 amount = _lotteryLimit.mul(1 ether).div(titanPrice);\n', '\n', '            if (amount > _collectedAmountForLottery)\n', '                amount = _collectedAmountForLottery;\n', '\n', '            _titan.transfer(_msgSender(), amount);\n', '            _collectedAmountForLottery = _collectedAmountForLottery.sub(amount);\n', '            _lotteryPaidOut = _lotteryPaidOut.add(amount);\n', '\n', '            emit SentLotteryAmount(_msgSender(), amount, true);\n', '\n', '            winnerInfo.push(\n', '                WinnerInfo({\n', '                    winner: _msgSender(),\n', '                    amount: amount,\n', '                    timestamp: block.timestamp\n', '                })\n', '            );\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function safeTitanTransfer(address to, uint256 amount)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        uint256 titanBal = _titan.balanceOf(address(this));\n', '\n', '        if (amount > titanBal) {\n', '            _titan.transfer(to, titanBal);\n', '        } else {\n', '            _titan.transfer(to, amount);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '}']