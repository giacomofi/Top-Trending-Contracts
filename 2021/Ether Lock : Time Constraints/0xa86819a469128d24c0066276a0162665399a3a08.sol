['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-13\n', '*/\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see `ERC20Detailed`.\n', ' */\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor() internal {}\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    constructor() internal {\n', '        _owner = _msgSender();\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(\n', '            newOwner != address(0),\n', '            "Ownable: new owner is the zero address"\n', '        );\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract Rookie_v8 is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     *  @dev Structs to store user staking data.\n', '     */\n', '    struct Deposits {\n', '        uint256 depositAmount;\n', '        uint256 depositTime;\n', '        uint256 endTime;\n', '        uint64 userIndex;\n', '        bool paid;\n', '        bool eligible;\n', '    }\n', '\n', '    /**\n', '     *  @dev Structs to store interest rate change.\n', '     */\n', '    struct Rates {\n', '        uint64 newInterestRate;\n', '        uint256 timeStamp;\n', '    }\n', '\n', '    mapping(address => Deposits) private deposits;\n', '    mapping(uint64 => Rates) public rates;\n', '    mapping(address => bool) private hasStaked;\n', '\n', '    address public tokenAddress;\n', '    uint256 public stakedBalance;\n', '    uint256 public rewardBalance;\n', '    uint256 public stakedTotal;\n', '    uint256 public totalReward;\n', '    uint64 public index;\n', '    uint64 public rate;\n', '    uint256 public lockDuration;\n', '    uint256 public eligibilityAmount;\n', '    string public name;\n', '\n', '    IERC20 public ERC20Interface;\n', '\n', '    /**\n', "     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n", '     */\n', '    event Staked(\n', '        address indexed token,\n', '        address indexed staker_,\n', '        uint256 stakedAmount_\n', '    );\n', '\n', '    /**\n', '     *  @dev Emitted when user withdraws his stakings\n', '     */\n', '    event PaidOut(\n', '        address indexed token,\n', '        address indexed staker_,\n', '        uint256 amount_,\n', '        uint256 reward_\n', '    );\n', '\n', '    /**\n', '     *   @param\n', '     *   name_ name of the contract\n', '     *   tokenAddress_ contract address of the token\n', '     *   rate_ rate multiplied by 100\n', '     *   lockduration_ duration in days\n', '     */\n', '    constructor(\n', '        string memory name_,\n', '        address tokenAddress_,\n', '        uint64 rate_,\n', '        uint256 lockDuration_\n', '    ) public Ownable() {\n', '        name = name_;\n', '        require(tokenAddress_ != address(0), "Zero token address");\n', '        tokenAddress = tokenAddress_;\n', '        lockDuration = lockDuration_;\n', '        require(rate_ != 0, "Zero interest rate");\n', '        rate = rate_;\n', '        rates[index] = Rates(rate, block.timestamp);\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', '     *  `rate_` New effective interest rate multiplied by 100\n', '     *  @dev to set interest rates\n', '     */\n', '    function setRate(uint64 rate_) external onlyOwner {\n', '        require(rate_ != 0, "Zero interest rate");\n', '        rate = rate_;\n', '        index++;\n', '        rates[index] = Rates(rate_, block.timestamp);\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', '     *  `amount_` Eligibility amount to be set for Professional Tier unlocks\n', '     *  @dev to set eligibility amount\n', '     */\n', '    function setEligibilityAmount(\n', '        uint256 eligibilityAmount_ //external\n', '    ) external onlyOwner {\n', '        eligibilityAmount = eligibilityAmount_;\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', "     *  `lockduration_' lock days\n", '     *  @dev to set lock duration days\n', '     */\n', '    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n', '        lockDuration = lockduration_;\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', '     *  `user_` User wallet address\n', '     *  @dev to view eligibility status of user\n', '     */\n', '    function eligibility(address user_) external view returns (bool) {\n', '        return deposits[user_].eligible;\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', '     *  `rewardAmount` rewards to be added to the staking contract\n', '     *  @dev to add rewards to the staking contract\n', "     *  once the allowance is given to this contract for 'rewardAmount' by the user\n", '     */\n', '    function addReward(uint256 rewardAmount)\n', '        external\n', '        _hasAllowance(msg.sender, rewardAmount)\n', '        returns (bool)\n', '    {\n', '        require(rewardAmount > 0, "Reward must be positive");\n', '        address from = msg.sender;\n', '\n', '        if (!_payMe(from, rewardAmount)) {\n', '            return false;\n', '        }\n', '\n', '        totalReward = totalReward.add(rewardAmount);\n', '        rewardBalance = rewardBalance.add(rewardAmount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', '     *  `user` User wallet address\n', '     *  @dev returns user staking data\n', '     */\n', '    function userDeposits(address user)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            bool\n', '        )\n', '    {\n', '        if (hasStaked[user]) {\n', '            return (\n', '                deposits[user].depositAmount,\n', '                deposits[user].depositTime,\n', '                deposits[user].endTime,\n', '                deposits[user].userIndex,\n', '                deposits[user].paid\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', '     *  `amount` Amount to be staked\n', '     /**\n', "     *  @dev to stake 'amount' value of tokens \n", '     *  once the user has given allowance to the staking contract\n', '     */\n', '    function stake(uint256 amount)\n', '        external\n', '        _hasAllowance(msg.sender, amount)\n', '        returns (bool)\n', '    {\n', '        require(amount > 0, "Can\'t stake 0 amount");\n', '        address from = msg.sender;\n', '        require(!hasStaked[from], "Already Staked");\n', '        return (_stake(from, amount));\n', '    }\n', '\n', '    function _stake(address from, uint256 amount) private returns (bool) {\n', '        if (!_payMe(from, amount)) {\n', '            return false;\n', '        }\n', '\n', '        hasStaked[from] = true;\n', '        bool stakerEligibility;\n', '        if (amount >= eligibilityAmount) {\n', '            stakerEligibility = true;\n', '        }\n', '\n', '        deposits[from] = Deposits(\n', '            amount,\n', '            block.timestamp,\n', '            block.timestamp.add((lockDuration.mul(86400))), //lockDuration * 24 * 3600\n', '            index,\n', '            false,\n', '            stakerEligibility\n', '        );\n', '\n', '        emit Staked(tokenAddress, from, amount);\n', '\n', '        stakedBalance = stakedBalance.add(amount);\n', '        stakedTotal = stakedTotal.add(amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev to withdraw user stakings after the lock period ends.\n', '     */\n', '    function withdraw() external returns (bool) {\n', '        address from = msg.sender;\n', '        require(hasStaked[from], "No stakes found for user");\n', '        require(\n', '            block.timestamp >= deposits[from].endTime,\n', '            "Requesting before lock time"\n', '        );\n', '        require(!deposits[from].paid, "Already paid out");\n', '        return (_withdraw(from));\n', '    }\n', '\n', '    function _withdraw(address from) private returns (bool) {\n', '        uint256 payOut = _calculate(from);\n', '        uint256 amount = deposits[from].depositAmount;\n', '        uint256 reward = payOut.sub(amount);\n', '        require(reward <= rewardBalance, "Not enough rewards");\n', '\n', '        stakedBalance = stakedBalance.sub(amount);\n', '        rewardBalance = rewardBalance.sub(reward);\n', '        deposits[from].paid = true;\n', '        hasStaked[from] = false;\n', '        if (deposits[from].eligible) {\n', '            deposits[from].eligible = false;\n', '        }\n', '\n', '        if (_payDirect(from, payOut)) {\n', '            emit PaidOut(tokenAddress, from, amount, reward);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function emergencyWithdraw() external returns (bool) {\n', '        address from = msg.sender;\n', '        require(hasStaked[from], "No stakes found for user");\n', '        require(\n', '            block.timestamp >= deposits[from].endTime,\n', '            "Requesting before lock time"\n', '        );\n', '        require(!deposits[from].paid, "Already paid out");\n', '\n', '        return (_emergencyWithdraw(from));\n', '    }\n', '\n', '    function _emergencyWithdraw(address from) private returns (bool) {\n', '        uint256 amount = deposits[from].depositAmount;\n', '        stakedBalance = stakedBalance.sub(amount);\n', '        deposits[from].paid = true;\n', '        hasStaked[from] = false; //Check-Effects-Interactions pattern\n', '        if (deposits[from].eligible) {\n', '            deposits[from].eligible = false;\n', '        }\n', '\n', '        bool principalPaid = _payDirect(from, amount);\n', '        require(principalPaid, "Error paying");\n', '        emit PaidOut(tokenAddress, from, amount, 0);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', '     *  `from` User wallet address\n', "     * @dev to calculate the rewards based on user staked 'amount'\n", "     * 'userIndex' - the index of the interest rate at the time of user stake.\n", "     * 'depositTime' - time of staking\n", '     */\n', '    function calculate(address from) external view returns (uint256) {\n', '        return _calculate(from);\n', '    }\n', '\n', '    function _calculate(address from) private view returns (uint256) {\n', '        if (!hasStaked[from]) return 0;\n', '        (\n', '            uint256 amount,\n', '            uint256 depositTime,\n', '            uint256 endTime,\n', '            uint64 userIndex\n', '        ) =\n', '            (\n', '                deposits[from].depositAmount,\n', '                deposits[from].depositTime,\n', '                deposits[from].endTime,\n', '                deposits[from].userIndex\n', '            );\n', '\n', '        uint256 time;\n', '        uint256 interest;\n', '        uint256 _lockduration = endTime.sub(depositTime);\n', '        for (uint64 i = userIndex; i < index; i++) {\n', '            //loop runs till the latest index/interest rate change\n', '            if (endTime < rates[i + 1].timeStamp) {\n', '                //if the change occurs after the endTime loop breaks\n', '                break;\n', '            } else {\n', '                time = rates[i + 1].timeStamp.sub(depositTime);\n', '                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n', '                    _lockduration.mul(10000)\n', '                ); //replace with (_lockduration * 10000)\n', '                amount += interest;\n', '                depositTime = rates[i + 1].timeStamp;\n', '                userIndex++;\n', '            }\n', '        }\n', '\n', '        if (depositTime < endTime) {\n', '            //final calculation for the remaining time period\n', '            time = endTime.sub(depositTime);\n', '\n', '            interest = time\n', '                .mul(amount)\n', '                .mul(rates[userIndex].newInterestRate)\n', '                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n', '\n', '            amount += interest;\n', '        }\n', '\n', '        return (amount);\n', '    }\n', '\n', '    function _payMe(address payer, uint256 amount) private returns (bool) {\n', '        return _payTo(payer, address(this), amount);\n', '    }\n', '\n', '    function _payTo(\n', '        address allower,\n', '        address receiver,\n', '        uint256 amount\n', '    ) private _hasAllowance(allower, amount) returns (bool) {\n', '        ERC20Interface = IERC20(tokenAddress);\n', '        return ERC20Interface.transferFrom(allower, receiver, amount);\n', '    }\n', '\n', '    function _payDirect(address to, uint256 amount) private returns (bool) {\n', '        ERC20Interface = IERC20(tokenAddress);\n', '        return ERC20Interface.transfer(to, amount);\n', '    }\n', '\n', '    modifier _hasAllowance(address allower, uint256 amount) {\n', '        // Make sure the allower has provided the right allowance.\n', '        ERC20Interface = IERC20(tokenAddress);\n', '        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n', '        require(amount <= ourAllowance, "Make sure to add enough allowance");\n', '        _;\n', '    }\n', '}']