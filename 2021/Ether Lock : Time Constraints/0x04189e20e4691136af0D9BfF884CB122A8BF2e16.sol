['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-23\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-23\n', '*/\n', '\n', '// File: contracts/interfaces/marketHandlerInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketHandlerInterface  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\tfunction setCircuitBreakWithOwner(bool _emergency) external returns (bool);\n', '\n', '\tfunction getTokenName() external view returns (string memory);\n', '\n', '\tfunction ownershipTransfer(address payable newOwner) external returns (bool);\n', '\n', '\tfunction deposit(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\tfunction withdraw(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction borrow(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction repay(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) external returns (uint256);\n', '\n', '\tfunction getTokenHandlerLimit() external view returns (uint256, uint256);\n', '    function getTokenHandlerBorrowLimit() external view returns (uint256);\n', '\tfunction getTokenHandlerMarginCallLimit() external view returns (uint256);\n', '\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) external returns (bool);\n', '\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) external returns (bool);\n', '\n', '\tfunction getUserAmountWithInterest(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserMaxBorrowAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxRepayAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction checkFirstAction() external returns (bool);\n', '\tfunction applyInterest(address payable userAddr) external returns (uint256, uint256);\n', '\n', '\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable returns (bool);\n', '\tfunction reserveWithdraw(uint256 unifiedTokenAmount) external returns (bool);\n', '\n', '\tfunction getDepositTotalAmount() external view returns (uint256);\n', '\tfunction getBorrowTotalAmount() external view returns (uint256);\n', '\n', '\tfunction getSIRandBIR() external view returns (uint256, uint256);\n', '}\n', '\n', '// File: contracts/interfaces/marketHandlerDataStorageInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketHandlerDataStorageInterface  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\n', '\tfunction setNewCustomer(address payable userAddr) external returns (bool);\n', '\n', '\tfunction getUserAccessed(address payable userAddr) external view returns (bool);\n', '\tfunction setUserAccessed(address payable userAddr, bool _accessed) external returns (bool);\n', '\n', '\tfunction getReservedAddr() external view returns (address payable);\n', '\tfunction setReservedAddr(address payable reservedAddress) external returns (bool);\n', '\n', '\tfunction getReservedAmount() external view returns (int256);\n', '\tfunction addReservedAmount(uint256 amount) external returns (int256);\n', '\tfunction subReservedAmount(uint256 amount) external returns (int256);\n', '\tfunction updateSignedReservedAmount(int256 amount) external returns (int256);\n', '\n', '\tfunction setTokenHandler(address _marketHandlerAddr, address _interestModelAddr) external returns (bool);\n', '\tfunction setCoinHandler(address _marketHandlerAddr, address _interestModelAddr) external returns (bool);\n', '\n', '\tfunction getDepositTotalAmount() external view returns (uint256);\n', '\tfunction addDepositTotalAmount(uint256 amount) external returns (uint256);\n', '\tfunction subDepositTotalAmount(uint256 amount) external returns (uint256);\n', '\n', '\tfunction getBorrowTotalAmount() external view returns (uint256);\n', '\tfunction addBorrowTotalAmount(uint256 amount) external returns (uint256);\n', '\tfunction subBorrowTotalAmount(uint256 amount) external returns (uint256);\n', '\n', '\tfunction getUserIntraDepositAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction addUserIntraDepositAmount(address payable userAddr, uint256 amount) external returns (uint256);\n', '\tfunction subUserIntraDepositAmount(address payable userAddr, uint256 amount) external returns (uint256);\n', '\n', '\tfunction getUserIntraBorrowAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction addUserIntraBorrowAmount(address payable userAddr, uint256 amount) external returns (uint256);\n', '\tfunction subUserIntraBorrowAmount(address payable userAddr, uint256 amount) external returns (uint256);\n', '\n', '\tfunction addDepositAmount(address payable userAddr, uint256 amount) external returns (bool);\n', '\tfunction subDepositAmount(address payable userAddr, uint256 amount) external returns (bool);\n', '\n', '\tfunction addBorrowAmount(address payable userAddr, uint256 amount) external returns (bool);\n', '\tfunction subBorrowAmount(address payable userAddr, uint256 amount) external returns (bool);\n', '\n', '\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction getHandlerAmount() external view returns (uint256, uint256);\n', '\n', '\tfunction getAmount(address payable userAddr) external view returns (uint256, uint256, uint256, uint256);\n', '\tfunction setAmount(address payable userAddr, uint256 depositTotalAmount, uint256 borrowTotalAmount, uint256 depositAmount, uint256 borrowAmount) external returns (uint256);\n', '\n', '\tfunction setBlocks(uint256 lastUpdatedBlock, uint256 inactiveActionDelta) external returns (bool);\n', '\n', '\tfunction getLastUpdatedBlock() external view returns (uint256);\n', '\tfunction setLastUpdatedBlock(uint256 _lastUpdatedBlock) external returns (bool);\n', '\n', '\tfunction getInactiveActionDelta() external view returns (uint256);\n', '\tfunction setInactiveActionDelta(uint256 inactiveActionDelta) external returns (bool);\n', '\n', '\tfunction syncActionEXR() external returns (bool);\n', '\n', '\tfunction getActionEXR() external view returns (uint256, uint256);\n', '\tfunction setActionEXR(uint256 actionDepositExRate, uint256 actionBorrowExRate) external returns (bool);\n', '\n', '\tfunction getGlobalDepositEXR() external view returns (uint256);\n', '\tfunction getGlobalBorrowEXR() external view returns (uint256);\n', '\n', '\tfunction setEXR(address payable userAddr, uint256 globalDepositEXR, uint256 globalBorrowEXR) external returns (bool);\n', '\n', '\tfunction getUserEXR(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction setUserEXR(address payable userAddr, uint256 depositEXR, uint256 borrowEXR) external returns (bool);\n', '\n', '\tfunction getGlobalEXR() external view returns (uint256, uint256);\n', '\n', '\tfunction getMarketHandlerAddr() external view returns (address);\n', '\tfunction setMarketHandlerAddr(address marketHandlerAddr) external returns (bool);\n', '\n', '\tfunction getInterestModelAddr() external view returns (address);\n', '\tfunction setInterestModelAddr(address interestModelAddr) external returns (bool);\n', '\n', '\n', '\tfunction getMinimumInterestRate() external view returns (uint256);\n', '\tfunction setMinimumInterestRate(uint256 _minimumInterestRate) external returns (bool);\n', '\n', '\tfunction getLiquiditySensitivity() external view returns (uint256);\n', '\tfunction setLiquiditySensitivity(uint256 _liquiditySensitivity) external returns (bool);\n', '\n', '\tfunction getLimit() external view returns (uint256, uint256);\n', '\n', '\tfunction getBorrowLimit() external view returns (uint256);\n', '\tfunction setBorrowLimit(uint256 _borrowLimit) external returns (bool);\n', '\n', '\tfunction getMarginCallLimit() external view returns (uint256);\n', '\tfunction setMarginCallLimit(uint256 _marginCallLimit) external returns (bool);\n', '\n', '\tfunction getLimitOfAction() external view returns (uint256);\n', '\tfunction setLimitOfAction(uint256 limitOfAction) external returns (bool);\n', '\n', '\tfunction getLiquidityLimit() external view returns (uint256);\n', '\tfunction setLiquidityLimit(uint256 liquidityLimit) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/marketManagerInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketManagerInterface  {\n', '\tfunction setBreakerTable(address _target, bool _status) external returns (bool);\n', '\n', '\tfunction getCircuitBreaker() external view returns (bool);\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address, string memory);\n', '\n', '\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr) external returns (bool);\n', '\n', '\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256, uint256, uint256, uint256);\n', '\n', '\tfunction getTokenHandlerPrice(uint256 handlerID) external view returns (uint256);\n', '\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view returns (uint256);\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\n', '\n', '\tfunction getTokenHandlersLength() external view returns (uint256);\n', '\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) external returns (bool);\n', '\n', '\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\n', '\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view returns (uint256);\n', '\n', '\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserLimitIntraAsset(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\n', '\n', '\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\n', '\n', '\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view returns (uint256);\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) external returns (uint256);\n', '\n', '\tfunction setLiquidationManager(address liquidationManagerAddr) external returns (bool);\n', '\n', '\tfunction rewardClaimAll(address payable userAddr) external returns (bool);\n', '\n', '\tfunction updateRewardParams(address payable userAddr) external returns (bool);\n', '\tfunction interestUpdateReward() external returns (bool);\n', '\tfunction getGlobalRewardInfo() external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction setOracleProxy(address oracleProxyAddr) external returns (bool);\n', '\n', '\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external returns (bool);\n', '\tfunction ownerRewardTransfer(uint256 _amount) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/interestModelInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface interestModelInterface {\n', '\tfunction getInterestAmount(address handlerDataStorageAddr, address payable userAddr, bool isView) external view returns (bool, uint256, uint256, bool, uint256, uint256);\n', '\tfunction viewInterestAmount(address handlerDataStorageAddr, address payable userAddr) external view returns (bool, uint256, uint256, bool, uint256, uint256);\n', '\tfunction getSIRandBIR(uint256 depositTotalAmount, uint256 borrowTotalAmount) external view returns (uint256, uint256);\n', '}\n', '\n', '// File: contracts/interfaces/marketSIHandlerDataStorageInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketSIHandlerDataStorageInterface  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\n', '\tfunction updateRewardPerBlockStorage(uint256 _rewardPerBlock) external returns (bool);\n', '\n', '\tfunction getRewardInfo(address userAddr) external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\n', '\n', '\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\n', '\tfunction setMarketRewardInfo(uint256 _rewardLane, uint256 _rewardLaneUpdateAt, uint256 _rewardPerBlock) external returns (bool);\n', '\n', '\tfunction getUserRewardInfo(address userAddr) external view returns (uint256, uint256, uint256);\n', '\tfunction setUserRewardInfo(address userAddr, uint256 _rewardLane, uint256 _rewardLaneUpdateAt, uint256 _rewardAmount) external returns (bool);\n', '\n', '\tfunction getBetaRate() external view returns (uint256);\n', '\tfunction setBetaRate(uint256 _betaRate) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/tokenInterface.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external ;\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external view returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external ;\n', '}\n', '\n', '// File: contracts/interfaces/proxyContractInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface proxyContractInterface  {\n', '\tfunction handlerProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction handlerViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '\tfunction siProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction siViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '}\n', '\n', '// File: contracts/interfaces/SIInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface SIInterface  {\n', '\tfunction setCircuitBreakWithOwner(bool emergency) external returns (bool);\n', '\tfunction setCircuitBreaker(bool emergency) external returns (bool);\n', '\n', '\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) external returns (bool);\n', '\tfunction updateRewardLane(address payable userAddr) external returns (bool);\n', '\n', '\tfunction getBetaRateBaseTotalAmount() external view returns (uint256);\n', '\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction getUserRewardInfo(address payable userAddr) external view returns (uint256, uint256, uint256);\n', '}\n', '\n', '// File: contracts/Errors.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract Modifier {\n', '    string internal constant ONLY_OWNER = "O";\n', '    string internal constant ONLY_MANAGER = "M";\n', '    string internal constant CIRCUIT_BREAKER = "emergency";\n', '}\n', '\n', 'contract ManagerModifier is Modifier {\n', '    string internal constant ONLY_HANDLER = "H";\n', '    string internal constant ONLY_LIQUIDATION_MANAGER = "LM";\n', '    string internal constant ONLY_BREAKER = "B";\n', '}\n', '\n', 'contract HandlerDataStorageModifier is Modifier {\n', '    string internal constant ONLY_BIFI_CONTRACT = "BF";\n', '}\n', '\n', 'contract SIDataStorageModifier is Modifier {\n', '    string internal constant ONLY_SI_HANDLER = "SI";\n', '}\n', '\n', 'contract HandlerErrors is Modifier {\n', '    string internal constant USE_VAULE = "use value";\n', '    string internal constant USE_ARG = "use arg";\n', '    string internal constant EXCEED_LIMIT = "exceed limit";\n', '    string internal constant NO_LIQUIDATION = "no liquidation";\n', '    string internal constant NO_LIQUIDATION_REWARD = "no enough reward";\n', '    string internal constant NO_EFFECTIVE_BALANCE = "not enough balance";\n', '    string internal constant TRANSFER = "err transfer";\n', '}\n', '\n', 'contract SIErrors is Modifier { }\n', '\n', 'contract InterestErrors is Modifier { }\n', '\n', 'contract LiquidationManagerErrors is Modifier {\n', '    string internal constant NO_DELINQUENT = "not delinquent";\n', '}\n', '\n', 'contract ManagerErrors is ManagerModifier {\n', '    string internal constant REWARD_TRANSFER = "RT";\n', '    string internal constant UNSUPPORTED_TOKEN = "UT";\n', '}\n', '\n', 'contract OracleProxyErrors is Modifier {\n', '    string internal constant ZERO_PRICE = "price zero";\n', '}\n', '\n', 'contract RequestProxyErrors is Modifier { }\n', '\n', 'contract ManagerDataStorageErrors is ManagerModifier {\n', '    string internal constant NULL_ADDRESS = "err addr null";\n', '}\n', '\n', '// File: contracts/marketHandler/tokenHandler.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title Bifi's tokenHandler logic contract for ERC20 tokens\n", ' * @author Bifi\n', ' */\n', 'contract tokenHandler is marketHandlerInterface, HandlerErrors {\n', '\tevent MarketIn(address userAddr);\n', '\n', '\tevent Deposit(address depositor, uint256 depositAmount, uint256 handlerID);\n', '\tevent Withdraw(address redeemer, uint256 redeemAmount, uint256 handlerID);\n', '\tevent Borrow(address borrower, uint256 borrowAmount, uint256 handlerID);\n', '\tevent Repay(address repayer, uint256 repayAmount, uint256 handlerID);\n', '\n', '\tevent ReserveDeposit(uint256 reserveDepositAmount, uint256 handlerID);\n', '\tevent ReserveWithdraw(uint256 reserveWithdrawAmount, uint256 handlerID);\n', '\n', '\tevent OwnershipTransferred(address owner, address newOwner);\n', '\n', '\tevent CircuitBreaked(bool breaked, uint256 blockNumber, uint256 handlerID);\n', '\n', '\taddress payable owner;\n', '\tuint256 handlerID;\n', '\tstring tokenName;\n', '\n', '\tuint256 constant unifiedPoint = 10 ** 18;\n', '\tuint256 unifiedTokenDecimal;\n', '\tuint256 underlyingTokenDecimal;\n', '\n', '\tmarketManagerInterface marketManager;\n', '\tinterestModelInterface interestModelInstance;\n', '\tmarketHandlerDataStorageInterface handlerDataStorage;\n', '\tmarketSIHandlerDataStorageInterface SIHandlerDataStorage;\n', '\tIERC20 erc20Instance;\n', '\n', '\tstruct ProxyInfo {\n', '\t\tbool result;\n', '\t\tbytes returnData;\n', '\t\tbytes data;\n', '\t\tbytes proxyData;\n', '\t}\n', '\n', '\tmodifier onlyMarketManager {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == address(marketManager)) || (msgSender == owner), ONLY_MANAGER);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == address(owner), ONLY_OWNER);\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set circuitBreak to freeze all of handlers by owner\n', '\t* @param _emergency Boolean state of the circuit break.\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setCircuitBreakWithOwner(bool _emergency) onlyOwner external override returns (bool)\n', '\t{\n', '\t\thandlerDataStorage.setCircuitBreaker(_emergency);\n', '\n', '\t\temit CircuitBreaked(_emergency, block.number, handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set circuitBreak which freeze all of handlers by marketManager\n', '\t* @param _emergency Boolean state of the circuit break.\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setCircuitBreaker(bool _emergency) onlyMarketManager external override returns (bool)\n', '\t{\n', '\t\thandlerDataStorage.setCircuitBreaker(_emergency);\n', '\n', '\t\temit CircuitBreaked(_emergency, block.number, handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Change the owner of the handler\n', '\t* @param newOwner the address of the owner to be replaced\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction ownershipTransfer(address payable newOwner) onlyOwner external override returns (bool)\n', '\t{\n', '\t\towner = newOwner;\n', '\n', '\t\temit OwnershipTransferred(owner, newOwner);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the token name\n', '   * @return the token name\n', '\t*/\n', '\tfunction getTokenName() external view override returns (string memory)\n', '\t{\n', '\t\treturn tokenName;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Deposit assets to the reserve of the handler.\n', '\t* @param unifiedTokenAmount The amount of token to deposit\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable override returns (bool)\n', '\t{\n', '\t\trequire(msg.value == 0, USE_ARG);\n', '\n', '\t\thandlerDataStorage.addReservedAmount(unifiedTokenAmount);\n', '\t\thandlerDataStorage.addDepositTotalAmount(unifiedTokenAmount);\n', '\n', '\t\t_transferFrom(msg.sender, unifiedTokenAmount);\n', '\n', '\t\temit ReserveDeposit(unifiedTokenAmount, handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Withdraw assets from the reserve of the handler.\n', '\t* @param unifiedTokenAmount The amount of token to withdraw\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction reserveWithdraw(uint256 unifiedTokenAmount) onlyOwner external override returns (bool)\n', '\t{\n', '\t\taddress payable reserveAddr = handlerDataStorage.getReservedAddr();\n', '\n', '\t\thandlerDataStorage.subReservedAmount(unifiedTokenAmount);\n', '\t\thandlerDataStorage.subDepositTotalAmount(unifiedTokenAmount);\n', '\n', '\t\t_transfer(reserveAddr, unifiedTokenAmount);\n', '\n', '\t\temit ReserveWithdraw(unifiedTokenAmount, handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Deposit action\n', '\t* @param unifiedTokenAmount The deposit amount\n', '\t* @param flag Flag for the full calcuation mode\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction deposit(uint256 unifiedTokenAmount, bool flag) external payable override returns (bool)\n', '\t{\n', '\t\trequire(msg.value == 0, USE_ARG);\n', '\n', '\t\taddress payable userAddr = msg.sender;\n', '\t\tuint256 _handlerID = handlerID;\n', '\n', '\t\tif(flag) {\n', '\t\t\t// flag is true, update interest, reward all handlers\n', '\t\t\tmarketManager.applyInterestHandlers(userAddr, _handlerID, flag);\n', '\t\t} else {\n', '\t\t\tmarketManager.rewardUpdateOfInAction(userAddr, _handlerID);\n', '\t\t\t_applyInterest(userAddr);\n', '\t\t}\n', '\n', '\t\thandlerDataStorage.addDepositAmount(userAddr, unifiedTokenAmount);\n', '\n', '\t\t_transferFrom(userAddr, unifiedTokenAmount);\n', '\n', '\t\temit Deposit(userAddr, unifiedTokenAmount, _handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Withdraw action\n', '\t* @param unifiedTokenAmount The withdraw amount\n', '\t* @param flag Flag for the full calcuation mode\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction withdraw(uint256 unifiedTokenAmount, bool flag) external override returns (bool)\n', '\t{\n', '\t\taddress payable userAddr = msg.sender;\n', '\t\tuint256 _handlerID = handlerID;\n', '\n', '\t\tuint256 userLiquidityAmount;\n', '\t\tuint256 userCollateralizableAmount;\n', '\t\tuint256 price;\n', '\t\t(userLiquidityAmount, userCollateralizableAmount, , , , price) = marketManager.applyInterestHandlers(userAddr, _handlerID, flag);\n', '\t\trequire(unifiedMul(unifiedTokenAmount, price) <= handlerDataStorage.getLimitOfAction(), EXCEED_LIMIT);\n', '\n', '\t\tuint256 adjustedAmount = _getUserActionMaxWithdrawAmount(userAddr, unifiedTokenAmount, userCollateralizableAmount);\n', '\n', '\t\thandlerDataStorage.subDepositAmount(userAddr, adjustedAmount);\n', '\n', '\t\t_transfer(userAddr, adjustedAmount);\n', '\n', '\t\temit Withdraw(userAddr, adjustedAmount, _handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Borrow action\n', '\t* @param unifiedTokenAmount The borrow amount\n', '\t* @param flag Flag for the full calcuation mode\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction borrow(uint256 unifiedTokenAmount, bool flag) external override returns (bool)\n', '\t{\n', '\t\taddress payable userAddr = msg.sender;\n', '\t\tuint256 _handlerID = handlerID;\n', '\n', '\t\tuint256 userLiquidityAmount;\n', '\t\tuint256 userCollateralizableAmount;\n', '\t\tuint256 price;\n', '\t\t(userLiquidityAmount, userCollateralizableAmount, , , , price) = marketManager.applyInterestHandlers(userAddr, _handlerID, flag);\n', '\t\trequire(unifiedMul(unifiedTokenAmount, price) <= handlerDataStorage.getLimitOfAction(), EXCEED_LIMIT);\n', '\n', '\t\tuint256 adjustedAmount = _getUserActionMaxBorrowAmount(unifiedTokenAmount, userLiquidityAmount);\n', '\n', '\t\thandlerDataStorage.addBorrowAmount(userAddr, adjustedAmount);\n', '\n', '\t\t_transfer(userAddr, adjustedAmount);\n', '\n', '\t\temit Borrow(userAddr, adjustedAmount, _handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Repay action\n', '\t* @param unifiedTokenAmount The repay amount\n', '\t* @param flag Flag for the full calcuation mode\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction repay(uint256 unifiedTokenAmount, bool flag) external payable override returns (bool)\n', '\t{\n', '\t\trequire(msg.value == 0, USE_ARG);\n', '\t\taddress payable userAddr = msg.sender;\n', '\t\tuint256 _handlerID = handlerID;\n', '\n', '\t\tif(flag) {\n', '\t\t\t// flag is true, update interest, reward all handlers\n', '\t\t\tmarketManager.applyInterestHandlers(userAddr, _handlerID, flag);\n', '\t\t} else {\n', '\t\t\tmarketManager.rewardUpdateOfInAction(userAddr, _handlerID);\n', '\t\t\t_applyInterest(userAddr);\n', '\t\t}\n', '\n', '\t\tuint256 userBorrowAmount = handlerDataStorage.getUserIntraBorrowAmount(userAddr);\n', '\n', '\t\tif (userBorrowAmount < unifiedTokenAmount)\n', '\t\t{\n', '\t\t\tunifiedTokenAmount = userBorrowAmount;\n', '\t\t}\n', '\n', '\t\thandlerDataStorage.subBorrowAmount(userAddr, unifiedTokenAmount);\n', '\n', '\t\t_transferFrom(userAddr, unifiedTokenAmount);\n', '\n', '\t\temit Repay(userAddr, unifiedTokenAmount, _handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', "\t* @dev liquidate delinquentBorrower's partial(or can total) asset\n", '\t* @param delinquentBorrower The user addresss of liquidation target\n', '\t* @param liquidateAmount The amount of liquidator request\n', '\t* @param liquidator The address of a user executing liquidate\n', "\t* @param rewardHandlerID The handler id of delinquentBorrower's collateral for receive\n", '\t* @return (liquidateAmount, delinquentDepositAsset, delinquentBorrowAsset), result of liquidate\n', '\t*/\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) onlyMarketManager external override returns (uint256, uint256, uint256)\n', '\t{\n', '\t\t/* over paied amount compaction */\n', '\t\tuint256 tmp;\n', '\t\tuint256 delinquentMarginCallDeposit;\n', '\t\tuint256 delinquentDepositAsset;\n', '\t\tuint256 delinquentBorrowAsset;\n', '\t\tuint256 liquidatorLiquidityAmount;\n', '\n', '      /* apply interest for sync "latest" asset for delinquentBorrower and liquidator */\n', '\t\t(, , delinquentMarginCallDeposit, delinquentDepositAsset, delinquentBorrowAsset, ) = marketManager.applyInterestHandlers(delinquentBorrower, handlerID, false);\n', '\t\t(, liquidatorLiquidityAmount, , , , ) = marketManager.applyInterestHandlers(liquidator, handlerID, false);\n', '\n', '      /* check delinquentBorrower liquidatable */\n', '\t\trequire(delinquentMarginCallDeposit <= delinquentBorrowAsset, NO_LIQUIDATION);\n', '\n', '\t\ttmp = handlerDataStorage.getUserIntraDepositAmount(liquidator);\n', '\t\tif (tmp <= liquidateAmount)\n', '\t\t{\n', '\t\t\tliquidateAmount = tmp;\n', '\t\t}\n', '\n', '\t\ttmp = handlerDataStorage.getUserIntraBorrowAmount(delinquentBorrower);\n', '\t\tif (tmp <= liquidateAmount)\n', '\t\t{\n', '\t\t\tliquidateAmount = tmp;\n', '\t\t}\n', '\n', '      /* get maximum "receive handler" amount by liquidate amount */\n', '\t\tliquidateAmount = marketManager.getMaxLiquidationReward(delinquentBorrower, handlerID, liquidateAmount, rewardHandlerID, unifiedDiv(delinquentBorrowAsset, delinquentDepositAsset));\n', '\n', '      /* check liquidator has enough amount for liquidation */\n', '\t\trequire(liquidatorLiquidityAmount > liquidateAmount, NO_EFFECTIVE_BALANCE);\n', '\n', '      /* update storage for liquidate*/\n', '\t\thandlerDataStorage.subDepositAmount(liquidator, liquidateAmount);\n', '\n', '\t\thandlerDataStorage.subBorrowAmount(delinquentBorrower, liquidateAmount);\n', '\n', '\t\treturn (liquidateAmount, delinquentDepositAsset, delinquentBorrowAsset);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev liquidator receive delinquentBorrower's collateral after liquidate delinquentBorrower's asset\n", '\t* @param delinquentBorrower The user addresss of liquidation target\n', "\t* @param liquidationAmountWithReward The amount of liquidator receiving delinquentBorrower's collateral\n", '\t* @param liquidator The address of a user executing liquidate\n', '\t* @return The amount of token transfered(in storage)\n', '\t*/\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) onlyMarketManager external override returns (uint256)\n', '\t{\n', '\t\tmarketManager.rewardUpdateOfInAction(delinquentBorrower, handlerID);\n', '\t\t_applyInterest(delinquentBorrower);\n', "\t\t/* check delinquentBorrower's collateral enough */\n", '\t\tuint256 collateralAmount = handlerDataStorage.getUserIntraDepositAmount(delinquentBorrower);\n', '\t\trequire(collateralAmount >= liquidationAmountWithReward, NO_LIQUIDATION_REWARD);\n', '\n', '\t\t/* collateral transfer */\n', '\t\thandlerDataStorage.subDepositAmount(delinquentBorrower, liquidationAmountWithReward);\n', '\n', '\t\t_transfer(liquidator, liquidationAmountWithReward);\n', '\n', '\t\treturn liquidationAmountWithReward;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get borrowLimit and marginCallLimit\n', '\t* @return borrowLimit and marginCallLimit\n', '\t*/\n', '\tfunction getTokenHandlerLimit() external view override returns (uint256, uint256)\n', '\t{\n', '\t\treturn handlerDataStorage.getLimit();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the borrow limit of the handler through a specific handlerID\n', '\t* @param borrowLimit The borrow limit\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) onlyOwner external override returns (bool)\n', '\t{\n', '\t\thandlerDataStorage.setBorrowLimit(borrowLimit);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the liquidation limit of the handler through a specific handlerID\n', '\t* @param marginCallLimit The liquidation limit\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) onlyOwner external override returns (bool)\n', '\t{\n', '\t\thandlerDataStorage.setMarginCallLimit(marginCallLimit);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the liquidation limit of handler through a specific handlerID\n', '\t* @return The liquidation limit\n', '\t*/\n', '\tfunction getTokenHandlerMarginCallLimit() external view override returns (uint256)\n', '\t{\n', '\t\treturn handlerDataStorage.getMarginCallLimit();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the borrow limit of the handler through a specific handlerID\n', '\t* @return The borrow limit\n', '\t*/\n', '\tfunction getTokenHandlerBorrowLimit() external view override returns (uint256)\n', '\t{\n', '\t\treturn handlerDataStorage.getBorrowLimit();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum amount that user can borrow\n', '\t* @param userAddr The address of user\n', '\t* @return the maximum amount that user can borrow\n', '\t*/\n', '\tfunction getUserMaxBorrowAmount(address payable userAddr) external view override returns (uint256)\n', '\t{\n', '\t\treturn _getUserMaxBorrowAmount(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum amount that user can borrow\n', '\t* @param userAddr The address of user\n', '\t* @return the maximum amount that user can borrow\n', '\t*/\n', '\tfunction _getUserMaxBorrowAmount(address payable userAddr) internal view returns (uint256)\n', '\t{\n', '\t\t/* Prevent Action: over "Token Liquidity" amount*/\n', '\t\tuint256 handlerLiquidityAmount = _getTokenLiquidityLimitAmountWithInterest(userAddr);\n', '\t\t/* Prevent Action: over "CREDIT" amount */\n', '\t\tuint256 userLiquidityAmount = marketManager.getUserExtraLiquidityAmount(userAddr, handlerID);\n', '\t\tuint256 minAmount = userLiquidityAmount;\n', '\t\tif (handlerLiquidityAmount < minAmount)\n', '\t\t{\n', '\t\t\tminAmount = handlerLiquidityAmount;\n', '\t\t}\n', '\n', '\t\treturn minAmount;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum amount that user can borrow\n', '\t* @param requestedAmount The amount of token to borrow\n', '\t* @param userLiquidityAmount The amount of liquidity that users can borrow\n', '\t* @return the maximum amount that user can borrow\n', '\t*/\n', '\tfunction _getUserActionMaxBorrowAmount(uint256 requestedAmount, uint256 userLiquidityAmount) internal view returns (uint256)\n', '\t{\n', '\t\t/* Prevent Action: over "Token Liquidity" amount*/\n', '\t\tuint256 handlerLiquidityAmount = _getTokenLiquidityLimitAmount();\n', '\n', '\t\t/* select minimum of handlerLiqudity and user liquidity */\n', '\t\tuint256 minAmount = requestedAmount;\n', '\n', '\t\tif (minAmount > handlerLiquidityAmount)\n', '\t\t{\n', '\t\t\tminAmount = handlerLiquidityAmount;\n', '\t\t}\n', '\n', '\t\tif (minAmount > userLiquidityAmount)\n', '\t\t{\n', '\t\t\tminAmount = userLiquidityAmount;\n', '\t\t}\n', '\n', '\t\treturn minAmount;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum amount that users can withdraw\n', '\t* @param userAddr The address of user\n', '\t* @return the maximum amount that users can withdraw\n', '\t*/\n', '\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view override returns (uint256)\n', '\t{\n', '\t\treturn _getUserMaxWithdrawAmount(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the rate of SIR and BIR\n', '\t* @return The rate of SIR and BIR\n', '\t*/\n', '\tfunction getSIRandBIR() external view override returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 totalDepositAmount = handlerDataStorage.getDepositTotalAmount();\n', '\t\tuint256 totalBorrowAmount = handlerDataStorage.getBorrowTotalAmount();\n', '\n', '\t\treturn interestModelInstance.getSIRandBIR(totalDepositAmount, totalBorrowAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum amount that users can withdraw\n', '\t* @param userAddr The address of user\n', '\t* @return the maximum amount that users can withdraw\n', '\t*/\n', '\tfunction _getUserMaxWithdrawAmount(address payable userAddr) internal view returns (uint256)\n', '\t{\n', '\t\tuint256 depositAmountWithInterest;\n', '\t\tuint256 borrowAmountWithInterest;\n', '\t\t(depositAmountWithInterest, borrowAmountWithInterest) = _getUserAmountWithInterest(userAddr);\n', '\n', '\t\tuint256 handlerLiquidityAmount = _getTokenLiquidityAmountWithInterest(userAddr);\n', '\n', '\t\tuint256 userLiquidityAmount = marketManager.getUserCollateralizableAmount(userAddr, handlerID);\n', '\n', '\t\t/* Prevent Action: over "DEPOSIT" amount */\n', '\t\tuint256 minAmount = depositAmountWithInterest;\n', '\t\t/* Prevent Action: over "CREDIT" amount */\n', '\t\tif (minAmount > userLiquidityAmount)\n', '\t\t{\n', '\t\t\tminAmount = userLiquidityAmount;\n', '\t\t}\n', '\n', '\t\tif (minAmount > handlerLiquidityAmount)\n', '\t\t{\n', '\t\t\tminAmount = handlerLiquidityAmount;\n', '\t\t}\n', '\n', '\t\treturn minAmount;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum amount that users can withdraw\n', '\t* @param userAddr The address of user\n', '\t* @param requestedAmount The amount of token to withdraw\n', '\t* @param collateralableAmount The amount of liquidity that users can borrow\n', '\t* @return the maximum amount that users can withdraw\n', '\t*/\n', '\tfunction _getUserActionMaxWithdrawAmount(address payable userAddr, uint256 requestedAmount, uint256 collateralableAmount) internal view returns (uint256)\n', '\t{\n', '\t\tuint256 depositAmount = handlerDataStorage.getUserIntraDepositAmount(userAddr);\n', '\n', '\t\tuint256 handlerLiquidityAmount = _getTokenLiquidityAmount();\n', '\n', '\t\t/* select minimum among deposited, requested and collateralable*/\n', '\t\tuint256 minAmount = depositAmount;\n', '\n', '\t\tif (minAmount > requestedAmount)\n', '\t\t{\n', '\t\t\tminAmount = requestedAmount;\n', '\t\t}\n', '\n', '\t\tif (minAmount > collateralableAmount)\n', '\t\t{\n', '\t\t\tminAmount = collateralableAmount;\n', '\t\t}\n', '\n', '\t\tif (minAmount > handlerLiquidityAmount)\n', '\t\t{\n', '\t\t\tminAmount = handlerLiquidityAmount;\n', '\t\t}\n', '\n', '\t\treturn minAmount;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum amount that users can repay\n', '\t* @param userAddr The address of user\n', '\t* @return the maximum amount that users can repay\n', '\t*/\n', '\tfunction getUserMaxRepayAmount(address payable userAddr) external view override returns (uint256)\n', '\t{\n', '\t\tuint256 depositAmountWithInterest;\n', '\t\tuint256 borrowAmountWithInterest;\n', '\t\t(depositAmountWithInterest, borrowAmountWithInterest) = _getUserAmountWithInterest(userAddr);\n', '\n', '\t\treturn borrowAmountWithInterest;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update (apply) interest entry point (external)\n', '\t* @param userAddr The user address\n', '\t* @return "latest" (userDepositAmount, userBorrowAmount)\n', '\t*/\n', '\tfunction applyInterest(address payable userAddr) external override returns (uint256, uint256)\n', '\t{\n', '\t\treturn _applyInterest(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update (apply) interest entry point (external)\n', '\t* @param userAddr The user address\n', '\t* @return "latest" (userDepositAmount, userBorrowAmount)\n', '\t*/\n', '\tfunction _applyInterest(address payable userAddr) internal returns (uint256, uint256)\n', '\t{\n', '\t\t_checkNewCustomer(userAddr);\n', '\t\t_checkFirstAction();\n', '\t\treturn _updateInterestAmount(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Check whether a given userAddr is a new user or not\n', '\t* @param userAddr The user address\n', '\t* @return true if the user is a new user; false otherwise.\n', '\t*/\n', '\tfunction _checkNewCustomer(address payable userAddr) internal returns (bool)\n', '\t{\n', '\t\tmarketHandlerDataStorageInterface _handlerDataStorage = handlerDataStorage;\n', '\t\tif (_handlerDataStorage.getUserAccessed(userAddr))\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\t\t/* hotfix */\n', '\t\t_handlerDataStorage.setUserAccessed(userAddr, true);\n', '\n', '\t\t(uint256 gDEXR, uint256 gBEXR) = _handlerDataStorage.getGlobalEXR();\n', '\t\t_handlerDataStorage.setUserEXR(userAddr, gDEXR, gBEXR);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the address of the token that the handler is dealing with\n', "\t* (coinHandler don't deal with tokens in coin handlers)\n", '\t* @return The address of the token\n', '\t*/\n', '\tfunction getERC20Addr() external view returns (address)\n', '\t{\n', '\t\treturn address(erc20Instance);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the amount of deposit and borrow of the user\n', '\t* @param userAddr The address of user\n', '\t* (depositAmount, borrowAmount)\n', '\t*/\n', '\tfunction getUserAmount(address payable userAddr) external view override returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 depositAmount = handlerDataStorage.getUserIntraDepositAmount(userAddr);\n', '\t\tuint256 borrowAmount = handlerDataStorage.getUserIntraBorrowAmount(userAddr);\n', '\n', '\t\treturn (depositAmount, borrowAmount);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get the amount of user's deposit\n", '\t* @param userAddr The address of user\n', "\t* @return the amount of user's deposit\n", '\t*/\n', '\tfunction getUserIntraDepositAmount(address payable userAddr) external view returns (uint256)\n', '\t{\n', '\t\treturn handlerDataStorage.getUserIntraDepositAmount(userAddr);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get the amount of user's borrow\n", '\t* @param userAddr The address of user\n', "\t* @return the amount of user's borrow\n", '\t*/\n', '\tfunction getUserIntraBorrowAmount(address payable userAddr) external view returns (uint256)\n', '\t{\n', '\t\treturn handlerDataStorage.getUserIntraBorrowAmount(userAddr);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get the amount of handler's total deposit\n", "\t* @return the amount of handler's total deposit\n", '\t*/\n', '\tfunction getDepositTotalAmount() external view override returns (uint256)\n', '\t{\n', '\t\treturn handlerDataStorage.getDepositTotalAmount();\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get the amount of handler's total borrow\n", "\t* @return the amount of handler's total borrow\n", '\t*/\n', '\tfunction getBorrowTotalAmount() external view override returns (uint256)\n', '\t{\n', '\t\treturn handlerDataStorage.getBorrowTotalAmount();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the amount of deposit and borrow of user including interest\n', '\t* @param userAddr The user address\n', '\t* @return (userDepositAmount, userBorrowAmount)\n', '\t*/\n', '\tfunction getUserAmountWithInterest(address payable userAddr) external view override returns (uint256, uint256)\n', '\t{\n', '\t\treturn _getUserAmountWithInterest(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the address of owner\n', '\t* @return the address of owner\n', '\t*/\n', '\tfunction getOwner() public view returns (address)\n', '\t{\n', '\t\treturn owner;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Check first action of user in the This Block (external)\n', '\t* @return true for first action\n', '\t*/\n', '\tfunction checkFirstAction() onlyMarketManager external override returns (bool)\n', '\t{\n', '\t\treturn _checkFirstAction();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Check first action of user in the This Block (external)\n', '\t* @return true for first action\n', '\t*/\n', '\tfunction _checkFirstAction() internal returns (bool)\n', '\t{\n', '\t\tmarketHandlerDataStorageInterface _handlerDataStorage = handlerDataStorage;\n', '\n', '\t\tuint256 lastUpdatedBlock = _handlerDataStorage.getLastUpdatedBlock();\n', '\t\tuint256 currentBlockNumber = block.number;\n', '\t\tuint256 blockDelta = sub(currentBlockNumber, lastUpdatedBlock);\n', '\n', '\t\tif (blockDelta > 0)\n', '\t\t{\n', '\t\t\t_handlerDataStorage.setBlocks(currentBlockNumber, blockDelta);\n', '\t\t\t_handlerDataStorage.syncActionEXR();\n', '\t\t\treturn true;\n', '\t\t}\n', '\n', '\t\treturn false;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev calculate (apply) interest (internal) and call storage update function\n', '\t* @param userAddr The user address\n', '\t* @return "latest" (userDepositAmount, userBorrowAmount)\n', '\t*/\n', '\tfunction _updateInterestAmount(address payable userAddr) internal returns (uint256, uint256)\n', '\t{\n', '\t\tbool depositNegativeFlag;\n', '\t\tuint256 deltaDepositAmount;\n', '\t\tuint256 globalDepositEXR;\n', '\n', '\t\tbool borrowNegativeFlag;\n', '\t\tuint256 deltaBorrowAmount;\n', '\t\tuint256 globalBorrowEXR;\n', '      /* calculate interest amount and params by call Interest Model */\n', '\t\t(depositNegativeFlag, deltaDepositAmount, globalDepositEXR, borrowNegativeFlag, deltaBorrowAmount, globalBorrowEXR) = interestModelInstance.getInterestAmount(address(handlerDataStorage), userAddr, false);\n', '\n', '\t\t/* update new global EXR to user EXR*/\n', '\t\thandlerDataStorage.setEXR(userAddr, globalDepositEXR, globalBorrowEXR);\n', '\n', '\t\t/* call storage update function for update "latest" interest information  */\n', '\t\treturn _setAmountReflectInterest(userAddr, depositNegativeFlag, deltaDepositAmount, borrowNegativeFlag, deltaBorrowAmount);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Apply the user's interest\n", '\t* @param userAddr The user address\n', '\t* @param depositNegativeFlag the sign of deltaDepositAmount (true for negative)\n', '\t* @param deltaDepositAmount The delta amount of deposit\n', '\t* @param borrowNegativeFlag the sign of deltaBorrowAmount (true for negative)\n', '\t* @param deltaBorrowAmount The delta amount of borrow\n', '\t* @return "latest" (userDepositAmount, userBorrowAmount)\n', '\t*/\n', '\tfunction _setAmountReflectInterest(address payable userAddr, bool depositNegativeFlag, uint256 deltaDepositAmount, bool borrowNegativeFlag, uint256 deltaBorrowAmount) internal returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 userDepositAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\tuint256 userBorrowAmount;\n', '      /* call _getAmountWithInterest for adding user storage amount and interest delta amount (deposit and borrow)*/\n', '\t\t(depositTotalAmount, userDepositAmount, borrowTotalAmount, userBorrowAmount) = _getAmountWithInterest(userAddr, depositNegativeFlag, deltaDepositAmount, borrowNegativeFlag, deltaBorrowAmount);\n', '\n', '\t\t/* update user amount in storage*/\n', '\t\thandlerDataStorage.setAmount(userAddr, depositTotalAmount, borrowTotalAmount, userDepositAmount, userBorrowAmount);\n', '\n', '      /* update "spread between deposits and borrows" */\n', '\t\t_updateReservedAmount(depositNegativeFlag, deltaDepositAmount, borrowNegativeFlag, deltaBorrowAmount);\n', '\n', '\t\treturn (userDepositAmount, userBorrowAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the "latest" user amount of deposit and borrow including interest (internal, view)\n', '\t* @param userAddr The user address\n', '\t* @return "latest" (userDepositAmount, userBorrowAmount)\n', '\t*/\n', '\tfunction _getUserAmountWithInterest(address payable userAddr) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 userDepositAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\tuint256 userBorrowAmount;\n', '\t\t(depositTotalAmount, userDepositAmount, borrowTotalAmount, userBorrowAmount) = _calcAmountWithInterest(userAddr);\n', '\n', '\t\treturn (userDepositAmount, userBorrowAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the "latest" handler amount of deposit and borrow including interest (internal, view)\n', '\t* @param userAddr The user address\n', '\t* @return "latest" (depositTotalAmount, borrowTotalAmount)\n', '\t*/\n', '\tfunction _getTotalAmountWithInterest(address payable userAddr) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 userDepositAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\tuint256 userBorrowAmount;\n', '\t\t(depositTotalAmount, userDepositAmount, borrowTotalAmount, userBorrowAmount) = _calcAmountWithInterest(userAddr);\n', '\n', '\t\treturn (depositTotalAmount, borrowTotalAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev The deposit and borrow amount with interest for the user\n', '\t* @param userAddr The user address\n', '\t* @return "latest" (depositTotalAmount, userDepositAmount, borrowTotalAmount, userBorrowAmount)\n', '\t*/\n', '\tfunction _calcAmountWithInterest(address payable userAddr) internal view returns (uint256, uint256, uint256, uint256)\n', '\t{\n', '\t\tbool depositNegativeFlag;\n', '\t\tuint256 deltaDepositAmount;\n', '\t\tuint256 globalDepositEXR;\n', '\n', '\t\tbool borrowNegativeFlag;\n', '\t\tuint256 deltaBorrowAmount;\n', '\t\tuint256 globalBorrowEXR;\n', '\t\t(depositNegativeFlag, deltaDepositAmount, globalDepositEXR, borrowNegativeFlag, deltaBorrowAmount, globalBorrowEXR) = interestModelInstance.getInterestAmount(address(handlerDataStorage), userAddr, true);\n', '\n', '\t\treturn _getAmountWithInterest(userAddr, depositNegativeFlag, deltaDepositAmount, borrowNegativeFlag, deltaBorrowAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculate "latest" amount with interest for the block delta\n', '\t* @param userAddr The user address\n', '\t* @param depositNegativeFlag the sign of deltaDepositAmount (true for negative)\n', '\t* @param deltaDepositAmount The delta amount of deposit\n', '\t* @param borrowNegativeFlag the sign of deltaBorrowAmount (true for negative)\n', '\t* @param deltaBorrowAmount The delta amount of borrow\n', '\t* @return "latest" (depositTotalAmount, userDepositAmount, borrowTotalAmount, userBorrowAmount)\n', '\t*/\n', '\tfunction _getAmountWithInterest(address payable userAddr, bool depositNegativeFlag, uint256 deltaDepositAmount, bool borrowNegativeFlag, uint256 deltaBorrowAmount) internal view returns (uint256, uint256, uint256, uint256)\n', '\t{\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 userDepositAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\tuint256 userBorrowAmount;\n', '\t\t(depositTotalAmount, borrowTotalAmount, userDepositAmount, userBorrowAmount) = handlerDataStorage.getAmount(userAddr);\n', '\n', '\t\tif (depositNegativeFlag)\n', '\t\t{\n', '\t\t\tdepositTotalAmount = sub(depositTotalAmount, deltaDepositAmount);\n', '\t\t\tuserDepositAmount = sub(userDepositAmount, deltaDepositAmount);\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tdepositTotalAmount = add(depositTotalAmount, deltaDepositAmount);\n', '\t\t\tuserDepositAmount = add(userDepositAmount, deltaDepositAmount);\n', '\t\t}\n', '\n', '\t\tif (borrowNegativeFlag)\n', '\t\t{\n', '\t\t\tborrowTotalAmount = sub(borrowTotalAmount, deltaBorrowAmount);\n', '\t\t\tuserBorrowAmount = sub(userBorrowAmount, deltaBorrowAmount);\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\tborrowTotalAmount = add(borrowTotalAmount, deltaBorrowAmount);\n', '\t\t\tuserBorrowAmount = add(userBorrowAmount, deltaBorrowAmount);\n', '\t\t}\n', '\n', '\t\treturn (depositTotalAmount, userDepositAmount, borrowTotalAmount, userBorrowAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update the amount of the reserve\n', '\t* @param depositNegativeFlag the sign of deltaDepositAmount (true for negative)\n', '\t* @param deltaDepositAmount The delta amount of deposit\n', '\t* @param borrowNegativeFlag the sign of deltaBorrowAmount (true for negative)\n', '\t* @param deltaBorrowAmount The delta amount of borrow\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction _updateReservedAmount(bool depositNegativeFlag, uint256 deltaDepositAmount, bool borrowNegativeFlag, uint256 deltaBorrowAmount) internal returns (bool)\n', '\t{\n', '\t\tint256 signedDeltaDepositAmount = int(deltaDepositAmount);\n', '\t\tint256 signedDeltaBorrowAmount = int(deltaBorrowAmount);\n', '\t\tif (depositNegativeFlag)\n', '\t\t{\n', '\t\t\tsignedDeltaDepositAmount = signedDeltaDepositAmount * (-1);\n', '\t\t}\n', '\n', '\t\tif (borrowNegativeFlag)\n', '\t\t{\n', '\t\t\tsignedDeltaBorrowAmount = signedDeltaBorrowAmount * (-1);\n', '\t\t}\n', '\n', '      /* signedDeltaReservedAmount is singed amount */\n', '\t\tint256 signedDeltaReservedAmount = signedSub(signedDeltaBorrowAmount, signedDeltaDepositAmount);\n', '\t\thandlerDataStorage.updateSignedReservedAmount(signedDeltaReservedAmount);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Sends the handler's assets to the given user\n", '\t* @param userAddr The address of user\n', '\t* @param unifiedTokenAmount The amount of token to send in unified token amount\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction _transfer(address payable userAddr, uint256 unifiedTokenAmount) internal returns (bool)\n', '\t{\n', '\t\tuint256 beforeBalance = erc20Instance.balanceOf(userAddr);\n', '\t\tuint256 underlyingAmount = _convertUnifiedToUnderlying(unifiedTokenAmount);\n', '\n', '\t\terc20Instance.transfer(userAddr, underlyingAmount);\n', '\n', '\t\tuint256 afterBalance = erc20Instance.balanceOf(userAddr);\n', '\t\trequire(underlyingAmount == sub(afterBalance, beforeBalance), TRANSFER);\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Sends the assets from the user to the contract\n', '\t* @param userAddr The address of user\n', '\t* @param unifiedTokenAmount The amount of token to send in unified token amount\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction _transferFrom(address payable userAddr, uint256 unifiedTokenAmount) internal returns (bool)\n', '\t{\n', '\t\tuint256 beforeBalance = erc20Instance.balanceOf(userAddr);\n', '\t\tuint256 underlyingAmount = _convertUnifiedToUnderlying(unifiedTokenAmount);\n', '\n', '\t\terc20Instance.transferFrom(userAddr, address(this), underlyingAmount);\n', '\n', '\t\tuint256 afterBalance = erc20Instance.balanceOf(userAddr);\n', '\t\trequire(underlyingAmount == sub(beforeBalance, afterBalance), TRANSFER);\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Convert amount of handler's unified decimals to amount of token's underlying decimals\n", '\t* @param unifiedTokenAmount The amount of unified decimals\n', '\t* @return (underlyingTokenAmount)\n', '\t*/\n', '\tfunction _convertUnifiedToUnderlying(uint256 unifiedTokenAmount) internal view returns (uint256)\n', '\t{\n', '\t\treturn div(mul(unifiedTokenAmount, underlyingTokenDecimal), unifiedTokenDecimal);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Convert amount of token's underlying decimals to amount of handler's unified decimals\n", '\t* @param underlyingTokenAmount The amount of underlying decimals\n', '\t* @return (unifiedTokenAmount)\n', '\t*/\n', '\tfunction _convertUnderlyingToUnified(uint256 underlyingTokenAmount) internal view returns (uint256)\n', '\t{\n', '\t\treturn div(mul(underlyingTokenAmount, unifiedTokenDecimal), underlyingTokenDecimal);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get (total deposit - total borrow) of the handler\n', '\t* @return (total deposit - total borrow) of the handler\n', '\t*/\n', '\tfunction _getTokenLiquidityAmount() internal view returns (uint256)\n', '\t{\n', '\t\tmarketHandlerDataStorageInterface _handlerDataStorage = handlerDataStorage;\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\t(depositTotalAmount, borrowTotalAmount) = _handlerDataStorage.getHandlerAmount();\n', '\n', '\t\tif (depositTotalAmount == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tif (depositTotalAmount < borrowTotalAmount)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\treturn sub(depositTotalAmount, borrowTotalAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get (total deposit * liquidity limit - total borrow) of the handler\n', '\t* @return (total deposit * liquidity limit - total borrow) of the handler\n', '\t*/\n', '\tfunction _getTokenLiquidityLimitAmount() internal view returns (uint256)\n', '\t{\n', '\t\tmarketHandlerDataStorageInterface _handlerDataStorage = handlerDataStorage;\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\t(depositTotalAmount, borrowTotalAmount) = _handlerDataStorage.getHandlerAmount();\n', '\n', '\t\tif (depositTotalAmount == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 liquidityDeposit = unifiedMul(depositTotalAmount, _handlerDataStorage.getLiquidityLimit());\n', '\t\tif (liquidityDeposit < borrowTotalAmount)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\treturn sub(liquidityDeposit, borrowTotalAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get (total deposit - total borrow) of the handler including interest\n', '\t* @param userAddr The user address(for wrapping function, unused)\n', '\t* @return (total deposit - total borrow) of the handler including interest\n', '\t*/\n', '\tfunction _getTokenLiquidityAmountWithInterest(address payable userAddr) internal view returns (uint256)\n', '\t{\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\t(depositTotalAmount, borrowTotalAmount) = _getTotalAmountWithInterest(userAddr);\n', '\n', '\t\tif (depositTotalAmount == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tif (depositTotalAmount < borrowTotalAmount)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\treturn sub(depositTotalAmount, borrowTotalAmount);\n', '\t}\n', '\t/**\n', '\t* @dev Get (total deposit * liquidity limit - total borrow) of the handler including interest\n', '\t* @param userAddr The user address(for wrapping function, unused)\n', '\t* @return (total deposit * liquidity limit - total borrow) of the handler including interest\n', '\t*/\n', '\tfunction _getTokenLiquidityLimitAmountWithInterest(address payable userAddr) internal view returns (uint256)\n', '\t{\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\t(depositTotalAmount, borrowTotalAmount) = _getTotalAmountWithInterest(userAddr);\n', '\n', '\t\tif (depositTotalAmount == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 liquidityDeposit = unifiedMul(depositTotalAmount, handlerDataStorage.getLiquidityLimit());\n', '\n', '\t\tif (liquidityDeposit < borrowTotalAmount)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\treturn sub(liquidityDeposit, borrowTotalAmount);\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Set the unifiedPoint of token's decimal\n", "\t * @param _unifiedTokenDecimal the unifiedPoint of token's decimal\n", '\t * @return true (TODO: validate results)\n', '\t */\n', '\tfunction setUnifiedTokenDecimal(uint256 _unifiedTokenDecimal) onlyOwner external returns (bool)\n', '\t{\n', '\t\tunifiedTokenDecimal = _unifiedTokenDecimal;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get the decimal of token\n', "\t * @return (uint256, uint256) the decimal of token and the unifiedPoint of token's decimal\n", '\t */\n', '\tfunction getTokenDecimals() external view returns (uint256, uint256)\n', '\t{\n', '\t\treturn (underlyingTokenDecimal, unifiedTokenDecimal);\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Get the unifiedPoint of token's decimal (for fixed decimal number)\n", "\t * @return the unifiedPoint of token's decimal\n", '\t */\n', '\t/* default: UnifiedTokenDecimal Function */\n', '\tfunction getUnifiedTokenDecimal() external view returns (uint256)\n', '\t{\n', '\t\treturn unifiedTokenDecimal;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get the decimal of the underlying token\n', '\t * @return the decimal of the underlying token\n', '\t */\n', '\t/* default: UnderlyingTokenDecimal Function */\n', '\tfunction getUnderlyingTokenDecimal() external view returns (uint256)\n', '\t{\n', '\t\treturn underlyingTokenDecimal;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set the decimal of token\n', '\t * @param _underlyingTokenDecimal the decimal of token\n', '\t * @return true (TODO: validate results)\n', '\t */\n', '\tfunction setUnderlyingTokenDecimal(uint256 _underlyingTokenDecimal) onlyOwner external returns (bool)\n', '\t{\n', '\t\tunderlyingTokenDecimal = _underlyingTokenDecimal;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the address of the marketManager contract\n', '\t* @param marketManagerAddr The address of the marketManager contract\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setMarketManager(address marketManagerAddr) onlyOwner public returns (bool)\n', '\t{\n', '\t\tmarketManager = marketManagerInterface(marketManagerAddr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the address of the interestModel contract\n', '\t* @param interestModelAddr The address of the interestModel contract\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setInterestModel(address interestModelAddr) onlyOwner public returns (bool)\n', '\t{\n', '\t\tinterestModelInstance = interestModelInterface(interestModelAddr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the address of the marketDataStorage contract\n', '\t* @param marketDataStorageAddr The address of the marketDataStorage contract\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setHandlerDataStorage(address marketDataStorageAddr) onlyOwner public returns (bool)\n', '\t{\n', '\t\thandlerDataStorage = marketHandlerDataStorageInterface(marketDataStorageAddr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Set the address and name of the underlying ERC-20 token\n', '\t * @param erc20Addr The address of ERC-20 token\n', '\t * @param name The name of ERC-20 token\n', '\t * @return true (TODO: validate results)\n', '\t */\n', '\tfunction setErc20(address erc20Addr, string memory name) onlyOwner public returns (bool)\n', '\t{\n', '\t\terc20Instance = IERC20(erc20Addr);\n', '\t\ttokenName = name;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the address of the siHandlerDataStorage contract\n', '\t* @param SIHandlerDataStorageAddr The address of the siHandlerDataStorage contract\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setSiHandlerDataStorage(address SIHandlerDataStorageAddr) onlyOwner public returns (bool)\n', '\t{\n', '\t\tSIHandlerDataStorage = marketSIHandlerDataStorageInterface(SIHandlerDataStorageAddr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the address of the siHandlerDataStorage contract\n', '\t* @return The address of the siHandlerDataStorage contract\n', '\t*/\n', '\tfunction getSiHandlerDataStorage() public view returns (address)\n', '\t{\n', '\t\treturn address(SIHandlerDataStorage);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the address of the marketManager contract\n', '\t* @return The address of the marketManager contract\n', '\t*/\n', '\tfunction getMarketManagerAddr() public view returns (address)\n', '\t{\n', '\t\treturn address(marketManager);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the address of the interestModel contract\n', '\t* @return The address of the interestModel contract\n', '\t*/\n', '\tfunction getInterestModelAddr() public view returns (address)\n', '\t{\n', '\t\treturn address(interestModelInstance);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get the address of handler's dataStroage\n", "\t* @return the address of handler's dataStroage\n", '\t*/\n', '\tfunction getHandlerDataStorageAddr() public view returns (address)\n', '\t{\n', '\t\treturn address(handlerDataStorage);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Get the address of the underlying ERC-20 token\n', '\t * @return The address of the underlying ERC-20 token\n', '\t */\n', '\tfunction getErc20Addr() public view returns (address)\n', '\t{\n', '\t\treturn address(erc20Instance);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the outgoing limit of tokens\n', '\t* @return The outgoing limit of tokens\n', '\t*/\n', '\tfunction getLimitOfAction() external view returns (uint256)\n', '\t{\n', '\t\treturn handlerDataStorage.getLimitOfAction();\n', '\t}\n', '\n', '\t/* ******************* Safe Math ******************* */\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "add overflow");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _sub(a, b, "sub overflow");\n', '\t}\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _mul(a, b);\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(a, b, "div by zero");\n', '\t}\n', '\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _mod(a, b, "mod by zero");\n', '\t}\n', '\n', '\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b <= a, errorMessage);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a * b;\n', '\t\trequire((c / a) == b, "mul overflow");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b > 0, errorMessage);\n', '\t\treturn a / b;\n', '\t}\n', '\n', '\tfunction _mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b != 0, errorMessage);\n', '\t\treturn a % b;\n', '\t}\n', '\n', '\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, unifiedPoint), b, "unified div by zero");\n', '\t}\n', '\n', '\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, b), unifiedPoint, "unified mul by zero");\n', '\t}\n', '\n', '\tfunction signedAdd(int256 a, int256 b) internal pure returns (int256)\n', '\t{\n', '\t\tint256 c = a + b;\n', '\t\trequire(((b >= 0) && (c >= a)) || ((b < 0) && (c < a)), "SignedSafeMath: addition overflow");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction signedSub(int256 a, int256 b) internal pure returns (int256)\n', '\t{\n', '\t\tint256 c = a - b;\n', '\t\trequire(((b >= 0) && (c <= a)) || ((b < 0) && (c > a)), "SignedSafeMath: subtraction overflow");\n', '\t\treturn c;\n', '\t}\n', '}']