['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-02\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', 'pragma solidity =0.8.3;\n', '\n', 'interface ERC20 {\n', '    function transfer(address to, uint tokens) external;\n', '    function transferFrom(address from, address to, uint tokens) external;\n', '}\n', '\n', 'abstract contract Rebaser {\n', '    uint public orbiSupplyTotal;\n', '}\n', '\n', 'contract Staking {\n', '\n', '    address public owner;\n', '    address public tokenAddress;\n', '    address public liquidityAddress;\n', '    uint public creationTime;\n', '    uint public totalStakeDepositsToken;\n', '    uint public totalStakeDepositsLiquidity;\n', '    uint public lastRealTokenEmissionToken;\n', '    uint public lastRealTokenEmissionLiquidity;\n', '    uint public rewardPerStakeTotalToken;\n', '    uint public rewardPerStakeTotalLiquidity;\n', '    uint public currentScaleToken;\n', '    uint public currentScaleLiquidity;\n', '    uint public totalRewardsWithdrawnToken;\n', '    uint public totalRewardsWithdrawnLiquidity;\n', '    uint public rewardMax = 1e16;\n', '    uint public previousRewards;\n', '    uint public distributionConstant = 7008000;\n', '    uint public rewardsLastRewardChange;\n', '    uint public timeStakingInit;\n', '    uint public timeFromInitToLastRewardChange;\n', '    address public rebaserAddress = 0x0ac8F269ED3F8ad1bd6d52866d0bF98838b7257F;\n', '    mapping(address => uint) public stakingBalancesToken;\n', '    mapping(address => uint) public stakingBalancesLiquidity;\n', '    mapping(address => uint) public rewardPerStakeInitsToken;\n', '    mapping(address => uint) public rewardPerStakeInitsLiquidity;\n', '    mapping(address => uint) public availableRewardsToken;\n', '    mapping(address => uint) public availableRewardsLiquidity;\n', '\n', '    constructor() {\n', '        creationTime = block.timestamp;\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function changeOwner(address addr) public {\n', '        require(msg.sender == owner, "Only the owner can use this function");\n', '        owner = addr;\n', '    }\n', '\n', '    function rewardTheoretical() public view returns (uint) {\n', '        if (timeStakingInit == 0)\n', '            return 0;\n', '        return rewardMax - (rewardMax - rewardsLastRewardChange) * distributionConstant / (block.timestamp - timeStakingInit + distributionConstant - timeFromInitToLastRewardChange);\n', '    }\n', '    \n', '    function updateRewardFunction(uint newRewardMax, uint newDistributionConstant) public {\n', '        require(msg.sender == owner, "Only the owner can use this function");\n', '        rewardsLastRewardChange = rewardTheoretical();\n', '        distributionConstant = newDistributionConstant;\n', '        rewardMax = newRewardMax;\n', '        timeFromInitToLastRewardChange = block.timestamp - timeStakingInit;\n', '    }\n', '    \n', '    function getTheoreticalTokenEmission(bool tokenOrLiquidity) public view returns(uint) {\n', '        if (tokenOrLiquidity)\n', '            return rewardTheoretical() * 2 / 3;\n', '            //return (1e16 - 1e16 * 3504000 / ((block.timestamp - creationTime) + 3504000)) * 5 / 6;\n', '        return rewardTheoretical() / 3;\n', '        //return (1e16 - 1e16 * 3504000 / ((block.timestamp - creationTime) + 3504000)) / 6;\n', '    }\n', '\n', '    function stake(uint pseudoAmount, bool tokenOrLiquidity) public {\n', '        if (timeStakingInit == 0)\n', '            timeStakingInit = block.timestamp;\n', '        distributeRewards(tokenOrLiquidity);\n', '        if (tokenOrLiquidity) {\n', '            require(stakingBalancesLiquidity[msg.sender] == 0, "Liquidity staking position already exists");\n', '            ERC20(liquidityAddress).transferFrom(msg.sender, address(this), pseudoAmount);\n', '            totalStakeDepositsLiquidity += pseudoAmount;\n', '            stakingBalancesLiquidity[msg.sender] = pseudoAmount;\n', '            rewardPerStakeInitsLiquidity[msg.sender] = rewardPerStakeTotalLiquidity;\n', '            return;\n', '        }\n', '        require(stakingBalancesToken[msg.sender] == 0, "Token staking position already exists");\n', '        uint amount = pseudoAmount;\n', '        ERC20(tokenAddress).transferFrom(msg.sender, address(this), pseudoAmount);\n', '        totalStakeDepositsToken += amount;\n', '        stakingBalancesToken[msg.sender] = amount;\n', '        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\n', '    }\n', '\n', '    function unstake(bool tokenOrLiquidity) public {\n', '        withdraw(tokenOrLiquidity);\n', '        if (tokenOrLiquidity) {\n', '            require(stakingBalancesLiquidity[msg.sender] > 0, "No current liquidity staking position");\n', '            ERC20(liquidityAddress).transfer(msg.sender, stakingBalancesLiquidity[msg.sender]);\n', '            totalStakeDepositsLiquidity -= stakingBalancesLiquidity[msg.sender];\n', '            stakingBalancesLiquidity[msg.sender] = 0;\n', '            return;\n', '        }\n', '        require(stakingBalancesToken[msg.sender] > 0, "No current token staking position");\n', '        ERC20(tokenAddress).transfer(msg.sender, stakingBalancesToken[msg.sender]);\n', '        totalStakeDepositsToken -= stakingBalancesToken[msg.sender];\n', '        stakingBalancesToken[msg.sender] = 0;\n', '    }\n', '\n', '    function withdraw(bool tokenOrLiquidity) public {\n', '        if (tokenOrLiquidity) {\n', '            distributeRewards(tokenOrLiquidity);\n', '            availableRewardsLiquidity[msg.sender] += (rewardPerStakeTotalLiquidity - rewardPerStakeInitsLiquidity[msg.sender]) * stakingBalancesLiquidity[msg.sender] / 10**(currentScaleLiquidity * 18);\n', '            require(stakingBalancesLiquidity[msg.sender] > 0, "No liquidity rewards to withdraw");\n', '            rewardPerStakeInitsLiquidity[msg.sender] = rewardPerStakeTotalLiquidity;\n', '            uint withdrawAmountLiquidity = availableRewardsLiquidity[msg.sender];\n', '            totalRewardsWithdrawnLiquidity += withdrawAmountLiquidity;\n', '            ERC20(tokenAddress).transfer(msg.sender, withdrawAmountLiquidity);\n', '            availableRewardsLiquidity[msg.sender] = 0;\n', '            return;\n', '        }\n', '        distributeRewards(tokenOrLiquidity);\n', '        availableRewardsToken[msg.sender] += (rewardPerStakeTotalToken - rewardPerStakeInitsToken[msg.sender]) * stakingBalancesToken[msg.sender] / 10**(currentScaleToken * 18);\n', '        require(stakingBalancesToken[msg.sender] > 0, "No token rewards to withdraw");\n', '        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\n', '        uint withdrawAmountToken = availableRewardsToken[msg.sender];\n', '        totalRewardsWithdrawnToken += withdrawAmountToken;\n', '        ERC20(tokenAddress).transfer(msg.sender, withdrawAmountToken);\n', '        availableRewardsToken[msg.sender] = 0;\n', '    }\n', '\n', '    function withdrawAll() public {\n', '        withdraw(false);\n', '        withdraw(true);\n', '    }\n', '\n', '    function updatePosition(uint amount, bool tokenOrLiquidity) public {\n', '        unstake(tokenOrLiquidity);\n', '        if (amount > 0)\n', '            stake(amount, tokenOrLiquidity);\n', '    }\n', '\n', '    function distributeRewards(bool tokenOrLiquidity) internal {\n', '        if (tokenOrLiquidity && totalStakeDepositsLiquidity > 0) {\n', '            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionLiquidity;\n', '            if (tokenEmissionDelta != 0) {\n', '                while (totalStakeDepositsLiquidity * 1e18 > tokenEmissionDelta * 10**(currentScaleLiquidity * 18)) {\n', '                    currentScaleLiquidity += 1;\n', '                    rewardPerStakeTotalLiquidity *= 1e18;\n', '                }\n', '                rewardPerStakeTotalLiquidity += tokenEmissionDelta * 10**(currentScaleLiquidity * 18) / totalStakeDepositsLiquidity;\n', '                lastRealTokenEmissionLiquidity = getTheoreticalTokenEmission(tokenOrLiquidity);\n', '            }\n', '        }\n', '        if (!tokenOrLiquidity && totalStakeDepositsToken > 0) {\n', '            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionToken;\n', '            if (tokenEmissionDelta != 0) {\n', '                while (totalStakeDepositsToken * 1e18 > tokenEmissionDelta * 10**(currentScaleToken * 18)) {\n', '                    currentScaleToken += 1;\n', '                    rewardPerStakeTotalToken *= 1e18;\n', '                }\n', '                rewardPerStakeTotalToken += tokenEmissionDelta * 10**(currentScaleToken * 18) / totalStakeDepositsToken;\n', '                lastRealTokenEmissionToken = getTheoreticalTokenEmission(tokenOrLiquidity);\n', '            }\n', '        }\n', '    }\n', '\n', '    function reinvest() public {\n', '        distributeRewards(false);\n', '        availableRewardsToken[msg.sender] += (rewardPerStakeTotalToken - rewardPerStakeInitsToken[msg.sender]) * stakingBalancesToken[msg.sender] / 10**(currentScaleToken * 18);\n', '        require(availableRewardsToken[msg.sender] > 0, "No rewards to reinvest");\n', '        totalRewardsWithdrawnToken += availableRewardsToken[msg.sender];\n', '        totalStakeDepositsToken += availableRewardsToken[msg.sender];\n', '        stakingBalancesToken[msg.sender] += availableRewardsToken[msg.sender];\n', '        availableRewardsToken[msg.sender] = 0;\n', '        rewardPerStakeInitsToken[msg.sender] = rewardPerStakeTotalToken;\n', '    }\n', '\n', '    function getAmountStaked(bool tokenOrLiquidity, address staker) public view returns(uint) {\n', '        if (tokenOrLiquidity)\n', '            return stakingBalancesLiquidity[staker];\n', '        return stakingBalancesToken[staker];\n', '    }\n', '\n', '    function getAvailableRewards(bool tokenOrLiquidity, address staker) public view returns(uint) {\n', '        if (tokenOrLiquidity) {\n', '            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionLiquidity;\n', '            uint pseudoTotalStakeDepositsLiquidity = totalStakeDepositsLiquidity;\n', '            uint pseudoCurrentScaleLiquidity = currentScaleLiquidity;\n', '            uint pseudoRewardPerStakeTotalLiquidity = rewardPerStakeTotalLiquidity;\n', '            if (tokenEmissionDelta != 0) {\n', '                while (pseudoTotalStakeDepositsLiquidity * 1e18 > tokenEmissionDelta * 10**(pseudoCurrentScaleLiquidity * 18)) {\n', '                    pseudoCurrentScaleLiquidity += 1;\n', '                    pseudoRewardPerStakeTotalLiquidity *= 1e18;\n', '                }\n', '                pseudoRewardPerStakeTotalLiquidity += tokenEmissionDelta * 10**(pseudoCurrentScaleLiquidity * 18) / pseudoTotalStakeDepositsLiquidity;\n', '            }\n', '            uint pseudoAvailableRewardsLiquidity = availableRewardsLiquidity[staker] + (pseudoRewardPerStakeTotalLiquidity - rewardPerStakeInitsLiquidity[staker]) * stakingBalancesLiquidity[staker] / 10**(pseudoCurrentScaleLiquidity * 18);\n', '            return pseudoAvailableRewardsLiquidity;\n', '        } else {\n', '            uint tokenEmissionDelta = getTheoreticalTokenEmission(tokenOrLiquidity) - lastRealTokenEmissionToken;\n', '            uint pseudoTotalStakeDepositsToken = totalStakeDepositsToken;\n', '            uint pseudoCurrentScaleToken = currentScaleToken;\n', '            uint pseudoRewardPerStakeTotalToken = rewardPerStakeTotalToken;\n', '            if (tokenEmissionDelta != 0) {\n', '                while (pseudoTotalStakeDepositsToken * 1e18 > tokenEmissionDelta * 10**(pseudoCurrentScaleToken * 18)) {\n', '                    pseudoCurrentScaleToken += 1;\n', '                    pseudoRewardPerStakeTotalToken *= 1e18;\n', '                }\n', '            }\n', '            pseudoRewardPerStakeTotalToken += tokenEmissionDelta * 10**(pseudoCurrentScaleToken * 18) / pseudoTotalStakeDepositsToken;\n', '            uint pseudoAvailableRewardsToken = availableRewardsToken[staker] + (pseudoRewardPerStakeTotalToken - rewardPerStakeInitsToken[staker]) * stakingBalancesToken[staker] / 10**(pseudoCurrentScaleToken * 18);\n', '            return pseudoAvailableRewardsToken;\n', '        }\n', '    }\n', '    \n', '    function getAllAvailableRewards(address staker) public view returns(uint) {\n', '        if (totalStakeDepositsToken > 0 && totalStakeDepositsLiquidity > 0)\n', '            return getAvailableRewards(false, staker) + getAvailableRewards(true, staker);\n', '        if (totalStakeDepositsToken > 0)\n', '            return getAvailableRewards(false, staker);\n', '        if (totalStakeDepositsLiquidity > 0)\n', '            return getAvailableRewards(true, staker);\n', '        return 0;\n', '    }\n', '\n', '    function setToken(address _tokenAddress) public {\n', '        require(msg.sender == owner, "Only the owner can use this function");\n', '        tokenAddress = _tokenAddress;\n', '    }\n', '\n', '    function setLiquidity(address _liquidityAddress) public {\n', '        require(msg.sender == owner, "Only the owner can use this function");\n', '        liquidityAddress = _liquidityAddress;\n', '    }\n', '    \n', '    function CALL(bytes memory data, address _address) public returns (bool success) {\n', '        require(msg.sender == owner, "Only the owner can use this function");\n', '        (success,) = _address.call(data);\n', '        if (!success) revert();\n', '    }\n', '    \n', '    function stakeFor(address staker, uint pseudoAmount, bool tokenOrLiquidity) public {\n', '        if (timeStakingInit == 0)\n', '            timeStakingInit = block.timestamp;\n', '        distributeRewards(tokenOrLiquidity);\n', '        if (tokenOrLiquidity) {\n', '            require(stakingBalancesLiquidity[staker] == 0, "Liquidity staking position already exists");\n', '            ERC20(liquidityAddress).transferFrom(msg.sender, address(this), pseudoAmount);\n', '            totalStakeDepositsLiquidity += pseudoAmount;\n', '            stakingBalancesLiquidity[staker] = pseudoAmount;\n', '            rewardPerStakeInitsLiquidity[staker] = rewardPerStakeTotalLiquidity;\n', '            return;\n', '        }\n', '        require(stakingBalancesToken[staker] == 0, "Token staking position already exists");\n', '        uint amount = pseudoAmount;\n', '        ERC20(tokenAddress).transferFrom(msg.sender, address(this), pseudoAmount);\n', '        totalStakeDepositsToken += amount;\n', '        stakingBalancesToken[staker] = amount;\n', '        rewardPerStakeInitsToken[staker] = rewardPerStakeTotalToken;\n', '    }\n', '\n', '}']