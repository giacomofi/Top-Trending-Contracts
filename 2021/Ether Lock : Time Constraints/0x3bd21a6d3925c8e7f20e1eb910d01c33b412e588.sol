['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-04\n', '*/\n', '\n', '/**\n', '* ROOM Team Token vesting contract\n', '*\n', '* This contract cliffs 10M ROOM tokens for 1 year with 25% vested every 3 months thereafter\n', '*\n', '* ROOM Protocol rewards 38M tokens\n', '* will be transferred to multi-sig wallet (0xd9d9e82dd6042eabb6ea5764217130F8b38d2Bf7) owned by the foundation till May 2021, \n', '* and then transferred to the protocol contract address.\n', '* \n', '* Foundation tokens 14.67M tokens cliffed for 1 year then vested for 25% every 3 months thereafter\n', '* will be transferred to multi-sig wallet (0xc56Ea5CC5eEA2B43632c1Dcb6a3856e75ebFa33b) \n', '* \n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', 'library SafeMath {\n', '    \n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    \n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '\n', '        return c;\n', '    }\n', '    \n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    \n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    \n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '\tevent Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract TokenVestingPools {\n', '    using SafeMath for uint256;\n', '\n', '    struct UserInfo{\n', '        uint256 lockedAmount;\n', '        uint256 withdrawn;\n', '    }\n', '\n', '    struct PoolInfo{\n', '        uint256 startReleasingTime;\n', '        uint256 batchPeriod;\n', '        uint256 batchCount;\n', '        uint256 totalLocked;\n', '        uint8 index;\n', '        string name;\n', '    }\n', '    \n', '    IERC20 public lockedToken;\n', '    \n', '    PoolInfo[] public lockPools;\n', '    \n', '    mapping (uint8 => mapping (address => UserInfo)) internal userInfo;\n', '\n', '    event Claim(uint8 pid, address indexed beneficiary, uint value);\n', '\n', '\n', '    constructor(address _token) internal{\n', '        lockedToken = IERC20(_token);\n', '    }\n', '\n', '    function _addVestingPool(string memory _name, uint256 _startReleasingTime, uint256 _batchCount,  uint256 _batchPeriod) internal returns(uint8){\n', '        \n', '        lockPools.push(PoolInfo({\n', '            name: _name,\n', '            startReleasingTime: _startReleasingTime,\n', '            batchPeriod: _batchPeriod,\n', '            batchCount: _batchCount,\n', '            totalLocked:0,\n', '            index:(uint8)(lockPools.length)\n', '        }));\n', '\n', '        return (uint8)(lockPools.length) -1;\n', '    }\n', '\n', '    function _addBeneficiary(uint8 _pid, address _beneficiary, uint256 _lockedTokensCount) internal{\n', '\n', '        require(_pid < lockPools.length, "non existing pool");\n', '        require(userInfo[_pid][_beneficiary].lockedAmount == 0, "existing beneficiary"); //can add Beneficiary only once to a pool\n', '\n', '        userInfo[_pid][_beneficiary].lockedAmount = _lockedTokensCount * 1e18;\n', '        lockPools[_pid].totalLocked = lockPools[_pid].totalLocked.add(userInfo[_pid][_beneficiary].lockedAmount);\n', '    }\n', '\n', '     function claim(uint8 _pid) public returns(uint256 amount){\n', '\n', '        // require(_pid < LockPoolsCount, "Can not claim from non existing pool"); // no need since getReleasableAmount will return 0\n', '\n', '        amount = getReleasableAmount(_pid, msg.sender);\n', '        require (amount > 0, "can not claimed 0 amount");\n', '\n', '        userInfo[_pid][msg.sender].withdrawn = userInfo[_pid][msg.sender].withdrawn.add(amount);\n', '\n', '        lockedToken.transfer(msg.sender,amount);\n', '        \n', '        emit Claim(_pid, msg.sender, amount);\n', '    }\n', '\n', '    function getReleasableAmount(uint8 _pid, address _beneficiary) public  view returns(uint256){\n', '        return getVestedAmount(_pid, _beneficiary, getCurrentTime()).sub(userInfo[_pid][_beneficiary].withdrawn);\n', '    }\n', '\n', '\n', '    function getVestedAmount(uint8 _pid, address _beneficiary, uint256 _time) public  view returns(uint256){\n', '\n', '        if (_pid >= lockPools.length){\n', '            return 0;\n', '        }\n', '\n', '        // if time < StartReleasingTime: then return 0\n', '        if(_time < lockPools[_pid].startReleasingTime){\n', '            return 0;\n', '        }\n', '\n', '        uint256 lockedAmount = userInfo[_pid][_beneficiary].lockedAmount;\n', '\n', '        // if locked amount 0 return 0\n', '        if (lockedAmount == 0){\n', '            return 0;\n', '        }\n', '\n', '        // elapsedBatchCount = ((time - startReleasingTime) / batchPeriod) + 1\n', '        uint256 elapsedBatchCount =\n', '                    _time.sub(lockPools[_pid].startReleasingTime)\n', '                    .div(lockPools[_pid].batchPeriod)\n', '                    .add(1);\n', '\n', '        // vestedAmount = lockedAmount  * elapsedBatchCount / batchCount\n', '        uint256  vestedAmount =\n', '                    lockedAmount\n', '                    .mul(elapsedBatchCount)\n', '                    .div(lockPools[_pid].batchCount);\n', '\n', '        if(vestedAmount > lockedAmount){\n', '            vestedAmount = lockedAmount;\n', '        }\n', '\n', '        return vestedAmount;\n', '    }\n', '\n', '    function getBeneficiaryInfo(uint8 _pid, address _beneficiary) public view \n', '        returns(address beneficiary, \n', '                uint256 totalLocked, \n', '                uint256 withdrawn, \n', '                uint256 releasableAmount, \n', '                uint256 nextBatchTime, \n', '                uint256 currentTime){\n', '\n', '        beneficiary = _beneficiary;\n', '        currentTime = getCurrentTime();\n', '        if(_pid < lockPools.length){\n', '            totalLocked = userInfo[_pid][_beneficiary].lockedAmount;\n', '            withdrawn = userInfo[_pid][_beneficiary].withdrawn;\n', '            releasableAmount = getReleasableAmount(_pid, _beneficiary);\n', '            nextBatchTime = getNextBatchTime(_pid, _beneficiary, currentTime);\n', '        }\n', '    }\n', '\n', '    function getSenderInfo(uint8 _pid) external view returns(address beneficiary, uint256 totalLocked, uint256 withdrawaned, uint256 releasableAmount, uint256 nextBatchTime, uint256 currentTime){\n', '        return getBeneficiaryInfo(_pid, msg.sender);\n', '    }\n', '\n', '    function getNextBatchTime(uint8 _pid, address _beneficiary, uint256 _time) public view returns(uint256){\n', '\n', '        // if total vested equal to total locked then return 0\n', '        if(getVestedAmount(_pid, _beneficiary, _time) == userInfo[_pid][_beneficiary].lockedAmount){\n', '            return 0;\n', '        }\n', '\n', '        // if time less than startReleasingTime: then return sartReleasingTime\n', '        if(_time <= lockPools[_pid].startReleasingTime){\n', '            return lockPools[_pid].startReleasingTime;\n', '        }\n', '\n', '        // find the next batch time\n', '         uint256 elapsedBatchCount =\n', '                    _time.sub(lockPools[_pid].startReleasingTime)\n', '                    .div(lockPools[_pid].batchPeriod)\n', '                    .add(1);\n', '\n', '        uint256 nextBatchTime =\n', '                    elapsedBatchCount\n', '                    .mul(lockPools[_pid].batchPeriod)\n', '                    .add(lockPools[_pid].startReleasingTime);\n', '\n', '        return nextBatchTime;\n', '\n', '    }\n', '\n', '    function getPoolsCount() external view returns(uint256 poolsCount){\n', '        return lockPools.length;\n', '    }\n', '\n', '    function getPoolInfo(uint8 _pid) external view returns(\n', '                string memory name,\n', '                uint256 totalLocked,\n', '                uint256  startReleasingTime,\n', '                uint256  batchCount,\n', '                uint256  batchPeriodInDays){\n', '                    \n', '        if(_pid < lockPools.length){\n', '            name = lockPools[_pid].name;\n', '            totalLocked = lockPools[_pid].totalLocked;\n', '            startReleasingTime = lockPools[_pid].startReleasingTime;\n', '            batchCount = lockPools[_pid].batchCount;\n', '            batchPeriodInDays = lockPools[_pid].batchPeriod.div(1 days);\n', '        }\n', '    }\n', '\n', '    function getTotalLocked() external view returns(uint256 totalLocked){\n', '        totalLocked =0;\n', '\n', '        for(uint8 i=0; i<lockPools.length; i++){\n', '            totalLocked = totalLocked.add(lockPools[i].totalLocked);\n', '        }\n', '    }\n', '\n', '    function getCurrentTime() public view returns(uint256){\n', '        return block.timestamp;\n', '    }\n', '}\n', '\n', '\n', 'contract RoomTeamLock is TokenVestingPools{\n', '\n', '    constructor () public TokenVestingPools(0xAd4f86a25bbc20FfB751f2FAC312A0B4d8F88c64){\n', '\n', '\t   // check https://www.epochconverter.com/ for timestamp\n', '\n', '\t   // Team tokens (10M) locked till Jan 01, 2022\n', '\t   // and will be relesed each 3 months by 25%\n', '\t   // 1640995200= January 1, 2022 12:00:00 AM GMT\n', '\t   // team tokens: 10,000,000 Token\n', '\t   uint8 teamLockPool = _addVestingPool("Team Lock" , 1640995200, 4, 90 days); \n', '\n', '\t   _addBeneficiary(teamLockPool, 0x4608f8245258e93aF27A15f9fBA17515149f4435,4000000); // 4,000,000 Tokens\n', '\t   _addBeneficiary(teamLockPool, 0x5a4D85F03d9C45907617bABcDc7f4C5599c4cE19,2000000); // 2,000,000 Tokens\n', '\t   _addBeneficiary(teamLockPool, 0x28eFeB6bf726bc9b1b2b989Cada5D9C95CfBb38C,1333334); // 1,333,334 Tokens\n', '\t   _addBeneficiary(teamLockPool, 0x971945b040B126dCe5aD2982FBD2a72d4Ba3966c,1333333); // 1,333,333 Tokens\n', '\t   _addBeneficiary(teamLockPool, 0xd558D2A872185C64DE4BF2a63Ad0Bc307f861997,1333333); // 1,333,333 Tokens\n', '    }\n', '\t\n', '}']