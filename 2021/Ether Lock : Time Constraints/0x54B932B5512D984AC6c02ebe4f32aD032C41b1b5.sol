['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-17\n', '*/\n', '\n', '// File: contracts/interfaces/ILiquidationManager.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's liquidation manager interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface ILiquidationManager  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\tfunction partialLiquidation(address payable delinquentBorrower, uint256 targetHandler, uint256 liquidateAmount, uint256 receiveHandler) external returns (uint256);\n', '\tfunction checkLiquidation(address payable userAddr) external view returns (bool);\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', 'pragma solidity ^0.6.12;\n', '\n', '// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n', '// Subject to the MIT license.\n', '\n', '/**\n', " * @title BiFi's safe-math Contract\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'library SafeMath {\n', '  uint256 internal constant unifiedPoint = 10 ** 18;\n', '\t/******************** Safe Math********************/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "a");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _sub(a, b, "s");\n', '\t}\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _mul(a, b);\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(a, b, "d");\n', '\t}\n', '\n', '\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b <= a, errorMessage);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a* b;\n', '\t\trequire((c / a) == b, "m");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b > 0, errorMessage);\n', '\t\treturn a / b;\n', '\t}\n', '\n', '\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, unifiedPoint), b, "d");\n', '\t}\n', '\n', '\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, b), unifiedPoint, "m");\n', '\t}\n', '}\n', '\n', '// File: contracts/interfaces/IManagerDataStorage.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's manager data storage interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IManagerDataStorage  {\n', '\tfunction getGlobalRewardPerBlock() external view returns (uint256);\n', '\tfunction setGlobalRewardPerBlock(uint256 _globalRewardPerBlock) external returns (bool);\n', '\n', '\tfunction getGlobalRewardDecrement() external view returns (uint256);\n', '\tfunction setGlobalRewardDecrement(uint256 _globalRewardDecrement) external returns (bool);\n', '\n', '\tfunction getGlobalRewardTotalAmount() external view returns (uint256);\n', '\tfunction setGlobalRewardTotalAmount(uint256 _globalRewardTotalAmount) external returns (bool);\n', '\n', '\tfunction getAlphaRate() external view returns (uint256);\n', '\tfunction setAlphaRate(uint256 _alphaRate) external returns (bool);\n', '\n', '\tfunction getAlphaLastUpdated() external view returns (uint256);\n', '\tfunction setAlphaLastUpdated(uint256 _alphaLastUpdated) external returns (bool);\n', '\n', '\tfunction getRewardParamUpdateRewardPerBlock() external view returns (uint256);\n', '\tfunction setRewardParamUpdateRewardPerBlock(uint256 _rewardParamUpdateRewardPerBlock) external returns (bool);\n', '\n', '\tfunction getRewardParamUpdated() external view returns (uint256);\n', '\tfunction setRewardParamUpdated(uint256 _rewardParamUpdated) external returns (bool);\n', '\n', '\tfunction getInterestUpdateRewardPerblock() external view returns (uint256);\n', '\tfunction setInterestUpdateRewardPerblock(uint256 _interestUpdateRewardPerblock) external returns (bool);\n', '\n', '\tfunction getInterestRewardUpdated() external view returns (uint256);\n', '\tfunction setInterestRewardUpdated(uint256 _interestRewardLastUpdated) external returns (bool);\n', '\n', '\tfunction setTokenHandler(uint256 handlerID, address handlerAddr) external returns (bool);\n', '\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address);\n', '\n', '\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\n', '\n', '\tfunction getTokenHandlerAddr(uint256 handlerID) external view returns (address);\n', '\tfunction setTokenHandlerAddr(uint256 handlerID, address handlerAddr) external returns (bool);\n', '\n', '\tfunction getTokenHandlerExist(uint256 handlerID) external view returns (bool);\n', '\tfunction setTokenHandlerExist(uint256 handlerID, bool exist) external returns (bool);\n', '\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\n', '\tfunction setTokenHandlerSupport(uint256 handlerID, bool support) external returns (bool);\n', '\n', '\tfunction setLiquidationManagerAddr(address _liquidationManagerAddr) external returns (bool);\n', '\tfunction getLiquidationManagerAddr() external view returns (address);\n', '\n', '\tfunction setManagerAddr(address _managerAddr) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IOracleProxy.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's oracle proxy interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IOracleProxy  {\n', '\tfunction getTokenPrice(uint256 tokenID) external view returns (uint256);\n', '\n', '\tfunction getOracleFeed(uint256 tokenID) external view returns (address, uint256);\n', '\tfunction setOracleFeed(uint256 tokenID, address feedAddr, uint256 decimals, bool needPriceConvert, uint256 priceConvertID) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n', 'pragma solidity 0.6.12;\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external ;\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external ;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/interfaces/IObserver.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's Observer interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IObserver {\n', '    function getAlphaBaseAsset() external view returns (uint256[] memory);\n', '    function setChainGlobalRewardPerblock(uint256 _idx, uint256 globalRewardPerBlocks) external returns (bool);\n', '    function updateChainMarketInfo(uint256 _idx, uint256 chainDeposit, uint256 chainBorrow) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IProxy.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's proxy interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IProxy  {\n', '\tfunction handlerProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction handlerViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '\tfunction siProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction siViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '}\n', '\n', '// File: contracts/interfaces/IMarketHandler.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's market handler interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IMarketHandler  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\tfunction setCircuitBreakWithOwner(bool _emergency) external returns (bool);\n', '\n', '\tfunction getTokenName() external view returns (string memory);\n', '\n', '\tfunction ownershipTransfer(address payable newOwner) external returns (bool);\n', '\n', '\tfunction deposit(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\tfunction withdraw(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction borrow(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction repay(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\n', '\tfunction executeFlashloan(\n', '\t\taddress receiverAddress,\n', '\t\tuint256 amount\n', '  ) external returns (bool);\n', '\n', '\tfunction depositFlashloanFee(\n', '\t\tuint256 amount\n', '\t) external returns (bool);\n', '\n', '  function convertUnifiedToUnderlying(uint256 unifiedTokenAmount) external view returns (uint256);\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) external returns (uint256);\n', '\n', '\tfunction getTokenHandlerLimit() external view returns (uint256, uint256);\n', '  function getTokenHandlerBorrowLimit() external view returns (uint256);\n', '\tfunction getTokenHandlerMarginCallLimit() external view returns (uint256);\n', '\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) external returns (bool);\n', '\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) external returns (bool);\n', '\n', '  function getTokenLiquidityAmountWithInterest(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction getUserAmountWithInterest(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserMaxBorrowAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxRepayAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction checkFirstAction() external returns (bool);\n', '\tfunction applyInterest(address payable userAddr) external returns (uint256, uint256);\n', '\n', '\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable returns (bool);\n', '\tfunction reserveWithdraw(uint256 unifiedTokenAmount) external returns (bool);\n', '\n', '\tfunction withdrawFlashloanFee(uint256 unifiedTokenAmount) external returns (bool);\n', '\n', '\tfunction getDepositTotalAmount() external view returns (uint256);\n', '\tfunction getBorrowTotalAmount() external view returns (uint256);\n', '\n', '\tfunction getSIRandBIR() external view returns (uint256, uint256);\n', '\n', '  function getERC20Addr() external view returns (address);\n', '}\n', '\n', '// File: contracts/interfaces/IServiceIncentive.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's si interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IServiceIncentive  {\n', '\tfunction setCircuitBreakWithOwner(bool emergency) external returns (bool);\n', '\tfunction setCircuitBreaker(bool emergency) external returns (bool);\n', '\n', '\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) external returns (bool);\n', '\tfunction updateRewardLane(address payable userAddr) external returns (bool);\n', '\n', '\tfunction getBetaRateBaseTotalAmount() external view returns (uint256);\n', '\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction getUserRewardInfo(address payable userAddr) external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction claimRewardAmountUser(address payable userAddr) external returns (uint256);\n', '}\n', '\n', '// File: contracts/Errors.sol\n', 'pragma solidity 0.6.12;\n', '\n', 'contract Modifier {\n', '    string internal constant ONLY_OWNER = "O";\n', '    string internal constant ONLY_MANAGER = "M";\n', '    string internal constant CIRCUIT_BREAKER = "emergency";\n', '}\n', '\n', 'contract ManagerModifier is Modifier {\n', '    string internal constant ONLY_HANDLER = "H";\n', '    string internal constant ONLY_LIQUIDATION_MANAGER = "LM";\n', '    string internal constant ONLY_BREAKER = "B";\n', '}\n', '\n', 'contract HandlerDataStorageModifier is Modifier {\n', '    string internal constant ONLY_BIFI_CONTRACT = "BF";\n', '}\n', '\n', 'contract SIDataStorageModifier is Modifier {\n', '    string internal constant ONLY_SI_HANDLER = "SI";\n', '}\n', '\n', 'contract HandlerErrors is Modifier {\n', '    string internal constant USE_VAULE = "use value";\n', '    string internal constant USE_ARG = "use arg";\n', '    string internal constant EXCEED_LIMIT = "exceed limit";\n', '    string internal constant NO_LIQUIDATION = "no liquidation";\n', '    string internal constant NO_LIQUIDATION_REWARD = "no enough reward";\n', '    string internal constant NO_EFFECTIVE_BALANCE = "not enough balance";\n', '    string internal constant TRANSFER = "err transfer";\n', '}\n', '\n', 'contract SIErrors is Modifier { }\n', '\n', 'contract InterestErrors is Modifier { }\n', '\n', 'contract LiquidationManagerErrors is Modifier {\n', '    string internal constant NO_DELINQUENT = "not delinquent";\n', '}\n', '\n', 'contract ManagerErrors is ManagerModifier {\n', '    string internal constant REWARD_TRANSFER = "RT";\n', '    string internal constant UNSUPPORTED_TOKEN = "UT";\n', '}\n', '\n', 'contract OracleProxyErrors is Modifier {\n', '    string internal constant ZERO_PRICE = "price zero";\n', '}\n', '\n', 'contract RequestProxyErrors is Modifier { }\n', '\n', 'contract ManagerDataStorageErrors is ManagerModifier {\n', '    string internal constant NULL_ADDRESS = "err addr null";\n', '}\n', '\n', '// File: contracts/marketManager/ManagerSlot.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's Slot contract\n", ' * @notice Manager Slot Definitions & Allocations\n', ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'contract ManagerSlot is ManagerErrors {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public owner;\n', '\tmapping(address => bool) operators;\n', '\tmapping(address => Breaker) internal breakerTable;\n', '\n', '\tbool public emergency = false;\n', '\n', '\tIManagerDataStorage internal dataStorageInstance;\n', '\tIOracleProxy internal oracleProxy;\n', '\n', '\t/* feat: manager reward token instance*/\n', '\tIERC20 internal rewardErc20Instance;\n', '\n', '\tIObserver public Observer;\n', '\n', '\taddress public slotSetterAddr;\n', '\taddress public handlerManagerAddr;\n', '\taddress public flashloanAddr;\n', '\n', '  // BiFi-X\n', '  address public positionStorageAddr;\n', '  address public nftAddr;\n', '\n', '\tuint256 public tokenHandlerLength;\n', '\n', '  struct FeeRateParams {\n', '    uint256 unifiedPoint;\n', '    uint256 minimum;\n', '    uint256 slope;\n', '    uint256 discountRate;\n', '  }\n', '\n', '  struct HandlerFlashloan {\n', '      uint256 flashFeeRate;\n', '      uint256 discountBase;\n', '      uint256 feeTotal;\n', '  }\n', '\n', '  mapping(uint256 => HandlerFlashloan) public handlerFlashloan;\n', '\n', '\tstruct UserAssetsInfo {\n', '\t\tuint256 depositAssetSum;\n', '\t\tuint256 borrowAssetSum;\n', '\t\tuint256 marginCallLimitSum;\n', '\t\tuint256 depositAssetBorrowLimitSum;\n', '\t\tuint256 depositAsset;\n', '\t\tuint256 borrowAsset;\n', '\t\tuint256 price;\n', '\t\tuint256 callerPrice;\n', '\t\tuint256 depositAmount;\n', '\t\tuint256 borrowAmount;\n', '\t\tuint256 borrowLimit;\n', '\t\tuint256 marginCallLimit;\n', '\t\tuint256 callerBorrowLimit;\n', '\t\tuint256 userBorrowableAsset;\n', '\t\tuint256 withdrawableAsset;\n', '\t}\n', '\n', '\tstruct Breaker {\n', '\t\tbool auth;\n', '\t\tbool tried;\n', '\t}\n', '\n', '\tstruct ContractInfo {\n', '\t\tbool support;\n', '\t\taddress addr;\n', '    address tokenAddr;\n', '\n', '    uint256 expectedBalance;\n', '    uint256 afterBalance;\n', '\n', '\t\tIProxy tokenHandler;\n', '\t\tbytes data;\n', '\n', '\t\tIMarketHandler handlerFunction;\n', '\t\tIServiceIncentive siFunction;\n', '\n', '\t\tIOracleProxy oracleProxy;\n', '\t\tIManagerDataStorage managerDataStorage;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner, ONLY_OWNER);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyHandler(uint256 handlerID) {\n', '\t\t_isHandler(handlerID);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyOperators {\n', '\t\taddress payable sender = msg.sender;\n', '\t\trequire(operators[sender] || sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isHandler(uint256 handlerID) internal view {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == dataStorageInstance.getTokenHandlerAddr(handlerID)) || (msgSender == owner), ONLY_HANDLER);\n', '\t}\n', '\n', '\tmodifier onlyLiquidationManager {\n', '\t\t_isLiquidationManager();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isLiquidationManager() internal view {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == dataStorageInstance.getLiquidationManagerAddr()) || (msgSender == owner), ONLY_LIQUIDATION_MANAGER);\n', '\t}\n', '\n', '\tmodifier circuitBreaker {\n', '\t\t_isCircuitBreak();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isCircuitBreak() internal view {\n', '\t\trequire((!emergency) || (msg.sender == owner), CIRCUIT_BREAKER);\n', '\t}\n', '\n', '\tmodifier onlyBreaker {\n', '\t\t_isBreaker();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isBreaker() internal view {\n', '\t\trequire(breakerTable[msg.sender].auth, ONLY_BREAKER);\n', '\t}\n', '}\n', '\n', '// File: contracts/context/BlockContext.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's BlockContext contract\n", ' * @notice BiFi getter Contract for Block Context Information\n', ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'contract BlockContext {\n', '    function _blockContext() internal view returns(uint256 context) {\n', '        // block number chain\n', '        // context = block.number;\n', '\n', '        // block timestamp chain\n', '        context = block.timestamp;\n', '    }\n', '}\n', '\n', '// File: contracts/marketManager/HandlerManager.sol\n', '// SPDX-License-Identifier: BSD-3-Clause\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's HandlerManager contract\n", ' * @notice BiFi Market Manager Business Logics(Interest, Incentive)\n', ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'contract HandlerManager is ManagerSlot, BlockContext {\n', '\n', '\tevent HandlerRewardUpdate(uint256 handlerID, uint256 alphaBaseAsset, uint256 rewardPerBlocks);\n', '\tevent ChainRewardUpdate(uint256 chainID, uint256 alphaBaseAsset, uint256 rewardPerBlocks);\n', '\n', '  /**\n', '\t* @dev Update interest of a user for a handler (internal)\n', '\t* @param userAddr The user address\n', '\t* @param callerID The handler ID\n', '\t* @param allFlag Flag for the full calculation mode (calculting for all handlers)\n', '\t* @return (uint256, uint256, uint256, uint256, uint256, uint256)\n', '\t*/\n', '\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256, uint256, uint256, uint256)\n', '\t{\n', '\t\tUserAssetsInfo memory userAssetsInfo;\n', '\t\tContractInfo memory handlerInfo;\n', '\t\thandlerInfo.oracleProxy = oracleProxy;\n', '\t\thandlerInfo.managerDataStorage = dataStorageInstance;\n', '\n', '\t\t/* From all handlers, get the token price, margin call limit, borrow limit */\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\t(handlerInfo.support, handlerInfo.addr) = handlerInfo.managerDataStorage.getTokenHandlerInfo(handlerID);\n', '\t\t\tif (handlerInfo.support)\n', '\t\t\t{\n', '\t\t\t\thandlerInfo.tokenHandler = IProxy(handlerInfo.addr);\n', '\n', '\t\t\t\t/* If the full-calculation mode is not set, work on the given handler only */\n', '\t\t\t\tif ((handlerID == callerID) || allFlag)\n', '\t\t\t\t{\n', '\t\t\t\t\thandlerInfo.tokenHandler.siProxy(\n', '\t\t\t\t\t\tabi.encodeWithSelector(\n', '\t\t\t\t\t\t\thandlerInfo.siFunction\n', '\t\t\t\t\t\t\t.updateRewardLane.selector,\n', '\t\t\t\t\t\t\tuserAddr\n', '\t\t\t\t\t\t)\n', '\t\t\t\t\t);\n', '\t\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerProxy(\n', '\t\t\t\t\t\tabi.encodeWithSelector(\n', '\t\t\t\t\t\t\thandlerInfo.handlerFunction\n', '\t\t\t\t\t\t\t.applyInterest.selector,\n', '\t\t\t\t\t\t\tuserAddr\n', '\t\t\t\t\t\t)\n', '\t\t\t\t\t);\n', '\n', '\t\t\t\t\t(userAssetsInfo.depositAmount, userAssetsInfo.borrowAmount) = abi.decode(handlerInfo.data, (uint256, uint256));\n', '\t\t\t\t}\n', '\t\t\t\telse\n', '\t\t\t\t{\n', '\t\t\t\t\t/* Get the deposit and borrow amount for the user */\n', '\t\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy(\n', '\t\t\t\t\t\tabi.encodeWithSelector(\n', '\t\t\t\t\t\t\thandlerInfo.handlerFunction\n', '\t\t\t\t\t\t\t.getUserAmount.selector,\n', '\t\t\t\t\t\t\tuserAddr\n', '\t\t\t\t\t\t)\n', '\t\t\t\t\t);\n', '\t\t\t\t\t(userAssetsInfo.depositAmount, userAssetsInfo.borrowAmount) = abi.decode(handlerInfo.data, (uint256, uint256));\n', '\t\t\t\t}\n', '\n', '\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy(\n', '\t\t\t\t\tabi.encodeWithSelector(\n', '\t\t\t\t\t\thandlerInfo.handlerFunction\n', '\t\t\t\t\t\t.getTokenHandlerLimit.selector\n', '\t\t\t\t\t)\n', '\t\t\t\t);\n', '\t\t\t\t(userAssetsInfo.borrowLimit, userAssetsInfo.marginCallLimit) = abi.decode(handlerInfo.data, (uint256, uint256));\n', '\n', '\t\t\t\t/* Get the token price */\n', '\t\t\t\tif (handlerID == callerID)\n', '\t\t\t\t{\n', '\t\t\t\t\tuserAssetsInfo.price = handlerInfo.oracleProxy.getTokenPrice(handlerID);\n', '\t\t\t\t\tuserAssetsInfo.callerPrice = userAssetsInfo.price;\n', '\t\t\t\t\tuserAssetsInfo.callerBorrowLimit = userAssetsInfo.borrowLimit;\n', '\t\t\t\t}\n', '\n', '\t\t\t\t/* If the user has no balance, the token handler can be ignored.*/\n', '\t\t\t\tif ((userAssetsInfo.depositAmount > 0) || (userAssetsInfo.borrowAmount > 0))\n', '\t\t\t\t{\n', '\t\t\t\t\tif (handlerID != callerID)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuserAssetsInfo.price = handlerInfo.oracleProxy.getTokenPrice(handlerID);\n', '\t\t\t\t\t}\n', '\n', '\t\t\t\t\t/* Compute the deposit parameters */\n', '\t\t\t\t\tif (userAssetsInfo.depositAmount > 0)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuserAssetsInfo.depositAsset = userAssetsInfo.depositAmount.unifiedMul(userAssetsInfo.price);\n', '\t\t\t\t\t\tuserAssetsInfo.depositAssetBorrowLimitSum = userAssetsInfo.depositAssetBorrowLimitSum.add(userAssetsInfo.depositAsset.unifiedMul(userAssetsInfo.borrowLimit));\n', '\t\t\t\t\t\tuserAssetsInfo.marginCallLimitSum = userAssetsInfo.marginCallLimitSum.add(userAssetsInfo.depositAsset.unifiedMul(userAssetsInfo.marginCallLimit));\n', '\t\t\t\t\t\tuserAssetsInfo.depositAssetSum = userAssetsInfo.depositAssetSum.add(userAssetsInfo.depositAsset);\n', '\t\t\t\t\t}\n', '\n', '\t\t\t\t\t/* Compute the borrow parameters */\n', '\t\t\t\t\tif (userAssetsInfo.borrowAmount > 0)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuserAssetsInfo.borrowAsset = userAssetsInfo.borrowAmount.unifiedMul(userAssetsInfo.price);\n', '\t\t\t\t\t\tuserAssetsInfo.borrowAssetSum = userAssetsInfo.borrowAssetSum.add(userAssetsInfo.borrowAsset);\n', '\t\t\t\t\t}\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tif (userAssetsInfo.depositAssetBorrowLimitSum > userAssetsInfo.borrowAssetSum)\n', '\t\t{\n', '\t\t\t/* Set the amount that the user can borrow from the borrow limit and previous borrows. */\n', '\t\t\tuserAssetsInfo.userBorrowableAsset = userAssetsInfo.depositAssetBorrowLimitSum.sub(userAssetsInfo.borrowAssetSum);\n', '\n', '\t\t\t/* Set the allowed amount that the user can withdraw based on the user borrow */\n', '\t\t\tuserAssetsInfo.withdrawableAsset = userAssetsInfo.depositAssetBorrowLimitSum.sub(userAssetsInfo.borrowAssetSum).unifiedDiv(userAssetsInfo.callerBorrowLimit);\n', '\t\t}\n', '\n', '\t\t/* Return the calculated parameters */\n', '\t\treturn (userAssetsInfo.userBorrowableAsset.unifiedDiv(userAssetsInfo.callerPrice), userAssetsInfo.withdrawableAsset.unifiedDiv(userAssetsInfo.callerPrice), userAssetsInfo.marginCallLimitSum, userAssetsInfo.depositAssetSum, userAssetsInfo.borrowAssetSum, userAssetsInfo.callerPrice);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Reward the user (msg.sender) with the reward token after calculating interest.\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction interestUpdateReward() external returns (bool)\n', '\t{\n', '\t\tuint256 thisBlock = _blockContext();\n', '\t\tuint256 interestRewardUpdated = dataStorageInstance.getInterestRewardUpdated();\n', '\t\tuint256 delta = thisBlock - interestRewardUpdated;\n', '\t\tif (delta == 0)\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\n', '\t\tdataStorageInstance.setInterestRewardUpdated(thisBlock);\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tIProxy tokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\t\tbytes memory data;\n', '\t\t\t(, data) = tokenHandler.handlerProxy(\n', '\t\t\t\tabi.encodeWithSelector(\n', '\t\t\t\t\tIMarketHandler\n', '\t\t\t\t\t.checkFirstAction.selector\n', '\t\t\t\t)\n', '\t\t\t);\n', '\t\t}\n', '\n', '\t\t/* transfer reward tokens */\n', '\t\treturn _rewardTransfer(msg.sender, delta.mul(dataStorageInstance.getInterestUpdateRewardPerblock()));\n', '\t}\n', '\n', ' /**\n', '\t* @dev (Update operation) update the rewards parameters.\n', '\t* @param userAddr The address of operator\n', '\t* @return Whether or not the operation succeed\n', '\t*/\n', '\tfunction updateRewardParams(address payable userAddr) onlyOperators external returns (bool)\n', '\t{\n', '\t\tif (_determineRewardParams(userAddr))\n', '\t\t{\n', '\t\t\treturn _calcRewardParams(userAddr);\n', '\t\t}\n', '\n', '\t\treturn false;\n', '\t}\n', '\n', '  /**\n', '\t* @dev (Update operation) update the rewards parameters (by using alpha- and beta-score).\n', '\t* @param userAddr The address of the operator\n', '\t* @return Whether or not this process succeed\n', '\t*/\n', '\tfunction _determineRewardParams(address payable userAddr) internal returns (bool)\n', '\t{\n', '\t\tuint256 thisBlockNum = _blockContext();\n', '\t\tIManagerDataStorage _dataStorage = dataStorageInstance;\n', '\t\t/* The inactive period (delta) since the last action happens */\n', '\t\tuint256 delta = thisBlockNum - _dataStorage.getRewardParamUpdated();\n', '\t\t_dataStorage.setRewardParamUpdated(thisBlockNum);\n', '\t\tif (delta == 0)\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\n', '\t\t/* Rewards assigned for a block */\n', '\t\tuint256 globalRewardPerBlock = _dataStorage.getGlobalRewardPerBlock();\n', '\t\t/* Rewards decrement for a block. (Rewards per block monotonically decreases) */\n', '\t\tuint256 globalRewardDecrement = _dataStorage.getGlobalRewardDecrement();\n', '\t\t/* Total amount of rewards */\n', '\t\tuint256 globalRewardTotalAmount = _dataStorage.getGlobalRewardTotalAmount();\n', '\n', '\t\t/* Remaining periods for reward distribution */\n', '\t\tuint256 remainingPeriod = globalRewardPerBlock.unifiedDiv(globalRewardDecrement);\n', '\n', '\t\tif (remainingPeriod >= delta.mul(SafeMath.unifiedPoint))\n', '\t\t{\n', '\t\t\tremainingPeriod = remainingPeriod.sub(delta.mul(SafeMath.unifiedPoint));\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn _epilogueOfDetermineRewardParams(_dataStorage, userAddr, delta, 0, globalRewardDecrement, 0);\n', '\t\t}\n', '\n', '\t\tif (globalRewardTotalAmount >= globalRewardPerBlock.mul(delta))\n', '\t\t{\n', '\t\t\tglobalRewardTotalAmount = globalRewardTotalAmount - globalRewardPerBlock.mul(delta);\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn _epilogueOfDetermineRewardParams(_dataStorage, userAddr, delta, 0, globalRewardDecrement, 0);\n', '\t\t}\n', '\n', '\t\tglobalRewardPerBlock = globalRewardTotalAmount.mul(2).unifiedDiv(remainingPeriod.add(SafeMath.unifiedPoint));\n', '\t\t/* To incentivze the update operation, the operator get paid with the\n', '\t\treward token */\n', '\t\treturn _epilogueOfDetermineRewardParams(_dataStorage, userAddr, delta, globalRewardPerBlock, globalRewardDecrement, globalRewardTotalAmount);\n', '\t}\n', '\n', '  /**\n', '\t* @dev Update rewards paramters of token handlers.\n', '\t* @param userAddr The address of operator\n', '\t* @return true\n', '\t*/\n', '\tfunction _calcRewardParams(address payable userAddr) internal returns (bool)\n', '\t{\n', '\t\tuint256 handlerLength = tokenHandlerLength;\n', '\t\tbytes memory data;\n', '\t\tuint256[] memory handlerAlphaRateBaseAsset = new uint256[](handlerLength);\n', '\t\tuint256[] memory chainAlphaRateBaseAsset;\n', '\t\tuint256 handlerID;\n', '\t\tuint256 alphaRateBaseGlobalAssetSum;\n', '\t\tfor (handlerID; handlerID < handlerLength; handlerID++)\n', '\t\t{\n', '\t\t\thandlerAlphaRateBaseAsset[handlerID] = _getAlphaBaseAsset(handlerID);\n', '\t\t\talphaRateBaseGlobalAssetSum = alphaRateBaseGlobalAssetSum.add(handlerAlphaRateBaseAsset[handlerID]);\n', '\t\t}\n', '\n', '\t\tchainAlphaRateBaseAsset = Observer.getAlphaBaseAsset();\n', '\t\thandlerID = 0;\n', '\t\tfor (;handlerID < chainAlphaRateBaseAsset.length; handlerID++) {\n', '\t\t\talphaRateBaseGlobalAssetSum = alphaRateBaseGlobalAssetSum.add(chainAlphaRateBaseAsset[handlerID]);\n', '\t\t}\n', '\n', '\t\thandlerID = 0;\n', '\t\tuint256 globalRewardPerBlocks = dataStorageInstance.getGlobalRewardPerBlock();\n', '\n', '\t\tfor (handlerID; handlerID < handlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tIProxy tokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\t\t(, data) = tokenHandler.siProxy(\n', '\t\t\t\tabi.encodeWithSelector(\n', '\t\t\t\t\tIServiceIncentive\n', '\t\t\t\t\t.updateRewardLane.selector,\n', '\t\t\t\t\tuserAddr\n', '\t\t\t\t)\n', '\t\t\t);\n', '\n', '\t\t\t/* Update reward parameter for the token handler */\n', '\t\t\tuint256 rewardPerBlocks = globalRewardPerBlocks\n', '\t\t\t\t\t\t\t\t.unifiedMul(\n', '\t\t\t\t\t\t\t\thandlerAlphaRateBaseAsset[handlerID]\n', '\t\t\t\t\t\t\t\t.unifiedDiv(alphaRateBaseGlobalAssetSum)\n', '\t\t\t\t\t\t\t\t);\n', '\t\t\tdata = abi.encodeWithSelector(\n', '\t\t\t\tIServiceIncentive.updateRewardPerBlockLogic.selector,\n', '\t\t\t\trewardPerBlocks\n', '\t\t\t);\n', '\t\t\t(, data) = tokenHandler.siProxy(data);\n', '\n', '\t\t\temit HandlerRewardUpdate(handlerID, handlerAlphaRateBaseAsset[handlerID], rewardPerBlocks);\n', '\t\t}\n', '\n', '\t\thandlerID = 0;\n', '\t\tfor (;handlerID < chainAlphaRateBaseAsset.length; handlerID++) {\n', '\t\t\tuint256 rewardPerBlocks = chainAlphaRateBaseAsset[handlerID]\n', '\t\t\t\t\t\t\t\t\t\t.unifiedDiv(alphaRateBaseGlobalAssetSum)\n', '\t\t\t\t\t\t\t\t\t\t.unifiedMul(globalRewardPerBlocks);\n', '\n', '\t\t\tObserver.setChainGlobalRewardPerblock(\n', '\t\t\t\thandlerID,\n', '\t\t\t\trewardPerBlocks\n', '\t\t\t);\n', '\t\t\temit ChainRewardUpdate(handlerID, chainAlphaRateBaseAsset[handlerID], rewardPerBlocks);\n', '\t\t}\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '  /**\n', '\t* @dev Epilogue of _determineRewardParams for code-size savings\n', '\t* @param _dataStorage interface of Manager Data Storage\n', '\t* @param userAddr User Address for Reward token transfer\n', '\t* @param _delta The inactive period (delta) since the last action happens\n', '\t* @param _globalRewardPerBlock Reward per block\n', '\t* @param _globalRewardDecrement Rewards decrement for a block\n', '\t* @param _globalRewardTotalAmount Total amount of rewards\n', '\t* @return true\n', '\t*/\n', '\tfunction _epilogueOfDetermineRewardParams(\n', '\t\tIManagerDataStorage _dataStorage,\n', '\t\taddress payable userAddr,\n', '\t\tuint256 _delta,\n', '\t\tuint256 _globalRewardPerBlock,\n', '\t\tuint256 _globalRewardDecrement,\n', '\t\tuint256 _globalRewardTotalAmount\n', '\t) internal returns (bool) {\n', '\t\t// Set the reward model parameters\n', '\t\t_dataStorage.setGlobalRewardPerBlock(_globalRewardPerBlock);\n', '\t\t_dataStorage.setGlobalRewardDecrement(_globalRewardDecrement);\n', '\t\t_dataStorage.setGlobalRewardTotalAmount(_globalRewardTotalAmount);\n', '\n', '\t\tuint256 rewardAmount = _delta.mul(_dataStorage.getRewardParamUpdateRewardPerBlock());\n', '\t\t/* To incentivze the update operation, the operator get paid with the\n', '\t\treward token */\n', '\t\t_rewardTransfer(userAddr, rewardAmount);\n', '\t\treturn true;\n', '\t}\n', '\n', '  /**\n', '\t* @dev Calculate the alpha-score for the handler (in USD price)\n', '\t* @param _handlerID The handler ID\n', '\t* @return The alpha-score of the handler\n', '\t*/\n', '\tfunction _getAlphaBaseAsset(uint256 _handlerID) internal view returns (uint256)\n', '\t{\n', '\t\tbytes memory data;\n', '\t\tIProxy tokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(_handlerID));\n', '\n', '    \t// TODO merge call\n', '\t\t(, data) = tokenHandler.handlerViewProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIMarketHandler\n', '\t\t\t\t.getDepositTotalAmount.selector\n', '\t\t\t)\n', '\t\t);\n', '\t\tuint256 _depositAmount = abi.decode(data, (uint256));\n', '\n', '\t\t(, data) = tokenHandler.handlerViewProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIMarketHandler\n', '\t\t\t\t.getBorrowTotalAmount.selector\n', '\t\t\t)\n', '\t\t);\n', '\t\tuint256 _borrowAmount = abi.decode(data, (uint256));\n', '\n', '\t\treturn _calcAlphaBaseAmount(\n', '              dataStorageInstance.getAlphaRate(),\n', '              _depositAmount,\n', '              _borrowAmount\n', '            )\n', '            .unifiedMul(_getTokenHandlerPrice(_handlerID));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculate the alpha-score for the handler (in token amount)\n', '\t* @param _alpha The alpha parameter\n', '\t* @param _depositAmount The total amount of deposit\n', '\t* @param _borrowAmount The total amount of borrow\n', '\t* @return The alpha-score of the handler (in token amount)\n', '\t*/\n', '\tfunction _calcAlphaBaseAmount(uint256 _alpha, uint256 _depositAmount, uint256 _borrowAmount) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _depositAmount.unifiedMul(_alpha).add(_borrowAmount.unifiedMul(SafeMath.unifiedPoint.sub(_alpha)));\n', '\t}\n', '\n', '  /**\n', '\t* @dev Get the token price for the handler\n', '\t* @param handlerID The handler id\n', '\t* @return The token price of the handler\n', '\t*/\n', '\tfunction _getTokenHandlerPrice(uint256 handlerID) internal view returns (uint256)\n', '\t{\n', '\t\treturn (oracleProxy.getTokenPrice(handlerID));\n', '\t}\n', '\n', '\n', '\t/**\n', '\t* @dev Claim all rewards for the user\n', '\t* @param userAddr The user address\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction rewardClaimAll(address payable userAddr) external returns (uint256)\n', '\t{\n', '\t\tuint256 handlerID;\n', '\t\tuint256 claimAmountSum;\n', '\t\tfor (handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tclaimAmountSum = claimAmountSum.add(_claimHandlerRewardAmount(handlerID, userAddr));\n', '\t\t}\n', '\t\trequire(_rewardTransfer(userAddr, claimAmountSum));\n', '\t\treturn claimAmountSum;\n', '\t}\n', '\n', '\n', '\tfunction claimHandlerReward(uint256 handlerID, address payable userAddr) external returns (uint256) {\n', '\t\tuint256 amount = _claimHandlerRewardAmount(handlerID, userAddr);\n', '\n', '\t\trequire(_rewardTransfer(userAddr, amount));\n', '\n', '\t\treturn amount;\n', '\t}\n', '\n', '\n', '\tfunction _claimHandlerRewardAmount(uint256 handlerID, address payable userAddr) internal returns (uint256) {\n', '\t\tbytes memory data;\n', '\n', '\t\tIProxy tokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\ttokenHandler.siProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIServiceIncentive\n', '\t\t\t\t.updateRewardLane.selector,\n', '\t\t\t\tuserAddr\n', '\t\t\t)\n', '\t\t);\n', '\n', '\t\t/* Claim reward for a token handler */\n', '\t\t(, data) = tokenHandler.siProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIServiceIncentive.claimRewardAmountUser.selector,\n', '\t\t\t\tuserAddr\n', '\t\t\t)\n', '\t\t);\n', '\t\treturn abi.decode(data, (uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer reward tokens to owner (for administration)\n', '\t* @param _amount The amount of the reward token\n', '\t* @return true\n', '\t*/\n', '\tfunction ownerRewardTransfer(uint256 _amount) onlyOwner external returns (bool)\n', '\t{\n', '\t\treturn _rewardTransfer(address(uint160(owner)), _amount);\n', '\t}\n', '\n', '  /**\n', '\t* @dev Transfer reward tokens to a user\n', '\t* @param userAddr The address of recipient\n', '\t* @param _amount The amount of the reward token\n', '\t* @return true\n', '\t*/\n', '\tfunction _rewardTransfer(address payable userAddr, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tIERC20 _rewardERC20 = rewardErc20Instance;\n', '\n', '\t\tif(address(_rewardERC20) != address(0x0)) {\n', '\t\t\tuint256 beforeBalance = _rewardERC20.balanceOf(userAddr);\n', '\t\t\t_rewardERC20.transfer(userAddr, _amount);\n', '\t\t\trequire(_amount == _rewardERC20.balanceOf(userAddr).sub(beforeBalance), REWARD_TRANSFER);\n', '\t\t\treturn true;\n', '\t\t}\n', '\t}\n', '}']