['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-23\n', '*/\n', '\n', '// File: contracts/interfaces/SIInterface.sol\n', '\n', 'interface SIInterface  {\n', '\tfunction setCircuitBreakWithOwner(bool emergency) external returns (bool);\n', '\tfunction setCircuitBreaker(bool emergency) external returns (bool);\n', '\n', '\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) external returns (bool);\n', '\tfunction updateRewardLane(address payable userAddr) external returns (bool);\n', '\n', '\tfunction getBetaRateBaseTotalAmount() external view returns (uint256);\n', '\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction getUserRewardInfo(address payable userAddr) external view returns (uint256, uint256, uint256);\n', '}\n', '\n', '// File: contracts/interfaces/marketHandlerDataStorageInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketHandlerDataStorageInterface  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\n', '\tfunction setNewCustomer(address payable userAddr) external returns (bool);\n', '\n', '\tfunction getUserAccessed(address payable userAddr) external view returns (bool);\n', '\tfunction setUserAccessed(address payable userAddr, bool _accessed) external returns (bool);\n', '\n', '\tfunction getReservedAddr() external view returns (address payable);\n', '\tfunction setReservedAddr(address payable reservedAddress) external returns (bool);\n', '\n', '\tfunction getReservedAmount() external view returns (int256);\n', '\tfunction addReservedAmount(uint256 amount) external returns (int256);\n', '\tfunction subReservedAmount(uint256 amount) external returns (int256);\n', '\tfunction updateSignedReservedAmount(int256 amount) external returns (int256);\n', '\n', '\tfunction setTokenHandler(address _marketHandlerAddr, address _interestModelAddr) external returns (bool);\n', '\tfunction setCoinHandler(address _marketHandlerAddr, address _interestModelAddr) external returns (bool);\n', '\n', '\tfunction getDepositTotalAmount() external view returns (uint256);\n', '\tfunction addDepositTotalAmount(uint256 amount) external returns (uint256);\n', '\tfunction subDepositTotalAmount(uint256 amount) external returns (uint256);\n', '\n', '\tfunction getBorrowTotalAmount() external view returns (uint256);\n', '\tfunction addBorrowTotalAmount(uint256 amount) external returns (uint256);\n', '\tfunction subBorrowTotalAmount(uint256 amount) external returns (uint256);\n', '\n', '\tfunction getUserIntraDepositAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction addUserIntraDepositAmount(address payable userAddr, uint256 amount) external returns (uint256);\n', '\tfunction subUserIntraDepositAmount(address payable userAddr, uint256 amount) external returns (uint256);\n', '\n', '\tfunction getUserIntraBorrowAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction addUserIntraBorrowAmount(address payable userAddr, uint256 amount) external returns (uint256);\n', '\tfunction subUserIntraBorrowAmount(address payable userAddr, uint256 amount) external returns (uint256);\n', '\n', '\tfunction addDepositAmount(address payable userAddr, uint256 amount) external returns (bool);\n', '\tfunction subDepositAmount(address payable userAddr, uint256 amount) external returns (bool);\n', '\n', '\tfunction addBorrowAmount(address payable userAddr, uint256 amount) external returns (bool);\n', '\tfunction subBorrowAmount(address payable userAddr, uint256 amount) external returns (bool);\n', '\n', '\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction getHandlerAmount() external view returns (uint256, uint256);\n', '\n', '\tfunction getAmount(address payable userAddr) external view returns (uint256, uint256, uint256, uint256);\n', '\tfunction setAmount(address payable userAddr, uint256 depositTotalAmount, uint256 borrowTotalAmount, uint256 depositAmount, uint256 borrowAmount) external returns (uint256);\n', '\n', '\tfunction setBlocks(uint256 lastUpdatedBlock, uint256 inactiveActionDelta) external returns (bool);\n', '\n', '\tfunction getLastUpdatedBlock() external view returns (uint256);\n', '\tfunction setLastUpdatedBlock(uint256 _lastUpdatedBlock) external returns (bool);\n', '\n', '\tfunction getInactiveActionDelta() external view returns (uint256);\n', '\tfunction setInactiveActionDelta(uint256 inactiveActionDelta) external returns (bool);\n', '\n', '\tfunction syncActionEXR() external returns (bool);\n', '\n', '\tfunction getActionEXR() external view returns (uint256, uint256);\n', '\tfunction setActionEXR(uint256 actionDepositExRate, uint256 actionBorrowExRate) external returns (bool);\n', '\n', '\tfunction getGlobalDepositEXR() external view returns (uint256);\n', '\tfunction getGlobalBorrowEXR() external view returns (uint256);\n', '\n', '\tfunction setEXR(address payable userAddr, uint256 globalDepositEXR, uint256 globalBorrowEXR) external returns (bool);\n', '\n', '\tfunction getUserEXR(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction setUserEXR(address payable userAddr, uint256 depositEXR, uint256 borrowEXR) external returns (bool);\n', '\n', '\tfunction getGlobalEXR() external view returns (uint256, uint256);\n', '\n', '\tfunction getMarketHandlerAddr() external view returns (address);\n', '\tfunction setMarketHandlerAddr(address marketHandlerAddr) external returns (bool);\n', '\n', '\tfunction getInterestModelAddr() external view returns (address);\n', '\tfunction setInterestModelAddr(address interestModelAddr) external returns (bool);\n', '\n', '\n', '\tfunction getMinimumInterestRate() external view returns (uint256);\n', '\tfunction setMinimumInterestRate(uint256 _minimumInterestRate) external returns (bool);\n', '\n', '\tfunction getLiquiditySensitivity() external view returns (uint256);\n', '\tfunction setLiquiditySensitivity(uint256 _liquiditySensitivity) external returns (bool);\n', '\n', '\tfunction getLimit() external view returns (uint256, uint256);\n', '\n', '\tfunction getBorrowLimit() external view returns (uint256);\n', '\tfunction setBorrowLimit(uint256 _borrowLimit) external returns (bool);\n', '\n', '\tfunction getMarginCallLimit() external view returns (uint256);\n', '\tfunction setMarginCallLimit(uint256 _marginCallLimit) external returns (bool);\n', '\n', '\tfunction getLimitOfAction() external view returns (uint256);\n', '\tfunction setLimitOfAction(uint256 limitOfAction) external returns (bool);\n', '\n', '\tfunction getLiquidityLimit() external view returns (uint256);\n', '\tfunction setLiquidityLimit(uint256 liquidityLimit) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/marketManagerInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketManagerInterface  {\n', '\tfunction setBreakerTable(address _target, bool _status) external returns (bool);\n', '\n', '\tfunction getCircuitBreaker() external view returns (bool);\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address, string memory);\n', '\n', '\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr) external returns (bool);\n', '\n', '\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256);\n', '\tfunction liquidationApplyInterestHandlers(address payable userAddr, uint256 callerID) external returns (uint256, uint256, uint256, uint256, uint256);\n', '\n', '\tfunction getTokenHandlerPrice(uint256 handlerID) external view returns (uint256);\n', '\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view returns (uint256);\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\n', '\n', '\tfunction getTokenHandlersLength() external view returns (uint256);\n', '\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) external returns (bool);\n', '\n', '\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\n', '\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view returns (uint256);\n', '\n', '\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserLimitIntraAsset(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\n', '\n', '\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\n', '\n', '\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view returns (uint256);\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) external returns (uint256);\n', '\n', '\tfunction setLiquidationManager(address liquidationManagerAddr) external returns (bool);\n', '\n', '\tfunction rewardClaimAll(address payable userAddr) external returns (bool);\n', '\n', '\tfunction updateRewardParams(address payable userAddr) external returns (bool);\n', '\tfunction interestUpdateReward() external returns (bool);\n', '\tfunction getGlobalRewardInfo() external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction setOracleProxy(address oracleProxyAddr) external returns (bool);\n', '\n', '\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external returns (bool);\n', '\tfunction ownerRewardTransfer(uint256 _amount) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/interestModelInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface interestModelInterface {\n', '\tfunction getInterestAmount(address handlerDataStorageAddr, address payable userAddr, bool isView) external view returns (bool, uint256, uint256, bool, uint256, uint256);\n', '\tfunction viewInterestAmount(address handlerDataStorageAddr, address payable userAddr) external view returns (bool, uint256, uint256, bool, uint256, uint256);\n', '\tfunction getSIRandBIR(address handlerDataStorageAddr, uint256 depositTotalAmount, uint256 borrowTotalAmount) external view returns (uint256, uint256);\n', '}\n', '\n', '// File: contracts/interfaces/marketSIHandlerDataStorageInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketSIHandlerDataStorageInterface  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\n', '\tfunction updateRewardPerBlockStorage(uint256 _rewardPerBlock) external returns (bool);\n', '\n', '\tfunction getRewardInfo(address userAddr) external view returns (uint256, uint256, uint256, uint256, uint256, uint256);\n', '\n', '\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\n', '\tfunction setMarketRewardInfo(uint256 _rewardLane, uint256 _rewardLaneUpdateAt, uint256 _rewardPerBlock) external returns (bool);\n', '\n', '\tfunction getUserRewardInfo(address userAddr) external view returns (uint256, uint256, uint256);\n', '\tfunction setUserRewardInfo(address userAddr, uint256 _rewardLane, uint256 _rewardLaneUpdateAt, uint256 _rewardAmount) external returns (bool);\n', '\n', '\tfunction getBetaRate() external view returns (uint256);\n', '\tfunction setBetaRate(uint256 _betaRate) external returns (bool);\n', '}\n', '\n', '// File: contracts/marketHandler/coinSI.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title Bifi's coinSI Contract\n", ' * @notice Contract of coinSI, where users can action with reward logic\n', ' * @author Bifi\n', ' */\n', 'contract coinSI is SIInterface {\n', '\tevent CircuitBreaked(bool breaked, uint256 blockNumber, uint256 handlerID);\n', '\n', '\taddress payable owner;\n', '\n', '\tuint256 handlerID;\n', '\n', '\tstring tokenName;\n', '\n', '\tuint256 constant unifiedPoint = 10 ** 18;\n', '\n', '\tmarketManagerInterface marketManager;\n', '\n', '\tinterestModelInterface interestModelInstance;\n', '\n', '\tmarketHandlerDataStorageInterface handlerDataStorage;\n', '\n', '\tmarketSIHandlerDataStorageInterface SIHandlerDataStorage;\n', '\n', '\tstruct MarketRewardInfo {\n', '\t\tuint256 rewardLane;\n', '\t\tuint256 rewardLaneUpdateAt;\n', '\t\tuint256 rewardPerBlock;\n', '\t}\n', '\n', '\tstruct UserRewardInfo {\n', '\t\tuint256 rewardLane;\n', '\t\tuint256 rewardLaneUpdateAt;\n', '\t\tuint256 rewardAmount;\n', '\t}\n', '\n', '\tmodifier onlyMarketManager {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == address(marketManager)) || (msgSender == owner), "onlyMarketManager function");\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == address(owner), "onlyOwner function");\n', '\t\t_;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Replace the owner of the handler\n', '\t* @param _owner the address of the owner to be replaced\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction ownershipTransfer(address _owner) onlyOwner external returns (bool)\n', '\t{\n', '\t\towner = address(uint160(_owner));\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set circuitBreak which freeze all of handlers with owner\n', '\t* @param _emergency The status on whether to use circuitBreak\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setCircuitBreakWithOwner(bool _emergency) onlyOwner external override returns (bool)\n', '\t{\n', '\t\tSIHandlerDataStorage.setCircuitBreaker(_emergency);\n', '\t\temit CircuitBreaked(_emergency, block.number, handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set circuitBreak which freeze all of handlers with marketManager\n', '\t* @param _emergency The status on whether to use circuitBreak\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setCircuitBreaker(bool _emergency) onlyMarketManager external override returns (bool)\n', '\t{\n', '\t\tSIHandlerDataStorage.setCircuitBreaker(_emergency);\n', '\t\temit CircuitBreaked(_emergency, block.number, handlerID);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update the amount of rewards per block\n', '\t* @param _rewardPerBlock The amount of rewards per block\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) onlyMarketManager external override returns (bool)\n', '\t{\n', '\t\treturn SIHandlerDataStorage.updateRewardPerBlockStorage(_rewardPerBlock);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculates the number of rewards given according to the gap of block number\n', '\t* @param userAddr The address of user\n', '\t* @return Whether or not updateRewardLane succeed\n', '\t*/\n', '\tfunction updateRewardLane(address payable userAddr) external override returns (bool)\n', '\t{\n', '\t\tMarketRewardInfo memory market;\n', '\t\tUserRewardInfo memory user;\n', '\t\tmarketSIHandlerDataStorageInterface _SIHandlerDataStorage = SIHandlerDataStorage;\n', '\t\t(market.rewardLane, market.rewardLaneUpdateAt, market.rewardPerBlock, user.rewardLane, user.rewardLaneUpdateAt, user.rewardAmount) = _SIHandlerDataStorage.getRewardInfo(userAddr);\n', '\n', "\t\t/* To calculate the amount of rewards that change as the block flows, bring in the user's deposit, borrow, and total deposit, total borrow of the market */\n", '\t\tuint256 currentBlockNum = block.number;\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\tuint256 depositUserAmount;\n', '\t\tuint256 borrowUserAmount;\n', '\t\t(depositTotalAmount, borrowTotalAmount, depositUserAmount, borrowUserAmount) = handlerDataStorage.getAmount(userAddr);\n', '\n', "\t\t/* Update the market's reward parameter value according to the rate of beta(the rate of weight) if the time of call is later than when the reward was updated */\n", '\t\tif (market.rewardLaneUpdateAt < currentBlockNum)\n', '\t\t{\n', '\t\t\tuint256 _delta = sub(currentBlockNum, market.rewardLaneUpdateAt);\n', '\t\t\tuint256 betaRateBaseTotalAmount = _calcBetaBaseAmount(_SIHandlerDataStorage.getBetaRate(), depositTotalAmount, borrowTotalAmount);\n', '\t\t\tif (betaRateBaseTotalAmount != 0)\n', '\t\t\t{\n', '\t\t\t\tmarket.rewardLane = add(market.rewardLane, _calcRewardLaneDistance(_delta, market.rewardPerBlock, betaRateBaseTotalAmount));\n', '\t\t\t}\n', '\n', '\t\t\t_SIHandlerDataStorage.setMarketRewardInfo(market.rewardLane, currentBlockNum, market.rewardPerBlock);\n', '\t\t}\n', '\n', "\t\t/* Update the user's reward parameter value according to the rate of beta(the rate of weight) if the time of call is later than when the reward was updated */\n", '\t\tif (user.rewardLaneUpdateAt < currentBlockNum)\n', '\t\t{\n', '\t\t\tuint256 betaRateBaseUserAmount = _calcBetaBaseAmount(_SIHandlerDataStorage.getBetaRate(), depositUserAmount, borrowUserAmount);\n', '\t\t\tif (betaRateBaseUserAmount != 0)\n', '\t\t\t{\n', '\t\t\t\tuser.rewardAmount = add(user.rewardAmount, unifiedMul(betaRateBaseUserAmount, sub(market.rewardLane, user.rewardLane)));\n', '\t\t\t}\n', '\n', '\t\t\t_SIHandlerDataStorage.setUserRewardInfo(userAddr, market.rewardLane, currentBlockNum, user.rewardAmount);\n', '\t\t\treturn true;\n', '\t\t}\n', '\n', '\t\treturn false;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculates the number of rewards given according to the gap of block number\n', "\t* @param _delta The amount of blockNumber's gap\n", '\t* @param _rewardPerBlock The amount of reward per block\n', '\t* @param _total The total amount of betaRate\n', '\t* @return The result of reward given according to the block number gap\n', '\t*/\n', '\tfunction _calcRewardLaneDistance(uint256 _delta, uint256 _rewardPerBlock, uint256 _total) internal pure returns (uint256)\n', '\t{\n', '\t\treturn mul(_delta, unifiedDiv(_rewardPerBlock, _total));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the total amount of betaRate\n', '\t* @return The total amount of betaRate\n', '\t*/\n', '\tfunction getBetaRateBaseTotalAmount() external view override returns (uint256)\n', '\t{\n', '\t\treturn _getBetaRateBaseTotalAmount();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the total amount of betaRate\n', '\t* @return The total amount of betaRate\n', '\t*/\n', '\tfunction _getBetaRateBaseTotalAmount() internal view returns (uint256)\n', '\t{\n', '\t\tuint256 depositTotalAmount;\n', '\t\tuint256 borrowTotalAmount;\n', '\t\t(depositTotalAmount, borrowTotalAmount) = handlerDataStorage.getHandlerAmount();\n', '\t\treturn _calcBetaBaseAmount(SIHandlerDataStorage.getBetaRate(), depositTotalAmount, borrowTotalAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculate the rewards given to the user through calculation, Based on the data rate\n', '\t* betaRateBaseAmount = (depositAmount * betaRate) + ((1 - betaRate) * borrowAmount)\n', '\t* @param userAddr The address of user\n', "\t* @return The amount of user's betaRate\n", '\t*/\n', '\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view override returns (uint256)\n', '\t{\n', '\t\treturn _getBetaRateBaseUserAmount(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculate the rewards given to the user through calculation, Based on the data rate\n', '\t* betaRateBaseAmount = (depositAmount * betaRate) + ((1 - betaRate) * borrowAmount)\n', '\t* @param userAddr The address of user\n', "\t* @return The amount of user's betaRate\n", '\t*/\n', '\tfunction _getBetaRateBaseUserAmount(address payable userAddr) internal view returns (uint256)\n', '\t{\n', '\t\tuint256 depositUserAmount;\n', '\t\tuint256 borrowUserAmount;\n', '\t\t(depositUserAmount, borrowUserAmount) = handlerDataStorage.getUserAmount(userAddr);\n', '\t\treturn _calcBetaBaseAmount(SIHandlerDataStorage.getBetaRate(), depositUserAmount, borrowUserAmount);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get the amount of user's accumulated rewards as tokens\n", '\t* and initialize user reward amount\n', '\t* @param userAddr The address of user who claimed\n', "\t* @return The amount of user's reward\n", '\t*/\n', '\tfunction claimRewardAmountUser(address payable userAddr) onlyMarketManager external returns (uint256)\n', '\t{\n', '\t\treturn _claimRewardAmountUser(userAddr);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get the amount of user's accumulated rewards as tokens\n", '\t* and initialize user reward amount\n', '\t* @param userAddr The address of user who claimed\n', "\t* @return The amount of user's reward\n", '\t*/\n', '\tfunction _claimRewardAmountUser(address payable userAddr) internal returns (uint256)\n', '\t{\n', '\t\tUserRewardInfo memory user;\n', '\t\tuint256 currentBlockNum = block.number;\n', '\t\t(user.rewardLane, user.rewardLaneUpdateAt, user.rewardAmount) = SIHandlerDataStorage.getUserRewardInfo(userAddr);\n', '\t\tSIHandlerDataStorage.setUserRewardInfo(userAddr, user.rewardLane, currentBlockNum, 0);\n', '\t\treturn user.rewardAmount;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculate the rewards given to the user through calculation, Based on the data rate\n', '\t* betaRateBaseAmount = (depositAmount * betaRate) + ((1 - betaRate) * borrowAmount)\n', '\t* @param _beta The rate of beta\n', "\t* @param _depositAmount The amount of user's deposit\n", "\t* @param _borrowAmount The amount of user's borrow\n", "\t* @return The amount of user's betaRate\n", '\t*/\n', '\tfunction _calcBetaBaseAmount(uint256 _beta, uint256 _depositAmount, uint256 _borrowAmount) internal pure returns (uint256)\n', '\t{\n', '\t\treturn add(unifiedMul(_depositAmount, _beta), unifiedMul(_borrowAmount, sub(unifiedPoint, _beta)));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get reward parameters related the market\n', '\t* @return (uint256,uint256,uint256) (rewardLane, rewardLaneUpdateAt, rewardPerBlock)\n', '\t*/\n', '\tfunction getMarketRewardInfo() external view override returns (uint256, uint256, uint256)\n', '\t{\n', '\t\treturn SIHandlerDataStorage.getMarketRewardInfo();\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get reward parameters related the user\n', '\t* @return (uint256,uint256,uint256) (rewardLane, rewardLaneUpdateAt, rewardAmount)\n', '\t*/\n', '\tfunction getUserRewardInfo(address payable userAddr) external view override returns (uint256, uint256, uint256)\n', '\t{\n', '\t\treturn SIHandlerDataStorage.getUserRewardInfo(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the rate of beta\n', '\t* @return The rate of beta\n', '\t*/\n', '\tfunction getBetaRate() external view returns (uint256)\n', '\t{\n', '\t\treturn SIHandlerDataStorage.getBetaRate();\n', '\t}\n', '\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "add overflow");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _sub(a, b, "sub overflow");\n', '\t}\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _mul(a, b);\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(a, b, "div by zero");\n', '\t}\n', '\n', '\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _mod(a, b, "mod by zero");\n', '\t}\n', '\n', '\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b <= a, errorMessage);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a * b;\n', '\t\trequire((c / a) == b, "mul overflow");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b > 0, errorMessage);\n', '\t\treturn a / b;\n', '\t}\n', '\n', '\tfunction _mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b != 0, errorMessage);\n', '\t\treturn a % b;\n', '\t}\n', '\n', '\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, unifiedPoint), b, "unified div by zero");\n', '\t}\n', '\n', '\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, b), unifiedPoint, "unified mul by zero");\n', '\t}\n', '\n', '\tfunction signedAdd(int256 a, int256 b) internal pure returns (int256)\n', '\t{\n', '\t\tint256 c = a + b;\n', '\t\trequire(((b >= 0) && (c >= a)) || ((b < 0) && (c < a)), "SignedSafeMath: addition overflow");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction signedSub(int256 a, int256 b) internal pure returns (int256)\n', '\t{\n', '\t\tint256 c = a - b;\n', '\t\trequire(((b >= 0) && (c <= a)) || ((b < 0) && (c > a)), "SignedSafeMath: subtraction overflow");\n', '\t\treturn c;\n', '\t}\n', '}']