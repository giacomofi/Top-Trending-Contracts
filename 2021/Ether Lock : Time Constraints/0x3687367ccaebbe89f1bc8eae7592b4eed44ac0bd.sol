['# @version 0.2.12\n', '"""\n', '@title Curve Crypto Pool Proxy\n', '@author Curve Finance\n', '@license MIT\n', '"""\n', '\n', 'interface Burner:\n', '    def burn(_coin: address) -> bool: payable\n', '\n', 'interface Curve:\n', '    def accept_transfer_ownership(): nonpayable\n', '    def apply_new_parameters(): nonpayable\n', '    def apply_transfer_ownership(): nonpayable\n', '    def claim_admin_fees(): nonpayable\n', '    def commit_new_parameters(\n', '        _new_mid_fee: uint256,\n', '        _new_out_fee: uint256,\n', '        _new_admin_fee: uint256,\n', '        _new_fee_gamma: uint256,\n', '        _new_price_threshold: uint256,\n', '        _new_adjustment_step: uint256,\n', '        _new_ma_half_time: uint256\n', '    ): nonpayable\n', '    def commit_transfer_ownership(_owner: address): nonpayable\n', '    def donate_admin_fees(): nonpayable\n', '    def kill_me(): nonpayable\n', '    def price_oracle(k: uint256) -> uint256: view\n', '    def ramp_A_gamma(future_A: uint256, future_gamma: uint256, future_time: uint256): nonpayable\n', '    def revert_new_parameters(): nonpayable\n', '    def revert_transfer_ownership(): nonpayable\n', '    def set_admin_fee_receiver(_admin_fee_receiver: address): nonpayable\n', '    def set_aave_referral(referral_code: uint256): nonpayable\n', '    def stop_ramp_A_gamma(): nonpayable\n', '    def unkill_me(): nonpayable\n', '\n', 'interface AddressProvider:\n', '    def get_registry() -> address: view\n', '\n', 'interface Registry:\n', '    def get_decimals(_pool: address) -> uint256[8]: view\n', '    def get_underlying_balances(_pool: address) -> uint256[8]: view\n', '\n', '\n', 'MAX_COINS: constant(int128) = 8\n', 'ADDRESS_PROVIDER: constant(address) = 0x0000000022D53366457F9d5E68Ec105046FC4383\n', '\n', 'struct PoolInfo:\n', '    balances: uint256[MAX_COINS]\n', '    underlying_balances: uint256[MAX_COINS]\n', '    decimals: uint256[MAX_COINS]\n', '    underlying_decimals: uint256[MAX_COINS]\n', '    lp_token: address\n', '    A: uint256\n', '    fee: uint256\n', '\n', 'event CommitAdmins:\n', '    ownership_admin: address\n', '    parameter_admin: address\n', '    emergency_admin: address\n', '\n', 'event ApplyAdmins:\n', '    ownership_admin: address\n', '    parameter_admin: address\n', '    emergency_admin: address\n', '\n', 'event AddBurner:\n', '    burner: address\n', '\n', '\n', 'ownership_admin: public(address)\n', 'parameter_admin: public(address)\n', 'emergency_admin: public(address)\n', '\n', 'future_ownership_admin: public(address)\n', 'future_parameter_admin: public(address)\n', 'future_emergency_admin: public(address)\n', '\n', 'burners: public(HashMap[address, address])\n', 'burner_kill: public(bool)\n', '\n', '# pool -> caller -> can call `donate_admin_fees`\n', 'donate_approval: public(HashMap[address, HashMap[address, bool]])\n', '\n', '@external\n', 'def __init__(\n', '    _ownership_admin: address,\n', '    _parameter_admin: address,\n', '    _emergency_admin: address\n', '):\n', '    self.ownership_admin = _ownership_admin\n', '    self.parameter_admin = _parameter_admin\n', '    self.emergency_admin = _emergency_admin\n', '\n', '\n', '@payable\n', '@external\n', 'def __default__():\n', '    # required to receive ETH fees\n', '    pass\n', '\n', '\n', '@external\n', 'def commit_set_admins(_o_admin: address, _p_admin: address, _e_admin: address):\n', '    """\n', '    @notice Set ownership admin to `_o_admin`, parameter admin to `_p_admin` and emergency admin to `_e_admin`\n', '    @param _o_admin Ownership admin\n', '    @param _p_admin Parameter admin\n', '    @param _e_admin Emergency admin\n', '    """\n', '    assert msg.sender == self.ownership_admin, "Access denied"\n', '\n', '    self.future_ownership_admin = _o_admin\n', '    self.future_parameter_admin = _p_admin\n', '    self.future_emergency_admin = _e_admin\n', '\n', '    log CommitAdmins(_o_admin, _p_admin, _e_admin)\n', '\n', '\n', '@external\n', 'def apply_set_admins():\n', '    """\n', '    @notice Apply the effects of `commit_set_admins`\n', '    """\n', '    assert msg.sender == self.ownership_admin, "Access denied"\n', '\n', '    _o_admin: address = self.future_ownership_admin\n', '    _p_admin: address = self.future_parameter_admin\n', '    _e_admin: address = self.future_emergency_admin\n', '    self.ownership_admin = _o_admin\n', '    self.parameter_admin = _p_admin\n', '    self.emergency_admin = _e_admin\n', '\n', '    log ApplyAdmins(_o_admin, _p_admin, _e_admin)\n', '\n', '\n', '@internal\n', 'def _set_burner(_coin: address, _burner: address):\n', '    old_burner: address = self.burners[_coin]\n', '    if _coin != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\n', '        if old_burner != ZERO_ADDRESS:\n', '            # revoke approval on previous burner\n', '            response: Bytes[32] = raw_call(\n', '                _coin,\n', '                concat(\n', '                    method_id("approve(address,uint256)"),\n', '                    convert(old_burner, bytes32),\n', '                    convert(0, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )\n', '            if len(response) != 0:\n', '                assert convert(response, bool)\n', '\n', '        if _burner != ZERO_ADDRESS:\n', '            # infinite approval for current burner\n', '            response: Bytes[32] = raw_call(\n', '                _coin,\n', '                concat(\n', '                    method_id("approve(address,uint256)"),\n', '                    convert(_burner, bytes32),\n', '                    convert(MAX_UINT256, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )\n', '            if len(response) != 0:\n', '                assert convert(response, bool)\n', '\n', '    self.burners[_coin] = _burner\n', '\n', '    log AddBurner(_burner)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def set_burner(_coin: address, _burner: address):\n', '    """\n', '    @notice Set burner of `_coin` to `_burner` address\n', '    @param _coin Token address\n', '    @param _burner Burner contract address\n', '    """\n', '    assert msg.sender == self.ownership_admin, "Access denied"\n', '\n', '    self._set_burner(_coin, _burner)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def set_many_burners(_coins: address[20], _burners: address[20]):\n', '    """\n', '    @notice Set burner of `_coin` to `_burner` address\n', '    @param _coins Token address\n', '    @param _burners Burner contract address\n', '    """\n', '    assert msg.sender == self.ownership_admin, "Access denied"\n', '\n', '    for i in range(20):\n', '        coin: address = _coins[i]\n', '        if coin == ZERO_ADDRESS:\n', '            break\n', '        self._set_burner(coin, _burners[i])\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def withdraw_admin_fees(_pool: address):\n', '    """\n', '    @notice Withdraw admin fees from `_pool`\n', '    @param _pool Pool address to withdraw admin fees from\n', '    """\n', '    Curve(_pool).claim_admin_fees()\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def withdraw_many(_pools: address[20]):\n', '    """\n', '    @notice Withdraw admin fees from multiple pools\n', '    @param _pools List of pool address to withdraw admin fees from\n', '    """\n', '    for pool in _pools:\n', '        if pool == ZERO_ADDRESS:\n', '            break\n', '        Curve(pool).claim_admin_fees()\n', '\n', '\n', '@external\n', "@nonreentrant('burn')\n", 'def burn(_coin: address):\n', '    """\n', '    @notice Burn accrued `_coin` via a preset burner\n', '    @dev Only callable by an EOA to prevent flashloan exploits\n', '    @param _coin Coin address\n', '    """\n', '    assert tx.origin == msg.sender\n', '    assert not self.burner_kill\n', '\n', '    _value: uint256 = 0\n', '    if _coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\n', '        _value = self.balance\n', '\n', '    Burner(self.burners[_coin]).burn(_coin, value=_value)  # dev: should implement burn()\n', '\n', '\n', '@external\n', "@nonreentrant('burn')\n", 'def burn_many(_coins: address[20]):\n', '    """\n', '    @notice Burn accrued admin fees from multiple coins\n', '    @dev Only callable by an EOA to prevent flashloan exploits\n', '    @param _coins List of coin addresses\n', '    """\n', '    assert tx.origin == msg.sender\n', '    assert not self.burner_kill\n', '\n', '    for coin in _coins:\n', '        if coin == ZERO_ADDRESS:\n', '            break\n', '\n', '        _value: uint256 = 0\n', '        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\n', '            _value = self.balance\n', '\n', '        Burner(self.burners[coin]).burn(coin, value=_value)  # dev: should implement burn()\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def kill_me(_pool: address):\n', '    """\n', '    @notice Pause the pool `_pool` - only remove_liquidity will be callable\n', '    @param _pool Pool address to pause\n', '    """\n', '    assert msg.sender == self.emergency_admin, "Access denied"\n', '    Curve(_pool).kill_me()\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def unkill_me(_pool: address):\n', '    """\n', '    @notice Unpause the pool `_pool`, re-enabling all functionality\n', '    @param _pool Pool address to unpause\n', '    """\n', '    assert msg.sender == self.emergency_admin or msg.sender == self.ownership_admin, "Access denied"\n', '    Curve(_pool).unkill_me()\n', '\n', '\n', '@external\n', 'def set_burner_kill(_is_killed: bool):\n', '    """\n', '    @notice Kill or unkill `burn` functionality\n', '    @param _is_killed Burner kill status\n', '    """\n', '    assert msg.sender == self.emergency_admin or msg.sender == self.ownership_admin, "Access denied"\n', '    self.burner_kill = _is_killed\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def commit_transfer_ownership(_pool: address, new_owner: address):\n', '    """\n', '    @notice Transfer ownership for `_pool` pool to `new_owner` address\n', '    @param _pool Pool which ownership is to be transferred\n', '    @param new_owner New pool owner address\n', '    """\n', '    assert msg.sender == self.ownership_admin, "Access denied"\n', '    Curve(_pool).commit_transfer_ownership(new_owner)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def apply_transfer_ownership(_pool: address):\n', '    """\n', '    @notice Apply transferring ownership of `_pool`\n', '    @param _pool Pool address\n', '    """\n', '    Curve(_pool).apply_transfer_ownership()\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def accept_transfer_ownership(_pool: address):\n', '    """\n', '    @notice Apply transferring ownership of `_pool`\n', '    @param _pool Pool address\n', '    """\n', '    Curve(_pool).accept_transfer_ownership()\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def revert_transfer_ownership(_pool: address):\n', '    """\n', '    @notice Revert commited transferring ownership for `_pool`\n', '    @param _pool Pool address\n', '    """\n', '    assert msg.sender in [self.ownership_admin, self.emergency_admin], "Access denied"\n', '    Curve(_pool).revert_transfer_ownership()\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def commit_new_parameters(\n', '    _pool: address,\n', '    _new_mid_fee: uint256,\n', '    _new_out_fee: uint256,\n', '    _new_admin_fee: uint256,\n', '    _new_fee_gamma: uint256,\n', '    _new_price_threshold: uint256,\n', '    _new_adjustment_step: uint256,\n', '    _new_ma_half_time: uint256,\n', '):\n', '    """\n', '    @notice Commit new parameters for `_pool`, A: `amplification`, fee: `new_fee` and admin fee: `new_admin_fee`\n', '    @param _pool Pool address\n', '    @param _new_mid_fee New mid fee, less than or equal to `_new_out_fee`\n', '    @param _new_out_fee New out fee, greater than MIN_FEE and less than MAX_FEE \n', '    @param _new_admin_fee New admin fee, less than MAX_ADMIN_FEE\n', '    @param _new_fee_gamma New fee gamma, within the bounds of [1, 2**100]\n', '    @param _new_price_threshold New price threshold, greater than `_new_mid_fee`\n', '    @param _new_adjustment_step New adjustment step, less than `_new_price_threshold`\n', '    @param _new_ma_half_time New MA half time, less than 7 days \n', '    """\n', '    assert msg.sender == self.parameter_admin, "Access denied"\n', '    Curve(_pool).commit_new_parameters(\n', '        _new_mid_fee,\n', '        _new_out_fee,\n', '        _new_admin_fee,\n', '        _new_fee_gamma,\n', '        _new_price_threshold,\n', '        _new_adjustment_step,\n', '        _new_ma_half_time\n', '    )  # dev: if implemented by the pool\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def apply_new_parameters(_pool: address):\n', '    """\n', '    @notice Apply new parameters for `_pool` pool\n', '    @dev Only callable by an EOA\n', '    @param _pool Pool address\n', '    """\n', '    assert msg.sender == tx.origin\n', '    Curve(_pool).apply_new_parameters()  # dev: if implemented by the pool\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def revert_new_parameters(_pool: address):\n', '    """\n', '    @notice Revert comitted new parameters for `_pool` pool\n', '    @param _pool Pool address\n', '    """\n', '    assert msg.sender in [self.ownership_admin, self.parameter_admin, self.emergency_admin], "Access denied"\n', '    Curve(_pool).revert_new_parameters()  # dev: if implemented by the pool\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def ramp_A_gamma(_pool: address, _future_A: uint256, _future_gamma: uint256, _future_time: uint256):\n', '    """\n', '    @notice Start gradually increasing A and gamma of `_pool` reaching `_future_A` and `_future_gamma` at `_future_time` time\n', '    @param _pool Pool address\n', '    @param _future_A Future A\n', '    @param _future_time Future time\n', '    """\n', '    assert msg.sender == self.parameter_admin, "Access denied"\n', '    Curve(_pool).ramp_A_gamma(_future_A, _future_gamma, _future_time)\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def stop_ramp_A_gamma(_pool: address):\n', '    """\n', '    @notice Stop gradually increasing A and gamma of `_pool`\n', '    @param _pool Pool address\n', '    """\n', '    assert msg.sender in [self.parameter_admin, self.emergency_admin], "Access denied"\n', '    Curve(_pool).stop_ramp_A_gamma()\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def set_aave_referral(_pool: address, referral_code: uint256):\n', '    """\n', '    @notice Set Aave referral for undelying tokens of `_pool` to `referral_code`\n', '    @param _pool Pool address\n', '    @param referral_code Aave referral code\n', '    """\n', '    assert msg.sender == self.ownership_admin, "Access denied"\n', '    Curve(_pool).set_aave_referral(referral_code)  # dev: if implemented by the pool\n', '\n', '\n', '@external\n', 'def set_donate_approval(_pool: address, _caller: address, _is_approved: bool):\n', '    """\n', '    @notice Set approval of `_caller` to donate admin fees for `_pool`\n', '    @param _pool Pool address\n', '    @param _caller Adddress to set approval for\n', '    @param _is_approved Approval status\n', '    """\n', '    assert msg.sender == self.ownership_admin, "Access denied"\n', '\n', '    self.donate_approval[_pool][_caller] = _is_approved\n', '\n', '\n', '@external\n', "@nonreentrant('lock')\n", 'def donate_admin_fees(_pool: address):\n', '    """\n', '    @notice Donate admin fees of `_pool` pool\n', '    @param _pool Pool address\n', '    """\n', '    if msg.sender != self.ownership_admin:\n', '        assert self.donate_approval[_pool][msg.sender], "Access denied"\n', '\n', '    Curve(_pool).donate_admin_fees()  # dev: if implemented by the pool']