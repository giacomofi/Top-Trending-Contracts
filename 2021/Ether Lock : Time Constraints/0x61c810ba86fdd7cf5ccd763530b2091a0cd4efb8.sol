['/**\n', ' *Submitted for verification at Etherscan.io on 2019-05-09\n', '*/\n', '\n', 'pragma solidity ^0.5.8;\n', '\n', 'import "./IERC20.sol";\n', 'import "./TransferHelper.sol";\n', 'import "./SafeMath.sol";\n', 'import "./PledgeMining.sol";\n', '\n', '\n', 'contract SunnyStop is Owned {\n', '    IERC20  _tokenA;\n', '    IERC20  _tokenB;\n', '    PledgeMining  _pledgeMining;\n', '    using TransferHelper for address;\n', '    using SafeMath for uint;\n', '//    uint256 periodUnit = 1 minutes;\n', '    uint256 periodUnit = 1 days;\n', '\n', '\n', '    mapping(address => bool)  public userUse;\n', '    mapping(address => uint256)  public userTokenA;\n', '    mapping(address => uint256)  public userTokenB;\n', '\n', '    uint256 public stopTime;\n', '    bool public mining_state;\n', '\n', '    struct Record {\n', '        uint256 id;\n', '        uint256 createTime;\n', '        uint256 stopTime;\n', '        uint256 heaven;\n', '        uint256 scale;\n', '        uint256 pledgeAmount;\n', '        uint256 releaseAmount;\n', '        uint256 over; // 1 processing 2 over\n', '    }\n', '\n', '\n', '    constructor(address tokenA, address tokenB, address payable pledgeMining_) public {\n', '        _tokenA = IERC20(tokenA);\n', '        _tokenB = IERC20(tokenB);\n', '        stopTime = block.timestamp;\n', '        owner = msg.sender;\n', '        _pledgeMining = PledgeMining(pledgeMining_);\n', '        mining_state = true;\n', '    }\n', '\n', '    modifier mining {\n', '        require(mining_state, "PLEDGE:STOP_MINING");\n', '        _;\n', '    }\n', '\n', '\n', '    // 停止挖矿,并从资金池提取WDAO\n', '    function stop_mining(uint256 tokenAAmount, uint256 tokenBAmount) public onlyOwner {\n', '        if (tokenAAmount > 0) {\n', '            require(address(_tokenA).safeTransfer(msg.sender, tokenAAmount), "SAFE_TRANSFER_ERROR");\n', '        }\n', '        if (tokenBAmount > 0) {\n', '            require(address(_tokenB).safeTransfer(msg.sender, tokenBAmount), "SAFE_TRANSFER_ERROR");\n', '        }\n', '        mining_state = false;\n', '    }\n', '\n', '\n', '    function calcReceiveIncome(Record memory r) internal view returns (uint256){\n', '\n', '        uint256 oneTotal = r.pledgeAmount.mul(r.scale).div(uint256(1000));\n', '        uint256 _income = oneTotal.mul(stopTime.sub(r.createTime)).div(r.heaven.mul(periodUnit));\n', '        if (r.stopTime > 0) {\n', '            // total income  =  54ADAO * 12 / 1000 * 周期时间\n', '            // total = amount * scale / 1000 * 周期时间\n', '            uint256 _total = oneTotal\n', '            .mul(r.stopTime.sub(r.createTime).div(r.heaven.mul(periodUnit)));\n', '            if (_income > _total) {\n', '                _income = _total;\n', '            }\n', '        }\n', '        _income = _income.sub(r.releaseAmount);\n', '        // 如果收益大于了平台余额，那么就不给币了\n', '        uint256 _balance = _tokenB.balanceOf(address(this));\n', '        if (_income > 0 && _income > _balance) {\n', '            _income = _balance;\n', '        }\n', '        return (_income);\n', '    }\n', '\n', '\n', '    function getAmount(address user) public view returns (uint256 token0, uint256 token1){\n', '        if (userUse[user]) {\n', '            return (token0, token1);\n', '        }\n', '\n', '        (\n', '        uint256 [4] memory page,\n', '        uint256 [] memory data\n', '        ) = _pledgeMining.getUserRecords(user, 0, 10000);\n', '\n', '        uint256 len = page[0];\n', '        uint256 prop_count = page[3];\n', '        for (uint256 i = 0; i < len; i++) {\n', '            Record memory r = Record(\n', '                data[i * prop_count + 0],\n', '                data[i * prop_count + 1],\n', '                data[i * prop_count + 2],\n', '                data[i * prop_count + 3],\n', '                data[i * prop_count + 4],\n', '                data[i * prop_count + 5],\n', '                data[i * prop_count + 6],\n', '                data[i * prop_count + 7]\n', '            );\n', '            if (r.over == uint256(1)) {\n', '                token1 = token1.add(calcReceiveIncome(r));\n', '                token0 = token0.add(r.pledgeAmount);\n', '            }\n', '\n', '        }\n', '        return (token0, token1);\n', '    }\n', '\n', '    event Withdraw(address indexed user, uint256 indexed token0, uint256 indexed token1);\n', '\n', '    function withdraw() public mining {\n', '        require(!userUse[msg.sender], "withdraw Use");\n', '        (uint256 token0, uint256 token1) = getAmount(msg.sender);\n', '        userUse[msg.sender] = true;\n', '        userTokenA[msg.sender] = userTokenA[msg.sender].add(token0);\n', '        userTokenB[msg.sender] = userTokenB[msg.sender].add(token1);\n', '        if (token0 > 0) {\n', '            require(address(_tokenA).safeTransfer(msg.sender, token0), "SAFE_TRANSFER_ERROR TOKEN0");\n', '        }\n', '        if (token1 > 0) {\n', '            require(address(_tokenB).safeTransfer(msg.sender, token1), "SAFE_TRANSFER_ERROR TOKEN1");\n', '        }\n', '        emit Withdraw(msg.sender, token0, token1);\n', '    }\n', '}']