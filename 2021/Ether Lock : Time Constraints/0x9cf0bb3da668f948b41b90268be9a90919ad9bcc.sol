['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-15\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.7.0;\n', '\n', 'library Address {\n', '  function isContract(address account) internal view returns (bool) {\n', '    uint256 size;\n', '    assembly { size := extcodesize(account) }\n', '    return size > 0;\n', '  }\n', '\n', '  function sendValue(address payable recipient, uint256 amount) internal {\n', '    require(address(this).balance >= amount, "Address: insufficient balance");\n', '    (bool success, ) = recipient.call{ value: amount }("");\n', '    require(success, "Address: unable to send value, recipient may have reverted");\n', '  }\n', '\n', '  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '    return functionCall(target, data, "Address: low-level call failed");\n', '  }\n', '\n', '  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '    return _functionCallWithValue(target, data, 0, errorMessage);\n', '  }\n', '\n', '  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '    return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '  }\n', '\n', '  function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '    require(address(this).balance >= value, "Address: insufficient balance for call");\n', '    return _functionCallWithValue(target, data, value, errorMessage);\n', '  }\n', '\n', '  function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '    require(isContract(target), "Address: call to non-contract");\n', '    (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '    if (success) {\n', '      return returndata;\n', '    } else {\n', '      if (returndata.length > 0) {\n', '        assembly {\n', '          let returndata_size := mload(returndata)\n', '          revert(add(32, returndata), returndata_size)\n', '        }\n', '      } else {\n', '        revert(errorMessage);\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return sub(a, b, "SafeMath: subtraction overflow");\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '    require(b <= a, errorMessage);\n', '    uint256 c = a - b;\n', '    return c;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return div(a, b, "SafeMath: division by zero");\n', '  }\n', '\n', '  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '    require(b > 0, errorMessage);\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return mod(a, b, "SafeMath: modulo by zero");\n', '  }\n', '\n', '  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '    require(b != 0, errorMessage);\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'library SafeERC20 {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '\n', '  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '  }\n', '\n', '  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '  }\n', '\n', '  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '    require((value == 0) || (token.allowance(address(this), spender) == 0), "SafeERC20: approve from non-zero to non-zero allowance");\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '  }\n', '\n', '  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '  }\n', '\n', '  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '    uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '  }\n', '\n', '  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '    bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '    if (returndata.length > 0) {\n', '      require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '    }\n', '  }\n', '}\n', '\n', 'library TransferHelper {\n', '  function safeApprove(address token, address to, uint value) internal {\n', '    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '  }\n', '\n', '  function safeTransfer(address token, address to, uint value) internal {\n', '    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '  }\n', '\n', '  function safeTransferFrom(address token, address from, address to, uint value) internal {\n', '    (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "    require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '  }\n', '}\n', '\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address account) external view returns (uint256);\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IFarmFactory {\n', '  function userEnteredFarm(address _user) external;\n', '  function userLeftFarm(address _user) external;\n', '  function registerFarm(address _farmAddress) external;\n', '}\n', '\n', 'contract RewardHolder {\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for IERC20;\n', '\n', '  address public farmGenerator;\n', '  address public farm;\n', '  address public rewardToken;\n', '  uint256 public farmableSupply;\n', '\n', '  constructor(address _farmGenerator, address _farm) public {\n', '    farmGenerator = _farmGenerator;\n', '    farm = _farm;\n', '  }\n', '\n', '  function init(address _rewardToken, uint256 _amount) public {\n', '    address msgSender = msg.sender;\n', '    TransferHelper.safeTransferFrom(_rewardToken, msgSender, address(this), _amount);\n', '    TransferHelper.safeApprove(_rewardToken, farm, _amount);\n', '    rewardToken = _rewardToken;\n', '    farmableSupply = _amount;\n', '  }\n', '}\n', '\n', '\n', 'contract FarmStaking {\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for IERC20;\n', '\n', '  /// @notice information stuct on each user than stakes tokens.\n', '  struct UserInfo {\n', '    uint256 amount;     // How many tokens the user has provided.\n', '    uint256 rewardDebt; // Reward debt.\n', '  }\n', '\n', '  /// @notice all the settings for this farm in one struct\n', '  struct FarmInfo {\n', '    IERC20 token;\n', '    IERC20 rewardToken;\n', '    address rewardHolder;\n', '    uint256 startBlock;\n', '    uint256 blockReward;\n', '    uint256 bonusEndBlock;\n', '    uint256 bonus;\n', '    uint256 endBlock;\n', '    uint256 lastRewardBlock;   // Last block number that reward distribution occurs.\n', '    uint256 accRewardPerShare; // Accumulated Rewards per share, times 1e12\n', '    uint256 farmableSupply;    // set in init, total amount of tokens farmable\n', '    uint256 numFarmers;\n', '  }\n', '\n', '  /// @notice farm type id. Useful for back-end systems to know how to read the contract (ABI) as we plan to launch multiple farm types\n', '  uint256 public farmType = 2;\n', '\n', '  IFarmFactory public factory;\n', '  address public farmGenerator;\n', '\n', '  FarmInfo public farmInfo;\n', '\n', '  /// @notice information on each user than stakes tokens\n', '  mapping (address => UserInfo) public userInfo;\n', '\n', '  event Deposit(address indexed user, uint256 amount);\n', '  event Withdraw(address indexed user, uint256 amount);\n', '  event EmergencyWithdraw(address indexed user, uint256 amount);\n', '\n', '  constructor(address _factory, address _farmGenerator) public {\n', '    factory = IFarmFactory(_factory);\n', '    farmGenerator = _farmGenerator;\n', '  }\n', '\n', '  /**\n', '   * @notice initialize the farming contract. This is called only once upon farm creation and the FarmGenerator ensures the farm has the correct paramaters\n', '   */\n', '  function init(address _rewardHolder, IERC20 _rewardToken, uint256 _amount, IERC20 _token, uint256 _blockReward, uint256 _startBlock, uint256 _endBlock, uint256 _bonusEndBlock, uint256 _bonus) public {\n', '    address msgSender = _msgSender();\n', "    require(msgSender == address(farmGenerator), 'FORBIDDEN');\n", '\n', '    farmInfo.rewardToken = _rewardToken;\n', '    farmInfo.rewardHolder = _rewardHolder;\n', '\n', '    farmInfo.startBlock = _startBlock;\n', '    farmInfo.blockReward = _blockReward;\n', '    farmInfo.bonusEndBlock = _bonusEndBlock;\n', '    farmInfo.bonus = _bonus;\n', '\n', '    uint256 lastRewardBlock = block.number > _startBlock ? block.number : _startBlock;\n', '    farmInfo.token = _token;\n', '    farmInfo.lastRewardBlock = lastRewardBlock;\n', '    farmInfo.accRewardPerShare = 0;\n', '\n', '    farmInfo.endBlock = _endBlock;\n', '    farmInfo.farmableSupply = _amount;\n', '  }\n', '\n', '  /**\n', '   * @notice Gets the reward multiplier over the given _from_block until _to block\n', '   * @param _from_block the start of the period to measure rewards for\n', '   * @param _to the end of the period to measure rewards for\n', '   * @return The weighted multiplier for the given period\n', '   */\n', '  function getMultiplier(uint256 _from_block, uint256 _to) public view returns (uint256) {\n', '    uint256 _from = _from_block >= farmInfo.startBlock ? _from_block : farmInfo.startBlock;\n', '    uint256 to = farmInfo.endBlock > _to ? _to : farmInfo.endBlock;\n', '    if (to <= farmInfo.bonusEndBlock) {\n', '      return to.sub(_from).mul(farmInfo.bonus);\n', '    } else if (_from >= farmInfo.bonusEndBlock) {\n', '      return to.sub(_from);\n', '    } else {\n', '      return farmInfo.bonusEndBlock.sub(_from).mul(farmInfo.bonus).add(\n', '        to.sub(farmInfo.bonusEndBlock)\n', '      );\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice function to see accumulated balance of reward token for specified user\n', '   * @param _user the user for whom unclaimed tokens will be shown\n', '   * @return total amount of withdrawable reward tokens\n', '   */\n', '  function pendingReward(address _user) external view returns (uint256) {\n', '    UserInfo storage user = userInfo[_user];\n', '    uint256 accRewardPerShare = farmInfo.accRewardPerShare;\n', '    uint256 tokenSupply = farmInfo.token.balanceOf(address(this));\n', '    if (block.number > farmInfo.lastRewardBlock && tokenSupply != 0) {\n', '      uint256 multiplier = getMultiplier(farmInfo.lastRewardBlock, block.number);\n', '      uint256 tokenReward = multiplier.mul(farmInfo.blockReward);\n', '      accRewardPerShare = accRewardPerShare.add(tokenReward.mul(1e12).div(tokenSupply));\n', '    }\n', '    return user.amount.mul(accRewardPerShare).div(1e12).sub(user.rewardDebt);\n', '  }\n', '\n', '  /**\n', '   * @notice updates pool information to be up to date to the current block\n', '   */\n', '  function updatePool() public {\n', '    if (block.number <= farmInfo.lastRewardBlock) {\n', '      return;\n', '    }\n', '    uint256 tokenSupply = farmInfo.token.balanceOf(address(this));\n', '    if (tokenSupply == 0) {\n', '      farmInfo.lastRewardBlock = block.number < farmInfo.endBlock ? block.number : farmInfo.endBlock;\n', '      return;\n', '    }\n', '    uint256 multiplier = getMultiplier(farmInfo.lastRewardBlock, block.number);\n', '    uint256 tokenReward = multiplier.mul(farmInfo.blockReward);\n', '    farmInfo.accRewardPerShare = farmInfo.accRewardPerShare.add(tokenReward.mul(1e12).div(tokenSupply));\n', '    farmInfo.lastRewardBlock = block.number < farmInfo.endBlock ? block.number : farmInfo.endBlock;\n', '  }\n', '\n', '  /**\n', '   * @notice deposit token function for msgSender\n', '   * @param _amount the total deposit amount\n', '   */\n', '  function deposit(uint256 _amount) public {\n', '    address msgSender = _msgSender();\n', '    UserInfo storage user = userInfo[msgSender];\n', '    updatePool();\n', '    if (user.amount > 0) {\n', '      uint256 pending = user.amount.mul(farmInfo.accRewardPerShare).div(1e12).sub(user.rewardDebt);\n', '      safeRewardTransfer(msgSender, pending);\n', '    }\n', '    if (user.amount == 0 && _amount > 0) {\n', '      factory.userEnteredFarm(msgSender);\n', '      farmInfo.numFarmers = farmInfo.numFarmers.add(1);\n', '    }\n', '    farmInfo.token.safeTransferFrom(address(msgSender), address(this), _amount);\n', '    user.amount = user.amount.add(_amount);\n', '    user.rewardDebt = user.amount.mul(farmInfo.accRewardPerShare).div(1e12);\n', '    emit Deposit(msgSender, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice withdraw token function for msgSender\n', '   * @param _amount the total withdrawable amount\n', '   */\n', '  function withdraw(uint256 _amount) public {\n', '    address msgSender = _msgSender();\n', '    UserInfo storage user = userInfo[msgSender];\n', '    require(user.amount >= _amount, "INSUFFICIENT");\n', '    updatePool();\n', '    if (user.amount == _amount && _amount > 0) {\n', '      factory.userLeftFarm(msgSender);\n', '      farmInfo.numFarmers = farmInfo.numFarmers.sub(1);\n', '    }\n', '    uint256 pending = user.amount.mul(farmInfo.accRewardPerShare).div(1e12).sub(user.rewardDebt);\n', '    safeRewardTransfer(msgSender, pending);\n', '    user.amount = user.amount.sub(_amount);\n', '    user.rewardDebt = user.amount.mul(farmInfo.accRewardPerShare).div(1e12);\n', '    farmInfo.token.safeTransfer(address(msgSender), _amount);\n', '    emit Withdraw(msgSender, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice emergency functoin to withdraw tokens and forego harvest rewards. Important to protect users tokens\n', '   */\n', '  function emergencyWithdraw() public {\n', '    address msgSender = _msgSender();\n', '    UserInfo storage user = userInfo[msgSender];\n', '    farmInfo.token.safeTransfer(address(msgSender), user.amount);\n', '    emit EmergencyWithdraw(msgSender, user.amount);\n', '    if (user.amount > 0) {\n', '      factory.userLeftFarm(msgSender);\n', '      farmInfo.numFarmers = farmInfo.numFarmers.sub(1);\n', '    }\n', '    user.amount = 0;\n', '    user.rewardDebt = 0;\n', '  }\n', '\n', '  /**\n', '   * @notice Safe reward transfer function, just in case a rounding error causes pool to not have enough reward tokens\n', '   * @param _to the user address to transfer tokens to\n', '   * @param _amount the total amount of tokens to transfer\n', '   */\n', '  function safeRewardTransfer(address _to, uint256 _amount) internal {\n', '    uint256 rewardBal = farmInfo.rewardToken.balanceOf(farmInfo.rewardHolder);\n', '    if (_amount > rewardBal) {\n', '      farmInfo.rewardToken.transferFrom(farmInfo.rewardHolder, _to, rewardBal);\n', '    } else {\n', '      farmInfo.rewardToken.transferFrom(farmInfo.rewardHolder, _to, _amount);\n', '    }\n', '  }\n', '\n', '  function _msgSender() internal view virtual returns (address payable) {\n', '    return msg.sender;\n', '  }\n', '}']