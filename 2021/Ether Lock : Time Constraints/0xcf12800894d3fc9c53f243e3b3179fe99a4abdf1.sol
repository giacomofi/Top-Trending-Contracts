['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-30\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-28\n', '*/\n', '\n', 'pragma solidity 0.6.0;\n', '\n', 'interface IERC777 {\n', '    function name() external view returns(string memory);\n', '    function symbol() external view returns(string memory);\n', '    function decimals() external view returns(uint8);\n', '    function totalSupply() external view returns(uint256);\n', '    function balanceOf(address owner) external view returns(uint256);\n', '    function transfer(address to, uint256 amount) external returns(bool);\n', '    function transferFrom(address from, address to, uint256 amount) external returns(bool);\n', '    function approve(address spender, uint256 amount) external returns(bool);\n', '    function allowance(address owner, address spender) external view returns(uint256);\n', '    function burnBalance(address _addr, uint _amount) external;\n', '    function mint(address _tokenHolder, uint256 _amount, bytes calldata _data, bytes calldata _operatorData) external;\n', '    function defaultOperators() external view returns(address[] memory);\n', '\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    event Transfer(address indexed from, address indexed to, uint256 amount);\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '}\n', '\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers.\n', '     * (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. \n', '     * (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns(uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', 'contract SeekReward {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Investor details\n', '    struct user {\n', '        uint256 cycle;\n', '        address upline;\n', '        uint256 referrals;\n', '        uint256 payouts;\n', '        uint256 referalBonus;\n', '        uint256 matchBonus;\n', '        uint256 depositAmount;\n', '        uint256 depositPayouts;\n', '        uint40 depositTime;\n', '        uint256 totalDeposits;\n', '        uint256 totalStructure;\n', '    }\n', '    \n', '    // Token instance\n', '    IERC777 public token;\n', '\n', '    // Mapping users details by address\n', '    mapping(address => user)public users;\n', '\n', '    // Contract status\n', '    bool public lockStatus;\n', '    // Admin1 address\n', '    address public admin1;\n', '    // Admin2 address\n', '    address public admin2;\n', '    // Total levels\n', '    uint[]public Levels;\n', '    // Total users count\n', '    uint256 public totalUsers = 1;\n', '    // Total deposit amount.\n', '    uint256 public totalDeposited;\n', '    // Total withdraw amount\n', '    uint256 public totalWithdraw;\n', '\n', '    // Matching bonus event\n', '    event MatchBonus(address indexed from, address indexed to, uint value, uint time);\n', '    // Withdraw event\n', '    event Withdraw(address indexed from, uint value, uint time);\n', '    // Deposit event\n', '    event Deposit(address indexed from, address indexed refer, uint value, uint time);\n', '    // Admin withdraw event\n', '    event AdminEarnings(address indexed user, uint value, uint time);\n', '    // User withdraw limt event\n', '    event LimitReached(address indexed from, uint value, uint time);\n', '   \n', '    /**\n', '     * @dev Initializes the contract setting the owners and token.\n', '     */\n', '    constructor(address  _owner1, address  _owner2, address _token) public {\n', '        admin1 = _owner1;\n', '        admin2 = _owner2;\n', '        token = IERC777(_token);\n', '\n', '        //Levels maximum amount\n', '        Levels.push(6000e18);\n', '        Levels.push(6000e18);\n', '        Levels.push(6000e18);\n', '        Levels.push(6000e18);\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(msg.sender == admin1, "SeekReward: Only Owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if lockStatus is true\n', '     */\n', '    modifier isLock() {\n', '        require(lockStatus == false, "SeekReward: Contract Locked");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by other contract\n', '     */\n', '    modifier isContractCheck(address _user) {\n', '        require(!isContract(_user), "SeekReward: Invalid address");\n', '        _;\n', '    }\n', '\n', '    function _setUpline(address _addr, address _upline) private {\n', '        if (users[_addr].upline == address(0) && _upline != _addr && _addr != admin1 && \n', '           (users[_upline].depositTime > 0 || _upline == admin1)) {\n', '            users[_addr].upline = _upline;\n', '            users[_upline].referrals = users[_upline].referrals.add(1);\n', '            totalUsers++;\n', '            for (uint8 i = 0; i < 21; i++) { // For update total structure for uplines\n', '                if (_upline == address(0)) break;\n', '                users[_upline].totalStructure++;\n', '                _upline = users[_upline].upline;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _deposit(address _addr, uint256 _amount) private {\n', '        require(users[_addr].upline != address(0) || _addr == admin1, "No upline");\n', '        if (users[_addr].depositTime > 0) {\n', '            users[_addr].cycle++;\n', '            require(users[_addr].payouts >= this.maxPayoutOf(users[_addr].depositAmount),\n', '            "SeekReward: Deposit already exists");\n', '            require(_amount >= users[_addr].depositAmount && _amount <= Levels[users[_addr].cycle > Levels.length - 1 ?Levels.length - 1 : users[_addr].cycle], "SeekReward: Bad amount");\n', '        }\n', '        else {\n', '            require(_amount >= 0.5e18 && _amount <= Levels[0], "SeekReward: Bad amount");\n', '        }\n', '        require(token.transferFrom(msg.sender, address(this), _amount), "Seekreward: transaction failed");\n', '\n', '        users[_addr].payouts = 0;\n', '        users[_addr].depositAmount = _amount;\n', '        users[_addr].depositPayouts = 0;\n', '        users[_addr].depositTime = uint40(block.timestamp);\n', '        users[_addr].referalBonus = 0;\n', '        users[_addr].matchBonus = 0;\n', '        users[_addr].totalDeposits = users[_addr].totalDeposits.add(_amount);\n', '        totalDeposited = totalDeposited.add(_amount);\n', '\n', '        address upline = users[_addr].upline;\n', '        address up = users[users[_addr].upline].upline;\n', '\n', '        if (upline != address(0)) {\n', '            token.transfer(upline, _amount.mul(10e18).div(100e18)); // 10% for direct referer\n', '            users[upline].referalBonus = users[upline].referalBonus.add(_amount.mul(10e18).div(100e18));\n', '        }\n', '        if (up != address(0)) {\n', '            token.transfer(up, _amount.mul(5e18).div(100e18)); // 5% for indirect referer\n', '            users[up].referalBonus = users[up].referalBonus.add(_amount.mul(5e18).div(100e18));\n', '        }\n', '\n', '        uint adminFee = _amount.mul(5e18).div(100e18);\n', '        token.transfer(admin1, adminFee.div(2)); // 2.5% admin1\n', '        token.transfer(admin2, adminFee.div(2)); // 2.5% admin2\n', '        adminFee = 0;\n', '        emit Deposit(_addr, users[_addr].upline, _amount, block.timestamp);\n', '    }\n', '\n', '    /**\n', '     * @dev deposit: User deposit with 1 seek token\n', '     * 5% adminshare split into 2 accounts\n', '     * @param _upline: Referal address\n', '     * @param amount:1st deposit minimum 1 seek & maximum 150 for cycle 1\n', '     * Next depsoit amount based on previous deposit amount and maximum amount based on cycles\n', '     */\n', '    function deposit(address _upline, uint amount) external isLock isContractCheck(msg.sender) {\n', '        _setUpline(msg.sender, _upline);\n', '        _deposit(msg.sender, amount);\n', '    }\n', '    \n', '    function _matchBonus(address _user, uint _amount) private {\n', '        address up = users[_user].upline;\n', '        for (uint i = 1; i <= 21; i++) { // For matching bonus\n', '            if (up == address(0)) break;\n', '            if (i <= 3) {\n', '                users[up].matchBonus = users[up].matchBonus.add(_amount); \n', '                emit MatchBonus(_user, up, _amount, block.timestamp);\n', '            }\n', '            else if (i <= 6) {\n', '                if (users[up].referrals >= 2) {\n', '                    users[up].matchBonus = users[up].matchBonus.add(_amount);\n', '                    emit MatchBonus(_user, up, _amount, block.timestamp);\n', '                }\n', '            }\n', '            else if (i <= 10) {\n', '                if (users[up].referrals >= 4) {\n', '                    users[up].matchBonus = users[up].matchBonus.add(_amount);\n', '                    emit MatchBonus(_user, up, _amount, block.timestamp);\n', '                }\n', '            }\n', '            else if (i <= 14) {\n', '                if (users[up].referrals >= 8) {\n', '                    users[up].matchBonus = users[up].matchBonus.add(_amount);\n', '                    emit MatchBonus(_user, up, _amount, block.timestamp);\n', '                }\n', '            }\n', '            else if (i <= 21) {\n', '                if (users[up].referrals >= 16) {\n', '                    users[up].matchBonus = users[up].matchBonus.add(_amount);\n', '                    emit MatchBonus(_user, up, _amount, block.timestamp);\n', '                }\n', '            }\n', '            up = users[up].upline;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw: User can get amount till maximum payout reach.\n', '     * maximum payout based on(daily ROI,matchbonus)\n', '     * maximum payout limit 210 percentage\n', '     */\n', '    function withdraw() external isLock {\n', '        (uint256 to_payout, uint256 max_payout) = this.payoutOf(msg.sender);\n', '        require(msg.sender != admin1, "SeekReward: only for users");\n', '        require(users[msg.sender].payouts < max_payout, "SeekReward: Full payouts");\n', '        // Deposit payout\n', '        if (to_payout > 0) {\n', '            if (users[msg.sender].payouts.add(to_payout) > max_payout) {\n', '                to_payout = max_payout.sub(users[msg.sender].payouts);\n', '            }\n', '            users[msg.sender].depositPayouts = users[msg.sender].depositPayouts.add(to_payout);\n', '            users[msg.sender].payouts = users[msg.sender].payouts.add(to_payout);\n', '            _matchBonus(msg.sender, to_payout.mul(3e18).div(100e18));\n', '        }\n', '        // matching bonus\n', '        if (users[msg.sender].payouts < max_payout && users[msg.sender].matchBonus > 0) {\n', '            if (users[msg.sender].payouts.add(users[msg.sender].matchBonus) > max_payout) {\n', '                users[msg.sender].matchBonus = max_payout.sub(users[msg.sender].payouts);\n', '            }\n', '            users[msg.sender].payouts = users[msg.sender].payouts.add(users[msg.sender].matchBonus);\n', '            to_payout = to_payout.add(users[msg.sender].matchBonus);\n', '            users[msg.sender].matchBonus = users[msg.sender].matchBonus.sub(users[msg.sender].matchBonus);\n', '        }\n', '        totalWithdraw = totalWithdraw.add(to_payout);\n', '        token.transfer(msg.sender, to_payout); // Daily roi and matching bonus\n', '        emit Withdraw(msg.sender, to_payout, block.timestamp);\n', '\n', '        if (users[msg.sender].payouts >= max_payout) {\n', '            emit LimitReached(msg.sender, users[msg.sender].payouts, block.timestamp);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev adminWithdraw: owner invokes the function\n', '     * owner can get referbonus, matchbonus \n', '     */\n', '    function adminWithdraw() external onlyOwner {\n', '        uint amount;\n', '        if (users[admin1].referalBonus > 0) {\n', '            amount = amount.add(users[admin1].referalBonus);\n', '            users[admin1].referalBonus = 0;\n', '        }\n', '        if (users[admin1].matchBonus > 0) {\n', '            amount = amount.add(users[admin1].matchBonus);\n', '            users[admin1].matchBonus = 0;\n', '        }\n', '        token.transfer(admin1, amount); //Referal bonus and matching bonus\n', '        emit AdminEarnings(admin1, amount, block.timestamp);\n', '    }\n', '\n', '    /**\n', '     * @dev maxPayoutOf: Amount calculate by 210 percentage\n', '     */\n', '    function maxPayoutOf(uint256 _amount) external pure returns(uint256) {\n', '        return _amount.mul(210).div(100);\n', '    }\n', '\n', '    /**\n', '     * @dev payoutOf: Users daily ROI and maximum payout will be show\n', '     */\n', '    function payoutOf(address _addr) external view returns(uint256 payout, uint256 max_payout) {\n', '        max_payout = this.maxPayoutOf(users[_addr].depositAmount);\n', '        if (users[_addr].depositPayouts < max_payout) {\n', '            payout = ((users[_addr].depositAmount.mul(1e18).div(100e18)).mul((block.timestamp\n', '            .sub(users[_addr].depositTime)).div(1 days))).sub(users[_addr].depositPayouts); // Daily roi\n', '            if (users[_addr].depositPayouts.add(payout) > max_payout) {\n', '                payout = max_payout.sub(users[_addr].depositPayouts);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev userInfo: Returns upline,depositTime,depositAmount,payouts,match_bonus\n', '     */\n', '    function userInfo(address _addr) external view returns(address upline, uint40 deposit_time,\n', '    uint256 deposit_amount, uint256 payouts, uint256 match_bonus) {\n', '        return (users[_addr].upline, users[_addr].depositTime, users[_addr].depositAmount,\n', '                users[_addr].payouts, users[_addr].matchBonus);\n', '    }\n', '\n', '    /**\n', '     * @dev userInfoTotals: Returns users referrals count, totalDeposit, totalStructure\n', '     */\n', '    function userInfoTotals(address _addr) external view returns(uint256 referrals,\n', '    uint256 total_deposits, uint256 total_structure) {\n', '        return (users[_addr].referrals, users[_addr].totalDeposits, users[_addr].totalStructure);\n', '    }\n', '\n', '    /**\n', '     * @dev contractInfo: Returns total users, totalDeposited, totalWithdraw\n', '     */\n', '    function contractInfo() external view returns(uint256 _total_users, uint256 _total_deposited,\n', '    uint256 _total_withdraw) {\n', '        return (totalUsers, totalDeposited, totalWithdraw);\n', '    }\n', '\n', '    /**\n', '     * @dev contractLock: For contract status\n', '     */\n', '    function contractLock(bool _lockStatus) public onlyOwner returns(bool) {\n', '        lockStatus = _lockStatus;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev failSafe: Returns transfer token\n', '     */\n', '    function failSafe(address _toUser, uint _amount) external onlyOwner returns(bool) {\n', '        require(_toUser != address(0), "Invalid Address");\n', '        require(token.balanceOf(address(this)) >= _amount, "SeekReward: insufficient amount");\n', '        token.transfer(_toUser, _amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev isContract: Returns true if account is a contract\n', '     */\n', '    function isContract(address _account) public view returns(bool) {\n', '        uint32 size;\n', '        assembly {\n', '            size:= extcodesize(_account)\n', '        }\n', '        if (size != 0)\n', '            return true;\n', '        return false;\n', '    }\n', '}']