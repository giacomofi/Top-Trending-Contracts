['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-10\n', '*/\n', '\n', '// File: contracts/utils/Ownable.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'contract Ownable {\n', '    address private _contract_owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = msg.sender;\n', '        _contract_owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _contract_owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_contract_owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_contract_owner, newOwner);\n', '        _contract_owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/utils/SafeMath.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'library SafeMath {\n', '    function safeAdd(uint a, uint b) public pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a, "add");\n', '    }\n', '    function safeSub(uint a, uint b) public pure returns (uint c) {\n', '        require(b <= a, "sub");\n', '        c = a - b;\n', '    }\n', '    function safeMul(uint a, uint b) public pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b, "mul");\n', '    }\n', '    function safeDiv(uint a, uint b) public pure returns (uint c) {\n', '        require(b > 0, "div");\n', '        c = a / b;\n', '    }\n', '}\n', '\n', '// File: contracts/utils/Address.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: contracts/erc20/IERC20.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/erc20/SafeERC20.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', '\n', '\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).safeAdd(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).safeSub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/core/HPeriod.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', '\n', 'contract HPeriod{\n', '  using SafeMath for uint;\n', '\n', '  uint256 period_start_block;\n', '  uint256 period_block_num;\n', '  uint256 period_gap_block;\n', '\n', '  struct period_info{\n', '    uint256 period;\n', '    uint256 start_block;\n', '    uint256 end_block;    // [start_block, end_block)\n', '  }\n', '\n', '  mapping (uint256 => period_info) all_periods;\n', '  uint256 current_period;\n', '\n', '  bool is_gapping;\n', '\n', '  constructor(uint256 _start_block, uint256 _period_block_num, uint256 _gap_block_num) public{\n', '    period_start_block = _start_block;\n', '    period_block_num = _period_block_num;\n', '\n', '    period_gap_block = _gap_block_num;\n', '    current_period = 0;\n', '    is_gapping = true;\n', '  }\n', '\n', '  function _end_current_and_start_new_period() internal returns(bool){\n', '    require(block.number >= period_start_block, "1st period not start yet");\n', '\n', '    if(is_gapping){\n', '      if(current_period == 0 || block.number.safeSub(all_periods[current_period].end_block) >= period_gap_block){\n', '        current_period = current_period + 1;\n', '        all_periods[current_period].period = current_period;\n', '        all_periods[current_period].start_block = block.number;\n', '        is_gapping = false;\n', '        return true;\n', '      }\n', '    }else{\n', '      if(block.number.safeSub(all_periods[current_period].start_block) >= period_block_num){\n', '        all_periods[current_period].end_block = block.number;\n', '        is_gapping = true;\n', '      }\n', '    }\n', '    return false;\n', '  }\n', '\n', '\n', '  event HPeriodChanged(uint256 old, uint256 new_period);\n', '  function _change_period(uint256 _period) internal{\n', '    uint256 old = period_block_num;\n', '    period_block_num = _period;\n', '    emit HPeriodChanged(old, period_block_num);\n', '  }\n', '\n', '  function getCurrentPeriodStartBlock() public view returns(uint256){\n', '    (, uint256 s, ) = getPeriodInfo(current_period);\n', '    return s;\n', '  }\n', '\n', '  function getPeriodInfo(uint256 period) public view returns(uint256 p, uint256 s, uint256 e){\n', '    p = all_periods[period].period;\n', '    s = all_periods[period].start_block;\n', '    e = all_periods[period].end_block;\n', '  }\n', '\n', '  function getParamPeriodStartBlock() public view returns(uint256){\n', '    return period_start_block;\n', '  }\n', '\n', '  function getParamPeriodBlockNum() public view returns(uint256){\n', '    return period_block_num;\n', '  }\n', '\n', '  function getParamPeriodGapNum() public view returns(uint256){\n', '    return period_gap_block;\n', '  }\n', '\n', '  function getCurrentPeriod() public view returns(uint256){\n', '    return current_period;\n', '  }\n', '\n', '  function isPeriodEnd(uint256 _period) public view returns(bool){\n', '    return all_periods[_period].end_block != 0;\n', '  }\n', '\n', '  function isPeriodStart(uint256 _period) public view returns(bool){\n', '    return all_periods[_period].start_block != 0;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/core/HPeriodToken.sol\n', '\n', 'pragma solidity >=0.4.21 <0.6.0;\n', '\n', '\n', '\n', '\n', '\n', 'contract HTokenFactoryInterface{\n', '  function createFixedRatioToken(address _token_addr, uint256 _period, uint256 _ratio, string memory _postfix) public returns(address);\n', '  function createFloatingToken(address _token_addr, uint256 _period, string memory _postfix) public returns(address);\n', '}\n', '\n', 'contract HTokenInterface{\n', '  function mint(address addr, uint256 amount)public;\n', '  function burnFrom(address addr, uint256 amount) public;\n', '  uint256 public period_number;\n', '  uint256 public ratio; // 0 is for floating\n', '  uint256 public underlying_balance;\n', '  function setUnderlyingBalance(uint256 _balance) public;\n', '  function setTargetToken(address _target) public;\n', '}\n', '\n', 'contract HPeriodToken is HPeriod, Ownable{\n', '\n', '  struct period_token_info{\n', '    address[] period_tokens;\n', '\n', '    mapping(bytes32 => address) hash_to_tokens;\n', '  }\n', '\n', '  mapping (uint256 => period_token_info) all_period_tokens;\n', '\n', '  HTokenFactoryInterface public token_factory;\n', '  address public target_token;\n', '\n', '\n', '  constructor(address _target_token, uint256 _start_block, uint256 _period, uint256 _gap, address _factory)\n', '    HPeriod(_start_block, _period, _gap) public{\n', '    target_token = _target_token;\n', '    token_factory = HTokenFactoryInterface(_factory);\n', '  }\n', '\n', '  function uint2str(uint256 i) internal pure returns (string memory c) {\n', '    if (i == 0) return "0";\n', '    uint256 j = i;\n', '    uint256 length;\n', '    while (j != 0){\n', '        length++;\n', '        j /= 10;\n', '    }\n', '    bytes memory bstr = new bytes(length);\n', '    uint256 k = length - 1;\n', '    while (i != 0){\n', '      bstr[k--] = byte(48 + uint8(i % 10));\n', '      i /= 10;\n', '    }\n', '    c = string(bstr);\n', '  }\n', '\n', '  function getOrCreateToken(uint ratio) public onlyOwner returns(address, bool){\n', '\n', '    _end_current_and_start_new_period();\n', '\n', '    uint256 p = getCurrentPeriod();\n', '    bytes32 h = keccak256(abi.encodePacked(target_token, getParamPeriodBlockNum(), ratio, p + 1));\n', '    address c = address(0x0);\n', '\n', '    period_token_info storage pi = all_period_tokens[p + 1];\n', '\n', '    bool s  = false;\n', '    if(pi.hash_to_tokens[h] == address(0x0)){\n', '      if(ratio == 0){\n', '        c = token_factory.createFloatingToken(target_token, p + 1, uint2str(getParamPeriodBlockNum()));\n', '      }\n', '      else{\n', '        c = token_factory.createFixedRatioToken(target_token, p + 1, ratio, uint2str(getParamPeriodBlockNum()));\n', '      }\n', '      HTokenInterface(c).setTargetToken(target_token);\n', '      Ownable ow = Ownable(c);\n', '      ow.transferOwnership(owner());\n', '      pi.period_tokens.push(c);\n', '      pi.hash_to_tokens[h] = c;\n', '      s = true;\n', '    }\n', '    c = pi.hash_to_tokens[h];\n', '\n', '    return(c, s);\n', '  }\n', '\n', '  function updatePeriodStatus() public onlyOwner returns(bool){\n', '    return _end_current_and_start_new_period();\n', '  }\n', '\n', '  function isPeriodTokenValid(address _token_addr) public view returns(bool){\n', '    HTokenInterface hti = HTokenInterface(_token_addr);\n', '    bytes32 h = keccak256(abi.encodePacked(target_token, getParamPeriodBlockNum(), hti.ratio(), hti.period_number()));\n', '    period_token_info storage pi = all_period_tokens[hti.period_number()];\n', '    if(pi.hash_to_tokens[h] == _token_addr){\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '  function totalAtPeriodWithRatio(uint256 _period, uint256 _ratio) public view returns(uint256) {\n', '    bytes32 h = keccak256(abi.encodePacked(target_token, getParamPeriodBlockNum(), _ratio, _period));\n', '    period_token_info storage pi = all_period_tokens[_period];\n', '    address c = pi.hash_to_tokens[h];\n', '    if(c == address(0x0)) return 0;\n', '\n', '    IERC20 e = IERC20(c);\n', '    return e.totalSupply();\n', '  }\n', '\n', '  function htokenAtPeriodWithRatio(uint256 _period, uint256 _ratio) public view returns(address){\n', '    bytes32 h = keccak256(abi.encodePacked(target_token, getParamPeriodBlockNum(), _ratio, _period));\n', '    period_token_info storage pi = all_period_tokens[_period];\n', '    address c = pi.hash_to_tokens[h];\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract HPeriodTokenFactory{\n', '\n', '  event NewPeriodToken(address addr);\n', '  function createPeriodToken(address _target_token, uint256 _start_block, uint256 _period, uint256 _gap, address _token_factory) public returns(address){\n', '    HPeriodToken pt = new HPeriodToken(_target_token, _start_block, _period, _gap, _token_factory);\n', '\n', '    pt.transferOwnership(msg.sender);\n', '    emit NewPeriodToken(address(pt));\n', '    return address(pt);\n', '  }\n', '\n', '}']