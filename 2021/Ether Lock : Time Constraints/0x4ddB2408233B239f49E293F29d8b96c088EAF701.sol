['//SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address tokenOwner)\n', '        external\n', '        view\n', '        returns (uint256 balance);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '}\n', '\n', 'interface IMasterChef {\n', '    struct UserInfo {\n', '        uint256 amount;\n', '        uint256 rewardDebt;\n', '    }\n', '\n', '    function userInfo(uint256 _poolId, address _user)\n', '        external\n', '        view\n', '        returns (IMasterChef.UserInfo memory);\n', '}\n', '\n', 'interface IMuseStaker {\n', '    function userInfo(address _user)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 bal,\n', '            uint256 claimable,\n', '            uint256 deposited,\n', '            uint256 timelock,\n', '            bool isClaimable,\n', '            uint256 globalShares,\n', '            uint256 globalBalance\n', '        );\n', '}\n', '\n', '/*\n', '    This governance voting strategy enables to check the sum of Muse tokens an address has in LP providing and wallet\n', '*/\n', 'contract GetVotes {\n', '    IERC20 public muse = IERC20(0xB6Ca7399B4F9CA56FC27cBfF44F4d2e4Eef1fc81);\n', '    IERC20 public uniLp = IERC20(0x20d2C17d1928EF4290BF17F922a10eAa2770BF43);\n', '    IMasterChef public masterChef =\n', '        IMasterChef(0x193b775aF4BF9E11656cA48724A710359446BF52);\n', '    IMuseStaker public museStaker =\n', '        IMuseStaker(0x4ffDE8e98227c17A64A9df30DfB1d3049457c5Db);\n', '\n', '    function getVotes(address _user) public view returns (uint256) {\n', '        uint256 userMuseBalance = muse.balanceOf(_user);\n', '        // lp tokens from user on masterchef\n', '        uint256 userLpTokens = masterChef.userInfo(0, _user).amount;\n', '        //total supply of of muse in lp\n', '        uint256 museInLpPool = muse.balanceOf(address(uniLp));\n', '        //total supply of lp tokens\n', '        uint256 lpTokensTotalSupply = uniLp.totalSupply();\n', '        // do calc for uniswap\n', '        uint256 museFromStake =\n', '            (museInLpPool / lpTokensTotalSupply) * userLpTokens;\n', '\n', '        //calc muse from single stake\n', '        uint256 claimable;\n', '        uint256 deposited;\n', '\n', '        (, claimable, deposited, , , , ) = museStaker.userInfo(_user);\n', '\n', '        uint256 museFromSingleStake = claimable + deposited;\n', '\n', '        return\n', '            (userMuseBalance + museFromStake + museFromSingleStake) / 1 ether;\n', '    }\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']