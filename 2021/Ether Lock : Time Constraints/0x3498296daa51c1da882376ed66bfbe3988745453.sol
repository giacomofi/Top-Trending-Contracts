['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-23\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.4;\n', '\n', 'contract Owned {\n', '    address public owner;\n', '    address public proposedOwner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() virtual {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev propeses a new owner\n', '     * Can only be called by the current owner.\n', '     */\n', '    function proposeOwner(address payable _newOwner) external onlyOwner {\n', '        proposedOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev claims ownership of the contract\n', '     * Can only be called by the new proposed owner.\n', '     */\n', '    function claimOwnership() external {\n', '        require(msg.sender == proposedOwner);\n', '        emit OwnershipTransferred(owner, proposedOwner);\n', '        owner = proposedOwner;\n', '    }\n', '}\n', '\n', 'interface IPika {\n', '    function minSupply() external returns (uint256);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    function burn(uint256 value) external;\n', '}\n', '\n', 'contract PikaStaking is Owned {\n', '    address public communityWallet;\n', '    uint256 public totalAmountStaked = 0;\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => uint256) public claimPeriods;\n', '    IPika public pika;\n', '    uint256 public periodNonce = 0;\n', '    uint256 public periodFinish;\n', '    uint256 public minPeriodDuration = 14 days;\n', '    uint256 public rewardPerToken = 0;\n', '    uint256 public maxInitializationReward;\n', '\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 amount);\n', '    event RewardClaimed(address indexed user, uint256 amount);\n', '    event StakingPeriodStarted(uint256 totalRewardPool, uint256 periodFinish);\n', '    event MinPeriodDurationUpdated(uint256 oldDuration, uint256 newDuration);\n', '    event MaxInitializationRewardUpdated(uint256 oldValue, uint256 newValue);\n', '\n', '    constructor(address _token, address _communityWallet) {\n', '        pika = IPika(_token);\n', '        communityWallet = _communityWallet;\n', '        maxInitializationReward = 1000000000 ether;\n', '        periodFinish = block.timestamp + 3 days;\n', '    }\n', '\n', '    /**\n', '     * @notice allows a user to stake tokens\n', '     * @dev requires to claim pending rewards before being able to stake more tokens\n', '     * @param _amount of tokens to stake\n', '     */\n', '    function stake(uint256 _amount) public {\n', '        uint256 balance = balances[msg.sender];\n', '        if (balance > 0) {\n', '            require(\n', '                claimPeriods[msg.sender] == periodNonce,\n', '                "Claim your reward before staking more tokens"\n', '            );\n', '        }\n', '        pika.transferFrom(msg.sender, address(this), _amount);\n', '        uint256 burnedAmount = (_amount * 12) / 100;\n', '        if (pika.totalSupply() - burnedAmount >= pika.minSupply()) {\n', '            pika.burn(burnedAmount);\n', '        } else {\n', '            burnedAmount = 0;\n', '        }\n', '        uint256 communityWalletAmount = (_amount * 3) / 100;\n', '        pika.transfer(communityWallet, communityWalletAmount);\n', '        uint256 userBalance = _amount - burnedAmount - communityWalletAmount;\n', '        balances[msg.sender] += userBalance;\n', '        claimPeriods[msg.sender] = periodNonce;\n', '        totalAmountStaked += userBalance;\n', '        emit Staked(msg.sender, userBalance);\n', '    }\n', '\n', '    /**\n', '     * @notice allows a user to withdraw staked tokens\n', '     * @dev unclaimed tokens cannot be claimed after withdrawal\n', '     * @dev unstakes all tokens\n', '     */\n', '    function withdraw() public {\n', '        uint256 balance = balances[msg.sender];\n', '        balances[msg.sender] = 0;\n', '        totalAmountStaked -= balance;\n', '        pika.transfer(msg.sender, balance);\n', '        emit Withdraw(msg.sender, balance);\n', '    }\n', '\n', '    /**\n', '     * @notice claims a reward for the staked tokens\n', '     * @dev can only claim once per staking period\n', '     */\n', '    function claimReward() public {\n', '        uint256 balance = balances[msg.sender];\n', '        require(balance > 0, "No tokens staked");\n', '        require(\n', '            claimPeriods[msg.sender] < periodNonce,\n', '            "Wait for this period to finish before claiming your reward"\n', '        );\n', '        claimPeriods[msg.sender] = periodNonce;\n', '        uint256 reward = (balance * rewardPerToken) / 1 ether;\n', '        pika.transfer(msg.sender, reward);\n', '        emit RewardClaimed(msg.sender, reward);\n', '    }\n', '\n', '    /**\n', '     * @notice returns claimable reward for a user\n', '     * @param _user to check\n', '     */\n', '    function claimableReward(address _user) public view returns (uint256) {\n', '        if (claimPeriods[_user] == periodNonce) {\n', '            return 0;\n', '        }\n', '        return (balances[_user] * rewardPerToken) / 1 ether;\n', '    }\n', '\n', '    /**\n', '     * @notice initializes new staking claim period\n', '     * @dev requires previous staking period to be over\n', '     * @dev only callable by anyone, msg.sender receives a portion of the staking pool as a reward\n', '     */\n', '    function initNewRewardPeriod() external {\n', '        require(\n', '            block.timestamp >= periodFinish,\n', '            "Wait for claim period to finish"\n', '        );\n', '        require(totalAmountStaked > 0, "No tokens staked in contract");\n', '        uint256 rewardPool = pika.balanceOf(address(this)) - totalAmountStaked;\n', '        uint256 initializationReward = rewardPool / 1000;\n', '        if (initializationReward > maxInitializationReward) {\n', '            initializationReward = maxInitializationReward;\n', '        }\n', '        rewardPool -= initializationReward;\n', '        pika.transfer(msg.sender, initializationReward);\n', '        rewardPerToken = (rewardPool * 1 ether) / totalAmountStaked;\n', '        periodNonce++;\n', '        periodFinish = block.timestamp + minPeriodDuration;\n', '        emit StakingPeriodStarted(rewardPool, periodFinish);\n', '    }\n', '\n', '    /**\n', '     * @notice sets a new minimum duration for each staking claim period\n', '     * @dev only callable by owner\n', '     * @param _days amount of days the new staking claim period should at least last\n', '     */\n', '    function setMinDuration(uint256 _days) external onlyOwner {\n', '        emit MinPeriodDurationUpdated(minPeriodDuration / 1 days, _days);\n', '        minPeriodDuration = _days * 1 days;\n', '    }\n', '\n', '    /**\n', '     * @notice sets maximum initialization reward\n', '     * @dev only callable by owner\n', '     * @param _newMaxReward new maximum reward paid out by initNewRewardPeriod function\n', '     */\n', '    function setMaxInitializationReward(uint256 _newMaxReward)\n', '        external\n', '        onlyOwner\n', '    {\n', '        emit MaxInitializationRewardUpdated(\n', '            maxInitializationReward,\n', '            _newMaxReward\n', '        );\n', '        maxInitializationReward = _newMaxReward;\n', '    }\n', '}']