['pragma solidity 0.6.5;\n', '\n', 'import "./PROS.sol";\n', 'import "./SafeMath.sol";\n', 'import "./SafeMath64.sol";\n', '\n', 'contract Vesting {\n', '\n', '  using SafeMath for uint256;\n', '  using SafeMath64 for uint64;\n', '  PROS public token;\n', '  address public owner;\n', '\n', '  uint constant internal SECONDS_PER_DAY = 1 days;\n', '\n', '  event Allocated(address recipient, uint64 startTime, uint256 amount, uint64 vestingDuration, uint64 vestingPeriodInDays, uint _upfront);\n', '  event TokensClaimed(address recipient, uint256 amountClaimed);\n', '\n', '  struct Allocation {\n', '    uint64 vestingDuration; \n', '    uint64 periodClaimed;  \n', '    uint64 periodInDays; \n', '    uint64 startTime; \n', '    uint256 amount;\n', '    uint256 totalClaimed;\n', '  }\n', '  mapping (address => Allocation) public tokenAllocations;\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner, "unauthorized");\n', '    _;\n', '  }\n', '\n', '  modifier nonZeroAddress(address x) {\n', '    require(x != address(0), "token-zero-address");\n', '    _;\n', '  }\n', '\n', '  constructor(address _token, address _owner) public\n', '  nonZeroAddress(_token)\n', '  nonZeroAddress(_owner)\n', '  {\n', '    token = PROS(_token);\n', '    owner = _owner;\n', '  }\n', '\n', '  /// @dev Add a new token vesting for user `_recipient`. Only one vesting per user is allowed\n', '  /// The amount of PROS tokens here need to be preapproved for transfer by this `Vesting` contract before this call\n', '  /// @param _recipient Address array of the token recipient entitled to claim the vested funds\n', '  /// @param _startTime Vesting start time array as seconds since unix epoch \n', '  /// @param _amount Total number of tokens array in vested\n', '  /// @param _vestingDuration Number of Periods in array.\n', '  /// @param _vestingPeriodInDays Array of Number of days in each Period\n', '  /// @param _upFront array of Amount of tokens `_recipient[i]` will get  right away\n', '  function addTokenVesting(address[] memory _recipient, uint64[] memory _startTime, uint256[] memory _amount, uint64[] memory _vestingDuration, uint64[] memory _vestingPeriodInDays, uint256[] memory _upFront) public \n', '  onlyOwner\n', '  {\n', '\n', '    require(_recipient.length == _startTime.length, "Different array length");\n', '    require(_recipient.length == _amount.length, "Different array length");\n', '    require(_recipient.length == _vestingDuration.length, "Different array length");\n', '    require(_recipient.length == _vestingPeriodInDays.length, "Different array length");\n', '    require(_recipient.length == _upFront.length, "Different array length");\n', '\n', '    for(uint i=0;i<_recipient.length;i++) {\n', '      require(tokenAllocations[_recipient[i]].startTime == 0, "token-user-grant-exists");\n', '      require(_startTime[i] != 0, "should be positive");\n', '      uint256 amountVestedPerPeriod = _amount[i].div(_vestingDuration[i]);\n', '      require(amountVestedPerPeriod > 0, "0-amount-vested-per-period");\n', '\n', '      // Transfer the vesting tokens under the control of the vesting contract\n', '      token.transferFrom(owner, address(this), _amount[i].add(_upFront[i]));\n', '\n', '      Allocation memory _allocation = Allocation({\n', '        startTime: _startTime[i], \n', '        amount: _amount[i],\n', '        vestingDuration: _vestingDuration[i],\n', '        periodInDays: _vestingPeriodInDays[i],\n', '        periodClaimed: 0,\n', '        totalClaimed: 0\n', '      });\n', '      tokenAllocations[_recipient[i]] = _allocation;\n', '\n', '      if(_upFront[i] > 0) {\n', '        token.transfer(_recipient[i], _upFront[i]);\n', '      }\n', '\n', '      emit Allocated(_recipient[i], _startTime[i], _amount[i], _vestingDuration[i], _vestingPeriodInDays[i], _upFront[i]);\n', '    }\n', '  }\n', '\n', '  /// @dev Allows a vesting recipient to claim their vested tokens. Errors if no tokens have vested\n', '  /// It is advised recipients check they are entitled to claim via `calculateVestingClaim` before calling this\n', '  function claimVestedTokens() public {\n', '    uint64 periodVested;\n', '    uint256 amountVested;\n', '    (periodVested, amountVested) = calculateVestingClaim(msg.sender);\n', '    require(amountVested > 0, "token-zero-amount-vested");\n', '\n', '    Allocation storage _tokenAllocated = tokenAllocations[msg.sender];\n', '    _tokenAllocated.periodClaimed = _tokenAllocated.periodClaimed.add(periodVested);\n', '    _tokenAllocated.totalClaimed = _tokenAllocated.totalClaimed.add(amountVested);\n', '    \n', '    require(token.transfer(msg.sender, amountVested), "token-sender-transfer-failed");\n', '    emit TokensClaimed(msg.sender, amountVested);\n', '  }\n', '\n', '  /// @dev Calculate the vested and unclaimed period and tokens available for `_recepient` to claim\n', '  /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\n', '  function calculateVestingClaim(address _recipient) public view returns (uint64, uint256) {\n', '    Allocation memory _tokenAllocations = tokenAllocations[_recipient];\n', '\n', "    // For vesting created with a future start date, that hasn't been reached, return 0, 0\n", '    if (now < _tokenAllocations.startTime) {\n', '      return (0, 0);\n', '    }\n', '\n', '    uint256 elapsedTime = now.sub(_tokenAllocations.startTime);\n', '    uint64 elapsedDays = uint64(elapsedTime / SECONDS_PER_DAY);\n', '    \n', '    \n', '    // If over vesting duration, all tokens vested\n', '    if (elapsedDays >= _tokenAllocations.vestingDuration.mul(_tokenAllocations.periodInDays)) {\n', '      uint256 remainingTokens = _tokenAllocations.amount.sub(_tokenAllocations.totalClaimed);\n', '      return (_tokenAllocations.vestingDuration.sub(_tokenAllocations.periodClaimed), remainingTokens);\n', '    } else {\n', '      uint64 elapsedPeriod = elapsedDays.div(_tokenAllocations.periodInDays);\n', '      uint64 periodVested = elapsedPeriod.sub(_tokenAllocations.periodClaimed);\n', '      uint256 amountVestedPerPeriod = _tokenAllocations.amount.div(_tokenAllocations.vestingDuration);\n', '      uint256 amountVested = uint(periodVested).mul(amountVestedPerPeriod);\n', '      return (periodVested, amountVested);\n', '    }\n', '  }\n', '\n', '  /// @dev Returns unclaimed allocation of user. \n', '  function unclaimedAllocation(address _user) external view returns(uint) {\n', '    return tokenAllocations[_user].amount.sub(tokenAllocations[_user].totalClaimed);\n', '  }\n', '}']