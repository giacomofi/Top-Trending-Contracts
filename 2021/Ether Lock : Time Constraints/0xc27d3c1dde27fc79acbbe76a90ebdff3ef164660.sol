['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-11\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.6.12;\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'library RightsManager {\n', '    struct Rights {\n', '        bool canPauseSwapping;\n', '        bool canChangeSwapFee;\n', '        bool canChangeWeights;\n', '        bool canAddRemoveTokens;\n', '        bool canWhitelistLPs;\n', '        bool canChangeCap;\n', '    }\n', '}\n', '\n', 'abstract contract ERC20 {\n', '    function approve(address spender, uint amount) external virtual returns (bool);\n', '    function transfer(address dst, uint amt) external virtual returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external virtual returns (bool);\n', '    function balanceOf(address whom) external view virtual returns (uint);\n', '    function allowance(address, address) external view virtual returns (uint);\n', '}\n', '\n', 'abstract contract BalancerOwnable {\n', '    function setController(address controller) external virtual;\n', '}\n', '\n', 'abstract contract AbstractPool is ERC20, BalancerOwnable {\n', '    function setSwapFee(uint swapFee) external virtual;\n', '    function setPublicSwap(bool public_) external virtual;\n', '    \n', '    function joinPool(uint poolAmountOut, uint[] calldata maxAmountsIn) external virtual;\n', '    function joinswapExternAmountIn(\n', '        address tokenIn, uint tokenAmountIn, uint minPoolAmountOut\n', '    ) external virtual returns (uint poolAmountOut);\n', '    function exitPool(uint poolAmountIn, uint[] calldata minAmountsOut) external virtual;\n', '}\n', '\n', 'abstract contract BPool is AbstractPool {\n', '    function finalize() external virtual;\n', '    function bind(address token, uint balance, uint denorm) external virtual;\n', '    function rebind(address token, uint balance, uint denorm) external virtual;\n', '    function unbind(address token) external virtual;\n', '    function isBound(address t) external view virtual returns (bool);\n', '    function getCurrentTokens() external view virtual returns (address[] memory);\n', '    function getFinalTokens() external view virtual returns(address[] memory);\n', '    function getBalance(address token) external view virtual returns (uint);\n', '}\n', '\n', 'abstract contract BFactory {\n', '    function newBPool() external virtual returns (BPool);\n', '}\n', '\n', 'abstract contract BalancerPool is ERC20 {\n', '    function getPoolId() external view virtual returns (bytes32);\n', '\n', '    enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT }\n', '}\n', '\n', 'abstract contract Vault {\n', '    struct JoinPoolRequest {\n', '        address[] assets;\n', '        uint256[] maxAmountsIn;\n', '        bytes userData;\n', '        bool fromInternalBalance;\n', '    }\n', '\n', '    function joinPool(\n', '        bytes32 poolId,\n', '        address sender,\n', '        address recipient,\n', '        JoinPoolRequest calldata request\n', '    ) external virtual;\n', '    function getPoolTokens(bytes32 poolId) external view virtual returns (address[] memory, uint[] memory, uint256);\n', '}\n', '\n', 'abstract contract ConfigurableRightsPool is AbstractPool {\n', '    struct PoolParams {\n', '        string poolTokenSymbol;\n', '        string poolTokenName;\n', '        address[] constituentTokens;\n', '        uint[] tokenBalances;\n', '        uint[] tokenWeights;\n', '        uint swapFee;\n', '    }\n', '\n', '    struct CrpParams {\n', '        uint initialSupply;\n', '        uint minimumWeightChangeBlockPeriod;\n', '        uint addTokenTimeLockInBlocks;\n', '    }\n', '\n', '    function createPool(\n', '        uint initialSupply, uint minimumWeightChangeBlockPeriod, uint addTokenTimeLockInBlocks\n', '    ) external virtual;\n', '    function createPool(uint initialSupply) external virtual;\n', '    function setCap(uint newCap) external virtual;\n', '    function updateWeight(address token, uint newWeight) external virtual;\n', '    function updateWeightsGradually(\n', '        uint[] calldata newWeights, uint startBlock, uint endBlock\n', '    ) external virtual;\n', '    function commitAddToken(address token, uint balance, uint denormalizedWeight) external virtual;\n', '    function applyAddToken() external virtual;\n', '    function removeToken(address token) external virtual;\n', '    function whitelistLiquidityProvider(address provider) external virtual;\n', '    function removeWhitelistedLiquidityProvider(address provider) external virtual;\n', '    function bPool() external view virtual returns (BPool);\n', '}\n', '\n', 'abstract contract CRPFactory {\n', '    function newCrp(\n', '        address factoryAddress,\n', '        ConfigurableRightsPool.PoolParams calldata params,\n', '        RightsManager.Rights calldata rights\n', '    ) external virtual returns (ConfigurableRightsPool);\n', '}\n', '\n', '/********************************** WARNING **********************************/\n', '//                                                                           //\n', '// This contract is only meant to be used in conjunction with ds-proxy.      //\n', '// Calling this contract directly will lead to loss of funds.                //\n', '//                                                                           //\n', '/********************************** WARNING **********************************/\n', '\n', 'contract BActions {\n', '\n', '    // --- Pool Creation ---\n', '\n', '    function create(\n', '        BFactory factory,\n', '        address[] calldata tokens,\n', '        uint[] calldata balances,\n', '        uint[] calldata weights,\n', '        uint swapFee,\n', '        bool finalize\n', '    ) external returns (BPool pool) {\n', '        require(tokens.length == balances.length, "ERR_LENGTH_MISMATCH");\n', '        require(tokens.length == weights.length, "ERR_LENGTH_MISMATCH");\n', '\n', '        pool = factory.newBPool();\n', '        pool.setSwapFee(swapFee);\n', '\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            ERC20 token = ERC20(tokens[i]);\n', '            require(token.transferFrom(msg.sender, address(this), balances[i]), "ERR_TRANSFER_FAILED");\n', '            _safeApprove(token, address(pool), balances[i]);\n', '            pool.bind(tokens[i], balances[i], weights[i]);\n', '        }\n', '\n', '        if (finalize) {\n', '            pool.finalize();\n', '            require(pool.transfer(msg.sender, pool.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '        } else {\n', '            pool.setPublicSwap(true);\n', '        }\n', '    }\n', '    \n', '    function createSmartPool(\n', '        CRPFactory factory,\n', '        BFactory bFactory,\n', '        ConfigurableRightsPool.PoolParams calldata poolParams,\n', '        ConfigurableRightsPool.CrpParams calldata crpParams,\n', '        RightsManager.Rights calldata rights\n', '    ) external returns (ConfigurableRightsPool crp) {\n', '        require(\n', '            poolParams.constituentTokens.length == poolParams.tokenBalances.length,\n', '            "ERR_LENGTH_MISMATCH"\n', '        );\n', '        require(\n', '            poolParams.constituentTokens.length == poolParams.tokenWeights.length,\n', '            "ERR_LENGTH_MISMATCH"\n', '        );\n', '\n', '        crp = factory.newCrp(\n', '            address(bFactory),\n', '            poolParams,\n', '            rights\n', '        );\n', '        \n', '        for (uint i = 0; i < poolParams.constituentTokens.length; i++) {\n', '            ERC20 token = ERC20(poolParams.constituentTokens[i]);\n', '            require(\n', '                token.transferFrom(msg.sender, address(this), poolParams.tokenBalances[i]),\n', '                "ERR_TRANSFER_FAILED"\n', '            );\n', '            _safeApprove(token, address(crp), poolParams.tokenBalances[i]);\n', '        }\n', '        \n', '        crp.createPool(\n', '            crpParams.initialSupply,\n', '            crpParams.minimumWeightChangeBlockPeriod,\n', '            crpParams.addTokenTimeLockInBlocks\n', '        );\n', '        require(crp.transfer(msg.sender, crpParams.initialSupply), "ERR_TRANSFER_FAILED");\n', '        // DSProxy instance keeps pool ownership to enable management\n', '    }\n', '    \n', '    // --- Joins ---\n', '    \n', '    function joinPool(\n', '        BPool pool,\n', '        uint poolAmountOut,\n', '        uint[] calldata maxAmountsIn\n', '    ) external {\n', '        address[] memory tokens = pool.getFinalTokens();\n', '        _join(pool, tokens, poolAmountOut, maxAmountsIn);\n', '    }\n', '    \n', '    function joinSmartPool(\n', '        ConfigurableRightsPool pool,\n', '        uint poolAmountOut,\n', '        uint[] calldata maxAmountsIn\n', '    ) external {\n', '        address[] memory tokens = pool.bPool().getCurrentTokens();\n', '        _join(pool, tokens, poolAmountOut, maxAmountsIn);\n', '    }\n', '\n', '    function joinswapExternAmountIn(\n', '        AbstractPool pool,\n', '        ERC20 token,\n', '        uint tokenAmountIn,\n', '        uint minPoolAmountOut\n', '    ) external {\n', '        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), "ERR_TRANSFER_FAILED");\n', '        _safeApprove(token, address(pool), tokenAmountIn);\n', '        uint poolAmountOut = pool.joinswapExternAmountIn(address(token), tokenAmountIn, minPoolAmountOut);\n', '        require(pool.transfer(msg.sender, poolAmountOut), "ERR_TRANSFER_FAILED");\n', '    }\n', '    \n', '    // --- Pool management (common) ---\n', '    \n', '    function setPublicSwap(AbstractPool pool, bool publicSwap) external {\n', '        pool.setPublicSwap(publicSwap);\n', '    }\n', '\n', '    function setSwapFee(AbstractPool pool, uint newFee) external {\n', '        pool.setSwapFee(newFee);\n', '    }\n', '\n', '    function setController(AbstractPool pool, address newController) external {\n', '        pool.setController(newController);\n', '    }\n', '    \n', '    // --- Private pool management ---\n', '\n', '    function setTokens(\n', '        BPool pool,\n', '        address[] calldata tokens,\n', '        uint[] calldata balances,\n', '        uint[] calldata denorms\n', '    ) external {\n', '        require(tokens.length == balances.length, "ERR_LENGTH_MISMATCH");\n', '        require(tokens.length == denorms.length, "ERR_LENGTH_MISMATCH");\n', '\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            ERC20 token = ERC20(tokens[i]);\n', '            if (pool.isBound(tokens[i])) {\n', '                if (balances[i] > pool.getBalance(tokens[i])) {\n', '                    require(\n', '                        token.transferFrom(msg.sender, address(this), balances[i] - pool.getBalance(tokens[i])),\n', '                        "ERR_TRANSFER_FAILED"\n', '                    );\n', '                    _safeApprove(token, address(pool), balances[i] - pool.getBalance(tokens[i]));\n', '                }\n', '                if (balances[i] > 10**6) {\n', '                    pool.rebind(tokens[i], balances[i], denorms[i]);\n', '                } else {\n', '                    pool.unbind(tokens[i]);\n', '                }\n', '\n', '            } else {\n', '                require(token.transferFrom(msg.sender, address(this), balances[i]), "ERR_TRANSFER_FAILED");\n', '                _safeApprove(token, address(pool), balances[i]);\n', '                pool.bind(tokens[i], balances[i], denorms[i]);\n', '            }\n', '\n', '            if (token.balanceOf(address(this)) > 0) {\n', '                require(token.transfer(msg.sender, token.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '            }\n', '\n', '        }\n', '    }\n', '\n', '    function finalize(BPool pool) external {\n', '        pool.finalize();\n', '        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '    }\n', '    \n', '    // --- Smart pool management ---\n', '    \n', '    function increaseWeight(\n', '        ConfigurableRightsPool crp,\n', '        ERC20 token,\n', '        uint newWeight,\n', '        uint tokenAmountIn\n', '    ) external {\n', '        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), "ERR_TRANSFER_FAILED");\n', '        _safeApprove(token, address(crp), tokenAmountIn);\n', '        crp.updateWeight(address(token), newWeight);\n', '        require(crp.transfer(msg.sender, crp.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '    }\n', '    \n', '    function decreaseWeight(\n', '        ConfigurableRightsPool crp,\n', '        ERC20 token,\n', '        uint newWeight,\n', '        uint poolAmountIn\n', '    ) external {\n', '        require(crp.transferFrom(msg.sender, address(this), poolAmountIn), "ERR_TRANSFER_FAILED");\n', '        crp.updateWeight(address(token), newWeight);\n', '        require(token.transfer(msg.sender, token.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '    }\n', '    \n', '    function updateWeightsGradually(\n', '        ConfigurableRightsPool crp,\n', '        uint[] calldata newWeights,\n', '        uint startBlock,\n', '        uint endBlock\n', '    ) external {\n', '        crp.updateWeightsGradually(newWeights, startBlock, endBlock);\n', '    }\n', '\n', '    function setCap(\n', '        ConfigurableRightsPool crp,\n', '        uint newCap\n', '    ) external {\n', '        crp.setCap(newCap);\n', '    }\n', '\n', '    function commitAddToken(\n', '        ConfigurableRightsPool crp,\n', '        ERC20 token,\n', '        uint balance,\n', '        uint denormalizedWeight\n', '    ) external {\n', '        crp.commitAddToken(address(token), balance, denormalizedWeight);\n', '    }\n', '\n', '    function applyAddToken(\n', '        ConfigurableRightsPool crp,\n', '        ERC20 token,\n', '        uint tokenAmountIn\n', '    ) external {\n', '        require(token.transferFrom(msg.sender, address(this), tokenAmountIn), "ERR_TRANSFER_FAILED");\n', '        _safeApprove(token, address(crp), tokenAmountIn);\n', '        crp.applyAddToken();\n', '        require(crp.transfer(msg.sender, crp.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '    }\n', '\n', '    function removeToken(\n', '        ConfigurableRightsPool crp,\n', '        ERC20 token,\n', '        uint poolAmountIn\n', '    ) external {\n', '        require(crp.transferFrom(msg.sender, address(this), poolAmountIn), "ERR_TRANSFER_FAILED");\n', '        crp.removeToken(address(token));\n', '        require(token.transfer(msg.sender, token.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '    }\n', '\n', '    function whitelistLiquidityProvider(\n', '        ConfigurableRightsPool crp,\n', '        address provider\n', '    ) external {\n', '        crp.whitelistLiquidityProvider(provider);\n', '    }\n', '\n', '    function removeWhitelistedLiquidityProvider(\n', '        ConfigurableRightsPool crp,\n', '        address provider\n', '    ) external {\n', '        crp.removeWhitelistedLiquidityProvider(provider);\n', '    }\n', '\n', '    // --- Migration ---\n', '\n', '    function migrateProportionally(\n', '        Vault vault,\n', '        BPool poolIn,\n', '        uint poolInAmount,\n', '        uint[] calldata  tokenOutAmountsMin,\n', '        BalancerPool poolOut,\n', '        uint poolOutAmountMin\n', '    ) external {\n', '        address[] memory tokens = poolIn.getFinalTokens();\n', '        (address[] memory outTokens, uint[] memory tokenInAmounts,) =\n', '            vault.getPoolTokens(poolOut.getPoolId());\n', '        require(tokens.length == 2);\n', '        require(outTokens.length == 2);\n', '        require((tokens[0] == outTokens[0]) || (tokens[0] == outTokens[1]));\n', '        require((tokens[1] == outTokens[0]) || (tokens[1] == outTokens[1]));\n', '        // Transfer v1 BPTs to proxy\n', '        poolIn.transferFrom(msg.sender, address(this), poolInAmount);\n', '        // Exit v1 pool\n', '        poolIn.exitPool(poolInAmount,  tokenOutAmountsMin);\n', '        // Approve each token to v2 vault\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            _safeApprove(ERC20(tokens[i]), address(vault), uint(-1));\n', '        }\n', '        // Calculate amounts for even join\n', '        // 1) find the lowest UserBalance-to-PoolBalance ratio\n', '        // 2) multiply by this ratio to get in amounts\n', '        uint lowestRatio = uint(-1);\n', '        uint lowestRatioToken = 0;\n', '        for (uint i = 0; i < outTokens.length; ++i) {\n', '            uint ratio = 1 ether * ERC20(outTokens[i]).balanceOf(address(this)) / tokenInAmounts[i];\n', '            if (ratio < lowestRatio) {\n', '                lowestRatio = ratio;\n', '                lowestRatioToken = i;\n', '            }\n', '        }\n', '        for (uint i = 0; i < outTokens.length; ++i) {\n', '            // Keep original amount for "bottleneck" token to avoid dust\n', '            if (lowestRatioToken == i) {\n', '                tokenInAmounts[i] = ERC20(outTokens[i]).balanceOf(address(this));\n', '            } else {\n', '                tokenInAmounts[i] = tokenInAmounts[i] * lowestRatio / 1 ether;\n', '            }\n', '        }\n', '        // Join v2 pool and transfer v2 BPTs to user\n', '        bytes memory userData = abi.encode(\n', '            BalancerPool.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n', '            tokenInAmounts,\n', '            poolOutAmountMin\n', '        );\n', '        Vault.JoinPoolRequest memory request = Vault.JoinPoolRequest(outTokens, tokenInAmounts, userData, false);\n', '        vault.joinPool(\n', '            poolOut.getPoolId(),\n', '            address(this),\n', '            msg.sender,\n', '            request\n', '        );\n', '        // Send "change" back\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            ERC20 token = ERC20(tokens[i]);\n', '            if (token.balanceOf(address(this)) > 0) {\n', '                require(token.transfer(msg.sender, token.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '            }\n', '        }\n', '    }\n', '\n', '    function migrateAll(\n', '        Vault vault,\n', '        BPool poolIn,\n', '        uint poolInAmount,\n', '        uint[] calldata tokenOutAmountsMin,\n', '        BalancerPool poolOut,\n', '        uint poolOutAmountMin\n', '    ) external {\n', '        address[] memory tokens = poolIn.getFinalTokens();\n', '        (address[] memory outTokens,,) = vault.getPoolTokens(poolOut.getPoolId());\n', '        require(tokens.length == 2);\n', '        require(outTokens.length == 2);\n', '        require((tokens[0] == outTokens[0]) || (tokens[0] == outTokens[1]));\n', '        require((tokens[1] == outTokens[0]) || (tokens[1] == outTokens[1]));\n', '        // Transfer v1 BPTs to proxy\n', '        poolIn.transferFrom(msg.sender, address(this), poolInAmount);\n', '        // Exit v1 pool\n', '        poolIn.exitPool(poolInAmount, tokenOutAmountsMin);\n', '        // Approve each token to v2 vault\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            _safeApprove(ERC20(tokens[i]), address(vault), uint(-1));\n', '        }\n', '        // Join v2 pool and transfer v2 BPTs to user\n', '        uint[] memory tokenInAmounts = new uint[](outTokens.length);\n', '        for (uint i = 0; i < outTokens.length; ++i) {\n', '            tokenInAmounts[i] = ERC20(outTokens[i]).balanceOf(address(this));\n', '        }\n', '\n', '        bytes memory userData = abi.encode(\n', '            BalancerPool.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT,\n', '            tokenInAmounts,\n', '            poolOutAmountMin\n', '        );\n', '        Vault.JoinPoolRequest memory request = Vault.JoinPoolRequest(outTokens, tokenInAmounts, userData, false);\n', '        vault.joinPool(\n', '            poolOut.getPoolId(),\n', '            address(this),\n', '            msg.sender,\n', '            request\n', '        );\n', '    }\n', '    \n', '    // --- Internals ---\n', '\n', '    function _safeApprove(ERC20 token, address spender, uint amount) internal {\n', '        if (token.allowance(address(this), spender) > 0) {\n', '            token.approve(spender, 0);\n', '        }\n', '        token.approve(spender, amount);\n', '    }\n', '\n', '    function _join(\n', '        AbstractPool pool,\n', '        address[] memory tokens,\n', '        uint poolAmountOut,\n', '        uint[] memory maxAmountsIn\n', '    ) internal {\n', '        require(maxAmountsIn.length == tokens.length, "ERR_LENGTH_MISMATCH");\n', '\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            ERC20 token = ERC20(tokens[i]);\n', '            require(token.transferFrom(msg.sender, address(this), maxAmountsIn[i]), "ERR_TRANSFER_FAILED");\n', '            _safeApprove(token, address(pool), maxAmountsIn[i]);\n', '        }\n', '        pool.joinPool(poolAmountOut, maxAmountsIn);\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            ERC20 token = ERC20(tokens[i]);\n', '            if (token.balanceOf(address(this)) > 0) {\n', '                require(token.transfer(msg.sender, token.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '            }\n', '        }\n', '        require(pool.transfer(msg.sender, pool.balanceOf(address(this))), "ERR_TRANSFER_FAILED");\n', '    }\n', '}']