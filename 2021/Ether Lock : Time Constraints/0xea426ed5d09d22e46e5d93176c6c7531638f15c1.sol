['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-17\n', '*/\n', '\n', 'pragma solidity ^0.6.10;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface TokenInterface {\n', '    function balanceOf(address) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function decimals() external view returns (uint);\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '\n', '}\n', '\n', 'contract Resolver {\n', '    struct TokenData {\n', '        bool isToken;\n', '        string name;\n', '        string symbol;\n', '        uint256 decimals;\n', '    }\n', '\n', '    function getTokenDetails(address[] memory tknAddress) public view returns (TokenData[] memory) {\n', '        TokenData[] memory tokenDatas = new TokenData[](tknAddress.length);\n', '        for (uint i = 0; i < tknAddress.length; i++) {\n', '            if (tknAddress[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n', '                tokenDatas[i] = TokenData(\n', '                    true,\n', '                    "ETHER",\n', '                    "ETH",\n', '                    18\n', '                );\n', '            } else {\n', '                TokenInterface token = TokenInterface(tknAddress[i]);\n', '                bool isToken = true;\n', '                \n', '                try token.symbol() {\n', '                } catch {\n', '                    isToken = false;\n', '                    continue;\n', '                }\n', '                \n', '                try token.name() {\n', '                } catch {\n', '                    isToken = false;\n', '                    continue;\n', '                }\n', '                \n', '                try token.decimals() {\n', '                } catch {\n', '                    isToken = false;\n', '                    continue;\n', '                }\n', '                \n', '                tokenDatas[i] = TokenData(\n', '                        true,\n', '                        token.name(),\n', '                        token.symbol(),\n', '                        token.decimals()\n', '                );\n', '            }\n', '        }\n', '        return tokenDatas;\n', '    }\n', '\n', '    function getBalances(address owner, address[] memory tknAddress) public view returns (uint[] memory) {\n', '        uint[] memory tokensBal = new uint[](tknAddress.length);\n', '        for (uint i = 0; i < tknAddress.length; i++) {\n', '            if (tknAddress[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n', '                tokensBal[i] = owner.balance;\n', '            } else {\n', '                TokenInterface token = TokenInterface(tknAddress[i]);\n', '                tokensBal[i] = token.balanceOf(owner);\n', '            }\n', '        }\n', '        return tokensBal;\n', '    }\n', '\n', '    function getAllowances(address owner, address spender, address[] memory tknAddress) public view returns (uint[] memory) {\n', '        uint[] memory tokenAllowances = new uint[](tknAddress.length);\n', '        for (uint i = 0; i < tknAddress.length; i++) {\n', '            if (tknAddress[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n', '                tokenAllowances[i] = 0;\n', '            } else {\n', '                TokenInterface token = TokenInterface(tknAddress[i]);\n', '                tokenAllowances[i] = token.allowance(owner, spender);\n', '            }\n', '        }\n', '        return tokenAllowances;\n', '    }\n', '\n', '}\n', '\n', '\n', 'contract InstaERC20Resolver is Resolver {\n', '\n', '    string public constant name = "ERC20-Resolver-v1.1";\n', '\n', '}']