['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-17\n', '*/\n', '\n', '// File: @openzeppelin/contracts/token/ERC777/IERC777.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC777Token standard as defined in the EIP.\n', ' *\n', ' * This contract uses the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\n', ' * token holders and recipients react to token movements by using setting implementers\n', ' * for the associated interfaces in said registry. See {IERC1820Registry} and\n', ' * {ERC1820Implementer}.\n', ' */\n', 'interface IERC777 {\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the smallest part of the token that is not divisible. This\n', '     * means all token operations (creation, movement and destruction) must have\n', '     * amounts that are a multiple of this number.\n', '     *\n', '     * For most token contracts, this value will equal 1.\n', '     */\n', '    function granularity() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by an account (`owner`).\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * If send or receive hooks are registered for the caller and `recipient`,\n', '     * the corresponding functions will be called with `data` and empty\n', '     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n', '     *\n', '     * Emits a {Sent} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - the caller must have at least `amount` tokens.\n', '     * - `recipient` cannot be the zero address.\n', '     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n', '     * interface.\n', '     */\n', '    function send(address recipient, uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', "     * @dev Destroys `amount` tokens from the caller's account, reducing the\n", '     * total supply.\n', '     *\n', '     * If a send hook is registered for the caller, the corresponding function\n', '     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\n', '     *\n', '     * Emits a {Burned} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - the caller must have at least `amount` tokens.\n', '     */\n', '    function burn(uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', '     * @dev Returns true if an account is an operator of `tokenHolder`.\n', '     * Operators can send and burn tokens on behalf of their owners. All\n', '     * accounts are their own operator.\n', '     *\n', '     * See {operatorSend} and {operatorBurn}.\n', '     */\n', '    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Make an account an operator of the caller.\n', '     *\n', '     * See {isOperatorFor}.\n', '     *\n', '     * Emits an {AuthorizedOperator} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `operator` cannot be calling address.\n', '     */\n', '    function authorizeOperator(address operator) external;\n', '\n', '    /**\n', "     * @dev Revoke an account's operator status for the caller.\n", '     *\n', '     * See {isOperatorFor} and {defaultOperators}.\n', '     *\n', '     * Emits a {RevokedOperator} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `operator` cannot be calling address.\n', '     */\n', '    function revokeOperator(address operator) external;\n', '\n', '    /**\n', '     * @dev Returns the list of default operators. These accounts are operators\n', '     * for all token holders, even if {authorizeOperator} was never called on\n', '     * them.\n', '     *\n', '     * This list is immutable, but individual holders may revoke these via\n', '     * {revokeOperator}, in which case {isOperatorFor} will return false.\n', '     */\n', '    function defaultOperators() external view returns (address[] memory);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\n', '     * be an operator of `sender`.\n', '     *\n', '     * If send or receive hooks are registered for `sender` and `recipient`,\n', '     * the corresponding functions will be called with `data` and\n', '     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\n', '     *\n', '     * Emits a {Sent} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `sender` must have at least `amount` tokens.\n', '     * - the caller must be an operator for `sender`.\n', '     * - `recipient` cannot be the zero address.\n', '     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\n', '     * interface.\n', '     */\n', '    function operatorSend(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount,\n', '        bytes calldata data,\n', '        bytes calldata operatorData\n', '    ) external;\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\n', '     * The caller must be an operator of `account`.\n', '     *\n', '     * If a send hook is registered for `account`, the corresponding function\n', '     * will be called with `data` and `operatorData`. See {IERC777Sender}.\n', '     *\n', '     * Emits a {Burned} event.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     * - the caller must be an operator for `account`.\n', '     */\n', '    function operatorBurn(\n', '        address account,\n', '        uint256 amount,\n', '        bytes calldata data,\n', '        bytes calldata operatorData\n', '    ) external;\n', '\n', '    event Sent(\n', '        address indexed operator,\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 amount,\n', '        bytes data,\n', '        bytes operatorData\n', '    );\n', '\n', '    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\n', '\n', '    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\n', '\n', '    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n', '\n', '    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n', ' *\n', ' * Accounts can be notified of {IERC777} tokens being sent to them by having a\n', ' * contract implement this interface (contract holders can be their own\n', ' * implementer) and registering it on the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n', ' *\n', ' * See {IERC1820Registry} and {ERC1820Implementer}.\n', ' */\n', 'interface IERC777Recipient {\n', '    /**\n', '     * @dev Called by an {IERC777} token contract whenever tokens are being\n', '     * moved or created into a registered account (`to`). The type of operation\n', '     * is conveyed by `from` being the zero address or not.\n', '     *\n', "     * This call occurs _after_ the token contract's state is updated, so\n", '     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n', '     *\n', '     * This function may revert to prevent the operation from being executed.\n', '     */\n', '    function tokensReceived(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        bytes calldata userData,\n', '        bytes calldata operatorData\n', '    ) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/introspection/IERC1820Registry.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the global ERC1820 Registry, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n', ' * implementers for interfaces in this registry, as well as query support.\n', ' *\n', ' * Implementers may be shared by multiple accounts, and can also implement more\n', ' * than a single interface for each account. Contracts can implement interfaces\n', ' * for themselves, but externally-owned accounts (EOA) must delegate this to a\n', ' * contract.\n', ' *\n', ' * {IERC165} interfaces can also be queried via the registry.\n', ' *\n', ' * For an in-depth explanation and source code analysis, see the EIP text.\n', ' */\n', 'interface IERC1820Registry {\n', '    /**\n', '     * @dev Sets `newManager` as the manager for `account`. A manager of an\n', '     * account is able to set interface implementers for it.\n', '     *\n', '     * By default, each account is its own manager. Passing a value of `0x0` in\n', '     * `newManager` will reset the manager to this initial state.\n', '     *\n', '     * Emits a {ManagerChanged} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     */\n', '    function setManager(address account, address newManager) external;\n', '\n', '    /**\n', '     * @dev Returns the manager for `account`.\n', '     *\n', '     * See {setManager}.\n', '     */\n', '    function getManager(address account) external view returns (address);\n', '\n', '    /**\n', "     * @dev Sets the `implementer` contract as ``account``'s implementer for\n", '     * `interfaceHash`.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     * The zero address can also be used in `implementer` to remove an old one.\n', '     *\n', '     * See {interfaceHash} to learn how these are created.\n', '     *\n', '     * Emits an {InterfaceImplementerSet} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n', '     * end in 28 zeroes).\n', '     * - `implementer` must implement {IERC1820Implementer} and return true when\n', '     * queried for support, unless `implementer` is the caller. See\n', '     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n', '     */\n', '    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n', '\n', '    /**\n', '     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n', '     * implementer is registered, returns the zero address.\n', '     *\n', '     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n', '     * zeroes), `account` will be queried for support of it.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     */\n', '    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n', '     * corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n', '     */\n', '    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n', '\n', '    /**\n', '     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n', '     *  @param account Address of the contract for which to update the cache.\n', '     *  @param interfaceId ERC165 interface for which to update the cache.\n', '     */\n', '    function updateERC165Cache(address account, bytes4 interfaceId) external;\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not.\n', '     *  If the result is not cached a direct lookup on the contract address is performed.\n', '     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n', '     *  {updateERC165Cache} with the contract address.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n', '\n', '    event ManagerChanged(address indexed account, address indexed newManager);\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: crosslend/data.sol\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', 'enum FinancialType{CRFI, CFil}\n', '\n', 'struct FinancialPackage {\n', '  FinancialType Type;\n', '  \n', '  uint256 Days;\n', '  uint256 CFilInterestRate;\n', '  uint256 CRFIInterestRateDyn;\n', '  uint256 ID;\n', '\n', '  uint256 Weight;\n', '  uint256 ParamCRFI;\n', '  uint256 ParamCFil;\n', '  uint256 Total;\n', '}\n', '\n', 'struct LoanCFilPackage {\n', '  uint256 APY;\n', '  uint256 PledgeRate;\n', '  uint256 PaymentDue;\n', '  uint256 PaymentDue99;\n', '\n', '  uint256 UpdateTime;\n', '  uint256 Param;\n', '}\n', '\n', 'struct ViewSystemInfo{\n', '  FinancialPackage[] Packages;\n', '  uint256 AffRate;\n', '  uint256 AffRequire;\n', '  uint256 EnableAffCFil;\n', '  \n', '  LoanCFilPackage LoanCFil;\n', '\n', '  ChainManager ChainM;\n', '\n', '  // invest\n', '  uint256 NewInvestID;\n', '  mapping(uint256 => InvestInfo) Invests;\n', '  mapping(address => uint256) InvestAddrID;\n', '        \n', '  // setting power\n', '  address SuperAdmin;\n', '  mapping(address => bool) Admins;\n', '\n', '  // statistic\n', '  uint256 nowInvestCRFI;\n', '  uint256 nowInvestCFil; \n', '  uint256 cfilInterestPool;\n', '  uint256 crfiInterestPool;\n', '\n', '  uint256 cfilLendingTotal;\n', '  uint256 crfiRewardTotal;\n', '  uint256 avaiCFilAmount;\n', '  \n', '  uint256 totalWeightCFil;\n', '  uint256 totalWeightCRFI;\n', '  uint256 crfiMinerPerDayCFil;\n', '  uint256 crfiMinerPerDayCRFI;\n', '  \n', '  uint256 ParamUpdateTime;\n', '}\n', '\n', 'struct SystemInfoView {\n', '  uint256 AffRate;\n', '  uint256 AffRequire;\n', '  uint256 EnableAffCFil;\n', '  \n', '  // invest\n', '  uint256 NewInvestID;\n', '\n', '  // statistic\n', '  uint256 nowInvestCRFI;\n', '  uint256 nowInvestCFil; \n', '  uint256 cfilInterestPool;\n', '  uint256 crfiInterestPool;\n', '\n', '  uint256 cfilLendingTotal;\n', '  uint256 crfiRewardTotal;\n', '  uint256 avaiCFilAmount;\n', '  \n', '  uint256 totalWeightCFil;\n', '  uint256 totalWeightCRFI;\n', '  uint256 crfiMinerPerDayCFil;\n', '  uint256 crfiMinerPerDayCRFI;\n', '  \n', '  uint256 ParamUpdateTime;\n', '}\n', '\n', 'struct SystemInfo {\n', '\n', '  FinancialPackage[] Packages;\n', '  uint256 AffRate;\n', '  uint256 AffRequire;\n', '  uint256 EnableAffCFil;\n', '  \n', '  LoanCFilPackage LoanCFil;\n', '\n', '  ChainManager ChainM;\n', '\n', '  // invest\n', '  uint256 NewInvestID;\n', '  mapping(uint256 => InvestInfo) Invests;\n', '  mapping(address => uint256) InvestAddrID;\n', '        \n', '  // setting power\n', '  address SuperAdmin;\n', '  mapping(address => bool) Admins;\n', '\n', '  // statistic\n', '  uint256 nowInvestCRFI;\n', '  uint256 nowInvestCFil; \n', '  uint256 cfilInterestPool;\n', '  uint256 crfiInterestPool;\n', '\n', '  uint256 cfilLendingTotal;\n', '  uint256 crfiRewardTotal;\n', '  uint256 avaiCFilAmount;\n', '  \n', '  uint256 totalWeightCFil;\n', '  uint256 totalWeightCRFI;\n', '  uint256 crfiMinerPerDayCFil;\n', '  uint256 crfiMinerPerDayCRFI;\n', '  \n', '  uint256 ParamUpdateTime;\n', '\n', '  mapping(string => string) kvMap;\n', '}\n', '\n', 'struct InterestDetail{\n', '  uint256 crfiInterest;\n', '  uint256 cfilInterest;\n', '}\n', '\n', 'struct LoanInvest{\n', '  uint256 Lending;\n', '  uint256 Pledge;\n', '  uint256 Param;\n', '  uint256 NowInterest;\n', '}\n', '\n', 'struct InvestInfoView {\n', '  address Addr;\n', '  uint256 ID;\n', '\n', '  uint256 affID;\n', '\n', '  // statistic for financial\n', '  uint256 totalAffTimes;\n', '  uint256 totalAffPackageTimes;\n', '  \n', '  uint256 totalAffCRFI;\n', '  uint256 totalAffCFil;\n', '  \n', '  uint256 nowInvestFinCRFI;\n', '  uint256 nowInvestFinCFil;\n', '}\n', '\n', 'struct InvestInfo {\n', '  mapping(uint256 => ChainQueue) InvestRecords;\n', '\n', '  address Addr;\n', '  uint256 ID;\n', '\n', '  uint256 affID;\n', '\n', '  LoanInvest LoanCFil;\n', '\n', '  // statistic for financial\n', '  uint256 totalAffTimes;\n', '  uint256 totalAffPackageTimes;\n', '  \n', '  uint256 totalAffCRFI;\n', '  uint256 totalAffCFil;\n', '  \n', '  uint256 nowInvestFinCRFI;\n', '  uint256 nowInvestFinCFil;\n', '}\n', '\n', '\n', '//////////////////// queue\n', '\n', 'struct QueueData {\n', '  uint256 RecordID;\n', '  \n', '  FinancialType Type;\n', '  uint256 PackageID;\n', '  uint256 Days;\n', '  uint256 EndTime;\n', '  uint256 AffID;\n', '  uint256 Amount;\n', '\n', '  uint256 ParamCRFI;\n', '  uint256 ParamCFil;\n', '}\n', '\n', 'struct ChainItem {\n', '  uint256 Next;\n', '  uint256 Prev;\n', '  uint256 My;\n', '  \n', '  QueueData Data;\n', '}\n', '\n', 'struct ChainQueue{\n', '  uint256 First;\n', '  uint256 End;\n', '\n', '  uint256 Size;\n', '}\n', '\n', '\n', 'struct ChainManager{\n', '  ChainItem[] rawQueue;\n', '\n', '  ChainQueue avaiQueue;\n', '}\n', '\n', 'library ChainQueueLib{\n', '\n', '  //////////////////// item\n', '  function GetNullItem(ChainManager storage chainM)\n', '    internal\n', '    view\n', '    returns(ChainItem storage item){\n', '    return chainM.rawQueue[0];\n', '  }\n', '\n', '  function HasNext(ChainManager storage chainM,\n', '                   ChainItem storage item)\n', '    internal\n', '    view\n', '    returns(bool has){\n', '\n', '    if(item.Next == 0){\n', '      return false;\n', '    }\n', '\n', '    return true;\n', '  }\n', '\n', '  function Next(ChainManager storage chainM,\n', '                ChainItem storage item)\n', '    internal\n', '    view\n', '    returns(ChainItem storage nextItem){\n', '\n', '    uint256 nextIdx = item.Next;\n', '    require(nextIdx > 0, "no next item");\n', '\n', '    return chainM.rawQueue[uint256(nextIdx)];\n', '  }\n', '\n', '  //////////////////// chain\n', '  function GetFirstItem(ChainManager storage chainM,\n', '                        ChainQueue storage chain)\n', '    internal\n', '    view\n', '    returns(ChainItem storage item){\n', '\n', '    require(chain.Size > 0, "chain is empty");\n', '\n', '    return chainM.rawQueue[chain.First];\n', '  }\n', '\n', '  function GetEndItem(ChainManager storage chainM,\n', '                      ChainQueue storage chain)\n', '    internal\n', '    view\n', '    returns(ChainItem storage item){\n', '\n', '    require(chain.Size > 0, "chain is empty");\n', '\n', '    return chainM.rawQueue[chain.End];\n', '  }\n', '\n', '  // need ensure the item is in chain\n', '  function DeleteItem(ChainManager storage chainM,\n', '                      ChainQueue storage chain,\n', '                      ChainItem storage item)\n', '    internal{\n', '\n', '    if(chain.First == item.My){\n', '      PopPutFirst(chainM, chain);\n', '      return;\n', '    } else if (chain.End == item.My){\n', '      PopPutEnd(chainM, chain);\n', '      return;\n', '    }\n', '\n', '    ChainItem storage next = chainM.rawQueue[item.Next];\n', '    ChainItem storage prev = chainM.rawQueue[item.Prev];\n', '\n', '    next.Prev = item.Prev;\n', '    prev.Next = item.Next;\n', '\n', '    item.Prev = 0;\n', '    item.Next = 0;\n', '\n', '    chain.Size--;\n', '\n', '    PutItem(chainM, item);\n', '  }\n', '\n', '  function PopPutFirst(ChainManager storage chainM,\n', '                       ChainQueue storage chain)\n', '    internal{\n', '\n', '    ChainItem storage item = PopFirstItem(chainM, chain);\n', '    PutItem(chainM, item);\n', '  }\n', '\n', '  function PopPutEnd(ChainManager storage chainM,\n', '                     ChainQueue storage chain)\n', '    internal{\n', '\n', '    ChainItem storage item = PopEndItem(chainM, chain);\n', '    PutItem(chainM, item);\n', '  }\n', '\n', '  function PopEndItem(ChainManager storage chainM,\n', '                        ChainQueue storage chain)\n', '    internal\n', '    returns(ChainItem storage item){\n', '    \n', '    require(chain.Size >0, "chain is empty");\n', '    \n', '    uint256 itemIdx = chain.End;\n', '    chain.End = chainM.rawQueue[itemIdx].Prev;\n', '    if(chain.End > 0){\n', '      chainM.rawQueue[chain.End].Next = 0;\n', '    } else {\n', '      chain.First = 0;\n', '    }\n', '    chain.Size--;\n', '    item = chainM.rawQueue[itemIdx];\n', '    item.Prev = 0;\n', '    return item;\n', '  }\n', '\n', '  function PopFirstItem(ChainManager storage chainM,\n', '                        ChainQueue storage chain)\n', '    internal\n', '    returns(ChainItem storage item){\n', '\n', '    require(chain.Size > 0, "chain is empty");\n', '\n', '    uint256 itemIdx = chain.First;\n', '    chain.First = chainM.rawQueue[itemIdx].Next;\n', '    if(chain.First > 0){\n', '      chainM.rawQueue[chain.First].Prev = 0;\n', '    } else {\n', '      chain.End = 0;\n', '    }\n', '    chain.Size--;\n', '\n', '    item = chainM.rawQueue[itemIdx];\n', '    item.Next = 0;\n', '\n', '    return item;\n', '  }\n', '\n', '  function PushEndItem(ChainManager storage chainM,\n', '                       ChainQueue storage chain,\n', '                       ChainItem storage item)\n', '    internal{\n', '\n', '    item.Prev = chain.End;\n', '    item.Next = 0;\n', '\n', '    if(chain.Size == 0){\n', '      chain.First = item.My;\n', '      chain.End = item.My;\n', '    } else {\n', '      chainM.rawQueue[chain.End].Next = item.My;\n', '      chain.End = item.My;\n', '    }\n', '    chain.Size++;\n', '  }\n', '\n', '  //////////////////// chain manager\n', '  function InitChainManager(ChainManager storage chainM)\n', '    internal{\n', '    if(chainM.rawQueue.length == 0){\n', '      chainM.rawQueue.push();\n', '    }\n', '  }\n', '  \n', '  function GetAvaiItem(ChainManager storage chainM)\n', '    internal\n', '    returns(ChainItem storage item){\n', '    \n', '    if(chainM.avaiQueue.Size == 0){\n', '      if(chainM.rawQueue.length == 0){\n', '        chainM.rawQueue.push();\n', '      }\n', '      \n', '      uint256 itemIdx = chainM.rawQueue.length;\n', '      chainM.rawQueue.push();\n', '\n', '      item = chainM.rawQueue[itemIdx];\n', '      item.Next = 0;\n', '      item.Prev = 0;\n', '      item.My = itemIdx;\n', '      \n', '      return item;\n', '    }\n', '\n', '    return PopFirstItem(chainM, chainM.avaiQueue);\n', '  }\n', '\n', '  function PutItem(ChainManager storage chainM,\n', '                   ChainItem storage item)\n', '    internal{\n', '    \n', '    PushEndItem(chainM, chainM.avaiQueue, item);\n', '  }\n', '}\n', '\n', '// File: crosslend/main.sol\n', '\n', 'pragma solidity >=0.7.0 <0.8.0;\n', 'pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract CrossLend is IERC777Recipient, ReentrancyGuard{\n', '  //////////////////// for using\n', '  using ChainQueueLib for ChainManager;\n', '  using SafeMath for uint256;\n', '\n', '  //////////////////// constant\n', '  IERC1820Registry constant internal _ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);\n', '\n', '  bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH = keccak256("ERC777TokensRecipient");\n', '\n', '  uint256 constant Decimal = 1e18;\n', '\n', '  uint256 public OneDayTime;\n', '\n', '  //////////////////// var\n', '  SystemInfo internal SInfo;\n', '  \n', '  IERC777 public CRFI;\n', '  IERC777 public CFil;\n', '  IERC777 public SFil;\n', '\n', '  //////////////////// modifier\n', '  modifier IsAdmin() {\n', '    require(msg.sender == SInfo.SuperAdmin || SInfo.Admins[msg.sender], "only admin");\n', '    _;\n', '  }\n', '\n', '  modifier IsSuperAdmin() {\n', '    require(SInfo.SuperAdmin == msg.sender, "only super admin");\n', '    _;\n', '  }\n', '\n', '  //////////////////// event\n', '  event AffEvent(address indexed receiver, address indexed sender, uint256 indexed affTimes, uint256 crfiInterest, uint256 cfilInterest, uint256 packageID, uint256 timestamp);\n', '\n', '  event AffBought(address indexed affer, address indexed sender, uint256 indexed affPackageTimes, uint256 amount, uint256 packageID, uint256 timestamp);\n', '  \n', '  event loanCFilEvent(address indexed addr, uint256 cfilAmount, uint256 sfilAmount);\n', '\n', '  //////////////////// constructor\n', '  constructor(address crfiAddr, address cfilAddr, address sfilAddr) {\n', '    CRFI = IERC777(crfiAddr);\n', '    CFil = IERC777(cfilAddr);\n', '    SFil = IERC777(sfilAddr);\n', '    OneDayTime = 60 * 60 * 24;\n', '\n', '    SInfo.SuperAdmin = msg.sender;\n', '\n', '    SInfo.AffRate = Decimal / 10;\n', '    SInfo.EnableAffCFil = 1;\n', '\n', '    SInfo.ChainM.InitChainManager();\n', '    \n', '    ////////// add package\n', '\n', '    SInfo.crfiMinerPerDayCFil = 1917808 * Decimal / 100;\n', '    SInfo.crfiMinerPerDayCRFI = 821918 * Decimal / 100;\n', '\n', '    SInfo.ParamUpdateTime = block.timestamp;\n', '    \n', '    // loan CFil\n', '    ChangeLoanRate(201 * Decimal / 1000,\n', '                   56 * Decimal / 100,\n', '                   2300 * Decimal);\n', '    SInfo.LoanCFil.UpdateTime = block.timestamp;\n', '\n', '    // add crfi\n', '    AddPackage(FinancialType.CRFI,\n', '               0,\n', '               (20 * Decimal) / 1000,\n', '               Decimal);\n', '    \n', '    AddPackage(FinancialType.CRFI,\n', '               90,\n', '               (32 * Decimal) / 1000,\n', '               (15 * Decimal) / 10);\n', '\n', '    AddPackage(FinancialType.CRFI,\n', '               180,\n', '               (34 * Decimal) / 1000,\n', '               2 * Decimal);\n', '\n', '    AddPackage(FinancialType.CRFI,\n', '               365,\n', '               (36 * Decimal) / 1000,\n', '               (25 * Decimal) / 10);\n', '                   \n', '    AddPackage(FinancialType.CRFI,\n', '               540,\n', '               (40 * Decimal) / 1000,\n', '               3 * Decimal);\n', '    \n', '    // add cfil\n', '    AddPackage(FinancialType.CFil,\n', '               0,\n', '               (20 * Decimal) / 1000,\n', '               Decimal);\n', '    \n', '    AddPackage(FinancialType.CFil,\n', '               90,\n', '               (33 * Decimal) / 1000,\n', '               (15 * Decimal) / 10);\n', '\n', '    AddPackage(FinancialType.CFil,\n', '               180, \n', '               (35 * Decimal) / 1000,\n', '               2 * Decimal);\n', '\n', '    AddPackage(FinancialType.CFil,\n', '               365,\n', '               (37 * Decimal) / 1000,\n', '               (25 * Decimal) / 10);\n', '                   \n', '    AddPackage(FinancialType.CFil,\n', '               540,\n', '               (41 * Decimal) / 1000,\n', '               3 * Decimal);\n', '    \n', '    // register interfaces\n', '    _ERC1820_REGISTRY.setInterfaceImplementer(address(this), _TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n', '  }\n', '  \n', '  //////////////////// super admin func\n', '  function AddAdmin(address admin)\n', '    public\n', '    IsSuperAdmin(){\n', '    require(!SInfo.Admins[admin], "already add this admin");\n', '    SInfo.Admins[admin] = true;\n', '  }\n', '\n', '  function DelAdmin(address admin)\n', '    public\n', '    IsSuperAdmin(){\n', '    require(SInfo.Admins[admin], "this addr is not admin");\n', '    SInfo.Admins[admin] = false;\n', '  }\n', '\n', '  function ChangeSuperAdmin(address suAdmin)\n', '    public\n', '    IsSuperAdmin(){\n', '    require(suAdmin != address(0x0), "empty new super admin");\n', '\n', '    if(suAdmin == SInfo.SuperAdmin){\n', '      return;\n', '    }\n', '    \n', '    SInfo.SuperAdmin = suAdmin;\n', '  }\n', '\n', '  //////////////////// admin func\n', '  function SetMap(string memory key,\n', '                  string memory value)\n', '    public\n', '    IsAdmin(){\n', '\n', '    SInfo.kvMap[key] = value;\n', '  }\n', '  \n', '  function ChangePackageRate(uint256 packageID,\n', '                             uint256 cfilInterestRate,\n', '                             uint256 weight)\n', '    public\n', '    IsAdmin(){\n', '    \n', '    require(packageID < SInfo.Packages.length, "packageID error");\n', '\n', '    updateAllParam();\n', '    \n', '    FinancialPackage storage package = SInfo.Packages[packageID];\n', '    package.CFilInterestRate = cfilInterestRate;\n', '\n', '    uint256 nowTotal = package.Total.mul(package.Weight) / Decimal;\n', '    if(package.Type == FinancialType.CRFI){\n', '      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.sub(nowTotal);\n', '    } else {\n', '      SInfo.totalWeightCFil = SInfo.totalWeightCFil.sub(nowTotal);\n', '    }\n', '\n', '    package.Weight = weight;\n', '\n', '    nowTotal = package.Total.mul(package.Weight) / Decimal;\n', '    if(package.Type == FinancialType.CRFI){\n', '      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.add(nowTotal);\n', '    } else {\n', '      SInfo.totalWeightCFil = SInfo.totalWeightCFil.add(nowTotal);\n', '    }\n', '  }\n', '\n', '  function AddPackage(FinancialType _type,\n', '                      uint256 dayTimes,\n', '                      uint256 cfilInterestRate,\n', '                      uint256 weight)\n', '    public\n', '    IsAdmin(){\n', '\n', '    updateAllParam();\n', '    \n', '    uint256 idx = SInfo.Packages.length;\n', '    SInfo.Packages.push();\n', '    FinancialPackage storage package = SInfo.Packages[idx];\n', '\n', '    package.Type = _type;\n', '    package.Days = dayTimes;\n', '    package.Weight = weight;\n', '    package.CFilInterestRate = cfilInterestRate;\n', '    package.ID = idx;\n', '  }\n', '\n', '  function ChangeCRFIMinerPerDay(uint256 crfi, uint256 cfil)\n', '    public\n', '    IsAdmin(){\n', '\n', '    updateAllParam();\n', '\n', '    SInfo.crfiMinerPerDayCFil = cfil;\n', '    SInfo.crfiMinerPerDayCRFI = crfi;\n', '  }\n', '\n', '  function ChangeLoanRate(uint256 apy, uint256 pledgeRate, uint256 paymentDue)\n', '    public\n', '    IsAdmin(){\n', '\n', '    require(pledgeRate > 0, "pledge rate can\'t = 0");\n', '\n', '    SInfo.LoanCFil.APY = apy;\n', '    SInfo.LoanCFil.PledgeRate = pledgeRate;\n', '    SInfo.LoanCFil.PaymentDue = paymentDue;\n', '    SInfo.LoanCFil.PaymentDue99 = paymentDue.mul(99) / 100;\n', '  }\n', '\n', '  function ChangeAffCFil(bool enable)\n', '    public\n', '    IsAdmin(){\n', '    if(enable && SInfo.EnableAffCFil == 0){\n', '      SInfo.EnableAffCFil = 1;\n', '    } else if(!enable && SInfo.EnableAffCFil > 0){\n', '      SInfo.EnableAffCFil = 0;\n', '    }\n', '  }\n', '\n', '  function ChangeAffRate(uint256 rate)\n', '    public\n', '    IsAdmin(){\n', '    \n', '    SInfo.AffRate = rate;\n', '  }\n', '\n', '  function ChangeAffRequire(uint256 amount)\n', '    public\n', '    IsAdmin(){\n', '    SInfo.AffRequire = amount;\n', '  }\n', '\n', '  function WithdrawCRFIInterestPool(uint256 amount)\n', '    public\n', '    IsAdmin(){\n', '    SInfo.crfiInterestPool = SInfo.crfiInterestPool.sub(amount);\n', '    CRFI.send(msg.sender, amount, "");\n', '  }\n', '\n', '  function WithdrawCFilInterestPool(uint256 amount)\n', '    public\n', '    IsAdmin(){\n', '    SInfo.cfilInterestPool = SInfo.cfilInterestPool.sub(amount);\n', '    CFil.send(msg.sender, amount, "");\n', '  }\n', '  \n', '  //////////////////// public\n', '  function tokensReceived(\n', '        address operator,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        bytes calldata userData,\n', '        bytes calldata operatorData)\n', '    public\n', '    override\n', '    nonReentrant(){\n', '\n', '    ////////// check\n', '    require(userData.length > 0, "no user data");\n', '    \n', '    // mode = 0, normal bought financial package\n', '    // mode = 2, charge cfil interest pool\n', '    // mode = 3, charge crfi interest pool\n', '    // mode = 4, loan cfil\n', '    // mode = 5, repay cfil by loan\n', '    (uint256 mode, uint256 param, address addr) = abi.decode(userData, (uint256,uint256, address));\n', '    require(from != address(0x0), "from is zero");\n', '\n', '    if(mode == 5){\n', '      _repayLoanCFil(from, amount);\n', '    }else if(mode == 4){\n', '      _loanCFil(from, amount);\n', '    }else if(mode == 3){\n', '      require(amount > 0, "no amount");\n', '      require(msg.sender == address(CRFI), "only charge crfi");\n', '      SInfo.crfiInterestPool = SInfo.crfiInterestPool.add(amount);\n', '      return;\n', '    }else if(mode == 2){\n', '      require(amount > 0, "no amount");\n', '      require(msg.sender == address(CFil), "only charge cfil");\n', '      SInfo.cfilInterestPool = SInfo.cfilInterestPool.add(amount);\n', '      \n', '      return;\n', '    } else if (mode == 0){\n', '      _buyFinancialPackage(from, param, addr, amount);\n', '    } else {\n', '      revert("mode error");\n', '    }\n', '  }\n', '  \n', '  function Withdraw(uint256 packageID, bool only, uint256 maxNum)\n', '    public\n', '    nonReentrant(){\n', '\n', '    InvestInfo storage uInfo = SInfo.Invests[getUID(msg.sender)];\n', '    \n', '    uint256 cfil;\n', '    uint256 cfilInterest;\n', '    uint256 crfi;\n', '    uint256 crfiInterest;\n', '\n', '    (crfi, crfiInterest, cfil, cfilInterest) = _withdrawFinancial(uInfo, packageID, only, maxNum);\n', '\n', '    if(crfi > 0){\n', '      uInfo.nowInvestFinCRFI = uInfo.nowInvestFinCRFI.sub(crfi);\n', '    }\n', '    if(cfil > 0){\n', '      uInfo.nowInvestFinCFil = uInfo.nowInvestFinCFil.sub(cfil);\n', '    }\n', '\n', '    withdrawCoin(uInfo.Addr, crfi, crfiInterest, cfil, cfilInterest);\n', '  }\n', '\n', '  //////////////////// view func\n', '\n', '  function GetMap(string memory key)\n', '    public\n', '    view\n', '    returns(string memory value){\n', '\n', '    return SInfo.kvMap[key];\n', '  }\n', '\n', '  function GetFinancialPackage()\n', '    public\n', '    view\n', '    returns(FinancialPackage[] memory packages){\n', '\n', '    packages = new FinancialPackage[](SInfo.Packages.length);\n', '    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\n', '      packages[packageID] = SInfo.Packages[packageID];\n', '      packages[packageID].CRFIInterestRateDyn = getFinancialCRFIRate(SInfo.Packages[packageID]);\n', '    }\n', '    \n', '    return packages;\n', '  }\n', '\n', '  function GetInvesterFinRecords(address addr)\n', '    public\n', '    view\n', '    returns(QueueData[] memory records){\n', '\n', '    uint256 uid = SInfo.InvestAddrID[addr];\n', '    if(uid == 0){\n', '      return records;\n', '    }\n', '\n', '    InvestInfo storage uInfo = SInfo.Invests[uid];\n', '\n', '    uint256 recordSize = 0;\n', '\n', '    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\n', '      ChainQueue storage chain = uInfo.InvestRecords[packageID];\n', '      recordSize = recordSize.add(chain.Size);\n', '    }\n', '\n', '    records = new QueueData[](recordSize);\n', '    uint256 id = 0;\n', '    \n', '    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\n', '      ChainQueue storage chain = uInfo.InvestRecords[packageID];\n', '      if(chain.Size == 0){\n', '        continue;\n', '      }\n', '\n', '      ChainItem storage item = SInfo.ChainM.GetFirstItem(chain);\n', '      for(;;){\n', '        records[id] = item.Data;\n', '        id++;\n', '\n', '        if(!SInfo.ChainM.HasNext(item)){\n', '          break;\n', '        }\n', '\n', '        item = SInfo.ChainM.Next(item);\n', '      }\n', '    }\n', '    \n', '    return records;\n', '  }\n', '\n', '\n', '  function GetSystemInfo()\n', '    public\n', '    view\n', '    returns(SystemInfoView memory sInfoView){\n', '\n', '    sInfoView.AffRate = SInfo.AffRate;\n', '    sInfoView.AffRequire = SInfo.AffRequire;\n', '    sInfoView.EnableAffCFil = SInfo.EnableAffCFil;\n', '    sInfoView.NewInvestID = SInfo.NewInvestID;\n', '    sInfoView.nowInvestCRFI = SInfo.nowInvestCRFI;\n', '    sInfoView.nowInvestCFil = SInfo.nowInvestCFil;\n', '    sInfoView.cfilInterestPool = SInfo.cfilInterestPool;\n', '    sInfoView.crfiInterestPool = SInfo.crfiInterestPool;\n', '\n', '    sInfoView.cfilLendingTotal = SInfo.cfilLendingTotal;\n', '    sInfoView.crfiRewardTotal = SInfo.crfiRewardTotal;\n', '    sInfoView.avaiCFilAmount = SInfo.avaiCFilAmount;\n', '  \n', '    sInfoView.totalWeightCFil = SInfo.totalWeightCFil;\n', '    sInfoView.totalWeightCRFI = SInfo.totalWeightCRFI;\n', '    sInfoView.crfiMinerPerDayCFil = SInfo.crfiMinerPerDayCFil;\n', '    sInfoView.crfiMinerPerDayCRFI = SInfo.crfiMinerPerDayCRFI;\n', '  \n', '    sInfoView.ParamUpdateTime = SInfo.ParamUpdateTime;\n', '\n', '    return sInfoView;\n', '  }\n', '\n', '  function GetPackages()\n', '    public\n', '    view\n', '    returns(FinancialPackage[] memory financialPackages,\n', '            LoanCFilPackage memory loanCFil){\n', '\n', '    return (GetFinancialPackage(),\n', '            SInfo.LoanCFil);\n', '  }\n', '\n', '\n', '  function GetInvestRecords(address addr)\n', '    public\n', '    view\n', '    returns(QueueData[] memory records,\n', '            LoanInvest memory loanInvest,\n', '            InterestDetail[] memory interestDetail){\n', '\n', '    uint256 uid = SInfo.InvestAddrID[addr];\n', '    if(uid == 0){\n', '      return (records, loanInvest, interestDetail);\n', '    }\n', '\n', '    InvestInfo storage uInfo = SInfo.Invests[uid];\n', '\n', '    records = GetInvesterFinRecords(addr);\n', '    interestDetail = new InterestDetail[](records.length+1);\n', '\n', '    uint256 id = 0;\n', '    for(; id < records.length; id++){\n', '      (interestDetail[id].crfiInterest, interestDetail[id].cfilInterest) = _calcInvestFinancial(records[id].PackageID, records[id].Amount, records[id].ParamCRFI, records[id].ParamCFil);\n', '    }\n', '\n', '    interestDetail[id].cfilInterest = calcInvestLoanStatus(uInfo);\n', '    interestDetail[id].cfilInterest = interestDetail[id].cfilInterest.add(uInfo.LoanCFil.NowInterest);\n', '\n', '    return(records,\n', '           uInfo.LoanCFil,\n', '           interestDetail);\n', '  }\n', '\n', '  function GetInvestInfo(uint256 uid, address addr)\n', '    public\n', '    view\n', '    returns(bool admin,\n', '            InvestInfoView memory uInfoView){\n', '    if(uid == 0){\n', '      uid = SInfo.InvestAddrID[addr];\n', '    }\n', '\n', '    if(uid == 0){\n', '      if(addr != address(0x0)){\n', '        admin = (SInfo.SuperAdmin == addr) || (SInfo.Admins[addr]);\n', '      }\n', '      return (admin,\n', '              uInfoView);\n', '    }\n', '    \n', '    InvestInfo storage uInfo = SInfo.Invests[uid];\n', '\n', '    admin = (SInfo.SuperAdmin == uInfo.Addr) || (SInfo.Admins[uInfo.Addr]);\n', '\n', '    uInfoView.Addr = uInfo.Addr;\n', '    uInfoView.ID = uInfo.ID;\n', '    uInfoView.affID = uInfo.affID;\n', '    uInfoView.totalAffTimes = uInfo.totalAffTimes;\n', '    uInfoView.totalAffPackageTimes = uInfo.totalAffPackageTimes;\n', '    uInfoView.totalAffCRFI = uInfo.totalAffCRFI;\n', '    uInfoView.totalAffCFil = uInfo.totalAffCFil;\n', '    uInfoView.nowInvestFinCRFI = uInfo.nowInvestFinCRFI;\n', '    uInfoView.nowInvestFinCFil = uInfo.nowInvestFinCFil;\n', '\n', '    return (admin,\n', '            uInfoView);\n', '  }\n', '\n', '  function calcSFilToCFil(uint256 sfil)\n', '    public\n', '    view\n', '    returns(uint256 cfil){\n', '    cfil = sfil.mul(SInfo.LoanCFil.PledgeRate) / Decimal;\n', '    return cfil;\n', '  }\n', '\n', '  function calcCFilToSFil(uint256 cfil)\n', '    public\n', '    view\n', '    returns(uint256 sfil){\n', '\n', '    sfil = cfil.mul(Decimal) / SInfo.LoanCFil.PledgeRate;\n', '    return sfil;\n', '  }\n', '  \n', '  //////////////////// for debug\n', '\n', '  function getChainMDetail()\n', '    public\n', '    view\n', '    returns(ChainManager memory chaimM){\n', '\n', '    return SInfo.ChainM;\n', '  }\n', '\n', '  function getInvestChainDetail(uint256 id)\n', '    public\n', '    view\n', '    returns(ChainQueue[] memory chains){\n', '\n', '    InvestInfo storage uInfo = SInfo.Invests[id];\n', '\n', '    chains = new ChainQueue[](SInfo.Packages.length);\n', '\n', '    for(uint256 packageID = 0; packageID < SInfo.Packages.length; packageID++){\n', '      chains[packageID] = uInfo.InvestRecords[packageID];\n', '    }\n', '\n', '    return chains;\n', '  }\n', '  \n', '  //////////////////// internal func\n', '  function _repayLoanCFil(address from,\n', '                          uint256 cfilAmount)\n', '    internal{\n', '    require(cfilAmount > 0, "no cfil amount");\n', '    require(msg.sender == address(CFil), "not cfil coin type");\n', '\n', '    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];\n', '    updateInvesterLoanCFil(uInfo);\n', '\n', '    // deal interest\n', '    uint256 repayInterest = cfilAmount;\n', '    if(uInfo.LoanCFil.NowInterest < cfilAmount){\n', '      repayInterest = uInfo.LoanCFil.NowInterest;\n', '    }\n', '\n', '    uInfo.LoanCFil.NowInterest = uInfo.LoanCFil.NowInterest.sub(repayInterest);\n', '    SInfo.cfilInterestPool = SInfo.cfilInterestPool.add(repayInterest);\n', '    cfilAmount = cfilAmount.sub(repayInterest);\n', '\n', '    // deal lending\n', '    if(cfilAmount == 0){\n', '      return;\n', '    }\n', '\n', '    uint256 repayLending = cfilAmount;\n', '    if(uInfo.LoanCFil.Lending < cfilAmount){\n', '      repayLending = uInfo.LoanCFil.Lending;\n', '    }\n', '\n', '    uint256 pledge = repayLending.mul(uInfo.LoanCFil.Pledge) / uInfo.LoanCFil.Lending;\n', '    uInfo.LoanCFil.Lending = uInfo.LoanCFil.Lending.sub(repayLending);\n', '    uInfo.LoanCFil.Pledge = uInfo.LoanCFil.Pledge.sub(pledge);\n', '    SInfo.cfilLendingTotal = SInfo.cfilLendingTotal.sub(repayLending);\n', '    SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.add(repayLending);\n', '    cfilAmount = cfilAmount.sub(repayLending);\n', '\n', '    if(pledge > 0){\n', '      SFil.send(from, pledge, "");\n', '    }\n', '    \n', '    if(cfilAmount > 0){\n', '      CFil.send(from, cfilAmount, "");\n', '    }\n', '  }\n', '  \n', '  function _loanCFil(address from,\n', '                     uint256 sfilAmount)\n', '    internal{\n', '\n', '    require(sfilAmount > 0, "no sfil amount");\n', '    require(msg.sender == address(SFil), "not sfil coin type");\n', '\n', '    uint256 cfilAmount = calcSFilToCFil(sfilAmount);\n', '    require(cfilAmount <= SInfo.avaiCFilAmount, "not enough cfil to loan");\n', '    require(cfilAmount >= SInfo.LoanCFil.PaymentDue99, "cfil amount is too small");\n', '\n', '    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];\n', '    updateInvesterLoanCFil(uInfo);\n', '    \n', '    if(uInfo.LoanCFil.Param < SInfo.LoanCFil.Param){\n', '      uInfo.LoanCFil.Param = SInfo.LoanCFil.Param;\n', '    }\n', '    uInfo.LoanCFil.Lending = uInfo.LoanCFil.Lending.add(cfilAmount);\n', '    uInfo.LoanCFil.Pledge = uInfo.LoanCFil.Pledge.add(sfilAmount);\n', '\n', '    SInfo.cfilLendingTotal = SInfo.cfilLendingTotal.add(cfilAmount);\n', '    SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.sub(cfilAmount);\n', '\n', '    CFil.send(from, cfilAmount, "");\n', '    emit loanCFilEvent(from, cfilAmount, sfilAmount);\n', '  }\n', '  \n', '  function _buyFinancialPackage(address from,\n', '                                uint256 packageID,\n', '                                address affAddr,\n', '                                uint256 amount)\n', '    internal{\n', '    // check\n', '    require(amount > 0, "no amount");\n', '    require(packageID < SInfo.Packages.length, "invalid packageID");\n', '    FinancialPackage storage package = SInfo.Packages[packageID];\n', '    if(package.Type == FinancialType.CRFI){\n', '      require(msg.sender == address(CRFI), "not CRFI coin type");\n', '    }else if(package.Type == FinancialType.CFil){\n', '      require(msg.sender == address(CFil), "not CFil coin type");\n', '    } else {\n', '      revert("not avai package type");\n', '    }\n', '\n', '    updateAllParam();\n', '    \n', '    // exec\n', '    InvestInfo storage uInfo = SInfo.Invests[getUID(from)];    \n', '\n', '    uint256 affID = uInfo.affID;\n', '\n', '    if(affID == 0 && affAddr != from && affAddr != address(0x0)){\n', '      uInfo.affID = getUID(affAddr);\n', '      affID = uInfo.affID;\n', '    }\n', '\n', '    if(package.Days == 0){\n', '      affID = 0;\n', '    }\n', '\n', '    if(affID != 0){\n', '      InvestInfo storage affInfo = SInfo.Invests[affID];\n', '      affInfo.totalAffPackageTimes++;      \n', '      emit AffBought(affAddr, from, affInfo.totalAffPackageTimes, amount, packageID, block.timestamp); \n', '    }\n', '\n', '    ChainQueue storage recordQ = uInfo.InvestRecords[package.ID];\n', '\n', '    ChainItem storage item = SInfo.ChainM.GetAvaiItem();\n', '\n', '    item.Data.Type = package.Type;\n', '    item.Data.PackageID = package.ID;\n', '    item.Data.Days = package.Days;\n', '    item.Data.EndTime = block.timestamp.add(package.Days.mul(OneDayTime));\n', '    item.Data.AffID = affID;\n', '    item.Data.Amount = amount;\n', '    item.Data.ParamCRFI = package.ParamCRFI;\n', '    item.Data.ParamCFil = package.ParamCFil;\n', '\n', '    SInfo.ChainM.PushEndItem(recordQ, item);\n', '\n', '    ////////// for statistic\n', '    package.Total = package.Total.add(amount);\n', '    if(package.Type == FinancialType.CRFI){\n', '      uInfo.nowInvestFinCRFI = uInfo.nowInvestFinCRFI.add(amount);\n', '      SInfo.nowInvestCRFI = SInfo.nowInvestCRFI.add(amount);\n', '      SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.add(amount.mul(package.Weight) / Decimal);\n', '    } else if(package.Type == FinancialType.CFil){\n', '      uInfo.nowInvestFinCFil = uInfo.nowInvestFinCFil.add(amount);\n', '      SInfo.nowInvestCFil = SInfo.nowInvestCFil.add(amount);\n', '      SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.add(amount);\n', '      SInfo.totalWeightCFil = SInfo.totalWeightCFil.add(amount.mul(package.Weight) / Decimal);\n', '    }\n', '  }\n', '\n', '  function _withdrawFinancial(InvestInfo storage uInfo, uint256 onlyPackageID, bool only, uint256 maxNum)\n', '    internal\n', '    returns(uint256 crfi,\n', '            uint256 crfiInterest,\n', '            uint256 cfil,\n', '            uint256 cfilInterest){\n', '\n', '    updateAllParam();\n', '\n', '    if(!only){\n', '      onlyPackageID = 0;\n', '    }\n', '\n', '    if(maxNum == 0){\n', '      maxNum -= 1;\n', '    }\n', '    \n', '    (uint256 packageID, ChainItem storage item, bool has) = getFirstValidItem(uInfo, onlyPackageID);\n', '    \n', '    while(has && maxNum > 0 && (!only || packageID == onlyPackageID)){\n', '      maxNum--;\n', '      QueueData storage data = item.Data;\n', '      FinancialPackage storage package = SInfo.Packages[data.PackageID];\n', '\n', '      (uint256 _crfiInterest, uint256 _cfilInterest) = calcInvestFinancial(data);\n', '      crfiInterest = crfiInterest.add(_crfiInterest);\n', '      cfilInterest = cfilInterest.add(_cfilInterest);\n', '\n', '      addAffCRFI(uInfo, data, _crfiInterest, _cfilInterest);\n', '\n', '      if((block.timestamp > data.EndTime && data.Days > 0) || (data.Days ==0 && only)){\n', '        package.Total = package.Total.sub(data.Amount);\n', '        if(data.Type == FinancialType.CFil){\n', '          cfil = cfil.add(data.Amount);\n', '          SInfo.totalWeightCFil = SInfo.totalWeightCFil.sub(data.Amount.mul(package.Weight) / Decimal);\n', '        } else {\n', '          crfi = crfi.add(data.Amount);\n', '          SInfo.totalWeightCRFI = SInfo.totalWeightCRFI.sub(data.Amount.mul(package.Weight) / Decimal);\n', '        }\n', '        SInfo.ChainM.PopPutFirst(uInfo.InvestRecords[packageID]);\n', '        (packageID, item, has) = getFirstValidItem(uInfo, packageID);\n', '      } else {\n', '        data.ParamCRFI = package.ParamCRFI;\n', '        data.ParamCFil = package.ParamCFil;\n', '        (packageID, item, has) = getNextItem(uInfo, packageID, item);\n', '      }\n', '    }\n', '\n', '    return (crfi, crfiInterest, cfil, cfilInterest);\n', '  }\n', '        \n', '  function getUID(address addr) internal returns(uint256 uID){\n', '    uID = SInfo.InvestAddrID[addr];\n', '    if(uID != 0){\n', '      return uID;\n', '    }\n', '    \n', '    SInfo.NewInvestID++;\n', '    uID = SInfo.NewInvestID;\n', '\n', '    InvestInfo storage uInfo = SInfo.Invests[uID];\n', '    uInfo.Addr = addr;\n', '    uInfo.ID = uID;\n', '        \n', '    SInfo.InvestAddrID[addr] = uID;\n', '    return uID;\n', '  }\n', '\n', '  function calcSystemLoanStatus()\n', '    internal\n', '    view\n', '    returns(uint256 param){\n', '\n', '    if(block.timestamp == SInfo.LoanCFil.UpdateTime){\n', '      return SInfo.LoanCFil.Param;\n', '    }\n', '\n', '    uint256 diffSec = block.timestamp.sub(SInfo.LoanCFil.UpdateTime);\n', '\n', '    param = SInfo.LoanCFil.Param.add(calcInterest(Decimal, SInfo.LoanCFil.APY, diffSec));\n', '\n', '    return param;\n', '  }\n', '\n', '  function calcInvestLoanStatus(InvestInfo storage uInfo)\n', '    internal\n', '    view\n', '    returns(uint256 cfilInterest){\n', '\n', '    if(uInfo.LoanCFil.Lending == 0){\n', '      return 0;\n', '    }\n', '    \n', '    uint256 param = calcSystemLoanStatus();\n', '    if(uInfo.LoanCFil.Param >= param){\n', '      return 0;\n', '    }\n', '    \n', '    cfilInterest = uInfo.LoanCFil.Lending.mul(param.sub(uInfo.LoanCFil.Param)) / Decimal;\n', '    \n', '    return cfilInterest;\n', '  }\n', '\n', '  function updateSystemLoanStatus()\n', '    internal{\n', '    uint256 param;\n', '    param = calcSystemLoanStatus();\n', '    if(param <= SInfo.LoanCFil.Param){\n', '      return;\n', '    }\n', '\n', '    SInfo.LoanCFil.Param = param;\n', '    SInfo.LoanCFil.UpdateTime = block.timestamp;\n', '  }\n', '\n', '  function updateInvesterLoanCFil(InvestInfo storage uInfo)\n', '    internal{\n', '    updateSystemLoanStatus();\n', '    uint256 cfilInterest = calcInvestLoanStatus(uInfo);\n', '    if(cfilInterest == 0){\n', '      return;\n', '    }\n', '\n', '    uInfo.LoanCFil.Param = SInfo.LoanCFil.Param;\n', '    uInfo.LoanCFil.NowInterest = uInfo.LoanCFil.NowInterest.add(cfilInterest);\n', '  }\n', '\n', '  function calcInterest(uint256 amount, uint256 rate, uint256 sec)\n', '    internal\n', '    view\n', '    returns(uint256){\n', '    \n', '    return amount.mul(rate).mul(sec) / 365 / OneDayTime / Decimal;    \n', '  }\n', '\n', '  function getFirstValidItem(InvestInfo storage uInfo, uint256 packageID)\n', '    internal\n', '    view\n', '    returns(uint256 newPackageID, ChainItem storage item, bool has){\n', '    \n', '    while(packageID < SInfo.Packages.length){\n', '      ChainQueue storage chain = uInfo.InvestRecords[packageID];\n', '      if(chain.Size == 0){\n', '        packageID++;\n', '        continue;\n', '      }\n', '      item = SInfo.ChainM.GetFirstItem(chain);\n', '      return (packageID, item, true);\n', '    }\n', '\n', '    return (0, SInfo.ChainM.GetNullItem(), false);\n', '  }\n', '\n', '  function getNextItem(InvestInfo storage uInfo,\n', '                       uint256 packageID,\n', '                       ChainItem storage item)\n', '    internal\n', '    view\n', '    returns(uint256, ChainItem storage, bool){\n', '\n', '    if(packageID >= SInfo.Packages.length){\n', '      return (0, item, false);\n', '    }\n', '\n', '    if(SInfo.ChainM.HasNext(item)){\n', '      return (packageID, SInfo.ChainM.Next(item), true);\n', '    }\n', '\n', '    return getFirstValidItem(uInfo, packageID+1);\n', '  }\n', '\n', '  function addAffCRFI(InvestInfo storage uInfo, QueueData storage data, uint256 crfiInterest, uint256 cfilInterest)\n', '    internal{\n', '    if(data.Days == 0){\n', '      return;\n', '    }\n', '    \n', '    uint256 affID = data.AffID;\n', '    if(affID == 0){\n', '      return;\n', '    }\n', '    InvestInfo storage affInfo = SInfo.Invests[affID];\n', '    if(affInfo.nowInvestFinCFil < SInfo.AffRequire){\n', '      return;\n', '    }\n', '    \n', '    uint256 affCRFI = crfiInterest.mul(SInfo.AffRate) / Decimal;\n', '    uint256 affCFil;\n', '\n', '    bool emitFlag;\n', '    if(affCRFI != 0){\n', '      emitFlag = true;\n', '      affInfo.totalAffCRFI = affInfo.totalAffCRFI.add(affCRFI);\n', '    }\n', '\n', '    if(SInfo.EnableAffCFil > 0){\n', '      affCFil = cfilInterest.mul(SInfo.AffRate) / Decimal;\n', '      if(affCFil != 0){\n', '        emitFlag = true;\n', '        affInfo.totalAffCFil = affInfo.totalAffCFil.add(affCFil);\n', '      }\n', '    }\n', '\n', '    if(!emitFlag){\n', '      return;\n', '    }\n', '    \n', '    affInfo.totalAffTimes++;\n', '    emit AffEvent(affInfo.Addr, uInfo.Addr, affInfo.totalAffTimes, affCRFI, affCFil, data.PackageID, block.timestamp);\n', '\n', '    withdrawCoin(affInfo.Addr, 0, affCRFI, 0, affCFil);\n', '\n', '  }\n', '\n', '  function withdrawCoin(address addr,\n', '                        uint256 crfi,\n', '                        uint256 crfiInterest,\n', '                        uint256 cfil,\n', '                        uint256 cfilInterest)\n', '    internal{\n', '    \n', '    require(cfil <= SInfo.nowInvestCFil, "cfil invest now error");\n', '    require(cfil <= SInfo.avaiCFilAmount, "not enough cfil to withdraw");    \n', '    require(crfi <= SInfo.nowInvestCRFI, "crfi invest now error");\n', '    \n', '    if(cfil > 0){\n', '      SInfo.nowInvestCFil = SInfo.nowInvestCFil.sub(cfil);\n', '      SInfo.avaiCFilAmount = SInfo.avaiCFilAmount.sub(cfil);\n', '    }\n', '\n', '    if(crfi > 0){\n', '      SInfo.nowInvestCRFI = SInfo.nowInvestCRFI.sub(crfi);\n', '    }\n', '    \n', '    if(cfilInterest > 0){\n', '      require(SInfo.cfilInterestPool >= cfilInterest, "cfil interest pool is not enough");\n', '      SInfo.cfilInterestPool = SInfo.cfilInterestPool.sub(cfilInterest);\n', '      cfil = cfil.add(cfilInterest);\n', '    }\n', '\n', '    if(crfiInterest > 0){\n', '      require(SInfo.crfiInterestPool >= crfiInterest, "crfi interest pool is not enough");\n', '      SInfo.crfiInterestPool = SInfo.crfiInterestPool.sub(crfiInterest);\n', '      crfi = crfi.add(crfiInterest);\n', '      SInfo.crfiRewardTotal = SInfo.crfiRewardTotal.add(crfiInterest);\n', '    }\n', '\n', '    if(cfil > 0){\n', '      CFil.send(addr, cfil, "");\n', '    }\n', '\n', '    if(crfi > 0){\n', '      CRFI.send(addr, crfi, "");\n', '    }\n', '  }\n', '\n', '  //////////////////// for update param\n', '  \n', '  function getFinancialCRFIRate(FinancialPackage storage package)\n', '    internal\n', '    view\n', '    returns(uint256 rate){\n', '    if(package.Total == 0){\n', '      return 0;\n', '    }\n', '    \n', '    uint256 x = package.Total.mul(package.Weight);\n', '    if(package.Type == FinancialType.CRFI){\n', '      if(SInfo.totalWeightCRFI == 0){\n', '        return 0;\n', '      }\n', '      rate = x.mul(SInfo.crfiMinerPerDayCRFI) / SInfo.totalWeightCRFI;\n', '    } else {\n', '      if(SInfo.totalWeightCFil == 0){\n', '        return 0;\n', '      }\n', '      rate = x.mul(SInfo.crfiMinerPerDayCFil) / SInfo.totalWeightCFil;\n', '    }\n', '\n', '    rate = rate.mul(365) / package.Total ;\n', '    \n', '    return rate;\n', '  }\n', '\n', '  function calcFinancialParam(FinancialPackage storage package)\n', '    internal\n', '    view\n', '    returns(uint256 paramCRFI,\n', '            uint256 paramCFil){\n', '\n', '    uint256 diffSec = block.timestamp.sub(SInfo.ParamUpdateTime);\n', '    if(diffSec == 0){\n', '      return (package.ParamCRFI, package.ParamCFil);\n', '    }\n', '\n', '    paramCFil = package.ParamCFil.add(calcInterest(Decimal, package.CFilInterestRate, diffSec));\n', '    paramCRFI = package.ParamCRFI.add(calcInterest(Decimal,\n', '                                                   getFinancialCRFIRate(package),\n', '                                                   diffSec));\n', '    return (paramCRFI, paramCFil);\n', '  }\n', '\n', '  function updateFinancialParam(FinancialPackage storage package)\n', '    internal{\n', '\n', '    (package.ParamCRFI, package.ParamCFil) = calcFinancialParam(package);\n', '  }\n', '\n', '  function updateAllParam()\n', '    internal{\n', '    if(block.timestamp == SInfo.ParamUpdateTime){\n', '      return;\n', '    }\n', '\n', '    for(uint256 i = 0; i < SInfo.Packages.length; i++){\n', '      updateFinancialParam(SInfo.Packages[i]);\n', '    }\n', '\n', '    SInfo.ParamUpdateTime = block.timestamp;\n', '  }\n', '\n', '  function _calcInvestFinancial(uint256 packageID, uint256 amount, uint256 paramCRFI, uint256 paramCFil)\n', '    internal\n', '    view\n', '    returns(uint256 crfiInterest, uint256 cfilInterest){\n', '    \n', '    FinancialPackage storage package = SInfo.Packages[packageID];\n', '\n', '    (uint256 packageParamCRFI, uint256 packageParamCFil) = calcFinancialParam(package);\n', '    crfiInterest = amount.mul(packageParamCRFI.sub(paramCRFI)) / Decimal;\n', '    cfilInterest = amount.mul(packageParamCFil.sub(paramCFil)) / Decimal;\n', '\n', '    return(crfiInterest, cfilInterest);\n', '  }\n', '\n', '  function calcInvestFinancial(QueueData storage data)\n', '    internal\n', '    view\n', '    returns(uint256 crfiInterest, uint256 cfilInterest){\n', '    return _calcInvestFinancial(data.PackageID, data.Amount, data.ParamCRFI, data.ParamCFil);\n', '  }\n', '}']