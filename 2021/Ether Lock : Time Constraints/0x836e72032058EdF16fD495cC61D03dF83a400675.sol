['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IMasks {\n', '    function ownerOf(uint256 tokenId) external returns (address);\n', '}\n', '\n', '\n', 'contract MaskForMuskBonus {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public constant CosmoTokenRewardAmount = 1e24;\n', '    //address public constant CosmoToken = 0x27cd7375478F189bdcF55616b088BE03d9c4339c;\n', '    address public CosmoToken;\n', '    address public MaskForMusk;\n', '    string public url = "https://CosmoSwap.space/";\n', '\n', '    mapping(uint256 => bool) private _tokenRewarded;\n', '\n', '    event Rewarded(address indexed tokenOwner, uint256 indexed tokenId, uint256 indexed amount);\n', '\n', '\n', '    constructor(address cosmoToken, address maskForMusk) public {\n', '        CosmoToken = cosmoToken;\n', '        MaskForMusk = maskForMusk;\n', '    }\n', '\n', '    function isRewarded(uint256 tokenId) public view returns (bool) {\n', '        return _tokenRewarded[tokenId];\n', '    }\n', '\n', '    function claim(uint256 tokenId) public returns (uint256) {\n', '        address tokenOwner = _msgSender();\n', '        require(isRewarded(tokenId) == false, "The reward has already been claimed");\n', '        require(IMasks(MaskForMusk).ownerOf(tokenId) == tokenOwner, "Only the owner can claim the reward");\n', '\n', '        _sendReward(tokenOwner, CosmoTokenRewardAmount);\n', '        _tokenRewarded[tokenId] = true;\n', '        emit Rewarded(tokenOwner, tokenId, CosmoTokenRewardAmount);\n', '        return CosmoTokenRewardAmount;\n', '    }\n', '\n', '    function claimMany(uint256[] memory tokenIds) public returns (uint256) {\n', '        address tokenOwner = _msgSender();\n', '        uint256 totalClaimed = 0;\n', '        for (uint256 i = 0; i < tokenIds.length; i++) {\n', '            // Duplicate token index check\n', '            for (uint256 j = i + 1; j < tokenIds.length; j++) {\n', '                require(tokenIds[i] != tokenIds[j], "Duplicate tokenId");\n', '            }\n', '\n', '            uint256 tokenId = tokenIds[i];\n', '            require(IMasks(MaskForMusk).ownerOf(tokenId) == tokenOwner, "Only the token owner can claim the reward");\n', '\n', '            if (isRewarded(tokenId) == false) {\n', '                totalClaimed = totalClaimed.add(CosmoTokenRewardAmount);\n', '                _tokenRewarded[tokenId] = true;\n', '                emit Rewarded(tokenOwner, tokenId, CosmoTokenRewardAmount);\n', '            }\n', '        }\n', '\n', '        require(totalClaimed != 0, "No rewards");\n', '        _sendReward(tokenOwner, totalClaimed);\n', '        return totalClaimed;\n', '    }\n', '\n', '    function _sendReward(address tokenOwner, uint256 totalClaimed) internal {\n', '        require(IERC20(CosmoToken).transfer(tokenOwner, totalClaimed), "Reward transfer failed");\n', '    }\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '}']