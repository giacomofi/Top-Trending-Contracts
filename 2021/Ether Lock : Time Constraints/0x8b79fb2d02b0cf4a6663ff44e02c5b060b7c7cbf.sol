['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-24\n', '*/\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.5.12;\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address whom) external view returns (uint);\n', '    function allowance(address, address) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transfer(address dst, uint amt) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '}\n', '\n', 'interface IMPool {\n', '    function controller() external returns (address);\n', '    function totalSupply() external view returns (uint);\n', '    function isBound(address t) external view returns (bool);\n', '    function getFinalTokens() external view returns(address[] memory);\n', '    function getBalance(address token) external view returns (uint);\n', '    function getDenormalizedWeight(address token) external view returns (uint);\n', '    function setSwapFee(uint swapFee) external;\n', '    function setController(address controller) external;\n', '    function setPair(address pair) external;\n', '    function bind(address token, uint balance, uint denorm) external;\n', '    function finalize(address beneficiary, uint256 initAmount) external;\n', '    function updatePairGPInfo(address[] calldata gps, uint[] calldata shares) external;\n', '    function joinPool(address beneficiary, uint poolAmountOut) external;\n', '    function rebind(address token, uint balance, uint denorm) external;\n', '}\n', '\n', 'interface TokenInterface {\n', '    function balanceOf(address) external view returns (uint);\n', '    function allowance(address, address) external view returns (uint);\n', '    function approve(address, uint) external returns (bool);\n', '    function transfer(address, uint) external returns (bool);\n', '    function transferFrom(address, address, uint) external returns (bool);\n', '    function deposit() external payable;\n', '    function withdraw(uint) external;\n', '}\n', '\n', 'interface IPairToken {\n', '    function setController(address _controller) external ;\n', '}\n', '\n', 'interface IMFactory {\n', '    function newMPool() external returns (IMPool);\n', '}\n', '\n', 'interface IPairFactory {\n', '    function newPair(address pool, uint256 perBlock, uint256 rate) external returns (IPairToken);\n', '    function getPairToken(address pool) external view returns (address);\n', '}\n', '\n', '\n', '\n', '/********************************** WARNING **********************************/\n', '//                                                                           //\n', '// This contract is only meant to be used in conjunction with ds-proxy.      //\n', '// Calling this contract directly will lead to loss of funds.                //\n', '//                                                                           //\n', '/********************************** WARNING **********************************/\n', '\n', 'contract MActions {\n', '\n', '    function createWithPair(\n', '        IMFactory factory,\n', '        IPairFactory pairFactory,\n', '        address[] calldata tokens,\n', '        uint[] calldata balances,\n', '        uint[] calldata denorms,\n', '        address[] calldata gps,\n', '        uint[] calldata shares,\n', '        uint swapFee,\n', '        uint gpRate\n', '    ) external payable returns (IMPool pool) {\n', '        pool = create(factory, tokens, balances, denorms, swapFee, 0, false);\n', '\n', '        IPairToken pair = pairFactory.newPair(address(pool), 4 * 10 ** 18, gpRate);\n', '\n', '        pool.setPair(address(pair));\n', '        if (gpRate > 0 && gpRate <= 15 && gps.length != 0 && gps.length == shares.length) {\n', '            pool.updatePairGPInfo(gps, shares);\n', '        }\n', '        pool.finalize(msg.sender, 0);\n', '        pool.setController(msg.sender);\n', '        pair.setController(msg.sender);\n', '    }\n', '\n', '    function create(\n', '        IMFactory factory,\n', '        address[] memory tokens,\n', '        uint[] memory balances,\n', '        uint[] memory denorms,\n', '        uint swapFee,\n', '        uint initLpSupply,\n', '        bool finalize\n', '    ) public payable returns (IMPool pool) {\n', '        require(tokens.length == balances.length, "ERR_LENGTH_MISMATCH");\n', '        require(tokens.length == denorms.length, "ERR_LENGTH_MISMATCH");\n', '\n', '        pool = factory.newMPool();\n', '        pool.setSwapFee(swapFee);\n', '\n', '        address ETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '        address weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            address inToken = tokens[i];\n', '            if (inToken == ETH) {\n', '                require(msg.value == balances[i], "ERR_LIMIT_IN");\n', '                TokenInterface(weth).deposit.value(msg.value)();\n', '                inToken = weth;\n', '            } else {\n', '                safeTransferFrom(inToken, msg.sender, address(this), balances[i]);\n', '            }\n', '            IERC20 token = IERC20(inToken);\n', '            if (token.allowance(address(this), address(pool)) > 0) {\n', '                safeApprove(inToken, address(pool), 0);\n', '            }\n', '            safeApprove(inToken, address(pool), balances[i]);\n', '            pool.bind(inToken, balances[i], denorms[i]);\n', '        }\n', '        if (finalize) {\n', '            pool.finalize(msg.sender, initLpSupply);\n', '            pool.setController(msg.sender);\n', '        }\n', '\n', '    }\n', '\n', '    function joinPool(\n', '        IMPool pool,\n', '        uint poolAmountOut,\n', '        uint[] calldata maxAmountsIn\n', '    ) external payable {\n', '        address[] memory tokens = pool.getFinalTokens();\n', '        require(maxAmountsIn.length == tokens.length, "ERR_LENGTH_MISMATCH");\n', '        uint poolTotal = pool.totalSupply();\n', '        uint ratio = bdiv(poolAmountOut, poolTotal);\n', '        require(ratio != 0, "ERR_MATH_APPROX");\n', '        address _weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            address t = tokens[i];\n', '            uint bal = pool.getBalance(t);\n', '            uint tokenAmountIn = bmul(ratio, bal);\n', '            require(tokenAmountIn != 0, "ERR_MATH_APPROX");\n', '            require(tokenAmountIn <= maxAmountsIn[i], "ERR_LIMIT_IN");\n', '            address from = msg.sender;\n', '            if (msg.value > 0 && t == _weth) {\n', '                require(msg.value <= maxAmountsIn[i], "ERR_ETH_IN");\n', '                TokenInterface weth = TokenInterface(_weth);\n', '                weth.deposit.value(tokenAmountIn)();\n', '                t = address(weth);\n', '                from = address(this);\n', '                if (msg.value > tokenAmountIn) {\n', '                    safeTransferETH(msg.sender, bsub(msg.value, tokenAmountIn));\n', '                }\n', '            }\n', '            safeTransferFrom(t, from, address(pool), tokenAmountIn);\n', '        }\n', '        pool.joinPool(msg.sender, poolAmountOut);\n', '    }\n', '\n', '    function rebind(\n', '        IMPool pool,\n', '        uint[] memory balances,\n', '        uint initLpSupply\n', '    ) public payable {\n', '        require(address(pool) != address(0), "ERR_POOL_INVALID");\n', '        address[] memory tokens = pool.getFinalTokens();\n', '        require(tokens.length == balances.length, "ERR_LENGTH_MISMATCH");\n', '        TokenInterface weth = TokenInterface(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '        bool costETH = false;\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            address inToken = tokens[i];\n', '            if (inToken == address(weth) && msg.value > 0) {\n', '                require(msg.value == balances[i], "ERR_LIMIT_IN");\n', '                weth.deposit.value(msg.value)();\n', '                costETH = true;\n', '            } else {\n', '                safeTransferFrom(inToken, msg.sender, address(this), balances[i]);\n', '            }\n', '            IERC20 token = IERC20(inToken);\n', '            if (token.allowance(address(this), address(pool)) > 0) {\n', '                safeApprove(inToken, address(pool), 0);\n', '            }\n', '            safeApprove(inToken, address(pool), balances[i]);\n', '            pool.rebind(inToken, balances[i], pool.getDenormalizedWeight(inToken));\n', '        }\n', '        if(msg.value > 0 && !costETH){\n', '            safeTransferETH(msg.sender, msg.value);\n', '        }\n', '        pool.finalize(msg.sender, initLpSupply);\n', '        pool.setController(msg.sender);\n', '    }\n', '\n', '    // when sender transfer controller to dproxy, dproxy could transfer controller back to msg.sender;\n', "    // note: mustn't transfer pool's controller to MActions.\n", '    function transferController(IMPool pool) external {\n', '        require(pool.controller() == address(this), "ERR_POOL_CONTROOLER");\n', '        pool.setController(msg.sender);\n', '    }\n', '\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::safeApprove: approve failed'\n", '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::safeTransfer: transfer failed'\n", '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', "            'TransferHelper::transferFrom: transferFrom failed'\n", '        );\n', '    }\n', '\n', '    function safeTransferETH(\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, ) = to.call.value(value)("");\n', "        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n", '    }\n', '\n', '    function setController(IMPool pool, address newController) external {\n', '        pool.setController(newController);\n', '    }\n', '\n', '\n', '    function bdiv(uint a, uint b)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint c0 = a * 10 ** 18;\n', '        require(a == 0 || c0 / a == 1 * 10 ** 18, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    function bmul(uint a, uint b)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        uint c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint c1 = c0 + (1 * 10 ** 18) / 2;\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint c2 = c1 / (1 * 10 ** 18);\n', '        return c2;\n', '    }\n', '\n', '    function bsub(uint a, uint b)\n', '    internal pure\n', '    returns (uint)\n', '    {\n', '        (uint c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint a, uint b)\n', '    internal pure\n', '    returns (uint, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '}']