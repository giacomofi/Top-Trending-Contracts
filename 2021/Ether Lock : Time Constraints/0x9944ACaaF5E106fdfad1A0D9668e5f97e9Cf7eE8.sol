['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC20.sol";\n', 'import "./ERC721.sol";\n', 'import "./Ownable.sol";\n', '\n', 'contract Ciphersquares is ERC721, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public CIPHERSQUARES_PROVENANCE = "";\n', '\n', '    // Maximum amount of NFTs in existance.\n', '    uint256 public constant MAX_NFT_SUPPLY = 3623;\n', '\n', '    uint256 public startingIndexBlock;\n', '\n', '    uint256 public startingIndex;\n', '\n', '    uint256 public REVEAL_TIMESTAMP;\n', '\n', '    address payable private constant _tFirst =\n', '        payable(0x31ED6272EE42493E0D898a595D15e9FB55196F32);\n', '    address payable private constant _tSecond =\n', '        payable(0xBE97e949A89a45F7c141A4d686864dA501cD0664);\n', '\n', '    bool public saleIsActive = false;\n', '\n', '    constructor() ERC721("Ciphersquares", "CSQR") {}\n', '\n', '    function exists(uint256 tokenId) public view returns (bool) {\n', '        return _exists(tokenId);\n', '    }\n', '\n', '    function tokensOfOwner(address _owner)\n', '        external\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        if (tokenCount == 0) {\n', '            // Return an empty array\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            for (uint256 index; index < tokenCount; index++) {\n', '                result[index] = tokenOfOwnerByIndex(_owner, index);\n', '            }\n', '            return result;\n', '        }\n', '    }\n', '\n', '    function getNFTPrice() public view returns (uint256) {\n', '        uint256 cipherSupply = totalSupply();\n', '\n', '        if (cipherSupply >= MAX_NFT_SUPPLY) {\n', '            return 0;\n', '        } else if (cipherSupply >= 3613) {\n', '            return 3.5 ether;\n', '        } else if (cipherSupply >= 3463) {\n', '            return 1.9 ether;\n', '        } else if (cipherSupply >= 3213) {\n', '            return 1.2 ether;\n', '        } else if (cipherSupply >= 2813) {\n', '            return 0.7 ether;\n', '        } else if (cipherSupply >= 2163) {\n', '            return 0.3 ether;\n', '        } else if (cipherSupply >= 1263) {\n', '            return 0.17 ether;\n', '        } else if (cipherSupply >= 663) {\n', '            return 0.09 ether;\n', '        } else if (cipherSupply >= 213) {\n', '            return 0.04 ether;\n', '        } else {\n', '            return 0.01 ether;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the base URI if we want to move things in the future (Callable by owner only)\n', '     */\n', '    function setBaseURI(string memory baseURI) external onlyOwner {\n', '        _setBaseURI(baseURI);\n', '    }\n', '\n', '    function setProvenance(string memory _provenance) external onlyOwner {\n', '        CIPHERSQUARES_PROVENANCE = _provenance;\n', '    }\n', '\n', '    /**\n', '     * @dev Mints yourself NFTs.\n', '     */\n', '    function mintNFTs(uint256 count) external payable {\n', '        require(saleIsActive, "Sale must be active to mint");\n', '        require(totalSupply() < MAX_NFT_SUPPLY, "Sale has already ended");\n', '        require(count > 0, "numberOfNfts cannot be 0");\n', '        require(count <= 20, "You may not buy more than 20 NFTs at once");\n', '        require(\n', '            SafeMath.add(totalSupply(), count) <= MAX_NFT_SUPPLY,\n', '            "Exceeds MAX_NFT_SUPPLY"\n', '        );\n', '        require(\n', '            SafeMath.mul(getNFTPrice(), count) == msg.value,\n', '            "Ether value sent is not correct"\n', '        );\n', '\n', '        for (uint256 i = 0; i < count; i++) {\n', '            uint256 mintIndex = totalSupply();\n', '            if (mintIndex < MAX_NFT_SUPPLY) {\n', '                _safeMint(msg.sender, mintIndex);\n', '            }\n', '        }\n', '\n', "        // If we haven't set the starting index and this is either 1) the last saleable token or 2) the first token to be sold after\n", '        // the end of pre-sale, set the starting index block\n', '        if (\n', '            startingIndexBlock == 0 &&\n', '            (totalSupply() == MAX_NFT_SUPPLY ||\n', '                block.timestamp >= REVEAL_TIMESTAMP)\n', '        ) {\n', '            startingIndexBlock = block.number;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev send eth to treasuryFirst and treasurySecond.\n', '     */\n', '    function withdraw() external onlyOwner {\n', '        uint256 total = address(this).balance;\n', '        uint256 amount = total.div(4);\n', '        _tFirst.transfer(amount);\n', '        _tSecond.transfer(total.sub(amount));\n', '    }\n', '\n', '    function startSale() external onlyOwner {\n', '        saleIsActive = true;\n', '        if (REVEAL_TIMESTAMP == 0) {\n', '            REVEAL_TIMESTAMP = block.timestamp + (86400 * 28);\n', '        }\n', '    }\n', '\n', '    function pauseSale() external onlyOwner {\n', '        saleIsActive = false;\n', '    }\n', '\n', '    /**\n', '     * Set the reveal timestamp index for the collection\n', '     */\n', '    function setRevealTimestamp(uint256 revealTimeStamp) external onlyOwner {\n', '        REVEAL_TIMESTAMP = revealTimeStamp;\n', '    }\n', '\n', '    /**\n', '     * Set the starting index for the collection\n', '     */\n', '    function setStartingIndex() external {\n', '        require(startingIndex == 0, "Starting index is already set");\n', '        require(startingIndexBlock != 0, "Starting index block must be set");\n', '\n', '        startingIndex = uint256(blockhash(startingIndexBlock)) % MAX_NFT_SUPPLY;\n', '        // Just a sanity case in the worst case if this function is called late (EVM only stores last 256 block hashes)\n', '        if (block.number.sub(startingIndexBlock) > 255) {\n', '            startingIndex =\n', '                uint256(blockhash(block.number - 1)) %\n', '                MAX_NFT_SUPPLY;\n', '        }\n', '        // Prevent default sequence\n', '        if (startingIndex == 0) {\n', '            startingIndex = startingIndex.add(1);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Set the starting index block for the collection, essentially unblocking\n', '     * setting starting index\n', '     */\n', '    function emergencySetStartingIndexBlock() external onlyOwner {\n', '        require(startingIndex == 0, "Starting index is already set");\n', '\n', '        startingIndexBlock = block.number;\n', '    }\n', '}']