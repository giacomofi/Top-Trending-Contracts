['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC721.sol";\n', 'import "./Ownable.sol";\n', 'import "./INonfungiblePositionManager.sol";\n', 'import "./IWETH9.sol";\n', 'import "./ICUTTToken.sol";\n', '\n', 'contract Cutties is ERC721, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public CUTTIES_PROVENANCE = "";\n', '\n', '    uint256 public constant MAX_CUTTIES_SUPPLY = 10000;\n', '\n', '    uint256 private _liquidityTokenAmount = 200000000 * 10**6 * 10**9;\n', '\n', '    bool public hasSaleStarted = false;\n', '\n', '    address payable private constant _team =\n', '        payable(0x375063822A5987d83bfc13398C095de89a4730a0);\n', '    address public _treasuryAddress;\n', '    address public _cuttToken;\n', '    address private _weth9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address private _nonfungiblePositionManager =\n', '        0xC36442b4a4522E871399CD717aBDD847Ab11FE88;\n', '\n', '    constructor(string memory baseURI) ERC721("Cutties", "CUTTIES") {\n', '        _setBaseURI(baseURI);\n', '        _treasuryAddress = msg.sender;\n', '    }\n', '\n', '    function deposit() external payable {}\n', '\n', '    function exists(uint256 tokenId) public view returns (bool) {\n', '        return _exists(tokenId);\n', '    }\n', '\n', '    function tokensOfOwner(address _owner)\n', '        external\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        uint256 tokenCount = balanceOf(_owner);\n', '        if (tokenCount == 0) {\n', '            return new uint256[](0);\n', '        } else {\n', '            uint256[] memory result = new uint256[](tokenCount);\n', '            for (uint256 index; index < tokenCount; index++) {\n', '                result[index] = tokenOfOwnerByIndex(_owner, index);\n', '            }\n', '            return result;\n', '        }\n', '    }\n', '\n', '    function getMintableCount() public view returns (uint256) {\n', '        uint256 cuttiesupply = totalSupply();\n', '\n', '        if (cuttiesupply >= MAX_CUTTIES_SUPPLY) {\n', '            return 0;\n', '        } else if (cuttiesupply >= 9990) {\n', '            // 9991 ~ 10000\n', '            return 1;\n', '        } else if (cuttiesupply >= 9900) {\n', '            // 9901 ~ 9990\n', '            return 5;\n', '        } else {\n', '            // 1 ~ 9900\n', '            return 20;\n', '        }\n', '    }\n', '\n', '    function getCuttiesPrice() public view returns (uint256) {\n', '        uint256 cuttiesupply = totalSupply();\n', '\n', '        if (cuttiesupply >= MAX_CUTTIES_SUPPLY) {\n', '            return 0;\n', '        } else if (cuttiesupply >= 9990) {\n', '            // 9990 ~ 9999\n', '            return 1 ether;\n', '        } else if (cuttiesupply >= 9900) {\n', '            // 9900 ~ 9989\n', '            return 0.64 ether;\n', '        } else if (cuttiesupply >= 8900) {\n', '            // 8900 ~ 9899\n', '            return 0.48 ether;\n', '        } else if (cuttiesupply >= 6700) {\n', '            // 6700 ~ 8899\n', '            return 0.32 ether;\n', '        } else if (cuttiesupply >= 3200) {\n', '            // 3200 ~ 6699\n', '            return 0.16 ether;\n', '        } else if (cuttiesupply >= 1200) {\n', '            // 1200 ~ 3199\n', '            return 0.08 ether;\n', '        } else if (cuttiesupply >= 200) {\n', '            // 200 ~ 1199\n', '            return 0.04 ether;\n', '        } else {\n', '            return 0.02 ether; // 0 ~ 199\n', '        }\n', '    }\n', '\n', '    function getCuttTokenAmount() public view returns (uint256) {\n', '        uint256 cuttiesupply = totalSupply();\n', '\n', '        if (cuttiesupply >= MAX_CUTTIES_SUPPLY) {\n', '            return 0;\n', '        } else if (cuttiesupply >= 9990) {\n', '            // 9990 ~ 9999\n', '            return uint256(496130184560).mul(10**9).div(10);\n', '        } else if (cuttiesupply >= 9900) {\n', '            // 9900 ~ 9989\n', '            return uint256(2857709863068).mul(10**9).div(90);\n', '        } else if (cuttiesupply >= 8900) {\n', '            // 8900 ~ 9899\n', '            return uint256(23814248858901).mul(10**9).div(1000);\n', '        } else if (cuttiesupply >= 6700) {\n', '            // 6700 ~ 8899\n', '            return uint256(34927564993054).mul(10**9).div(2200);\n', '        } else if (cuttiesupply >= 3200) {\n', '            // 3200 ~ 6699\n', '            return uint256(27783290335384).mul(10**9).div(3500);\n', '        } else if (cuttiesupply >= 1200) {\n', '            // 1200 ~ 3199\n', '            return uint256(7938082952967).mul(10**9).div(2000);\n', '        } else if (cuttiesupply >= 200) {\n', '            // 200 ~ 1199\n', '            return uint256(1984520738242).mul(10**9).div(1000);\n', '        } else {\n', '            // 0 ~ 199\n', '            return uint256(198452073824).mul(10**9).div(200);\n', '        }\n', '    }\n', '\n', '    function setBaseURI(string memory baseURI) external onlyOwner {\n', '        _setBaseURI(baseURI);\n', '    }\n', '\n', '    function setProvenance(string memory _provenance) external onlyOwner {\n', '        CUTTIES_PROVENANCE = _provenance;\n', '    }\n', '\n', '    function mintCutties(address to, uint256 count) external payable {\n', '        require(_cuttToken != address(0));\n', '        uint256 cuttiesupply = totalSupply();\n', '        require(hasSaleStarted);\n', '        require(count > 0 && count <= getMintableCount());\n', '        require(SafeMath.add(cuttiesupply, count) <= MAX_CUTTIES_SUPPLY);\n', '        require(SafeMath.mul(getCuttiesPrice(), count) == msg.value);\n', '\n', '        uint256 tokenAmount = getCuttTokenAmount();\n', '        ICUTTToken(_cuttToken).transfer(to, tokenAmount.mul(count));\n', '\n', '        for (uint8 i; i < count; i++) {\n', '            uint256 mintIndex = totalSupply();\n', '            _safeMint(to, mintIndex);\n', '        }\n', '    }\n', '\n', '    function reserveCutties() external onlyOwner {\n', '        uint256 supply = totalSupply();\n', '        for (uint256 i = 0; i < 30; i++) {\n', '            _safeMint(msg.sender, supply + i);\n', '        }\n', '    }\n', '\n', '    function withdraw(uint256 amount) external onlyOwner {\n', '        _team.transfer(amount);\n', '    }\n', '\n', '    function startSale() public onlyOwner {\n', '        hasSaleStarted = true;\n', '    }\n', '\n', '    function pauseSale() public onlyOwner {\n', '        hasSaleStarted = false;\n', '    }\n', '\n', '    function setTokenAddress(address tokenAddress) public onlyOwner {\n', '        _cuttToken = tokenAddress;\n', '    }\n', '\n', '    function setLiquidityTokenAmount(uint256 liquidityTokenAmount)\n', '        public\n', '        onlyOwner\n', '    {\n', '        _liquidityTokenAmount = liquidityTokenAmount;\n', '    }\n', '\n', '    function mintLiquidityAndCuttiesToken() public onlyOwner {\n', '        require(_cuttToken != address(0));\n', '        ICUTTToken(_cuttToken).mintLiquidityToken();\n', '        ICUTTToken(_cuttToken).mintCuttiesToken();\n', '    }\n', '\n', '    function getTokens() public view returns (address token0, address token1) {\n', '        token0 = (_weth9 < _cuttToken) ? _weth9 : _cuttToken;\n', '        token1 = (_weth9 > _cuttToken) ? _weth9 : _cuttToken;\n', '    }\n', '\n', '    function getTokenBalances()\n', '        public\n', '        view\n', '        returns (uint256 balance0, uint256 balance1)\n', '    {\n', '        uint256 cuttBalance =\n', '            ICUTTToken(_cuttToken).balanceOf(address(this)) >=\n', '                _liquidityTokenAmount\n', '                ? _liquidityTokenAmount\n', '                : ICUTTToken(_cuttToken).balanceOf(address(this));\n', '        uint256 ethBalance = address(this).balance;\n', '\n', '        balance0 = (_weth9 < _cuttToken) ? ethBalance : cuttBalance;\n', '        balance1 = (_weth9 > _cuttToken) ? ethBalance : cuttBalance;\n', '    }\n', '\n', '    function sqrt(uint160 x) internal pure returns (uint160 y) {\n', '        uint160 z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '\n', '    function createPoolAndLiquidity(\n', '        uint24 fee,\n', '        int24 tickLower,\n', '        int24 tickUpper\n', '    ) public onlyOwner {\n', '        require(_cuttToken != address(0));\n', '        require(!hasSaleStarted);\n', '        (address token0, address token1) = getTokens();\n', '        (uint256 balance0, uint256 balance1) = getTokenBalances();\n', '        require(balance0 > 0);\n', '        require(balance1 > 0);\n', '\n', '        uint160 sqrtPriceX96 =\n', '            (sqrt(uint160(balance1)) << 96) / sqrt(uint160(balance0));\n', '\n', '        address poolAddress =\n', '            INonfungiblePositionManager(_nonfungiblePositionManager)\n', '                .createAndInitializePoolIfNecessary{\n', '                value: address(this).balance\n', '            }(token0, token1, fee, sqrtPriceX96);\n', '\n', '        ICUTTToken(_cuttToken).setPoolAddress(poolAddress);\n', '\n', '        ICUTTToken(_cuttToken).approve(\n', '            _nonfungiblePositionManager,\n', '            _liquidityTokenAmount\n', '        );\n', '\n', '        INonfungiblePositionManager.MintParams memory data =\n', '            INonfungiblePositionManager.MintParams(\n', '                token0,\n', '                token1,\n', '                fee,\n', '                tickLower,\n', '                tickUpper,\n', '                balance0,\n', '                balance1,\n', '                0,\n', '                0,\n', '                address(this),\n', '                (uint256)(block.timestamp).add(1000)\n', '            );\n', '\n', '        INonfungiblePositionManager(_nonfungiblePositionManager).mint(data);\n', '    }\n', '\n', '    function setTreasuryAddress(address treasuryAddress) public {\n', '        require(msg.sender == _treasuryAddress);\n', '        _treasuryAddress = treasuryAddress;\n', '    }\n', '\n', '    function withdrawNFT(uint256 tokenId) external {\n', '        require(msg.sender == _treasuryAddress);\n', '        INonfungiblePositionManager(_nonfungiblePositionManager).approve(\n', '            _treasuryAddress,\n', '            tokenId\n', '        );\n', '        INonfungiblePositionManager(_nonfungiblePositionManager).transferFrom(\n', '            address(this),\n', '            _treasuryAddress,\n', '            tokenId\n', '        );\n', '    }\n', '\n', '    function burnExtraToken() public onlyOwner {\n', '        require(_cuttToken != address(0));\n', '        require(!hasSaleStarted);\n', '        uint256 amount = ICUTTToken(_cuttToken).balanceOf(address(this));\n', '        ICUTTToken(_cuttToken).burn(amount);\n', '    }\n', '}']