['# @version 0.2.12\n', '"""\n', '@title Root-Chain Gauge\n', '@author Curve Finance\n', '@license MIT\n', '@notice Calculates total allocated weekly CRV emission\n', '        mints and sends across a sidechain bridge\n', '"""\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', '\n', 'interface CRV20:\n', '    def future_epoch_time_write() -> uint256: nonpayable\n', '    def rate() -> uint256: view\n', '\n', 'interface Controller:\n', '    def period() -> int128: view\n', '    def period_write() -> int128: nonpayable\n', '    def period_timestamp(p: int128) -> uint256: view\n', '    def gauge_relative_weight(addr: address, time: uint256) -> uint256: view\n', '    def voting_escrow() -> address: view\n', '    def checkpoint(): nonpayable\n', '    def checkpoint_gauge(addr: address): nonpayable\n', '\n', 'interface Minter:\n', '    def token() -> address: view\n', '    def controller() -> address: view\n', '    def minted(user: address, gauge: address) -> uint256: view\n', '    def mint(gauge: address): nonpayable\n', '\n', '\n', 'event Deposit:\n', '    provider: indexed(address)\n', '    value: uint256\n', '\n', 'event Withdraw:\n', '    provider: indexed(address)\n', '    value: uint256\n', '\n', 'event UpdateLiquidityLimit:\n', '    user: address\n', '    original_balance: uint256\n', '    original_supply: uint256\n', '    working_balance: uint256\n', '    working_supply: uint256\n', '\n', 'event CommitOwnership:\n', '    admin: address\n', '\n', 'event ApplyOwnership:\n', '    admin: address\n', '\n', 'event Transfer:\n', '    _from: indexed(address)\n', '    _to: indexed(address)\n', '    _value: uint256\n', '\n', 'event Approval:\n', '    _owner: indexed(address)\n', '    _spender: indexed(address)\n', '    _value: uint256\n', '\n', '\n', 'WEEK: constant(uint256) = 604800\n', '\n', 'minter: public(address)\n', 'crv_token: public(address)\n', 'controller: public(address)\n', 'future_epoch_time: public(uint256)\n', '\n', 'period: public(uint256)\n', 'emissions: public(uint256)\n', 'inflation_rate: public(uint256)\n', '\n', 'admin: public(address)\n', 'future_admin: public(address)  # Can and will be a smart contract\n', 'is_killed: public(bool)\n', '\n', 'checkpoint_admin: public(address)\n', 'anyswap_bridge: public(address)\n', '\n', '\n', '@external\n', 'def __init__(_minter: address, _admin: address, _anyswap_bridge: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _minter Minter contract address\n', '    @param _admin Admin who can kill the gauge\n', '    @param _anyswap_bridge Address of the AnySwap bridge where CRV is transferred\n', '    """\n', '\n', '    crv_token: address = Minter(_minter).token()\n', '    controller: address = Minter(_minter).controller()\n', '\n', '    self.minter = _minter\n', '    self.admin = _admin\n', '    self.crv_token = crv_token\n', '    self.controller = controller\n', '    self.anyswap_bridge = _anyswap_bridge\n', '\n', '    self.period = block.timestamp / WEEK\n', '    self.inflation_rate = CRV20(crv_token).rate()\n', '    self.future_epoch_time = CRV20(crv_token).future_epoch_time_write()\n', '\n', '\n', '\n', '@external\n', 'def checkpoint() -> bool:\n', '    """\n', '    @notice Mint all allocated CRV emissions and transfer across the bridge\n', '    @dev Should be called once per week, after the new epoch period has begun\n', '    """\n', '    assert self.checkpoint_admin in [ZERO_ADDRESS, msg.sender]\n', '    rate: uint256 = self.inflation_rate\n', '    new_rate: uint256 = rate\n', '    prev_future_epoch: uint256 = self.future_epoch_time\n', '    token: address = self.crv_token\n', '    if prev_future_epoch < block.timestamp:\n', '        self.future_epoch_time = CRV20(token).future_epoch_time_write()\n', '        new_rate = CRV20(token).rate()\n', '        self.inflation_rate = new_rate\n', '\n', '    last_period: uint256 = self.period\n', '    current_period: uint256 = block.timestamp / WEEK\n', '\n', '    if last_period < current_period:\n', '        controller: address = self.controller\n', '        Controller(controller).checkpoint_gauge(self)\n', '\n', '        emissions: uint256 = 0\n', '        last_period += 1\n', '        for i in range(last_period, last_period+255):\n', '            if i > current_period:\n', '                break\n', '            week_time: uint256 = i * WEEK\n', '            gauge_weight: uint256 = Controller(controller).gauge_relative_weight(self, i * WEEK)\n', '            emissions += gauge_weight * rate * WEEK / 10**18\n', '\n', '            if prev_future_epoch < week_time:\n', '                # If we went across one or multiple epochs, apply the rate\n', '                # of the first epoch until it ends, and then the rate of\n', '                # the last epoch.\n', '                # If more than one epoch is crossed - the gauge gets less,\n', "                # but that'd meen it wasn't called for more than 1 year\n", '                rate = new_rate\n', '                prev_future_epoch = MAX_UINT256\n', '\n', '        self.period = current_period\n', '        self.emissions += emissions\n', '        if emissions > 0 and not self.is_killed:\n', '            Minter(self.minter).mint(self)\n', '            ERC20(token).transfer(self.anyswap_bridge, emissions)\n', '\n', '    return True\n', '\n', '\n', '@view\n', '@external\n', 'def user_checkpoint(addr: address) -> bool:\n', '    return True\n', '\n', '\n', '@view\n', '@external\n', 'def integrate_fraction(addr: address) -> uint256:\n', '    assert addr == self, "Gauge can only mint for itself"\n', '    return self.emissions\n', '\n', '\n', '@external\n', 'def set_killed(_is_killed: bool):\n', '    """\n', '    @notice Set the killed status for this contract\n', '    @dev When killed, the gauge always yields a rate of 0 and so cannot mint CRV\n', '    @param _is_killed Killed status to set\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '\n', '    self.is_killed = _is_killed\n', '\n', '\n', '@external\n', 'def commit_transfer_ownership(addr: address):\n', '    """\n', '    @notice Transfer ownership of GaugeController to `addr`\n', '    @param addr Address to have ownership transferred to\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '\n', '    self.future_admin = addr\n', '    log CommitOwnership(addr)\n', '\n', '\n', '@external\n', 'def accept_transfer_ownership():\n', '    """\n', '    @notice Accept a pending ownership transfer\n', '    """\n', '    _admin: address = self.future_admin\n', '    assert msg.sender == _admin  # dev: future admin only\n', '\n', '    self.admin = _admin\n', '    log ApplyOwnership(_admin)\n', '\n', '\n', '@external\n', 'def set_checkpoint_admin(_admin: address):\n', '    """\n', '    @notice Set the checkpoint admin address\n', '    @dev Setting to ZERO_ADDRESS allows anyone to call `checkpoint`\n', '    @param _admin Address of the checkpoint admin\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '\n', '    self.checkpoint_admin = _admin']