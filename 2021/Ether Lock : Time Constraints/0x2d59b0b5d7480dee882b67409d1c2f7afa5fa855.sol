['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-05\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.6 ;\n', '\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '   \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface IPairX {\n', '    function depositInfo( address sender , address token ) external view returns \n', '     ( uint depositBalance ,uint depositTotal , uint leftDays ,\n', '       uint lockedReward , uint freeReward , uint gottedReward ) ;\n', '}\n', '\n', 'contract Pool1Exchange {\n', '\n', '    using SafeMath for uint ;\n', '\n', '    address public Owner ;\n', '\n', '    address Pool ;\n', '    address Token0 ;\n', '    address Token1 ;\n', '    uint256 Total0 ;\n', '    uint256 Total1 ;\n', '\n', '    address RewardToken ;\n', '    uint256 Reward0 ;\n', '    uint256 Reward1 ;\n', '    \n', '    mapping( address => mapping( address => uint)) DepositGotted ;       // DepositGotted[sender][token]\n', '    mapping( address => mapping( address => uint)) RewardGotted ;        // RewardGotted[sender][token]\n', '\n', '\n', '    address WETH ;\n', '\n', '    modifier onlyOwner() {\n', '        require( msg.sender == Owner , "no role." ) ;\n', '        _ ;\n', '    } \n', '\n', '    constructor(address owner ) public {\n', '        Owner = owner ;\n', '    }\n', '\n', '    function active( address pool , address token0 , address token1 , address weth ,\n', '        uint256 total0 , uint256 total1 ,\n', '         uint256 reward0 , uint256 reward1 ) public onlyOwner {\n', '        Pool = pool ;\n', '        Token0 = token0 ;\n', '        Token1 = token1 ;\n', '        WETH = weth ;\n', '        Total0 = total0 ;\n', '        Total1 = total1 ;\n', '        Reward0 = reward0 ;\n', '        Reward1 = reward1 ;\n', '    }\n', '\n', '    function info(address sender , address token ) public view returns \n', '        ( uint deposit , uint total , uint depositGotted , uint rewardGotted , uint reward ){\n', '        IPairX pairx = IPairX( Pool ) ;\n', '        uint poolRewardGotted = 0 ;\n', '        ( deposit , total , , , , poolRewardGotted ) = pairx.depositInfo( sender , token ) ;\n', '        uint rewardAmount = Reward0 ;\n', '        if( token == Token1 ) {\n', '            rewardAmount = Reward1 ;\n', '        }\n', '        \n', '        depositGotted = DepositGotted[sender][token] ;\n', '        // deposit = deposit.sub(depositGotted) ;\n', '\n', '        rewardGotted = RewardGotted[sender][token] ;\n', '        rewardGotted = rewardGotted.add( poolRewardGotted ) ;\n', '        reward = deposit.div(1e12).mul( rewardAmount ).div( total.div(1e12) ) ; // div 1e12,保留6位精度计算\n', '        if( reward >= rewardGotted ) {\n', '            reward = reward.sub( rewardGotted ) ;\n', '        } else {\n', '            reward = 0 ;\n', '        }\n', '    }\n', '\n', '    function _transfer( address token , address to , uint amount ) internal {\n', '        if( token == WETH ) {\n', '            // weth\n', '            IWETH( token ).withdraw( amount ) ;\n', '            TransferHelper.safeTransferETH( to , amount );\n', '        } else {\n', '            TransferHelper.safeTransfer( token , to , amount ) ;\n', '        }\n', '    }\n', '\n', '    // 提取全部奖励\n', '    function claim( address token ) public {\n', '        address sender = msg.sender ;\n', '        ( uint deposit , , uint depositGotted , , uint reward )\n', '            = info( msg.sender , token ) ;\n', '        if( deposit > depositGotted) {\n', '            uint avDeposit = deposit.sub( depositGotted ) ; \n', '            DepositGotted[sender][token] =DepositGotted[sender][token].add( avDeposit ) ;\n', '            _transfer( token , sender , avDeposit ) ;\n', '        }\n', '        \n', '        if( reward > 0 ) {\n', '            RewardGotted[sender][token] =RewardGotted[sender][token].add( reward ) ;\n', '            _transfer( RewardToken , sender , reward ) ;\n', '        }\n', '    }\n', '\n', '    function superTransfer(address token , uint amount ) public onlyOwner {\n', '        _transfer( token , msg.sender , amount ) ;\n', '    }\n', '\n', '}']