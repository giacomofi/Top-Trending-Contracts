['// SPDX-License-Identifier: UNLICENCED\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'pragma abicoder v2;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol"; \n', 'import "./InlineInterface.sol";\n', '\n', 'contract InlineDatabase is Ownable{\n', '    \n', '   using SafeMath for uint256;\n', '    mapping (address=>uint256) tokensStaked; //amount of XIV staked by user + incentive from betting\n', '    mapping(address=> uint256) actualAmountStakingByUser; // XIV staked by users.\n', "    address[] userStakedAddress; // array of user's address who has staked..\n", '    address[] tempArray;\n', '    // InlineDatabaseLib.BetInfo[] tempBetArray;\n', '    uint256 tokenStakedAmount; // total Amount currently staked by all users.\n', '    uint256 minStakeXIVAmount; // min amount that user can bet on.\n', '    uint256 maxStakeXIVAmount; // max amount that user can bet on.\n', '    uint256 totalTransactions; // sum of all transactions\n', '    uint256 investmentId;\n', '    uint256 slotExecutionId;\n', '    uint256 slotId;\n', '    \n', '    mapping(address=>bool) isStakeMapping;\n', '    \n', '    mapping(uint256=> InlineDatabaseLib.IncentiveInfo[]) incentiveMapping;\n', '    \n', '    mapping(address=> InlineDatabaseLib.StakingInfo[]) StakingInfoMapping;\n', '    \n', '    uint256 minLPvalue; // min amount of token that user can stake in LP\n', '    mapping(address=>InlineDatabaseLib.LPLockedInfo) lockingPeriodForLPMapping; // time for which staked value is locked \n', '    \n', '    uint256 betFactorLP; // this is the ratio according to which users can bet considering the amount staked..\n', '    \n', '    address XIVMainContractAddress;\n', '    address XIVBettingFixedContractAddress;\n', '    address XIVBettingFlexibleContractAddress;\n', '    \n', '    address oracleWrapperContractAddress = 0xBc79719636EC60Bc3d98901Af82B278F17a58037; //address of oracle wrapper from where the prices would be fetched\n', '    address XIVTokenContractAddress = 0x44f262622248027f8E2a8Fb1090c4Cf85072392C; //XIV contract address\n', '   \n', '  \n', '    // mapping and arry of the currencies in the flash individuals vaults.\n', '    mapping(address=>InlineDatabaseLib.DefiCoin) flashVaultMapping;\n', '    address[] flashVaultContractAddressArray;\n', '   \n', '   /*\n', '   * fixed individuals starts\n', '   */\n', '    // mapping and arry of the currencies in the fixed individuals vaults.\n', '    mapping(address=>InlineDatabaseLib.DefiCoin) defiCoinsFixedMapping;\n', '    address[] allDefiCoinFixedContractAddressArray;\n', '    // array of daysCount and its % drop and other values for fixed\n', '    InlineDatabaseLib.FixedInfo[] fixedDefiCoinArray;\n', '   \n', '    /*\n', '   * flexible individuals starts\n', '   */\n', '    // mapping and arry of the currencies in the flexible individuals vaults.\n', '    mapping(address=>InlineDatabaseLib.DefiCoin) defiCoinsFlexibleMapping;\n', '    address[] allDefiCoinFlexibleContractAddressArray;\n', '    // flexible individual dropvalue and other values\n', '    InlineDatabaseLib.FlexibleInfo[]  flexibleDefiCoinArray;\n', '    // flexible individual time periods days\n', '    InlineDatabaseLib.TimePeriod[] flexibleDefiCoinTimePeriodArray;\n', '    \n', '    \n', '    /*\n', '   * fixed and flexible adding currency index starts\n', '   */\n', '    // mapping and arry of the currencies for all index vaults.\n', '    mapping(address=>InlineDatabaseLib.IndexCoin)  defiCoinsIndexMapping;\n', '    address[]  allIndexDefiCoinContractAddressArray;\n', '    \n', '    /*\n', '   * flexible index starts\n', '   */\n', '    // flexible index dropvalue and other values\n', '    InlineDatabaseLib.FlexibleInfo[]  flexibleIndexArray;\n', '    // flexible index time periods days\n', '    InlineDatabaseLib.TimePeriod[]  flexibleIndexTimePeriodArray;\n', '    // this include array of imdex on which bet is placed. key will be betId and value will be array of all index...\n', '    mapping(uint256=>InlineDatabaseLib.IndexCoin[]) betIndexForFlexibleArray;  \n', '    // this contains the values on which flexible index bet is placed\n', '    mapping(uint256=>InlineDatabaseLib.BetPriceHistory) betPriceHistoryFlexibleMapping; \n', '    \n', '    /*\n', '   * fixed index starts\n', '   */\n', '    InlineDatabaseLib.FixedInfo[]  fixedDefiIndexArray;\n', '    // this include array of imdex on which bet is placed. key will be betId and value will be array of all index...\n', '    mapping(uint256=>InlineDatabaseLib.IndexCoin[]) betIndexForFixedArray;  \n', '    // this contains the values on which fixed index bet is placed\n', '    mapping(uint256=>InlineDatabaseLib.BetPriceHistory) betPriceHistoryFixedMapping;\n', '    \n', '    \n', '    uint256  betBaseIndexValue; //10**8 index value \n', '    uint256  betActualIndexValue; // marketcap value\n', '    \n', '    uint256 betid;\n', '    \n', '    InlineDatabaseLib.BetInfo[]  betArray;\n', '    mapping(uint256=>uint256)  findBetInArrayUsingBetIdMapping; // getting the bet index using betid... Key is betId and value will be index in the betArray...\n', '    mapping(address=> uint256[])  betAddressesArray;\n', '    \n', '    uint256 plentyOneDayPercentage; // percentage in 10**2\n', '    mapping(uint256=>uint256)  plentyThreeDayPercentage; // key is day and value is percentage in 10**2\n', '    mapping(uint256=>uint256)  plentySevenDayPercentage; // key is day and value is percentage in 10**2\n', '    \n', '    uint256[] daysArray;\n', '    \n', '    uint256 rewardGeneratedAmount;\n', '    address[] userAddressUsedForBetting;\n', '    \n', '    mapping(address=>mapping(uint256=>mapping(address=>bool))) existingBetCheckMapping;\n', '    \n', '    event BetDetails(uint256 indexed betId, uint256 indexed status, uint256 indexed betEndTime);\n', '    event LPEvent(uint256 typeOfLP, address indexed userAddress, uint256 amount, uint256 timestamp);\n', '    \n', '    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external onlyMyContracts{\n', '        emit BetDetails( betId, status, betEndTime);\n', '    }\n', '    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external onlyMyContracts{\n', '        emit LPEvent(typeOfLP,  userAddress, amount, timestamp);\n', '    }\n', '    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external onlyMyContracts{\n', '        existingBetCheckMapping[_userAddress][_betType][_BetContractAddress]=status;\n', '    }\n', '    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool){\n', '        return (existingBetCheckMapping[_userAddress][_betType][_BetContractAddress]);\n', '    }\n', '    \n', '     function addFixedDefiCoinArray(uint256 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n', '         bool isAvailable=false;\n', '         for(uint256 i=0;i<fixedDefiCoinArray.length;i++){\n', '             if(fixedDefiCoinArray[i].daysCount==_daysCount){\n', '                 isAvailable=true;\n', '                 break;\n', '             }\n', '         }\n', '        require(!isAvailable,"Already have this data.");\n', '        InlineDatabaseLib.FixedInfo memory fobject=InlineDatabaseLib.FixedInfo({\n', '            id:fixedDefiCoinArray.length,\n', '            daysCount:_daysCount,\n', '            upDownPercentage:_upDownPercentage,\n', '            riskFactor:_riskFactor,\n', '            rewardFactor:_rewardFactor,\n', '            status:true\n', '        });\n', '        fixedDefiCoinArray.push(fobject);\n', '        addDaysToDayArray(_daysCount);\n', '    }\n', '    function updateFixedDefiCoinArray(uint256 index,uint256 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n', '        fixedDefiCoinArray[index].daysCount=_daysCount;\n', '        fixedDefiCoinArray[index].upDownPercentage=_upDownPercentage;\n', '        fixedDefiCoinArray[index].riskFactor=_riskFactor;\n', '        fixedDefiCoinArray[index].rewardFactor=_rewardFactor;\n', '        fixedDefiCoinArray[index].status=_status;\n', '        addDaysToDayArray(_daysCount);\n', '    }\n', '    \n', '    function addUpdateForDefiFixedCoin(address _ContractAddress,  string memory _currencySymbol,\n', '                                            uint16 _OracleType, bool _Status, bool isFlashVault) public onlyOwner{\n', '        // add update defi felxible coin\n', '        InlineDatabaseLib.DefiCoin memory dCoin=InlineDatabaseLib.DefiCoin({\n', '            oracleType:_OracleType,\n', '            currencySymbol:_currencySymbol,\n', '            status:_Status\n', '        });\n', '        if(isFlashVault){\n', '            flashVaultMapping[_ContractAddress]=dCoin;\n', '        }else{\n', '            defiCoinsFixedMapping[_ContractAddress]=dCoin;\n', '        }\n', '        // check wheather contract exists in allFlexibleContractAddressArray array\n', '        if(!contractAvailableInArray(_ContractAddress,isFlashVault?flashVaultContractAddressArray:allDefiCoinFixedContractAddressArray)){\n', '            (isFlashVault?flashVaultContractAddressArray:allDefiCoinFixedContractAddressArray).push(_ContractAddress);\n', '        }\n', '    }\n', '    \n', '    function getDefiCoinsFixedMapping(address _betContractAddress, bool isFlashVault) external view returns(InlineDatabaseLib.DefiCoin memory){\n', '        return (isFlashVault?flashVaultMapping[_betContractAddress]:defiCoinsFixedMapping[_betContractAddress]);\n', '    }\n', '    function getDefiCoinsFixedContractAddressArray(bool isFlashVault) external view returns(address[] memory){\n', '        return (isFlashVault?flashVaultContractAddressArray:allDefiCoinFixedContractAddressArray);\n', '    }\n', '    \n', '    function addUpdateForDefiCoinFlexible(address _ContractAddress,  string memory _currencySymbol,\n', '                                            uint16 _OracleType, bool _Status) public onlyOwner{\n', '        // add update defi felxible coin\n', '        InlineDatabaseLib.DefiCoin memory dCoin=InlineDatabaseLib.DefiCoin({\n', '            oracleType:_OracleType,\n', '            currencySymbol:_currencySymbol,\n', '            status:_Status\n', '        });\n', '        defiCoinsFlexibleMapping[_ContractAddress]=dCoin;\n', '        // check wheather contract exists in allFlexibleContractAddressArray array\n', '        if(!contractAvailableInArray(_ContractAddress,allDefiCoinFlexibleContractAddressArray)){\n', '            allDefiCoinFlexibleContractAddressArray.push(_ContractAddress);\n', '        }\n', '    }\n', '    \n', '    function getDefiCoinsFlexibleMapping(address _betContractAddress) external view returns(InlineDatabaseLib.DefiCoin memory){\n', '        return (defiCoinsFlexibleMapping[_betContractAddress]);\n', '    }\n', '    function getDefiCoinsFlexibleContractAddressArray() external view returns(address[] memory){\n', '        return allDefiCoinFlexibleContractAddressArray;\n', '    }\n', '    function addflexibleDefiCoinArray(uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n', '        InlineDatabaseLib.FlexibleInfo memory fobject=InlineDatabaseLib.FlexibleInfo({\n', '            id:flexibleDefiCoinArray.length,\n', '            upDownPercentage:_upDownPercentage,\n', '            riskFactor:_riskFactor,\n', '            rewardFactor:_rewardFactor,\n', '            status:true\n', '        });\n', '        flexibleDefiCoinArray.push(fobject);\n', '    }\n', '    function updateflexibleDefiCoinArray(uint256 index,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n', '        flexibleDefiCoinArray[index].upDownPercentage=_upDownPercentage;\n', '        flexibleDefiCoinArray[index].riskFactor=_riskFactor;\n', '        flexibleDefiCoinArray[index].rewardFactor=_rewardFactor;\n', '        flexibleDefiCoinArray[index].status=_status;\n', '    }\n', '     function addFlexibleDefiCoinTimePeriodArray(uint256 _tdays) public onlyOwner{\n', '         bool isAvailable=false;\n', '         for(uint256 i=0;i<flexibleDefiCoinTimePeriodArray.length;i++){\n', '             if(flexibleDefiCoinTimePeriodArray[i]._days==_tdays){\n', '                 isAvailable=true;\n', '                 break;\n', '             }\n', '         }\n', '        require(!isAvailable,"Already have this data.");\n', '         InlineDatabaseLib.TimePeriod memory tobject= InlineDatabaseLib.TimePeriod({\n', '             _days:_tdays,\n', '             status:true\n', '         });\n', '        flexibleDefiCoinTimePeriodArray.push(tobject);\n', '        addDaysToDayArray(_tdays);\n', '    }\n', '    function updateFlexibleDefiCoinTimePeriodArray(uint256 index, uint256 _tdays, bool _status) public onlyOwner{\n', '        flexibleDefiCoinTimePeriodArray[index]._days=_tdays;\n', '        flexibleDefiCoinTimePeriodArray[index].status=_status;\n', '        addDaysToDayArray(_tdays);\n', '    }\n', '    \n', '    function getFlexibleDefiCoinTimePeriodArray() public view returns(InlineDatabaseLib.TimePeriod[] memory){\n', '        return flexibleDefiCoinTimePeriodArray;\n', '    }\n', '    \n', '     function addUpdateForIndexCoin(InlineDatabaseLib.IndexCoin[] memory tupleCoinArray) public onlyOwner{\n', '        // add update index fixed coin\n', '        tempArray=new address[](0);\n', '        allIndexDefiCoinContractAddressArray=tempArray;\n', '        \n', '        for(uint256 i=0;i<tupleCoinArray.length;i++){\n', '            defiCoinsIndexMapping[tupleCoinArray[i].contractAddress]=tupleCoinArray[i];\n', '            // check wheather contract exists in allFixedContractAddressArray array\n', '            if(!contractAvailableInArray(tupleCoinArray[i].contractAddress,allIndexDefiCoinContractAddressArray)){\n', '                allIndexDefiCoinContractAddressArray.push(tupleCoinArray[i].contractAddress);\n', '            }\n', '        }\n', '    }\n', '    function addflexibleIndexCoinArray(uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n', '        InlineDatabaseLib.FlexibleInfo memory fobject=InlineDatabaseLib.FlexibleInfo({\n', '            id:flexibleIndexArray.length,\n', '            upDownPercentage:_upDownPercentage,\n', '            riskFactor:_riskFactor,\n', '            rewardFactor:_rewardFactor,\n', '            status:true\n', '        });\n', '        flexibleIndexArray.push(fobject);\n', '    }\n', '    function updateflexibleIndexCoinArray(uint256 index,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n', '        flexibleIndexArray[index].upDownPercentage=_upDownPercentage;\n', '        flexibleIndexArray[index].riskFactor=_riskFactor;\n', '        flexibleIndexArray[index].rewardFactor=_rewardFactor;\n', '        flexibleIndexArray[index].status=_status;\n', '    }\n', '    \n', '    function addFlexibleIndexTimePeriodArray(uint256 _tdays) public onlyOwner{\n', '         bool isAvailable=false;\n', '         for(uint256 i=0;i<flexibleIndexTimePeriodArray.length;i++){\n', '             if(flexibleIndexTimePeriodArray[i]._days==_tdays){\n', '                 isAvailable=true;\n', '                 break;\n', '             }\n', '         }\n', '        require(!isAvailable,"Already have this data.");\n', '         InlineDatabaseLib.TimePeriod memory tobject= InlineDatabaseLib.TimePeriod({\n', '             _days:_tdays,\n', '             status:true\n', '         });\n', '        flexibleIndexTimePeriodArray.push(tobject);\n', '        addDaysToDayArray(_tdays);\n', '    }\n', '    function updateFlexibleIndexTimePeriodArray(uint256 index, uint256 _tdays, bool _status) public onlyOwner{\n', '        flexibleIndexTimePeriodArray[index]._days=_tdays;\n', '        flexibleIndexTimePeriodArray[index].status=_status;\n', '        addDaysToDayArray(_tdays);\n', '    }\n', '    function getFlexibleIndexTimePeriodArray() public view returns(InlineDatabaseLib.TimePeriod[] memory){\n', '        return flexibleIndexTimePeriodArray;\n', '    }\n', '   function addFixedDefiIndexArray(uint256 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n', '         bool isAvailable=false;\n', '         for(uint256 i=0;i<fixedDefiIndexArray.length;i++){\n', '             if(fixedDefiIndexArray[i].daysCount==_daysCount){\n', '                 isAvailable=true;\n', '                 break;\n', '             }\n', '         }\n', '        require(!isAvailable,"Already have this data.");\n', '        InlineDatabaseLib.FixedInfo memory fobject=InlineDatabaseLib.FixedInfo({\n', '            id:fixedDefiIndexArray.length,\n', '            daysCount:_daysCount,\n', '            upDownPercentage:_upDownPercentage,\n', '            riskFactor:_riskFactor,\n', '            rewardFactor:_rewardFactor,\n', '            status:true\n', '        });\n', '        fixedDefiIndexArray.push(fobject);\n', '        addDaysToDayArray(_daysCount);\n', '    }\n', '    function updateFixedDefiIndexArray(uint256 index,uint256 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n', '        fixedDefiIndexArray[index].daysCount=_daysCount;\n', '        fixedDefiIndexArray[index].upDownPercentage=_upDownPercentage;\n', '        fixedDefiIndexArray[index].riskFactor=_riskFactor;\n', '        fixedDefiIndexArray[index].rewardFactor=_rewardFactor;\n', '        fixedDefiIndexArray[index].status=_status;\n', '        addDaysToDayArray(_daysCount);\n', '    }\n', '    function contractAvailableInArray(address _ContractAddress,address[] memory _contractArray) internal pure returns(bool){\n', '        for(uint256 i=0;i<_contractArray.length;i++){\n', '            if(_ContractAddress==_contractArray[i]){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }  \n', '   \n', '    \n', '    function updateMaxStakeXIVAmount(uint256 _maxStakeXIVAmount) external onlyOwner{\n', '        maxStakeXIVAmount=_maxStakeXIVAmount;\n', '    }\n', '    function getMaxStakeXIVAmount() external view returns(uint256){\n', '        return maxStakeXIVAmount;\n', '    }\n', '    function updateMinStakeXIVAmount(uint256 _minStakeXIVAmount) external onlyOwner{\n', '        minStakeXIVAmount=_minStakeXIVAmount;\n', '    }\n', '    function getMinStakeXIVAmount() external view returns(uint256){\n', '        return minStakeXIVAmount;\n', '    }\n', '    function updateMinLPvalue(uint256 _minLPvalue) external onlyOwner{\n', '        minLPvalue=_minLPvalue;\n', '    }\n', '    function getMinLPvalue() external view returns(uint256){\n', '        return minLPvalue;\n', '    }\n', '    function updateBetFactorLP(uint256 _betFactorLP) external onlyOwner{\n', '        betFactorLP=_betFactorLP;\n', '    }\n', '    function getBetFactorLP() external view returns(uint256){\n', '        return betFactorLP;\n', '    }\n', '    \n', '    function updateTotalTransactions(uint256 _totalTransactions) external onlyMyContracts{\n', '        totalTransactions=_totalTransactions;\n', '    }\n', '    function getTotalTransactions() external view returns(uint256){\n', '        return totalTransactions;\n', '    }\n', '    \n', '    function updateXIVMainContractAddress(address _XIVMainContractAddress) external onlyOwner{\n', '        XIVMainContractAddress=_XIVMainContractAddress;\n', '    }\n', '    function updateXIVBettingFixedContractAddress(address _XIVBettingFixedContractAddress) external onlyOwner{\n', '        XIVBettingFixedContractAddress=_XIVBettingFixedContractAddress;\n', '    }\n', '    function updateXIVBettingFlexibleContractAddress(address _XIVBettingFlexibleContractAddress) external onlyOwner{\n', '        XIVBettingFlexibleContractAddress=_XIVBettingFlexibleContractAddress;\n', '    }\n', '    function updateXIVTokenContractAddress(address _XIVTokenContractAddress) external onlyOwner{\n', '        XIVTokenContractAddress=_XIVTokenContractAddress;\n', '    }\n', '    function getXIVTokenContractAddress() external view returns(address){\n', '        return XIVTokenContractAddress;\n', '    }\n', '    function updateBetBaseIndexValue(uint256 _betBaseIndexValue) external onlyMyContracts{\n', '        betBaseIndexValue=_betBaseIndexValue;\n', '    }\n', '    function getBetBaseIndexValue() external view returns(uint256){\n', '        return betBaseIndexValue;\n', '    }\n', '    function updateBetActualIndexValue(uint256 _betActualIndexValue) external onlyMyContracts{\n', '        betActualIndexValue=_betActualIndexValue;\n', '    }\n', '    function getBetActualIndexValue() external view returns(uint256){\n', '        return betActualIndexValue;\n', '    }\n', '    \n', '    // function transferETH(address payable userAddress,uint256 amount) external onlyMyContracts {\n', '    //     require(address(this).balance >= amount,"The Contract does not have enough ethers.");\n', '    //     userAddress.transfer(amount);\n', '    // }\n', '    function transferTokens(address contractAddress,address userAddress,uint256 amount) external onlyMyContracts {\n', '        Token tokenObj=Token(contractAddress);\n', '        require(tokenObj.balanceOf(address(this))>= amount, "Tokens not available");\n', '        tokenObj.transfer(userAddress, amount);\n', '    }\n', '    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external onlyMyContracts {\n', '        require(checkTokens(contractAddress,amount,fromAddress));\n', '        Token(contractAddress).transferFrom(fromAddress, toAddress, amount);\n', '    }\n', '    function checkTokens(address contractAddress,uint256 amount, address fromAddress) internal view returns(bool){\n', '         Token tokenObj = Token(contractAddress);\n', '        //check if user has balance\n', '        require(tokenObj.balanceOf(fromAddress) >= amount, "You don\'t have enough XIV balance");\n', '        //check if user has provided allowance\n', '        require(tokenObj.allowance(fromAddress,address(this)) >= amount, \n', '        "Please allow smart contract to spend on your behalf");\n', '        return true;\n', '    }\n', '    function getTokensStaked(address userAddress) external view returns(uint256){\n', '        return (tokensStaked[userAddress]);\n', '    }\n', '    function updateTokensStaked(address userAddress, uint256 amount) external onlyMyContracts{\n', '        tokensStaked[userAddress]=amount;\n', '    }\n', '    function getStakingInfoMapping(address userAddress) external view returns(InlineDatabaseLib.StakingInfo[] memory){\n', '        return (StakingInfoMapping[userAddress]);\n', '    }\n', '    function updateStakingInfoMapping(address userAddress, InlineDatabaseLib.StakingInfo memory sInfo) external onlyMyContracts{\n', '        StakingInfoMapping[userAddress].push(sInfo);\n', '    }\n', '    function getActualAmountStakedByUser(address userAddress) external view returns(uint256){\n', '        return (actualAmountStakingByUser[userAddress]);\n', '    }\n', '    function updateIsStakeMapping(address userAddress,bool isStake) external onlyMyContracts{\n', '        isStakeMapping[userAddress]=(isStake);\n', '    }\n', '    function getIsStakeMapping(address userAddress) external view returns(bool){\n', '        return (isStakeMapping[userAddress]);\n', '    }\n', '    function updateIncentiveMapping(uint256 _slotId, InlineDatabaseLib.IncentiveInfo memory iInfo) external onlyMyContracts{\n', '        incentiveMapping[_slotId].push(iInfo);\n', '    }\n', '    function getIncentiveMapping(uint256 _slotId) external view returns(InlineDatabaseLib.IncentiveInfo[] memory){\n', '        return (incentiveMapping[_slotId]);\n', '    }\n', '    \n', '    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external onlyMyContracts{\n', '        actualAmountStakingByUser[userAddress]=amount;\n', '    }\n', '    \n', '    function getLockingPeriodForLPMapping(address userAddress) external view returns(InlineDatabaseLib.LPLockedInfo memory){\n', '        return (lockingPeriodForLPMapping[userAddress]);\n', '    }\n', '    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external onlyMyContracts{\n', '        InlineDatabaseLib.LPLockedInfo memory lpLockedInfo= InlineDatabaseLib.LPLockedInfo({\n', '            lockedTimeStamp:_lockedTimeStamp,\n', '            amountLocked:_amountLocked\n', '        });\n', '        lockingPeriodForLPMapping[userAddress]=lpLockedInfo;\n', '    }\n', '    \n', '    function getTokenStakedAmount() external view returns(uint256){\n', '        return (tokenStakedAmount);\n', '    }\n', '    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external onlyMyContracts{\n', '        tokenStakedAmount=_tokenStakedAmount;\n', '    }\n', '    function getBetId() external view returns(uint256){\n', '        return betid;\n', '    }\n', '    function updateBetId(uint256 _userBetId) external onlyMyContracts{\n', '        betid=_userBetId;\n', '    }\n', '    function getInvestmentId() external view returns(uint256){\n', '        return investmentId;\n', '    }\n', '    function updateInvestmentId(uint256 _investmentId) external onlyMyContracts{\n', '        investmentId=_investmentId;\n', '    }\n', '    function getSlotExecutionId() external view returns(uint256){\n', '        return slotExecutionId;\n', '    }\n', '    function updateSlotExecutionId(uint256 _slotExecutionId) external onlyMyContracts{\n', '        slotExecutionId=_slotExecutionId;\n', '    }\n', '    function getSlotId() external view returns(uint256){\n', '        return slotId;\n', '    }\n', '    function updateSlotId(uint256 _slotId) external onlyMyContracts{\n', '        slotId=_slotId;\n', '    }\n', '    \n', '    function updateBetArray(InlineDatabaseLib.BetInfo memory bObject) external onlyMyContracts{\n', '        betArray.push(bObject);\n', '    }\n', '    function updateBetArrayIndex(InlineDatabaseLib.BetInfo memory bObject, uint256 index) external onlyMyContracts{\n', '        betArray[index]=bObject;\n', '    }\n', '    function getBetArray() external view returns(InlineDatabaseLib.BetInfo[] memory){\n', '        return betArray;\n', '    }\n', '    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256){\n', '        return findBetInArrayUsingBetIdMapping[_betid];\n', '    }\n', '    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external onlyMyContracts{\n', '        findBetInArrayUsingBetIdMapping[_betid]=value;\n', '    }\n', '    function updateUserStakedAddress(address _address) external onlyMyContracts{\n', '        userStakedAddress.push(_address);\n', '    }\n', '    function getUserStakedAddress() external view returns(address[] memory){\n', '        return userStakedAddress;\n', '    }\n', '    function updateUserStakedAddress(address[] memory _userStakedAddress) external onlyMyContracts{\n', '        userStakedAddress=_userStakedAddress;\n', '    }\n', '    function getFlexibleDefiCoinArray() external view returns(InlineDatabaseLib.FlexibleInfo[] memory){\n', '        return flexibleDefiCoinArray;\n', '    }\n', '    \n', '    function getFlexibleIndexArray() external view returns(InlineDatabaseLib.FlexibleInfo[] memory){\n', '        return flexibleIndexArray;\n', '    }\n', '    \n', '    function getFixedDefiCoinArray() external view returns(InlineDatabaseLib.FixedInfo[] memory){\n', '        return fixedDefiCoinArray;\n', '    }\n', '    \n', '    function getFixedDefiIndexArray() external view returns(InlineDatabaseLib.FixedInfo[] memory){\n', '        return fixedDefiIndexArray;\n', '    }\n', '    function getAllIndexContractAddressArray() external view returns(address[] memory){\n', '        return allIndexDefiCoinContractAddressArray;\n', '    }\n', '    function getDefiCoinIndexMapping(address _ContractAddress) external view returns(InlineDatabaseLib.IndexCoin memory){\n', '        return (defiCoinsIndexMapping[_ContractAddress]);\n', '    }\n', '    function updateBetIndexForFixedArray(uint256 _betId, InlineDatabaseLib.IndexCoin memory iCArray) external onlyMyContracts{\n', '        betIndexForFixedArray[_betId].push(iCArray);\n', '    }\n', '    function getBetIndexForFixedArray(uint256 _betId) external view returns(InlineDatabaseLib.IndexCoin[] memory){\n', '        return (betIndexForFixedArray[_betId]);\n', '    }\n', '    function updateBetIndexForFlexibleArray(uint256 _betId, InlineDatabaseLib.IndexCoin memory iCArray) external onlyMyContracts{\n', '        betIndexForFlexibleArray[_betId].push(iCArray);\n', '    }\n', '    function getBetIndexForFlexibleArray(uint256 _betId) external view returns(InlineDatabaseLib.IndexCoin[] memory){\n', '        return (betIndexForFlexibleArray[_betId]);\n', '    }\n', '    function updateBetPriceHistoryFixedMapping(uint256 _betId, InlineDatabaseLib.BetPriceHistory memory bPHObj) external onlyMyContracts{\n', '        betPriceHistoryFixedMapping[_betId]=bPHObj;\n', '    }\n', '    function getBetPriceHistoryFixedMapping(uint256 _betId) external view returns(InlineDatabaseLib.BetPriceHistory memory){\n', '        return (betPriceHistoryFixedMapping[_betId]);\n', '    }\n', '    function updateBetPriceHistoryFlexibleMapping(uint256 _betId, InlineDatabaseLib.BetPriceHistory memory bPHObj) external onlyMyContracts{\n', '        betPriceHistoryFlexibleMapping[_betId]=bPHObj;\n', '    }\n', '    function getBetPriceHistoryFlexibleMapping(uint256 _betId) external view returns(InlineDatabaseLib.BetPriceHistory memory){\n', '        return (betPriceHistoryFlexibleMapping[_betId]);\n', '    }\n', '    function addUpdatePlentyOneDayPercentage(uint256 percentage) public onlyOwner{\n', '        plentyOneDayPercentage=percentage;\n', '    }\n', '    function getPlentyOneDayPercentage() external view returns(uint256){\n', '        return (plentyOneDayPercentage);\n', '    }\n', '    \n', '    function addUpdatePlentyThreeDayPercentage(uint256 _days, uint256 percentage) public onlyOwner{\n', '        plentyThreeDayPercentage[_days]=percentage;\n', '    }\n', '    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256){\n', '        return (plentyThreeDayPercentage[_days]);\n', '    }\n', '    \n', '    function addUpdatePlentySevenDayPercentage(uint256 _days, uint256 percentage) public onlyOwner{\n', '        plentySevenDayPercentage[_days]=percentage;\n', '    }\n', '    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256){\n', '        return (plentySevenDayPercentage[_days]);\n', '    }\n', '    function updateOrcaleAddress(address oracleAddress) external onlyOwner{\n', '        oracleWrapperContractAddress=oracleAddress;\n', '    }\n', '    function getOracleWrapperContractAddress() external view returns(address){\n', '        return oracleWrapperContractAddress;\n', '    }\n', '    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory){\n', '        return betAddressesArray[userAddress];\n', '    }\n', '    function getUserBetCount(address userAddress) external view returns(uint256){\n', '        return betAddressesArray[userAddress].length;\n', '    }\n', '    function getUserBetArray(address userAddress, uint256 pageNo, uint256 pageSize) external view returns(InlineDatabaseLib.BetInfo[] memory){\n', '        uint256[] memory betIndexes=betAddressesArray[userAddress];\n', '        if(betIndexes.length>0){\n', '            uint256 startIndex=(((betIndexes.length).sub(pageNo.mul(pageSize))).sub(1));\n', '            uint256 endIndex;\n', '            uint256 pageCount=startIndex.add(1);\n', '            if(pageSize.sub(1)<startIndex){\n', '                endIndex=(startIndex.sub(pageSize.sub(1)));\n', '                pageCount=pageSize;\n', '            }\n', '            InlineDatabaseLib.BetInfo[] memory bArray=new InlineDatabaseLib.BetInfo[](pageCount);\n', '            uint256 value;\n', '            for(uint256 i=endIndex;i<=startIndex;i++){\n', '                bArray[value]=betArray[findBetInArrayUsingBetIdMapping[betIndexes[i]]];\n', '                value++;\n', '            }\n', '            return bArray;\n', '        }\n', '        return new InlineDatabaseLib.BetInfo[](0);\n', '    }\n', '    function updateBetAddressesArray(address userAddress, uint256 _betId) external onlyMyContracts{\n', '        betAddressesArray[userAddress].push(_betId);\n', '    }\n', '    function getRewardGeneratedAmount() external view returns(uint256){\n', '        return rewardGeneratedAmount;\n', '    }\n', '    function updateRewardGeneratedAmount(uint256 _rewardGeneratedAmount) external onlyMyContracts{\n', '        rewardGeneratedAmount=_rewardGeneratedAmount;\n', '    }\n', '    \n', '    function addUserAddressUsedForBetting(address userAddress) external onlyMyContracts{\n', '        userAddressUsedForBetting.push(userAddress);\n', '    }\n', '    function getUserAddressUsedForBetting() external view returns(address[] memory){\n', '        return userAddressUsedForBetting;\n', '    }\n', '    function addDaysToDayArray(uint256 _days) internal{\n', '        bool isAvailable;\n', '        for(uint256 i=0;i<daysArray.length;i++){\n', '            if(daysArray[i]==_days){\n', '                isAvailable=true;\n', '                break;\n', '            }\n', '        }\n', '        if(!isAvailable){\n', '            daysArray.push(_days);\n', '        }\n', '    }\n', '    function isDaysAvailable(uint256 _days) external view returns(bool){\n', '        for(uint256 i=0;i<daysArray.length;i++){\n', '            if(daysArray[i]==_days){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    function getDaysArray() external view returns(uint256[] memory){\n', '        return daysArray;\n', '    }\n', '    \n', '    \n', '    modifier onlyMyContracts() {\n', '        require(msg.sender == XIVMainContractAddress || msg.sender==XIVBettingFixedContractAddress || msg.sender== XIVBettingFlexibleContractAddress);\n', '        _;\n', '    }\n', '    fallback() external payable {\n', '    }\n', '}']