['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', '//SPDX-License-Identifier: Unlicense\n', 'pragma solidity ^0.8.0;\n', '\n', 'contract MerkleTwoDrop {\n', '\n', '    struct Airdrop {\n', '      bytes32 root;\n', '      mapping(address => bool) awarded;\n', '    }\n', '\n', '    /// Events\n', '    event Start(uint id);\n', '    event Award(uint id, address recipient, uint amount0, uint amount1);\n', '\n', '    /// State\n', '    mapping(uint => Airdrop) public airdrops;\n', '    ITokenManager public tokenManager0;\n', '    ITokenManager public tokenManager1;\n', '    uint public airdropsCount;\n', '    address public startAuth;\n', '\n', '    bool private initialized;\n', '\n', '    function initialize(address _tokenManager0, address _tokenManager1, address _startAuth) public {\n', '        require(!initialized, "Already initialized");\n', '        initialized = true;\n', '\n', '        require(_tokenManager0 != address(0), "Needs token0 manager");\n', '        require(_tokenManager1 != address(0), "Needs token1 manager");\n', '        require(_startAuth != address(0), "Needs startAuth");\n', '\n', '        tokenManager0 = ITokenManager(_tokenManager0);\n', '        tokenManager1 = ITokenManager(_tokenManager1);\n', '        startAuth = _startAuth;\n', '    }\n', '\n', '    /**\n', '     * @notice Start a new airdrop `_root`\n', '     * @param _root New airdrop merkle root\n', '     */\n', '    function start(bytes32 _root) public {\n', '        require(msg.sender == startAuth, "Not authorized");\n', '        _start(_root);\n', '    }\n', '\n', '    function _start(bytes32 _root) internal returns(uint id){\n', '        id = ++airdropsCount;    // start at 1\n', '        Airdrop storage newAirdrop = airdrops[id];\n', '        newAirdrop.root = _root;\n', '        emit Start(id);\n', '    }\n', '\n', '    /**\n', '     * @notice Award from airdrop\n', '     * @param _id Airdrop id\n', '     * @param _recipient Recepient of award\n', '     * @param _amount0 The token0 amount\n', '     * @param _amount1 The token1 amount\n', '     * @param _proof Merkle proof to correspond to data supplied\n', '     */\n', '    function award(uint _id, address _recipient, uint256 _amount0, uint256 _amount1, bytes32[] calldata _proof) public {\n', '        Airdrop storage airdrop = airdrops[_id];\n', '\n', '        bytes32 hash = keccak256(abi.encodePacked(_recipient, _amount0, _amount1));\n', '        require( validate(airdrop.root, _proof, hash), "Invalid proof" );\n', '\n', '        require( !airdrops[_id].awarded[_recipient], "Already awarded" );\n', '\n', '        airdrops[_id].awarded[_recipient] = true;\n', '\n', '        tokenManager0.mint(_recipient, _amount0);\n', '        tokenManager1.mint(_recipient, _amount1);\n', '\n', '        emit Award(_id, _recipient, _amount0, _amount1);\n', '    }\n', '\n', '    /**\n', '     * @notice Award from multiple airdrops to single recipient\n', '     * @param _ids Airdrop ids\n', '     * @param _recipient Recepient of award\n', '     * @param _amount0s The token0 amounts\n', '     * @param _amount1s The token1 amounts\n', '     * @param _proofs Merkle proofs\n', '     */\n', '    function awardFromMany(uint[] calldata _ids, address _recipient, uint[] calldata _amount0s, uint[] calldata _amount1s, bytes32[][] calldata _proofs) public {\n', '\n', '        uint totalAmount0;\n', '        uint totalAmount1;\n', '\n', '        for (uint i = 0; i < _ids.length; i++) {\n', '            uint id = _ids[i];\n', '\n', '            bytes32 hash = keccak256(abi.encodePacked(_recipient, _amount0s[i], _amount1s[i]));\n', '            require( validate(airdrops[id].root, _proofs[i], hash), "Invalid proof" );\n', '\n', '            require( !airdrops[id].awarded[_recipient], "Already awarded" );\n', '\n', '            airdrops[id].awarded[_recipient] = true;\n', '\n', '            totalAmount0 += _amount0s[i];\n', '            totalAmount1 += _amount1s[i];\n', '\n', '            emit Award(id, _recipient, _amount0s[i], _amount1s[i]);\n', '        }\n', '\n', '        tokenManager0.mint(_recipient, totalAmount0);\n', '        tokenManager1.mint(_recipient, totalAmount1);\n', '\n', '    }\n', '\n', '    /**\n', '     * @notice Award from airdrop to multiple recipients\n', '     * @param _id Airdrop ids\n', '     * @param _recipients Recepients of award\n', '     * @param _amount0s The karma amount\n', '     * @param _amount1s The currency amount\n', '     * @param _proofs Merkle proofs\n', '     */\n', '    function awardToMany(uint _id, address[] calldata _recipients, uint[] calldata _amount0s, uint[] calldata _amount1s, bytes32[][] calldata _proofs) public {\n', '\n', '        for (uint i = 0; i < _recipients.length; i++) {\n', '            address recipient = _recipients[i];\n', '\n', '            if( airdrops[_id].awarded[recipient] )\n', '                continue;\n', '\n', '            bytes32 hash = keccak256(abi.encodePacked(recipient, _amount0s[i], _amount1s[i]));\n', '            if( !validate(airdrops[_id].root, _proofs[i], hash) )\n', '                continue;\n', '\n', '            airdrops[_id].awarded[recipient] = true;\n', '\n', '            tokenManager0.mint(recipient, _amount0s[i]);\n', '            tokenManager1.mint(recipient, _amount1s[i]);\n', '\n', '            emit Award(_id, recipient, _amount0s[i], _amount1s[i]);\n', '        }\n', '\n', '    }\n', '\n', '    function validate(bytes32 root, bytes32[] memory proof, bytes32 hash) public pure returns (bool) {\n', '\n', '        for (uint i = 0; i < proof.length; i++) {\n', '            if (hash < proof[i]) {\n', '                hash = keccak256(abi.encodePacked(hash, proof[i]));\n', '            } else {\n', '                hash = keccak256(abi.encodePacked(proof[i], hash));\n', '            }\n', '        }\n', '\n', '        return hash == root;\n', '    }\n', '\n', '    /**\n', '     * @notice Check if address:`_recipient` awarded in airdrop:`_id`\n', '     * @param _id Airdrop id\n', '     * @param _recipient Recipient to check\n', '     */\n', '    function awarded(uint _id, address _recipient) public view returns(bool) {\n', '        return airdrops[_id].awarded[_recipient];\n', '    }\n', '}\n', '\n', 'abstract contract ITokenManager {\n', '    function mint(address _receiver, uint256 _amount) virtual external;\n', '}']