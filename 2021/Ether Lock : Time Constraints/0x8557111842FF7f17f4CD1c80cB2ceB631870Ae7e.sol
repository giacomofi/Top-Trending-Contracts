['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IERC20.sol";\n', 'import "./Ownable.sol";\n', 'import "./MerkleProof.sol";\n', '\n', '/**\n', ' * Contract which implements a merkle airdrop for a given token\n', ' * Based on an account balance snapshot stored in a merkle tree\n', ' */\n', 'contract PendingXTKRewardsSnapshot is Ownable {\n', '\n', '    IERC20 token;\n', '\n', '    bytes32 root; // merkle tree root\n', '\n', '    mapping (uint256 => uint256) _redeemed;\n', '\n', '    constructor (IERC20 _token, bytes32 _root) {\n', '        token = _token;\n', '        root = _root;\n', '    }\n', '\n', '    // Check if a given reward has already been redeemed\n', '    function redeemed(uint256 index) public view returns (uint256 redeemedBlock, uint256 redeemedMask) {\n', '        redeemedBlock = _redeemed[index / 256];\n', '        redeemedMask = (uint256(1) << uint256(index % 256));\n', '        require((redeemedBlock & redeemedMask) == 0, "Tokens have already been redeemed");\n', '    }\n', '\n', '    // Get airdrop tokens assigned to address\n', '    // Requires sending merkle proof to the function\n', '    function redeem(uint256 index, address recipient, uint256 amount, bytes32[] memory merkleProof) public {\n', '        // Make sure msg.sender is the recipient of this airdrop\n', '        require(msg.sender == recipient, "The reward recipient should be the transaction sender");\n', '\n', '        // Make sure the tokens have not already been redeemed\n', '        (uint256 redeemedBlock, uint256 redeemedMask) = redeemed(index);\n', '        _redeemed[index / 256] = redeemedBlock | redeemedMask;\n', '\n', '        // Compute the merkle leaf from index, recipient and amount\n', '        bytes32 leaf = keccak256(abi.encodePacked(index, recipient, amount));\n', '        // verify the proof is valid\n', '        require(MerkleProof.verify(merkleProof, root, leaf), "Proof is not valid");\n', '        // Redeem!\n', '        token.transfer(recipient, amount);\n', '    }\n', '\n', '    function recoverToken() external onlyOwner {\n', '        token.transfer(msg.sender, token.balanceOf(address(this)));\n', '    }\n', '}']