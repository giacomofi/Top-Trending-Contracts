['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', 'import {IERC20} from "./IERC20.sol";\n', 'import {SafeERC20} from "./SafeERC20.sol";\n', 'import {IMarginPool} from "./IMarginPool.sol";\n', 'import {IXToken} from "./IXToken.sol";\n', 'import {WadRayMath} from "./WadRayMath.sol";\n', 'import {Errors} from "./Errors.sol";\n', 'import {IncentivizedERC20} from "./IncentivizedERC20.sol";\n', 'import {SafeMath} from "./SafeMath.sol";\n', 'import {\n', '    IMarginPoolAddressesProvider\n', '} from "./IMarginPoolAddressesProvider.sol";\n', 'import {Address} from "./Address.sol";\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\n', ' * available, which can be aplied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' */\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor() internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(\n', '            localCounter == _guardCounter,\n', '            "ReentrancyGuard: reentrant call"\n', '        );\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Lever ERC20 XToken\n', ' * @dev Implementation of the interest bearing token for the Lever protocol\n', ' * @author Lever\n', ' */\n', 'contract XToken is\n', '    IncentivizedERC20,\n', '    IXToken,\n', '    ReentrancyGuard\n', '{\n', '    using WadRayMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    // address public rewardsDistribution;\n', '    IERC20 public rewardsToken;\n', '    uint256 public periodFinish = 0;\n', '    uint256 public rewardRate = 0;\n', '    uint256 public rewardsDuration = 30 days;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public rewardPerTokenStored;\n', '\n', '    mapping(address => uint256) public userRewardPerTokenPaid;\n', '    mapping(address => uint256) public rewards;\n', '\n', '    bytes public constant EIP712_REVISION = bytes("1");\n', '    bytes32 internal constant EIP712_DOMAIN =\n', '        keccak256(\n', '            "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '        );\n', '    bytes32 public constant PERMIT_TYPEHASH =\n', '        keccak256(\n', '            "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"\n', '        );\n', '\n', '    uint256 public constant UINT_MAX_VALUE = uint256(-1);\n', '    address public immutable UNDERLYING_ASSET_ADDRESS;\n', '    address public immutable RESERVE_TREASURY_ADDRESS;\n', '    IMarginPool public immutable POOL;\n', '    IMarginPoolAddressesProvider public addressesProvider;\n', '\n', '    /// @dev owner => next valid nonce to submit with permit()\n', '    mapping(address => uint256) public _nonces;\n', '\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '\n', '    /* ========== MODIFIERS ========== */\n', '\n', '    modifier updateReward(address account) {\n', '        rewardPerTokenStored = rewardPerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '        if (account != address(0)) {\n', '            rewards[account] = earned(account);\n', '            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyRewardsDistribution() {\n', '        require(\n', '            msg.sender == addressesProvider.getRewardsDistribution(),\n', '            "Caller is not RewardsDistribution contract"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyMarginPool {\n', '        require(\n', '            _msgSender() == address(POOL),\n', '            Errors.CT_CALLER_MUST_BE_MARGIN_POOL\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address _addressesProvider,\n', '        address underlyingAssetAddress,\n', '        string memory tokenName,\n', '        string memory tokenSymbol,\n', '        uint8 decimals\n', '    ) public IncentivizedERC20(tokenName, tokenSymbol, decimals) {\n', '        addressesProvider = IMarginPoolAddressesProvider(_addressesProvider);\n', '        POOL = IMarginPool(addressesProvider.getMarginPool());\n', '        UNDERLYING_ASSET_ADDRESS = underlyingAssetAddress;\n', '        RESERVE_TREASURY_ADDRESS = addressesProvider.getTreasuryAddress();\n', '        // rewardsDistribution = addressesProvider.getRewardsDistribution();\n', '        rewardsToken = IERC20(IMarginPoolAddressesProvider(_addressesProvider).getLeverToken());\n', '    }\n', '\n', '    /**\n', '     * @dev Burns xTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n', '     * - Only callable by the MarginPool, as extra state updates there need to be managed\n', '     * @param user The owner of the xTokens, getting them burned\n', '     * @param receiverOfUnderlying The address that will receive the underlying\n', '     * @param amount The amount being burned\n', '     * @param index The new liquidity index of the reserve\n', '     **/\n', '    function burn(\n', '        address user,\n', '        address receiverOfUnderlying,\n', '        uint256 amount,\n', '        uint256 index\n', '    ) external override onlyMarginPool updateReward(user) {\n', '        uint256 amountScaled = amount.rayDiv(index);\n', '        require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n', '        _burn(user, amountScaled);\n', '        if (receiverOfUnderlying != address(this)) {\n', '            IERC20(UNDERLYING_ASSET_ADDRESS).safeTransfer(\n', '                receiverOfUnderlying,\n', '                amount\n', '            );\n', '        }\n', '\n', '        emit Transfer(user, address(0), amount);\n', '        emit Burn(user, receiverOfUnderlying, amount, index);\n', '    }\n', '\n', '    /**\n', '     * @dev Mints `amount` xTokens to `user`\n', '     * - Only callable by the MarginPool, as extra state updates there need to be managed\n', '     * @param user The address receiving the minted tokens\n', '     * @param amount The amount of tokens getting minted\n', '     * @param index The new liquidity index of the reserve\n', '     * @return `true` if the the previous balance of the user was 0\n', '     */\n', '    function mint(\n', '        address user,\n', '        uint256 amount,\n', '        uint256 index\n', '    ) external override onlyMarginPool updateReward(user) returns (bool) {\n', '        uint256 previousBalance = super.balanceOf(user);\n', '\n', '        uint256 amountScaled = amount.rayDiv(index);\n', '        require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n', '        _mint(user, amountScaled);\n', '        emit Transfer(address(0), user, amount);\n', '        emit Mint(user, amount, index);\n', '\n', '        return previousBalance == 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Mints xTokens to the reserve treasury\n', '     * - Only callable by the MarginPool\n', '     * @param amount The amount of tokens getting minted\n', '     * @param index The new liquidity index of the reserve\n', '     */\n', '    function mintToTreasury(uint256 amount, uint256 index)\n', '        external\n', '        override\n', '        onlyMarginPool\n', '        updateReward(RESERVE_TREASURY_ADDRESS)\n', '    {\n', '        if (amount == 0) {\n', '            return;\n', '        }\n', '\n', "        // Compared to the normal mint, we don't check for rounding errors.\n", '        // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n', '        // In that case, the treasury will experience a (very small) loss, but it\n', '        // wont cause potentially valid transactions to fail.\n', '        _mint(RESERVE_TREASURY_ADDRESS, amount.rayDiv(index));\n', '        emit Transfer(address(0), RESERVE_TREASURY_ADDRESS, amount);\n', '        emit Mint(RESERVE_TREASURY_ADDRESS, amount, index);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers xTokens in the event of a borrow being liquidated, in case the liquidators reclaims the xToken\n', '     * - Only callable by the MarginPool\n', '     * @param from The address getting liquidated, current owner of the xTokens\n', '     * @param to The recipient\n', '     * @param value The amount of tokens getting transferred\n', '     **/\n', '    function transferOnLiquidation(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external override onlyMarginPool updateReward(from) updateReward(to) {\n', '        // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted\n', '        // so no need to emit a specific event here\n', '        _transfer(from, to, value, false);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n', '     * @param user The user whose balance is calculated\n', '     * @return The balance of the user\n', '     **/\n', '    function balanceOf(address user)\n', '        public\n', '        view\n', '        override(IncentivizedERC20, IERC20)\n', '        returns (uint256)\n', '    {\n', '        return\n', '            super.balanceOf(user).rayMul(\n', '                POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS)\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n', "     * updated stored balance divided by the reserve's liquidity index at the moment of the update\n", '     * @param user The user whose balance is calculated\n', '     * @return The scaled balance of the user\n', '     **/\n', '    function scaledBalanceOf(address user)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return super.balanceOf(user);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the scaled balance of the user and the scaled total supply.\n', '     * @param user The address of the user\n', '     * @return The scaled balance of the user\n', '     * @return The scaled balance and the scaled total supply\n', '     **/\n', '    function getScaledUserBalanceAndSupply(address user)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256, uint256)\n', '    {\n', '        return (super.balanceOf(user), super.totalSupply());\n', '    }\n', '\n', '    /**\n', '     * @dev calculates the total supply of the specific xToken\n', '     * since the balance of every single user increases over time, the total supply\n', '     * does that too.\n', '     * @return the current total supply\n', '     **/\n', '    function totalSupply()\n', '        public\n', '        view\n', '        override(IncentivizedERC20, IERC20)\n', '        returns (uint256)\n', '    {\n', '        uint256 currentSupplyScaled = super.totalSupply();\n', '\n', '        if (currentSupplyScaled == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return\n', '            currentSupplyScaled.rayMul(\n', '                POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS)\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n', '     * @return the scaled total supply\n', '     **/\n', '    function scaledTotalSupply()\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return super.totalSupply();\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the underlying asset to `target`. Used by the MarginPool to transfer\n', '     * assets in borrow(), withdraw()\n', '     * @param target The recipient of the xTokens\n', '     * @param amount The amount getting transferred\n', '     * @return The amount transferred\n', '     **/\n', '    function transferUnderlyingTo(address target, uint256 amount)\n', '        external\n', '        override\n', '        onlyMarginPool\n', '        returns (uint256)\n', '    {\n', '        IERC20(UNDERLYING_ASSET_ADDRESS).safeTransfer(target, amount);\n', '        return amount;\n', '    }\n', '\n', '    /**\n', '     * @dev implements the permit function as for\n', '     * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n', '     * @param owner The owner of the funds\n', '     * @param spender The spender\n', '     * @param value The amount\n', '     * @param deadline The deadline timestamp, type(uint256).max for max deadline\n', '     * @param v Signature param\n', '     * @param s Signature param\n', '     * @param r Signature param\n', '     */\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external {\n', '        require(owner != address(0), "INVALID_OWNER");\n', '        //solium-disable-next-line\n', '        require(block.timestamp <= deadline, "INVALID_EXPIRATION");\n', '        uint256 currentValidNonce = _nonces[owner];\n', '        bytes32 digest =\n', '            keccak256(\n', '                abi.encodePacked(\n', '                    "\\x19\\x01",\n', '                    DOMAIN_SEPARATOR,\n', '                    keccak256(\n', '                        abi.encode(\n', '                            PERMIT_TYPEHASH,\n', '                            owner,\n', '                            spender,\n', '                            value,\n', '                            currentValidNonce,\n', '                            deadline\n', '                        )\n', '                    )\n', '                )\n', '            );\n', '        require(owner == ecrecover(digest, v, r, s), "INVALID_SIGNATURE");\n', '        _nonces[owner] = currentValidNonce.add(1);\n', '        _approve(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the xTokens between two users. Validates the transfer\n', '     * (ie checks for valid HF after the transfer) if required\n', '     * @param from The source address\n', '     * @param to The destination address\n', '     * @param amount The amount getting transferred\n', '     * @param validate `true` if the transfer needs to be validated\n', '     **/\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        bool validate\n', '    ) internal updateReward(from) updateReward(to) {\n', '        uint256 index =\n', '            POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS);\n', '\n', '        uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n', '        uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n', '\n', '        super._transfer(from, to, amount.rayDiv(index));\n', '        if (validate) {\n', '            POOL.finalizeTransfer(\n', '                UNDERLYING_ASSET_ADDRESS,\n', '                from,\n', '                to,\n', '                amount,\n', '                fromBalanceBefore,\n', '                toBalanceBefore\n', '            );\n', '        }\n', '\n', '        emit BalanceTransfer(from, to, amount, index);\n', '    }\n', '\n', '    /**\n', '     * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n', '     * @param from The source address\n', '     * @param to The destination address\n', '     * @param amount The amount getting transferred\n', '     **/\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) internal override {\n', '        _transfer(from, to, amount, true);\n', '    }\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint256) {\n', '        return Math.min(block.timestamp, periodFinish);\n', '    }\n', '\n', '    function rewardPerToken() public view returns (uint256) {\n', '        if (totalSupply() == 0) {\n', '            return rewardPerTokenStored;\n', '        }\n', '        return\n', '            rewardPerTokenStored.add(\n', '                lastTimeRewardApplicable()\n', '                    .sub(lastUpdateTime)\n', '                    .mul(rewardRate)\n', '                    .mul(1e18)\n', '                    .div(totalSupply())\n', '            );\n', '    }\n', '\n', '    function earned(address account) public view returns (uint256) {\n', '        return\n', '            balanceOf(account)\n', '                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n', '                .div(1e18)\n', '                .add(rewards[account]);\n', '    }\n', '\n', '    function getRewardForDuration() external view returns (uint256) {\n', '        return rewardRate.mul(rewardsDuration);\n', '    }\n', '\n', '    function getReward() public nonReentrant updateReward(msg.sender) {\n', '        uint256 reward = rewards[msg.sender];\n', '        require(reward > 0);\n', '        rewards[msg.sender] = 0;\n', '        rewardsToken.safeTransfer(msg.sender, reward);\n', '        emit RewardPaid(msg.sender, reward);\n', '    }\n', '\n', '    /* ========== RESTRICTED FUNCTIONS ========== */\n', '\n', '    function notifyRewardAmount(uint256 reward, uint256 _rewardsDuration)\n', '        external\n', '        onlyRewardsDistribution\n', '        updateReward(address(0))\n', '    {\n', '        // Ensure the provided reward amount is not more than the balance in the contract.\n', '        // This keeps the reward rate in the right range, preventing overflows due to\n', '        // very high values of rewardRate in the earned and rewardsPerToken functions;\n', '        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n', '        uint256 balance = rewardsToken.balanceOf(address(this));\n', '        if (block.timestamp >= periodFinish) {\n', '            rewardsDuration = _rewardsDuration;\n', '            rewardRate = reward.div(rewardsDuration);\n', '            require(\n', '                rewardRate <= balance.div(rewardsDuration),\n', '                "Provided reward too high"\n', '            );\n', '            periodFinish = block.timestamp.add(rewardsDuration);\n', '        } else {\n', '            uint256 remaining = periodFinish.sub(block.timestamp);\n', '            uint256 leftover = remaining.mul(rewardRate);\n', '            rewardRate = reward.add(leftover).div(remaining);\n', '            require(\n', '                rewardRate <= balance.div(remaining),\n', '                "Provided reward too high"\n', '            );\n', '        }\n', '\n', '        lastUpdateTime = block.timestamp;\n', '        emit RewardAdded(reward, _rewardsDuration);\n', '    }\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event RewardAdded(uint256 reward, uint256 _rewardsDuration);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '}']