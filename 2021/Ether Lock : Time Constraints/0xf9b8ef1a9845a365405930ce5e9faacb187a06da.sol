['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Ownable.sol";\n', '\n', 'contract XEDStaking is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint64;\n', '    using SafeERC20 for IERC20;\n', '\n', '    bool public active;\n', '\n', '    // set with beginStaking()\n', '    uint256 public startTime;\n', '\n', '    // users will have 10 days before staking gets closed for depositing\n', '    uint256 public cutoffTime;\n', '    IERC20 internal immutable stakingToken;\n', '\n', '    // used for whitelisting users for staking by signing a message\n', '    address private bouncer;\n', '\n', '    enum poolNames {BRONZE, SILVER, GOLD}\n', '\n', '    struct pool {\n', '        uint256 maturityAPY;\n', '        uint64 daysToMaturity;\n', '        uint64 earlyWithdrawalAPY;\n', '        uint64 daysToEarlyWithdrawal;\n', '        uint256 maxPoolCapacity; // maximum of funds staked in total\n', '        uint256 rewardSupply; // reward supply available for the pool\n', '        uint256 stakingFunds; // staking rewards not withdrawn yet\n', '        uint256 userFunds; // gets decreased with withdrawals\n', "        uint256 totalDeposited; // doesn't get decreased with withdrawals\n", '    }\n', '\n', '    mapping(poolNames => pool) public pools;\n', '\n', '    struct userDeposit {\n', '        uint256 amount;\n', '        uint256 depositTime;\n', '    }\n', '\n', '    mapping(address => mapping(poolNames => userDeposit)) private userDeposits;\n', '\n', '    // Sum of the rewardSupply of all pools rounded up -> (821918 + 5753425 + 12328768) / 100\n', '    uint256 public constant TOTAL_REWARD_SUPPLY = (18904111 * 1 ether) / 100;\n', '    uint256 public constant MIN_STAKING_AMOUNT = 2000 * 1 ether;\n', '\n', '    constructor(IERC20 tokenContract) {\n', '        stakingToken = tokenContract;\n', '        bouncer = msg.sender;\n', '\n', '        pools[poolNames.BRONZE] = pool({\n', '            maturityAPY: 20,\n', '            daysToMaturity: 60,\n', '            earlyWithdrawalAPY: 8,\n', '            daysToEarlyWithdrawal: 30,\n', '            maxPoolCapacity: 250000 * 1 ether,\n', '            rewardSupply: (821918 * 1 ether) / 100, // 250000*20*60 / (100*365)\n', '            stakingFunds: 0,\n', '            userFunds: 0,\n', '            totalDeposited: 0\n', '        });\n', '\n', '        pools[poolNames.SILVER] = pool({\n', '            maturityAPY: 35,\n', '            daysToMaturity: 120,\n', '            earlyWithdrawalAPY: 14,\n', '            daysToEarlyWithdrawal: 60,\n', '            maxPoolCapacity: 500000 * 1 ether,\n', '            rewardSupply: (5753425 * 1 ether) / 100, // 500000*35*120 / (100*365)\n', '            stakingFunds: 0,\n', '            userFunds: 0,\n', '            totalDeposited: 0\n', '        });\n', '\n', '        pools[poolNames.GOLD] = pool({\n', '            maturityAPY: 50,\n', '            daysToMaturity: 180,\n', '            earlyWithdrawalAPY: 20,\n', '            daysToEarlyWithdrawal: 100,\n', '            maxPoolCapacity: 500000 * 1 ether,\n', '            rewardSupply: (12328768 * 1 ether) / 100, // 500000*50*180 / (100*365)\n', '            stakingFunds: 0,\n', '            userFunds: 0,\n', '            totalDeposited: 0\n', '        });\n', '    }\n', '\n', '    // Bouncer will be a hot wallet in our backend without any critical access (e.g: access to funds)\n', '    // If the hot wallet gets compromised, the owner can just change the bouncer without any critical issues.\n', '    function setBouncer(address _bouncer) external onlyOwner {\n', '        bouncer = _bouncer;\n', '    }\n', '\n', '    // Our backend will send to allowed users a signed message (signed by the bouncer)\n', '    // with this contract address and user address\n', '    modifier onlyAllowedUser(\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) {\n', '        require(\n', '            isAllowedUser(msg.sender, _v, _r, _s),\n', '            "User isn\'t authorized to perform this operation."\n', '        );\n', '        _;\n', '    }\n', '\n', '    // Function that checks if a given address is allowed by checking the signature\n', '    // of the message sent by the backend.\n', '    // To whitelist all addresses, the bouncer can be set to address(0).\n', '    function isAllowedUser(\n', '        address user,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) public view returns (bool) {\n', '        bytes32 hash = keccak256(abi.encodePacked(address(this), user));\n', '        return\n', '            bouncer ==\n', '            ecrecover(\n', '                keccak256(\n', '                    abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)\n', '                ),\n', '                _v,\n', '                _r,\n', '                _s\n', '            );\n', '    }\n', '\n', '    // Collect any funds that are in the contract, including those that are sent\n', '    // accidentally to it.\n', '    function collect(poolNames _pool) external onlyOwner {\n', '        require(block.timestamp > cutoffTime, "Can only collect excess reward tokens after deposits are locked");\n', '        uint256 excessRewards = getExcessRewards(_pool);\n', '        pools[_pool].stakingFunds = pools[_pool].stakingFunds.sub(excessRewards);\n', '        stakingToken.safeTransfer(owner(), excessRewards);\n', '    }\n', '\n', '    event Deposit(\n', '        poolNames indexed pool,\n', '        address indexed userAddress,\n', '        uint256 depositAmount\n', '    );\n', '\n', '    function deposit(\n', '        uint256 _depositAmount,\n', '        poolNames _pool,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) external onlyAllowedUser(_v, _r, _s) {\n', '        require(active, "Staking is not active yet");\n', '        require(block.timestamp < cutoffTime, "Deposit time period over");\n', '        require(_depositAmount >= MIN_STAKING_AMOUNT, "Deposit amount too low");\n', '\n', '        uint256 newUserFunds = pools[_pool].userFunds.add(_depositAmount);\n', '        require(\n', '            newUserFunds <= pools[_pool].maxPoolCapacity,\n', '            "Staking capacity exceeded"\n', '        );\n', '\n', '        pools[_pool].totalDeposited = pools[_pool].totalDeposited.add(\n', '            _depositAmount\n', '        );\n', '        pools[_pool].userFunds = newUserFunds;\n', '\n', '        userDeposits[msg.sender][_pool].amount = userDeposits[msg.sender][_pool]\n', '            .amount\n', '            .add(_depositAmount);\n', '        userDeposits[msg.sender][_pool].depositTime = block.timestamp;\n', '\n', '        stakingToken.safeTransferFrom(\n', '            msg.sender,\n', '            address(this),\n', '            _depositAmount\n', '        );\n', '        emit Deposit(_pool, msg.sender, _depositAmount);\n', '    }\n', '\n', '    event Withdraw(\n', '        poolNames indexed pool,\n', '        address indexed userAddress,\n', '        uint256 principal,\n', '        uint256 yield\n', '    );\n', '\n', '    // if withdrawn before early withdrawal period user gets 0% APY (only gets his/her funds back)\n', '    function withdraw(poolNames _pool) external {\n', '        uint256 withdrawalAmount = userDeposits[msg.sender][_pool].amount;\n', '        require(withdrawalAmount > 0, "nothing to withdraw");\n', '\n', '        uint256 userYield = getUserYield(msg.sender, _pool);\n', '        pools[_pool].userFunds = pools[_pool].userFunds.sub(withdrawalAmount);\n', '        pools[_pool].stakingFunds = pools[_pool].stakingFunds.sub(userYield);\n', '\n', '        delete userDeposits[msg.sender][_pool];\n', '\n', '        uint256 totalToTransfer = withdrawalAmount.add(userYield);\n', '\n', '        stakingToken.safeTransfer(msg.sender, totalToTransfer);\n', '        emit Withdraw(_pool, msg.sender, withdrawalAmount, userYield);\n', '    }\n', '\n', '    event StakingBegins(uint256 timestamp, uint256 stakingFunds);\n', '\n', '    function beginStaking() external onlyOwner {\n', '        require(\n', '            stakingToken.balanceOf(address(this)) >= TOTAL_REWARD_SUPPLY,\n', '            "Not enough staking rewards"\n', '        );\n', '        require(!active, "Can only begin staking once");\n', '        active = true;\n', '        startTime = block.timestamp;\n', '        cutoffTime = startTime.add(10 days);\n', '        pools[poolNames.BRONZE].stakingFunds = pools[poolNames.BRONZE]\n', '            .rewardSupply;\n', '        pools[poolNames.SILVER].stakingFunds = pools[poolNames.SILVER]\n', '            .rewardSupply;\n', '        pools[poolNames.GOLD].stakingFunds = pools[poolNames.GOLD].rewardSupply;\n', '        emit StakingBegins(startTime, TOTAL_REWARD_SUPPLY);\n', '    }\n', '\n', '    function getYieldMultiplier(uint256 daysStaked, poolNames _pool)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (daysStaked >= pools[_pool].daysToMaturity)\n', '            return pools[_pool].maturityAPY;\n', '        if (daysStaked >= pools[_pool].daysToEarlyWithdrawal)\n', '            return pools[_pool].earlyWithdrawalAPY;\n', '        return 0;\n', '    }\n', '\n', '    function getUserYield(address _userAddress, poolNames _pool)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 depositTime = userDeposits[_userAddress][_pool].depositTime;\n', '        uint256 amount = userDeposits[_userAddress][_pool].amount;\n', '\n', '        uint256 daysStaked = (block.timestamp - depositTime) / 1 days;\n', '\n', '        uint256 yieldMultiplier = getYieldMultiplier(daysStaked, _pool);\n', '        uint256 daysMultiplier = getNDays(daysStaked, _pool);\n', '\n', '        return (amount * yieldMultiplier * daysMultiplier) / (100 * 365);\n', '    }\n', '\n', '    function getExcessRewards(poolNames _pool)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 pendingUsersRewards = \n', '        (pools[_pool].userFunds \n', '        * pools[_pool].daysToMaturity \n', '        * pools[_pool].maturityAPY) / (100 * 365);\n', '\n', '        return pools[_pool].stakingFunds.sub(pendingUsersRewards);     \n', '    }\n', '\n', '    function getNDays(uint256 daysStaked, poolNames _pool)\n', '        public\n', '        view\n', '        returns (uint64)\n', '    {\n', '        if (daysStaked >= pools[_pool].daysToMaturity)\n', '            return pools[_pool].daysToMaturity;\n', '        if (daysStaked >= pools[_pool].daysToEarlyWithdrawal)\n', '            return pools[_pool].daysToEarlyWithdrawal;\n', '        return 0;\n', '    }\n', '\n', '    function getUserDeposit(address _userAddress, poolNames _pool)\n', '        external\n', '        view\n', '        returns (userDeposit memory)\n', '    {\n', '        return userDeposits[_userAddress][_pool];\n', '    }\n', '\n', '    function getStakingPool(poolNames _pool)\n', '        external\n', '        view\n', '        returns (pool memory)\n', '    {\n', '        return pools[_pool];\n', '    }\n', '}']