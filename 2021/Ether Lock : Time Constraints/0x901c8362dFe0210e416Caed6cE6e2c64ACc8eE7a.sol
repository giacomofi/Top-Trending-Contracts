['// SPDX-License-Identifier: P-P-P-PONZO!!!\n', 'pragma solidity ^0.7.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./IERC20.sol";\n', 'import "./IGatedERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./Address.sol";\n', 'import "./TokensRecoverable.sol";\n', '\n', 'contract FeeSplitter is TokensRecoverable\n', '{\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    using Address for address;\n', '\n', '    mapping (IGatedERC20 => address[]) public feeCollectors;\n', '    mapping (IGatedERC20 => uint256[]) public feeRates;\n', '    mapping (IGatedERC20 => uint256) public burnRates;\n', '\n', '    function setFees(IGatedERC20 token, uint256 burnRate, address[] memory collectors, uint256[] memory rates) public ownerOnly() // 100% = 10000\n', '    {\n', '        require (collectors.length == rates.length && collectors.length > 0, "Fee Collectors and Rates should be the same size and not empty");\n', '        \n', '        if (token.balanceOf(address(this)) > 0)\n', '        {\n', '            payFees(token);\n', '        }\n', '\n', '        feeCollectors[token] = collectors;\n', '        feeRates[token] = rates;\n', '        burnRates[token] = burnRate;\n', '    }\n', '\n', '    function payFees(IGatedERC20 token) public\n', '    {\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require (balance > 0, "Nothing to pay");\n', '\n', '        if (burnRates[token] > 0)\n', '        {\n', '            uint256 burnAmount = burnRates[token] * balance / 10000;\n', '            token.burn(address(this), burnAmount);\n', '        }\n', '\n', '        address[] memory collectors = feeCollectors[token];\n', '        uint256[] memory rates = feeRates[token];\n', '\n', '        for (uint256 i = 0; i < collectors.length; i++)\n', '        {\n', '            address collector = collectors[i];\n', '            uint256 rate = rates[i];\n', '\n', '            if (rate > 0)\n', '            {\n', '                uint256 feeAmount = rate * balance / 10000;\n', '                token.transfer(collector, feeAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function canRecoverTokens(IERC20 token) internal override view returns (bool) \n', '    { \n', '        address[] memory collectors = feeCollectors[IGatedERC20(address(token))];\n', '        return address(token) != address(this) && collectors.length == 0; \n', '    }\n', '}']