['// SPDX-License-Identifier: U-U-U-UPPPPP!!!\n', 'pragma solidity ^0.7.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./IERC20.sol";\n', 'import "./IGatedERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./Address.sol";\n', 'import "./TokensRecoverable.sol";\n', '\n', 'contract FeeSplitter is TokensRecoverable\n', '{\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    using Address for address;\n', '    \n', '    uint256 devRateMin = 1000;  \n', '    uint256 rootRateMin = 1000; \n', '    address public devAddress;\n', '    address public immutable deployerAddress;\n', '    address public rootFeederAddress;\n', '\n', '    mapping (IGatedERC20 => address[]) public feeCollectors;\n', '    mapping (IGatedERC20 => uint256[]) public feeRates;\n', '    mapping (IGatedERC20 => uint256) public burnRates;\n', '\n', '    constructor(address _devAddress, address _rootFeederAddress)\n', '    {\n', '        deployerAddress = msg.sender;\n', '        devAddress = _devAddress;\n', '        rootFeederAddress = _rootFeederAddress;\n', '    }\n', '\n', '    function setDevAddress(address _devAddress) public\n', '    {\n', '        require (msg.sender == deployerAddress || msg.sender == devAddress, "Not a deployer or dev address");\n', '        devAddress = _devAddress;\n', '    }\n', '\n', '    function setRootFeederAddress(address _rootFeederAddress) public ownerOnly()\n', '    {\n', '        rootFeederAddress = _rootFeederAddress;\n', '    }\n', '\n', '    function setFees(IGatedERC20 token, uint256 burnRate, address[] memory collectors, uint256[] memory rates) public ownerOnly() // 100% = 10000\n', '    {\n', '        require (collectors.length == rates.length && collectors.length > 1, "Fee Collectors and Rates must be the same size and contain at least 2 elements");\n', '        require (collectors[0] == devAddress && collectors[1] == rootFeederAddress, "First address must be dev address, second address must be rootFeeder address");\n', '        require (rates[0] >= devRateMin && rates[1] >= rootRateMin, "First rate must be greater or equal to devRateMin and second rate must be greater or equal to rootRateMin");\n', '        \n', '        uint256 totalRate = burnRate;\n', '        for (uint256 i = 0; i < rates.length; i++)\n', '        {\n', '            totalRate = totalRate + rates[i];\n', '        }\n', '\n', '        require (totalRate == 10000, "Total fee rate must be 100%");\n', '        \n', '        if (token.balanceOf(address(this)) > 0)\n', '        {\n', '            payFees(token);\n', '        }\n', '\n', '        feeCollectors[token] = collectors;\n', '        feeRates[token] = rates;\n', '        burnRates[token] = burnRate;\n', '    }\n', '\n', '    function payFees(IGatedERC20 token) public\n', '    {\n', '        uint256 balance = token.balanceOf(address(this));\n', '        require (balance > 0, "Nothing to pay");\n', '\n', '        if (burnRates[token] > 0)\n', '        {\n', '            uint256 burnAmount = burnRates[token] * balance / 10000;\n', '            token.burn(address(this), burnAmount);\n', '        }\n', '\n', '        address[] memory collectors = feeCollectors[token];\n', '        uint256[] memory rates = feeRates[token];\n', '\n', '        for (uint256 i = 0; i < collectors.length; i++)\n', '        {\n', '            address collector = collectors[i];\n', '            uint256 rate = rates[i];\n', '\n', '            if (rate > 0)\n', '            {\n', '                uint256 feeAmount = rate * balance / 10000;\n', '                token.transfer(collector, feeAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function canRecoverTokens(IERC20 token) internal override view returns (bool) \n', '    { \n', '        address[] memory collectors = feeCollectors[IGatedERC20(address(token))];\n', '        return address(token) != address(this) && collectors.length == 0; \n', '    }\n', '}']