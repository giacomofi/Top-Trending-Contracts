['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./IMigrator.sol";\n', '\n', 'import "./ERC20Mintable.sol";\n', '\n', 'import "./Ownable.sol";\n', 'import "./ERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', '\n', 'contract MasterChef is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // Info of each user.\n', '    struct UserInfo {\n', '        uint256 amount; // How many LP tokens the user has provided.\n', '        uint256 rewardDebt; // Reward debt. See explanation below.\n', '        //\n', '        // We do some fancy math here. Basically, any point in time, the amount of BASKETs\n', '        // entitled to a user but is pending to be distributed is:\n', '        //\n', '        //   pending reward = (user.amount * pool.accBasketPerShare) - user.rewardDebt\n', '        //\n', "        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n", "        //   1. The pool's `accBasketPerShare` (and `lastRewardBlock`) gets updated.\n", '        //   2. User receives the pending reward sent to his/her address.\n', "        //   3. User's `amount` gets updated.\n", "        //   4. User's `rewardDebt` gets updated.\n", '    }\n', '\n', '    // Info of each pool.\n', '    struct PoolInfo {\n', '        IERC20 lpToken; // Address of LP token contract.\n', '        uint256 allocPoint; // How many allocation points assigned to this pool. BASKETs to distribute per block.\n', '        uint256 lastRewardBlock; // Last block number that BASKETs distribution occurs.\n', '        uint256 accBasketPerShare; // Accumulated BASKETs per share, times 1e12. See below.\n', '    }\n', '\n', '    // The BASKET TOKEN!\n', '    ERC20 public basket;\n', '\n', '    // Div rate\n', '    uint256 public constant divRate = 1e18;\n', '\n', '    // Dev fund (10)%\n', '    uint256 public constant devFundRate = 0.1e18;\n', '    // Treasury rate (30)%\n', '    uint256 public constant treasuryRate = 0.3e18;\n', '    // Dev address\n', '    address public devaddr;\n', '    // Treasury address\n', '    address public treasuryaddr;\n', '    // BASKET tokens created per block.\n', '    uint256 public basketPerBlock;\n', '    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\n', '    IMigrator public migrator;\n', '\n', '    // Info of each pool.\n', '    PoolInfo[] public poolInfo;\n', '    // Info of each user that stakes LP tokens.\n', '    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n', '    // Total allocation points. Must be the sum of all allocation points in all pools.\n', '    uint256 public totalAllocPoint = 0;\n', '    // The block number when BASKET mining starts.\n', '    uint256 public startBlock;\n', '\n', '    // Events\n', '    event Recovered(address token, uint256 amount);\n', '    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '\n', '    constructor(\n', '        ERC20 _basket,\n', '        address _timelock,\n', '        address _devaddr,\n', '        address _treasuryaddr,\n', '        uint256 _basketPerBlock,\n', '        uint256 _startBlock\n', '    ) {\n', '        basket = _basket;\n', '        devaddr = _devaddr;\n', '        treasuryaddr = _treasuryaddr;\n', '        basketPerBlock = _basketPerBlock;\n', '        startBlock = _startBlock;\n', '\n', '        transferOwnership(_timelock);\n', '    }\n', '\n', '    function poolLength() external view returns (uint256) {\n', '        return poolInfo.length;\n', '    }\n', '\n', '    // Add a new lp to the pool. Can only be called by the owner.\n', '    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n', '    function add(\n', '        uint256 _allocPoint,\n', '        IERC20 _lpToken,\n', '        bool _withUpdate\n', '    ) public onlyOwner {\n', '        if (_withUpdate) {\n', '            massUpdatePools();\n', '        }\n', '        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n', '        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n', '        poolInfo.push(\n', '            PoolInfo({\n', '                lpToken: _lpToken,\n', '                allocPoint: _allocPoint,\n', '                lastRewardBlock: lastRewardBlock,\n', '                accBasketPerShare: 0\n', '            })\n', '        );\n', '    }\n', '\n', "    // Update the given pool's BASKET allocation point. Can only be called by the owner.\n", '    function set(\n', '        uint256 _pid,\n', '        uint256 _allocPoint,\n', '        bool _withUpdate\n', '    ) public onlyOwner {\n', '        if (_withUpdate) {\n', '            massUpdatePools();\n', '        }\n', '        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\n', '        poolInfo[_pid].allocPoint = _allocPoint;\n', '    }\n', '\n', '    // Return reward multiplier over the given _from to _to block.\n', '    function getMultiplier(uint256 _from, uint256 _to) public pure returns (uint256) {\n', '        return _to.sub(_from);\n', '    }\n', '\n', '    // View function to see pending BASKETs on frontend.\n', '    function pendingBasket(uint256 _pid, address _user) external view returns (uint256) {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][_user];\n', '        uint256 accBasketPerShare = pool.accBasketPerShare;\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n', '            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n', '            uint256 basketReward = multiplier.mul(basketPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n', '            accBasketPerShare = accBasketPerShare.add(basketReward.mul(1e12).div(lpSupply));\n', '        }\n', '        return user.amount.mul(accBasketPerShare).div(1e12).sub(user.rewardDebt);\n', '    }\n', '\n', '    // Update reward vairables for all pools. Be careful of gas spending!\n', '    function massUpdatePools() public {\n', '        uint256 length = poolInfo.length;\n', '        for (uint256 pid = 0; pid < length; ++pid) {\n', '            updatePool(pid);\n', '        }\n', '    }\n', '\n', '    // Update reward variables of the given pool to be up-to-date.\n', '    function updatePool(uint256 _pid) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        if (block.number <= pool.lastRewardBlock) {\n', '            return;\n', '        }\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '        if (lpSupply == 0) {\n', '            pool.lastRewardBlock = block.number;\n', '            return;\n', '        }\n', '        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n', '        uint256 basketReward = multiplier.mul(basketPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\n', '\n', '        uint256 devAlloc = basketReward.mul(devFundRate).div(divRate);\n', '        uint256 treasuryAlloc = basketReward.mul(treasuryRate).div(divRate);\n', '\n', '        uint256 basketWithoutDevAndTreasury = basketReward.sub(devAlloc).sub(treasuryAlloc);\n', '\n', '        ERC20Mintable(address(basket)).mint(devaddr, devAlloc);\n', '        ERC20Mintable(address(basket)).mint(treasuryaddr, treasuryAlloc);\n', '        ERC20Mintable(address(basket)).mint(address(this), basketWithoutDevAndTreasury);\n', '\n', '        pool.accBasketPerShare = pool.accBasketPerShare.add(basketWithoutDevAndTreasury.mul(1e12).div(lpSupply));\n', '        pool.lastRewardBlock = block.number;\n', '    }\n', '\n', '    // Deposit LP tokens to MasterChef for BASKET allocation.\n', '    function deposit(uint256 _pid, uint256 _amount) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        updatePool(_pid);\n', '        if (user.amount > 0) {\n', '            uint256 pending = user.amount.mul(pool.accBasketPerShare).div(1e12).sub(user.rewardDebt);\n', '            safeBasketTransfer(msg.sender, pending);\n', '        }\n', '        pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n', '        user.amount = user.amount.add(_amount);\n', '        user.rewardDebt = user.amount.mul(pool.accBasketPerShare).div(1e12);\n', '        emit Deposit(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    // Withdraw LP tokens from MasterChef.\n', '    function withdraw(uint256 _pid, uint256 _amount) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        require(user.amount >= _amount, "withdraw: not good");\n', '        updatePool(_pid);\n', '        uint256 pending = user.amount.mul(pool.accBasketPerShare).div(1e12).sub(user.rewardDebt);\n', '        safeBasketTransfer(msg.sender, pending);\n', '        user.amount = user.amount.sub(_amount);\n', '        user.rewardDebt = user.amount.mul(pool.accBasketPerShare).div(1e12);\n', '        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n', '        emit Withdraw(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw(uint256 _pid) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n', '        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n', '        user.amount = 0;\n', '        user.rewardDebt = 0;\n', '    }\n', '\n', '    // Safe basket transfer function, just in case if rounding error causes pool to not have enough BASKETs.\n', '    function safeBasketTransfer(address _to, uint256 _amount) internal {\n', '        uint256 basketBal = basket.balanceOf(address(this));\n', '        if (_amount > basketBal) {\n', '            basket.transfer(_to, basketBal);\n', '        } else {\n', '            basket.transfer(_to, _amount);\n', '        }\n', '    }\n', '\n', '    // **** Custom functions ****\n', '\n', '    function setDev(address _devaddr) public {\n', '        require(msg.sender == devaddr, "dev: wut?");\n', '        devaddr = _devaddr;\n', '    }\n', '\n', '    function setTreasury(address _treasury) public {\n', '        require(msg.sender == treasuryaddr, "treasury: wut?");\n', '        treasuryaddr = _treasury;\n', '    }\n', '\n', '    function setBasketPerBlock(uint256 _basketPerBlock) public onlyOwner {\n', '        require(_basketPerBlock > 0, "!basketPerBlock-0");\n', '        basketPerBlock = _basketPerBlock;\n', '    }\n', '\n', '    function setStartBlock(uint256 _startBlock) public onlyOwner {\n', '        require(block.number < startBlock, "started");\n', '        startBlock = _startBlock;\n', '    }\n', '\n', '    // **** Migrate ****\n', '\n', '    // Set the migrator contract. Can only be called by the owner.\n', '    function setMigrator(IMigrator _migrator) public onlyOwner {\n', '        migrator = _migrator;\n', '    }\n', '\n', '    // Migrate lp token to another lp contract\n', '    function migrate(uint256 _pid) public onlyOwner {\n', '        require(address(migrator) != address(0), "migrate: no migrator");\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        IERC20 lpToken = pool.lpToken;\n', '        uint256 bal = lpToken.balanceOf(address(this));\n', '        lpToken.safeApprove(address(migrator), bal);\n', '        IERC20 newLpToken = IERC20(migrator.migrate(address(lpToken)));\n', '        require(bal == newLpToken.balanceOf(address(this)), "migrate: bad");\n', '        pool.lpToken = newLpToken;\n', '    }\n', '}']