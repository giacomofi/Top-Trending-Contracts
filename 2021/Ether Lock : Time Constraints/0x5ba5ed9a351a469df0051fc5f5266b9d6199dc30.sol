['# @version 0.2.12\n', '\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', '\n', 'interface GaugeController:\n', '    def vote_user_slopes(user: address, gauge: address) -> VotedSlope: view\n', '    def last_user_vote(user: address, gauge: address) -> uint256: view\n', '    def points_weight(gauge: address, time: uint256) -> Point: view\n', '    def checkpoint_gauge(gauge: address): nonpayable\n', '\n', '\n', 'struct Point:\n', '    bias: uint256\n', '    slope: uint256\n', '\n', 'struct VotedSlope:\n', '    slope: uint256\n', '    power: uint256\n', '    end: uint256\n', '\n', '\n', 'WEEK: constant(uint256) = 86400 * 7\n', 'GAUGE_CONTROLLER: constant(address) = 0x2F50D538606Fa9EDD2B11E2446BEb18C9D5846bB\n', 'PRECISION: constant(uint256) = 10**18\n', '\n', 'gauge: public(address)\n', 'reward_token: public(address)\n', '\n', 'active_period: public(uint256)\n', 'reward_per_token: public(uint256)\n', '\n', 'last_user_claim: public(HashMap[address, uint256])\n', '\n', '\n', '@external\n', 'def __init__(_gauge: address, _reward_token: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _gauge Gauge address to incentivize\n', '    @param _reward_token Incentive token address\n', '    """\n', '    self.gauge = _gauge\n', '    self.reward_token = _reward_token\n', '    self.active_period = block.timestamp / WEEK * WEEK\n', '\n', '\n', '@internal\n', 'def _update_period() -> uint256:\n', '    period: uint256 = self.active_period\n', '    if block.timestamp >= period + WEEK:\n', '        gauge: address = self.gauge\n', '        period = block.timestamp / WEEK * WEEK\n', '        GaugeController(GAUGE_CONTROLLER).checkpoint_gauge(gauge)\n', '        slope: uint256 = GaugeController(GAUGE_CONTROLLER).points_weight(gauge, period).slope\n', '        amount: uint256 = ERC20(self.reward_token).balanceOf(self)\n', '        self.reward_per_token = amount * PRECISION / slope\n', '        self.active_period = period\n', '\n', '    return period\n', '\n', '\n', '@external\n', 'def add_reward_amount(_amount: uint256) -> bool:\n', '    """\n', '    @notice Add reward tokens to the contract\n', '    @dev Rewards are fully claimable at the beginning of the next epoch week, based\n', "         on the result of current week's gauge weight vote. Rewards that are unclaimed\n", '         by the end of the week are rolled over into the following week.\n', '    @param _amount Amount of `reward_token` to transfer\n', '    @return Success bool\n', '    """\n', '    self._update_period()\n', '    assert ERC20(self.reward_token).transferFrom(msg.sender, self, _amount)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def claim_reward(_user: address = msg.sender) -> uint256:\n', '    """\n', '    @notice Claim a reward for a gauge-weight vote\n', "    @dev Rewards are only claimable for the current epoch week, based on the user's\n", '         active gauge weight vote. The vote must have been made prior to the start\n', '         of the current week. Rewards left unclaimed in a week are lost.\n', '    @param _user User to claim for\n', '    @return Amount of reward claimed\n', '    """\n', '    period: uint256 = self._update_period()\n', '    amount: uint256 = 0\n', '    if self.last_user_claim[_user] < period:\n', '        self.last_user_claim[_user] = period\n', '        gauge: address = self.gauge\n', '        last_vote: uint256 = GaugeController(GAUGE_CONTROLLER).last_user_vote(_user, gauge)\n', '        if last_vote < period:\n', '            slope: uint256 = GaugeController(GAUGE_CONTROLLER).vote_user_slopes(_user, gauge).slope\n', '            amount = slope * self.reward_per_token / PRECISION\n', '            if amount > 0:\n', '                assert ERC20(self.reward_token).transfer(_user, amount)\n', '\n', '    return amount']