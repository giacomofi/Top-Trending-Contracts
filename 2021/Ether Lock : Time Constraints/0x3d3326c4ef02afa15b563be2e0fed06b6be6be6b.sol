['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-24\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address) external returns (uint256);\n', '\n', '    // some tokens (like USDT) are not returning bool as ERC20 standard require\n', '    function transfer(address, uint256) external;\n', '\n', '    // we will not check for return value because lots of non-erc20 complaints (like USDT)\n', '    function transferFrom(\n', '        address,\n', '        address,\n', '        uint256\n', '    ) external;\n', '\n', '    function allowance(address, address) external returns (uint256);\n', '}\n', '\n', 'contract UniqStaking {\n', '    // Info of each user in pool\n', '    struct UserInfo {\n', '        uint256 depositTime;\n', '        bool bonus;\n', '    }\n', '\n', '    // Info about staking pool\n', '    struct PoolInfo {\n', '        uint256 slots;\n', '        uint256 stakeValue;\n', '        uint256 closeTime; // last call to stake\n', '        uint256 usedSlots;\n', '        uint256 lockPeriod; // stake length\n', '        address token;\n', '        string image;\n', '        string name;\n', '    }\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    // Info of each pool.\n', '    PoolInfo[] private _poolInfo;\n', '\n', '    // Info of each user that stakes.\n', '    // [stake no][user]=UserInfo\n', '    mapping(uint256 => mapping(address => UserInfo)) private _userInfo;\n', '\n', '    // how many tokens users stake\n', '    mapping(address => uint256) private _userStake;\n', '\n', '    event Deposit(\n', '        address indexed user,\n', '        uint256 indexed pid,\n', '        uint256 amount,\n', '        uint256 timeout\n', '    );\n', '    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '\n', '    string private _baseURI;\n', '\n', '    constructor(string memory baseURI) {\n', '        _baseURI = baseURI;\n', '        owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '    @dev Return the length of pool array.\n', '    */\n', '    function getPoolCount() external view returns (uint256) {\n', '        return _poolInfo.length;\n', '    }\n', '\n', '    /**\n', '    @dev Return current number of holders in a pool\n', '     */\n', '    function getSlotsCount(uint256 _pid) external view returns (uint256) {\n', '        return _poolInfo[_pid].usedSlots;\n', '    }\n', '\n', '    function poolInfo(uint256 _pid) external view returns (PoolInfo memory) {\n', '        return _poolInfo[_pid];\n', '    }\n', '\n', '    function userInfo(uint256 _pid, address user)\n', '        external\n', '        view\n', '        returns (UserInfo memory)\n', '    {\n', '        return _userInfo[_pid][user];\n', '    }\n', '\n', '    // how long until user can withdraw from stake\n', '    function getCountdown(address user, uint256 id)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 ts = _userInfo[id][user].depositTime + _poolInfo[id].lockPeriod;\n', '        if (block.timestamp > ts) {\n', '            return 0;\n', '        } else {\n', '            return ts - block.timestamp;\n', '        }\n', '    }\n', '\n', '    // return full pool gift URL\n', '    function stakingGift(uint256 id) external view returns (string memory) {\n', '        return string(abi.encodePacked(_baseURI, _poolInfo[id].image));\n', '    }\n', '\n', '    /**\n', '    Open a new staking pool, starting now.\n', '    @param _slots: max number of stake users\n', '    @param _stake: min token required\n', '    @param _duration: lifetime of a pool in seconds\n', '    @param _lockPeriod: time to stake (in seconds)\n', '    @param _image: URL of image gift\n', '    @param _name: staking name\n', '   */\n', '    function addStakePool(\n', '        uint256 _slots,\n', '        uint256 _stake,\n', '        address _token,\n', '        uint256 _duration,\n', '        uint256 _lockPeriod,\n', '        string calldata _image,\n', '        string calldata _name\n', '    ) external onlyOwner {\n', '        _poolInfo.push(\n', '            PoolInfo({\n', '                slots: _slots,\n', '                stakeValue: _stake,\n', '                closeTime: block.timestamp + _duration,\n', '                usedSlots: 0,\n', '                lockPeriod: _lockPeriod,\n', '                token: _token,\n', '                image: _image,\n', '                name: _name\n', '            })\n', '        );\n', '    }\n', '\n', '    /**\n', "    Transfer ERC-20 token from sender's account to staking contract. \n", '   */\n', '    function deposit(uint256 _pid, uint256 _amount) external {\n', '        PoolInfo storage pool = _poolInfo[_pid];\n', '        UserInfo storage user = _userInfo[_pid][msg.sender];\n', '\n', '        // check if selected Pool restrictions are met\n', '        require(block.timestamp < pool.closeTime, "Already closed");\n', '        require(pool.usedSlots < pool.slots, "Pool is already full");\n', '        require(user.depositTime == 0, "User already in staking pool");\n', '        require(_amount == pool.stakeValue, "Needs exact stake");\n', '\n', '        user.depositTime = block.timestamp;\n', '        pool.usedSlots += 1;\n', '\n', '        // move fund and update records\n', '        IERC20(pool.token).transferFrom(\n', '            address(msg.sender),\n', '            address(this),\n', '            _amount\n', '        );\n', '\n', '        // store amount\n', '        _userStake[pool.token] += _amount;\n', '\n', '        // emit event\n', '        emit Deposit(\n', '            msg.sender,\n', '            _pid,\n', '            _amount,\n', '            pool.lockPeriod + block.timestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '    Returns full funded amount of ERC-20 token to requester if lock period is over\n', '   */\n', '    function withdraw(uint256 _pid) external {\n', '        PoolInfo storage pool = _poolInfo[_pid];\n', '        UserInfo storage user = _userInfo[_pid][msg.sender];\n', '\n', '        // check if caller is a stakeholder of the current pool\n', '        require(user.depositTime > 0, "Not stakeholder");\n', '\n', '        // check if lock period is over\n', '        require(\n', '            block.timestamp > user.depositTime + pool.lockPeriod,\n', '            "Still locked"\n', '        );\n', '\n', '        // no double withdrawal\n', '        require(user.bonus == false, "Already withdrawn");\n', '\n', '        // make user happy\n', '        user.bonus = true;\n', '\n', '        // return fund\n', '        IERC20(pool.token).transfer(address(msg.sender), pool.stakeValue);\n', '\n', '        // reduce stored amount\n', '        _userStake[pool.token] -= pool.stakeValue;\n', '\n', '        // emit proper event\n', '        emit Withdraw(msg.sender, _pid, pool.stakeValue);\n', '    }\n', '\n', '    function pastStakes(address user) external view returns (uint256[] memory) {\n', '        uint256 max = _poolInfo.length;\n', '        if (max == 0) {\n', '            return new uint256[](0);\n', '        }\n', '        // need temporary storage\n', '        // solidity disallow size changes\n', '        uint256[] memory tmp = new uint256[](max);\n', '        uint256 found;\n', '        for (uint256 i = 0; i < max; i++) {\n', '            if (_userInfo[i][user].bonus) {\n', '                tmp[found] = i;\n', '                found += 1;\n', '            }\n', '        }\n', '        // copy to output\n', '        uint256[] memory stakes = new uint256[](found);\n', '        for (uint256 i = 0; i < found; i++) {\n', '            stakes[i] = tmp[i];\n', '        }\n', '        return stakes;\n', '    }\n', '\n', '    function currentStakes(address user)\n', '        external\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        uint256 max = _poolInfo.length;\n', '        if (max == 0) {\n', '            return new uint256[](0);\n', '        }\n', '        uint256[] memory tmp = new uint256[](max);\n', '        uint256 found;\n', '        for (uint256 i = 0; i < max; i++) {\n', '            if (\n', '                _userInfo[i][user].depositTime > 0 &&\n', '                _userInfo[i][user].bonus == false\n', '            ) {\n', '                tmp[found] = i;\n', '                found += 1;\n', '            }\n', '        }\n', '        // copy to output\n', '        uint256[] memory stakes = new uint256[](found);\n', '        for (uint256 i = 0; i < found; i++) {\n', '            stakes[i] = tmp[i];\n', '        }\n', '        return stakes;\n', '    }\n', '\n', '    function acceptOwnership() external {\n', '        require(\n', '            msg.sender != address(0) && msg.sender == newOwner,\n', '            "Only NewOwner"\n', '        );\n', '        newOwner = address(0);\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Only for contract Owner");\n', '        _;\n', '    }\n', '\n', '    function changeOwner(address _newOwner) external onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    // Update baseURI for pool gifts\n', '    function updateUri(string calldata uri) external onlyOwner {\n', '        _baseURI = uri;\n', '    }\n', '\n', '    /**\n', '    @dev Function to recover accidentally send ERC20 tokens\n', '    @param _token ERC20 token address\n', '    */\n', '    function rescueERC20(address _token) external onlyOwner {\n', '        uint256 amt = IERC20(_token).balanceOf(address(this));\n', '        // leave users stake\n', '        amt -= _userStake[_token];\n', '        require(amt > 0, "Nothing to rescue");\n', '        IERC20(_token).transfer(owner, amt);\n', '    }\n', '\n', '    /**\n', '    @dev Function to recover any ETH send to contract\n', '    */\n', '    function rescueETH() external onlyOwner {\n', '        payable(owner).transfer(address(this).balance);\n', '    }\n', '}']