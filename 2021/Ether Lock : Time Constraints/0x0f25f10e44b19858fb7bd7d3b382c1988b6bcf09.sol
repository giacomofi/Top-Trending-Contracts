['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.4;\n', 'import "./ERC20Snapshot.sol";\n', '\n', '/**\n', '███╗   ██╗ █████╗ ████████╗██╗   ██╗██████╗ ███████╗    ██████╗  ██████╗ ██╗   ██╗    ██╗███╗   ██╗██╗   ██╗\n', '████╗  ██║██╔══██╗╚══██╔══╝██║   ██║██╔══██╗██╔════╝    ██╔══██╗██╔═══██╗╚██╗ ██╔╝    ██║████╗  ██║██║   ██║\n', '██╔██╗ ██║███████║   ██║   ██║   ██║██████╔╝█████╗      ██████╔╝██║   ██║ ╚████╔╝     ██║██╔██╗ ██║██║   ██║\n', '██║╚██╗██║██╔══██║   ██║   ██║   ██║██╔══██╗██╔══╝      ██╔══██╗██║   ██║  ╚██╔╝      ██║██║╚██╗██║██║   ██║\n', '██║ ╚████║██║  ██║   ██║   ╚██████╔╝██║  ██║███████╗    ██████╔╝╚██████╔╝   ██║       ██║██║ ╚████║╚██████╔╝\n', '╚═╝  ╚═══╝╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝╚══════╝    ╚═════╝  ╚═════╝    ╚═╝       ╚═╝╚═╝  ╚═══╝ ╚═════╝ \n', '\n', '* @title WOOINU Betting Contract\n', '* @author Nature Boy Inu <spaceowl.eth>\n', '*/\n', 'contract bettingInu is ERC20("WOOINU used for betting", "BINU"), ERC20Snapshot{\n', '    /**\n', '    * @dev Event emitted when a bet is created.\n', '    * @return The index, The URI, The reward, and The timestamp of when it ends\n', '    */\n', '    event betCreated(uint256 index, string metadataURI, uint256 reward, uint256 snapshotID, uint256 end);\n', '\n', '    /**\n', '    * @dev Event emmited when a bets result is given by a owner\n', '    * @return The index and The winning choice\n', '    */\n', '    event betFinalized(uint256 index, uint256 choiceAorB);\n', '\n', '    /**\n', '    * @dev Event emmited when a user bets\n', '    * @return Index of the bet, Amount betted, The user and The choice the user chose\n', '    */\n', '    event _bet(uint256 index, uint256 amount, address sender, uint256 choice);\n', '\n', '    /**\n', '    * @dev Event emmited when a user collects his reward\n', '    * @return The user, The index of the bet, Amount rewarded\n', '    */\n', '    event rewardCollected(address user, uint256 index, uint256 rewardAmount);\n', '\n', '    /**\n', '    * @dev Event emmited when a user deposit WOOINU\n', '    * @return The user, the amount deposited \n', '    */\n', '    event _deposit(address user, uint256 amount);\n', '\n', '    /**\n', '    * @dev Event emmited when a user withdraws WOOINU\n', '    * @return The user, the amount withdrawed\n', '    */\n', '    event withdrawal(address user, uint256 amount);\n', '\n', '    /**\n', '    * @dev Event emmited when a user unlocks his WOOINU\n', '    * @return The user\n', '    */\n', '    event _unlock(address user, uint256 amount);\n', '    \n', '    /**\n', '    * @dev onlyOwner modifier to check if the caller is the owner\n', '    */\n', '    modifier onlyOwner{\n', '        require(_msgSender() == _owner, "BINU: You must be the owner to do this command");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '    * @dev Modifier that check if `x` index exists by checking if the index is lower than\n', '    * the amount of bets created\n', '    * @param index: Index of the bet\n', '    */\n', '    modifier exists(uint256 index){\n', '        require(index < _bets.length, "BINU: That bet does not exist");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Struct of a bet\n', '    * @param totalReward: The total amount of $ETH to reward to user\n', '    * @param Choices: Amount of choices \n', '    * @param metadataURI: A URI for a bets metadata (name, image, etc.)\n', '    * @param end: The timestamp of when the betting period will be finished\n', '    * @param winningChoice: After its finalized, this will show who won\n', '    * @param snapshotID: Snapshot to store everyones balances for betting\n', '    */\n', '    struct bet__ {\n', '        uint256 totalReward;\n', '        uint256 choices;\n', '        uint256 end;\n', '        uint256 snapshotID;\n', '        uint256 winningChoice;\n', '        string metadataURI;\n', '    }\n', '\n', '    /**\n', '    * @dev Struct of a lock\n', '    * @param amount: Amount of coins locked\n', '    * @param endDate: The timestamp of when the coins get unlocked \n', '    */\n', '    struct _lock{\n', '        uint256 amount;\n', '        uint256 endDate;\n', '    }\n', '\n', '    /**\n', '    * @dev A struct to store a users bet, user to make sure the user has betted\n', '    * to collect his reward\n', '    * @param choice: The choice he betted\n', '    * @param amount: Amount of tokens betted\n', '    */\n', '    struct _bet_{\n', '        uint256 choice;\n', '        uint256 amount;\n', '    }\n', '\n', '    /**\n', '    * @dev \n', '    * _bets: Array of all the bets created\n', '    * _tokenContract: The contract of the ERC20\n', '    * _owner: The creator of this contract or the owner\n', '    * _lockAmount: After a user adds tokens, this defines how much those tokens will be locked for\n', '    * _locks: A mapping of User => Timestamp of when he can unlock his tokens\n', '    * bets_: A mapping of User => Bet index => _bet_ struct for choice and amount\n', '    * _totalBetted: A mapping of Bet index => Choice => Total amount betted\n', '    */\n', '    bet__[] private _bets;\n', '    IERC20 private _tokenContract;\n', '    address private _owner;\n', '    uint256 private _lockAmount;\n', '    mapping (address => _lock) private _locks;\n', '    mapping (address => mapping(uint256 => _bet_)) private bets_;\n', '    mapping (uint256 => mapping(uint256 => uint256)) private _totalBetted;\n', '\n', '    /**\n', '    * @dev Sets the token contract (ERC20), the total amount for lock and the owner\n', '    */\n', '    constructor (IERC20 __tokenContract){\n', '        _tokenContract = __tokenContract;\n', '        _lockAmount = 600;\n', '        _owner = _msgSender();\n', '    }\n', '\n', '    /**\n', '    * @return Returns the ERC20 being used\n', '    */\n', '    function tokenContract() external view returns (IERC20){\n', '        return _tokenContract;\n', '    }\n', '\n', '    /**\n', '    * @return Returns the current owner of this contract\n', '    */\n', '    function owner() external view returns (address){\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '    * @return Returns how much time tokens are locked for\n', '    */\n', '    function lockAmount() external view returns (uint256){\n', '        return _lockAmount;\n', '    }\n', '\n', '    /**\n', '    * @return Returns all the bets that have been done + ongoing bets. \n', '    * @dev Used for viewing purposes\n', '    */\n', '    function bets() external view returns (bet__[] memory){\n', '        return _bets;\n', '    }\n', '\n', '    /**\n', '    * @return Returns a bet by its index\n', '    * @param index: The index of the bet\n', '    */\n', '    function betByIndex(uint256 index) external view returns (bet__ memory){\n', '        return _bets[index];\n', '    }\n', '\n', '    /**\n', '    * @return Returns when a user can unlock his coin + the amount he has locked\n', '    * @param user: The user to check\n', '    */\n', '    function lock(address user) external view returns (_lock memory){\n', '        return _locks[user];\n', '    }\n', '\n', '    /**\n', '    * @return Returns how much a user has betted on a bet\n', '    * @param user: The user to check\n', '    * @param index: The index of the bet\n', '    */\n', '    function betOf(address user, uint256 index) external view returns (_bet_ memory){\n', '        return bets_[user][index];\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers ownership of the contract\n', '    * @param newOwner: The user to transfer ownership to\n', '    */\n', '    function transferOwnership(address newOwner) external onlyOwner{\n', '        _owner = newOwner;\n', '    }\n', '    \n', '    /**\n', "    * @dev Checks if user has enough unlocked BINU's and reverts if he doesn't\n", '    * also deletes the lock for viewing purposes if his lock expired this saves\n', '    * gas and makes it look better\n', '    * @param user: The user to check for\n', '    * @param amount: The amount needed for the user to have\n', '    */\n', '    function checkForLock(address user, uint256 amount) internal view {\n', '        uint256 amountLocked = _locks[user].amount;\n', '        if (amountLocked != 0){\n', '            unchecked{\n', '                require(balanceOf(user) - amountLocked >= amount, "BINU: You can only transfer unlocked BINU");\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Checks for lock before transfering, calls checkForLock()\n', '    * @param from: User sending the transaction\n', '    * @param to: Not used\n', '    * @param amount: The amount transfered\n', '    */\n', '    function _beforeTokenTransfer(address from, address to , uint256 amount) internal virtual override(ERC20, ERC20Snapshot) {\n', '       checkForLock(from, amount);\n', '       super._beforeTokenTransfer(from, to, amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Creates a bet for people to bet on and takes a snapshot of balances(See [email\xa0protected]) and emits betcreated\n', '    * @param metadataURI: The uri used to check for info like image, etc. used for viewing purposes\n', '    * @param choices: The amount of choices allowed to bet on\n', '    * @param end: How much seconds until the betting period ends\n', '    */\n', '    function createBet(string memory metadataURI, uint256 end, uint256 choices) payable external onlyOwner {\n', '        uint256 index = _bets.length;\n', '        uint256 snapshotID = _snapshot();\n', '        uint256 _end = block.timestamp + end;\n', '        bet__ memory __bet;\n', '        __bet.totalReward = msg.value;\n', '        __bet.metadataURI = metadataURI;\n', '        __bet.end = _end;\n', '        __bet.snapshotID = snapshotID;\n', '        __bet.choices = choices;\n', '        _bets.push(__bet);\n', '        emit betCreated(index, metadataURI, msg.value, snapshotID, _end);\n', '    }\n', '\n', '    /**\n', '    * @dev Bets on a NFT and emits _bet(), gets balance from snapshot. amount can be 0 to change the choice\n', '    * @param index: The index of the bet\n', '    * @param amount: The amount to bet on it\n', '    * @param __bet: What to bet on\n', '    */\n', '    function bet(uint256 index, uint256 amount, uint256 __bet) external exists(index){\n', '        address sender = _msgSender();\n', '        bet__ memory bet_ = _bets[index];\n', '        require(block.timestamp < bet_.end, "BINU: The betting period has ended");\n', '        require (__bet <= bet_.choices, "BINU: That is not a valid bet");\n', '        unchecked{\n', '        require(balanceOfAt(sender, bet_.snapshotID) - bets_[sender][index].amount >= amount, "BINU: You do not have enough BINU");\n', '        }\n', '        bets_[sender][index].amount += amount;\n', '        bets_[sender][index].choice = __bet;\n', '        _totalBetted[index][__bet] += amount;\n', '        emit _bet(index, amount, sender, __bet);\n', '    }\n', '\n', '    /**\n', '    * @dev Wraps the ERC20 and locks it. Emits _deposit()\n', '    * Time to lock: it calculates the average between the 2 locks, so if you add in a small amount on a big lock that small amount will have a similars\n', '    * lock as that big amount, same or very similar\n', "    * Also, checks if he hasn't already unlocked because it would cause errors if he hasn't\n", '    * @param amount: Amount of tokens to wrap\n', '    */\n', '    function deposit(uint256 amount) external {\n', '        address sender = _msgSender();\n', "        // Unlocks if it hasn't already. This would ensure that its not renewing the lock for already unlocked tokens\n", '        if (_locks[sender].endDate <= block.timestamp && _locks[sender].endDate != 0){delete _locks[sender];}\n', '        _tokenContract.transferFrom(sender, address(this), amount);\n', '        _locks[sender] = _lock(_locks[sender].amount + amount, (block.timestamp + _lockAmount));\n', '        _mint(sender, amount);\n', '        emit _deposit(sender, amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Redeems the wrapped tokens for the ERC20. Emits withdrawal()\n', '    * @param amount: Amount to redeem\n', '    */\n', '    function withdraw(uint256 amount) external {\n', '        address sender = _msgSender();\n', '        checkForLock(sender, amount);\n', '        _burn(sender, amount);\n', '        _tokenContract.transfer(sender, amount);\n', '        emit withdrawal(sender, amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Unlocks the users tokens, should cost a bit of gas, emits _unlock()\n', '    * because of the gas refund\n', '    */\n', '    function unlock() external {\n', '        address sender = _msgSender();\n', '        uint256 amount = _locks[sender].amount;\n', '        require(_locks[sender].endDate <= block.timestamp && _locks[sender].endDate != 0, "BINU: Nothing to unlock");\n', '        delete _locks[sender];\n', '        emit _unlock(sender, amount);\n', '    }\n', '    \n', '    /**\n', '    * @dev Collects the reward of winning a bet\n', '    * @param index: The index of the bet to collect rewards from\n', '    */\n', '    function collectRewards(uint256 index) external exists(index){\n', '        address sender = _msgSender();\n', '        bet__ memory bet_ = _bets[index]; \n', '        require (block.timestamp >= bet_.end, "BINU: The betting period has not ended");\n', '        require (bets_[sender][index].amount != 0, "BINU: You have not betted on that");\n', '        require (bet_.winningChoice != 0, "BINU: Please wait until the results of this bet have been published");\n', '        require (bet_.winningChoice == bets_[sender][index].choice, "BINU: You chose the wrong choice");\n', '        uint256 amountToReward = (((bet_.totalReward * 1e18) / (_totalBetted[index][bet_.winningChoice])) * bets_[sender][index].amount) / 1e18;\n', '        delete bets_[sender][index];\n', '        payable(sender).transfer(amountToReward);\n', '        emit rewardCollected(sender, index, amountToReward);\n', '    }\n', '\n', '    /**\n', '    * @dev A command that can only be used by the owner to choose the winning choice of a bet, emits betFinalized()\n', '    * @param index: The index of the bet to finalize\n', '    * @param winningChoice: The winningChoice of the bet\n', '    */\n', '    function finalizeBet(uint256 index, uint256 winningChoice) external onlyOwner exists(index){\n', '        require(_bets[index].end <= block.timestamp, "BINU: This bet has not ended yet");\n', '        require(winningChoice <= _bets[index].choices, "BINU: That is not a valid winning bet");\n', '        _bets[index].winningChoice = winningChoice;\n', '        emit betFinalized(index, winningChoice);\n', '    }\n', '\n', '    /**\n', '    * @dev A command that only the the owner can call that changes how much time\n', '    * funds are locked for\n', '    * @param newLock: The new amount of time locks will be\n', '    */\n', '    function setLockAmount(uint256 newLock) external onlyOwner {\n', '        _lockAmount = newLock;\n', '    }\n', '\n', '    /**\n', '    * @dev A command that only the owner can call that changes the ERC20 being used for this contract\n', '    * @param newContract: The new ERC20 being used\n', '    */\n', '    function setTokenContract(IERC20 newContract) external onlyOwner {\n', '        _tokenContract = newContract;\n', '    }\n', '\n', '}']