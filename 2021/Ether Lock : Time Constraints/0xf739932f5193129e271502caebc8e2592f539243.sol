['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-17\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface ERC20 {\n', '    function transferFrom(address _from, address _to, uint _value) external returns (bool);\n', '    function transfer(address _to, uint _value) external returns (bool);\n', '    function decimals() external view returns (uint);\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '}\n', '\n', 'struct MyTokenImbalanceData {\n', '    int  totalBuyUnitsImbalance;\n', '    uint lastRateUpdateBlock;\n', '}\n', '\n', '  // bps - basic rate steps. one step is 1 / 10000 of the rate.\n', 'struct StepFunction {\n', '    int[] x; // quantity for each step. Quantity of each step includes previous steps.\n', '    int[] y; // rate change per quantity step  in bps.\n', '}\n', '\n', 'struct RatesTokenData {\n', '    bool listed;  // was added to reserve\n', '    bool enabled; // whether trade is enabled\n', '\n', '    uint index;  // index in tokenList\n', '    // position in the compact data\n', '    uint arrayIndex;\n', '    uint fieldIndex;\n', '    uint baseRate;\n', '    StepFunction buyRateQtyStepFunction; // in bps. higher quantity - bigger the rate.\n', '    StepFunction sellRateQtyStepFunction;// in bps. higher the qua\n', '    \n', '    uint slippageBpsUnit;\n', '}\n', '\n', 'abstract contract  IConversionRate {\n', '    \n', '    mapping(address => RatesTokenData) public tokenData;\n', '    mapping(address => MyTokenImbalanceData) public tokenImbalanceData;\n', '    mapping(address => uint) public tokenMaxTotalImbalance;\n', '    function recordImbalance(address token,int buyAmount,uint256 rateUpdateBlock,uint256 currentBlock) virtual external;\n', '    function getRate(address token, uint256 currentBlockNumber, bool buy, uint256 qty) virtual external view returns(uint256);\n', '    function getListedTokens() virtual external view returns(address[] memory);\n', '    function getQuota(address token, bool isBuy) virtual external view returns (int quota);\n', '    function maxGasPrice() virtual external view returns (uint);\n', '    function getFeedRate(address token, bool buy) virtual public view returns (uint);\n', '    function getRateUpdateBlock(address token) virtual public view returns(uint);\n', '   \n', '}\n', '\n', '\n', 'contract KyberHelper {\n', '    \n', '    struct TokenData {\n', '        address token;\n', '        \n', '        uint256 rateUpdateBlock;\n', '\n', '        uint256 baseBuyRate;\n', '        uint256 baseSellRate;\n', '        \n', '        StepFunction buyRateQtyStepFunction;       // in bps. higher quantity - bigger the rate.\n', '        StepFunction sellRateQtyStepFunction;      // in bps. higher the qua\n', '        StepFunction buyRateImbalanceStepFunction; // in BPS. higher reserve imbalance - bigger the rate.\n', '        StepFunction sellRateImbalanceStepFunction;\n', '    }\n', '    \n', '    struct RatesCompactData {\n', '        address token;\n', '        byte buy;\n', '        byte sell;\n', '    }\n', '    \n', '    struct TokenControlInfo {\n', '        address token;\n', '        uint minimalRecordResolution;\n', '        uint maxPerBlockImbalance;\n', '        uint maxTotalImbalance;\n', '    }\n', '\n', '    struct KyberTokenImbalanceData {\n', '        int  lastBlockBuyUnitsImbalance;\n', '        uint lastBlock;\n', '        int  totalBuyUnitsImbalance;\n', '        uint lastRateUpdateBlock;\n', '    }\n', '    \n', '    //  coded by 1inch\n', '    struct TokenImbalanceData {\n', '        address token;\n', '        uint256[5] data;\n', '    }\n', '    \n', '    // coded by OneBit\n', '    struct MyImbalanceData {\n', '        address token;\n', '        int totalImbalance;\n', '    }\n', '    \n', '    struct QuotaData {\n', '        address token;\n', '        uint256 buyQuota;\n', '        uint256 sellQuota;\n', '    }\n', '    \n', '    string constant public VERSION = "MyKyberRate v0.1";\n', '    \n', '    function getMyImbalanceData(address conversionRateContract) external view returns (MyImbalanceData[] memory data) {\n', '        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\n', '        data = new MyImbalanceData[](tokens.length);\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            data[i].token = tokens[i];\n', '            uint rateUpdateBlock = IConversionRate(conversionRateContract).getRateUpdateBlock(tokens[i]);\n', '            (int totalBuyUnitsImbalance, uint lastRateUpdateBlock) = IConversionRate(conversionRateContract).tokenImbalanceData(tokens[i]);\n', '            if(lastRateUpdateBlock == rateUpdateBlock) {\n', '                data[i].totalImbalance = totalBuyUnitsImbalance;\n', '            }\n', '            else {\n', '                 data[i].totalImbalance = 0;\n', '            }\n', '        }\n', '    }\n', '    \n', '    function getQuotaData(address conversionRateContract) external view returns (QuotaData[] memory data) {\n', '        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\n', '        data = new QuotaData[](tokens.length);\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            data[i].token = tokens[i];\n', '            int buyQuota = IConversionRate(conversionRateContract).getQuota(tokens[i],true);\n', '            int sellQuota = IConversionRate(conversionRateContract).getQuota(tokens[i],false);\n', '            if(buyQuota >=0 ){\n', '                data[i].buyQuota = uint(buyQuota);\n', '            }\n', '            else {\n', '                data[i].buyQuota = 0;\n', '            }\n', '            if(sellQuota >=0 ){\n', '                data[i].sellQuota = uint(sellQuota);\n', '            }\n', '            else {\n', '                data[i].sellQuota = 0;\n', '            }\n', '            \n', '        }\n', '    }\n', '    \n', '    function getTokenControlInfo(address conversionRateContract) external view returns (TokenControlInfo[] memory data) {\n', '        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\n', '        data = new TokenControlInfo[](tokens.length);\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            uint maxTotalImbalance = IConversionRate(conversionRateContract).tokenMaxTotalImbalance(tokens[i]);\n', '            \n', '            data[i].token = tokens[i];\n', '            uint tokenResolution = getTokenResolution(tokens[i]);\n', '            data[i].minimalRecordResolution = tokenResolution; \n', '            data[i].maxPerBlockImbalance = maxTotalImbalance/tokenResolution;\n', '            data[i].maxTotalImbalance = maxTotalImbalance/tokenResolution;\n', '        }\n', '    }\n', '    \n', '    function getRatesCompactData(address conversionRateContract) external view returns (RatesCompactData[] memory data) {\n', '          address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\n', '          data = new RatesCompactData[](tokens.length);\n', '          for (uint i = 0; i < tokens.length; i++) {              \n', '              data[i].token = tokens[i];\n', '              data[i].buy = 0;\n', '              data[i].sell = 0;\n', '          }\n', '    }\n', '    \n', '    function getStepFunctionData(address conversionRateContract) external view returns (TokenData[] memory data) {\n', '        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\n', '        \n', '        data = new TokenData[](tokens.length);\n', '        \n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            address token = tokens[i];\n', '            data[i].token = tokens[i];\n', '            \n', '            data[i].rateUpdateBlock = IConversionRate(conversionRateContract).getRateUpdateBlock(tokens[i]);\n', '            \n', '            data[i].baseBuyRate = IConversionRate(conversionRateContract).getFeedRate(tokens[i], true);\n', '            data[i].baseSellRate = IConversionRate(conversionRateContract).getFeedRate(tokens[i], false);\n', '\n', '            (,,,,,, StepFunction memory buyRateQtyStepFunction, StepFunction memory sellRateQtyStepFunction,)\n', '            = IConversionRate(conversionRateContract).tokenData(token);\n', '            data[i].buyRateQtyStepFunction = buyRateQtyStepFunction;\n', '            data[i].sellRateQtyStepFunction = sellRateQtyStepFunction;\n', '        }\n', '    }\n', '    \n', '    function getTokenImbalanceData(address conversionRateContract) external view returns (TokenImbalanceData[] memory data) {\n', '        address[] memory tokens = IConversionRate(conversionRateContract).getListedTokens();\n', '        data = new TokenImbalanceData[](tokens.length);\n', '        uint currentBlockNumber = block.number;\n', '        for (uint i = 0; i < tokens.length; i++) {\n', '            data[i].token = tokens[i];\n', '            uint tokenResolution = getTokenResolution(tokens[i]);\n', '            (int totalBuyUnitsImbalance, uint lastRateUpdateBlock) = IConversionRate(conversionRateContract).tokenImbalanceData(tokens[i]);\n', '            //uint rateUpdateBlock = IConversionRate(conversionRateContract).getRateUpdateBlock(tokens[i]);\n', '            for (uint j = 0; j < 5; j++) {\n', '                //if(currentBlockNumber%5 == j && lastRateUpdateBlock == rateUpdateBlock) {\n', '                if(currentBlockNumber%5 == j) {\n', '                    totalBuyUnitsImbalance = totalBuyUnitsImbalance/int(tokenResolution);\n', '                    KyberTokenImbalanceData memory kyberTokenImbalanceData = KyberTokenImbalanceData(0,currentBlockNumber,totalBuyUnitsImbalance,lastRateUpdateBlock);\n', '                    data[i].data[j] = encodeTokenImbalanceData(kyberTokenImbalanceData);\n', '                }\n', '                else {\n', '                    data[i].data[j] = 0x1;\n', '                }\n', '                \n', '            }\n', '            \n', '        }\n', '    }\n', '    \n', '    function getTokenResolution(address token) internal view returns (uint) {\n', '        uint tokenDecimal = ERC20(token).decimals();\n', '        if (tokenDecimal > 10) {\n', '            return 10 ** (tokenDecimal-10);\n', '        }\n', '        else {\n', '            return 1;\n', '        }\n', '    }\n', '\n', '    uint constant internal POW_2_64 = 2 ** 64;\n', '    function encodeTokenImbalanceData(KyberTokenImbalanceData memory data) public pure returns(uint) {\n', '        // check for overflows\n', '        require(data.lastBlockBuyUnitsImbalance < int(POW_2_64 / 2));\n', '        require(data.lastBlockBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\n', '        require(data.lastBlock < POW_2_64);\n', '        require(data.totalBuyUnitsImbalance < int(POW_2_64 / 2));\n', '        require(data.totalBuyUnitsImbalance > int(-1 * int(POW_2_64) / 2));\n', '        require(data.lastRateUpdateBlock < POW_2_64);\n', '\n', '        // do encoding\n', '        uint result = uint(data.lastBlockBuyUnitsImbalance) & (POW_2_64 - 1);\n', '        result |= data.lastBlock * POW_2_64;\n', '        result |= (uint(data.totalBuyUnitsImbalance) & (POW_2_64 - 1)) * POW_2_64 * POW_2_64;\n', '        result |= data.lastRateUpdateBlock * POW_2_64 * POW_2_64 * POW_2_64;\n', '\n', '        return result;\n', '    }\n', '    \n', '    function decodeTokenImbalanceData(uint input) public pure returns(KyberTokenImbalanceData memory) {\n', '        KyberTokenImbalanceData memory data;\n', '\n', '        data.lastBlockBuyUnitsImbalance = int(int64(input & (POW_2_64 - 1)));\n', '        data.lastBlock = uint(uint64((input / POW_2_64) & (POW_2_64 - 1)));\n', '        data.totalBuyUnitsImbalance = int(int64((input / (POW_2_64 * POW_2_64)) & (POW_2_64 - 1)));\n', '        data.lastRateUpdateBlock = uint(uint64((input / (POW_2_64 * POW_2_64 * POW_2_64))));\n', '\n', '        return data;\n', '    }\n', '    \n', '}']