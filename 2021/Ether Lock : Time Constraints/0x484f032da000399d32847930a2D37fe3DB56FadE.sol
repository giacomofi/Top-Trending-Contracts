['// SPDX-License-Identifier: UNLICENCED\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'pragma abicoder v2;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./XIVInterface.sol";\n', '\n', 'contract XIVBettingFixed is Ownable{\n', '    \n', '    using SafeMath for uint256;\n', '    uint256 constant secondsInADay=24 hours;\n', '    \n', '    uint256 stakeOffset;\n', '    bool isValued=false;\n', '    address public databaseContractAddress=0x18464e4584759A50CE9FC58eA5997F8B0D1EA1d8;\n', '    \n', '    \n', '     function betFixed(uint256 amountOfXIV, uint16 typeOfBet, address _betContractAddress, uint256 betSlabeIndex) external{\n', '        // 0-> defi Fixed, 1->defi flexible, 2-> index Fixed and 3-> index flexible 4-> flash fixed 5-> flash flexible\n', '        require(typeOfBet==0 || typeOfBet==2 || typeOfBet==4,"Invalid bet Type");\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        require(!dContract.getExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress),"you can\'t place bet using these values.");\n', '        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\n', '        require((dContract.getBetFactorLP()).mul(dContract.getTokenStakedAmount())>=\n', '                        ((tokenObj.balanceOf(databaseContractAddress)).sub(dContract.getTokenStakedAmount())).add(amountOfXIV),\n', '                        "Staking Vaults Have EXCEEDED CAPACITY. Please Check Back in 24hrs?");\n', '        require(amountOfXIV>=dContract.getMinStakeXIVAmount() && amountOfXIV<=dContract.getMaxStakeXIVAmount(),"Please enter amount in the specified range");\n', '                   \n', '        if(typeOfBet==0 || typeOfBet==4){\n', '            bool isFlashVault=(typeOfBet==4?true:false);\n', '            require(dContract.isDaysAvailable(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount),"Day does not exists.");\n', '            require(dContract.getFixedDefiCoinArray().length>betSlabeIndex,"Day does not exists.");\n', '            require(checkTimeForBet(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount),"Staking time closed for the selected day");\n', '            require(dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).status,"The currency is currently disabled.");\n', '           \n', '            // defi fixed\n', '            OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n', '            XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\n', '                id:dContract.getBetId(),\n', '                principalAmount:amountOfXIV,\n', '                amount:amountOfXIV,\n', '                userAddress:msg.sender,\n', '                contractAddress:_betContractAddress,\n', '                betType:typeOfBet,\n', '                currentPrice:uint256(oWObject.getPrice(dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).currencySymbol, dContract.getDefiCoinsFixedMapping(_betContractAddress,isFlashVault).oracleType)),\n', '                betTimePeriod:(dContract.getFixedDefiCoinArray()[betSlabeIndex].daysCount).mul(1 days),\n', '                checkpointPercent:dContract.getFixedDefiCoinArray()[betSlabeIndex].upDownPercentage,\n', '                rewardFactor:dContract.getFixedDefiCoinArray()[betSlabeIndex].rewardFactor,\n', '                riskFactor:dContract.getFixedDefiCoinArray()[betSlabeIndex].riskFactor,\n', '                timestamp:block.timestamp,\n', '                adminCommissionFee:0,\n', '                status:0\n', '            });\n', '            dContract.updateBetArray(binfo);\n', '            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\n', '            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\n', '                dContract.addUserAddressUsedForBetting(msg.sender);\n', '            }\n', '            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\n', '            dContract.updateBetId(dContract.getBetId().add(1));\n', '            uint256 betEndTime=(((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(binfo.betTimePeriod).sub(1));\n', '            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\n', '        }else if(typeOfBet==2){\n', '            //index Fixed \n', '            require(dContract.isDaysAvailable(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount),"Day does not exists.");\n', '            require(dContract.getFixedDefiIndexArray().length>betSlabeIndex,"Day does not exists.");\n', '            require(checkTimeForBet(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount),"Staking time closed for the selected day");\n', '            \n', '             XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\n', '                id:dContract.getBetId(),\n', '                principalAmount:amountOfXIV,\n', '                amount:amountOfXIV,\n', '                userAddress:msg.sender,\n', '                contractAddress:address(0),\n', '                betType:typeOfBet,\n', '                currentPrice:uint256(calculateIndexValueForFixedInternal(dContract.getBetId())),\n', '                betTimePeriod:(dContract.getFixedDefiIndexArray()[betSlabeIndex].daysCount).mul(1 days),\n', '                checkpointPercent:dContract.getFixedDefiIndexArray()[betSlabeIndex].upDownPercentage,\n', '                rewardFactor:dContract.getFixedDefiIndexArray()[betSlabeIndex].rewardFactor,\n', '                riskFactor:dContract.getFixedDefiIndexArray()[betSlabeIndex].riskFactor,\n', '                timestamp:block.timestamp,\n', '                adminCommissionFee:0,\n', '                status:0\n', '            });\n', '            dContract.updateBetArray(binfo);\n', '            dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\n', '            if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\n', '                dContract.addUserAddressUsedForBetting(msg.sender);\n', '            }\n', '            dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\n', '            dContract.updateBetId(dContract.getBetId().add(1));\n', '            uint256 betEndTime=(((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(binfo.betTimePeriod).sub(1));\n', '            dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\n', '        }\n', '        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amountOfXIV);\n', '        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amountOfXIV));\n', '        dContract.updateExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress,true);\n', '    }\n', '    function checkTimeForBet(uint256 _days) public view returns(bool){\n', '        uint256 currentTime=block.timestamp;\n', '        uint256 utcNoon=((block.timestamp.div(secondsInADay)).mul(secondsInADay)).add(secondsInADay.div(2));\n', '        if(_days==1){\n', '            if(((utcNoon).add(4 hours))>currentTime && utcNoon<currentTime){\n', '                return true;\n', '            }else{\n', '                return false;\n', '            }\n', '        }else if(_days==3){\n', '            if(((utcNoon).add(12 hours))>currentTime && utcNoon<currentTime){\n', '                return true;\n', '            }else{\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function calculateIndexValueForFixedInternal(uint256 _betId) internal returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap;\n', '        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray().length;i++){\n', '            Token tObj=Token(dContract.getAllIndexContractAddressArray()[i]);\n', '            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getAllIndexContractAddressArray()[i]);\n', '            if(iCObj.status){\n', '                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n', '                dContract.updateBetIndexForFixedArray(_betId,iCObj);\n', '            }\n', '        }\n', '        XIVDatabaseLib.BetPriceHistory memory bPHObj=XIVDatabaseLib.BetPriceHistory({\n', '            baseIndexValue:dContract.getBetBaseIndexValue()==0?10**11:dContract.getBetBaseIndexValue(),\n', '            actualIndexValue:totalMarketcap\n', '        });\n', '        dContract.updateBetPriceHistoryFixedMapping(_betId,bPHObj);\n', '        if(dContract.getBetBaseIndexValue()==0){\n', '            dContract.updateBetBaseIndexValue(10**11);\n', '        }else{\n', '            if(totalMarketcap>dContract.getBetActualIndexValue()){\n', '                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().add((\n', '                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue()))\n', '                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\n', '            }else if(totalMarketcap<dContract.getBetActualIndexValue()){\n', '                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue().sub((\n', '                                                     (dContract.getBetActualIndexValue().sub(totalMarketcap))\n', '                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue())));\n', '            }\n', '        }\n', '        dContract.updateBetActualIndexValue(totalMarketcap);\n', '        return totalMarketcap;\n', '    }\n', '    function updateStatus(uint256[] memory offerIds/**uint256 pageNo, uint256 pageSize**/) external {\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n', '        if(!isValued){\n', '            stakeOffset=stakeOffset.add(dContract.getTokenStakedAmount());\n', '            isValued=true;\n', '        }\n', '           for(uint256 i=0;i<offerIds.length;i++){ \n', '            XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[offerIds[i]];\n', '            if(bObject.status==0){\n', '                uint256 sevenDaysTime=(((((bObject.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(bObject.betTimePeriod).sub(1));\n', '                if(block.timestamp>=sevenDaysTime){\n', '                     if(bObject.betType==0 || bObject.betType==1 || bObject.betType==4 || bObject.betType==5){\n', '                        // defi fixed\n', '                        string memory tempSymbol;\n', '                        uint256 tempOracle;\n', '                        if(bObject.betType==0 || bObject.betType==4 || bObject.betType==5){\n', '                            bool isFlashVault=((bObject.betType==4 || bObject.betType==5)?true:false);\n', '                            tempSymbol=dContract.getDefiCoinsFixedMapping(bObject.contractAddress,isFlashVault).currencySymbol;\n', '                            tempOracle=dContract.getDefiCoinsFixedMapping(bObject.contractAddress,isFlashVault).oracleType;\n', '                        }else if(bObject.betType==1){\n', '                            tempSymbol=dContract.getDefiCoinsFlexibleMapping(bObject.contractAddress).currencySymbol;\n', '                            tempOracle=dContract.getDefiCoinsFlexibleMapping(bObject.contractAddress).oracleType;\n', '                        }\n', '                        uint256 currentprice=uint256(oWObject.getPrice(tempSymbol, tempOracle));\n', '                       \n', '                        if(currentprice<bObject.currentPrice){\n', '                            uint16 percentageValue=uint16(((bObject.currentPrice.sub(currentprice)).mul(10**4))\n', '                                                    .div(bObject.currentPrice));\n', '                            if(percentageValue>=bObject.checkpointPercent){\n', '                                updateXIVForStakers(offerIds[i], true);\n', '                            }else{\n', '                                updateXIVForStakers(offerIds[i], false);\n', '                            }\n', '                        }else{\n', '                            updateXIVForStakers(offerIds[i], false);\n', '                        }\n', '                    }else if(bObject.betType==2){\n', '                        //index Fixed \n', '                       updateXIVForStakersIndexFixed(offerIds[i]);\n', '                        \n', '                    }else if(bObject.betType==3){\n', '                        //index flexible\n', '                       updateXIVForStakersIndexFlexible(offerIds[i]);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '    function getUserStakedAddressCount() public view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        return dContract.getUserStakedAddress().length;\n', '    }\n', '    \n', '    function incentiveStakers(uint256 pageNo, uint256 pageSize) external{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 pageStart=pageNo.mul(pageSize);\n', '        uint256 pageSizeValue=(pageSize.mul(pageNo.add(1)));\n', '        if(getUserStakedAddressCount()<pageSizeValue){\n', '            pageSizeValue=getUserStakedAddressCount();\n', '        }\n', '        for(uint256 i=pageStart;i<pageSizeValue;i++){\n', '            address userAddress=dContract.getUserStakedAddress()[i];\n', '            uint256 updatedAmount;\n', '            if(stakeOffset>0){\n', '                updatedAmount=(((dContract.getTokensStaked(userAddress).mul(10**4).mul(stakeOffset))\n', '                                    .div(dContract.getTokenStakedAmount().mul(10**4))));\n', '            }else{\n', '                updatedAmount=dContract.getTokensStaked(userAddress);\n', '            }\n', '            \n', '            dContract.updateTokensStaked(userAddress,updatedAmount);\n', '        }\n', '        if(getUserStakedAddressCount()<pageSizeValue || getUserStakedAddressCount()==pageSizeValue){\n', '            if(stakeOffset>0){\n', '                dContract.updateTokenStakedAmount(stakeOffset);\n', '            }else{\n', '                dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount());\n', '            }\n', '            stakeOffset=0;\n', '            isValued=false;\n', '        }\n', '    }\n', '    function updateXIVForStakers(uint256 index, bool isWon) internal{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        if(isWon){\n', '            bObject.status=1;\n', '            uint256 rewardAmount=(uint256(bObject.rewardFactor).mul(bObject.amount)).div(10**4);\n', '            dContract.updateRewardGeneratedAmount(dContract.getRewardGeneratedAmount().add(rewardAmount));\n', '            stakeOffset=stakeOffset.sub(rewardAmount);\n', '            bObject.amount=bObject.amount.add(rewardAmount);\n', '            dContract.updateBetArrayIndex(bObject,index);\n', '        }else{\n', '            bObject.status=2;\n', '            uint256 riskAmount=(uint256(bObject.riskFactor).mul(bObject.amount)).div(10**4);\n', '            stakeOffset=stakeOffset.add(riskAmount);\n', '            bObject.amount=bObject.amount.sub(riskAmount);\n', '            dContract.updateBetArrayIndex(bObject,index);\n', '        }\n', '        dContract.updateExistingBetCheckMapping(bObject.userAddress,bObject.betType,bObject.contractAddress,false);\n', '    }\n', '    \n', '    function getCalculateIndexValueForFixed(uint256 index) public view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap;\n', '        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        for(uint256 i=0;i<dContract.getBetIndexForFixedArray(bObject.id).length;i++){\n', '            Token tObj=Token(dContract.getBetIndexForFixedArray(bObject.id)[i].contractAddress);\n', '            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getBetIndexForFixedArray(bObject.id)[i].contractAddress);\n', '            if(iCObj.status){\n', '                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n', '            }\n', '        }\n', '        return totalMarketcap;\n', '    }\n', '    \n', '    function updateXIVForStakersIndexFixed(uint256 index) internal{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap=getCalculateIndexValueForFixed(index);\n', '        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        if(dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue>totalMarketcap){\n', '             uint16 percentageValue=uint16(((dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue\n', '                                                .sub(totalMarketcap)\n', '                                                .mul(10**4)).div(dContract.getBetPriceHistoryFixedMapping(bObject.id).actualIndexValue)));\n', '            if(percentageValue>=bObject.checkpointPercent){\n', '                updateXIVForStakers(index, true);\n', '            }else{\n', '                updateXIVForStakers(index, false);\n', '            }\n', '        }else{\n', '            updateXIVForStakers(index, false);\n', '        }\n', '    }\n', '    function getCalculateIndexValueForFlexible(uint256 index) public view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap;\n', '        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        for(uint256 i=0;i<dContract.getBetIndexForFlexibleArray(bObject.id).length;i++){\n', '            Token tObj=Token(dContract.getBetIndexForFlexibleArray(bObject.id)[i].contractAddress);\n', '            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getDefiCoinIndexMapping(dContract.getBetIndexForFlexibleArray(bObject.id)[i].contractAddress);\n', '            if(iCObj.status){\n', '                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n', '            }\n', '        }\n', '        return totalMarketcap;\n', '    }\n', '    function marketCapValue(XIVDatabaseLib.IndexCoin memory iCObj,Token tObj) internal view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n', '         if((keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked("ETH"))) || (keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked("BTC")))){\n', '            return ((((oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n', '                                    /*    .mul(iCObj.contributionPercentage)*/)\n', '                                        .div(10**2)));\n', '        }else{\n', '            return (((tObj.totalSupply().mul(oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n', '                                /*.mul(iCObj.contributionPercentage)*/)\n', '                                .div((10**tObj.decimals()).mul(10**2))));\n', '        }\n', '    }\n', '    function updateXIVForStakersIndexFlexible(uint256 index) internal{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap=getCalculateIndexValueForFlexible(index);\n', '        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        if(dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue>totalMarketcap){\n', '             uint16 percentageValue=uint16(((dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue.sub(totalMarketcap)\n', '                                                     .mul(10**4)).div(dContract.getBetPriceHistoryFlexibleMapping(bObject.id).actualIndexValue)));\n', '            if(percentageValue>=bObject.checkpointPercent){\n', '                updateXIVForStakers(index, true);\n', '            }else{\n', '                updateXIVForStakers(index, false);\n', '            }\n', '        }else{\n', '            updateXIVForStakers(index, false);\n', '        }\n', '    }\n', '    \n', '    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\n', '        databaseContractAddress=_databaseContractAddress;\n', '    }\n', '}']