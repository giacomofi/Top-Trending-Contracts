['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'pragma abicoder v2;\n', '\n', 'import "./ReentrancyGuard.sol";\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./InlineInterface.sol";\n', '\n', 'contract InlineBettingFixed is Ownable,ReentrancyGuard{\n', '    \n', '    using SafeMath for uint256;\n', '    uint256 constant secondsInADay=24 hours;\n', '    \n', '    uint256 public stakeOffset;\n', '    bool isValued=false;\n', '    address public databaseContractAddress=0x96A0F13597D7DAB5952Cdcf8C8Ca09eAc97a0a75;\n', '    \n', '    \n', '     function betFixed(uint256 amountOfXIV, uint16 typeOfBet, address _betContractAddress, uint256 betSlabeIndex) external nonReentrant{\n', '        /* 0-> defi fixed, 1-> defi flexible, 2-> defi index fixed, 3-> defi index flexible, \n', '        * 4-> chain coin fixed, 5-> chain coin flexible, 6-> chain index fixed, 7-> chain index flexible\n', '        * 8-> NFT fixed, 9-> NFT flexible, 10-> NFT index fixed, 11-> NFT index flexible\n', '        */\n', '        require(typeOfBet==0 || typeOfBet==2 || typeOfBet==4 || typeOfBet==6 || typeOfBet==8 || typeOfBet==10,"Invalid bet Type");\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        require(!dContract.getExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress),"you can\'t place bet using these values.");\n', '        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\n', '        require((dContract.getBetFactorLP()).mul(dContract.getTokenStakedAmount())>=\n', '                        ((tokenObj.balanceOf(databaseContractAddress)).sub(dContract.getTokenStakedAmount())).add(amountOfXIV),\n', '                        "Staking Vaults Have EXCEEDED CAPACITY. Please Check Back in 24hrs?");\n', '        require(amountOfXIV>=dContract.getMinStakeXIVAmount() && amountOfXIV<=dContract.getMaxStakeXIVAmount(),"Please enter amount in the specified range");\n', '        uint256 _currentPrice;   \n', '        InlineDatabaseLib.FixedInfo memory fixInfo;\n', '        uint256 _coinType;\n', '        if(typeOfBet==0 || typeOfBet==2){\n', '            _coinType=1;\n', '        }else if(typeOfBet==4 || typeOfBet==6){\n', '            _coinType=2;\n', '        }else if(typeOfBet==8 || typeOfBet==10){\n', '            _coinType=3;\n', '        }\n', '        if(typeOfBet==0 || typeOfBet==4 || typeOfBet==8){\n', '            require(dContract.getFixedDefiCoinArray().length>betSlabeIndex,"Day does not exists.");\n', '            require(dContract.getFixedMapping(_betContractAddress,_coinType).status,"The currency is currently disabled.");\n', '            OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n', '           _currentPrice=uint256(oWObject.getPrice(dContract.getFixedMapping(_betContractAddress,_coinType).currencySymbol, dContract.getFixedMapping(_betContractAddress,_coinType).oracleType));\n', '            fixInfo=dContract.getFixedDefiCoinArray()[betSlabeIndex];\n', '        }else{\n', '            //index Fixed \n', '            require(dContract.getFixedDefiIndexArray().length>betSlabeIndex,"Day does not exists.");\n', '            _currentPrice=uint256(calculateIndexValueForFixedInternal(dContract.getBetId(),_coinType));\n', '            fixInfo=dContract.getFixedDefiIndexArray()[betSlabeIndex];\n', '        }\n', '        require(checkTimeForBet(fixInfo.daysCount),"Staking time closed for the selected day");\n', '        \n', '         InlineDatabaseLib.BetInfo memory binfo=InlineDatabaseLib.BetInfo({\n', '                id:uint128(dContract.getBetId()),\n', '                principalAmount:amountOfXIV,\n', '                amount:amountOfXIV,\n', '                userAddress:msg.sender,\n', '                contractAddress:typeOfBet==2?address(0):_betContractAddress,\n', '                betType:typeOfBet,\n', '                currentPrice:_currentPrice,\n', '                betTimePeriod:(uint256(fixInfo.daysCount)).mul(1 days),\n', '                checkpointPercent:fixInfo.upDownPercentage,\n', '                rewardFactor:fixInfo.rewardFactor,\n', '                riskFactor:fixInfo.riskFactor,\n', '                timestamp:block.timestamp,\n', '                coinType:_coinType,\n', '                status:0\n', '            });\n', '            dContract.updateBetArray(binfo);\n', '        dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\n', '        if(dContract.getBetsAccordingToUserAddress(msg.sender).length==0){\n', '            dContract.addUserAddressUsedForBetting(msg.sender);\n', '        }\n', '        dContract.updateBetAddressesArray(msg.sender,dContract.getBetId());\n', '        dContract.updateBetId(dContract.getBetId().add(1));\n', '        uint256 betEndTime=(((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(binfo.betTimePeriod).sub(1));\n', '        dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\n', '        \n', '        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),msg.sender,databaseContractAddress,amountOfXIV);\n', '        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(amountOfXIV));\n', '        dContract.updateExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress,true);\n', '    }\n', '    function checkTimeForBet(uint256 _days) public view returns(bool){\n', '        uint256 currentTime=block.timestamp;\n', '        uint256 utcNoon=((currentTime.div(secondsInADay)).mul(secondsInADay)).add(secondsInADay.div(2));\n', '        if(_days==1){\n', '            if(((utcNoon).add(4 hours))>currentTime && utcNoon<currentTime){\n', '                return true;\n', '            }else{\n', '                return false;\n', '            }\n', '        }else if(_days==3){\n', '            if(((utcNoon).add(12 hours))>currentTime && utcNoon<currentTime){\n', '                return true;\n', '            }else{\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '    function calculateIndexValueForFixedInternal(uint256 _betId,uint256 coinType) internal returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap;\n', '        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray(coinType).length;i++){\n', '            Token tObj=Token(dContract.getAllIndexContractAddressArray(coinType)[i]);\n', '            InlineDatabaseLib.IndexCoin memory iCObj=dContract.getIndexMapping(dContract.getAllIndexContractAddressArray(coinType)[i],coinType);\n', '            if(iCObj.status){\n', '                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n', '                dContract.updateBetIndexArray(_betId,iCObj);\n', '            }\n', '        }\n', '        InlineDatabaseLib.BetPriceHistory memory bPHObj=InlineDatabaseLib.BetPriceHistory({\n', '            baseIndexValue:uint128(dContract.getBetBaseIndexValue(coinType)==0?10**11:dContract.getBetBaseIndexValue(coinType)),\n', '            actualIndexValue:uint128(totalMarketcap)\n', '        });\n', '        dContract.updateBetPriceHistoryMapping(_betId,bPHObj);\n', '        if(dContract.getBetBaseIndexValue(coinType)==0){\n', '            dContract.updateBetBaseIndexValue(10**11,coinType);\n', '        }else{\n', '            if(totalMarketcap>dContract.getBetActualIndexValue(coinType)){\n', '                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue(coinType).add((\n', '                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue(coinType)))\n', '                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue(coinType))),coinType);\n', '            }else if(totalMarketcap<dContract.getBetActualIndexValue(coinType)){\n', '                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue(coinType).sub((\n', '                                                     (dContract.getBetActualIndexValue(coinType).sub(totalMarketcap))\n', '                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue(coinType))),coinType);\n', '            }\n', '        }\n', '        dContract.updateBetActualIndexValue(totalMarketcap,coinType);\n', '        return totalMarketcap;\n', '    }\n', '    function updateStatus(uint256[] memory offerIds) external nonReentrant{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n', '          for(uint256 i=0;i<offerIds.length;i++){ \n', '            InlineDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[offerIds[i]];\n', '            if(bObject.status==0){\n', '                uint256 sevenDaysTime=(((((bObject.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(bObject.betTimePeriod).sub(1));\n', '                if(block.timestamp>=sevenDaysTime){\n', '                    if(!isValued){\n', '                        stakeOffset=stakeOffset.add(dContract.getTokenStakedAmount());\n', '                        isValued=true;\n', '                    }\n', '                     if(bObject.betType==0 || bObject.betType==1 || bObject.betType==4 || bObject.betType==5 || bObject.betType==8 || bObject.betType==9){\n', '                        // defi fixed\n', '                        string memory tempSymbol;\n', '                        uint256 tempOracle;\n', '                        if(bObject.betType==0 || bObject.betType==4 || bObject.betType==8){\n', '                            tempSymbol=dContract.getFixedMapping(bObject.contractAddress,bObject.coinType).currencySymbol;\n', '                            tempOracle=dContract.getFixedMapping(bObject.contractAddress,bObject.coinType).oracleType;\n', '                        }else{\n', '                            tempSymbol=dContract.getFlexibleMapping(bObject.contractAddress,bObject.coinType).currencySymbol;\n', '                            tempOracle=dContract.getFlexibleMapping(bObject.contractAddress,bObject.coinType).oracleType;\n', '                        }\n', '                        uint256 currentprice=uint256(oWObject.getPrice(tempSymbol, tempOracle));\n', '                       \n', '                        if(currentprice>bObject.currentPrice){\n', '                            uint16 percentageValue=uint16(((currentprice.sub(bObject.currentPrice)).mul(10**4))\n', '                                                    .div(currentprice));\n', '                            if(percentageValue>=bObject.checkpointPercent){\n', '                                updateXIVForStakers(offerIds[i], true);\n', '                            }else{\n', '                                updateXIVForStakers(offerIds[i], false);\n', '                            }\n', '                        }else{\n', '                            updateXIVForStakers(offerIds[i], false);\n', '                        }\n', '                    }else{\n', '                        //index  \n', '                      updateXIVForStakersIndex(offerIds[i]);\n', '                        \n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '    function getUserStakedAddressCount() public view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        return dContract.getUserStakedAddress().length;\n', '    }\n', '    \n', '    function incentiveStakers(uint256 pageNo, uint256 pageSize) external nonReentrant{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 pageStart=pageNo.mul(pageSize);\n', '        uint256 pageSizeValue=(pageSize.mul(pageNo.add(1)));\n', '        if(getUserStakedAddressCount()<pageSizeValue){\n', '            pageSizeValue=getUserStakedAddressCount();\n', '        }\n', '        for(uint256 i=pageStart;i<pageSizeValue;i++){\n', '            address userAddress=dContract.getUserStakedAddress()[i];\n', '            uint256 updatedAmount;\n', '            if(stakeOffset>0){\n', '                updatedAmount=(((dContract.getTokensStaked(userAddress).mul(10**4).mul(stakeOffset))\n', '                                    .div(dContract.getTokenStakedAmount().mul(10**4))));\n', '            }else{\n', '                updatedAmount=dContract.getTokensStaked(userAddress);\n', '            }\n', '            \n', '            dContract.updateTokensStaked(userAddress,updatedAmount);\n', '        }\n', '        if(getUserStakedAddressCount()<pageSizeValue || getUserStakedAddressCount()==pageSizeValue){\n', '            if(stakeOffset>0){\n', '                dContract.updateTokenStakedAmount(stakeOffset);\n', '            }else{\n', '                dContract.updateTokenStakedAmount(dContract.getTokenStakedAmount());\n', '            }\n', '            stakeOffset=0;\n', '            isValued=false;\n', '        }\n', '    }\n', '    function updateXIVForStakers(uint256 index, bool isWon) internal{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        InlineDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        if(isWon){\n', '            bObject.status=1;\n', '            uint256 rewardAmount=(uint256(bObject.rewardFactor).mul(bObject.amount)).div(10**4);\n', '            stakeOffset=stakeOffset.sub(rewardAmount);\n', '            bObject.amount=bObject.amount.add(rewardAmount);\n', '            dContract.updateBetArrayIndex(bObject,index);\n', '        }else{\n', '            bObject.status=2;\n', '            uint256 riskAmount=(uint256(bObject.riskFactor).mul(bObject.amount)).div(10**4);\n', '            stakeOffset=stakeOffset.add(riskAmount);\n', '            bObject.amount=bObject.amount.sub(riskAmount);\n', '            dContract.updateBetArrayIndex(bObject,index);\n', '        }\n', '        dContract.updateExistingBetCheckMapping(bObject.userAddress,bObject.betType,bObject.contractAddress,false);\n', '    }\n', '    \n', '    function getCalculateIndexValue(uint256 index) public view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap;\n', '        InlineDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        for(uint256 i=0;i<dContract.getBetIndexArray(bObject.id).length;i++){\n', '            Token tObj=Token(dContract.getBetIndexArray(bObject.id)[i].contractAddress);\n', '            InlineDatabaseLib.IndexCoin memory iCObj=dContract.getIndexMapping(dContract.getBetIndexArray(bObject.id)[i].contractAddress,bObject.coinType);\n', '            if(iCObj.status){\n', '                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n', '            }\n', '        }\n', '        return totalMarketcap;\n', '    }\n', '    \n', '    function updateXIVForStakersIndex(uint256 index) internal{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap=getCalculateIndexValue(index);\n', '        InlineDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        if(dContract.getBetPriceHistoryMapping(bObject.id).actualIndexValue<totalMarketcap){\n', '             uint16 percentageValue=uint16(((uint256(totalMarketcap)\n', '                                                .sub(dContract.getBetPriceHistoryMapping(bObject.id).actualIndexValue)\n', '                                                .mul(10**4)).div(totalMarketcap)));\n', '            if(percentageValue>=bObject.checkpointPercent){\n', '                updateXIVForStakers(index, true);\n', '            }else{\n', '                updateXIVForStakers(index, false);\n', '            }\n', '        }else{\n', '            updateXIVForStakers(index, false);\n', '        }\n', '    }\n', '    function marketCapValue(InlineDatabaseLib.IndexCoin memory iCObj,Token tObj) internal view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n', '         if((keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked("ETH"))) || (keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked("BTC")))){\n', '            return ((((oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n', '                                    /*    .mul(iCObj.contributionPercentage)*/)\n', '                                        .div(10**2)));\n', '        }else{\n', '            return (((tObj.totalSupply().mul(oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n', '                                /*.mul(iCObj.contributionPercentage)*/)\n', '                                .div((10**tObj.decimals()).mul(10**2))));\n', '        }\n', '    }\n', '    \n', '    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\n', '        databaseContractAddress=_databaseContractAddress;\n', '    }\n', '}']