['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-02\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint bountyValue) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint bountyValue) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint bountyValue) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'interface UniswapRouter {\n', '    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory);\n', '}\n', '\n', 'interface YCrvGauge {\n', '    function deposit(uint256 bountyValue) external;\n', '    function withdraw(uint256 bountyValue) external;\n', '}\n', '\n', 'interface TokenMinter {\n', '    function mint(address account) external;\n', '}\n', '\n', '\n', '\n', '// import relevant packages/package functions like SafeMath, Address, SafeERC20\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '   \n', '\n', '// Implement FLOW (see the README)\n', 'contract pseudo_svault {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    IERC20 constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    UniswapRouter constant UNIROUTER = UniswapRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);  //UniswapV2Router02 is deployed here; https://uniswap.org/docs/v2/smart-contracts/router02/\n', '    YCrvGauge constant YCRVGAUGE = YCrvGauge(0xFA712EE4788C042e2B7BB55E6cb8ec569C4530c1);\n', '    IERC20 constant CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);\n', '    TokenMinter constant TOKENMINTER = TokenMinter(0xd061D61a4d941c39E5453435B6345Dc261C2fcE0);\n', '\n', '    // create struct Bounty\n', '    struct Bounty {\n', '        uint256 bountyValue;\n', '        uint256 bountyTimeStamp;\n', '        uint256 totalBountyDeposit;\n', '    }\n', '\n', '    // declare mappings\n', '    mapping(address => uint) public _rewardedBalancePerUser;\n', '    mapping(address => uint) public _lastTimestampPerUser;\n', '    mapping(address => uint) public _depositBalancePerUser;\n', '\n', '    uint256 public _totalBountyDeposit;\n', '\n', '    Bounty[] public _bounties;\n', '\n', '    string public vaultName;\n', '    address public vaultAddress;\n', '\n', '    IERC20 public token0;\n', '    IERC20 public token1; // PF deployer address\n', '\n', '    address public feeAddress;\n', '    uint32 public feeRate;\n', '    address public treasury;\n', '\n', '    bool public isWithdrawable;\n', '\n', '    // based on convo with Ali the user rate should be 70%, treasury rate 30%; total rate is 10000 or 100%\n', '    uint256 public rewardUserRate = 7000;\n', '    uint32 public rewardTreasuryRate = 3000;\n', '    // may want totalRate to be constant rather than public\n', '    uint256 public totalRate = 10000;\n', '    \n', '    uint256 public crv_0;\n', '    uint256 public token_0;\n', '    \n', '    address public gov;\n', '\n', '    // declare events; same as OG contract but also has an event for the sent bounty\n', '    event Deposited(address indexed user, uint256 bountyValue);\n', '    event ClaimedReward(address indexed user, uint256 bountyValue);\n', '    event Withdrawn(address indexed user, uint256 bountyValue);\n', '    event DistributedBounty(address indexed, uint256 bountyValue);\n', '\n', '    // implement constructor\n', '    // might get rid of _vaultAddress\n', '    constructor (address _token0, address _token1, address _feeAddress, string memory name, address _treasury) payable {\n', '        token0 = IERC20(_token0);\n', '        token1 = IERC20(_token1);\n', '        feeAddress = _feeAddress;\n', '        vaultName = name;\n', '        gov = msg.sender;\n', '        treasury = _treasury;\n', '        token0.approve(address(YCRVGAUGE), type(uint).max);\n', '        CRV.approve(address(UNIROUTER), type(uint).max);\n', '        // token0.approve(address(YCRVGAUGE), 100);\n', '        // CRV.approve(address(UNIROUTER), 100);\n', '    }\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == gov, "!governance");\n', '        _;\n', '    }\n', '\n', '    function setGovernance(address _gov)\n', '        external\n', '        onlyGov\n', '    {\n', '        gov = _gov;\n', '    }\n', '\n', '    function setToken0(address _token)\n', '        external\n', '        onlyGov\n', '    {\n', '        token0 = IERC20(_token);\n', '    }\n', '\n', '    function setToken1(address _token)\n', '        external\n', '        onlyGov\n', '    {\n', '        token1 = IERC20(_token);\n', '    }\n', '\n', '    function setTreasury(address _treasury)\n', '        external\n', '        onlyGov\n', '    {\n', '        treasury = _treasury;\n', '    }\n', '\n', '    function setUserRate(uint256 _rewardUserRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        rewardUserRate = _rewardUserRate;\n', '    }\n', '\n', '    function setTreasuryRate(uint32 _rewardTreasuryRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        rewardTreasuryRate = _rewardTreasuryRate;\n', '    }\n', '\n', '    function setFeeAddress(address _feeAddress)\n', '        external\n', '        onlyGov\n', '    {\n', '        feeAddress = _feeAddress;\n', '    }\n', '\n', '    function setFeeRate(uint32 _feeRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        feeRate = _feeRate;\n', '    }\n', '\n', '    function setWithdrawable(bool _isWithdrawable)\n', '        external\n', '        onlyGov\n', '    {\n', '        isWithdrawable = _isWithdrawable;\n', '    }\n', '\n', '    function setVaultName(string memory name)\n', '        external\n', '        onlyGov\n', '    {\n', '        vaultName = name;\n', '    }\n', '\n', '    function setTotalRate(uint256 _totalRate)\n', '        external\n', '        onlyGov\n', '    {\n', '        totalRate = _totalRate;\n', '    }\n', '    \n', '    // function makeCRV() internal {\n', '    //     uint rewardAmountForCRVToken = CRV.balanceOf(address(this));\n', '    //     TOKENMINTER.mint(address(YCRVGAUGE));\n', '    //     rewardAmountForCRVToken = CRV.balanceOf(address(this)) - rewardAmountForCRVToken;\n', '    // }\n', '\n', '    // I modified getReward() such that updating rewardedBalance is greatly simplifed \n', '    // this is similar structure to the modifier updateBalance() in original contract but makes use of\n', '    // SafeMath as well as the Bounty struct (_bounties) for easier access of specific public information\n', '    // rewardedBalance is updated by adding the:\n', '    // (bountyValue ((rewardvaleeForCRVToken) * _depositBalancePerUser[userAddress]) / _bounties[k].totalBountyDeposit)\n', '    function getReward(address userAddress) internal {\n', '\n', '        uint256 rewardedBalance = _rewardedBalancePerUser[userAddress];\n', '        uint256 lastTimestamp = _lastTimestampPerUser[userAddress];\n', '\n', '        // make sure timestamp & _bounties struct is larger than 0 in order to avoid processing dud calls \n', "        // lastTimestamp of user's address must be less than previous user's\n", '        if (lastTimestamp > 0 && _bounties.length > 0) {\n', '            for (uint k = _bounties.length - 1; lastTimestamp < _bounties[k].bountyTimeStamp; k--) {\n', '                rewardedBalance = rewardedBalance.add(_bounties[k].bountyValue.mul(_depositBalancePerUser[userAddress]).div(_bounties[k].totalBountyDeposit));\n', '                if (k == 0) break; // break for loop if k is 0 to avoid unnessecary runtime\n', '            }\n', '        }\n', '        _rewardedBalancePerUser[userAddress] = rewardedBalance;\n', '        _lastTimestampPerUser[msg.sender] = block.timestamp;\n', '    }\n', '\n', "    // function deposit(uint amount) external updateBalance(msg.sender) --> shouldn't need this since getReward is called each time which acts\n", '    // in exact same capacity as updateBalance() in OG contract; getReward from OG contract is very inefficient and has been split up in this contract \n', '    \n', '    // bountyValue is in yCRV when user deposits\n', '    function deposit(uint256 bountyValue) external {\n', '        getReward(msg.sender);\n', '\n', '        uint256 feebountyValue = bountyValue.mul(feeRate).div(totalRate); \n', '       \n', '        // actual amount being deposited after fee is assessed       \n', '        uint256 realbountyValue = bountyValue.sub(feebountyValue);\n', '        \n', '        if (feebountyValue > 0) {\n', '            token0.transferFrom(msg.sender, feeAddress, feebountyValue);\n', '        }\n', '\n', '        // vaultAddress is used here instead of address(this) in original contract because we want to deposit to vault\n', '        // address(this) [address of the contract instance] might make more sense if the this is deployed by PF\n', "        // actual amount being deposited into PF's yUSD vault after fee is assessed \n", '\n', '        // address(this) since this is actually just transferring the yCRV to the contract instance who then deposits\n', '        if (realbountyValue > 0) {\n', '            token0.transferFrom(msg.sender, address(this), realbountyValue);\n', '            YCRVGAUGE.deposit(realbountyValue); // -> does this need to be done here or will vaultAddress handle depositing this to ycrvguage?\n', '            _depositBalancePerUser[msg.sender] = _depositBalancePerUser[msg.sender].add(realbountyValue);  // use _depositBalancePerUser from mapping\n', '            _totalBountyDeposit = _totalBountyDeposit.add(realbountyValue); // update _totalBountyDeposit\n', '            emit Deposited(msg.sender, realbountyValue);\n', '        }\n', '    }\n', '\n', '    // PF is withdrawing from yUSD or CRV on behalf of user\n', "    // msg.sender in this case is PF's address I believe...might use userAddress instead of msg.sender\n", '    function withdraw(uint256 bountyValue) external {\n', '        // again make sure there is something to withdraw to avoid dud calls\n', '\n', '        // require(token0.balanceOf(address(this)) > 0, "nothing to withdraw");\n', '        require(isWithdrawable, "not withdrawable");\n', '\n', '        getReward(msg.sender);\n', '\n', "        // if the bountyValue is larger than the user's balance then we'll reset the bountyValue to the user's actual balance\n", '        if (bountyValue > _depositBalancePerUser[msg.sender]) {\n', '            bountyValue = _depositBalancePerUser[msg.sender];\n', '        }\n', '\n', "        // again making sure to avoid continuing if there's nothing to withdraw after reseting bountyValue\n", '        require(bountyValue > 0, "withdraw amount is 0");\n', '\n', '        YCRVGAUGE.withdraw(bountyValue);\n', '\n', '        // transfer CRV tokens to PF, the sender\n', '        token0.transfer(msg.sender, bountyValue);\n', '\n', '        // assign deposit balance to the deposit balance minus the bountyValue (the amount needed to be withdrawn for YCRV)\n', '        _depositBalancePerUser[msg.sender] = _depositBalancePerUser[msg.sender].sub(bountyValue);\n', '        //update public total bounty deposit value such that bountyValue needed to be withdrawn for YCRV is withdrawn\n', '        _totalBountyDeposit = _totalBountyDeposit.sub(bountyValue);  // seems like full amount should be withdrawn\n', '\n', '        emit Withdrawn(msg.sender, bountyValue);\n', '    }\n', '\n', '\n', '    // making a new separate function to actually send the bounty and send to treasury (called by PF)\n', '    // this function is called last once the user claimReward() has been called\n', '    // this function uses logic from the getReward() in the original contract\n', '    // and is a cleaner implementation\n', '    function _distributeBounty(uint256 maxBountyValue) internal returns (uint256, uint256) {\n', '        // again make sure there is a bounty vaue to give in order to avoid dud calls\n', '        require(maxBountyValue > 0, "bountyValue can\'t be 0");\n', '        require(_totalBountyDeposit > 0, "totalDeposit must bigger than 0");\n', '\n', '\n', '        uint256 treasuryBountyValue; \n', '        uint256 bountyValueUser = maxBountyValue.mul(rewardUserRate).div(totalRate);  // bountyValueUser == rewardCRVTokenAmountForUsers in original contract (i.e. rewardAmountForCRVToken * rewardUserRate / TOTALRATE)\n', '        treasuryBountyValue = maxBountyValue.sub(bountyValueUser);  // update bountyValue (amountWithdrawForYCRV) by subtracting bountyValueUser (rewardCRVTokenAmountForUsers)\n', '        \n', '        // perform swap here --> need to assess what swapExactTokensForTokens() call takes as args\n', '\n', '        // somthing like UNIROUTER.swapExactTokensForTokens(rewardCRVTokenAmountForUsers, 0, tokens, address(this), type(uint).max);\n', '        // where tokens is an array that has CRV, WETH, and token1\n', '        // this call will update token1\n', '        address[] memory tokens = new address[](3);\n', '        tokens[0] = address(CRV);\n', '        tokens[1] = address(WETH);\n', '        tokens[2] = address(token1);\n', '\n', '        uint256 pylon_before;\n', '        uint256 pylon_after;\n', '\n', '        pylon_before = token1.balanceOf(address(this));\n', '\n', '        if (bountyValueUser > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(bountyValueUser, 0, tokens, address(this), type(uint).max);\n', '        }\n', '\n', '        pylon_after = token1.balanceOf(address(this));\n', '\n', "        // transfers PYLON tokens to user...don't need to convert here if already done in claimReward()\n", '        // token1.safeTransferFrom(msg.sender, address(this), bountyValueUser); // bountyValueUser has been adjusted and can now be sent to user\n', '        \n', '        // convert bountyValue to WETH and then send to treasury\n', '        // somthing like UNIROUTER.swapExactTokensForTokens(rewardCRVTokenAmountForUsers, 0, tokens1, address(this), type(uint).max);\n', '        // where tokens1 is an array that has CRV and WETH\n', '\n', '        address[] memory tokens1 = new address[](2);\n', '        tokens1[0] = address(CRV);\n', '        tokens1[1] = address(WETH);\n', '\n', '        if (treasuryBountyValue > 0) {\n', '            UNIROUTER.swapExactTokensForTokens(treasuryBountyValue, 0, tokens1, address(this), type(uint).max);\n', '        }\n', '\n', '        uint wethBalance;\n', '        wethBalance = WETH.balanceOf(address(this));\n', '        WETH.transfer(treasury, wethBalance);\n', '\n', '        Bounty memory bounty;\n', '        bounty = Bounty(bountyValueUser, block.timestamp, _totalBountyDeposit);\n', '        _bounties.push(bounty); // push bounty struct object to _bounties array\n', '        emit DistributedBounty(msg.sender, bountyValueUser);\n', '\n', '        return (pylon_before, pylon_after);\n', '\n', '    }\n', '\n', '    // here I adapt the original claimReward() logic into two separate functions that also draw upon\n', '    // another function, getBountyValue() to retrieve the max bounty; getBountyValue() is adapated from\n', '    // the modifier in the original contract and code used in the original claimReward() function\n', '    // this function is called on behalf of the user, so pylon token will transfer to PF deployer\n', '    function claimReward() external {\n', '        getReward(msg.sender);\n', '\n', '        // uint rewardPylonTokenAmountForUsers = token1.balanceOf(address(this));\n', '\n', "        // maxBounty is essentially 'currentRewardAmount' as defined in the original claimReward() function, but is vetted.\n", '        // see getBountyValue() below\n', '        uint256 maxBounty = getBountyValue(msg.sender);\n', '        // is the max reward, not yet differentiated into CRV vs PYLON or with rates applied\n', '\n', '        _rewardedBalancePerUser[msg.sender] = _rewardedBalancePerUser[msg.sender].sub(maxBounty); // adjusts the _rewardedBalancePerUser for the claim call\n', '        \n', '        // *** probably need to convert bountyValue into PYLONs here ***\n', '        // *** apply 70%\n', '\n', '        // also assess 30% WETH here, send values to distributeBounty (modify this to take 2 args)\n', '\n', '        // may not need this check... implementation of this in claimReward() in OG contract is pretty confusing\n', "        // this wouldn't make sense to do if bountyValue is in CRV denomination (an arbitrary value, actually, that\n", "        // simply is implicity denominated in yCRV or yUSD in my logic) hasn't been converted yet\n", '        // but the bountyValue has beem adequately kept track of/updated here so when token1.transfer is called\n', '        // the logic in transfer() function in PYLON.sol properly scales things from CRV values to PYLON\n', '        // uint token1balance = token1.balanceOf(address(this));\n', '        // if (bountyValue > token1balance){\n', '        //     bountyValue = token1balance;\n', '        // } \n', '\n', '        // Transfer converts balance to PYLONS and sends to msg.sender which should be the PF deployer address\n', "        // will use distributeBounty to send to user's address and the share to treasury address\n", '\n', '        uint256 finalPylonUserBounty;\n', '        uint256 previousPylonUserBounty;\n', '\n', '        (previousPylonUserBounty, finalPylonUserBounty) = _distributeBounty(maxBounty);\n', '\n', '        token1.transfer(msg.sender, finalPylonUserBounty);\n', '        emit ClaimedReward(msg.sender, finalPylonUserBounty);\n', '    }\n', '\n', '\n', '    // this function uses logic from claimReward() in original contract and draws on original modifier method\n', '    // rewardedBalance is equivalent to currentRewardAmount = accTotalReward * accDepositBalancePerUser[msg.sender] / accTotalDeposit in original contract\n', '    function getBountyValue(address userAddress) public view returns (uint256) {\n', '\n', '        uint256 rewardedBalance = _rewardedBalancePerUser[userAddress];\n', '        uint256 lastTimestamp = _lastTimestampPerUser[userAddress];\n', '\n', '        if (_bounties.length > 0) {\n', '            if (lastTimestamp > 0) {\n', '                for (uint l = _bounties.length - 1; lastTimestamp < _bounties[l].bountyTimeStamp; l--) {\n', '                    rewardedBalance = rewardedBalance.add(_bounties[l].bountyValue.mul(_depositBalancePerUser[userAddress]).div(_bounties[l].totalBountyDeposit));\n', '                    // currentRewardAmount = accTotalReward * accDepositBalancePerUser[msg.sender] / accTotalDeposit;\n', '                    // _bounties[i].amount == accTotalReward in OG\n', '                    // _depositBalances[userAddress] == accDepositBalancePerUser[msg.sender] in OG\n', '                    // _bounties[i].totalDeposit == accTotalDeposit in OG\n', '\n', '                    // rewardedBalance becomes maxbounty and is original rewardBalance + currentRewardAmount from OG\n', '\n', '                    if (l == 0) break;\n', '                }\n', '            }\n', '        // add option to add time to delay (e.g. force a user to wait a certain amount of time to withdraw or else get penalized?)\n', '\n', '        }\n', '        return rewardedBalance;\n', '    }\n', '\n', '    function seize(address token, address to) external onlyGov {\n', '        require(IERC20(token) != token0 && IERC20(token) != token1, "main tokens");\n', '        if (token != address(0)) {\n', '            uint256 amount = IERC20(token).balanceOf(address(this));\n', '            IERC20(token).transfer(to, amount);\n', '        }\n', '        else {\n', '            uint256 amount = address(this).balance;\n', '            payable(to).transfer(amount);\n', '        }\n', '    }\n', '        \n', '    fallback () external payable { }\n', '    receive () external payable { }\n', '}']