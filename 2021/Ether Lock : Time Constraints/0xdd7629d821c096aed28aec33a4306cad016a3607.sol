['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.7.0;\n', 'import "./FarmStaking.sol";\n', '\n', 'abstract contract Context {\n', '  function _msgSender() internal view virtual returns (address payable) {\n', '    return msg.sender;\n', '  }\n', '}\n', '\n', 'abstract contract Ownable is Context {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor () internal {\n', '    address msgSender = _msgSender();\n', '    _owner = msgSender;\n', '    emit OwnershipTransferred(address(0), msgSender);\n', '  }\n', '\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', 'contract FarmStakingGenerator is Context, Ownable {\n', '  using SafeMath for uint256;\n', '  IFarmFactory public factory;\n', '\n', '  struct FarmParameters {\n', '    uint256 bonusBlocks;\n', '    uint256 totalBonusReward;\n', '    uint256 numBlocks;\n', '    uint256 endBlock;\n', '    uint256 requiredAmount;\n', '  }\n', '\n', '  constructor(IFarmFactory _factory) public {\n', '    factory = _factory;\n', '  }\n', '\n', '  /**\n', '   * @notice Determine the endBlock based on inputs. Used on the front end to show the exact settings the Farm contract will be deployed with\n', '   */\n', '  function determineEndBlock(uint256 _amount, uint256 _blockReward, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus) public pure returns (uint256, uint256) {\n', '    FarmParameters memory params;\n', '    params.bonusBlocks = _bonusEndBlock.sub(_startBlock);\n', '    params.totalBonusReward = params.bonusBlocks.mul(_bonus).mul(_blockReward);\n', '    params.numBlocks = _amount.sub(params.totalBonusReward).div(_blockReward);\n', '    params.endBlock = params.numBlocks.add(params.bonusBlocks).add(_startBlock);\n', '\n', '    uint256 nonBonusBlocks = params.endBlock.sub(_bonusEndBlock);\n', '    uint256 effectiveBlocks = params.bonusBlocks.mul(_bonus).add(nonBonusBlocks);\n', '    uint256 requiredAmount = _blockReward.mul(effectiveBlocks);\n', '    return (params.endBlock, requiredAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Determine the blockReward based on inputs specifying an end date. Used on the front end to show the exact settings the Farm contract will be deployed with\n', '   */\n', '  function determineBlockReward(uint256 _amount, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus, uint256 _endBlock) public pure returns (uint256, uint256) {\n', '    uint256 bonusBlocks = _bonusEndBlock.sub(_startBlock);\n', '    uint256 nonBonusBlocks = _endBlock.sub(_bonusEndBlock);\n', '    uint256 effectiveBlocks = bonusBlocks.mul(_bonus).add(nonBonusBlocks);\n', '    uint256 blockReward = _amount.div(effectiveBlocks);\n', '    uint256 requiredAmount = blockReward.mul(effectiveBlocks);\n', '    return (blockReward, requiredAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Creates a new FarmStaking contract and registers it in the \n', '   * .sol. All farming rewards are locked in the FarmStaking Contract\n', '   */\n', '  function createFarmStaking(IERC20 _rewardToken, uint256 _amount, IERC20 _token, uint256 _blockReward, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus) public onlyOwner returns (address){\n', "    require(_startBlock > block.number, 'START'); // ideally at least 24 hours more to give farmers time\n", "    require(_bonus > 0, 'BONUS');\n", "    require(address(_rewardToken) != address(0), 'REWARD TOKEN');\n", "    require(address(_token) != address(0), 'TOKEN');\n", "    require(_blockReward > 1000, 'BLOCK REWARD'); // minimum 1000 divisibility per block reward\n", '\n', '    FarmParameters memory params;\n', '    (params.endBlock, params.requiredAmount) = determineEndBlock(_amount, _blockReward, _startBlock, _bonusEndBlock, _bonus);\n', '\n', '    TransferHelper.safeTransferFrom(address(_rewardToken), address(_msgSender()), address(this), params.requiredAmount);\n', '    FarmStaking newFarm = new FarmStaking(address(factory), address(this));\n', '    RewardHolder newRewardHolder = new RewardHolder(address(this), address(newFarm));\n', '    TransferHelper.safeApprove(address(_rewardToken), address(newRewardHolder), params.requiredAmount);\n', '    newRewardHolder.init(address(_rewardToken), params.requiredAmount);\n', '    newFarm.init(address(newRewardHolder), _rewardToken, params.requiredAmount, _token, _blockReward, _startBlock, params.endBlock, _bonusEndBlock, _bonus);\n', '\n', '    factory.registerFarm(address(newFarm));\n', '    return (address(newFarm));\n', '  }\n', '}']