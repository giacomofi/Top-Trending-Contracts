['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-28\n', '*/\n', '\n', '//SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', 'library SafeMath {\n', '\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', ' \n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', ' \n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', 'abstract contract AdminRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event AdminAdded(address indexed account);\n', '    event AdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _Admins;\n', '\n', '    constructor () internal {\n', '        _addAdmin(_msgSender());\n', '    }\n', '\n', '    modifier onlyAdmin() {\n', '        require(isAdmin(_msgSender()), "AdminRole: caller does not have the Admin role");\n', '        _;\n', '    }\n', '\n', '    function isAdmin(address account) public view returns (bool) {\n', '        return _Admins.has(account);\n', '    }\n', '\n', '    function addAdmin(address account) public onlyAdmin {\n', '        _addAdmin(account);\n', '    }\n', '\n', '    function renounceAdmin() public {\n', '        _removeAdmin(_msgSender());\n', '    }\n', '\n', '    function _addAdmin(address account) internal {\n', '        _Admins.add(account);\n', '        emit AdminAdded(account);\n', '    }\n', '\n', '    function _removeAdmin(address account) internal {\n', '        _Admins.remove(account);\n', '        emit AdminRemoved(account);\n', '    }\n', '}\n', 'contract A5T_USDC_Staking is Ownable,AdminRole{\n', '    using SafeMath for uint256;\n', '    \n', '    address public A5T_USDC_Address         = address(0x7d34F36bdD18e67783Df5d4Df9092c83614f9033);\n', '    address public A5T_Address              = address(0xe8272210954eA85DE6D2Ae739806Ab593B5d9c51);\n', '    \n', '    IERC20 A5T;\n', '    IERC20 A5T_USDC_Pair;\n', '    \n', '    uint256 public window_start_date;\n', '    uint256 public window_end_date;\n', '    \n', '    struct Pool{\n', '        uint                        pool_Duration;\n', '        uint256                     total_A5T_Reward;\n', '        uint256                     TVL;                //Total Value Locked in A5T-USDC LP Tokens\n', '        mapping(address => uint256) stake_amount;\n', '        mapping(address => bool)    isClaimed;\n', '    }\n', '    \n', '    mapping(uint => Pool)   public pools;\n', '    uint                    public pool_count;\n', '    \n', '    event stakeEvent(address staker, uint256 LP_amount,uint pool_number);\n', '    event unstakeEvent(address staker, uint256 LP_amount,uint pool_number);\n', '    event rewardEvent(address staker, uint256 reward_amount,uint pool_number);\n', '    \n', '    constructor () public //creation settings\n', '    {\n', '        A5T               = IERC20(A5T_Address);\n', '        A5T_USDC_Pair     = IERC20(A5T_USDC_Address);\n', '        pool_count++;\n', '        pools[pool_count].pool_Duration     = 30 days;\n', '        pools[pool_count].total_A5T_Reward  = 100000 * (10**18);\n', '        \n', '        pool_count++;\n', '        pools[pool_count].pool_Duration     = 60 days;\n', '        pools[pool_count].total_A5T_Reward  = 500000 * (10**18);\n', '        \n', '    }\n', '    function stake(uint _pool_number,uint256 _LP_Amount) public\n', '    {\n', "        require(_LP_Amount>=0,'zero amount');\n", "        require(_pool_number>0 && _pool_number<=pool_count,'invalid pool number');\n", "        require(window_start_date >0 && window_end_date>0,'not started');\n", "        require(block.timestamp <= window_end_date && block.timestamp >= window_start_date,'not time to stake');\n", '        \n', '        //Check if the contract is allowed to send token on user behalf\n', '        uint256 allowance = A5T_USDC_Pair.allowance(msg.sender,address(this));\n', "        require (allowance>=_LP_Amount,'allowance error');\n", '        \n', "        require(A5T_USDC_Pair.transferFrom(msg.sender,address(this),_LP_Amount),'transfer Token Error');\n", '        pools[_pool_number].TVL = pools[_pool_number].TVL.add(_LP_Amount);\n', '        pools[_pool_number].stake_amount[msg.sender] = pools[_pool_number].stake_amount[msg.sender].add(_LP_Amount);\n', '        \n', '        emit stakeEvent(msg.sender, _LP_Amount,_pool_number);\n', '        \n', '    }\n', '    // function unstake(uint _pool_number) public {\n', '        \n', "    //     require(_pool_number>0 && _pool_number<=pool_count,'invalid pool number');\n", "    //     require(block.timestamp >= window_end_date+pools[_pool_number].pool_Duration,'not time to unstake yet');\n", "    //     require(!pools[_pool_number].isUnstaked[msg.sender],'already unstaked');\n", '        \n', '    //     pools[_pool_number].isUnstaked[msg.sender] = true;\n', '        \n', "    //     require(A5T_USDC_Pair.transfer(msg.sender, pools[_pool_number].stake_amount[msg.sender]),'transfer Token Error');\n", '        \n', '    //     emit unstakeEvent(msg.sender, pools[_pool_number].stake_amount[msg.sender],_pool_number);\n', '    // }\n', '    // function claimReward(uint _pool_number) public{\n', "    //     require(_pool_number>0 && _pool_number<=pool_count,'invalid pool number');\n", "    //     require(block.timestamp >= window_end_date+pools[_pool_number].pool_Duration,'not time to unstake yet');\n", "    //     require(pools[_pool_number].stake_amount[msg.sender] > 0,'nothing to unstake');\n", "    //     require(!pools[_pool_number].isClaimed[msg.sender],'already claimed');\n", '        \n', '    //     pools[_pool_number].isClaimed[msg.sender] = true;\n', '        \n', "    //     require(A5T.transfer(msg.sender, pools[_pool_number].stake_amount[msg.sender].mul(pools[_pool_number].total_A5T_Reward).div(pools[_pool_number].TVL)),'transfer Token Error');\n", '        \n', '    //     emit rewardEvent(msg.sender, pools[_pool_number].stake_amount[msg.sender].mul(pools[_pool_number].total_A5T_Reward).div(pools[_pool_number].TVL),_pool_number);\n', '    // }\n', '    function claimAndUnstake(uint _pool_number) public{\n', "        require(_pool_number>0 && _pool_number<=pool_count,'invalid pool number');\n", "        require(block.timestamp >= window_end_date+pools[_pool_number].pool_Duration,'not time to unstake yet');\n", "        require(pools[_pool_number].stake_amount[msg.sender] > 0,'nothing to unstake');\n", "        require(!pools[_pool_number].isClaimed[msg.sender],'already claimed');\n", '        \n', '        pools[_pool_number].isClaimed[msg.sender] = true;\n', '        \n', "        require(A5T_USDC_Pair.transfer(msg.sender, pools[_pool_number].stake_amount[msg.sender]),'transfer Token Error');\n", '        \n', '        emit unstakeEvent(msg.sender, pools[_pool_number].stake_amount[msg.sender],_pool_number);\n', '        \n', "        require(A5T.transfer(msg.sender, pools[_pool_number].stake_amount[msg.sender].mul(pools[_pool_number].total_A5T_Reward).div(pools[_pool_number].TVL)),'transfer Token Error');\n", '        \n', '        emit rewardEvent(msg.sender, pools[_pool_number].stake_amount[msg.sender].mul(pools[_pool_number].total_A5T_Reward).div(pools[_pool_number].TVL),_pool_number);\n', '    }\n', '    //Getters\n', '    function getNow() public view returns(uint256){\n', '        return block.timestamp;\n', '    }\n', '    function getPool_stakeAmount(uint _pool_number,address _staker) public view returns(uint256 _stakeAmount){\n', '        return pools[_pool_number].stake_amount[_staker];\n', '    }\n', '    \n', '    function getPool_isClaimed(uint _pool_number,address _staker) public view returns(bool _isClaimed){\n', '        return pools[_pool_number].isClaimed[_staker];\n', '    }\n', '    //Setters\n', '    function change_Pool_Reward(uint _pool_number,uint256 _new_A5T_reward) public onlyAdmin {\n', "        require(_new_A5T_reward>0,'invalid reward');\n", "        require(_pool_number>0 && _pool_number<=pool_count,'invalid pool number');\n", '        pools[_pool_number].total_A5T_Reward = _new_A5T_reward;\n', '        \n', '    }\n', '    function change_Pool_Duration(uint _pool_number,uint256 _new_Duration) public onlyAdmin {\n', "        require(_new_Duration>0,'invalid duration');\n", "        require(_pool_number>0 && _pool_number<=pool_count,'invalid pool number');\n", '        pools[_pool_number].pool_Duration = _new_Duration;\n', '        \n', '    }\n', '    function setWindow_Start_Date(uint256 _date) public onlyAdmin {\n', '        if (window_end_date != 0)\n', "            require(_date<window_end_date,'start date must less than end date');\n", '        window_start_date = _date;\n', '    }\n', '    function setWindow_End_Date(uint256 _date) public onlyAdmin {\n', '        if (window_start_date != 0)\n', "            require(window_start_date<_date,'start date must less than end date');\n", '        window_end_date = _date;\n', '    }\n', '    function setA5Taddress(address _newAddress) public onlyAdmin {\n', '        A5T_Address         = _newAddress;\n', '        A5T                 = IERC20(A5T_Address);\n', '    }\n', '    function setPairAddress(address _newPairAddress) public onlyAdmin {\n', '        A5T_USDC_Address            = _newPairAddress;\n', '        A5T_USDC_Pair               = IERC20(A5T_USDC_Address);\n', '    }\n', '\n', '    \n', '    //Protect the pool in case of hacking\n', '    function kill(address payable _to) onlyOwner public {\n', '        uint256 balance = A5T.balanceOf(address(this));\n', '        A5T.transfer(_to, balance);\n', '        A5T_USDC_Pair.transfer(_to, balance);\n', '        selfdestruct(_to);\n', '    }\n', '    function transferFundA5T(uint256 amount, address payable _to) onlyOwner public {\n', '        uint256 balance = A5T.balanceOf(address(this));\n', "        require(amount<=balance,'exceed contract balance');\n", '        A5T.transfer(_to, amount);\n', '    }\n', '    function transferFundPair(uint256 amount, address payable _to) onlyOwner public {\n', '        uint256 balance = A5T_USDC_Pair.balanceOf(address(this));\n', "        require(amount<=balance,'exceed contract balance');\n", '        A5T_USDC_Pair.transfer(_to, amount);\n', '    }\n', '    function transferFund(uint256 amount, address payable _to) public onlyOwner {\n', "        require(amount<=address(this).balance,'exceed contract balance');\n", '        _to.transfer(amount);\n', '    }\n', '}']