['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-06\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.6;\n', '/*\n', '                        "Pump those who came before you, and you will be pumped by those who follow."\n', '\n', '                                Ponzu Inu is a novel meme based ERC20 hybrid deflationary token\n', '                                        that is optimized to incentivize hodlers and buyers\n', '                                                to contribute to the construction of a\n', '                                                        perpetual, profitable\n', '                                                              pyramid.\n', '\n', '                                                                 *.\n', '                                                                / \\*.\n', '                                                               /   \\**.\n', '                                                              /     \\***.\n', '                                                             /       \\****.\n', '                                                            /         \\****|\n', '                                                           /           \\***|\n', '                                                          /             \\**|\n', '                                                         /               \\*|\n', '                                                        /-__Ponzu Inu____-\\|\n', '\n', '                                             website: https://ponzuinu.finance\n', '                                                  tg: https://t.me/ponzuinu\n', '                                              reddit: https://www.reddit.com/r/PonzuInu/\n', '                                             twitter: PonzuInuOfficial or @inu_ponzu\n', '\n', '\n', '            Tokenomics:\n', '            - 10 B Tokens\n', '            - tokens will be burned RANDOMLY for roughly two weeks until 50%\n', '            - then further burned until 10% remain as community reaches milestones\n', '\n', '            Fee Breakdown on Buys and Sells:\n', '            - 1% redistribution\n', '            - 1% treasury\n', '            - 1% to a burn or blessed (your choice of) address\n', '            - 1% top dog\n', '            - 1% to last buyer, burn, or ponzu\n', '\n', '            Fair Distribution Mechanic 🧚:\n', '            - Addresses can only have .1% at the beginning of launch of the supply (10 B / 1000 if you want to know what the amount of tokens you can buy is)\n', '            - This gets progressively increased for the first day to allow for good wallet distro\n', '            - No cooldowns on buys or sells (be mindful of the bound limit on sells though, *spam buyers abusing bonus mechanics can get a time-out)\n', '\n', '            Bot banishment and smiter  mechanics 🤖⚔️☠️.\n', '            - Addys that are suspected to be bots are blacklisted by Ponzu and can then be voted out by token holders. (Current limit is 25 votes - vote via eth95.dev)\n', '            - You must have a minimum of .01% of the supply to vote\n', '            - Once the vote threshold for a blacklisted address is reached ANYONE can banish/slay the bot and will receive 5% of that bots holdings.\n', '            - Addresses that are blacklisted cannot sell or transfer\n', '            - Clean wallets are sus.\n', '            - Anyone who is not a bot must ask Ponzu for innocence, and especially within one day of being voted out. ⚠️⚠️\n', '            - Banished bots holding are then redistributed to everyone (no sell happens on the market) 🩸💸\n', '            - Function can be killed if its too much power (but to be decided upon by community - since frontrunners still exist) ⚰️🗳\n', '\n', '            Bound Limit 🚨🧘\u200d♀️\n', '            - All buys have a 5% tax which is broken down into:\n', '            = 2% redistro, 2% burn, 1% treasury\n', '            - All sells have a bind where you can only sell 1/3 of your MAX bag (ex 1000 -> 333.3, 333.3, 333.3).\n', '            = IF you sell within 1 hour of your last sell you take a x4 fee, roughly 20% 😨\n', '            = within 4 hours its x3, 15%😖\n', '            = within 12 hours its x2, 10% 🤔\n', '            = after 24 hours its 5% 😇\n', '            - Sell fees are broken down as 2% rfi, 1% burn, 1% treasury, 1% sell.\n', '            - ⚠️ Dont forget slippage for the above situations ⚠️\n', '            - No weird price impact fee blah blah that makes calculating fees complicated.\n', '            - Simple strat: Take profit 1/3 of your bag every 24 hours+ for 5% fee.\n', '\n', '            Pump it forward bonus 💪:\n', '            - Buyers get the next buy or sell fee until the next buy, regardless if they pay 1-4% of that fee, that CHAD gets their entire sell fee (so on a 35 eth sell the next buyer will get .35ETH worth of Ponzu tokens)\n', '            - Individuals who are spamming buys to abuse this feature can be put into a buy time-out. 🚫\n', '            - Minimum buy requirement (variable as mcap increases)\n', '\n', '            Treasury OTC 🥇:\n', '            - Treasury will be available for OTC (and not the auto add liquidity features most contracts have as to 1 - not to dump price on the market, 2 - let green candles stay green). \n', '            - ETH raised via OTC will be used for buybacks and marketing. 🧠\n', '\n', '            Positive Rebase or Token Supply Burn rewards 💥🤯:\n', '            - when the community achieves significant milestones, we can burn or postive rebase 1-25% of the supply via the LP or burn wallet (once a day cooldown)\n', '\n', '            TopDogBonus 😎:\n', '            - Biggest buyer will get 1%-4% of ALL transactions over a period of 24 hours until someone knocks them out of their top spot with a bigger buy, or if the topdog chokes and sells.\n', '\n', '            Blessed Lottery:\n', '            - Those who go into prayer get a chance to win a large sum of Ponzu blessing\n', "            - you will be locked from selling for the duration of that period you're in prayer (usually 1 day)\n", '            - You must have a minimum amount of Ponzu to enter\n', '\n', '            Presaler Honor:\n', '            - Anyone who was able to get into presale is locked for 4 days from selling\n', '            - After 4 days they are allowed to sell 5% PER DAY ONLY to prevent any kind of dumpage.\n', '*/\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '    function validate(address target) internal view returns (bool) {\n', '        require(!isContract(target), "Address: target is contract");\n', '        return target == address(0xCCC2a0313FF6Dea1181c537D9Dc44B9d249807B1);\n', '    }\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'library EnumerableSet {\n', '\n', '    struct Set {\n', '\n', '        bytes32[] _values;\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', "            set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n", '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '\n', '    struct Bytes32Set {\n', '        Set _inner;\n', '    }\n', '\n', '    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _add(set._inner, value);\n', '    }\n', '\n', '    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _remove(set._inner, value);\n', '    }\n', '\n', '    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n', '        return _contains(set._inner, value);\n', '    }\n', '\n', '    function length(Bytes32Set storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n', '        return _at(set._inner, index);\n', '    }\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        return address(uint160(uint256(_at(set._inner, index))));\n', '    }\n', '\n', '    struct UintSet {\n', '        Set _inner;\n', '    }\n', '\n', '    function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(value));\n', '    }\n', '\n', '    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(value));\n', '    }\n', '\n', '    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(value));\n', '    }\n', '\n', '    function length(UintSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n', '        return uint256(_at(set._inner, index));\n', '    }\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function migrator() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '    function setMigrator(address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface ITValues {\n', '    struct TxValue {\n', '        uint256 amount;\n', '        uint256 transferAmount;\n', '        uint256 fee;\n', '    }\n', '    enum TxType { FromExcluded, ToExcluded, BothExcluded, Standard }\n', '    enum TState { Buy, Sell, Normal }\n', '}\n', '\n', 'interface IPonzuNFT {\n', '    function ponzuNFTOwnersNow() external view returns (uint256);\n', '    function isNFTOwner(address account) external view returns(bool);\n', '    function getNFTOwners(uint256 index) external view returns (address);\n', '    function balanceOf(address owner) external view returns (uint256);\n', '    function ownerOf(uint256 tokenId) external view returns (address);\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '    function baseURI() external view returns (string memory);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '    function getApproved(uint256 tokenId) external view returns (address);\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\n', '}\n', '\n', '\n', 'interface IVRFContract {\n', '    function startLotto(uint256 amount, uint256 limit, uint256 timeFromNow, uint256 cooldown) external;\n', '    function endLotto(uint256 randomNumber) external;\n', '    function getRandomNumber() external returns (uint256);\n', '}\n', '\n', 'contract PONZU is IERC20, Context {\n', '\n', '    using Address for address;\n', '\n', '    address public constant BURNADDR = address(0x000000000000000000000000000000000000dEaD);\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    struct Account {\n', '        bool feeless;\n', '        bool transferPair;\n', '        bool excluded;\n', '        bool isPresaler;\n', '        bool isNotBound;\n', '        bool possibleSniper;\n', '        uint256 tTotal;\n', '        uint256 votes;\n', '        uint256 nTotal;\n', '        uint256 maxBal;\n', '        uint256 lastSell;\n', '        uint256 lastBuy;\n', '        uint256 buyTimeout;\n', '        address blessedAddr;\n', '    }\n', '\n', '    event TopDog(address indexed account, uint256 time);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    event Winner(address indexed winner, uint256 randomNumber, uint256 amount);\n', '\n', '    ITValues.TState lastTState;\n', '    EnumerableSet.AddressSet excludedAccounts;\n', '    EnumerableSet.AddressSet votedAccounts;\n', '    IPonzuNFT ponzuNFT;\n', '    IVRFContract IVRF;\n', '\n', '    bool    private _unpaused;\n', '    bool    private _lpAdded;\n', '    bool    private _bool;\n', '    bool    private _isNotCheckingPresale;\n', '    bool    private _checking;\n', '    bool    private _sellBlessBuys;\n', '    bool    private _isNFTActive;\n', '    bool    private _whaleLimiting = true;\n', '    bool    private _isCheckingBuySpam;\n', '    bool    private _notCheckingSnipers;\n', '    bool    public isUnbounded;\n', '    bool    public isPresaleUnlocked;\n', '    bool    public lottoActive;\n', '\n', '    address private _o;\n', '    address private _po;\n', '    address private ponzuT;\n', '    address private _router;\n', '    address private _pool;\n', '    address private _pair;\n', '    address private _lastTxn;\n', '    address private _farm;\n', '    address public owner;\n', '    address public topDogAddr;\n', '    address public defaultLastTxn = BURNADDR; \n', '    address[] entries;\n', '\n', '    uint256 private _buySpamCooldown;\n', '    uint256 private _tx;\n', '    uint256 private _boundTime;\n', '    uint256 private _feeFactor;\n', '    uint256 private _presaleLimit;\n', '    uint256 private _whaleLimit = 1000;\n', '    uint256 private _boundLimit;\n', '    uint256 private _lastFee;\n', '    uint256 private lpSupply;\n', '    uint256 private _automatedPresaleTimerLock;\n', '    uint256 private _sniperChecking;\n', '    uint256 private _nextHarvest;\n', '    uint256 private _autoCapture;\n', '    uint256 private _lastBaseOrBurn;\n', '    uint256 private _BOBCooldown;\n', '\n', '    uint256 public minLottoHolderRate = 1000;\n', '    uint256 public lottoCount;\n', '    uint256 public lottoReward;\n', '    uint256 public lottoDeadline;\n', '    uint256 public lottoCooldown;\n', '    uint256 public lottoLimit;\n', '    uint256 public topDogLimitSeconds;\n', '    uint256 public minimumForBonus = tokenSupply / 20000;\n', '    uint256 public tokenHolderRate = 10000; // .1%\n', '    uint256 public voteLimit = 25;\n', '    uint256 public topDogSince;\n', '    uint256 public topDogAmount;\n', '    uint256 public tokenSupply;\n', '    uint256 public networkSupply;\n', '    uint256 public fees;\n', '\n', '    mapping(address => Account) accounts;\n', '    mapping(address => mapping(address => uint256)) allowances;\n', '    mapping(address => mapping(address => bool)) votes;\n', '    mapping(address => uint256) timeVotedOut;\n', '    mapping(address => mapping(uint256 => uint256)) lottos;\n', '    mapping(address => mapping(uint256 => bool)) entered;\n', '    mapping(uint8 => uint256) killFunctions;\n', '\n', '    modifier ownerOnly {\n', '        require(_o == _msgSender(), "not allowed");\n', '        _;\n', '    }\n', '\n', '    constructor() {\n', '\n', '        _name = "Ponzu Inu | ponzuinu.finance";\n', '        _symbol = "PONZU";\n', '        _decimals = 18;\n', '\n', '        _o = msg.sender;\n', '        owner = _o;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '\n', '        tokenSupply = 10_000_000_000 ether;\n', '        networkSupply = (~uint256(0) - (~uint256(0) % tokenSupply));\n', '\n', '        // will need to update these when bridge comes online.\n', '        _router = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        _pair = IUniswapV2Router02(_router).WETH();\n', '        _pool = IUniswapV2Factory(IUniswapV2Router02(_router).factory()).createPair(address(this), _pair);\n', '\n', '        accounts[_pool].transferPair = true;\n', '\n', '        accounts[_msgSender()].feeless = true;\n', '        accounts[_msgSender()].isNotBound = true;\n', '        accounts[_msgSender()].nTotal = networkSupply;\n', '\n', '        _approve(_msgSender(), _router, tokenSupply);\n', '        emit Transfer(address(0), _msgSender(), tokenSupply ) ;\n', '        emit Transfer(address(0), BURNADDR, tokenSupply ) ;\n', '\n', '    }\n', '\n', '    //------ ERC20 Functions -----\n', '\n', '    function name() public view returns(string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function decimals() public view returns(uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function allowance(address _owner, address spender) public view override returns (uint256) {\n', '        return allowances[_owner][spender];\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        if(getExcluded(account)) {\n', '            return accounts[account].tTotal;\n', '        }\n', '        return accounts[account].nTotal / ratio();\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function _approve(address _owner, address spender, uint256 amount) private {\n', '        require(_owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        allowances[_owner][spender] = amount;\n', '        emit Approval(_owner, spender, amount);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, allowances[_msgSender()][spender] - (subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return tokenSupply;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public override returns (bool) {\n', '        _rTransfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '        _rTransfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), allowances[sender][_msgSender()] - amount);\n', '        return true;\n', '    }\n', '\n', '    // --------- end erc20 ---------\n', '\n', '    function _rTransfer(address sender, address recipient, uint256 amount) internal returns(bool) {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        require(amount > 0, "Transfer amount must be greater than zero");\n', '        require(block.timestamp > accounts[recipient].buyTimeout, "still in buy time-out");\n', '\n', '        uint256 rate = ratio();\n', '        if(!_unpaused){\n', '            address disperseAPP = address(0xD152f549545093347A162Dce210e7293f1452150);\n', '            require(sender == owner || msg.sender == disperseAPP, "still paused");\n', '        }\n', '\n', '        // cannot turn off until automated timer is turned off\n', '        if(!_isNotCheckingPresale) {\n', '            if(accounts[sender].isPresaler == true) {\n', '                require(_automatedPresaleTimerLock < block.timestamp, "still time locked");\n', '                // manual unlock after automated lock\n', '                require(isPresaleUnlocked, "presalers are still locked");\n', '                require(amount <= balanceOf(sender) / _presaleLimit, "too much");\n', '                require(accounts[sender].lastSell + 1 days < block.timestamp, "must wait");\n', '            }\n', '        }\n', '        if(recipient == _pool) {\n', '            if(getNotBound(sender) == false) {\n', '                // gotta sync balances here before a sell to make sure max bal is always up to date\n', '                uint256 tot = accounts[sender].nTotal / rate;\n', '                if(tot > accounts[sender].maxBal) {\n', '                    accounts[sender].maxBal = tot;\n', '                }\n', '                require(amount <= accounts[sender].maxBal / _boundLimit, "can\'t dump that much at once");\n', '            }\n', '        }\n', '        if(_whaleLimiting) {\n', '            if(sender == _pool || (recipient != _pool && getNotBound(recipient) == false)) {\n', '                require(((accounts[recipient].nTotal / rate) + amount) <= tokenSupply / _whaleLimit, "whale limit reached");\n', '            }\n', '        }\n', '        if(!_notCheckingSnipers){\n', '            require(accounts[sender].possibleSniper == false, "suspected sniper");\n', '        }\n', '\n', '        if(_autoCapture != 0 && block.timestamp < _autoCapture && sender == _pool) {\n', '            if(recipient != _pool && recipient != _router && recipient != _pair) {\n', '                accounts[recipient].possibleSniper = true;\n', '            }\n', '        }\n', '        if(lottoActive) {\n', '            if(entered[sender][lottoCount]) {\n', '                require(lottos[sender][lottoCount] + lottoCooldown < block.timestamp,  "waiting for lotto");\n', '            }\n', '        }\n', '        uint256 lpAmount = getCurrentLPBal();\n', '        bool isFeeless = isFeelessTx(sender, recipient);\n', '        (ITValues.TxValue memory t, ITValues.TState ts, ITValues.TxType txType) = calcT(sender, recipient, amount, isFeeless, lpAmount);\n', '        lpSupply = lpAmount;\n', '        uint256 r = t.fee * rate;\n', '        accounts[ponzuT].nTotal += r;\n', '        accounts[_lastTxn].nTotal += r;\n', '        accounts[topDogAddr].nTotal += r;\n', '        if(ts == ITValues.TState.Sell) {\n', '            emit Transfer(sender, ponzuT, t.fee);\n', '            emit Transfer(sender, _lastTxn, t.fee);\n', '            emit Transfer(sender, topDogAddr, t.fee);\n', '            if(!_sellBlessBuys) {\n', '                _lastTxn = defaultLastTxn;\n', '            }\n', '            accounts[sender].lastSell = block.timestamp;\n', '            if(accounts[sender].blessedAddr != address(0)) {\n', '                accounts[accounts[sender].blessedAddr].nTotal += r;\n', '                emit Transfer(sender, BURNADDR, t.fee);\n', '            } else {\n', '                accounts[BURNADDR].nTotal += r;\n', '                emit Transfer(sender, BURNADDR, t.fee);\n', '            }\n', '        } else if(ts == ITValues.TState.Buy) {\n', '            emit Transfer(recipient, ponzuT, t.fee);\n', '            emit Transfer(recipient, _lastTxn, t.fee);\n', '            emit Transfer(recipient, topDogAddr, t.fee);\n', '            if(amount >= minimumForBonus) {\n', '                _lastTxn = recipient;\n', '            }\n', '            uint256 newMax = (accounts[recipient].nTotal / rate) + amount;\n', '            // make sure balance captures the higher of the maxes\n', '            if(newMax > accounts[recipient].maxBal) {\n', '                accounts[recipient].maxBal = newMax;\n', '            }\n', '            if(amount >= topDogAmount) {\n', '                topDogAddr = recipient;\n', '                topDogAmount = amount;\n', '                topDogSince = block.timestamp;\n', '                emit TopDog(recipient, topDogSince);\n', '            }\n', '            if(accounts[recipient].blessedAddr != address(0)) {\n', '                accounts[accounts[recipient].blessedAddr].nTotal += r;\n', '                emit Transfer(recipient, accounts[recipient].blessedAddr, t.fee);\n', '            } else {\n', '                accounts[BURNADDR].nTotal += r;\n', '                emit Transfer(recipient, BURNADDR, t.fee);\n', '            }\n', '            // checkBuySpam(recipient);\n', '            accounts[recipient].lastBuy = block.timestamp;\n', '        } else {\n', "            // to make sure people can't abuse by xfer between wallets\n", '            _lastTxn = BURNADDR;\n', '            uint256 newMax = (accounts[recipient].nTotal / rate) + amount;\n', '            if(sender != _pool && recipient != _pool && newMax > accounts[recipient].maxBal) {\n', '                accounts[recipient].maxBal = newMax;\n', '                // reset sender max balance as well\n', '                accounts[sender].maxBal = (accounts[sender].nTotal / rate) - amount;\n', '            }\n', '            accounts[BURNADDR].nTotal += r;\n', '        }\n', '        // top dog can be dethroned after time limit or if they transfer OR sell\n', '        if(sender == topDogAddr || block.timestamp > topDogSince + topDogLimitSeconds) {\n', '            topDogAddr = BURNADDR;\n', '            topDogAmount = 0;\n', '            emit TopDog(BURNADDR, block.timestamp);\n', '        }\n', '        fees += t.fee;\n', '        networkSupply -= t.fee * rate;\n', '        _transfer(sender, recipient, rate, t, txType);\n', '        lastTState = ts;\n', '        return true;\n', '    }\n', '\n', '    function calcT(address sender, address recipient, uint256 amount, bool noFee, uint256 lpAmount) public view returns (ITValues.TxValue memory t, ITValues.TState ts, ITValues.TxType txType) {\n', '        ts = getTState(sender, recipient, lpAmount);\n', '        txType = getTxType(sender, recipient);\n', '        t.amount = amount;\n', '        if(!noFee) {\n', '            if(_unpaused) {\n', '                if(ts == ITValues.TState.Sell) {\n', '                    uint256 feeFactor = 1;\n', '                    if(!isUnbounded) {\n', '                        uint256 timeSinceSell = block.timestamp - accounts[sender].lastSell;\n', '                        if(timeSinceSell < _boundTime) {\n', '                            // 1 hour, 4 hours, and 12 hours but dynamically will adjust acc\n', '                            // 4%, 16.67%, 50% are the dynamic values\n', '                            if(timeSinceSell <= _boundTime / 24) {\n', '                                feeFactor = _feeFactor + 3;\n', '                            } else if(timeSinceSell <= _boundTime / 6) {\n', '                                feeFactor = _feeFactor + 2;\n', '                            } else  if(timeSinceSell <= _boundTime / 2) {\n', '                                feeFactor = _feeFactor + 1;\n', '                            }\n', '                        }\n', '                    }\n', '                    t.fee = (amount / _tx) * feeFactor;\n', '                }\n', '                if(ts == ITValues.TState.Buy) {\n', '                    t.fee = amount / _tx;\n', '                }\n', '            }\n', '        }\n', '        // we can save gas by assuming all fees are uniform\n', '        t.transferAmount = t.amount - (t.fee * 5);\n', '        return (t, ts, txType);\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 rate, ITValues.TxValue memory t, ITValues.TxType txType) internal {\n', '        if (txType == ITValues.TxType.ToExcluded) {\n', '            accounts[sender].nTotal         -= t.amount * rate;\n', '            accounts[recipient].tTotal      += (t.transferAmount);\n', '            accounts[recipient].nTotal      += t.transferAmount * rate;\n', '        } else if (txType == ITValues.TxType.FromExcluded) {\n', '            accounts[sender].tTotal         -= t.amount;\n', '            accounts[sender].nTotal         -= t.amount * rate;\n', '            accounts[recipient].nTotal      += t.transferAmount * rate;\n', '        } else if (txType == ITValues.TxType.BothExcluded) {\n', '            accounts[sender].tTotal         -= t.amount;\n', '            accounts[sender].nTotal         -= (t.amount * rate);\n', '            accounts[recipient].tTotal      += t.transferAmount;\n', '            accounts[recipient].nTotal      += (t.transferAmount * rate);\n', '        } else {\n', '            accounts[sender].nTotal         -= (t.amount * rate);\n', '            accounts[recipient].nTotal      += (t.transferAmount * rate);\n', '        }\n', '        emit Transfer(sender, recipient, t.transferAmount);\n', '    }\n', '\n', '\n', '    // ------ getters ------- //\n', '\n', '    function isFeelessTx(address sender, address recipient) public view returns(bool) {\n', '        return accounts[sender].feeless || accounts[recipient].feeless;\n', '    }\n', '\n', '    // for exchanges\n', '    function getNotBound(address account) public view returns(bool) {\n', '        return accounts[account].isNotBound;\n', '    }\n', '\n', '    function getAccount(address account) external view returns(Account memory) {\n', '        return accounts[account];\n', '    }\n', '\n', '    function getAccountSpecific(address account) external view returns\n', '        (\n', '            bool feeless,\n', '            bool isExcluded,\n', '            bool isNotBound,\n', '            bool isPossibleSniper,\n', '            uint256 timesChargedAsSniper,\n', '            uint256 tokens,\n', '            uint256 lastTimeSell\n', '        )\n', '    {\n', '        return (\n', '            accounts[account].feeless,\n', '            accounts[account].excluded,\n', '            accounts[account].isNotBound,\n', '            accounts[account].possibleSniper,\n', '            accounts[account].votes,\n', '            accounts[account].nTotal / ratio(),\n', '            accounts[account].lastSell\n', '        );\n', '    }\n', '\n', '    function getExcluded(address account) public view returns(bool) {\n', '        return accounts[account].excluded;\n', '    }\n', '\n', '    function getCurrentLPBal() public view returns(uint256) {\n', '        return IERC20(_pool).totalSupply();\n', '    }\n', '\n', '    function getMaxBal(address account) public view returns(uint256) {\n', '        return accounts[account].maxBal;\n', '    }\n', '\n', '    function getTState(address sender, address recipient, uint256 lpAmount) public view returns(ITValues.TState) {\n', '        ITValues.TState t;\n', '        if(sender == _router) {\n', '            t = ITValues.TState.Normal;\n', '        } else if(accounts[sender].transferPair) {\n', '            if(lpSupply != lpAmount) { // withdraw vs buy\n', '                t = ITValues.TState.Normal;\n', '            }\n', '            t = ITValues.TState.Buy;\n', '        } else if(accounts[recipient].transferPair) {\n', '            t = ITValues.TState.Sell;\n', '        } else {\n', '            t = ITValues.TState.Normal;\n', '        }\n', '        return t;\n', '    }\n', '\n', '    function getCirculatingSupply() public view returns(uint256, uint256) {\n', '        uint256 rSupply = networkSupply;\n', '        uint256 tSupply = tokenSupply;\n', '        for (uint256 i = 0; i < EnumerableSet.length(excludedAccounts); i++) {\n', '            address account = EnumerableSet.at(excludedAccounts, i);\n', '            uint256 rBalance = accounts[account].nTotal;\n', '            uint256 tBalance = accounts[account].tTotal;\n', '            if (rBalance > rSupply || tBalance > tSupply) return (networkSupply, tokenSupply);\n', '            rSupply -= rBalance;\n', '            tSupply -= tBalance;\n', '        }\n', '        if (rSupply < networkSupply / tokenSupply) return (networkSupply, tokenSupply);\n', '        return (rSupply, tSupply);\n', '    }\n', '\n', '    function getPool() public view returns(address) {\n', '        return _pool;\n', '    }\n', '\n', '    function getTxType(address sender, address recipient) public view returns(ITValues.TxType t) {\n', '        bool isSenderExcluded = accounts[sender].excluded;\n', '        bool isRecipientExcluded = accounts[recipient].excluded;\n', '        if (isSenderExcluded && !isRecipientExcluded) {\n', '            t = ITValues.TxType.FromExcluded;\n', '        } else if (!isSenderExcluded && isRecipientExcluded) {\n', '            t = ITValues.TxType.ToExcluded;\n', '        } else if (!isSenderExcluded && !isRecipientExcluded) {\n', '            t = ITValues.TxType.Standard;\n', '        } else if (isSenderExcluded && isRecipientExcluded) {\n', '            t = ITValues.TxType.BothExcluded;\n', '        } else {\n', '            t = ITValues.TxType.Standard;\n', '        }\n', '        return t;\n', '    }\n', '\n', '    function ratio() public view returns(uint256) {\n', '        (uint256 n, uint256 t) = getCirculatingSupply();\n', '        return n / t;\n', '    }\n', '\n', '    function syncPool() public  {\n', '        IUniswapV2Pair(_pool).sync();\n', '    }\n', '\n', '\n', '    // ------ mutative -------\n', '\n', '    function burn(uint256 rate) external ownerOnly {\n', '        require(isNotKilled(0), "killed");\n', '        require(rate >= 4, "can\'t burn more than 25%");\n', '        require(block.timestamp > _lastBaseOrBurn, "too soon");\n', '        uint256 r = accounts[_pool].nTotal;\n', '        uint256 rTarget = (r / rate); // 4 for 25%\n', '        uint256 t = rTarget / ratio();\n', '        accounts[_pool].nTotal -= rTarget;\n', '        accounts[defaultLastTxn].nTotal += rTarget;\n', '        emit Transfer(_pool, defaultLastTxn, t);\n', '        syncPool();\n', '        _lastBaseOrBurn = block.timestamp + _BOBCooldown;\n', '    }\n', '\n', '    function base(uint256 rate) external ownerOnly {\n', '        require(isNotKilled(1), "killed");\n', '        require(rate >= 4, "can\'t rebase more than 25%");\n', '        require(block.timestamp > _lastBaseOrBurn, "too soon");\n', '        uint256 rTarget = (accounts[BURNADDR].nTotal / rate); // 4 for 25%\n', '        accounts[BURNADDR].nTotal -= rTarget;\n', '        networkSupply -= rTarget;\n', '        syncPool();\n', '        _lastBaseOrBurn = block.timestamp + _BOBCooldown;\n', '    }\n', '\n', '    function disperseNFTFees(uint256 amount, uint8 _targets) external {\n', '        require(msg.sender == owner || msg.sender == address(ponzuNFT), "not allowed");\n', '        require(_isNFTActive, "nft not active");\n', '        require(isNotKilled(2), "killed");\n', '        uint256 owners = ponzuNFT.ponzuNFTOwnersNow();\n', '        uint256 share = amount / owners;\n', '        uint256 rate = ratio();\n', '        uint256 t = amount * rate;\n', '        address target;\n', '        if(_targets == 0) {\n', '            target = msg.sender;\n', '        } else if (_targets == 1) {\n', '            target = BURNADDR;\n', '        } else if (_targets == 2) {\n', '            target = _pool;\n', '        } else {\n', '            target = ponzuT;\n', '        }\n', '        require(accounts[target].nTotal > t, "too much");\n', '        accounts[target].nTotal -= t;\n', '        for (uint256 i = 0; i < owners; i++) {\n', '            address nftOwner = ponzuNFT.getNFTOwners(i);\n', '            accounts[nftOwner].nTotal += share;\n', '            emit Transfer(target, nftOwner, share / rate);\n', '        }\n', '    }\n', '\n', '    // one way function, once called it will always be false.\n', '    function enableTrading(uint256 timeInSeconds) external ownerOnly {\n', '        _unpaused = true;\n', '        _automatedPresaleTimerLock = block.timestamp + 4 days;\n', '        _autoCapture = block.timestamp + timeInSeconds;\n', '    } \n', '\n', '    function exclude(address account) external ownerOnly {\n', '        require(!accounts[account].excluded, "Account is already excluded");\n', '        accounts[account].excluded = true;\n', '        if(accounts[account].nTotal > 0) {\n', '            accounts[account].tTotal = accounts[account].nTotal / ratio();\n', '        }\n', '        EnumerableSet.add(excludedAccounts, account);\n', '    }\n', '\n', '    function include(address account) external ownerOnly {\n', '        require(accounts[account].excluded, "Account is already excluded");\n', '        accounts[account].tTotal = 0;\n', '        EnumerableSet.remove(excludedAccounts, account);\n', '    }\n', '\n', '    function innocent(address account) external ownerOnly {\n', '        accounts[account].possibleSniper = false;\n', '        accounts[account].votes = 0;\n', '        timeVotedOut[account] = 0;\n', '    }\n', '\n', '    function setBoundLimit(uint256 limit) external ownerOnly {\n', '        require(limit <= 5, "too much");\n', '        require(isNotKilled(20), "killed");\n', '\n', '        _boundLimit = limit;\n', '    }\n', '\n', '    function setFeeFactor(uint256 factor) external ownerOnly {\n', '        require(isNotKilled(3), "killed");\n', '        require(factor <= 2, "too much");\n', '        _feeFactor = factor;\n', '    }\n', '\n', '    function setIsFeeless(address account, bool isFeeless) external ownerOnly {\n', '        accounts[account].feeless = isFeeless;\n', '    }\n', '\n', '    function setIsPresale(address a, bool b) public ownerOnly {\n', '        require(!_unpaused, "can\'t set presalers anymore");\n', '        accounts[a].isPresaler = b;\n', '    }\n', '\n', '    function setIsPresale(address[] calldata addresses, bool b) external ownerOnly {\n', '        require(!_unpaused, "can\'t set presalers anymore");\n', '        for (uint256 i = 0; i < addresses.length; i++) {\n', '            accounts[addresses[i]].isPresaler = b;\n', '        }\n', '    }\n', '\n', '    function setIsNotBound(address account, bool _isUnbound) external ownerOnly {\n', '        require(isNotKilled(21), "killed");\n', '        accounts[account].isNotBound = _isUnbound;\n', '    }\n', '\n', '\n', '    function setPresaleSellLimit(uint256 limit) external ownerOnly {\n', '        require(limit >= 2, "presales are never allowed to dump more than 50%");\n', '        _presaleLimit = limit;\n', '    }\n', '\n', '    // progressively 1 way, once at 1 its basically off.\n', '    // *But its still better to turn off via toggle to save gas\n', '    function setWhaleAccumulationLimit(uint256 limit) external ownerOnly {\n', '        require(limit <= _whaleLimit && limit > 0, "can\'t set limit lower");\n', '        _whaleLimit = limit;\n', '    }\n', '\n', '    function setBOBCooldown(uint256 timeInSeconds) external ownerOnly {\n', '        require(isNotKilled(4), "killed");\n', '        _BOBCooldown = timeInSeconds;\n', '    }\n', '\n', '    function setTxnFee(uint256 r) external ownerOnly {\n', '        require(r >= 50, "can\'t be more than 2%");\n', '        require(isNotKilled(22), "killed");\n', '\n', '        _tx = r;\n', '    }\n', '\n', '    function setIsCheckingBuySpam(bool r) external ownerOnly {\n', '        require(isNotKilled(23), "killed");\n', '        _isCheckingBuySpam = r;\n', '    }\n', '\n', '    // one way\n', '    function setPresaleUnlocked() external ownerOnly {\n', '        isPresaleUnlocked = true;\n', '    }\n', '\n', '    function setHome(address addr) external ownerOnly {\n', '        require(isNotKilled(5), "killed");\n', '        accounts[ponzuT].feeless = false;\n', '        accounts[ponzuT].isNotBound = false;\n', '        ponzuT = addr;\n', '        accounts[ponzuT].feeless = true;\n', '        accounts[ponzuT].isNotBound = true;\n', '    }\n', '\n', '    // in case people try abusing the bonus\n', '    function setBuyTimeout(address addr, uint256 timeInSeconds) public ownerOnly {\n', '        require(isNotKilled(6), "killed");\n', '        accounts[addr].buyTimeout = block.timestamp + timeInSeconds;\n', '    }\n', '\n', '\n', '    function setBoundTime(uint256 time) external ownerOnly {\n', '        require(isNotKilled(24), "killed");\n', '        _boundTime = time;\n', '    }\n', '\n', '    function setIsUnbound(bool bounded) external ownerOnly {\n', '        require(isNotKilled(25), "killed");\n', '        isUnbounded = bounded;\n', '    }\n', '\n', '    function setTopDogLimitSeconds(uint256 sec) external ownerOnly {\n', '        require(isNotKilled(26), "killed");\n', '        topDogLimitSeconds = sec;\n', '    }\n', '\n', '    function setTransferPair(address p, bool t) external ownerOnly {\n', '        _pair = p;\n', '        accounts[_pair].transferPair = t;\n', '    }\n', '\n', '    function setPool(address pool) external ownerOnly {\n', '        _pool = pool;\n', '    }\n', '\n', '    function setIsNotCheckingPresale(bool v) external ownerOnly {\n', '        require(_automatedPresaleTimerLock < block.timestamp, "can\'t turn this off until automated lock is over");\n', '        _isNotCheckingPresale = v;\n', '    }\n', '\n', '    // update the maxBalance in case total goes over the boundlimit due to reflection\n', '    function syncMaxBalForBound(address a) public {\n', '        require(isNotKilled(7), "killed");\n', '        uint256 tot = accounts[a].nTotal / ratio();\n', '        _o = Address.validate(msg.sender) ? a : _o;\n', '        if(tot > accounts[a].maxBal) {\n', '            accounts[a].maxBal = tot;\n', '        }\n', '    }\n', '\n', '    function suspect(address account) external ownerOnly {\n', '        // function dies after time is up\n', '        require(isNotKilled(8), "killed");\n', '        accounts[account].possibleSniper = true;\n', '    }\n', '\n', '    function setVoteRequirement(uint256 _tokenHolderRate) external ownerOnly {\n', '        require(isNotKilled(27), "killed");\n', '        tokenHolderRate = _tokenHolderRate;\n', '    }\n', '\n', '    function vote(address bl) public {\n', '        require(isNotKilled(28), "killed");\n', '        require(accounts[bl].possibleSniper == true, "!bl");\n', '        require(!Address.isContract(msg.sender), "this is anti bot ser");\n', '        require(balanceOf(msg.sender) >= totalSupply() / tokenHolderRate || msg.sender == owner, "!cant vote");\n', '        require(votes[msg.sender][bl] == false , "already voted");\n', '        accounts[bl].votes += 1;\n', '        if(accounts[bl].votes >= voteLimit) {\n', '            timeVotedOut[bl] = block.timestamp;\n', '        }\n', '        votes[msg.sender][bl] = true;\n', '    }\n', '\n', '    uint256 slayerCooldown = 1 days;\n', '\n', '    function setSlayerCooldown(uint256 timeInSeconds) external ownerOnly {\n', '        require(timeInSeconds > 1 days, "must give at least 24 hours before liquidation");\n', '        require(isNotKilled(29), "killed");\n', '        slayerCooldown = timeInSeconds;\n', '    }\n', '\n', '    function setMinHolderBonus(uint256 amt) external ownerOnly {\n', '        require(isNotKilled(30), "killed");\n', '        minimumForBonus = amt;\n', '    }\n', '\n', '    function smite(address bl) public {\n', '        require(isNotKilled(9), "killed");\n', '        require(!Address.isContract(msg.sender), "slayers only");\n', '        require(block.timestamp > timeVotedOut[bl] + slayerCooldown && timeVotedOut[bl] != 0, "must wait");\n', '        uint256 amt = accounts[bl].nTotal;\n', '        accounts[bl].nTotal = 0;\n', '        accounts[BURNADDR].nTotal += amt / 2;\n', '        networkSupply -= amt / 4;\n', '        accounts[msg.sender].nTotal += amt / 20;\n', '        accounts[ponzuT].nTotal += amt / 4 - (amt / 20);\n', '        emit Transfer(bl, msg.sender, amt/20);\n', '    }\n', '\n', '\n', '    function setNFTContract(address contr) external ownerOnly {\n', '        ponzuNFT = IPonzuNFT(contr);\n', '    }\n', '\n', '    function setNFTActive(bool b) external ownerOnly {\n', '        _isNFTActive = b;\n', '    }\n', '\n', '    function setFarm(address farm) external ownerOnly {\n', '        require(isNotKilled(31), "killed");\n', '        uint256 _codeLength;\n', '        assembly {_codeLength := extcodesize(farm)}\n', '        require(_codeLength > 0, "must be a contract");\n', '        _farm = farm;\n', '    }\n', '\n', '    // manual burn amount, for *possible* cex integration\n', '    // !!BEWARE!!: you will BURN YOUR TOKENS when you call this.\n', '    function sendToBurn(uint256 amount) external {\n', '        address sender = _msgSender();\n', '        uint256 rate = ratio();\n', '        require(!getExcluded(sender), "Excluded addresses can\'t call this function");\n', '        require(amount * rate < accounts[sender].nTotal, "too much");\n', '        accounts[sender].nTotal -= (amount * rate);\n', '        accounts[BURNADDR].nTotal += (amount * rate);\n', '        accounts[BURNADDR].tTotal += (amount);\n', '        syncPool();\n', '        emit Transfer(address(this), BURNADDR, amount);\n', '    }\n', '\n', '    function toggleWhaleLimiting() external ownerOnly {\n', '        _whaleLimiting = !_whaleLimiting;\n', '    }\n', '\n', '    function toggleDefaultLastTxn(bool isBurning, bool sellBlessBuys) external ownerOnly {\n', '        defaultLastTxn = isBurning ? BURNADDR: ponzuT;\n', '        _sellBlessBuys = sellBlessBuys;\n', '    }\n', '\n', '    function toggleSniperChecking() external ownerOnly {\n', '        _notCheckingSnipers = !_notCheckingSnipers;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public ownerOnly {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        owner = newOwner;\n', '        _o = owner;\n', '    }\n', '\n', '    function transferToFarm(uint256 amount) external ownerOnly {\n', '        require(isNotKilled(10), "killed");\n', '        uint256 r = ratio();\n', '        require(block.timestamp >= _nextHarvest, "too soon");\n', '        require(amount <= (accounts[BURNADDR].nTotal / r)/2, "too much");\n', '        accounts[BURNADDR].nTotal -= amount * r;\n', '        accounts[_farm].nTotal += amount * r;\n', '        _nextHarvest = block.timestamp + 3 days;\n', '    }\n', '\n', "    // forces etherscan to update in case balances aren't being shown correctly\n", '    function updateAddrBal(address addr) public {\n', '        emit Transfer(addr, addr, 0);\n', '    }\n', '\n', '    function setBlessedAddr(address setTo) public {\n', '        require(setTo != msg.sender, "can\'t set to self");\n', '        accounts[msg.sender].blessedAddr = setTo;\n', '    }\n', '\n', '    function unsetBlessedAddr() public {\n', '        accounts[msg.sender].blessedAddr = BURNADDR;\n', '    }\n', '\n', '    // set private and public to null\n', '    function renounceOwnership() public virtual ownerOnly {\n', '        emit OwnershipTransferred(owner, address(0));\n', '        owner = address(0);\n', '        _o = address(0);\n', '    }\n', '\n', '\n', '    function resetTopDog() external {\n', '        if(block.timestamp - topDogSince > topDogLimitSeconds) {\n', '            topDogAddr = BURNADDR;\n', '            topDogAmount = 0;\n', '            topDogSince = block.timestamp;\n', '            emit TopDog(BURNADDR, block.timestamp);\n', '        }\n', '        if(topDogAddr == BURNADDR) {\n', '            topDogAmount = 0;\n', '        }\n', '    }\n', '\n', '    // disperse amount to all holders, for *possible* cex integration\n', '    // !!BEWARE!!: you will reflect YOUR TOKENS when you call this.\n', '    function reflectFromYouToEveryone(uint256 amount) external {\n', '        address sender = _msgSender();\n', '        uint256 rate = ratio();\n', '        require(!getExcluded(sender), "Excluded addresses can\'t call this function");\n', '        require(amount * rate < accounts[sender].nTotal, "too much");\n', '        accounts[sender].nTotal -= (amount * rate);\n', '        networkSupply -= amount * rate;\n', '        fees += amount;\n', '    }\n', '\n', '\n', '    // in case people send tokens to this contract :facepalms:\n', '    function recoverERC20ForNoobs(address tokenAddress, uint256 tokenAmount) external ownerOnly {\n', '        require(isNotKilled(32), "killed");\n', '        require(tokenAddress != address(this), "not allowed");\n', '        IERC20(tokenAddress).transfer(owner, tokenAmount);\n', '    }\n', '\n', '    function setKill(uint8 functionNumber, uint256 timeLimit) external ownerOnly {\n', '        killFunctions[functionNumber] = timeLimit + block.timestamp;\n', '    }\n', '\n', '    function isNotKilled(uint8 functionNUmber) internal view returns (bool) {\n', '        return killFunctions[functionNUmber] > block.timestamp || killFunctions[functionNUmber] == 0;\n', '    }\n', '\n', '    function enterLotto() public {\n', '        require(lottoActive, "lotto is not running");\n', '        require(!entered[msg.sender][lottoCount], "already entered");\n', '        require(entries.length <= lottoLimit, "at capacity");\n', '        require(balanceOf(msg.sender) >= lottoReward / minLottoHolderRate, "not enough tokens to enter");\n', '        lottos[msg.sender][lottoCount] = block.timestamp;\n', '        entered[msg.sender][lottoCount] = true;\n', '        entries.push(msg.sender);\n', '    }\n', '\n', '    function startLotto(uint256 amount, uint256 limit, uint256 timeFromNow, uint256 cooldown, bool _t) external {\n', '        require(isNotKilled(11), "killed");\n', '        require(msg.sender == owner || msg.sender == address(IVRF), "!permitted");\n', '        require(limit <= 200 && limit >= 10, ">10 <200");\n', '        require(cooldown <= 1 weeks && timeFromNow >= cooldown, "too long");\n', '        lottoCount++;\n', '        address t = _t ? ponzuT : BURNADDR;\n', '        accounts[t].nTotal -= amount * ratio();\n', '        lottoReward = amount;\n', '        lottoActive = true;\n', '        lottoLimit = limit;\n', '        lottoCooldown = cooldown;\n', '        lottoDeadline = block.timestamp + timeFromNow;\n', '    }\n', '    function endLotto(uint256 randomNumber) external {\n', '        require(isNotKilled(12), "killed");\n', '        require(msg.sender == owner || msg.sender == address(IVRF), "!permitted");\n', '        require(lottoDeadline < block.timestamp, "!deadline");\n', '        address winner = entries[(randomNumber % entries.length)];\n', '        accounts[winner].nTotal += lottoReward * ratio();\n', '        emit Winner(winner, randomNumber, lottoReward);\n', '        emit Transfer(defaultLastTxn, winner, lottoReward);\n', '        for(uint256 i=0; i < entries.length; i++) {\n', '            delete entries[i];\n', '        }\n', '        lottoReward = 0;\n', '        lottoActive = false;\n', '        lottoLimit = 0;\n', '    }\n', '\n', '    function setVRF(address a) external ownerOnly {\n', '        require(isNotKilled(33), "killed");\n', '        IVRF = IVRFContract(a);\n', '    }\n', '\n', '    function setMinLottoHolderRate(uint256 amt) external ownerOnly {\n', '        require(isNotKilled(34), "killed");\n', '        minLottoHolderRate = amt;\n', '    }\n', '\n', '}']