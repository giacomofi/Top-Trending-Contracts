['pragma solidity 0.5.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../Ownable.sol";\n', 'import "./ERC1155Minter.sol";\n', 'import "../IERC20.sol";\n', 'import "../LPTokenWrapper.sol";\n', '\n', '\n', 'contract LPGenesisPoolGame is LPTokenWrapper, Ownable {\n', '    uint256 public constant MAX_STAKE = 2020000000000000000;\n', '    ERC1155Minter public gameMinter;\n', '\n', '    uint256 public gameStartTime;\n', '    uint256 public rewardNeeded;\n', '    uint256 public width;\n', '    string public url;\n', '    mapping(address => uint256) public lastUpdateTime;\n', '    mapping(address => uint256) public points;\n', '\n', '    event GameStarted(uint256 gameStartTime, uint256 rewardNeeded);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event Created(address indexed user, uint256 indexed id, uint256 x, uint256 y);\n', '\n', '    modifier updateReward(address account) {\n', '        if (account != address(0)) {\n', '            points[account] = earned(account);\n', '            lastUpdateTime[account] = block.timestamp;\n', '        }\n', '        _;\n', '    }\n', '\n', '    constructor(ERC1155Minter _gameMinter, IERC20 _erc20Address) public LPTokenWrapper(_erc20Address) {\n', '        gameMinter = _gameMinter;\n', '    }\n', '\n', '    function start(uint256 _gameStartTime, uint256 _amount, uint256 _imageWidth, string memory _url) public onlyOwner {\n', '        require(gameStartTime == 0,  "Already started");\n', '        require(block.timestamp <= _gameStartTime, "Only future time to start");\n', '\n', '        gameStartTime = _gameStartTime;\n', '        rewardNeeded = _amount;\n', '        width =_imageWidth;\n', '        url = _url;\n', '        emit GameStarted(_gameStartTime, _amount);\n', '    }\n', '\n', '    function earned(address account) public view returns (uint256) {\n', '        uint256 blockTime = block.timestamp;\n', '        return\n', '            points[account].add(\n', '                (blockTime.sub(lastUpdateTime[account]).mul(1e18).div(86400).mul(\n', '                    (balanceOf(account).mul(10000)).div(1e18)\n', '                //1 point equals 2.02 LP tokens per day\n', '                )).div(20200)\n', '            );\n', '    }\n', '\n', "    // stake visibility is public as overriding LPTokenWrapper's stake() function\n", '    function stake(uint256 amount) public updateReward(msg.sender) {\n', '        require(gameStartTime != 0,  "Not started yet");\n', '        require(amount.add(balanceOf(msg.sender)) <= MAX_STAKE, "Cannot stake more than 2.02 UNI-V2 LP");\n', '\n', '        super.stake(amount);\n', '        emit Staked(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint256 amount) public updateReward(msg.sender) {\n', '        require(amount > 0, "Cannot withdraw 0");\n', '\n', '        super.withdraw(amount);\n', '        emit Withdrawn(msg.sender, amount);\n', '    }\n', '\n', '    function exit() external {\n', '        withdraw(balanceOf(msg.sender));\n', '    }\n', '\n', '    function redeem(uint256 _xPoint, uint256 _yPoint) public updateReward(msg.sender) {\n', '        require(gameStartTime != 0,  "Not started yet");\n', '        require(points[msg.sender] >= rewardNeeded, "Not enough points to play");\n', '\n', '        points[msg.sender] = points[msg.sender].sub(rewardNeeded);\n', '        uint256 _id = _generateId(_xPoint, _yPoint, width);\n', '        gameMinter.create(msg.sender, 1, 1, _id, uint64(_xPoint), uint64(_yPoint), "0x");\n', '        emit Created(msg.sender, _id, _xPoint, _yPoint);\n', '    }\n', '\n', '    function _generateId(uint256 _xPoint, uint256 _yPoint, uint256 _width) internal view returns(uint256) {\n', '        uint256 id = _width * _yPoint + _xPoint;\n', '        require(gameMinter.creators(id) == address(0), "Id already used");\n', '        return id;\n', '    }\n', '}']