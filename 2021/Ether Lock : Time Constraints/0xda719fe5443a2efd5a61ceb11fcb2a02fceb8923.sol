['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-08\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', 'pragma solidity 0.4.25;\n', '\n', '/**\n', ' * token contract functions\n', '*/\n', 'contract Ierc20 {\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function approveAndCall(address spender, uint tokens, bytes data) external returns (bool success);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a);\n', '    return c;\n', '  }\n', '\n', '  function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n', '    uint256 c = add(a,m);\n', '    uint256 d = sub(c,1);\n', '    return mul(div(d,m),m);\n', '  }\n', '}\n', '\n', 'contract Owned {\n', '        address public owner;\n', '        event OwnerChanges(address newOwner);\n', '        \n', '        constructor() public {\n', '            owner = msg.sender;\n', '        }\n', '\n', '        modifier onlyOwner {\n', '            require(msg.sender == owner);\n', '            _;\n', '        }\n', '\n', '        function transferOwnership(address newOwner) onlyOwner external {\n', '            require(newOwner != address(0), "New owner is the zero address");\n', '            owner = newOwner;\n', '            emit OwnerChanges(newOwner);\n', '        }\n', '}\n', '\n', 'contract StakingPool is Owned {\n', '    using SafeMath for uint256;\n', '    \n', '    Ierc20 public tswap;\n', '    Ierc20 public rewardToken;\n', '    uint256 poolDuration;\n', '    uint256 totalRewards;\n', '    uint256 rewardsWithdrawn;\n', '    uint256 poolStartTime;\n', '    uint256 poolEndTime;\n', '    uint256 totalStaked;\n', '    // Represents a single stake for a user. A user may have multiple.\n', '    struct Stake {\n', '        uint256 amount;\n', '        uint256 stakingTime;\n', '        uint256 lastWithdrawTime;\n', '    }\n', '    mapping (address => Stake[]) public userStaking;\n', '    \n', '    // Represents total staking of an user\n', '    struct UserTotals {\n', '        uint256 totalStaking;\n', '        uint256 totalStakingTIme;\n', '    }\n', '    mapping (address => UserTotals) public userTotalStaking;\n', '    \n', '    struct Ris3Rewards {\n', '        uint256 totalWithdrawn;\n', '        uint256 lastWithdrawTime;\n', '    }\n', '    mapping(address => Ris3Rewards) public userRewardInfo;\n', '    \n', '    event OwnerSetReward(uint256 amount);\n', '    event Staked(address userAddress, uint256 amount);\n', '    event StakingWithdrawal(address userAddress, uint256 amount);\n', '    event RewardWithdrawal(address userAddress, uint256 amount);\n', '    event PoolDurationChange(uint256 poolDuration);\n', '    \n', '    /**\n', '     * Constrctor function\n', '    */\n', '    constructor() public {\n', '        tswap = Ierc20(0xCC4304A31d09258b0029eA7FE63d032f52e44EFe);\n', '        rewardToken = Ierc20(0x8D717AB5eaC1016b64C2A7fD04720Fd2D27D1B86);\n', '        poolDuration = 720 hours;\n', '    }\n', '    \n', '    //Set pool rewards\n', '    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n', '        require(poolStartTime == 0, "Pool rewards already set");\n', '        require(_rewardAmount > 0, "Cannot create pool with zero amount");\n', '        \n', '        //set total rewards value\n', '        totalRewards = _rewardAmount;\n', '        \n', '        poolStartTime = now;\n', '        poolEndTime = now + poolDuration;\n', '        \n', '        //transfer tokens to contract\n', '        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n', '        emit OwnerSetReward(_rewardAmount);\n', '    }\n', '    \n', '    //Stake function for users to stake SWAP token\n', '    function stake(uint256 amount) external {\n', '        require(amount > 0, "Cannot stake 0");\n', '        require(now < poolEndTime, "Staking pool is closed"); //staking pool is closed for staking\n', '        \n', '        //add value in staking\n', '        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n', '        \n', '        //add new stake\n', '        Stake memory newStake = Stake(amount, now, 0);\n', '        userStaking[msg.sender].push(newStake);\n', '        \n', '        //add to total staked\n', '        totalStaked = totalStaked.add(amount);\n', '        \n', '        tswap.transferFrom(msg.sender, this, amount);\n', '        emit Staked(msg.sender, amount);\n', '    }\n', '    \n', '    //compute rewards\n', '    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n', '        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n', '        if (rewardPerSecond != 0 ) {\n', '            rewardPerSecond = rewardPerSecond.div(poolDuration);\n', '        }\n', '        \n', '        if (rewardPerSecond > 0) {\n', '            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n', '            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n', '                    userRewards = userRewards.div(1 ether);\n', '            \n', '            return _rewardAmount.add(userRewards);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    //calculate your rewards\n', '    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n', '        // all user stakes\n', '        Stake[] storage accountStakes = userStaking[_userAddress];\n', '        \n', '        // Redeem from most recent stake and go backwards in time.\n', '        uint256 rewardAmount = 0;\n', '        uint256 i = accountStakes.length;\n', '        while (i > 0) {\n', '            Stake storage userStake = accountStakes[i - 1];\n', '            uint256 stakeTimeSec;\n', '            \n', '            //check if current time is more than pool ending time\n', '            if (now > poolEndTime) {\n', '                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n', '                if(userStake.lastWithdrawTime != 0){\n', '                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n', '                }\n', '            } else {\n', '                stakeTimeSec = now.sub(userStake.stakingTime);\n', '                if(userStake.lastWithdrawTime != 0){\n', '                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n', '                }\n', '            }\n', '            \n', '            // fully redeem a past stake\n', '            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n', '            i--;\n', '        }\n', '        \n', '        return rewardAmount;\n', '    }\n', '    \n', '    //Withdraw staking and rewards\n', '    function withdrawStaking(uint256 amount) external {\n', '        require(amount > 0, "Amount can not be zero");\n', '        require(userTotalStaking[msg.sender].totalStaking >= amount, "You are trying to withdaw more than your stake");\n', '        \n', '        // 1. User Accounting\n', '        Stake[] storage accountStakes = userStaking[msg.sender];\n', '        \n', '        // Redeem from most recent stake and go backwards in time.\n', '        uint256 sharesLeftToBurn = amount;\n', '        uint256 rewardAmount = 0;\n', '        while (sharesLeftToBurn > 0) {\n', '            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n', '            uint256 stakeTimeSec;\n', '            //check if current time is more than pool ending time\n', '            if (now > poolEndTime) {\n', '                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n', '                if(lastStake.lastWithdrawTime != 0){\n', '                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n', '                }\n', '            } else {\n', '                stakeTimeSec = now.sub(lastStake.stakingTime);\n', '                if(lastStake.lastWithdrawTime != 0){\n', '                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n', '                }\n', '            }\n', '            \n', '            if (lastStake.amount <= sharesLeftToBurn) {\n', '                // fully redeem a past stake\n', '                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n', '                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n', '                accountStakes.length--;\n', '            } else {\n', '                // partially redeem a past stake\n', '                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n', '                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n', '                lastStake.lastWithdrawTime = now;\n', '                sharesLeftToBurn = 0;\n', '            }\n', '        }\n', '        \n', '        //substract value in staking\n', '        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n', '        \n', '        //substract from total staked\n', '        totalStaked = totalStaked.sub(amount);\n', '        \n', '        //update user rewards info\n', '        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n', '        userRewardInfo[msg.sender].lastWithdrawTime = now;\n', '        \n', '        //update total rewards withdrawn\n', '        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n', '        \n', '        //transfer rewards and tokens\n', '        rewardToken.transfer(msg.sender, rewardAmount);\n', '        tswap.transfer(msg.sender, amount);\n', '        \n', '        emit RewardWithdrawal(msg.sender, rewardAmount);\n', '        emit StakingWithdrawal(msg.sender, amount);\n', '    }\n', '    \n', '    //Withdraw rewards\n', '    function withdrawRewardsOnly() external {\n', '        uint256 _rwdAmount = calculateReward(msg.sender);\n', '        require(_rwdAmount > 0, "You do not have enough rewards");\n', '        \n', '        // 1. User Accounting\n', '        Stake[] storage accountStakes = userStaking[msg.sender];\n', '        \n', '        // Redeem from most recent stake and go backwards in time.\n', '        uint256 rewardAmount = 0;\n', '        uint256 i = accountStakes.length;\n', '        while (i > 0) {\n', '            Stake storage userStake = accountStakes[i - 1];\n', '            uint256 stakeTimeSec;\n', '            \n', '            //check if current time is more than pool ending time\n', '            if (now > poolEndTime) {\n', '                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n', '                if(userStake.lastWithdrawTime != 0){\n', '                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n', '                }\n', '            } else {\n', '                stakeTimeSec = now.sub(userStake.stakingTime);\n', '                if(userStake.lastWithdrawTime != 0){\n', '                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n', '                }\n', '            }\n', '            \n', '            // fully redeem a past stake\n', '            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n', '            userStake.lastWithdrawTime = now;\n', '            i--;\n', '        }\n', '        \n', '        //update user rewards info\n', '        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n', '        userRewardInfo[msg.sender].lastWithdrawTime = now;\n', '        \n', '        //update total rewards withdrawn\n', '        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n', '        \n', '        //transfer rewards\n', '        rewardToken.transfer(msg.sender, rewardAmount);\n', '        emit RewardWithdrawal(msg.sender, rewardAmount);\n', '    }\n', '    \n', '    //get staking details by user address\n', '    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n', '        return userTotalStaking[_userAddress].totalStaking;\n', '    }\n', '    \n', '    //get total rewards collected by user\n', '    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n', '    {\n', '        return userRewardInfo[userAddress].totalWithdrawn;\n', '    }\n', '    \n', '    //get total SWAP token staked in the contract\n', '    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n', '        return totalStaked;\n', '    }\n', '    \n', '    //get total rewards in the contract\n', '    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n', '        return totalRewards;\n', '    }\n', '    \n', '    //get pool details\n', '    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n', '        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n', '    }\n', '    \n', '    //get duration of pools\n', '    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n', '        return poolDuration;\n', '    }\n', '\n', '    //set duration of pools by owner in seconds\n', '    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n', '        poolDuration = _poolDuration;\n', '        poolEndTime = poolStartTime + _poolDuration;\n', '        emit PoolDurationChange(_poolDuration);\n', '    }\n', '    \n', '    //get SWAP token address\n', '    function getSwapAddress() external constant returns (address _swapAddress) {\n', '        return address(tswap);\n', '    }\n', '    \n', '    //set tswap address\n', '    function setTswapAddress(address _address) external onlyOwner {\n', '        tswap = Ierc20(_address);\n', '    }\n', '    \n', '    //set reward token address\n', '    function setRewardTokenAddress(address _address) external onlyOwner {\n', '        rewardToken = Ierc20(_address);\n', '    }\n', '    \n', '}']