['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-13\n', '*/\n', '\n', '// Liquidity contract with pegged value\n', 'pragma solidity 0.5.16;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see `ERC20Detailed`.\n', ' */\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract Context {\n', '    constructor() internal {}\n', '\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    constructor() internal {\n', '        _owner = _msgSender();\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(\n', '            newOwner != address(0),\n', '            "Ownable: new owner is the zero address"\n', '        );\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract Liquidity_v8 is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * @dev Structs to store user staking data.\n', '     */\n', '    struct Deposits {\n', '        uint256 depositAmount;\n', '        uint256 depositTime;\n', '        uint256 endTime;\n', '        uint64 userIndex;\n', '        bool paid;\n', '    }\n', '\n', '    /**\n', '     * @dev Structs to store interest rate change.\n', '     */\n', '    struct Rates {\n', '        uint64 newInterestRate;\n', '        uint256 timeStamp;\n', '    }\n', '\n', '    mapping(address => bool) private hasStaked;\n', '    mapping(address => Deposits) private deposits;\n', '    mapping(uint64 => Rates) public rates;\n', '\n', '    string public name;\n', '    address public tokenAddress;\n', '    address public rewardTokenAddress;\n', '    uint256 public stakedTotal;\n', '    uint256 public totalReward;\n', '    uint256 public rewardBalance;\n', '    uint256 public stakedBalance;\n', '    uint64 public rate;\n', '    uint64 public index;\n', '    uint256 public lockDuration;\n', '\n', '    IERC20 public ERC20Interface;\n', '\n', '    /**\n', "     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n", '     */\n', '    event Staked(\n', '        address indexed token,\n', '        address indexed staker_,\n', '        uint256 stakedAmount_\n', '    );\n', '\n', '    /**\n', '     * @dev Emitted when user withdraws his stakings\n', '     */\n', '    event PaidOut(\n', '        address indexed token,\n', '        address indexed rewardToken,\n', '        address indexed staker_,\n', '        uint256 amount_,\n', '        uint256 reward_\n', '    );\n', '\n', '    /**\n', '     *   @param\n', '     *   name_ name of the contract\n', '     *   tokenAddress_ contract address of the token\n', '     *   rewardTokenAddress_ contract address of the reward token\n', '     *   rate_ rate multiplied by 100\n', '     *   lockduration_ duration in days\n', '     */\n', '    constructor(\n', '        string memory name_,\n', '        address tokenAddress_,\n', '        address rewardTokenAddress_,\n', '        uint64 rate_,\n', '        uint256 lockDuration_\n', '    ) public Ownable() {\n', '        name = name_;\n', '        require(tokenAddress_ != address(0), "Token address: 0 address");\n', '        tokenAddress = tokenAddress_;\n', '        require(\n', '            rewardTokenAddress_ != address(0),\n', '            "Reward token address: 0 address"\n', '        );\n', '        rewardTokenAddress = rewardTokenAddress_;\n', '        require(rate_ != 0, "Zero interest rate");\n', '        rate = rate_;\n', '        lockDuration = lockDuration_;\n', '        rates[index] = Rates(rate, block.timestamp);\n', '    }\n', '\n', '    /**\n', '     * @dev to set interest rates\n', '     */\n', '    function setRate(uint64 rate_) external onlyOwner {\n', '        require(rate_ != 0, "Zero interest rate");\n', '        index++;\n', '        rates[index] = Rates(rate_, block.timestamp);\n', '        rate = rate_;\n', '    }\n', '\n', '    /**\n', '     *  Requirements:\n', "     *  'lockduration_' lock days\n", '     *  @dev to set lock duration days\n', '     */\n', '    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n', '        lockDuration = lockduration_;\n', '    }\n', '\n', '    /**\n', '     * @dev to add rewards to the staking contract\n', "     * once the allowance is given to this contract for 'rewardAmount' by the user\n", '     */\n', '    function addReward(uint256 rewardAmount)\n', '        external\n', '        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n', '        returns (bool)\n', '    {\n', '        require(rewardAmount > 0, "Reward must be positive");\n', '        address from = msg.sender;\n', '        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n', '            return false;\n', '        }\n', '        totalReward = totalReward.add(rewardAmount);\n', '        rewardBalance = rewardBalance.add(rewardAmount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev returns user staking data\n', '     */\n', '    function userDeposits(address user)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            uint256,\n', '            bool\n', '        )\n', '    {\n', '        if (hasStaked[user]) {\n', '            return (\n', '                deposits[user].depositAmount,\n', '                deposits[user].depositTime,\n', '                deposits[user].endTime,\n', '                deposits[user].userIndex,\n', '                deposits[user].paid\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Requirements:\n', "     * - 'amount' Amount to be staked\n", '     /**\n', "     * @dev to stake 'amount' value of tokens \n", '     * once the user has given allowance to the staking contract\n', '     */\n', '    function stake(uint256 amount)\n', '        external\n', '        _hasAllowance(msg.sender, amount, tokenAddress)\n', '        returns (bool)\n', '    {\n', '        require(amount > 0, "Can\'t stake 0 amount");\n', '        address from = msg.sender;\n', '        require(!hasStaked[from], "Already staked");\n', '        return _stake(from, amount);\n', '    }\n', '\n', '    function _stake(address staker, uint256 amount) private returns (bool) {\n', '        if (!_payMe(staker, amount, tokenAddress)) {\n', '            return false;\n', '        }\n', '        hasStaked[staker] = true;\n', '        deposits[staker] = Deposits(\n', '            amount,\n', '            block.timestamp,\n', '            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n', '            index,\n', '            false\n', '        );\n', '        emit Staked(tokenAddress, staker, amount);\n', '\n', '        // Transfer is completed\n', '        stakedBalance = stakedBalance.add(amount);\n', '        stakedTotal = stakedTotal.add(amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev to withdraw user stakings after the lock period ends.\n', '     */\n', '    function withdraw() external returns (bool) {\n', '        address from = msg.sender;\n', '        require(hasStaked[from], "No stakes found for user");\n', '        require(\n', '            block.timestamp >= deposits[from].endTime,\n', '            "Requesting before lock time"\n', '        );\n', '        require(!deposits[from].paid, "Already paid out");\n', '\n', '        return (_withdraw(from));\n', '    }\n', '\n', '    function _withdraw(address from) private returns (bool) {\n', '        uint256 getPeggedBNF = getPeggedValue();\n', '        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n', '        uint256 amount = deposits[from].depositAmount;\n', '        require(reward <= rewardBalance, "Not enough rewards");\n', '\n', '        stakedBalance = stakedBalance.sub(amount);\n', '        rewardBalance = rewardBalance.sub(reward);\n', '        deposits[from].paid = true;\n', '        hasStaked[from] = false; //Check-Effects-Interactions pattern\n', '\n', '        bool principalPaid = _payDirect(from, amount, tokenAddress);\n', '        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n', '        require(principalPaid && rewardPaid, "Error paying");\n', '        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev to calculate the price of BNF per UNIv2 in the LP\n', '     */\n', '    function getPeggedValue() private returns (uint256) {\n', '        ERC20Interface = IERC20(tokenAddress);\n', '        uint256 getReserves;\n', '        if (ERC20Interface.token0() == rewardTokenAddress) {\n', '            (getReserves, , ) = ERC20Interface.getReserves();\n', '        } else {\n', '            (, getReserves, ) = ERC20Interface.getReserves();\n', '        }\n', '\n', '        uint256 totalSupply = ERC20Interface.totalSupply();\n', '        return (getReserves.mul(10**18).div(totalSupply));\n', '    }\n', '\n', '    function emergencyWithdraw() external returns (bool) {\n', '        address from = msg.sender;\n', '        require(hasStaked[from], "No stakes found for user");\n', '        require(\n', '            block.timestamp >= deposits[from].endTime,\n', '            "Requesting before lock time"\n', '        );\n', '        require(!deposits[from].paid, "Already paid out");\n', '\n', '        return (_emergencyWithdraw(from));\n', '    }\n', '\n', '    function _emergencyWithdraw(address from) private returns (bool) {\n', '        uint256 amount = deposits[from].depositAmount;\n', '        stakedBalance = stakedBalance.sub(amount);\n', '        deposits[from].paid = true;\n', '        hasStaked[from] = false; //Check-Effects-Interactions pattern\n', '\n', '        bool principalPaid = _payDirect(from, amount, tokenAddress);\n', '        require(principalPaid, "Error paying");\n', '        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @param\n', '     * from user wallet address\n', "     * @dev to calculate the rewards based on user staked 'amount'\n", '     */\n', '    function calculate(address from) external view returns (uint256) {\n', '        return _calculate(from);\n', '    }\n', '\n', '    function _calculate(address from) private view returns (uint256) {\n', '        if (!hasStaked[from]) return 0;\n', '        (\n', '            uint256 amount,\n', '            uint256 depositTime,\n', '            uint256 endTime,\n', '            uint64 userIndex\n', '        ) =\n', '            (\n', '                deposits[from].depositAmount,\n', '                deposits[from].depositTime,\n', '                deposits[from].endTime,\n', '                deposits[from].userIndex\n', '            );\n', '\n', '        uint256 time;\n', '        uint256 interest;\n', '        uint256 _lockduration = endTime.sub(depositTime);\n', '        for (uint64 i = userIndex; i < index; i++) {\n', '            //loop runs till the latest index/interest rate change\n', '            if (endTime < rates[i + 1].timeStamp) {\n', '                //if the change occurs after the endTime loop breaks\n', '                break;\n', '            } else {\n', '                time = rates[i + 1].timeStamp.sub(depositTime);\n', '                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n', '                    _lockduration.mul(10000)\n', '                ); //replace with (_lockduration * 10000)\n', '                amount += interest;\n', '                depositTime = rates[i + 1].timeStamp;\n', '                userIndex++;\n', '            }\n', '        }\n', '\n', '        if (depositTime < endTime) {\n', '            //final calculation for the remaining time period\n', '            time = endTime.sub(depositTime);\n', '\n', '            interest = time\n', '                .mul(amount)\n', '                .mul(rates[userIndex].newInterestRate)\n', '                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n', '\n', '            amount += interest;\n', '        }\n', '\n', '        return (interest);\n', '    }\n', '\n', '    function _payMe(\n', '        address payer,\n', '        uint256 amount,\n', '        address token\n', '    ) private returns (bool) {\n', '        return _payTo(payer, address(this), amount, token);\n', '    }\n', '\n', '    function _payTo(\n', '        address allower,\n', '        address receiver,\n', '        uint256 amount,\n', '        address token\n', '    ) private _hasAllowance(allower, amount, token) returns (bool) {\n', '        // Request to transfer amount from the contract to receiver.\n', '        // contract does not own the funds, so the allower must have added allowance to the contract\n', '        // Allower is the original owner.\n', '        ERC20Interface = IERC20(token);\n', '        return ERC20Interface.transferFrom(allower, receiver, amount);\n', '    }\n', '\n', '    function _payDirect(\n', '        address to,\n', '        uint256 amount,\n', '        address token\n', '    ) private returns (bool) {\n', '        ERC20Interface = IERC20(token);\n', '        return ERC20Interface.transfer(to, amount);\n', '    }\n', '\n', '    modifier _hasAllowance(\n', '        address allower,\n', '        uint256 amount,\n', '        address token\n', '    ) {\n', '        // Make sure the allower has provided the right allowance.\n', '        ERC20Interface = IERC20(token);\n', '        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n', '        require(amount <= ourAllowance, "Make sure to add enough allowance");\n', '        _;\n', '    }\n', '}']