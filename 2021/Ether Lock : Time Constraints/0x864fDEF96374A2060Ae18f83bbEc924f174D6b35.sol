['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-19\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'struct PoolParams {\n', '    string poolTokenSymbol;\n', '    string poolTokenName;\n', '    address[] constituentTokens;\n', '    uint256[] tokenBalances;\n', '    uint256[] tokenWeights;\n', '    uint256 swapFee;\n', '}\n', '\n', 'struct Rights {\n', '    bool canPauseSwapping;\n', '    bool canChangeSwapFee;\n', '    bool canChangeWeights;\n', '    bool canAddRemoveTokens;\n', '    bool canWhitelistLPs;\n', '    bool canChangeCap;\n', '}\n', '\n', 'library BalancerConstants {\n', '    uint256 public constant BONE = 10**18;\n', '}\n', '\n', 'interface IConfigurableRightsPool is IERC20 {\n', '    function whitelistLiquidityProvider(address provider) external;\n', '\n', '    function setController(address newOwner) external;\n', '    function getController() external returns (address);\n', '\n', '    function createPool(\n', '        uint256 initialSupply,\n', '        uint256 minimumWeightChangeBlockPeriodParam,\n', '        uint256 addTokenTimeLockInBlocksParam\n', '    ) external;\n', '\n', '    function updateWeightsGradually(\n', '        uint256[] calldata newWeights,\n', '        uint256 startBlock,\n', '        uint256 endBlock\n', '    ) external;\n', '\n', '    function bPool() external view returns (address);\n', '    function pokeWeights() external;\n', '    function setPublicSwap(bool) external;\n', '}\n', '\n', 'contract Sale {\n', '    IConfigurableRightsPool public immutable crpPool;\n', '\n', '    uint256 public immutable radTokenBalance;\n', '    uint256 public immutable usdcTokenBalance;\n', '\n', '    IERC20 public immutable radToken;\n', '    IERC20 public immutable usdcToken;\n', '\n', '    uint256 public constant RAD_END_WEIGHT = 20;\n', '    uint256 public constant USDC_END_WEIGHT = 20;\n', '\n', '    address lp;\n', '\n', '    constructor(\n', '        IConfigurableRightsPool _crpPool,\n', '        IERC20 _radToken,\n', '        IERC20 _usdcToken,\n', '        uint256 _radTokenBalance,\n', '        uint256 _usdcTokenBalance,\n', '        address _lp\n', '    ) {\n', '        crpPool = _crpPool;\n', '        radToken = _radToken;\n', '        usdcToken = _usdcToken;\n', '        radTokenBalance = _radTokenBalance;\n', '        usdcTokenBalance = _usdcTokenBalance;\n', '        lp = _lp;\n', '    }\n', '\n', '    /// Begin the sale. Transfers balances from the sender into the\n', '    /// Balancer pool, and transfers the pool tokens to the sender.\n', '    function begin(\n', '        uint256 minimumWeightChangeBlockPeriod,\n', '        uint256 weightChangeStartDelay,\n', '        address controller\n', '    ) public {\n', '        require(\n', '            msg.sender == lp,\n', '            "Sale::begin: only the LP can call this function"\n', '        );\n', '        require(\n', '            controller != address(0),\n', '            "Sale::begin: the controller must be set"\n', '        );\n', '        require(\n', '            radToken.transferFrom(msg.sender, address(this), radTokenBalance),\n', '            "Sale::begin: transfer of RAD must succeed"\n', '        );\n', '        require(\n', '            usdcToken.transferFrom(msg.sender, address(this), usdcTokenBalance),\n', '            "Sale::begin: transfer of USDC must succeed"\n', '        );\n', '        require(\n', '            crpPool.getController() == address(this),\n', '            "Sale::begin: sale must be controller"\n', '        );\n', '\n', '        radToken.approve(address(crpPool), radTokenBalance);\n', '        usdcToken.approve(address(crpPool), usdcTokenBalance);\n', '\n', '        // How many pool tokens to mint.\n', '        uint256 poolTokens = 100 * BalancerConstants.BONE;\n', '\n', '        crpPool.createPool(\n', '          poolTokens,\n', '          minimumWeightChangeBlockPeriod,\n', '          0\n', '        );\n', '\n', '        require(\n', '            crpPool.totalSupply() == poolTokens,\n', '            "Sale::begin: pool tokens must match total supply"\n', '        );\n', '\n', '        uint256[] memory endWeights = new uint256[](2);\n', '        endWeights[0] = RAD_END_WEIGHT * BalancerConstants.BONE;\n', '        endWeights[1] = USDC_END_WEIGHT * BalancerConstants.BONE;\n', '\n', '        // Start and end of the weight/price curve.\n', '        uint256 startBlock = block.number + weightChangeStartDelay;\n', '        uint256 endBlock = startBlock + minimumWeightChangeBlockPeriod;\n', '\n', '        // Kick-off the price curve.\n', '        crpPool.updateWeightsGradually(endWeights, startBlock, endBlock);\n', '        // Transfer ownership of the pool tokens to the sender.\n', '        crpPool.transfer(msg.sender, poolTokens);\n', '        // Set the pool controller, who can pause the sale.\n', '        crpPool.setController(controller);\n', '    }\n', '}']