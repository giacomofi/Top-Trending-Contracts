['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-18\n', '*/\n', '\n', '/*\n', 'https://powerpool.finance/\n', '\n', '          wrrrw r wrr\n', '         ppwr rrr wppr0       prwwwrp                                 prwwwrp                   wr0\n', '        rr 0rrrwrrprpwp0      pp   pr  prrrr0 pp   0r  prrrr0  0rwrrr pp   pr  prrrr0  prrrr0    r0\n', '        rrp pr   wr00rrp      prwww0  pp   wr pp w00r prwwwpr  0rw    prwww0  pp   wr pp   wr    r0\n', '        r0rprprwrrrp pr0      pp      wr   pr pp rwwr wr       0r     pp      wr   pr wr   pr    r0\n', '         prwr wrr0wpwr        00        www0   0w0ww    www0   0w     00        www0    www0   0www0\n', '          wrr ww0rrrr\n', '\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract ContextUpgradeSafe is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '\n', '\n', '    }\n', '\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/access/Ownable.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract OwnableUpgradeSafe is Initializable, ContextUpgradeSafe {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '\n', '\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.6.2;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/token/ERC20/SafeERC20.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'contract ReentrancyGuardUpgradeSafe is Initializable {\n', '    bool private _notEntered;\n', '\n', '\n', '    function __ReentrancyGuard_init() internal initializer {\n', '        __ReentrancyGuard_init_unchained();\n', '    }\n', '\n', '    function __ReentrancyGuard_init_unchained() internal initializer {\n', '\n', '\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// File: contracts/interfaces/ILpTokenMigrator.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// note "contracts-ethereum-package" (but not "contracts") version of the package\n', '\n', '\n', 'interface ILpTokenMigrator {\n', '  // Perform LP token migration from legacy UniswapV2 to PowerSwap.\n', '  // Take the current LP token address and return the new LP token address.\n', "  // Migrator should have full access to the caller's LP token.\n", '  // Return the new LP token address.\n', '  //\n', '  // XXX Migrator must have allowance access to UniswapV2 LP tokens.\n', '  // PowerSwap must mint EXACTLY the same amount of PowerSwap LP tokens or\n', '  // else something bad will happen. Traditional UniswapV2 does not\n', '  // do that so be careful!\n', '  function migrate(IERC20 token, uint8 poolType) external returns (IERC20);\n', '}\n', '\n', '// File: contracts/interfaces/IVestedLPMining.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @notice\n', ' */\n', 'interface IVestedLPMining {\n', '  /**\n', '   * @notice Initializes the storage of the contract\n', '   * @dev "constructor" to be called on a new proxy deployment\n', '   * @dev Sets the contract `owner` account to the deploying account\n', '   */\n', '  function initialize(\n', '    IERC20 _cvp,\n', '    address _reservoir,\n', '    uint256 _cvpPerBlock,\n', '    uint256 _startBlock,\n', '    uint256 _cvpVestingPeriodInBlocks\n', '  ) external;\n', '\n', '  function poolLength() external view returns (uint256);\n', '\n', '  /// @notice Add a new pool (only the owner may call)\n', '  function add(\n', '    uint256 _allocPoint,\n', '    IERC20 _lpToken,\n', '    uint8 _poolType,\n', '    bool _votesEnabled,\n', '    uint256 _lpBoostRate,\n', '    uint256 _cvpBoostRate,\n', '    uint256 _lpBoostMinRatio,\n', '    uint256 _lpBoostMaxRatio\n', '  ) external;\n', '\n', '  /// @notice Update parameters of the given pool (only the owner may call)\n', '  function set(\n', '    uint256 _pid,\n', '    uint256 _allocPoint,\n', '    uint8 _poolType,\n', '    bool _votesEnabled,\n', '    uint256 _lpBoostRate,\n', '    uint256 _cvpBoostRate,\n', '    uint256 _lpBoostMinRatio,\n', '    uint256 _lpBoostMaxRatio\n', '  ) external;\n', '\n', '  /// @notice Set the migrator contract (only the owner may call)\n', '  function setMigrator(ILpTokenMigrator _migrator) external;\n', '\n', '  /// @notice Set CVP reward per block (only the owner may call)\n', '  /// @dev Consider updating pool before calling this function\n', '  function setCvpPerBlock(uint256 _cvpPerBlock) external;\n', '\n', '  /// @notice Set CVP vesting period in blocks (only the owner may call)\n', '  function setCvpVestingPeriodInBlocks(uint256 _cvpVestingPeriodInBlocks) external;\n', '\n', '  function setCvpPoolByMetaPool(address _metaPool, address _cvpPool) external;\n', '\n', '  /// @notice Migrate LP token to another LP contract\n', '  function migrate(uint256 _pid) external;\n', '\n', '  /// @notice Return the amount of pending CVPs entitled to the given user of the pool\n', '  function pendingCvp(uint256 _pid, address _user) external view returns (uint256);\n', '\n', '  /// @notice Return the amount of CVP tokens which may be vested to a user of a pool in the current block\n', '  function vestableCvp(uint256 _pid, address user) external view returns (uint256);\n', '\n', '  /// @notice Return `true` if the LP Token is added to created pools\n', '  function isLpTokenAdded(IERC20 _lpToken) external view returns (bool);\n', '\n', '  /// @notice Update reward computation params for all pools\n', '  /// @dev Be careful of gas spending\n', '  function massUpdatePools() external;\n', '\n', '  /// @notice Update CVP tokens allocation for the given pool\n', '  function updatePool(uint256 _pid) external;\n', '\n', '  /// @notice Deposit the given amount of LP tokens to the given pool\n', '  function deposit(\n', '    uint256 _pid,\n', '    uint256 _amount,\n', '    uint256 _boostAmount\n', '  ) external;\n', '\n', '  /// @notice Withdraw the given amount of LP tokens from the given pool\n', '  function withdraw(\n', '    uint256 _pid,\n', '    uint256 _amount,\n', '    uint256 _boostAmount\n', '  ) external;\n', '\n', '  /// @notice Withdraw LP tokens without caring about pending CVP tokens. EMERGENCY ONLY.\n', '  function emergencyWithdraw(uint256 _pid) external;\n', '\n', '  /// @notice Write votes of the given user at the current block\n', '  function checkpointVotes(address _user) external;\n', '\n', '  /// @notice Get CVP amount and the share of CVPs in LP pools for the given account and the checkpoint\n', '  function getCheckpoint(address account, uint32 checkpointId)\n', '    external\n', '    view\n', '    returns (\n', '      uint32 fromBlock,\n', '      uint96 cvpAmount,\n', '      uint96 pooledCvpShare\n', '    );\n', '\n', '  event AddLpToken(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n', '  event SetLpToken(address indexed lpToken, uint256 indexed pid, uint256 allocPoint);\n', '  event SetMigrator(address indexed migrator);\n', '  event SetCvpPerBlock(uint256 cvpPerBlock);\n', '  event SetCvpVestingPeriodInBlocks(uint256 cvpVestingPeriodInBlocks);\n', '  event SetCvpPoolByMetaPool(address indexed metaPool, address indexed cvpPool);\n', '  event MigrateLpToken(address indexed oldLpToken, address indexed newLpToken, uint256 indexed pid);\n', '\n', '  event Deposit(address indexed user, uint256 indexed pid, uint256 amount, uint256 boostAmount);\n', '  event Withdraw(address indexed user, uint256 indexed pid, uint256 amount, uint256 boostAmount);\n', '  event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount, uint256 boostAmount);\n', '\n', '  event CheckpointTotalLpVotes(uint256 lpVotes);\n', '  event CheckpointUserLpVotes(address indexed user, uint256 indexed pid, uint256 lpVotes);\n', '  event CheckpointUserVotes(address indexed user, uint256 pendedVotes, uint256 lpVotesShare);\n', '}\n', '\n', '// File: contracts/lib/ReservedSlots.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @dev Slots reserved for possible storage layout changes (it neither spends gas nor adds extra bytecode)\n', 'contract ReservedSlots {\n', '    uint256[100] private __gap;\n', '}\n', '\n', '// File: contracts/lib/SafeMath96.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath96 {\n', '\n', '    function add(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        uint96 c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function add(uint96 a, uint96 b) internal pure returns (uint96) {\n', '        return add(a, b, "SafeMath96: addition overflow");\n', '    }\n', '\n', '    function sub(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    function sub(uint96 a, uint96 b) internal pure returns (uint96) {\n', '        return sub(a, b, "SafeMath96: subtraction overflow");\n', '    }\n', '\n', '    function average(uint96 a, uint96 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '\n', '    function fromUint(uint n, string memory errorMessage) internal pure returns (uint96) {\n', '        require(n < 2**96, errorMessage);\n', '        return uint96(n);\n', '    }\n', '\n', '    function fromUint(uint n) internal pure returns (uint96) {\n', '        return fromUint(n, "SafeMath96: exceeds 96 bits");\n', '    }\n', '}\n', '\n', '// File: contracts/lib/SafeMath32.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath32 {\n', '\n', '    function add(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\n', '        uint32 c = a + b;\n', '        require(c >= a, errorMessage);\n', '        return c;\n', '    }\n', '\n', '    function add(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        return add(a, b, "SafeMath32: addition overflow");\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b, string memory errorMessage) internal pure returns (uint32) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\n', '        return sub(a, b, "SafeMath32: subtraction overflow");\n', '    }\n', '\n', '    function fromUint(uint n, string memory errorMessage) internal pure returns (uint32) {\n', '        require(n < 2**32, errorMessage);\n', '        return uint32(n);\n', '    }\n', '\n', '    function fromUint(uint n) internal pure returns (uint32) {\n', '        return fromUint(n, "SafeMath32: exceeds 32 bits");\n', '    }\n', '}\n', '\n', '// File: contracts/lib/DelegatableCheckpoints.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'library DelegatableCheckpoints {\n', '\n', '    /// @dev A checkpoint storing some data effective from a given block\n', '    struct Checkpoint {\n', '        uint32 fromBlock;\n', '        uint192 data;\n', '        // uint32 __reserved;\n', '    }\n', '\n', "    /// @dev A set of checkpoints and a 'delegatee'\n", '    struct Record {\n', '        uint32 numCheckpoints;\n', '        uint32 lastCheckpointBlock;\n', '        address delegatee;\n', '        // uint32 __reserved;\n', '\n', '        // Checkpoints by IDs\n', '        mapping (uint32 => Checkpoint) checkpoints;\n', '        // Checkpoint IDs get counted from 1 (but not from 0) -\n', "        // the 1st checkpoint has ID of 1, and the last checkpoint' ID is `numCheckpoints`\n", '    }\n', '\n', '    function getCheckpoint(Record storage record, uint checkpointId)\n', '    internal view returns (uint32 fromBlock, uint192 data)\n', '    {\n', '        return checkpointId == 0 || checkpointId > record.numCheckpoints\n', '            ? (0, 0)\n', '            : _getCheckpoint(record, uint32(checkpointId));\n', '    }\n', '\n', '    function _getCheckpoint(Record storage record, uint32 checkpointId)\n', '    internal view returns (uint32 fromBlock, uint192 data)\n', '    {\n', '        return (record.checkpoints[checkpointId].fromBlock, record.checkpoints[checkpointId].data);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the data recorded in the latest checkpoint of the given record\n', '     */\n', '    function getLatestData(Record storage record)\n', '    internal view returns (uint192, uint32)\n', '    {\n', '        Record memory _record = record;\n', '        return _record.numCheckpoints == 0\n', '        ? (0, 0)\n', '        : (record.checkpoints[_record.numCheckpoints].data, record.checkpoints[_record.numCheckpoints].fromBlock);\n', '    }\n', '\n', '    /**\n', "     * @dev Returns the prior data written in the given record' checkpoints as of a block number\n", '     * (reverts if the requested block has not been finalized)\n', '     * @param record The record with checkpoints\n', '     * @param blockNumber The block number to get the data at\n', '     * @param checkpointId Optional ID of a checkpoint to first look into\n', '     * @return The data effective as of the given block\n', '     */\n', '    function getPriorData(Record storage record, uint blockNumber, uint checkpointId)\n', '    internal view returns (uint192, uint32)\n', '    {\n', '        uint32 blockNum = _safeMinedBlockNum(blockNumber);\n', '        Record memory _record = record;\n', '        Checkpoint memory cp;\n', '\n', "        // First check specific checkpoint, if it's provided\n", '        if (checkpointId != 0) {\n', '            require(checkpointId <= _record.numCheckpoints, "ChPoints: invalid checkpoint id");\n', '            uint32 cpId = uint32(checkpointId);\n', '\n', '            cp = record.checkpoints[cpId];\n', '            if (cp.fromBlock == blockNum) {\n', '                return (cp.data, cp.fromBlock);\n', '            } else if (cp.fromBlock < cp.fromBlock) {\n', '                if (cpId == _record.numCheckpoints) {\n', '                    return (cp.data, cp.fromBlock);\n', '                }\n', '                uint32 nextFromBlock = record.checkpoints[cpId + 1].fromBlock;\n', '                if (nextFromBlock > blockNum) {\n', '                    return (cp.data, cp.fromBlock);\n', '                }\n', '            }\n', '        }\n', '\n', '        // Finally, search trough all checkpoints\n', '        (uint32 checkpointId, uint192 data) = _findCheckpoint(record, _record.numCheckpoints, blockNum);\n', '        return (data, record.checkpoints[checkpointId].fromBlock);\n', '    }\n', '\n', '    /**\n', '     * @dev Finds a checkpoint in the given record for the given block number\n', '     * (reverts if the requested block has not been finalized)\n', '     * @param record The record with checkpoints\n', '     * @param blockNumber The block number to get the checkpoint at\n', '     * @return id The checkpoint ID\n', '     * @return data The checkpoint data\n', '     */\n', '    function findCheckpoint(Record storage record, uint blockNumber)\n', '    internal view returns (uint32 id, uint192 data)\n', '    {\n', '        uint32 blockNum = _safeMinedBlockNum(blockNumber);\n', '        uint32 numCheckpoints = record.numCheckpoints;\n', '\n', '        (id, data) = _findCheckpoint(record, numCheckpoints, blockNum);\n', '    }\n', '\n', '    /**\n', '     * @dev Writes a checkpoint with given data to the given record and returns the checkpoint ID\n', '     */\n', '    function writeCheckpoint(Record storage record, uint192 data)\n', '    internal returns (uint32 id)\n', '    {\n', '        uint32 blockNum = _safeBlockNum(block.number);\n', '        Record memory _record = record;\n', '\n', '        uint192 oldData = _record.numCheckpoints > 0 ? record.checkpoints[_record.numCheckpoints].data : 0;\n', '        bool isChanged = data != oldData;\n', '\n', '        if (_record.lastCheckpointBlock != blockNum) {\n', '            _record.numCheckpoints = _record.numCheckpoints + 1; // overflow chance ignored\n', '            record.numCheckpoints = _record.numCheckpoints;\n', '            record.lastCheckpointBlock = blockNum;\n', '            isChanged = true;\n', '        }\n', '        if (isChanged) {\n', '            record.checkpoints[_record.numCheckpoints] = Checkpoint(blockNum, data);\n', '        }\n', '        id = _record.numCheckpoints;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the given record properties (w/o mappings)\n', '     */\n', '    function getProperties(Record storage record) internal view returns (uint32, uint32, address) {\n', '        return (record.numCheckpoints, record.lastCheckpointBlock, record.delegatee);\n', '    }\n', '\n', '    /**\n', '     * @dev Writes given delegatee to the given record\n', '     */\n', '    function writeDelegatee(Record storage record, address delegatee) internal {\n', '        record.delegatee = delegatee;\n', '    }\n', '\n', '    function _safeBlockNum(uint256 blockNumber) private pure returns (uint32) {\n', '        require(blockNumber < 2**32, "ChPoints: blockNum >= 2**32");\n', '        return uint32(blockNumber);\n', '    }\n', '\n', '    function _safeMinedBlockNum(uint256 blockNumber) private view returns (uint32) {\n', '        require(blockNumber < block.number, "ChPoints: block not yet mined");\n', '        return _safeBlockNum(blockNumber);\n', '    }\n', '\n', '    function _findCheckpoint(Record storage record, uint32 numCheckpoints, uint32 blockNum)\n', '    private view returns (uint32, uint192)\n', '    {\n', '        Checkpoint memory cp;\n', '\n', '        // Check special cases first\n', '        if (numCheckpoints == 0) {\n', '            return (0, 0);\n', '        }\n', '        cp = record.checkpoints[numCheckpoints];\n', '        if (cp.fromBlock <= blockNum) {\n', '            return (numCheckpoints, cp.data);\n', '        }\n', '        if (record.checkpoints[1].fromBlock > blockNum) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint32 lower = 1;\n', '        uint32 upper = numCheckpoints;\n', '        while (upper > lower) {\n', '            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n', '            cp = record.checkpoints[center];\n', '            if (cp.fromBlock == blockNum) {\n', '                return (center, cp.data);\n', '            } else if (cp.fromBlock < blockNum) {\n', '                lower = center;\n', '            } else {\n', '                upper = center - 1;\n', '            }\n', '        }\n', '        return (lower, record.checkpoints[lower].data);\n', '    }\n', '}\n', '\n', '// File: contracts/powerindex-mining/DelegatableVotes.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'abstract contract DelegatableVotes {\n', '  using SafeMath96 for uint96;\n', '  using DelegatableCheckpoints for DelegatableCheckpoints.Record;\n', '\n', '  /**\n', '   * @notice Votes computation data for each account\n', '   * @dev Data adjusted to account "delegated" votes\n', '   * @dev For the contract address, stores shared for all accounts data\n', '   */\n', '  mapping(address => DelegatableCheckpoints.Record) public book;\n', '\n', '  /**\n', '   * @dev Data on votes which an account may delegate or has already delegated\n', '   */\n', '  mapping(address => uint192) internal delegatables;\n', '\n', "  /// @notice The event is emitted when a delegate account' vote balance changes\n", '  event CheckpointBalanceChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n', '\n', "  /// @notice An event that's emitted when an account changes its delegate\n", '  event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n', '\n', '  /**\n', '   * @notice Get the "delegatee" account for the message sender\n', '   */\n', '  function delegatee() public view returns (address) {\n', '    return book[msg.sender].delegatee;\n', '  }\n', '\n', '  /**\n', '   * @notice Delegate votes from `msg.sender` to `delegatee`\n', '   * @param delegatee_ The address to delegate votes to\n', '   */\n', '  function delegate(address delegatee_) public {\n', '    require(delegatee_ != address(this), "delegate: can\'t delegate to the contract address");\n', '    return _delegate(msg.sender, delegatee_);\n', '  }\n', '\n', '  /**\n', '   * @notice Get the current votes balance for `account`\n', '   * @param account The address to get votes balance\n', '   * @return The number of current votes for `account`\n', '   */\n', '  function _getCurrentVotes(address account) internal view returns (uint96) {\n', '    (uint192 userData, uint32 userDataBlockNumber) = book[account].getLatestData();\n', '    if (userData == 0) return 0;\n', '\n', '    (uint192 sharedData, ) = book[address(this)].getLatestData();\n', '    (uint192 sharedDataAtUserSave, ) = book[address(this)].getPriorData(userDataBlockNumber, 0);\n', '    return _computeUserVotes(userData, sharedData, sharedDataAtUserSave);\n', '  }\n', '\n', '  /**\n', '   * @notice Determine the prior number of votes for the given account as of the given block\n', '   * @dev To prevent misinformation, the call reverts if the block requested is not finalized\n', '   * @param account The address of the account to get votes for\n', '   * @param blockNumber The block number to get votes at\n', '   * @return The number of votes the account had as of the given block\n', '   */\n', '  function _getPriorVotes(address account, uint256 blockNumber) internal view returns (uint96) {\n', '    return _getPriorVotes(account, blockNumber, 0, 0);\n', '  }\n', '\n', '  /**\n', '   * @notice Gas-optimized version of the `getPriorVotes` function -\n', '   * it accepts IDs of checkpoints to look for votes data as of the given block in\n', '   * (if the checkpoints miss the data, it get searched through all checkpoints recorded)\n', '   * @dev Call (off-chain) the `findCheckpoints` function to get needed IDs\n', '   * @param account The address of the account to get votes for\n', '   * @param blockNumber The block number to get votes at\n', '   * @param userCheckpointId ID of the checkpoint to look for the user data first\n', '   * @param userCheckpointId ID of the checkpoint to look for the shared data first\n', '   * @return The number of votes the account had as of the given block\n', '   */\n', '  function _getPriorVotes(\n', '    address account,\n', '    uint256 blockNumber,\n', '    uint32 userCheckpointId,\n', '    uint32 sharedCheckpointId\n', '  ) internal view returns (uint96) {\n', '    (uint192 userData, uint32 userDataBlockNumber) = book[account].getPriorData(blockNumber, userCheckpointId);\n', '    if (userData == 0) return 0;\n', '\n', '    (uint192 sharedData, ) = book[address(this)].getPriorData(blockNumber, sharedCheckpointId);\n', '    (uint192 sharedDataAtUserSave, ) = book[address(this)].getPriorData(userDataBlockNumber, 0);\n', '    return _computeUserVotes(userData, sharedData, sharedDataAtUserSave);\n', '  }\n', '\n', "  /// @notice Returns IDs of checkpoints which store the given account' votes computation data\n", '  /// @dev Intended for off-chain use (by UI)\n', '  function findCheckpoints(address account, uint256 blockNumber)\n', '    external\n', '    view\n', '    returns (uint32 userCheckpointId, uint32 sharedCheckpointId)\n', '  {\n', '    require(account != address(0), "findCheckpoints: zero account");\n', '    (userCheckpointId, ) = book[account].findCheckpoint(blockNumber);\n', '    (sharedCheckpointId, ) = book[address(this)].findCheckpoint(blockNumber);\n', '  }\n', '\n', '  function _getCheckpoint(address account, uint32 checkpointId) internal view returns (uint32 fromBlock, uint192 data) {\n', '    (fromBlock, data) = book[account].getCheckpoint(checkpointId);\n', '  }\n', '\n', '  function _writeSharedData(uint192 data) internal {\n', '    book[address(this)].writeCheckpoint(data);\n', '  }\n', '\n', '  function _writeUserData(address account, uint192 data) internal {\n', '    DelegatableCheckpoints.Record storage src = book[account];\n', '    address _delegatee = src.delegatee;\n', '    DelegatableCheckpoints.Record storage dst = _delegatee == address(0) ? src : book[_delegatee];\n', '\n', '    (uint192 latestData, ) = dst.getLatestData();\n', '    dst.writeCheckpoint(\n', '      // keep in mind votes which others could have delegated\n', '      _computeUserData(latestData, data, delegatables[account])\n', '    );\n', '    delegatables[account] = data;\n', '  }\n', '\n', '  function _moveUserData(\n', '    address account,\n', '    address from,\n', '    address to\n', '  ) internal {\n', '    DelegatableCheckpoints.Record storage src;\n', '    DelegatableCheckpoints.Record storage dst;\n', '\n', '    if (from == address(0)) {\n', '      // no former delegatee\n', '      src = book[account];\n', '      dst = book[to];\n', '    } else if (to == address(0)) {\n', '      // delegation revoked\n', '      src = book[from];\n', '      dst = book[account];\n', '    } else {\n', '      src = book[from];\n', '      dst = book[to];\n', '    }\n', '    uint192 delegatable = delegatables[account];\n', '\n', '    (uint192 srcPrevData, ) = src.getLatestData();\n', '    uint192 srcData = _computeUserData(srcPrevData, 0, delegatable);\n', '    if (srcPrevData != srcData) src.writeCheckpoint(srcData);\n', '\n', '    (uint192 dstPrevData, ) = dst.getLatestData();\n', '    uint192 dstData = _computeUserData(dstPrevData, delegatable, 0);\n', '    if (dstPrevData != dstData) dst.writeCheckpoint(dstData);\n', '  }\n', '\n', '  function _delegate(address delegator, address delegatee_) internal {\n', '    address currentDelegate = book[delegator].delegatee;\n', '    book[delegator].delegatee = delegatee_;\n', '\n', '    emit DelegateChanged(delegator, currentDelegate, delegatee_);\n', '\n', '    _moveUserData(delegator, currentDelegate, delegatee_);\n', '  }\n', '\n', '  function _computeUserVotes(\n', '    uint192 userData,\n', '    uint192 sharedData,\n', '    uint192 sharedDataAtUserSave\n', '  ) internal pure virtual returns (uint96 votes);\n', '\n', '  function _computeUserData(\n', '    uint192 prevData,\n', '    uint192 newDelegated,\n', '    uint192 prevDelegated\n', '  ) internal pure virtual returns (uint192 userData) {\n', '    (uint96 prevA, uint96 prevB) = _unpackData(prevData);\n', '    (uint96 newDelegatedA, uint96 newDelegatedB) = _unpackData(newDelegated);\n', '    (uint96 prevDelegatedA, uint96 prevDelegatedB) = _unpackData(prevDelegated);\n', '    userData = _packData(\n', '      _getNewValue(prevA, newDelegatedA, prevDelegatedA),\n', '      _getNewValue(prevB, newDelegatedB, prevDelegatedB)\n', '    );\n', '  }\n', '\n', '  function _unpackData(uint192 data) internal pure virtual returns (uint96 valA, uint96 valB) {\n', '    return (uint96(data >> 96), uint96((data << 96) >> 96));\n', '  }\n', '\n', '  function _packData(uint96 valA, uint96 valB) internal pure virtual returns (uint192 data) {\n', '    return ((uint192(valA) << 96) | uint192(valB));\n', '  }\n', '\n', '  function _getNewValue(\n', '    uint96 val,\n', '    uint96 more,\n', '    uint96 less\n', '  ) internal pure virtual returns (uint96 newVal) {\n', '    if (more == less) {\n', '      newVal = val;\n', '    } else if (more > less) {\n', '      newVal = val.add(more.sub(less));\n', '    } else {\n', '      uint96 decrease = less.sub(more);\n', '      newVal = val > decrease ? val.sub(decrease) : 0;\n', '    }\n', '  }\n', '\n', '  uint256[50] private _gap; // reserved\n', '}\n', '\n', '// File: contracts/powerindex-mining/VestedLPMining.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract VestedLPMining is\n', '  OwnableUpgradeSafe,\n', '  ReentrancyGuardUpgradeSafe,\n', '  ReservedSlots,\n', '  DelegatableVotes,\n', '  IVestedLPMining\n', '{\n', '  using SafeMath for uint256;\n', '  using SafeMath96 for uint96;\n', '  using SafeMath32 for uint32;\n', '\n', '  using SafeERC20 for IERC20;\n', '\n', '  /// @dev properties grouped to optimize storage costs\n', '\n', '  struct User {\n', '    uint32 lastUpdateBlock; // block when the params (below) were updated\n', '    uint32 vestingBlock; // block by when all entitled CVP tokens to be vested\n', '    uint96 pendedCvp; // amount of CVPs tokens entitled but not yet vested to the user\n', '    uint96 cvpAdjust; // adjustments for pended CVP tokens amount computation\n', '    // (with regard to LP token deposits/withdrawals in the past)\n', '    uint256 lptAmount; // amount of LP tokens the user has provided to a pool\n', '    /** @dev\n', '     * At any time, the amount of CVP tokens entitled to a user but not yet vested is the sum of:\n', '     * (1) CVP token amount entitled after the user last time deposited or withdrawn LP tokens\n', '     *     = (user.lptAmount * pool.accCvpPerLpt) - user.cvpAdjust\n', '     * (2) CVP token amount entitled before the last deposit or withdrawal but not yet vested\n', '     *     = user.pendedCvp\n', '     *\n', '     * Whenever a user deposits or withdraws LP tokens to a pool:\n', '     *   1. `pool.accCvpPerLpt` for the pool gets updated;\n', '     *   2. CVP token amounts to be entitled and vested to the user get computed;\n', '     *   3. Token amount which may be vested get sent to the user;\n', "     *   3. User' `lptAmount`, `cvpAdjust` and `pendedCvp` get updated.\n", '     *\n', '     * Note comments on vesting rules in the `function _computeCvpVesting` code bellow.\n', '     */\n', '  }\n', '\n', '  struct Pool {\n', '    IERC20 lpToken; // address of the LP token contract\n', '    bool votesEnabled; // if the pool is enabled to write votes\n', '    uint8 poolType; // pool type (1 - Uniswap, 2 - Balancer)\n', '    uint32 allocPoint; // points assigned to the pool, which affect CVPs distribution between pools\n', '    uint32 lastUpdateBlock; // latest block when the pool params which follow was updated\n', '    uint256 accCvpPerLpt; // accumulated distributed CVPs per one deposited LP token, times 1e12\n', '  }\n', '\n', '  // scale factor for `accCvpPerLpt`\n', '  uint256 internal constant SCALE = 1e12;\n', '\n', '  // The CVP TOKEN\n', '  IERC20 public cvp;\n', '  // Total amount of CVP tokens pended (not yet vested to users)\n', '  uint96 public cvpVestingPool;\n', '\n', '  // Reservoir address\n', '  address public reservoir;\n', '  // Vesting duration in blocks\n', '  uint32 public cvpVestingPeriodInBlocks;\n', '  // The block number when CVP powerindex-mining starts\n', '  uint32 public startBlock;\n', '  // The amount of CVP tokens rewarded to all pools every block\n', '  uint96 public cvpPerBlock;\n', '\n', '  // The migrator contract (only the owner may assign it)\n', '  ILpTokenMigrator public migrator;\n', '\n', '  // Params of each pool\n', '  Pool[] public pools;\n', '  // Pid (i.e. the index in `pools`) of each pool by its LP token address\n', '  mapping(address => uint256) public poolPidByAddress;\n', '  // Params of each user that stakes LP tokens, by the Pid and the user address\n', '  mapping(uint256 => mapping(address => User)) public users;\n', '  // Sum of allocation points for all pools\n', '  uint256 public totalAllocPoint = 0;\n', '\n', '  mapping(address => address) public cvpPoolByMetaPool;\n', '\n', '  mapping(address => uint256) public lastSwapBlock;\n', '\n', '  struct PoolBoost {\n', '    uint256 lpBoostRate;\n', '    uint256 cvpBoostRate;\n', '    uint32 lastUpdateBlock;\n', '    uint256 accCvpPerLpBoost;\n', '    uint256 accCvpPerCvpBoost;\n', '  }\n', '\n', '  struct UserPoolBoost {\n', '    uint256 balance;\n', '    uint32 lastUpdateBlock;\n', '  }\n', '\n', '  mapping(uint256 => PoolBoost) public poolBoostByLp;\n', '  mapping(uint256 => mapping(address => UserPoolBoost)) public usersPoolBoost;\n', '\n', '  mapping(address => uint256) public lpBoostRatioByToken;\n', '  mapping(address => uint256) public lpBoostMaxRatioByToken;\n', '\n', '  mapping(address => bool) public votingEnabled;\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function initialize(\n', '    IERC20 _cvp,\n', '    address _reservoir,\n', '    uint256 _cvpPerBlock,\n', '    uint256 _startBlock,\n', '    uint256 _cvpVestingPeriodInBlocks\n', '  ) external override initializer {\n', '    __Ownable_init();\n', '    __ReentrancyGuard_init_unchained();\n', '\n', '    cvp = _cvp;\n', '    reservoir = _reservoir;\n', '    startBlock = SafeMath32.fromUint(_startBlock, "VLPMining: too big startBlock");\n', '    cvpVestingPeriodInBlocks = SafeMath32.fromUint(_cvpVestingPeriodInBlocks, "VLPMining: too big vest period");\n', '    setCvpPerBlock(_cvpPerBlock);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function poolLength() external view override returns (uint256) {\n', '    return pools.length;\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function add(\n', '    uint256 _allocPoint,\n', '    IERC20 _lpToken,\n', '    uint8 _poolType,\n', '    bool _votesEnabled,\n', '    uint256 _lpBoostRate,\n', '    uint256 _cvpBoostRate,\n', '    uint256 _lpBoostMinRatio,\n', '    uint256 _lpBoostMaxRatio\n', '  ) public override onlyOwner {\n', '    require(!isLpTokenAdded(_lpToken), "VLPMining: token already added");\n', '\n', '    massUpdatePools();\n', '    uint32 blockNum = _currBlock();\n', '    uint32 lastUpdateBlock = blockNum > startBlock ? blockNum : startBlock;\n', '    totalAllocPoint = totalAllocPoint.add(_allocPoint);\n', '\n', '    uint256 pid = pools.length;\n', '    pools.push(\n', '      Pool({\n', '        lpToken: _lpToken,\n', '        votesEnabled: _votesEnabled,\n', '        poolType: _poolType,\n', '        allocPoint: SafeMath32.fromUint(_allocPoint, "VLPMining: too big allocation"),\n', '        lastUpdateBlock: lastUpdateBlock,\n', '        accCvpPerLpt: 0\n', '      })\n', '    );\n', '    poolPidByAddress[address(_lpToken)] = pid;\n', '\n', '    poolBoostByLp[pid].lpBoostRate = _lpBoostRate;\n', '    poolBoostByLp[pid].cvpBoostRate = _cvpBoostRate;\n', '\n', '    poolBoostByLp[pid].lastUpdateBlock = lastUpdateBlock;\n', '    lpBoostRatioByToken[address(_lpToken)] = _lpBoostMinRatio;\n', '    lpBoostMaxRatioByToken[address(_lpToken)] = _lpBoostMaxRatio;\n', '\n', '    emit AddLpToken(address(_lpToken), pid, _allocPoint);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function set(\n', '    uint256 _pid,\n', '    uint256 _allocPoint,\n', '    uint8 _poolType,\n', '    bool _votesEnabled,\n', '    uint256 _lpBoostRate,\n', '    uint256 _cvpBoostRate,\n', '    uint256 _lpBoostMinRatio,\n', '    uint256 _lpBoostMaxRatio\n', '  ) public override onlyOwner {\n', '    massUpdatePools();\n', '    totalAllocPoint = totalAllocPoint.sub(uint256(pools[_pid].allocPoint)).add(_allocPoint);\n', '    pools[_pid].allocPoint = SafeMath32.fromUint(_allocPoint, "VLPMining: too big allocation");\n', '    pools[_pid].votesEnabled = _votesEnabled;\n', '    pools[_pid].poolType = _poolType;\n', '\n', '    poolBoostByLp[_pid].lpBoostRate = _lpBoostRate;\n', '    poolBoostByLp[_pid].cvpBoostRate = _cvpBoostRate;\n', '\n', '    lpBoostRatioByToken[address(pools[_pid].lpToken)] = _lpBoostMinRatio;\n', '    lpBoostMaxRatioByToken[address(pools[_pid].lpToken)] = _lpBoostMaxRatio;\n', '\n', '    emit SetLpToken(address(pools[_pid].lpToken), _pid, _allocPoint);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function setMigrator(ILpTokenMigrator _migrator) public override onlyOwner {\n', '    migrator = _migrator;\n', '\n', '    emit SetMigrator(address(_migrator));\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function setCvpPerBlock(uint256 _cvpPerBlock) public override onlyOwner {\n', '    cvpPerBlock = SafeMath96.fromUint(_cvpPerBlock, "VLPMining: too big cvpPerBlock");\n', '\n', '    emit SetCvpPerBlock(_cvpPerBlock);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function setCvpVestingPeriodInBlocks(uint256 _cvpVestingPeriodInBlocks) public override onlyOwner {\n', '    cvpVestingPeriodInBlocks = SafeMath32.fromUint(\n', '      _cvpVestingPeriodInBlocks,\n', '      "VLPMining: too big cvpVestingPeriodInBlocks"\n', '    );\n', '\n', '    emit SetCvpVestingPeriodInBlocks(_cvpVestingPeriodInBlocks);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function setCvpPoolByMetaPool(address _metaPool, address _cvpPool) public override onlyOwner {\n', '    cvpPoolByMetaPool[_metaPool] = _cvpPool;\n', '\n', '    emit SetCvpPoolByMetaPool(_metaPool, _cvpPool);\n', '  }\n', '\n', '  function updateCvpAdjust(\n', '    uint256 _pid,\n', '    address[] calldata _users,\n', '    uint96[] calldata _cvpAdjust\n', '  ) external onlyOwner {\n', '    uint256 len = _users.length;\n', '    require(len == _cvpAdjust.length, "Lengths not match");\n', '    for (uint256 i = 0; i < len; i++) {\n', '      users[_pid][_users[i]].cvpAdjust = _cvpAdjust[i];\n', '    }\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  /// @dev Anyone may call, so we have to trust the migrator contract\n', '  function migrate(uint256 _pid) public override nonReentrant {\n', '    require(address(migrator) != address(0), "VLPMining: no migrator");\n', '    Pool storage pool = pools[_pid];\n', '    IERC20 lpToken = pool.lpToken;\n', '    uint256 bal = lpToken.balanceOf(address(this));\n', '    lpToken.safeApprove(address(migrator), bal);\n', '    IERC20 newLpToken = migrator.migrate(lpToken, pool.poolType);\n', '    require(bal == newLpToken.balanceOf(address(this)), "VLPMining: invalid migration");\n', '    pool.lpToken = newLpToken;\n', '\n', '    delete poolPidByAddress[address(lpToken)];\n', '    poolPidByAddress[address(newLpToken)] = _pid;\n', '\n', '    emit MigrateLpToken(address(lpToken), address(newLpToken), _pid);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function pendingCvp(uint256 _pid, address _user) external view override returns (uint256) {\n', '    if (_pid >= pools.length) return 0;\n', '\n', '    Pool memory _pool = pools[_pid];\n', '    PoolBoost memory _poolBoost = poolBoostByLp[_pid];\n', '    User memory user = users[_pid][_user];\n', '    UserPoolBoost memory userPB = usersPoolBoost[_pid][_user];\n', '\n', '    _computePoolReward(_pool);\n', '    _computePoolBoostReward(_poolBoost);\n', '\n', '    _pool.lastUpdateBlock = pools[_pid].lastUpdateBlock;\n', '    _computePoolRewardByBoost(_pool, _poolBoost);\n', '    uint96 newlyEntitled = _computeCvpToEntitle(user, _pool, userPB, _poolBoost);\n', '\n', '    return uint256(newlyEntitled.add(user.pendedCvp));\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function vestableCvp(uint256 _pid, address user) external view override returns (uint256) {\n', '    Pool memory _pool = pools[_pid];\n', '    PoolBoost memory _poolBoost = poolBoostByLp[_pid];\n', '    User memory _user = users[_pid][user];\n', '    UserPoolBoost memory _userPB = usersPoolBoost[_pid][user];\n', '\n', '    _computePoolReward(_pool);\n', '    _computePoolBoostReward(_poolBoost);\n', '\n', '    _pool.lastUpdateBlock = pools[_pid].lastUpdateBlock;\n', '    _computePoolRewardByBoost(_pool, _poolBoost);\n', '    (, uint256 newlyVested) = _computeCvpVesting(_user, _pool, _userPB, _poolBoost);\n', '\n', '    return newlyVested;\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function isLpTokenAdded(IERC20 _lpToken) public view override returns (bool) {\n', '    uint256 pid = poolPidByAddress[address(_lpToken)];\n', '    return pools.length > pid && address(pools[pid].lpToken) == address(_lpToken);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function massUpdatePools() public override {\n', '    uint256 length = pools.length;\n', '    for (uint256 pid = 0; pid < length; ++pid) {\n', '      updatePool(pid);\n', '    }\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function updatePool(uint256 _pid) public override nonReentrant {\n', '    _doPoolUpdate(pools[_pid], poolBoostByLp[_pid]);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function deposit(\n', '    uint256 _pid,\n', '    uint256 _amount,\n', '    uint256 _boostAmount\n', '  ) public override nonReentrant {\n', '    _validatePoolId(_pid);\n', '    _preventSameTxOriginAndMsgSender();\n', '\n', '    Pool storage pool = pools[_pid];\n', '    PoolBoost storage poolBoost = poolBoostByLp[_pid];\n', '    User storage user = users[_pid][msg.sender];\n', '    UserPoolBoost storage userPB = usersPoolBoost[_pid][msg.sender];\n', '\n', '    _doPoolUpdate(pool, poolBoost);\n', '    _vestUserCvp(user, pool, userPB, poolBoost);\n', '\n', '    if (_amount != 0) {\n', '      pool.lpToken.safeTransferFrom(msg.sender, address(this), _amount);\n', '      user.lptAmount = user.lptAmount.add(_amount);\n', '    }\n', '    if (_boostAmount != 0) {\n', '      cvp.safeTransferFrom(msg.sender, address(this), _boostAmount);\n', '      userPB.balance = userPB.balance.add(_boostAmount);\n', '    }\n', '    if (userPB.balance != 0) {\n', '      require(!cvpAmountNotInBoundsToBoost(userPB.balance, user.lptAmount, address(pool.lpToken)), "BOOST_BOUNDS");\n', '    }\n', '    user.cvpAdjust = _computeCvpAdjustmentWithBoost(user.lptAmount, pool, userPB, poolBoost);\n', '    emit Deposit(msg.sender, _pid, _amount, _boostAmount);\n', '\n', '    if (votingEnabled[msg.sender]) {\n', '      _doCheckpointVotes(msg.sender);\n', '    }\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function withdraw(\n', '    uint256 _pid,\n', '    uint256 _amount,\n', '    uint256 _boostAmount\n', '  ) public override nonReentrant {\n', '    _validatePoolId(_pid);\n', '    _preventSameTxOriginAndMsgSender();\n', '\n', '    Pool storage pool = pools[_pid];\n', '    PoolBoost storage poolBoost = poolBoostByLp[_pid];\n', '    User storage user = users[_pid][msg.sender];\n', '    UserPoolBoost storage userPB = usersPoolBoost[_pid][msg.sender];\n', '    require(user.lptAmount >= _amount, "VLPMining: amount exceeds balance");\n', '\n', '    _doPoolUpdate(pool, poolBoost);\n', '    _vestUserCvp(user, pool, userPB, poolBoost);\n', '\n', '    if (_amount != 0) {\n', '      user.lptAmount = user.lptAmount.sub(_amount);\n', '      pool.lpToken.safeTransfer(msg.sender, _amount);\n', '    }\n', '    if (_boostAmount != 0) {\n', '      userPB.balance = userPB.balance.sub(_boostAmount);\n', '      cvp.safeTransfer(msg.sender, _boostAmount);\n', '    }\n', '    if (userPB.balance != 0) {\n', '      require(!cvpAmountNotInBoundsToBoost(userPB.balance, user.lptAmount, address(pool.lpToken)), "BOOST_BOUNDS");\n', '    }\n', '    user.cvpAdjust = _computeCvpAdjustmentWithBoost(user.lptAmount, pool, userPB, poolBoost);\n', '    emit Withdraw(msg.sender, _pid, _amount, _boostAmount);\n', '\n', '    if (votingEnabled[msg.sender]) {\n', '      _doCheckpointVotes(msg.sender);\n', '    }\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function emergencyWithdraw(uint256 _pid) public override nonReentrant {\n', '    _validatePoolId(_pid);\n', '    _preventSameTxOriginAndMsgSender();\n', '\n', '    Pool storage pool = pools[_pid];\n', '    User storage user = users[_pid][msg.sender];\n', '    UserPoolBoost storage userPB = usersPoolBoost[_pid][msg.sender];\n', '\n', '    pool.lpToken.safeTransfer(msg.sender, user.lptAmount);\n', '    if (userPB.balance != 0) {\n', '      cvp.safeTransfer(msg.sender, userPB.balance);\n', '    }\n', '    emit EmergencyWithdraw(msg.sender, _pid, user.lptAmount, userPB.balance);\n', '\n', '    if (user.pendedCvp > 0) {\n', "      // TODO: Make user.pendedCvp be updated as of the pool' lastUpdateBlock\n", '      cvpVestingPool = user.pendedCvp > cvpVestingPool ? 0 : cvpVestingPool.sub(user.pendedCvp);\n', '    }\n', '\n', '    user.lptAmount = 0;\n', '    user.cvpAdjust = 0;\n', '    user.pendedCvp = 0;\n', '    user.vestingBlock = 0;\n', '    userPB.balance = 0;\n', '\n', '    if (votingEnabled[msg.sender]) {\n', '      _doCheckpointVotes(msg.sender);\n', '    }\n', '  }\n', '\n', '  function setVotingEnabled(bool _isEnabled) public nonReentrant {\n', '    votingEnabled[msg.sender] = _isEnabled;\n', '    if (_isEnabled) {\n', '      _doCheckpointVotes(msg.sender);\n', '    }\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function checkpointVotes(address _user) public override nonReentrant {\n', '    _doCheckpointVotes(_user);\n', '  }\n', '\n', '  function getCurrentVotes(address account) external view returns (uint96) {\n', '    if (!votingEnabled[account]) {\n', '      return 0;\n', '    }\n', '    return _getCurrentVotes(account);\n', '  }\n', '\n', '  function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n', '    if (!votingEnabled[account]) {\n', '      return 0;\n', '    }\n', '    return _getPriorVotes(account, blockNumber);\n', '  }\n', '\n', '  function getPriorVotes(\n', '    address account,\n', '    uint256 blockNumber,\n', '    uint32 userCheckpointId,\n', '    uint32 sharedCheckpointId\n', '  ) external view returns (uint96) {\n', '    if (!votingEnabled[account]) {\n', '      return 0;\n', '    }\n', '    return _getPriorVotes(account, blockNumber, userCheckpointId, sharedCheckpointId);\n', '  }\n', '\n', '  /// @inheritdoc IVestedLPMining\n', '  function getCheckpoint(address account, uint32 checkpointId)\n', '    external\n', '    view\n', '    override\n', '    returns (\n', '      uint32 fromBlock,\n', '      uint96 cvpAmount,\n', '      uint96 pooledCvpShare\n', '    )\n', '  {\n', '    uint192 data;\n', '    (fromBlock, data) = _getCheckpoint(account, checkpointId);\n', '    (cvpAmount, pooledCvpShare) = _unpackData(data);\n', '  }\n', '\n', '  function _doCheckpointVotes(address _user) internal {\n', '    uint256 length = pools.length;\n', '    uint96 userPendedCvp = 0;\n', '    uint256 userTotalLpCvp = 0;\n', '    uint96 totalLpCvp = 0;\n', '    for (uint256 pid = 0; pid < length; ++pid) {\n', '      userPendedCvp = userPendedCvp.add(users[pid][_user].pendedCvp);\n', '\n', '      Pool storage pool = pools[pid];\n', '      uint96 lpCvp;\n', '      address lpToken = address(pool.lpToken);\n', '      address cvpPoolByMeta = cvpPoolByMetaPool[lpToken];\n', '      if (cvpPoolByMeta == address(0)) {\n', '        lpCvp = SafeMath96.fromUint(cvp.balanceOf(lpToken), "VLPMining::_doCheckpointVotes:1");\n', '        totalLpCvp = totalLpCvp.add(lpCvp);\n', '      } else {\n', '        uint256 poolTotalSupply = IERC20(cvpPoolByMeta).totalSupply();\n', '        uint256 poolBalance = IERC20(cvpPoolByMeta).balanceOf(lpToken);\n', '        uint256 lpShare = uint256(poolBalance).mul(SCALE).div(poolTotalSupply);\n', '        uint256 metaPoolCvp = cvp.balanceOf(cvpPoolByMeta);\n', '        lpCvp = SafeMath96.fromUint(metaPoolCvp.mul(lpShare).div(SCALE), "VLPMining::_doCheckpointVotes:1");\n', '      }\n', '\n', '      if (!pool.votesEnabled) {\n', '        continue;\n', '      }\n', '\n', '      uint256 lptTotalSupply = pool.lpToken.totalSupply();\n', '      uint256 lptAmount = users[pid][_user].lptAmount;\n', '      if (lptAmount != 0 && lptTotalSupply != 0) {\n', '        uint256 cvpPerLpt = uint256(lpCvp).mul(SCALE).div(lptTotalSupply);\n', '        uint256 userLpCvp = lptAmount.mul(cvpPerLpt).div(SCALE);\n', '        userTotalLpCvp = userTotalLpCvp.add(userLpCvp);\n', '\n', '        emit CheckpointUserLpVotes(_user, pid, userLpCvp);\n', '      }\n', '    }\n', '\n', '    uint96 lpCvpUserShare =\n', '      (userTotalLpCvp == 0 || totalLpCvp == 0)\n', '        ? 0\n', '        : SafeMath96.fromUint(userTotalLpCvp.mul(SCALE).div(totalLpCvp), "VLPMining::_doCheckpointVotes:2");\n', '\n', '    emit CheckpointTotalLpVotes(totalLpCvp);\n', '    emit CheckpointUserVotes(_user, uint256(userPendedCvp), lpCvpUserShare);\n', '\n', '    _writeUserData(_user, _packData(userPendedCvp, lpCvpUserShare));\n', '    _writeSharedData(_packData(totalLpCvp, 0));\n', '  }\n', '\n', '  function _transferCvp(address _to, uint256 _amount) internal {\n', '    SafeERC20.safeTransferFrom(cvp, reservoir, _to, _amount);\n', '  }\n', '\n', '  /// @dev must be guarded for reentrancy\n', '  function _doPoolUpdate(Pool storage pool, PoolBoost storage poolBoost) internal {\n', '    Pool memory _pool = pool;\n', '    uint32 prevBlock = _pool.lastUpdateBlock;\n', '    uint256 prevAcc = _pool.accCvpPerLpt;\n', '\n', '    uint256 cvpReward = _computePoolReward(_pool);\n', '\n', '    if (poolBoost.lpBoostRate != 0) {\n', '      PoolBoost memory _poolBoost = poolBoost;\n', '      uint32 prevBoostBlock = poolBoost.lastUpdateBlock;\n', '      uint256 prevCvpBoostAcc = poolBoost.accCvpPerCvpBoost;\n', '      uint256 prevLpBoostAcc = poolBoost.accCvpPerLpBoost;\n', '\n', '      cvpReward = cvpReward.add(_computePoolBoostReward(_poolBoost));\n', '      _pool.lastUpdateBlock = prevBlock;\n', '      cvpReward = cvpReward.add(_computePoolRewardByBoost(_pool, _poolBoost));\n', '\n', '      if (_poolBoost.accCvpPerCvpBoost > prevCvpBoostAcc) {\n', '        poolBoost.accCvpPerCvpBoost = _poolBoost.accCvpPerCvpBoost;\n', '      }\n', '      if (_poolBoost.accCvpPerLpBoost > prevLpBoostAcc) {\n', '        poolBoost.accCvpPerLpBoost = _poolBoost.accCvpPerLpBoost;\n', '      }\n', '      if (_poolBoost.lastUpdateBlock > prevBoostBlock) {\n', '        poolBoost.lastUpdateBlock = _poolBoost.lastUpdateBlock;\n', '      }\n', '    }\n', '\n', '    if (_pool.accCvpPerLpt > prevAcc) {\n', '      pool.accCvpPerLpt = _pool.accCvpPerLpt;\n', '    }\n', '    if (_pool.lastUpdateBlock > prevBlock) {\n', '      pool.lastUpdateBlock = _pool.lastUpdateBlock;\n', '    }\n', '\n', '    if (cvpReward != 0) {\n', '      cvpVestingPool = cvpVestingPool.add(\n', '        SafeMath96.fromUint(cvpReward, "VLPMining::_doPoolUpdate:1"),\n', '        "VLPMining::_doPoolUpdate:2"\n', '      );\n', '    }\n', '  }\n', '\n', '  function _vestUserCvp(\n', '    User storage user,\n', '    Pool storage pool,\n', '    UserPoolBoost storage userPB,\n', '    PoolBoost storage poolBoost\n', '  ) internal {\n', '    User memory _user = user;\n', '    UserPoolBoost memory _userPB = userPB;\n', '    uint32 prevVestingBlock = _user.vestingBlock;\n', '    uint32 prevUpdateBlock = _user.lastUpdateBlock;\n', '    (uint256 newlyEntitled, uint256 newlyVested) = _computeCvpVesting(_user, pool, _userPB, poolBoost);\n', '\n', '    if (newlyEntitled != 0 || newlyVested != 0) {\n', '      user.pendedCvp = _user.pendedCvp;\n', '    }\n', '    if (newlyVested != 0) {\n', '      if (newlyVested > cvpVestingPool) newlyVested = uint256(cvpVestingPool);\n', '      cvpVestingPool = cvpVestingPool.sub(\n', '        SafeMath96.fromUint(newlyVested, "VLPMining::_vestUserCvp:1"),\n', '        "VLPMining::_vestUserCvp:2"\n', '      );\n', '      _transferCvp(msg.sender, newlyVested);\n', '    }\n', '    if (_user.vestingBlock > prevVestingBlock) {\n', '      user.vestingBlock = _user.vestingBlock;\n', '    }\n', '    if (_user.lastUpdateBlock > prevUpdateBlock) {\n', '      user.lastUpdateBlock = _user.lastUpdateBlock;\n', '    }\n', '  }\n', '\n', '  /* @dev Compute the amount of CVP tokens to be entitled and vested to a user of a pool\n', '   * ... and update the `_user` instance (in the memory):\n', '   *   `_user.pendedCvp` gets increased by `newlyEntitled - newlyVested`\n', '   *   `_user.vestingBlock` set to the updated value\n', '   *   `_user.lastUpdateBlock` set to the current block\n', '   *\n', '   * @param _user - user to compute tokens for\n', "   * @param accCvpPerLpt - value of the pool' `pool.accCvpPerLpt`\n", '   * @return newlyEntitled - CVP amount to entitle (on top of tokens entitled so far)\n', '   * @return newlyVested - CVP amount to vest (on top of tokens already vested)\n', '   */\n', '  function _computeCvpVesting(\n', '    User memory _user,\n', '    Pool memory pool,\n', '    UserPoolBoost memory _userPB,\n', '    PoolBoost memory _poolBoost\n', '  ) internal view returns (uint256 newlyEntitled, uint256 newlyVested) {\n', '    uint32 prevBlock = _user.lastUpdateBlock;\n', '    _user.lastUpdateBlock = _currBlock();\n', '    if (prevBlock >= _user.lastUpdateBlock) {\n', '      return (0, 0);\n', '    }\n', '\n', '    uint32 age = _user.lastUpdateBlock - prevBlock;\n', '\n', '    // Tokens which are to be entitled starting from the `user.lastUpdateBlock`, shall be\n', '    // vested proportionally to the number of blocks already minted within the period between\n', '    // the `user.lastUpdateBlock` and `cvpVestingPeriodInBlocks` following the current block\n', '    newlyEntitled = uint256(_computeCvpToEntitle(_user, pool, _userPB, _poolBoost));\n', '    uint256 newToVest =\n', '      newlyEntitled == 0 ? 0 : (newlyEntitled.mul(uint256(age)).div(uint256(age + cvpVestingPeriodInBlocks)));\n', '\n', '    // Tokens which have been pended since the `user.lastUpdateBlock` shall be vested:\n', '    // - in full, if the `user.vestingBlock` has been mined\n', '    // - otherwise, proportionally to the number of blocks already mined so far in the period\n', '    //   between the `user.lastUpdateBlock` and the `user.vestingBlock` (not yet mined)\n', '    uint256 pended = uint256(_user.pendedCvp);\n', '    age = _user.lastUpdateBlock >= _user.vestingBlock ? cvpVestingPeriodInBlocks : _user.lastUpdateBlock - prevBlock;\n', '    uint256 pendedToVest =\n', '      pended == 0\n', '        ? 0\n', '        : (\n', '          age >= cvpVestingPeriodInBlocks\n', '            ? pended\n', '            : pended.mul(uint256(age)).div(uint256(_user.vestingBlock - prevBlock))\n', '        );\n', '\n', '    newlyVested = pendedToVest.add(newToVest);\n', '    _user.pendedCvp = SafeMath96.fromUint(\n', '      uint256(_user.pendedCvp).add(newlyEntitled).sub(newlyVested),\n', '      "VLPMining::computeCvpVest:1"\n', '    );\n', '\n', '    // Amount of CVP token pended (i.e. not yet vested) from now\n', '    uint256 remainingPended = pended == 0 ? 0 : pended.sub(pendedToVest);\n', '    uint256 unreleasedNewly = newlyEntitled == 0 ? 0 : newlyEntitled.sub(newToVest);\n', '    uint256 pending = remainingPended.add(unreleasedNewly);\n', '\n', '    // Compute the vesting block (i.e. when the pended tokens to be all vested)\n', '    uint256 period = 0;\n', '    if (remainingPended == 0 || pending == 0) {\n', '      // newly entitled CVPs only or nothing remain pended\n', '      period = cvpVestingPeriodInBlocks;\n', '    } else {\n', '      // "old" CVPs and, perhaps, "new" CVPs are pending - the weighted average applied\n', '      age = _user.vestingBlock - _user.lastUpdateBlock;\n', '      period = ((remainingPended.mul(age)).add(unreleasedNewly.mul(cvpVestingPeriodInBlocks))).div(pending);\n', '    }\n', '    _user.vestingBlock =\n', '      _user.lastUpdateBlock +\n', '      (cvpVestingPeriodInBlocks > uint32(period) ? uint32(period) : cvpVestingPeriodInBlocks);\n', '\n', '    return (newlyEntitled, newlyVested);\n', '  }\n', '\n', '  function _computePoolReward(Pool memory _pool) internal view returns (uint256 poolCvpReward) {\n', '    (poolCvpReward, _pool.accCvpPerLpt, _pool.lastUpdateBlock) = _computeReward(\n', '      _pool.lastUpdateBlock,\n', '      _pool.accCvpPerLpt,\n', '      _pool.lpToken,\n', '      SCALE.mul(uint256(cvpPerBlock)).mul(uint256(_pool.allocPoint)).div(totalAllocPoint)\n', '    );\n', '  }\n', '\n', '  function _computePoolRewardByBoost(Pool memory _pool, PoolBoost memory _poolBoost)\n', '    internal\n', '    view\n', '    returns (uint256 poolCvpReward)\n', '  {\n', '    (poolCvpReward, _poolBoost.accCvpPerLpBoost, _pool.lastUpdateBlock) = _computeReward(\n', '      _pool.lastUpdateBlock,\n', '      _poolBoost.accCvpPerLpBoost,\n', '      _pool.lpToken,\n', '      _poolBoost.lpBoostRate\n', '    );\n', '  }\n', '\n', '  function _computePoolBoostReward(PoolBoost memory _poolBoost) internal view returns (uint256 poolCvpReward) {\n', '    (poolCvpReward, _poolBoost.accCvpPerCvpBoost, _poolBoost.lastUpdateBlock) = _computeReward(\n', '      _poolBoost.lastUpdateBlock,\n', '      _poolBoost.accCvpPerCvpBoost,\n', '      cvp,\n', '      _poolBoost.cvpBoostRate\n', '    );\n', '  }\n', '\n', '  function _computeReward(\n', '    uint256 _lastUpdateBlock,\n', '    uint256 _accumulated,\n', '    IERC20 _token,\n', '    uint256 _cvpPoolRate\n', '  )\n', '    internal\n', '    view\n', '    returns (\n', '      uint256 poolCvpReward,\n', '      uint256 newAccumulated,\n', '      uint32 newLastUpdateBlock\n', '    )\n', '  {\n', '    newAccumulated = _accumulated;\n', '\n', '    newLastUpdateBlock = _currBlock();\n', '    if (newLastUpdateBlock > _lastUpdateBlock) {\n', "      uint256 multiplier = uint256(newLastUpdateBlock - _lastUpdateBlock); // can't overflow\n", '\n', '      uint256 lptBalance = _token.balanceOf(address(this));\n', '      if (lptBalance != 0) {\n', '        poolCvpReward = multiplier.mul(_cvpPoolRate).div(SCALE);\n', '\n', '        newAccumulated = newAccumulated.add(poolCvpReward.mul(SCALE).div(lptBalance));\n', '      }\n', '    }\n', '  }\n', '\n', '  function _computeUserVotes(\n', '    uint192 userData,\n', '    uint192 sharedData,\n', '    uint192 sharedDataAtUserSave\n', '  ) internal pure override returns (uint96 votes) {\n', '    (uint96 ownCvp, uint96 pooledCvpShare) = _unpackData(userData);\n', '    (uint96 currentTotalPooledCvp, ) = _unpackData(sharedData);\n', '    (uint96 totalPooledCvpAtUserSave, ) = _unpackData(sharedDataAtUserSave);\n', '\n', '    if (pooledCvpShare == 0) {\n', '      votes = ownCvp;\n', '    } else {\n', '      uint256 pooledCvp = uint256(pooledCvpShare).mul(currentTotalPooledCvp).div(SCALE);\n', '      if (currentTotalPooledCvp != totalPooledCvpAtUserSave) {\n', '        uint256 totalCvpDiffRatio = uint256(currentTotalPooledCvp).mul(SCALE).div(uint256(totalPooledCvpAtUserSave));\n', '        if (totalCvpDiffRatio > SCALE) {\n', '          pooledCvp = pooledCvp.mul(SCALE).div(totalCvpDiffRatio);\n', '        }\n', '      }\n', '      votes = ownCvp.add(SafeMath96.fromUint(pooledCvp, "VLPMining::_computeVotes"));\n', '    }\n', '  }\n', '\n', '  function _computeCvpToEntitle(\n', '    User memory user,\n', '    Pool memory pool,\n', '    UserPoolBoost memory userPB,\n', '    PoolBoost memory poolBoost\n', '  ) private view returns (uint96 cvpResult) {\n', '    if (user.lptAmount == 0) {\n', '      return 0;\n', '    }\n', '    return\n', '      _computeCvpAdjustmentWithBoost(user.lptAmount, pool, userPB, poolBoost).sub(\n', '        user.cvpAdjust,\n', '        "VLPMining::computeCvp:2"\n', '      );\n', '  }\n', '\n', '  function _computeCvpAdjustmentWithBoost(\n', '    uint256 lptAmount,\n', '    Pool memory pool,\n', '    UserPoolBoost memory userPB,\n', '    PoolBoost memory poolBoost\n', '  ) private view returns (uint96 cvpResult) {\n', '    cvpResult = _computeCvpAdjustment(lptAmount, pool.accCvpPerLpt);\n', '    if (poolBoost.cvpBoostRate == 0 || poolBoost.lpBoostRate == 0 || userPB.balance == 0) {\n', '      return cvpResult;\n', '    }\n', '    return\n', '      cvpResult.add(_computeCvpAdjustment(userPB.balance, poolBoost.accCvpPerCvpBoost)).add(\n', '        _computeCvpAdjustment(lptAmount, poolBoost.accCvpPerLpBoost)\n', '      );\n', '  }\n', '\n', '  function _computeCvpAdjustment(uint256 lptAmount, uint256 accCvpPerLpt) private pure returns (uint96) {\n', '    return SafeMath96.fromUint(lptAmount.mul(accCvpPerLpt).div(SCALE), "VLPMining::_computeCvpAdj");\n', '  }\n', '\n', '  function cvpAmountNotInBoundsToBoost(\n', '    uint256 _cvpAmount,\n', '    uint256 _lpAmount,\n', '    address _lpToken\n', '  ) public view returns (bool) {\n', '    return\n', '      _cvpAmount < cvpBalanceToBoost(_lpAmount, _lpToken, true) ||\n', '      _cvpAmount > cvpBalanceToBoost(_lpAmount, _lpToken, false);\n', '  }\n', '\n', '  function cvpBalanceToBoost(\n', '    uint256 _lpAmount,\n', '    address _lpToken,\n', '    bool _min\n', '  ) public view returns (uint256) {\n', '    return _lpAmount.mul(_min ? lpBoostRatioByToken[_lpToken] : lpBoostMaxRatioByToken[_lpToken]).div(SCALE);\n', '  }\n', '\n', '  function _validatePoolId(uint256 pid) private view {\n', '    require(pid < pools.length, "VLPMining: invalid pool id");\n', '  }\n', '\n', '  function _currBlock() private view returns (uint32) {\n', '    return SafeMath32.fromUint(block.number, "VLPMining::_currBlock:overflow");\n', '  }\n', '\n', '  function _preventSameTxOriginAndMsgSender() internal {\n', '    require(block.number > lastSwapBlock[tx.origin], "SAME_TX_ORIGIN");\n', '    lastSwapBlock[tx.origin] = block.number;\n', '\n', '    if (msg.sender != tx.origin) {\n', '      require(block.number > lastSwapBlock[msg.sender], "SAME_MSG_SENDER");\n', '      lastSwapBlock[msg.sender] = block.number;\n', '    }\n', '  }\n', '}']