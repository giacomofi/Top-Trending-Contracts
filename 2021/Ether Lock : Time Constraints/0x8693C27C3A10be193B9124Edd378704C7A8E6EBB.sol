['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-24\n', '*/\n', '\n', '// File: contracts/lib/SafeMath.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath mul overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath div 0"); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath sub b > a");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath add overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath mod 0");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/crossApproach/lib/HTLCTxLib.sol\n', '\n', '/*\n', '\n', '  Copyright 2019 Wanchain Foundation.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License");\n', '  you may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '  Unless required by applicable law or agreed to in writing, software\n', '  distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions and\n', '  limitations under the License.\n', '\n', '*/\n', '\n', '//                            _           _           _\n', '//  __      ____ _ _ __   ___| |__   __ _(_)_ __   __| | _____   __\n', "//  \\ \\ /\\ / / _` | '_ \\ / __| '_ \\ / _` | | '_ \\@/ _` |/ _ \\ \\ / /\n", '//   \\ V  V / (_| | | | | (__| | | | (_| | | | | | (_| |  __/\\ V /\n', '//    \\_/\\_/ \\__,_|_| |_|\\___|_| |_|\\__,_|_|_| |_|\\__,_|\\___| \\_/\n', '//\n', '//\n', '\n', 'pragma solidity ^0.4.26;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'library HTLCTxLib {\n', '    using SafeMath for uint;\n', '\n', '    /**\n', '     *\n', '     * ENUMS\n', '     *\n', '     */\n', '\n', '    /// @notice tx info status\n', '    /// @notice uninitialized,locked,redeemed,revoked\n', '    enum TxStatus {None, Locked, Redeemed, Revoked, AssetLocked, DebtLocked}\n', '\n', '    /**\n', '     *\n', '     * STRUCTURES\n', '     *\n', '     */\n', '\n', '    /// @notice struct of HTLC user mint lock parameters\n', '    struct HTLCUserParams {\n', '        bytes32 xHash;                  /// hash of HTLC random number\n', '        bytes32 smgID;                  /// ID of storeman group which user has selected\n', '        uint tokenPairID;               /// token pair id on cross chain\n', '        uint value;                     /// exchange token value\n', '        uint lockFee;                   /// exchange token value\n', '        uint lockedTime;                /// HTLC lock time\n', '    }\n', '\n', '    /// @notice HTLC(Hashed TimeLock Contract) tx info\n', '    struct BaseTx {\n', '        bytes32 smgID;                  /// HTLC transaction storeman ID\n', '        uint lockedTime;                /// HTLC transaction locked time\n', '        uint beginLockedTime;           /// HTLC transaction begin locked time\n', '        TxStatus status;                /// HTLC transaction status\n', '    }\n', '\n', '    /// @notice user  tx info\n', '    struct UserTx {\n', '        BaseTx baseTx;\n', '        uint tokenPairID;\n', '        uint value;\n', '        uint fee;\n', "        address userAccount;            /// HTLC transaction sender address for the security check while user's revoke\n", '    }\n', '    /// @notice storeman  tx info\n', '    struct SmgTx {\n', '        BaseTx baseTx;\n', '        uint tokenPairID;\n', '        uint value;\n', "        address  userAccount;          /// HTLC transaction user address for the security check while user's redeem\n", '    }\n', '    /// @notice storeman  debt tx info\n', '    struct DebtTx {\n', '        BaseTx baseTx;\n', '        bytes32 srcSmgID;              /// HTLC transaction sender(source storeman) ID\n', '    }\n', '\n', '    struct Data {\n', '        /// @notice mapping of hash(x) to UserTx -- xHash->htlcUserTxData\n', '        mapping(bytes32 => UserTx) mapHashXUserTxs;\n', '\n', '        /// @notice mapping of hash(x) to SmgTx -- xHash->htlcSmgTxData\n', '        mapping(bytes32 => SmgTx) mapHashXSmgTxs;\n', '\n', '        /// @notice mapping of hash(x) to DebtTx -- xHash->htlcDebtTxData\n', '        mapping(bytes32 => DebtTx) mapHashXDebtTxs;\n', '\n', '    }\n', '\n', '    /**\n', '     *\n', '     * MANIPULATIONS\n', '     *\n', '     */\n', '\n', '    /// @notice                     add user transaction info\n', '    /// @param params               parameters for user tx\n', '    function addUserTx(Data storage self, HTLCUserParams memory params)\n', '        public\n', '    {\n', '        UserTx memory userTx = self.mapHashXUserTxs[params.xHash];\n', '        // UserTx storage userTx = self.mapHashXUserTxs[params.xHash];\n', '        // require(params.value != 0, "Value is invalid");\n', '        require(userTx.baseTx.status == TxStatus.None, "User tx exists");\n', '\n', '        userTx.baseTx.smgID = params.smgID;\n', '        userTx.baseTx.lockedTime = params.lockedTime;\n', '        userTx.baseTx.beginLockedTime = now;\n', '        userTx.baseTx.status = TxStatus.Locked;\n', '        userTx.tokenPairID = params.tokenPairID;\n', '        userTx.value = params.value;\n', '        userTx.fee = params.lockFee;\n', '        userTx.userAccount = msg.sender;\n', '\n', '        self.mapHashXUserTxs[params.xHash] = userTx;\n', '    }\n', '\n', '    /// @notice                     refund coins from HTLC transaction, which is used for storeman redeem(outbound)\n', '    /// @param x                    HTLC random number\n', '    function redeemUserTx(Data storage self, bytes32 x)\n', '        external\n', '        returns(bytes32 xHash)\n', '    {\n', '        xHash = sha256(abi.encodePacked(x));\n', '\n', '        UserTx storage userTx = self.mapHashXUserTxs[xHash];\n', '        require(userTx.baseTx.status == TxStatus.Locked, "Status is not locked");\n', '        require(now < userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime), "Redeem timeout");\n', '\n', '        userTx.baseTx.status = TxStatus.Redeemed;\n', '\n', '        return xHash;\n', '    }\n', '\n', '    /// @notice                     revoke user transaction\n', '    /// @param  xHash               hash of HTLC random number\n', '    function revokeUserTx(Data storage self, bytes32 xHash)\n', '        external\n', '    {\n', '        UserTx storage userTx = self.mapHashXUserTxs[xHash];\n', '        require(userTx.baseTx.status == TxStatus.Locked, "Status is not locked");\n', '        require(now >= userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime), "Revoke is not permitted");\n', '\n', '        userTx.baseTx.status = TxStatus.Revoked;\n', '    }\n', '\n', '    /// @notice                    function for get user info\n', '    /// @param xHash               hash of HTLC random number\n', '    /// @return smgID              ID of storeman which user has selected\n', '    /// @return tokenPairID        token pair ID of cross chain\n', '    /// @return value              exchange value\n', '    /// @return fee                exchange fee\n', "    /// @return userAccount        HTLC transaction sender address for the security check while user's revoke\n", '    function getUserTx(Data storage self, bytes32 xHash)\n', '        external\n', '        view\n', '        returns (bytes32, uint, uint, uint, address)\n', '    {\n', '        UserTx storage userTx = self.mapHashXUserTxs[xHash];\n', '        return (userTx.baseTx.smgID, userTx.tokenPairID, userTx.value, userTx.fee, userTx.userAccount);\n', '    }\n', '\n', '    /// @notice                     add storeman transaction info\n', '    /// @param  xHash               hash of HTLC random number\n', '    /// @param  smgID               ID of the storeman which user has selected\n', '    /// @param  tokenPairID         token pair ID of cross chain\n', '    /// @param  value               HTLC transfer value of token\n', '    /// @param  userAccount            user account address on the destination chain, which is used to redeem token\n', '    function addSmgTx(Data storage self, bytes32 xHash, bytes32 smgID, uint tokenPairID, uint value, address userAccount, uint lockedTime)\n', '        external\n', '    {\n', '        SmgTx memory smgTx = self.mapHashXSmgTxs[xHash];\n', '        // SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n', '        require(value != 0, "Value is invalid");\n', '        require(smgTx.baseTx.status == TxStatus.None, "Smg tx exists");\n', '\n', '        smgTx.baseTx.smgID = smgID;\n', '        smgTx.baseTx.status = TxStatus.Locked;\n', '        smgTx.baseTx.lockedTime = lockedTime;\n', '        smgTx.baseTx.beginLockedTime = now;\n', '        smgTx.tokenPairID = tokenPairID;\n', '        smgTx.value = value;\n', '        smgTx.userAccount = userAccount;\n', '\n', '        self.mapHashXSmgTxs[xHash] = smgTx;\n', '    }\n', '\n', '    /// @notice                     refund coins from HTLC transaction, which is used for users redeem(inbound)\n', '    /// @param x                    HTLC random number\n', '    function redeemSmgTx(Data storage self, bytes32 x)\n', '        external\n', '        returns(bytes32 xHash)\n', '    {\n', '        xHash = sha256(abi.encodePacked(x));\n', '\n', '        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n', '        require(smgTx.baseTx.status == TxStatus.Locked, "Status is not locked");\n', '        require(now < smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime), "Redeem timeout");\n', '\n', '        smgTx.baseTx.status = TxStatus.Redeemed;\n', '\n', '        return xHash;\n', '    }\n', '\n', '    /// @notice                     revoke storeman transaction\n', '    /// @param  xHash               hash of HTLC random number\n', '    function revokeSmgTx(Data storage self, bytes32 xHash)\n', '        external\n', '    {\n', '        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n', '        require(smgTx.baseTx.status == TxStatus.Locked, "Status is not locked");\n', '        require(now >= smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime), "Revoke is not permitted");\n', '\n', '        smgTx.baseTx.status = TxStatus.Revoked;\n', '    }\n', '\n', '    /// @notice                     function for get smg info\n', '    /// @param xHash                hash of HTLC random number\n', '    /// @return smgID               ID of storeman which user has selected\n', '    /// @return tokenPairID         token pair ID of cross chain\n', '    /// @return value               exchange value\n', '    /// @return userAccount            user account address for redeem\n', '    function getSmgTx(Data storage self, bytes32 xHash)\n', '        external\n', '        view\n', '        returns (bytes32, uint, uint, address)\n', '    {\n', '        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n', '        return (smgTx.baseTx.smgID, smgTx.tokenPairID, smgTx.value, smgTx.userAccount);\n', '    }\n', '\n', '    /// @notice                     add storeman transaction info\n', '    /// @param  xHash               hash of HTLC random number\n', '    /// @param  srcSmgID            ID of source storeman group\n', '    /// @param  destSmgID           ID of the storeman which will take over of the debt of source storeman group\n', '    /// @param  lockedTime          HTLC lock time\n', "    /// @param  status              Status, should be 'Locked' for asset or 'DebtLocked' for debt\n", '    function addDebtTx(Data storage self, bytes32 xHash, bytes32 srcSmgID, bytes32 destSmgID, uint lockedTime, TxStatus status)\n', '        external\n', '    {\n', '        DebtTx memory debtTx = self.mapHashXDebtTxs[xHash];\n', '        // DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n', '        require(debtTx.baseTx.status == TxStatus.None, "Debt tx exists");\n', '\n', '        debtTx.baseTx.smgID = destSmgID;\n', '        debtTx.baseTx.status = status;//TxStatus.Locked;\n', '        debtTx.baseTx.lockedTime = lockedTime;\n', '        debtTx.baseTx.beginLockedTime = now;\n', '        debtTx.srcSmgID = srcSmgID;\n', '\n', '        self.mapHashXDebtTxs[xHash] = debtTx;\n', '    }\n', '\n', '    /// @notice                     refund coins from HTLC transaction\n', '    /// @param x                    HTLC random number\n', "    /// @param status               Status, should be 'Locked' for asset or 'DebtLocked' for debt\n", '    function redeemDebtTx(Data storage self, bytes32 x, TxStatus status)\n', '        external\n', '        returns(bytes32 xHash)\n', '    {\n', '        xHash = sha256(abi.encodePacked(x));\n', '\n', '        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n', '        // require(debtTx.baseTx.status == TxStatus.Locked, "Status is not locked");\n', '        require(debtTx.baseTx.status == status, "Status is not locked");\n', '        require(now < debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime), "Redeem timeout");\n', '\n', '        debtTx.baseTx.status = TxStatus.Redeemed;\n', '\n', '        return xHash;\n', '    }\n', '\n', '    /// @notice                     revoke debt transaction, which is used for source storeman group\n', '    /// @param  xHash               hash of HTLC random number\n', "    /// @param  status              Status, should be 'Locked' for asset or 'DebtLocked' for debt\n", '    function revokeDebtTx(Data storage self, bytes32 xHash, TxStatus status)\n', '        external\n', '    {\n', '        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n', '        // require(debtTx.baseTx.status == TxStatus.Locked, "Status is not locked");\n', '        require(debtTx.baseTx.status == status, "Status is not locked");\n', '        require(now >= debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime), "Revoke is not permitted");\n', '\n', '        debtTx.baseTx.status = TxStatus.Revoked;\n', '    }\n', '\n', '    /// @notice                     function for get debt info\n', '    /// @param xHash                hash of HTLC random number\n', '    /// @return srcSmgID            ID of source storeman\n', '    /// @return destSmgID           ID of destination storeman\n', '    function getDebtTx(Data storage self, bytes32 xHash)\n', '        external\n', '        view\n', '        returns (bytes32, bytes32)\n', '    {\n', '        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n', '        return (debtTx.srcSmgID, debtTx.baseTx.smgID);\n', '    }\n', '\n', '    function getLeftTime(uint endTime) private view returns (uint) {\n', '        if (now < endTime) {\n', '            return endTime.sub(now);\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    /// @notice                     function for get debt info\n', '    /// @param xHash                hash of HTLC random number\n', '    /// @return leftTime            the left lock time\n', '    function getLeftLockedTime(Data storage self, bytes32 xHash)\n', '        external\n', '        view\n', '        returns (uint)\n', '    {\n', '        UserTx storage userTx = self.mapHashXUserTxs[xHash];\n', '        if (userTx.baseTx.status != TxStatus.None) {\n', '            return getLeftTime(userTx.baseTx.beginLockedTime.add(userTx.baseTx.lockedTime));\n', '        }\n', '        SmgTx storage smgTx = self.mapHashXSmgTxs[xHash];\n', '        if (smgTx.baseTx.status != TxStatus.None) {\n', '            return getLeftTime(smgTx.baseTx.beginLockedTime.add(smgTx.baseTx.lockedTime));\n', '        }\n', '        DebtTx storage debtTx = self.mapHashXDebtTxs[xHash];\n', '        if (debtTx.baseTx.status != TxStatus.None) {\n', '            return getLeftTime(debtTx.baseTx.beginLockedTime.add(debtTx.baseTx.lockedTime));\n', '        }\n', "        require(false, 'invalid xHash');\n", '    }\n', '}']