['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-09\n', '*/\n', '\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface IERC20 {\n', '\n', '}\n', '\n', 'interface IGUniPool {\n', '    function token0() external view returns (IERC20);\n', '\n', '    function token1() external view returns (IERC20);\n', '\n', '    // function pool() external view returns (IUniswapV3Pool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    // function mint(uint256 mintAmount, address receiver)\n', '    //     external\n', '    //     returns (\n', '    //         uint256 amount0,\n', '    //         uint256 amount1,\n', '    //         uint128 liquidityMinted\n', '    //     );\n', '\n', '    // function burn(uint256 burnAmount, address receiver)\n', '    //     external\n', '    //     returns (\n', '    //         uint256 amount0,\n', '    //         uint256 amount1,\n', '    //         uint128 liquidityBurned\n', '    //     );\n', '\n', '    // function getMintAmounts(uint256 amount0Max, uint256 amount1Max)\n', '    //     external\n', '    //     view\n', '    //     returns (\n', '    //         uint256 amount0,\n', '    //         uint256 amount1,\n', '    //         uint256 mintAmount\n', '    //     );\n', '\n', '    // function getPositionID() external view returns (bytes32 positionID);\n', '}\n', '\n', 'interface IGUniRouter {\n', '\n', '    function getPoolUnderlyingBalances(IGUniPool pool)\n', '        external\n', '        view\n', '        returns (uint256 amount0, uint256 amount1);\n', '\n', '    function getUnderlyingBalances(\n', '        IGUniPool pool,\n', '        address account,\n', '        uint256 balance\n', '    ) external view returns (uint256 amount0, uint256 amount1);\n', '\n', '}\n', '\n', 'struct StakingRewardsInfo {\n', '    address stakingRewards;\n', '    uint rewardAmount;\n', '}\n', 'interface StakingFactoryInterface {\n', '\n', '    function stakingRewardsInfoByStakingToken(address) external view returns(StakingRewardsInfo memory);\n', '\n', '}\n', '\n', 'interface StakingInterface {\n', '    function totalSupply() external view returns (uint256);\n', '    function rewardRate() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function earned(address account) external view returns (uint256);\n', '    function rewardPerToken() external view returns (uint256);\n', '}\n', '\n', '\n', 'contract DSMath {\n', '\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x + y) >= x, "math-not-safe");\n', '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "math-not-safe");\n', '    }\n', '\n', '    uint constant WAD = 10 ** 18;\n', '\n', '    function wmul(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '\n', '    function wdiv(uint x, uint y) internal pure returns (uint z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '}\n', '\n', 'contract Helpers is DSMath {\n', '\n', '    StakingFactoryInterface public constant getStakingFactory = StakingFactoryInterface(0xf39eC5a471edF20Ecc7db1c2c34B4C73ab4B2C19);\n', '    IGUniRouter public constant gelatoRouter = IGUniRouter(0x8CA6fa325bc32f86a12cC4964Edf1f71655007A7);\n', '\n', '    struct UserData {\n', '        address pool; // address of pool contract\n', '        address staking; // address of staking contract\n', '        address token0Addr; // address of token 0\n', '        address token1Addr; // address of token 1\n', '        uint poolTokenSupply; // Total supply of Pool token\n', '        uint poolToken0Bal; // balance of total pool for token0\n', '        uint poolToken1Bal; // balance of total pool for token1\n', '        uint poolTokenSupplyStaked; // total pool token locked in staking contract\n', '        uint stakingToken0Bal; // total balance of token0 in Staking\n', '        uint stakingToken1Bal; // total balance of token1 in Staking\n', '        uint rewardRate; // INST distributing per second\n', '        uint token0Bal; // balance of token 0 of user\n', '        uint token1Bal; // balance of token 1 of user\n', '        uint earned; // INST earned from staking\n', "        uint stakedBal; // user's pool token bal in staking contract\n", "        uint poolBal; // ideal pool token in user's DSA\n", '        uint totalBal; // stakedBal + poolTknBal\n', '    }\n', '\n', '}\n', '\n', 'contract Resolver is Helpers {\n', '\n', '    function getSinglePosition(address user, address pool) public view returns(UserData memory _data) {\n', '        _data.pool = pool;\n', '        StakingInterface stakingContract = StakingInterface(getStakingFactory.stakingRewardsInfoByStakingToken(pool).stakingRewards);\n', '        _data.staking = address(stakingContract);\n', '        IGUniPool poolContract = IGUniPool(pool);\n', '        _data.token0Addr = address(poolContract.token0());\n', '        _data.token1Addr = address(poolContract.token1());\n', '        if (_data.staking == address(0)) {\n', '            _data.earned = 0;\n', '            _data.stakedBal = 0;\n', '        } else {\n', '            _data.earned = stakingContract.earned(user);\n', '            _data.stakedBal = stakingContract.balanceOf(user);\n', '        }\n', '        _data.poolBal = poolContract.balanceOf(user);\n', '        _data.totalBal = add(_data.stakedBal, _data.poolBal);\n', '        (_data.token0Bal, _data.token1Bal) = gelatoRouter.getUnderlyingBalances(poolContract, user, _data.totalBal);\n', '        _data.poolTokenSupply = poolContract.balanceOf(user);\n', '        (_data.poolToken0Bal, _data.poolToken1Bal) = gelatoRouter.getPoolUnderlyingBalances(poolContract);\n', '        _data.poolTokenSupplyStaked = stakingContract.totalSupply();\n', '        (_data.stakingToken0Bal, _data.stakingToken1Bal) = gelatoRouter.getUnderlyingBalances(poolContract, _data.staking, _data.poolTokenSupplyStaked);\n', '        _data.rewardRate = stakingContract.rewardRate();\n', '    }\n', '\n', '    function getPosition(address user, address[] memory pools) public view returns(UserData[] memory _data) {\n', '        for (uint i = 0; i < pools.length; i++) {\n', '            _data[i] = getSinglePosition(user, pools[i]);\n', '        }\n', '    }\n', '\n', '}']