['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-24\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '  function initialize() external;\n', '  function totalSupply() external view returns (uint);\n', '  function balanceOf(address account) external view returns (uint);\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '  function allowance(address owner, address spender) external view returns (uint);\n', '  function symbol() external view returns (string memory);\n', '  function decimals() external view returns (uint);\n', '  function approve(address spender, uint amount) external returns (bool);\n', '  function mint(address account, uint amount) external;\n', '  function burn(address account, uint amount) external;\n', '  function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract Ownable {\n', '\n', '  address public owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor() {\n', '    owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), owner);\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(isOwner(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  function isOwner() public view returns (bool) {\n', '    return msg.sender == owner;\n', '  }\n', '\n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(owner, address(0));\n', '    owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract MasterPool is Ownable {\n', '\n', '  struct UserInfo {\n', '    uint amount;\n', '    uint rewardDebt;\n', '  }\n', '\n', '  // Info of each pool.\n', '  struct PoolInfo {\n', '    IERC20 lpToken;        // Address of LP token contract.\n', '    uint allocPoints;      // How many allocation points assigned to this pool. RewardTokens to distribute per block.\n', '    uint lastRewardBlock;  // Last block number that RewardTokens distribution occurs.\n', '    uint accRewardTokenPerShare; // Accumulated RewardTokens per share, times 1e12. See below.\n', '  }\n', '\n', '  struct PoolPosition {\n', '    uint pid;\n', '    bool added; // To prevent duplicates.\n', '  }\n', '\n', '  IERC20 public rewardToken;\n', '  uint public rewardTokenPerBlock;\n', '\n', '  // Info of each pool.\n', '  PoolInfo[] public poolInfo;\n', '  // Info of each user that stakes LP tokens.\n', '  mapping (uint => mapping (address => UserInfo)) public userInfo;\n', '  mapping (address => PoolPosition) public pidByToken;\n', '  // Total allocation poitns. Must be the sum of all allocation points in all pools.\n', '  uint public totalAllocPoints;\n', '  // The block number when RewardToken mining starts.\n', '  uint public startBlock;\n', '\n', '  event Deposit(address indexed user, uint indexed pid, uint amount);\n', '  event Withdraw(address indexed user, uint indexed pid, uint amount);\n', '  event EmergencyWithdraw(address indexed user, uint indexed pid, uint amount);\n', '\n', '  event PoolUpdate(\n', '    address indexed lpToken,\n', '    uint    indexed pid,\n', '    uint            allocPoints,\n', '    bool    indexed withUpdate\n', '  );\n', '\n', '  constructor(\n', '    IERC20 _rewardToken,\n', '    uint _rewardTokenPerBlock,\n', '    uint _startBlock\n', '  ) {\n', '    rewardToken = _rewardToken;\n', '    rewardTokenPerBlock = _rewardTokenPerBlock;\n', '    startBlock = _startBlock;\n', '  }\n', '\n', '  function poolLength() external view returns (uint) {\n', '    return poolInfo.length;\n', '  }\n', '\n', '  // Add a new lp to the pool. Can only be called by the owner.\n', '  function add(address _lpToken, uint _allocPoints, bool _withUpdate) public onlyOwner {\n', '\n', '    require(pidByToken[_lpToken].added == false, "MasterPool: already added");\n', '\n', '    if (_withUpdate) {\n', '      massUpdatePools();\n', '    }\n', '\n', '    uint lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n', '    totalAllocPoints = totalAllocPoints + _allocPoints;\n', '    poolInfo.push(PoolInfo({\n', '      lpToken: IERC20(_lpToken),\n', '      allocPoints: _allocPoints,\n', '      lastRewardBlock: lastRewardBlock,\n', '      accRewardTokenPerShare: 0\n', '    }));\n', '\n', '    pidByToken[_lpToken] = PoolPosition({\n', '      pid: poolInfo.length - 1,\n', '      added: true\n', '    });\n', '\n', '    emit PoolUpdate(_lpToken, poolInfo.length - 1, _allocPoints, _withUpdate);\n', '  }\n', '\n', "  // Update the given pool's RewardToken allocation point. Can only be called by the owner.\n", '  function set(uint _pid, uint _allocPoints, bool _withUpdate) public onlyOwner {\n', '\n', '    if (_withUpdate) {\n', '      massUpdatePools();\n', '    }\n', '\n', '    totalAllocPoints = totalAllocPoints - poolInfo[_pid].allocPoints + _allocPoints;\n', '    poolInfo[_pid].allocPoints = _allocPoints;\n', '\n', '    emit PoolUpdate(address(poolInfo[_pid].lpToken), _pid, _allocPoints, _withUpdate);\n', '  }\n', '\n', '  // View function to see pending RewardTokens on frontend.\n', '  function pendingRewards(uint _pid, address _user) external view returns (uint) {\n', '\n', '    PoolInfo storage pool = poolInfo[_pid];\n', '    UserInfo storage user = userInfo[_pid][_user];\n', '    uint accRewardTokenPerShare = pool.accRewardTokenPerShare;\n', '    uint lpSupply = pool.lpToken.balanceOf(address(this));\n', '\n', '    if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n', '      uint multiplier = block.number - pool.lastRewardBlock;\n', '      uint rewardTokenReward = multiplier * rewardTokenPerBlock * pool.allocPoints / totalAllocPoints;\n', '      accRewardTokenPerShare += rewardTokenReward * 1e12 / lpSupply;\n', '    }\n', '\n', '    return (user.amount * accRewardTokenPerShare / 1e12) - user.rewardDebt;\n', '  }\n', '\n', '  // Update reward vairables for all pools. Be careful of gas spending!\n', '  function massUpdatePools() public {\n', '      uint length = poolInfo.length;\n', '      for (uint pid = 0; pid < length; ++pid) {\n', '        updatePool(pid);\n', '      }\n', '  }\n', '\n', '  // Update reward variables of the given pool to be up-to-date.\n', '  function updatePool(uint _pid) public {\n', '    PoolInfo storage pool = poolInfo[_pid];\n', '    if (block.number <= pool.lastRewardBlock) {\n', '      return;\n', '    }\n', '    uint lpSupply = pool.lpToken.balanceOf(address(this));\n', '    if (lpSupply == 0) {\n', '      pool.lastRewardBlock = block.number;\n', '      return;\n', '    }\n', '    uint multiplier = block.number - pool.lastRewardBlock;\n', '    uint rewardTokenReward = multiplier * rewardTokenPerBlock * pool.allocPoints / totalAllocPoints;\n', '    pool.accRewardTokenPerShare += rewardTokenReward * 1e12 / lpSupply;\n', '    pool.lastRewardBlock = block.number;\n', '  }\n', '\n', '  function deposit(uint _pid, uint _amount) public {\n', '    PoolInfo storage pool = poolInfo[_pid];\n', '    UserInfo storage user = userInfo[_pid][msg.sender];\n', '    updatePool(_pid);\n', '\n', '    if (user.amount > 0) {\n', '      uint pending = (user.amount * pool.accRewardTokenPerShare / 1e12) - user.rewardDebt;\n', '      safeRewardTokenTransfer(msg.sender, pending);\n', '    }\n', '\n', '    pool.lpToken.transferFrom(address(msg.sender), address(this), _amount);\n', '    user.amount += _amount;\n', '    user.rewardDebt = user.amount * pool.accRewardTokenPerShare / 1e12;\n', '    emit Deposit(msg.sender, _pid, _amount);\n', '  }\n', '\n', '  function withdraw(uint _pid, uint _amount) public {\n', '    PoolInfo storage pool = poolInfo[_pid];\n', '    UserInfo storage user = userInfo[_pid][msg.sender];\n', '    require(user.amount >= _amount, "MasterPool: user.amount >= _amount");\n', '    updatePool(_pid);\n', '    uint pending = (user.amount * pool.accRewardTokenPerShare / 1e12) - user.rewardDebt;\n', '    safeRewardTokenTransfer(msg.sender, pending);\n', '    user.amount = user.amount - _amount;\n', '    user.rewardDebt = user.amount * pool.accRewardTokenPerShare / 1e12;\n', '    pool.lpToken.transfer(address(msg.sender), _amount);\n', '    emit Withdraw(msg.sender, _pid, _amount);\n', '  }\n', '\n', '  function emergencyWithdraw(uint _pid) public {\n', '    PoolInfo storage pool = poolInfo[_pid];\n', '    UserInfo storage user = userInfo[_pid][msg.sender];\n', '    pool.lpToken.transfer(address(msg.sender), user.amount);\n', '    emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n', '    user.amount = 0;\n', '    user.rewardDebt = 0;\n', '  }\n', '\n', '  // Allows to migrate rewards to a new staking contract.\n', '  function migrateRewards(address _recipient, uint _amount) public onlyOwner {\n', '    rewardToken.transfer(_recipient, _amount);\n', '  }\n', '\n', '  // Safe rewardToken transfer function, just in case if rounding error causes pool to not have enough RewardTokens.\n', '  function safeRewardTokenTransfer(address _to, uint _amount) internal {\n', '    uint rewardTokenBal = rewardToken.balanceOf(address(this));\n', '    if (_amount > rewardTokenBal) {\n', '      rewardToken.transfer(_to, rewardTokenBal);\n', '    } else {\n', '      rewardToken.transfer(_to, _amount);\n', '    }\n', '  }\n', '}']