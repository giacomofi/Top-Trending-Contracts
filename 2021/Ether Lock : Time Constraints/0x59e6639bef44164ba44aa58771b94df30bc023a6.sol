['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-15\n', '*/\n', '\n', 'pragma solidity = 0.5.16;\n', '\n', 'contract Ownable {\n', '\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == msg.sender, "YouSwap: CALLER_IS_NOT_THE_OWNER");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "YouSwap: NEW_OWNER_IS_THE_ZERO_ADDRESS");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract IDO is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    //Private offering\n', '    mapping(address => uint256) private _ordersOfPriIDO;\n', '    uint256 public startHeightOfPriIDO;\n', '    uint256 public endHeightOfPriIDO;\n', '    uint256 public totalUsdtAmountOfPriIDO = 0;\n', '    uint256 public constant supplyYouForPriIDO = 5 * 10 ** 11;//50万YOU\n', '    uint256 public reservedYouOfPriIDO = 0;\n', '    uint256 public constant upperLimitUsdtOfPriIDO = 500 * 10 ** 6;//500USDT\n', '    bool private _priOfferingFinished = false;\n', '    bool private _priIDOWithdrawFinished = false;\n', '\n', '    event PrivateOffering(address indexed participant, uint256 amountOfYou, uint256 amountOfUsdt);\n', '    event PrivateOfferingClaimed(address indexed participant, uint256 amountOfYou);\n', '\n', '    //Public offering\n', '    mapping(address => uint256) private _ordersOfPubIDO;\n', '    uint256 public constant targetUsdtAmountOfPubIDO = 5 * 10 ** 10;//5万USDT\n', '    uint256 public constant targetYouAmountOfPubIDO = 5 * 10 ** 11;//50万YOU\n', '    uint256 public totalUsdtAmountOfPubIDO = 0;\n', '    uint256 public startHeightOfPubIDO;\n', '    uint256 public endHeightOfPubIDO;\n', '    uint256 public constant bottomLimitUsdtOfPubIDO = 100 * 10 ** 6; //100USDT\n', '    bool private _pubIDOWithdrawFinished = false;\n', '\n', '    event PublicOffering(address indexed participant, uint256 amountOfUsdt);\n', '    event PublicOfferingClaimed(address indexed participant, uint256 amountOfYou);\n', '    event PublicOfferingRefund(address indexed participant, uint256 amountOfUsdt);\n', '\n', '    mapping(address => uint8) private _whiteList;\n', '\n', '    address private constant _usdtToken = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '    address private _youToken;\n', '\n', '    uint256 public constant initialLiquidYou = 3 * 10 ** 12;//3 000 000YOU For initial Liquid\n', '    address private constant _vault = 0x6B5C21a770dA1621BB28C9a2b6F282E5FC9154d5;\n', '\n', '    uint private unlocked = 1;\n', '    constructor(address youToken) public {\n', '        _youToken = youToken;\n', '\n', '        startHeightOfPriIDO = 12047150;\n', '        endHeightOfPriIDO = 12048590;\n', '\n', '        startHeightOfPubIDO = 0;\n', '        endHeightOfPubIDO = 0;\n', '    }\n', '\n', '    modifier lock() {\n', "        require(unlocked == 1, 'YouSwap: LOCKED');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    function initPubIDO(uint256 startHOfPubIDO, uint256 endHOfPubIDO) onlyOwner public {\n', "        require(startHeightOfPubIDO == 0 && startHOfPubIDO > block.number && endHOfPubIDO > startHOfPubIDO, 'YouSwap:NOT_ALLOWED');\n", '\n', '        startHeightOfPubIDO = startHOfPubIDO;\n', '        endHeightOfPubIDO = endHOfPubIDO;\n', '    }\n', '\n', '    modifier inWhiteList() {\n', '        require(_whiteList[msg.sender] == 1, "YouSwap: NOT_IN_WHITE_LIST");\n', '        _;\n', '    }\n', '\n', '    function isInWhiteList(address account) external view returns (bool) {\n', '        return _whiteList[account] == 1;\n', '    }\n', '\n', '    function addToWhiteList(address account) external onlyOwner {\n', '        _whiteList[account] = 1;\n', '    }\n', '\n', '    function addBatchToWhiteList(address[] calldata accounts) external onlyOwner {\n', '        for (uint i = 0; i < accounts.length; i++) {\n', '            _whiteList[accounts[i]] = 1;\n', '        }\n', '    }\n', '\n', '    function removeFromWhiteList(address account) external onlyOwner {\n', '        _whiteList[account] = 0;\n', '    }\n', '\n', '    function claim() inWhiteList external lock {\n', '        require((block.number >= endHeightOfPriIDO && _ordersOfPriIDO[msg.sender] > 0)\n', "            || (block.number >= endHeightOfPubIDO && _ordersOfPubIDO[msg.sender] > 0), 'YouSwap: FORBIDDEN');\n", '\n', '        uint256 reservedYouFromPriIDO = _ordersOfPriIDO[msg.sender];\n', '        if (block.number >= endHeightOfPriIDO && reservedYouFromPriIDO > 0) {\n', '            _ordersOfPriIDO[msg.sender] = 0;\n', '            _mintYou(_youToken, msg.sender, reservedYouFromPriIDO);\n', '            emit PrivateOfferingClaimed(msg.sender, reservedYouFromPriIDO);\n', '        }\n', '\n', '        uint256 amountOfUsdtPayed = _ordersOfPubIDO[msg.sender];\n', '        if (block.number >= endHeightOfPubIDO && amountOfUsdtPayed > 0) {\n', '            uint256 reservedYouFromPubIDO = 0;\n', '            if (totalUsdtAmountOfPubIDO > targetUsdtAmountOfPubIDO) {\n', '                uint256 availableAmountOfUsdt = amountOfUsdtPayed.mul(targetUsdtAmountOfPubIDO).div(totalUsdtAmountOfPubIDO);\n', '                reservedYouFromPubIDO = availableAmountOfUsdt.mul(10);\n', '                uint256 usdtAmountToRefund = amountOfUsdtPayed.sub(availableAmountOfUsdt).sub(10);\n', '\n', '                if (usdtAmountToRefund > 0) {\n', '                    _transfer(_usdtToken, msg.sender, usdtAmountToRefund);\n', '                    emit PublicOfferingRefund(msg.sender, usdtAmountToRefund);\n', '                }\n', '            }\n', '            else {\n', '                reservedYouFromPubIDO = amountOfUsdtPayed.mul(10);\n', '            }\n', '\n', '            _ordersOfPubIDO[msg.sender] = 0;\n', '            _mintYou(_youToken, msg.sender, reservedYouFromPubIDO);\n', '            emit PublicOfferingClaimed(msg.sender, reservedYouFromPubIDO);\n', '        }\n', '    }\n', '\n', '    function withdrawPriIDO() onlyOwner external {\n', "        require(block.number > endHeightOfPriIDO, 'YouSwap: BLOCK_HEIGHT_NOT_REACHED');\n", "        require(!_priIDOWithdrawFinished, 'YouSwap: PRI_IDO_WITHDRAWN_ALREADY');\n", '\n', '        _transfer(_usdtToken, _vault, totalUsdtAmountOfPriIDO);\n', '\n', '        _priIDOWithdrawFinished = true;\n', '    }\n', '\n', '    function withdrawPubIDO() onlyOwner external {\n', "        require(block.number > endHeightOfPubIDO, 'YouSwap: BLOCK_HEIGHT_NOT_REACHED');\n", "        require(!_pubIDOWithdrawFinished, 'YouSwap: PUB_IDO_WITHDRAWN_ALREADY');\n", '\n', '        uint256 amountToWithdraw = totalUsdtAmountOfPubIDO;\n', '        if (totalUsdtAmountOfPubIDO > targetUsdtAmountOfPubIDO) {\n', '            amountToWithdraw = targetUsdtAmountOfPubIDO;\n', '        }\n', '\n', '        _transfer(_usdtToken, _vault, amountToWithdraw);\n', '        _mintYou(_youToken, _vault, initialLiquidYou);\n', '\n', '        _pubIDOWithdrawFinished = true;\n', '    }\n', '\n', '    function privateOffering(uint256 amountOfUsdt) inWhiteList external lock returns (bool)  {\n', "        require(block.number >= startHeightOfPriIDO, 'YouSwap:NOT_STARTED_YET');\n", "        require(!_priOfferingFinished && block.number <= endHeightOfPriIDO, 'YouSwap:PRIVATE_OFFERING_ALREADY_FINISHED');\n", "        require(_ordersOfPriIDO[msg.sender] == 0, 'YouSwap: ENROLLED_ALREADY');\n", "        require(amountOfUsdt <= upperLimitUsdtOfPriIDO, 'YouSwap: EXCEEDS_THE_UPPER_LIMIT');\n", '        require(amountOfUsdt > 0, "YouSwap: INVALID_AMOUNT");\n', '\n', "        require(reservedYouOfPriIDO < supplyYouForPriIDO, 'YouSwap:INSUFFICIENT_YOU');\n", '        uint256 amountOfYou = amountOfUsdt.mul(10);\n', '        //0.1USDT/YOU\n', '        if (reservedYouOfPriIDO.add(amountOfYou) >= supplyYouForPriIDO) {\n', '            amountOfYou = supplyYouForPriIDO.sub(reservedYouOfPriIDO);\n', '            amountOfUsdt = amountOfYou.div(10);\n', '\n', '            _priOfferingFinished = true;\n', '        }\n', '        _transferFrom(_usdtToken, amountOfUsdt);\n', '\n', '        _ordersOfPriIDO[msg.sender] = amountOfYou;\n', '        reservedYouOfPriIDO = reservedYouOfPriIDO.add(amountOfYou);\n', '        totalUsdtAmountOfPriIDO = totalUsdtAmountOfPriIDO.add(amountOfUsdt);\n', '        emit PrivateOffering(msg.sender, amountOfYou, amountOfUsdt);\n', '\n', '        return true;\n', '    }\n', '\n', '    function priOfferingFinished() public view returns (bool) {\n', '        return block.number > endHeightOfPriIDO || _priOfferingFinished;\n', '    }\n', '\n', '    function pubOfferingFinished() public view returns (bool) {\n', '        return block.number > endHeightOfPubIDO;\n', '    }\n', '\n', '    function publicOffering(uint256 amountOfUsdt) external lock returns (bool)  {\n', "        require(block.number >= startHeightOfPubIDO, 'YouSwap:PUBLIC_OFFERING_NOT_STARTED_YET');\n", "        require(block.number <= endHeightOfPubIDO, 'YouSwap:PUBLIC_OFFERING_ALREADY_FINISHED');\n", "        require(amountOfUsdt >= bottomLimitUsdtOfPubIDO, 'YouSwap: 100USDT_AT_LEAST');\n", '\n', '        _transferFrom(_usdtToken, amountOfUsdt);\n', '\n', '        _ordersOfPubIDO[msg.sender] = _ordersOfPubIDO[msg.sender].add(amountOfUsdt);\n', '        totalUsdtAmountOfPubIDO = totalUsdtAmountOfPubIDO.add(amountOfUsdt);\n', '\n', '        emit PublicOffering(msg.sender, amountOfUsdt);\n', '\n', '        _whiteList[msg.sender] = 1;\n', '\n', '        return true;\n', '    }\n', '\n', '    function _transferFrom(address token, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, msg.sender, address(this), amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'YouSwap: TRANSFER_FAILED');\n", '    }\n', '\n', '    function _mintYou(address token, address recipient, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('mint(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'YouSwap: TRANSFER_FAILED');\n", '    }\n', '\n', '    function _transfer(address token, address recipient, uint amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'YouSwap: TRANSFER_FAILED');\n", '    }\n', '}']