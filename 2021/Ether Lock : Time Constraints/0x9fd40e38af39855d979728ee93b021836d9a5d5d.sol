['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-03\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-24\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-31\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a * b;\n', '    assert(a == 0 || c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner,"ERR_AUTHORIZED_OWNER_ONLY");\n', '    _;\n', '  }\n', '\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) onlyOwner public {\n', '    require(newOwner != address(0),"ERR_ZERO_ADDRESS");\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '}\n', '\n', 'library EnumerableSet {\n', '    // To implement this library for multiple types with as little code\n', '    // repetition as possible, we write it in terms of a generic Set type with\n', '    // bytes32 values.\n', '    // The Set implementation uses private functions, and user-facing\n', '    // implementations (such as AddressSet) are just wrappers around the\n', '    // underlying Set.\n', '    // This means that we can only create new EnumerableSets for types that fit\n', '    // in bytes32.\n', '\n', '    struct Set {\n', '        // Storage of set values\n', '        bytes32[] _values;\n', '\n', '        // Position of the value in the `values` array, plus 1 because index 0\n', '        // means a value is not in the set.\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', '            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '\n', '    // AddressSet\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(uint256(value)));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        return address(uint256(_at(set._inner, index)));\n', '    }\n', ' }\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract RemitPresale is Ownable{\n', '    using SafeMath for uint256;\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '    \n', '    uint256 public minDeposit;\n', '    uint256 public maxDeposit;\n', '    uint256 public tokenPrice;\n', '    uint256 public startTime;\n', '    uint256 public endTime;\n', '    uint256 public capAmount;\n', '    uint256 public totalInvestment;\n', '    uint256 public totalRemitPurchased;\n', '    bool public isPaused;\n', '    \n', '    address public walletAddress;\n', '    \n', '    IERC20 public remit;\n', '    constructor(address _tokenAddress,address _walletAddress)public{\n', '        \n', '        require(_walletAddress != address(0));\n', '        require(_tokenAddress != address(0));\n', '        remit = IERC20(_tokenAddress);\n', '        walletAddress = _walletAddress;\n', '    }\n', '        \n', '    \n', '    //Mappings\n', '    EnumerableSet.AddressSet private depositers;\n', '    \n', '    mapping(address => uint256)public claimableAmount;\n', '    \n', '    //Events\n', '    \n', '    event TokenPurchase(\n', '    address indexed beneficiary,\n', '    address indexed purchaser,\n', '    uint256 value,\n', '    uint256 amount\n', '  );\n', '  \n', '  event TokenClaimed(\n', '    address indexed purchaser,\n', '    uint256 timestamp,\n', '    uint256 amount\n', '  );\n', '      \n', '    \n', '    /*\n', '     * @dev To start the pre sale\n', '     * \n', '     * @param\n', "     *  '_endTime' - specifies the end time of pre sale\n", '     */\n', '    function startPresale(uint256 _endTime)external onlyOwner{\n', '        \n', '        require(minDeposit != 0 && maxDeposit != 0 && tokenPrice != 0 ,"ERR_SET_MINDEPOSIT_MAXDEPOSIT_PRICE_FIRST");\n', '        require(capAmount != 0,"ERR_CAP_AMOUNT_CANNOT_BE_0");\n', '        require(_endTime > now , "ERR_PRESALE_ENDTIME_CANNOT_BE_CURRENT_TIME");\n', '        \n', '        startTime = now;\n', '        endTime = _endTime;\n', '        isPaused = false;\n', '    }\n', '    \n', '     /*\n', '     * @dev To buy the tokens\n', '     *\n', '     */\n', '    function buyToken()public payable {\n', '        \n', '       address _buyer = msg.sender;\n', '       uint256 _ethDeposited = msg.value;\n', '       \n', '       require(startTime != 0,"ERR_PRESALE_HAS_NOT_STARTED");\n', '       require(now < endTime,"ERR_PRESALE_ENDED");\n', '       require(!isPaused,"ERR_PRESALE_IS_PAUSED");\n', '       require(_ethDeposited >= minDeposit && _ethDeposited <= maxDeposit,"ERR_AMOUNT_TOO_SMALL_OR_TOO_BIG");\n', '       require(totalInvestment.add(_ethDeposited) <= capAmount,"ERR_CAP_HIT_CANNOT_ACCEPT");\n', '       require(remit.balanceOf(address(this)) != 0,"ERR_TOKENS_SOLD_OUT");\n', '       \n', '       uint256 amount = _calculateTokens(_ethDeposited);\n', '     \n', '       if(!depositers.contains(_buyer)) depositers.add(_buyer);\n', '       claimableAmount[_buyer] = claimableAmount[_buyer].add(amount);\n', '     \n', '       totalInvestment = totalInvestment.add(_ethDeposited);\n', '        \n', '       emit TokenPurchase(address(this),_buyer,_ethDeposited,amount);\n', '    }\n', '    \n', '    /*\n', '     * @dev To claim the tokens\n', '     *\n', '     */\n', '    function claim()external  {\n', '        \n', '       address _buyer = msg.sender;\n', '       \n', '       require(now > endTime,"ERR_CANNOT_CLAIM_BEFORE_PRESALE_ENDS");\n', '       require(depositers.contains(_buyer),"ERR_NOT_AUTHORIZED_TO_CLAIM");\n', '       require(claimableAmount[_buyer] != 0,"ERR_NO_AMOUNT_TO_CLAIM");\n', '       \n', '       uint256 amount = claimableAmount[_buyer];\n', '       \n', '       require(remit.transfer(_buyer,amount),"ERR_TRANSFER_FAILED");\n', '       \n', '       claimableAmount[_buyer] = 0;\n', '       depositers.remove(_buyer);\n', '       \n', '       emit TokenClaimed(_buyer,now,amount);\n', '    }\n', '    \n', '    //To get number of tokens relevant to eth deposited\n', '    function _calculateTokens(uint256 _ethDeposited)internal returns(uint256){\n', '        uint256 tokens = (_ethDeposited).mul(1e18).div(tokenPrice);\n', '        totalRemitPurchased = totalRemitPurchased.add(tokens);\n', '        return tokens;\n', '    }\n', '    \n', '     /*\n', '     * @dev To withdraw the eth deposited\n', '     *\n', '     */\n', '    function withdrawDepositedEth()external onlyOwner{\n', '        (bool success,) = walletAddress.call{value:totalInvestment}(new bytes(0));\n', '        require(success,"ERR_TRANSFER_FAILED");\n', '        \n', '        totalInvestment = 0;\n', '    }\n', '    \n', '     /*\n', '     * @dev To set minium deposit limit\n', '     * \n', '     * @param\n', "     *  '_minamount' - specifies minimum amount to be deposited\n", '     */\n', '    function setMinDeposit(uint256 _minamount)external onlyOwner{\n', '        minDeposit = _minamount;\n', '    }\n', '    \n', '     /*\n', '     * @dev To set maximum deposit limit\n', '     * \n', '     * @param\n', "     *  '_maxamount' - specifies maximum amount can be deposited\n", '     */\n', '    function setMaxDeposit(uint256 _maxamount)external onlyOwner{\n', '        maxDeposit = _maxamount;\n', '    }\n', '    \n', '     /*\n', '     * @dev To set token price\n', '     * \n', '     * @param\n', "     *  '_price' - specifies token price\n", '     */\n', '    function setPrice(uint _price)external onlyOwner{\n', '        tokenPrice = _price;\n', '    }\n', '    \n', '    /*\n', '     * @dev To set cap limit\n', '     * \n', '     * @param\n', "     *  '_limit' - specifies cap limit\n", '     */\n', '    function setCap(uint _limit)external onlyOwner{\n', '        capAmount = _limit;\n', '    }\n', '    \n', '     /*\n', '     * @dev To set wallet address where eth will be transferred\n', '     * \n', '     * @param\n', "     *  '_walletAddress' - specifies address of user\n", '     */\n', '    function setWalletAddress(address _walletAddress)external onlyOwner{\n', '        walletAddress = _walletAddress;\n', '    }\n', '    \n', '    /*\n', '     * @dev To pauseor unpause the pre sale\n', '     * \n', '     * @param\n', "     *  '_val' - specifies the boolean value\n", '     */\n', '    function isPausable(bool _val)external onlyOwner{\n', '        isPaused = _val;\n', '    }\n', '    \n', '    receive () payable external {\n', '      buyToken();\n', '    }\n', '    \n', '    fallback () payable external {\n', '       buyToken();\n', '    }\n', '   \n', '}']