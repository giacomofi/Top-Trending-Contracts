['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./EnumerableSet.sol";\n', 'import "./ERC20.sol";\n', '\n', 'interface IERAC {\n', '    /**\n', '     * @dev Query the TokenId(ERAC) list for the specified account.\n', '     *\n', '     */\n', '    function getTokenIds(address owner) external view returns (uint256[] memory);\n', '}\n', '\n', 'contract ERACBonus is Ownable {\n', '\n', '    address private _eracAddress;\n', '    mapping(uint256 => uint256) private _withdrawalAmount;\n', '    mapping(address => mapping(uint256 => uint256)) private _tokenWithdrawalAmount;\n', '    uint256 private balance;\n', '    mapping(address => uint256) private tokenWithdrawTotal;\n', '    using SafeMath for uint256;\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '    EnumerableSet.AddressSet private tokens;\n', '\n', '    constructor(address eracAddress) {\n', '        require(eracAddress != address(0), "ERACBonus: address is the zero address");\n', '        _eracAddress = eracAddress;\n', '    }\n', '\n', '    modifier validTokenId(uint256 tokenId) {\n', '        require(tokenId >= 1 && tokenId <= 10000, "ERACBonus: operator an invalid ERAC token id");\n', '        _;\n', '    }\n', '\n', '    function setNFTAddress(address addr) public onlyOwner {\n', '        require(addr != address(0), "ERACBonus: address is the zero address");\n', '        _eracAddress = addr;\n', '    }\n', '\n', '    function addToken(address tokenAddr) public onlyOwner {\n', '        require(tokenAddr != address(0));\n', '        tokens.add(tokenAddr);\n', '    }\n', '\n', '    function removeToken(address tokenAddr) public onlyOwner {\n', '        tokens.remove(tokenAddr);\n', '    }\n', '\n', '    fallback() payable external {}\n', '\n', '    receive() payable external {\n', '        require(msg.value > 0, "recharge must be >0");\n', '        balance = balance.add(msg.value);\n', '    }\n', '\n', '    function _getLevel(uint256 id) private pure validTokenId(id) returns (uint256) {\n', '        return id > 6000 ? 1 : (id > 4000 ? 2 : (id > 3000 ? 3 : (id > 2000 ? 4 : (id > 1000 ? 5 : (id > 300 ? 6 : (id > 100 ? 7 : (id > 10 ? 8 : 9)))))));\n', '    }\n', '\n', '    function getTotalFeeETH() public view returns (uint256){\n', '        return balance;\n', '    }\n', '\n', '    function getTotalFeeToken(address tokenAddr) public view returns (uint256){\n', '        require(tokenAddr != address(0));\n', '        require(tokens.contains(tokenAddr), "this token is not allow");\n', '        return ERC20(tokenAddr).balanceOf(address(this)).add(tokenWithdrawTotal[tokenAddr]);\n', '    }\n', '\n', '    function balanceOfERAC(uint256 tokenId) public validTokenId(tokenId) view returns (uint256) {\n', '        uint16[10] memory levelBonusNum = [0, 15, 30, 60, 80, 100, 171, 800, 1778, 20000];\n', '        return balance * levelBonusNum[_getLevel(tokenId)] / 1000000 - _withdrawalAmount[tokenId];\n', '    }\n', '\n', '    function balanceOfERACToken(address tokenAddr, uint256 tokenId) public validTokenId(tokenId) view returns (uint256) {\n', '        uint16[10] memory levelBonusNum = [0, 15, 30, 60, 80, 100, 171, 800, 1778, 20000];\n', '        return getTotalFeeToken(tokenAddr) * levelBonusNum[_getLevel(tokenId)] / 1000000 - _tokenWithdrawalAmount[tokenAddr][tokenId];\n', '    }\n', '\n', '    function getBalanceOfAccountETH(address owner) public view returns (uint256) {\n', '        uint256[] memory tokenIds = IERAC(_eracAddress).getTokenIds(owner);\n', '        uint length = tokenIds.length;\n', '        if (length == 0) {\n', '            return 0;\n', '        }\n', '        uint256 totalAmount = 0;\n', '        for (uint i = 0; i < length; ++i) {\n', '            totalAmount = totalAmount.add(balanceOfERAC(tokenIds[i]));\n', '        }\n', '\n', '        return totalAmount;\n', '    }\n', '\n', '    function getTokenList() public view returns (address [] memory addrs){\n', '        uint length = tokens.length();\n', '        addrs = new address[](length);\n', '        for (uint i = 0; i < length; ++i) {\n', '            addrs[i] = tokens.at(i);\n', '        }\n', '        return addrs;\n', '    }\n', '\n', '    function containsToken(address tokenAddr) public view returns (bool){\n', '        return tokens.contains(tokenAddr);\n', '    }\n', '\n', '    function getBalanceOfAccountToken(address tokenAddr, address owner) public view returns (uint256) {\n', '        require(tokenAddr != address(0));\n', '        require(tokens.contains(tokenAddr), "this token is not allow");\n', '        uint256[] memory tokenIds = IERAC(_eracAddress).getTokenIds(owner);\n', '        uint length = tokenIds.length;\n', '        if (length == 0) {\n', '            return 0;\n', '        }\n', '        uint256 totalAmount = 0;\n', '        for (uint i = 0; i < length; ++i) {\n', '            totalAmount = totalAmount.add(balanceOfERACToken(tokenAddr, tokenIds[i]));\n', '        }\n', '\n', '        return totalAmount;\n', '    }\n', '\n', '\n', '    function withdrawETH() public returns (bool) {\n', '        uint256[] memory tokenIds = IERAC(_eracAddress).getTokenIds(msg.sender);\n', '        require(tokenIds.length > 0, "ERACBonus:you has no ERAC token");\n', '\n', '        uint256 withdrawBalance = 0;\n', '        for (uint i = 0; i < tokenIds.length; ++i) {\n', '            uint256 tokenId = tokenIds[i];\n', '            uint256 balanceOfThis = balanceOfERAC(tokenId);\n', '            if (balanceOfThis > 0) {\n', '                _withdrawalAmount[tokenId] = _withdrawalAmount[tokenId].add(balanceOfThis);\n', '                withdrawBalance = withdrawBalance.add(balanceOfThis);\n', '            }\n', '        }\n', '\n', '        require(withdrawBalance > 0, "ERACBonus: since last withdraw has no new Bonus produce");\n', '        payable(msg.sender).transfer(withdrawBalance);\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdrawToken(address tokenAddr) public returns (bool) {\n', '        require(tokenAddr != address(0));\n', '        require(tokens.contains(tokenAddr), "this token is not allow");\n', '        uint256[] memory tokenIds = IERAC(_eracAddress).getTokenIds(msg.sender);\n', '        require(tokenIds.length > 0, "ERACBonus:you has no ERAC token");\n', '\n', '        uint256 withdrawBalance = 0;\n', '        for (uint i = 0; i < tokenIds.length; ++i) {\n', '            uint256 tokenId = tokenIds[i];\n', '            uint256 balanceOfThis = balanceOfERACToken(tokenAddr, tokenId);\n', '            if (balanceOfThis > 0) {\n', '                _tokenWithdrawalAmount[tokenAddr][tokenId] = _tokenWithdrawalAmount[tokenAddr][tokenId].add(balanceOfThis);\n', '                withdrawBalance = withdrawBalance.add(balanceOfThis);\n', '            }\n', '        }\n', '\n', '        require(withdrawBalance > 0, "ERACBonus: since last withdraw has no new Bonus produce");\n', '        require(ERC20(tokenAddr).transfer(msg.sender, withdrawBalance), "recharge failed");\n', '        tokenWithdrawTotal[tokenAddr] = tokenWithdrawTotal[tokenAddr].add(withdrawBalance);\n', '        return true;\n', '    }\n', '\n', '}']