['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-14\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', ' /**\n', ' * @dev Returns the amount of tokens in existence.\n', ' */\n', ' function totalSupply() external view returns (uint256);\n', '\n', ' /**\n', ' * @dev Returns the amount of tokens owned by `account`.\n', ' */\n', ' function balanceOf(address account) external view returns (uint256);\n', '\n', ' /**\n', " * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", ' *\n', ' * Returns a boolean value indicating whether the operation succeeded.\n', ' *\n', ' * Emits a {Transfer} event.\n', ' */\n', ' function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', ' /**\n', ' * @dev Returns the remaining number of tokens that `spender` will be\n', ' * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', ' * zero by default.\n', ' *\n', ' * This value changes when {approve} or {transferFrom} are called.\n', ' */\n', ' function allowance(address owner, address spender) external view returns (uint256);\n', '\n', ' /**\n', " * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", ' *\n', ' * Returns a boolean value indicating whether the operation succeeded.\n', ' *\n', ' * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', ' * that someone may use both the old and the new allowance by unfortunate\n', ' * transaction ordering. One possible solution to mitigate this race\n', " * condition is to first reduce the spender's allowance to 0 and set the\n", ' * desired value afterwards:\n', ' * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', ' *\n', ' * Emits an {Approval} event.\n', ' */\n', ' function approve(address spender, uint256 amount) external returns (bool);\n', '\n', ' /**\n', ' * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', " * allowance mechanism. `amount` is then deducted from the caller's\n", ' * allowance.\n', ' *\n', ' * Returns a boolean value indicating whether the operation succeeded.\n', ' *\n', ' * Emits a {Transfer} event.\n', ' */\n', ' function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', ' /**\n', ' * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', ' * another (`to`).\n', ' *\n', ' * Note that `value` may be zero.\n', ' */\n', ' event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', ' /**\n', ' * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', ' * a call to {approve}. `value` is the new allowance.\n', ' */\n', ' event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Optional functions from the ERC20 standard.\n', ' */\n', 'contract ERC20Detailed is IERC20 {\n', ' string private _name;\n', ' string private _symbol;\n', ' uint8 private _decimals;\n', '\n', ' /**\n', ' * @dev Sets the values for `name`, `symbol`, and `decimals`. All three of\n', ' * these values are immutable: they can only be set once during\n', ' * construction.\n', ' */\n', ' constructor (string memory name, string memory symbol, uint8 decimals) public {\n', ' _name = name;\n', ' _symbol = symbol;\n', ' _decimals = decimals;\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the name of the token.\n', ' */\n', ' function name() public view returns (string memory) {\n', ' return _name;\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the symbol of the token, usually a shorter version of the\n', ' * name.\n', ' */\n', ' function symbol() public view returns (string memory) {\n', ' return _symbol;\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the number of decimals used to get its user representation.\n', ' * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', ' * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', ' *\n', ' * Tokens usually opt for a value of 18, imitating the relationship between\n', ' * Ether and Wei.\n', ' *\n', ' * NOTE: This information is only used for _display_ purposes: it in\n', ' * no way affects any of the arithmetic of the contract, including\n', ' * {IERC20-balanceOf} and {IERC20-transfer}.\n', ' */\n', ' function decimals() public view returns (uint8) {\n', ' return _decimals;\n', ' }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', ' // Empty internal constructor, to prevent people from mistakenly deploying\n', ' // an instance of this contract, which should be used via inheritance.\n', ' constructor () internal { }\n', ' // solhint-disable-previous-line no-empty-blocks\n', '\n', ' function _msgSender() internal view returns (address payable) {\n', ' return msg.sender;\n', ' }\n', '\n', ' function _msgData() internal view returns (bytes memory) {\n', ' this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', ' return msg.data;\n', ' }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', ' /**\n', ' * @dev Returns the addition of two unsigned integers, reverting on\n', ' * overflow.\n', ' *\n', " * Counterpart to Solidity's `+` operator.\n", ' *\n', ' * Requirements:\n', ' * - Addition cannot overflow.\n', ' */\n', ' function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', ' uint256 c = a + b;\n', ' require(c >= a, "SafeMath: addition overflow");\n', '\n', ' return c;\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the subtraction of two unsigned integers, reverting on\n', ' * overflow (when the result is negative).\n', ' *\n', " * Counterpart to Solidity's `-` operator.\n", ' *\n', ' * Requirements:\n', ' * - Subtraction cannot overflow.\n', ' */\n', ' function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', ' return sub(a, b, "SafeMath: subtraction overflow");\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', ' * overflow (when the result is negative).\n', ' *\n', " * Counterpart to Solidity's `-` operator.\n", ' *\n', ' * Requirements:\n', ' * - Subtraction cannot overflow.\n', ' *\n', ' * _Available since v2.4.0._\n', ' */\n', ' function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', ' require(b <= a, errorMessage);\n', ' uint256 c = a - b;\n', '\n', ' return c;\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the multiplication of two unsigned integers, reverting on\n', ' * overflow.\n', ' *\n', " * Counterpart to Solidity's `*` operator.\n", ' *\n', ' * Requirements:\n', ' * - Multiplication cannot overflow.\n', ' */\n', ' function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', " // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", " // benefit is lost if 'b' is also tested.\n", ' // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', ' if (a == 0) {\n', ' return 0;\n', ' }\n', '\n', ' uint256 c = a * b;\n', ' require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', ' return c;\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the integer division of two unsigned integers. Reverts on\n', ' * division by zero. The result is rounded towards zero.\n', ' *\n', " * Counterpart to Solidity's `/` operator. Note: this function uses a\n", ' * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', ' * uses an invalid opcode to revert (consuming all remaining gas).\n', ' *\n', ' * Requirements:\n', ' * - The divisor cannot be zero.\n', ' */\n', ' function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', ' return div(a, b, "SafeMath: division by zero");\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', ' * division by zero. The result is rounded towards zero.\n', ' *\n', " * Counterpart to Solidity's `/` operator. Note: this function uses a\n", ' * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', ' * uses an invalid opcode to revert (consuming all remaining gas).\n', ' *\n', ' * Requirements:\n', ' * - The divisor cannot be zero.\n', ' *\n', ' * _Available since v2.4.0._\n', ' */\n', ' function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', ' // Solidity only automatically asserts when dividing by 0\n', ' require(b > 0, errorMessage);\n', ' uint256 c = a / b;\n', " // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', ' return c;\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', ' * Reverts when dividing by zero.\n', ' *\n', " * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", ' * opcode (which leaves remaining gas untouched) while Solidity uses an\n', ' * invalid opcode to revert (consuming all remaining gas).\n', ' *\n', ' * Requirements:\n', ' * - The divisor cannot be zero.\n', ' */\n', ' function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', ' return mod(a, b, "SafeMath: modulo by zero");\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', ' * Reverts with custom message when dividing by zero.\n', ' *\n', " * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", ' * opcode (which leaves remaining gas untouched) while Solidity uses an\n', ' * invalid opcode to revert (consuming all remaining gas).\n', ' *\n', ' * Requirements:\n', ' * - The divisor cannot be zero.\n', ' *\n', ' * _Available since v2.4.0._\n', ' */\n', ' function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', ' require(b != 0, errorMessage);\n', ' return a % b;\n', ' }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20Mintable}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', ' using SafeMath for uint256;\n', '\n', ' mapping (address => uint256) private _balances;\n', '\n', ' mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', ' uint256 private _totalSupply;\n', '\n', ' /**\n', ' * @dev See {IERC20-totalSupply}.\n', ' */\n', ' function totalSupply() public view returns (uint256) {\n', ' return _totalSupply;\n', ' }\n', '\n', ' /**\n', ' * @dev See {IERC20-balanceOf}.\n', ' */\n', ' function balanceOf(address account) public view returns (uint256) {\n', ' return _balances[account];\n', ' }\n', '\n', ' /**\n', ' * @dev See {IERC20-transfer}.\n', ' *\n', ' * Requirements:\n', ' *\n', ' * - `recipient` cannot be the zero address.\n', ' * - the caller must have a balance of at least `amount`.\n', ' */\n', ' function transfer(address recipient, uint256 amount) public returns (bool) {\n', ' _transfer(_msgSender(), recipient, amount);\n', ' return true;\n', ' }\n', '\n', ' /**\n', ' * @dev See {IERC20-allowance}.\n', ' */\n', ' function allowance(address owner, address spender) public view returns (uint256) {\n', ' return _allowances[owner][spender];\n', ' }\n', '\n', ' /**\n', ' * @dev See {IERC20-approve}.\n', ' *\n', ' * Requirements:\n', ' *\n', ' * - `spender` cannot be the zero address.\n', ' */\n', ' function approve(address spender, uint256 amount) public returns (bool) {\n', ' _approve(_msgSender(), spender, amount);\n', ' return true;\n', ' }\n', '\n', ' /**\n', ' * @dev See {IERC20-transferFrom}.\n', ' *\n', ' * Emits an {Approval} event indicating the updated allowance. This is not\n', ' * required by the EIP. See the note at the beginning of {ERC20};\n', ' *\n', ' * Requirements:\n', ' * - `sender` and `recipient` cannot be the zero address.\n', ' * - `sender` must have a balance of at least `amount`.\n', " * - the caller must have allowance for `sender`'s tokens of at least\n", ' * `amount`.\n', ' */\n', ' function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', ' _transfer(sender, recipient, amount);\n', ' _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', ' return true;\n', ' }\n', '\n', ' /**\n', ' * @dev Atomically increases the allowance granted to `spender` by the caller.\n', ' *\n', ' * This is an alternative to {approve} that can be used as a mitigation for\n', ' * problems described in {IERC20-approve}.\n', ' *\n', ' * Emits an {Approval} event indicating the updated allowance.\n', ' *\n', ' * Requirements:\n', ' *\n', ' * - `spender` cannot be the zero address.\n', ' */\n', ' function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', ' _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', ' return true;\n', ' }\n', '\n', ' /**\n', ' * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', ' *\n', ' * This is an alternative to {approve} that can be used as a mitigation for\n', ' * problems described in {IERC20-approve}.\n', ' *\n', ' * Emits an {Approval} event indicating the updated allowance.\n', ' *\n', ' * Requirements:\n', ' *\n', ' * - `spender` cannot be the zero address.\n', ' * - `spender` must have allowance for the caller of at least\n', ' * `subtractedValue`.\n', ' */\n', ' function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', ' _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', ' return true;\n', ' }\n', '\n', ' /**\n', ' * @dev Moves tokens `amount` from `sender` to `recipient`.\n', ' *\n', ' * This is internal function is equivalent to {transfer}, and can be used to\n', ' * e.g. implement automatic token fees, slashing mechanisms, etc.\n', ' *\n', ' * Emits a {Transfer} event.\n', ' *\n', ' * Requirements:\n', ' *\n', ' * - `sender` cannot be the zero address.\n', ' * - `recipient` cannot be the zero address.\n', ' * - `sender` must have a balance of at least `amount`.\n', ' */\n', ' function _transfer(address sender, address recipient, uint256 amount) internal {\n', ' require(sender != address(0), "ERC20: transfer from the zero address");\n', ' require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', ' _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', ' _balances[recipient] = _balances[recipient].add(amount);\n', ' emit Transfer(sender, recipient, amount);\n', ' }\n', '\n', ' /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', ' * the total supply.\n', ' *\n', ' * Emits a {Transfer} event with `from` set to the zero address.\n', ' *\n', ' * Requirements\n', ' *\n', ' * - `to` cannot be the zero address.\n', ' */\n', ' function _mint(address account, uint256 amount) internal {\n', ' require(account != address(0), "ERC20: mint to the zero address");\n', '\n', ' _totalSupply = _totalSupply.add(amount);\n', ' _balances[account] = _balances[account].add(amount);\n', ' emit Transfer(address(0), account, amount);\n', ' }\n', '\n', ' /**\n', ' * @dev Destroys `amount` tokens from `account`, reducing the\n', ' * total supply.\n', ' *\n', ' * Emits a {Transfer} event with `to` set to the zero address.\n', ' *\n', ' * Requirements\n', ' *\n', ' * - `account` cannot be the zero address.\n', ' * - `account` must have at least `amount` tokens.\n', ' */\n', ' function _burn(address account, uint256 amount) internal {\n', ' require(account != address(0), "ERC20: burn from the zero address");\n', '\n', ' _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', ' _totalSupply = _totalSupply.sub(amount);\n', ' emit Transfer(account, address(0), amount);\n', ' }\n', '\n', ' /**\n', ' * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', ' *\n', ' * This is internal function is equivalent to `approve`, and can be used to\n', ' * e.g. set automatic allowances for certain subsystems, etc.\n', ' *\n', ' * Emits an {Approval} event.\n', ' *\n', ' * Requirements:\n', ' *\n', ' * - `owner` cannot be the zero address.\n', ' * - `spender` cannot be the zero address.\n', ' */\n', ' function _approve(address owner, address spender, uint256 amount) internal {\n', ' require(owner != address(0), "ERC20: approve from the zero address");\n', ' require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', ' _allowances[owner][spender] = amount;\n', ' emit Approval(owner, spender, amount);\n', ' }\n', '\n', ' /**\n', ' * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n', " * from the caller's allowance.\n", ' *\n', ' * See {_burn} and {_approve}.\n', ' */\n', ' function _burnFrom(address account, uint256 amount) internal {\n', ' _burn(account, amount);\n', ' _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));\n', ' }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', ' address private _owner;\n', '\n', ' event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', ' /**\n', ' * @dev Initializes the contract setting the deployer as the initial owner.\n', ' */\n', ' constructor () internal {\n', ' address msgSender = _msgSender();\n', ' _owner = msgSender;\n', ' emit OwnershipTransferred(address(0), msgSender);\n', ' }\n', '\n', ' /**\n', ' * @dev Returns the address of the current owner.\n', ' */\n', ' function owner() public view returns (address) {\n', ' return _owner;\n', ' }\n', '\n', ' /**\n', ' * @dev Throws if called by any account other than the owner.\n', ' */\n', ' modifier onlyOwner() {\n', ' require(isOwner(), "Ownable: caller is not the owner");\n', ' _;\n', ' }\n', '\n', ' /**\n', ' * @dev Returns true if the caller is the current owner.\n', ' */\n', ' function isOwner() public view returns (bool) {\n', ' return _msgSender() == _owner;\n', ' }\n', '\n', ' /**\n', ' * @dev Leaves the contract without owner. It will not be possible to call\n', ' * `onlyOwner` functions anymore. Can only be called by the current owner.\n', ' *\n', ' * NOTE: Renouncing ownership will leave the contract without an owner,\n', ' * thereby removing any functionality that is only available to the owner.\n', ' */\n', ' function renounceOwnership() public onlyOwner {\n', ' emit OwnershipTransferred(_owner, address(0));\n', ' _owner = address(0);\n', ' }\n', '\n', ' /**\n', ' * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', ' * Can only be called by the current owner.\n', ' */\n', ' function transferOwnership(address newOwner) public onlyOwner {\n', ' _transferOwnership(newOwner);\n', ' }\n', '\n', ' /**\n', ' * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', ' */\n', ' function _transferOwnership(address newOwner) internal {\n', ' require(newOwner != address(0), "Ownable: new owner is the zero address");\n', ' emit OwnershipTransferred(_owner, newOwner);\n', ' _owner = newOwner;\n', ' }\n', '}\n', '\n', '\n', 'contract KiiAToken is ERC20, ERC20Detailed, Ownable {\n', '\n', ' //Token percentages\n', ' uint256 private tokenSaleRatio = 50;\n', ' uint256 private foundersRatio = 10;\n', ' uint256 private marketingRatio = 40;\n', ' uint256 private foundersplit = 20; \n', '\n', ' //Constructor\n', ' constructor(\n', ' string memory _name, \n', ' string memory _symbol, \n', ' uint8 _decimals,\n', ' address _founder1,\n', ' address _founder2,\n', ' address _founder3,\n', ' address _founder4,\n', ' address _founder5,\n', ' address _marketing,\n', ' address _publicsale,\n', ' uint256 _initialSupply\n', ' )\n', ' ERC20Detailed(_name, _symbol, _decimals)\n', ' public\n', ' {\n', ' uint256 tempInitialSupply = _initialSupply * (10 ** uint256(_decimals));\n', '\n', ' uint256 publicSupply = tempInitialSupply.mul(tokenSaleRatio).div(100);\n', ' uint256 marketingSupply = tempInitialSupply.mul(marketingRatio).div(100);\n', ' uint256 tempfounderSupply = tempInitialSupply.mul(foundersRatio).div(100);\n', ' uint256 founderSupply = tempfounderSupply.mul(foundersplit).div(100);\n', '\n', ' _mint(_publicsale, publicSupply);\n', ' _mint(_marketing, marketingSupply);\n', ' _mint(_founder1, founderSupply);\n', ' _mint(_founder2, founderSupply);\n', ' _mint(_founder3, founderSupply);\n', ' _mint(_founder4, founderSupply);\n', ' _mint(_founder5, founderSupply);\n', '\n', ' }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', "// BokkyPooBah's DateTime Library v1.00\n", '//\n', '// A gas-efficient Solidity date and time library\n', '//\n', '// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n', '//\n', '// Tested date range 1970/01/01 to 2345/12/31\n', '//\n', '// Conventions:\n', '// Unit | Range | Notes\n', '// :-------- |:-------------:|:-----\n', '// timestamp | >= 0 | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n', '// year | 1970 ... 2345 |\n', '// month | 1 ... 12 |\n', '// day | 1 ... 31 |\n', '// hour | 0 ... 23 |\n', '// minute | 0 ... 59 |\n', '// second | 0 ... 59 |\n', '// dayOfWeek | 1 ... 7 | 1 = Monday, ..., 7 = Sunday\n', '//\n', '//\n', '// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\n', '//\n', '// GNU Lesser General Public License 3.0\n', '// https://www.gnu.org/licenses/lgpl-3.0.en.html\n', '// ----------------------------------------------------------------------------\n', '\n', 'library BokkyPooBahsDateTimeLibrary {\n', '\n', ' uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n', ' uint constant SECONDS_PER_HOUR = 60 * 60;\n', ' uint constant SECONDS_PER_MINUTE = 60;\n', ' int constant OFFSET19700101 = 2440588;\n', '\n', ' uint constant DOW_MON = 1;\n', ' uint constant DOW_TUE = 2;\n', ' uint constant DOW_WED = 3;\n', ' uint constant DOW_THU = 4;\n', ' uint constant DOW_FRI = 5;\n', ' uint constant DOW_SAT = 6;\n', ' uint constant DOW_SUN = 7;\n', '\n', ' // ------------------------------------------------------------------------\n', ' // Calculate the number of days from 1970/01/01 to year/month/day using\n', ' // the date conversion algorithm from\n', ' // http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n', ' // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n', ' //\n', ' // days = day\n', ' // - 32075\n', ' // + 1461 * (year + 4800 + (month - 14) / 12) / 4\n', ' // + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n', ' // - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n', ' // - offset\n', ' // ------------------------------------------------------------------------\n', ' function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n', ' require(year >= 1970);\n', ' int _year = int(year);\n', ' int _month = int(month);\n', ' int _day = int(day);\n', '\n', ' int __days = _day\n', ' - 32075\n', ' + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n', ' + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n', ' - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n', ' - OFFSET19700101;\n', '\n', ' _days = uint(__days);\n', ' }\n', '\n', ' // ------------------------------------------------------------------------\n', ' // Calculate year/month/day from the number of days since 1970/01/01 using\n', ' // the date conversion algorithm from\n', ' // http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n', ' // and adding the offset 2440588 so that 1970/01/01 is day 0\n', ' //\n', ' // int L = days + 68569 + offset\n', ' // int N = 4 * L / 146097\n', ' // L = L - (146097 * N + 3) / 4\n', ' // year = 4000 * (L + 1) / 1461001\n', ' // L = L - 1461 * year / 4 + 31\n', ' // month = 80 * L / 2447\n', ' // dd = L - 2447 * month / 80\n', ' // L = month / 11\n', ' // month = month + 2 - 12 * L\n', ' // year = 100 * (N - 49) + year + L\n', ' // ------------------------------------------------------------------------\n', ' function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n', ' int __days = int(_days);\n', '\n', ' int L = __days + 68569 + OFFSET19700101;\n', ' int N = 4 * L / 146097;\n', ' L = L - (146097 * N + 3) / 4;\n', ' int _year = 4000 * (L + 1) / 1461001;\n', ' L = L - 1461 * _year / 4 + 31;\n', ' int _month = 80 * L / 2447;\n', ' int _day = L - 2447 * _month / 80;\n', ' L = _month / 11;\n', ' _month = _month + 2 - 12 * L;\n', ' _year = 100 * (N - 49) + _year + L;\n', '\n', ' year = uint(_year);\n', ' month = uint(_month);\n', ' day = uint(_day);\n', ' }\n', '\n', ' function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n', ' timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n', ' }\n', ' function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n', ' timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n', ' }\n', ' function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' }\n', ' function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' uint secs = timestamp % SECONDS_PER_DAY;\n', ' hour = secs / SECONDS_PER_HOUR;\n', ' secs = secs % SECONDS_PER_HOUR;\n', ' minute = secs / SECONDS_PER_MINUTE;\n', ' second = secs % SECONDS_PER_MINUTE;\n', ' }\n', '\n', ' function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n', ' if (year >= 1970 && month > 0 && month <= 12) {\n', ' uint daysInMonth = _getDaysInMonth(year, month);\n', ' if (day > 0 && day <= daysInMonth) {\n', ' valid = true;\n', ' }\n', ' }\n', ' }\n', ' function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n', ' if (isValidDate(year, month, day)) {\n', ' if (hour < 24 && minute < 60 && second < 60) {\n', ' valid = true;\n', ' }\n', ' }\n', ' }\n', ' function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n', ' uint year;\n', ' uint month;\n', ' uint day;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' leapYear = _isLeapYear(year);\n', ' }\n', ' function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n', ' leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n', ' }\n', ' function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n', ' weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n', ' }\n', ' function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n', ' weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n', ' }\n', ' function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n', ' uint year;\n', ' uint month;\n', ' uint day;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' daysInMonth = _getDaysInMonth(year, month);\n', ' }\n', ' function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n', ' if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', ' daysInMonth = 31;\n', ' } else if (month != 2) {\n', ' daysInMonth = 30;\n', ' } else {\n', ' daysInMonth = _isLeapYear(year) ? 29 : 28;\n', ' }\n', ' }\n', ' // 1 = Monday, 7 = Sunday\n', ' function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n', ' uint _days = timestamp / SECONDS_PER_DAY;\n', ' dayOfWeek = (_days + 3) % 7 + 1;\n', ' }\n', '\n', ' function getYear(uint timestamp) internal pure returns (uint year) {\n', ' uint month;\n', ' uint day;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' }\n', ' function getMonth(uint timestamp) internal pure returns (uint month) {\n', ' uint year;\n', ' uint day;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' }\n', ' function getDay(uint timestamp) internal pure returns (uint day) {\n', ' uint year;\n', ' uint month;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' }\n', ' function getHour(uint timestamp) internal pure returns (uint hour) {\n', ' uint secs = timestamp % SECONDS_PER_DAY;\n', ' hour = secs / SECONDS_PER_HOUR;\n', ' }\n', ' function getMinute(uint timestamp) internal pure returns (uint minute) {\n', ' uint secs = timestamp % SECONDS_PER_HOUR;\n', ' minute = secs / SECONDS_PER_MINUTE;\n', ' }\n', ' function getSecond(uint timestamp) internal pure returns (uint second) {\n', ' second = timestamp % SECONDS_PER_MINUTE;\n', ' }\n', '\n', ' function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n', ' uint year;\n', ' uint month;\n', ' uint day;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' year += _years;\n', ' uint daysInMonth = _getDaysInMonth(year, month);\n', ' if (day > daysInMonth) {\n', ' day = daysInMonth;\n', ' }\n', ' newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', ' require(newTimestamp >= timestamp);\n', ' }\n', ' function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n', ' uint year;\n', ' uint month;\n', ' uint day;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' month += _months;\n', ' year += (month - 1) / 12;\n', ' month = (month - 1) % 12 + 1;\n', ' uint daysInMonth = _getDaysInMonth(year, month);\n', ' if (day > daysInMonth) {\n', ' day = daysInMonth;\n', ' }\n', ' newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', ' require(newTimestamp >= timestamp);\n', ' }\n', ' function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n', ' newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n', ' require(newTimestamp >= timestamp);\n', ' }\n', ' function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n', ' newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n', ' require(newTimestamp >= timestamp);\n', ' }\n', ' function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n', ' newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n', ' require(newTimestamp >= timestamp);\n', ' }\n', ' function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n', ' newTimestamp = timestamp + _seconds;\n', ' require(newTimestamp >= timestamp);\n', ' }\n', '\n', ' function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n', ' uint year;\n', ' uint month;\n', ' uint day;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' year -= _years;\n', ' uint daysInMonth = _getDaysInMonth(year, month);\n', ' if (day > daysInMonth) {\n', ' day = daysInMonth;\n', ' }\n', ' newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', ' require(newTimestamp <= timestamp);\n', ' }\n', ' function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n', ' uint year;\n', ' uint month;\n', ' uint day;\n', ' (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', ' uint yearMonth = year * 12 + (month - 1) - _months;\n', ' year = yearMonth / 12;\n', ' month = yearMonth % 12 + 1;\n', ' uint daysInMonth = _getDaysInMonth(year, month);\n', ' if (day > daysInMonth) {\n', ' day = daysInMonth;\n', ' }\n', ' newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', ' require(newTimestamp <= timestamp);\n', ' }\n', ' function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n', ' newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n', ' require(newTimestamp <= timestamp);\n', ' }\n', ' function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n', ' newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n', ' require(newTimestamp <= timestamp);\n', ' }\n', ' function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n', ' newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n', ' require(newTimestamp <= timestamp);\n', ' }\n', ' function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n', ' newTimestamp = timestamp - _seconds;\n', ' require(newTimestamp <= timestamp);\n', ' }\n', '\n', ' function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n', ' require(fromTimestamp <= toTimestamp);\n', ' uint fromYear;\n', ' uint fromMonth;\n', ' uint fromDay;\n', ' uint toYear;\n', ' uint toMonth;\n', ' uint toDay;\n', ' (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n', ' (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n', ' _years = toYear - fromYear;\n', ' }\n', ' function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n', ' require(fromTimestamp <= toTimestamp);\n', ' uint fromYear;\n', ' uint fromMonth;\n', ' uint fromDay;\n', ' uint toYear;\n', ' uint toMonth;\n', ' uint toDay;\n', ' (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n', ' (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n', ' _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n', ' }\n', ' function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n', ' require(fromTimestamp <= toTimestamp);\n', ' _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n', ' }\n', ' function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n', ' require(fromTimestamp <= toTimestamp);\n', ' _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n', ' }\n', ' function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n', ' require(fromTimestamp <= toTimestamp);\n', ' _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n', ' }\n', ' function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n', ' require(fromTimestamp <= toTimestamp);\n', ' _seconds = toTimestamp - fromTimestamp;\n', ' }\n', '}\n', '\n', '\n', 'contract KiiADefi{\n', '\n', ' string public name = "KiiA Token Farm";\n', ' address public onlyOwner;\n', ' KiiAToken public kiiaToken;\n', ' using SafeMath for uint256;\n', '\n', ' using BokkyPooBahsDateTimeLibrary for uint;\n', ' \n', ' function _diffDays(uint fromTimestamp, uint toTimestamp) public pure returns (uint _days) {\n', ' _days = BokkyPooBahsDateTimeLibrary.diffDays(fromTimestamp, toTimestamp);\n', ' }\n', '\n', ' function _getTotalDays(uint _months) public view returns(uint){\n', ' uint fromday = now;\n', ' uint today = fromday.addMonths(_months);\n', ' uint pendindays = _diffDays(fromday,today);\n', ' return (pendindays);\n', ' }\n', '\n', ' //Deposit structure to hold all the variables\n', ' struct Deposits {\n', ' uint deposit_id;\n', ' address investorAddress;\n', ' uint planid;\n', ' uint plantype;\n', ' uint month;\n', ' uint interest;\n', ' uint256 invested;\n', ' uint256 totalBonusToReceive;\n', ' uint256 principalPmt;\n', ' uint256 dailyEarnings;\n', ' uint nthDay;\n', ' uint daysToClose;\n', ' bool isUnlocked;\n', ' bool withdrawn;\n', ' }\n', ' \n', ' //PlanDetails structure\n', ' struct PlanDetails {\n', ' uint planid;\n', ' uint month;\n', ' uint interest;\n', ' uint plantype;\n', ' bool isActive;\n', ' }\n', ' \n', ' //Events to capture deposit event\n', ' event addDepositEvent(\n', ' uint depositId,\n', ' address investorAddress\n', ' );\n', ' \n', ' //Events to capture add plan\n', ' event addPlanEvent(\n', ' uint index,\n', ' uint planid\n', ' );\n', ' \n', ' //Events to capture update/edit plan\n', ' event updateorEditPlanEvent(\n', ' uint planid\n', ' );\n', ' \n', ' event dummyEvent(\n', ' address text1, \n', ' bytes32 text2\n', ' );\n', ' \n', ' event dummyEventint(\n', ' uint text1, \n', ' bool text2,\n', ' uint text3\n', ' );\n', ' \n', ' //Events to capture whitelist event\n', ' event whiteListEvent(\n', ' address owner,\n', ' address investor\n', ' );\n', ' \n', ' //Event to capture calculate bonus\n', ' event calculateBonusEvent(\n', ' uint depositid,\n', ' address investorAddress\n', ' );\n', ' \n', ' //Events to capture unlock event\n', ' event addUnlockEvent(\n', ' uint indexed _id,\n', ' address _investorAddress,\n', ' uint _planid\n', ' ); \n', ' \n', ' //Events to capture lock event\n', ' event addlockEvent(\n', ' uint indexed _id,\n', ' address _investorAddress,\n', ' uint _planid\n', ' ); \n', ' \n', ' //Events to capture Withdraw event \n', ' event addWithdrawEvent(\n', ' uint indexed _id,\n', ' address _investorAddress,\n', ' uint _planid\n', ' ); \n', ' \n', ' uint public depositCounter;\n', ' uint public planCounter;\n', ' \n', ' Deposits[] public allDeposits;\n', ' PlanDetails[] public allPlanDetails;\n', ' \n', ' //to view deposit information\n', ' mapping(address=>Deposits[]) public depositDetails;\n', ' mapping(address=>mapping(uint=>Deposits[])) public viewDeposit;\n', '\n', ' mapping(address => bool) public whitelistAddresses;\n', ' address[] public whiteListed;\n', ' address[] public stakers;\n', ' mapping(address => bool) public hasStaked;\n', ' \n', ' //address -> plan -> staking or not\n', ' mapping(address => mapping(uint => bool)) public isStaking;\n', ' \n', ' //plan active state\n', ' mapping(uint =>bool) public isPlanActive;\n', '\n', ' constructor(KiiAToken _kiiaToken, address _owneraddr) public payable {\n', ' kiiaToken = _kiiaToken;\n', ' onlyOwner = _owneraddr;\n', ' }\n', ' \n', ' function addEth() public payable {\n', ' //function to accept ether \n', ' }\n', ' \n', ' //Function to whitelist address\n', ' function whiteListIt(address _beneficiary) public returns(uint) {\n', ' // Only owner can call this function\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' require(whitelistAddresses[_beneficiary]==false, "Already whitelisted");\n', ' whitelistAddresses[_beneficiary] = true;\n', ' whiteListed.push(_beneficiary);\n', ' emit whiteListEvent(msg.sender,_beneficiary);\n', ' return 0;\n', ' }\n', ' \n', ' //Function to whitelist address in bulk fashion\n', ' function bulkwhiteListIt(address[] memory _beneficiary) public returns(uint) {\n', ' // Only owner can call this function\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' uint tot = _beneficiary.length;\n', ' if(tot<=255){\n', ' for(uint i=0;i<tot; i++){\n', ' if(!whitelistAddresses[_beneficiary[i]]){\n', ' whitelistAddresses[_beneficiary[i]] = true;\n', ' whiteListed.push(_beneficiary[i]);\n', ' emit whiteListEvent(msg.sender,_beneficiary[i]);\n', ' }\n', ' }\n', ' return 0; \n', ' }\n', ' }\n', ' \n', ' //Function to bulk remove from bulkremoveFromwhiteListIt\n', ' function bulkremoveFromwhiteListIt(address[] memory _beneficiary) public returns(uint) {\n', ' // Only owner can call this function\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' uint tot = _beneficiary.length;\n', ' if(tot<=255){\n', ' for(uint i=0;i<tot; i++){\n', ' if(!whitelistAddresses[_beneficiary[i]]){\n', ' whitelistAddresses[_beneficiary[i]] = false;\n', ' whiteListed.push(_beneficiary[i]);\n', ' emit whiteListEvent(msg.sender,_beneficiary[i]);\n', ' }\n', ' }\n', ' return 0; \n', ' }\n', ' }\n', ' \n', ' //remove from whiteList\n', ' function removefromWhiteList(address _beneficiary) public returns(uint) {\n', ' // Only owner can call this function\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' require(whitelistAddresses[_beneficiary]==true, "Already in graylist");\n', ' whitelistAddresses[_beneficiary] = false;\n', ' emit whiteListEvent(msg.sender,_beneficiary);\n', ' return 0;\n', ' }\n', ' \n', ' //Getter Function for getplan by id\n', ' function getPlanById(uint _planid) public view returns(uint plan_id,uint month,uint interest,uint plantype,bool isActive){\n', ' uint tot = allPlanDetails.length;\n', ' for(uint i=0;i<tot;i++){\n', ' if(allPlanDetails[i].planid==_planid){\n', ' return(allPlanDetails[i].planid,allPlanDetails[i].month,allPlanDetails[i].interest,allPlanDetails[i].plantype,allPlanDetails[i].isActive);\n', ' }\n', ' }\n', ' }\n', ' \n', ' //Getter Function for getplan by id\n', ' function getPlanDetails(uint _planid) internal view returns(uint month,uint interest,uint plantype){\n', ' uint tot = allPlanDetails.length;\n', ' for(uint i=0;i<tot;i++){\n', ' if(allPlanDetails[i].planid==_planid){\n', ' return(allPlanDetails[i].month,allPlanDetails[i].interest,allPlanDetails[i].plantype);\n', ' }\n', ' }\n', '\n', ' }\n', ' \n', ' //this function is to avoid stack too deep error\n', ' function _deposits(uint _month, uint _amount, uint256 _interest) internal view returns (uint _nthdayv2,uint _pendingDaysv2,uint256 _totalBonusToReceivev2,uint256 _dailyEarningsv2,uint _principalPmtDailyv2) {\n', ' uint256 _pendingDaysv1 = _getTotalDays(_month);\n', ' uint256 _interesttoDivide = _interest.mul(1000000).div(100) ;\n', ' uint256 _totalBonusToReceivev1 = _amount.mul(_interesttoDivide).div(1000000);\n', ' uint _nthdayv1 = 0;\n', ' uint _principalPmtDaily = 0;\n', ' uint _dailyEarningsv1 = 0;\n', ' return (_nthdayv1,_pendingDaysv1,_totalBonusToReceivev1,_dailyEarningsv1,_principalPmtDaily);\n', ' } \n', ' \n', ' function depositTokens(uint _plan,uint256 _plandate, uint _amount) public{\n', ' // check if user is whitelisted\n', ' require(whitelistAddresses[msg.sender]==true,"Only whitelisted user is allowed to deposit tokens");\n', ' require(_amount > 0, "amount cannot be 0");\n', ' require(isPlanActive[_plan]==true,"Plan is not active"); // To check if plan is active \n', ' \n', ' (uint _month,uint _interest,uint _plantype) = getPlanDetails(_plan);\n', ' \n', ' require(_interest > 0, "interest rate cannot be 0");\n', ' require(_month > 0,"_months cannot be 0");\n', ' \n', ' // Trasnfer kiiA tokens to this contract for staking\n', ' kiiaToken.transferFrom(msg.sender, address(this), _amount);\n', ' \n', ' //scope to remove the error Stack too deep\n', ' (uint _nthday,uint _daystoclose,uint _totalBonusToReceive,uint _dailyEarnings,uint _principalPmtDaily) = _deposits(_month,_amount,_interest);\n', ' \n', ' uint _localid = allDeposits.length++;\n', ' //deposit token in defi\n', ' allDeposits[allDeposits.length-1] = Deposits(_plandate, \n', ' msg.sender,\n', ' _plan,\n', ' _plantype,\n', ' _month,\n', ' _interest,\n', ' _amount,\n', ' _totalBonusToReceive,\n', ' _principalPmtDaily,\n', ' _dailyEarnings,\n', ' _nthday,\n', ' _daystoclose,\n', ' false,\n', ' false\n', ' );\n', ' \n', ' //Add Deposit details\n', ' depositDetails[msg.sender].push(allDeposits[allDeposits.length-1]);\n', ' \n', ' //is Staking in this plan \n', ' isStaking[msg.sender][_plandate] = true;\n', '\n', " // Add user to stakers array *only* if they haven't staked already\n", ' if(!hasStaked[msg.sender]) {\n', ' stakers.push(msg.sender);\n', ' } \n', ' hasStaked[msg.sender] = true;\n', ' \n', ' emit addDepositEvent(_localid, msg.sender);\n', ' \n', ' }\n', ' \n', ' //Setter function for plan\n', ' function registerPlan(uint _planid, uint _month,uint _interest,uint _plantype) public returns(uint){\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' require(_planid > 0, "Plan Id cannot be 0");\n', ' require(_month > 0, "Month cannot be 0");\n', ' require(_interest > 0, "Interest cannot be 0");\n', ' require(_plantype >= 0, "Plantype can be either 0 or 1");\n', ' require(_plantype <= 1, "Plantype can be either 0 or 1");\n', ' require(isPlanActive[_planid]==false,"Plan already exists in active status"); \n', '\n', ' planCounter = planCounter + 1;\n', ' uint _localid = allPlanDetails.length++;\n', ' allPlanDetails[allPlanDetails.length-1] = PlanDetails(_planid,\n', ' _month,\n', ' _interest,\n', ' _plantype,\n', ' true\n', ' ); \n', ' isPlanActive[_planid] = true;\n', ' emit addPlanEvent(_localid,_planid);\n', ' return 0;\n', ' }\n', ' \n', ' //Setter function for plan\n', ' function updatePlan(uint _planid, uint _month,uint _interest,uint _plantype) public returns(uint){\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' require(_planid > 0, "Plan Id cannot be 0");\n', ' require(_month > 0, "Month cannot be 0");\n', ' require(_interest > 0, "Interest cannot be 0");\n', '\n', ' uint tot = allPlanDetails.length;\n', ' for(uint i=0;i<tot;i++){\n', ' if(allPlanDetails[i].planid==_planid){\n', ' allPlanDetails[i].month = _month;\n', ' allPlanDetails[i].interest = _interest;\n', ' allPlanDetails[i].plantype = _plantype;\n', ' }\n', ' }\n', ' emit updateorEditPlanEvent(_planid);\n', ' return 0;\n', ' }\n', ' \n', ' //Deactivate plan\n', ' function deactivatePlan(uint _planid) public returns(uint){\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' require(isPlanActive[_planid]==true, "Plan already deactivated");\n', ' isPlanActive[_planid]= false;\n', ' emit updateorEditPlanEvent(_planid);\n', ' return 0;\n', ' }\n', ' \n', ' //Reactivate plan\n', ' function reactivatePlan(uint _planid) public returns(uint){\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' require(isPlanActive[_planid]==false, "Plan already activated");\n', ' isPlanActive[_planid]= true;\n', ' emit updateorEditPlanEvent(_planid);\n', ' return 0;\n', ' }\n', ' \n', ' //To calculate bonus - this function should be called once per day by owner\n', ' function calcBonus() public returns(uint){\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' uint totDep = allDeposits.length;\n', ' for(uint i=0; i<totDep;i++){\n', ' uint _plantype = allDeposits[i].plantype;\n', ' uint _nthDay = allDeposits[i].nthDay;\n', ' uint _invested = allDeposits[i].invested;\n', ' uint _daysToClose= allDeposits[i].daysToClose;\n', ' uint _principalPmt = _invested.div(_daysToClose);\n', '\n', ' //check if already withdrawn, if yes, then dont calculate\n', ' bool _withdrawn = allDeposits[i].withdrawn;\n', ' emit dummyEventint(_plantype,_withdrawn,0);\n', ' if(_plantype==0){\n', ' if(_nthDay<_daysToClose){\n', ' allDeposits[i].nthDay = _nthDay.add(1);\n', ' allDeposits[i].principalPmt = allDeposits[i].principalPmt + _principalPmt;\n', ' //emit event\n', ' emit calculateBonusEvent(allDeposits[i].deposit_id,allDeposits[i].investorAddress);\n', ' } \n', ' }\n', ' if(_plantype==1){\n', ' if(_nthDay<_daysToClose){\n', ' allDeposits[i].nthDay = _nthDay.add(1);\n', ' allDeposits[i].principalPmt = allDeposits[i].principalPmt + _principalPmt;\n', ' //emit event\n', ' emit calculateBonusEvent(allDeposits[i].deposit_id,allDeposits[i].investorAddress);\n', ' }\n', ' }\n', ' }\n', '\n', ' }\n', ' \n', ' //Get deposit by address\n', ' uint[] depNewArray;\n', ' function getDepositidByAddress(address _beneficiary) public returns(uint[] memory){\n', ' uint tot = allDeposits.length;\n', ' uint[] memory tmparray;\n', ' depNewArray = tmparray;\n', ' for(uint i =0; i< tot; i++){\n', ' if(allDeposits[i].investorAddress==_beneficiary){\n', ' depNewArray.push(allDeposits[i].deposit_id);\n', ' }\n', ' }\n', ' return depNewArray;\n', ' }\n', ' \n', ' \n', ' function getDepositByAddress(address _beneficiary,uint _deposit_id) public view returns(uint256,uint,uint,uint,uint,uint256,uint256,uint,uint,uint,bool){\n', ' uint tot = allDeposits.length;\n', ' for(uint i=0;i<tot;i++){\n', ' if(_beneficiary==allDeposits[i].investorAddress){\n', ' if(allDeposits[i].deposit_id==_deposit_id){\n', ' return(allDeposits[i].invested,\n', ' allDeposits[i].planid,\n', ' allDeposits[i].plantype,\n', ' allDeposits[i].month,\n', ' allDeposits[i].interest,\n', ' allDeposits[i].totalBonusToReceive,\n', ' allDeposits[i].dailyEarnings,\n', ' allDeposits[i].principalPmt,\n', ' allDeposits[i].daysToClose,\n', ' allDeposits[i].nthDay,\n', ' allDeposits[i].isUnlocked\n', ' );\n', ' }\n', ' }\n', ' }\n', ' }\n', ' \n', ' // Unlock address\n', ' function setLock(address _beneficiary,uint _deposit_id) public returns(uint) {\n', ' // Only owner can call this function\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' // set lock\n', ' uint totDep = allDeposits.length;\n', ' for(uint i=0;i<totDep; i++){\n', ' if(allDeposits[i].investorAddress==_beneficiary){\n', ' if (allDeposits[i].deposit_id==_deposit_id){\n', ' allDeposits[i].isUnlocked = false;\n', ' emit addlockEvent(allDeposits[i].deposit_id,allDeposits[i].investorAddress,allDeposits[i].planid);\n', ' }\n', ' }\n', ' }\n', ' return 0;\n', ' }\n', ' \n', ' // Unlock address\n', ' function unlock(address _beneficiary,uint _deposit_id) public returns(uint) {\n', ' // Only owner can call this function\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' // Unlock\n', ' uint totDep = allDeposits.length;\n', ' for(uint i=0;i<totDep; i++){\n', ' if(allDeposits[i].investorAddress==_beneficiary){\n', ' if (allDeposits[i].deposit_id==_deposit_id){\n', ' allDeposits[i].isUnlocked = true;\n', ' emit addUnlockEvent(allDeposits[i].deposit_id,allDeposits[i].investorAddress,allDeposits[i].planid);\n', ' }\n', ' }\n', ' }\n', ' return 0;\n', ' }\n', '\n', ' // Bulk Unlock address\n', ' function bulkunlock(address[] memory _beneficiary, uint256[] memory _deposit_id) public returns(uint) {\n', ' // Only owner can call this function\n', ' require(msg.sender == onlyOwner, "caller must be the owner");\n', ' require(_beneficiary.length == _deposit_id.length,"Array length must be equal");\n', ' // Unlock\n', ' uint totDep = allDeposits.length;\n', ' for (uint j = 0; j < _beneficiary.length; j++) {\n', ' for(uint i=0;i<totDep; i++){\n', ' if(allDeposits[i].investorAddress==_beneficiary[j]){\n', ' if (allDeposits[i].deposit_id==_deposit_id[j]){\n', ' allDeposits[i].isUnlocked = true;\n', ' }\n', ' }\n', ' }\n', ' }\n', ' return 0;\n', ' }\n', '\n', ' // Bring staker list Getter function\n', ' function stakerlist() public view returns(address[] memory){\n', ' return stakers;\n', ' }\n', ' \n', ' // Bring whitelisted addresss list \n', ' address[] whiteArray;\n', ' function whiteListedAddress() public returns(address[] memory){\n', ' uint tot = whiteListed.length;\n', ' address[] memory tmparray;\n', ' whiteArray = tmparray;\n', ' for(uint i=0;i<tot; i++){\n', ' whiteArray.push(whiteListed[i]);\n', ' emit dummyEvent(whiteListed[i],"testing");\n', ' }\n', ' return whiteArray;\n', ' }\n', ' \n', ' // Bring bloacklisted addresss list \n', ' address[] blackArray;\n', ' function blackListedAddress() public returns(address[] memory){\n', ' uint tot = whiteListed.length;\n', ' address[] memory tmparray;\n', ' blackArray = tmparray;\n', ' for(uint i=0;i<tot; i++){\n', ' if(whitelistAddresses[whiteListed[i]]==false){\n', ' blackArray.push(whiteListed[i]);\n', ' }\n', ' }\n', ' return blackArray;\n', ' }\n', ' \n', ' // Unstaking Tokens (Withdraw)\n', ' function withDrawTokens(uint _deposit_id, uint _plantype) public returns(uint) {\n', ' uint totDep = allDeposits.length;\n', ' for(uint i=0;i<totDep; i++){\n', ' if(allDeposits[i].investorAddress==msg.sender){\n', ' if (allDeposits[i].deposit_id==_deposit_id){\n', ' require(allDeposits[i].invested > 0, "Staking balance cannot be 0");\n', ' require(allDeposits[i].withdrawn==false, "Plan is already withdrawn by user");\n', ' require(allDeposits[i].isUnlocked==true, "User account must be unlocked by owner to withdraw");\n', ' require(isStaking[msg.sender][_deposit_id]==true,"User is not staking any amount in this plan");\n', ' uint balance = allDeposits[i].invested;\n', ' \n', ' //Regular Plan withdrawal\n', ' if(_plantype==0){\n', ' uint _principalPmt = allDeposits[i].principalPmt;\n', ' uint _toTransfer1 = balance.sub(_principalPmt);\n', ' // Transfer back KiiA tokens to this address\n', ' kiiaToken.transfer(msg.sender, _toTransfer1);\n', ' allDeposits[i].principalPmt = _principalPmt.add(_toTransfer1);\n', ' allDeposits[i].totalBonusToReceive = 0;\n', ' allDeposits[i].withdrawn = true;\n', ' isStaking[msg.sender][_deposit_id]=false;\n', ' emit addWithdrawEvent(allDeposits[i].deposit_id,allDeposits[i].investorAddress,allDeposits[i].planid);\n', ' return 0;\n', ' }\n', ' \n', ' //Fixed Plan withdrawal\n', ' if(_plantype==1){\n', ' uint nthDay = allDeposits[i].nthDay;\n', ' uint dailyEarnings = allDeposits[i].dailyEarnings;\n', ' uint256 _interestAccumulated = nthDay.mul(dailyEarnings);\n', ' uint256 _toTransfer2 = balance.add(_interestAccumulated);\n', ' // Transfer back KiiA tokens to this address\n', ' kiiaToken.transfer(msg.sender, _toTransfer2);\n', ' allDeposits[i].totalBonusToReceive = 0;\n', ' allDeposits[i].withdrawn = true;\n', ' isStaking[msg.sender][_deposit_id]=false;\n', ' emit addWithdrawEvent(allDeposits[i].deposit_id,allDeposits[i].investorAddress,allDeposits[i].planid);\n', ' return 0;\n', ' }\n', ' }\n', ' }\n', ' }\n', ' }\n', '}']