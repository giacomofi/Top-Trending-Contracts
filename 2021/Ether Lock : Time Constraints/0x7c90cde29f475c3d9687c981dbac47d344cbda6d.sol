['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.7.3;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./IERC20.sol";\n', 'import "./Context.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./IBOOST.sol";\n', 'import "./Ownable.sol";\n', '\n', 'contract LOOTStakingPool is ReentrancyGuard, Context, Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  constructor(address _loot, address _silver) {\n', '    LOOT = IERC20(_loot);\n', '    SILVER = IERC20(_silver);\n', '  }\n', '\n', '  IERC20 private LOOT;\n', '  IERC20 private SILVER;\n', '  IBOOST private BOOST;\n', '\n', '  function setBoostContract(address _address) public onlyOwner {\n', '    BOOST = IBOOST(_address);\n', '  }\n', '\n', '  address private feeAddress = 0x4Cf135b4f0236B0fC55DfA9a09B25843416cE023;\n', '\n', '  mapping(address => uint256) private stakedBalance;\n', '  mapping(address => uint256) public lastUpdateTime;\n', '  mapping(address => uint256) public reward;\n', '\n', '  event Staked(address indexed user, uint256 amount);\n', '  event Unstake(address indexed user, uint256 amount);\n', '  event Redeem(address indexed user, uint256 amount);\n', '\n', '  modifier updateReward(address account) {\n', '    if (account != address(0)) {\n', '      reward[account] = earned(account);\n', '      lastUpdateTime[account] = block.timestamp;\n', '    }\n', '    _;\n', '  }\n', '\n', '  function balanceOf(address account) public view returns (uint256) {\n', '    return stakedBalance[account];\n', '  }\n', '\n', '  function manualUpdate(address account) public nonReentrant {\n', '    if (account != address(0)) {\n', '      reward[account] = earned(account);\n', '      lastUpdateTime[account] = block.timestamp;\n', '    }\n', '  }\n', '\n', '  function earned(address account) public view returns (uint256) {\n', '    uint256 blockTime = block.timestamp;\n', '    uint256 earnedAmount = blockTime.sub(lastUpdateTime[account]).mul(balanceOf(account)).div(432000);\n', '    if (BOOST.hasBoost(account) == true) {\n', '      earnedAmount = earnedAmount.mul(11).div(10);\n', '    }\n', '    return reward[account].add(earnedAmount);\n', '  }\n', '\n', '  function stake(uint256 amount) public updateReward(_msgSender()) nonReentrant {\n', '    require(amount >= 100, "Too small stake");\n', '    uint256 fee = amount.div(100);\n', '    uint256 stakeAmount = amount.sub(fee);\n', '    stakedBalance[_msgSender()] = stakedBalance[_msgSender()].add(stakeAmount);\n', '    LOOT.transferFrom(_msgSender(), address(this), amount);\n', '    LOOT.transfer(feeAddress, fee);\n', '    emit Staked(_msgSender(), stakeAmount);\n', '  }\n', '\n', '  function withdraw(uint256 amount) public updateReward(_msgSender()) nonReentrant {\n', '    require(amount > 0, "Cannot withdraw 0");\n', '    require(amount <= balanceOf(_msgSender()), "Cannot withdraw more than balance");\n', '    uint256 fee = amount.div(50);\n', '    uint256 stakeAmount = amount.sub(fee);\n', '    LOOT.transfer(_msgSender(), stakeAmount);\n', '    LOOT.transfer(feeAddress, fee);\n', '    stakedBalance[_msgSender()] = stakedBalance[_msgSender()].sub(amount);\n', '    emit Unstake(_msgSender(), stakeAmount);\n', '  }\n', '\n', '  function exit() external {\n', '    withdraw(balanceOf(_msgSender()));\n', '  }\n', '    \n', '  function redeem() public updateReward(_msgSender()) nonReentrant {\n', '    require(reward[_msgSender()] > 0, "Nothing to redeem");\n', '    uint256 amount = reward[_msgSender()];\n', '    reward[_msgSender()] = 0;\n', '    SILVER.mint(_msgSender(), amount);\n', '    emit Redeem(_msgSender(), amount);\n', '  }\n', '}']