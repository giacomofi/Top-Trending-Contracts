['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-14\n', '*/\n', '\n', '/*\n', '    safeMath.sol v1.0.1\n', '    Safe mathematical operations\n', '    \n', '    This file is part of Screenist [NIS] token project.\n', '    \n', "    Author: Andor 'iFA' Rajci, Fusion Solutions KFT @ [email\xa0protected]\n", '*/\n', 'pragma solidity 0.4.26;\n', '\n', 'library SafeMath {\n', '    /* Internals */\n', '    function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a + b;\n', '        assert( c >= a );\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a - b;\n', '        assert( c <= a );\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a * b;\n', '        assert( c == 0 || c / a == b );\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns(uint256) {\n', '        return a / b;\n', '    }\n', '    function pow(uint256 a, uint256 b) internal pure returns(uint256 c) {\n', '        c = a ** b;\n', '        assert( c % a == 0 );\n', '        return a ** b;\n', '    }\n', '}\n', '\n', '/*\n', '    owner.sol v1.0.0\n', '    Owner\n', '    \n', '    This file is part of Screenist [NIS] token project.\n', '    \n', "    Author: Andor 'iFA' Rajci, Fusion Solutions KFT @ [email\xa0protected]\n", '*/\n', 'pragma solidity 0.4.26;\n', '\n', 'contract Owned {\n', '    /* Variables */\n', '    address public owner = msg.sender;\n', '    /* Constructor */\n', '    constructor(address _owner) public {\n', '        if ( _owner == address(0x00000000000000000000000000000000000000) ) {\n', '            _owner = msg.sender;\n', '        }\n', '        owner = _owner;\n', '    }\n', '    /* Externals */\n', '    function replaceOwner(address _owner) external returns(bool) {\n', '        require( isOwner() );\n', '        owner = _owner;\n', '        return true;\n', '    }\n', '    /* Internals */\n', '    function isOwner() internal view returns(bool) {\n', '        return owner == msg.sender;\n', '    }\n', '    /* Modifiers */\n', '    modifier forOwner {\n', '        require( isOwner() );\n', '        _;\n', '    }\n', '}\n', '\n', '/*\n', '    tokenDB.sol v1.0.0\n', '    Token Database - ABSTRACT\n', '    \n', '    This file is part of Screenist [NIS] token project.\n', '    \n', "    Author: Andor 'iFA' Rajci, Fusion Solutions KFT @ [email\xa0protected]\n", '*/\n', 'pragma solidity 0.4.26;\n', '\n', 'contract TokenDB is Owned {\n', '    /* Declarations */\n', '    using SafeMath for uint256;\n', '    /* Structures */\n', '    struct balances_s {\n', '        uint256 amount;\n', '        bool valid;\n', '    }\n', '    struct vesting_s {\n', '        uint256 amount;\n', '        uint256 startBlock;\n', '        uint256 endBlock;\n', '        uint256 claimedAmount;\n', '        bool    valid;\n', '    }\n', '    /* Variables */\n', '    mapping(address => mapping(address => uint256)) private allowance;\n', '    mapping(address => balances_s) private balances;\n', '    mapping(address => vesting_s) public vesting;\n', '    uint256 public totalSupply;\n', '    address public tokenAddress;\n', '    address public oldDBAddress;\n', '    uint256 public totalVesting;\n', '    /* Constructor */\n', '    constructor(address _owner, address _tokenAddress, address _oldDBAddress) Owned(_owner) public {}\n', '    /* Externals */\n', '    function changeTokenAddress(address _tokenAddress) external forOwner {}\n', '    function mint(address _to, uint256 _amount) external returns(bool _success) {}\n', '    function transfer(address _from, address _to, uint256 _amount) external returns(bool _success) {}\n', '    function bulkTransfer(address _from, address[] memory _to, uint256[] memory _amount) public returns(bool _success) {}\n', '    function setAllowance(address _owner, address _spender, uint256 _amount) external returns(bool _success) {}\n', '    function setVesting(address _owner, uint256 _amount, uint256 _startBlock, uint256 _endBlock, uint256 _claimedAmount) external returns(bool _success) {}\n', '    /* Constants */\n', '    function getAllowance(address _owner, address _spender) public view returns(bool _success, uint256 _remaining) {}\n', '    function getBalance(address _owner) public view returns(bool _success, uint256 _balance) {}\n', '    function getTotalSupply() public view returns(bool _success, uint256 _totalSupply) {}\n', '    function getTotalVesting() public view returns(bool _success, uint256 _totalVesting) {}\n', '    function getVesting(address _owner) public view returns(bool _success, uint256 _amount, uint256 _startBlock, uint256 _endBlock, uint256 _claimedAmount, bool _valid) {}\n', '    /* Internals */\n', '    function _getBalance(address _owner) internal view returns(uint256 _balance) {}\n', '    function _getTotalSupply() internal view returns(uint256 _totalSupply) {}\n', '    function _getTotalVesting() internal view returns(uint256 _totalVesting) {}\n', '}\n', '\n', '/*\n', '    token.sol v1.0.0\n', '    Token Proxy\n', '    \n', '    This file is part of Screenist [NIS] token project.\n', '    \n', "    Author: Andor 'iFA' Rajci, Fusion Solutions KFT @ [email\xa0protected]\n", '*/\n', 'pragma solidity 0.4.26;\n', '\n', 'contract Token is Owned {\n', '    /* Declarations */\n', '    using SafeMath for uint256;\n', '    /* Variables */\n', '    string  public name = "Screenist Token";\n', '    string  public symbol = "NIS";\n', '    uint8   public decimals = 8;\n', '    address public libAddress;\n', '    address public freezeAdmin;\n', '    address public vestingAdmin;\n', '    TokenDB public db;\n', '    bool    public underFreeze;\n', '    /* Constructor */\n', '    constructor(address _owner, address _freezeAdmin, address _vestingAdmin, address _libAddress, address _dbAddress, bool _isLib) Owned(_owner) public {\n', '        if ( ! _isLib ) {\n', '            db = TokenDB(_dbAddress);\n', '            libAddress = _libAddress;\n', '            vestingAdmin = _vestingAdmin;\n', '            freezeAdmin = _freezeAdmin;\n', '            require( db.setAllowance(address(this), _owner, uint256(0)-1) );\n', '            require( db.mint(address(this), 1.55e16) );\n', '            emit Mint(address(this), 1.55e16);\n', '        }\n', '    }\n', '    /* Fallback */\n', '    function () external payable {\n', '        owner.transfer(msg.value);\n', '    }\n', '    /* Externals */\n', '    function changeLibAddress(address _libAddress) public forOwner {\n', '        libAddress = _libAddress;\n', '    }\n', '    function changeDBAddress(address _dbAddress) public forOwner {\n', '        db = TokenDB(_dbAddress);\n', '    }\n', '    function setFreezeStatus(bool _newStatus) public forFreezeAdmin {\n', '        underFreeze = _newStatus;\n', '    }\n', '    function approve(address _spender, uint256 _value) public returns (bool _success) {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    function transfer(address _to, uint256 _amount) public isNotFrozen returns(bool _success)  {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    function bulkTransfer(address[] memory _to, uint256[] memory _amount) public isNotFrozen returns(bool _success)  {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _amount) public isNotFrozen returns (bool _success)  {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    function setVesting(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock) public forVestingAdmin {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0)\n', '            }\n', '        }\n', '    }\n', '    function claimVesting() public isNotFrozen {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0)\n', '            }\n', '        }\n', '    }\n', '    /* Constants */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 _remaining) {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    function balanceOf(address _owner) public constant returns (uint256 _balance) {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    function totalSupply() public constant returns (uint256 _totalSupply) {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    function getVesting(address _owner) public constant returns(uint256 _amount, uint256 _startBlock, uint256 _endBlock, uint256 _claimedAmount) {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x80)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x80)\n', '            }\n', '        }\n', '    }\n', '    function totalVesting() public constant returns(uint256 _amount) {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    function calcVesting(address _owner) public constant returns(uint256 _reward) {\n', '        address _trg = libAddress;\n', '        assembly {\n', '            let m := mload(0x40)\n', '            calldatacopy(m, 0, calldatasize)\n', '            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\n', '            switch success case 0 {\n', '                revert(0, 0)\n', '            } default {\n', '                return(m, 0x20)\n', '            }\n', '        }\n', '    }\n', '    /* Events */\n', '    event AllowanceUsed(address indexed _spender, address indexed _owner, uint256 indexed _value);\n', '    event Mint(address indexed _addr, uint256 indexed _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event VestingDefined(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock);\n', '    event VestingClaimed(address _beneficiary, uint256 _amount);\n', '    /* Modifiers */\n', '    modifier isNotFrozen {\n', '        require( ! underFreeze );\n', '        _;\n', '    }\n', '    modifier forOwner {\n', '        require( isOwner() );\n', '        _;\n', '    }\n', '    modifier forVestingAdmin {\n', '        require( msg.sender == vestingAdmin );\n', '        _;\n', '    }\n', '    modifier forFreezeAdmin {\n', '        require( msg.sender == freezeAdmin );\n', '        _;\n', '    }\n', '}\n', '\n', '/*\n', '    tokenLib.sol v1.0.1\n', '    Token Library\n', '    \n', '    This file is part of Screenist [NIS] token project.\n', '    \n', "    Author: Andor 'iFA' Rajci, Fusion Solutions KFT @ [email\xa0protected]\n", '*/\n', 'pragma solidity 0.4.26;\n', '\n', 'contract TokenLib is Token {\n', '    /* Constructor */\n', '    constructor(address _owner, address _freezeAdmin, address _vestingAdmin, address _libAddress, address _dbAddress) Token(_owner, _freezeAdmin, _vestingAdmin, _libAddress, _dbAddress, true) public {}\n', '    /* Externals */\n', '    function approve(address _spender, uint256 _amount) public returns (bool _success) {\n', '        _approve(_spender, _amount);\n', '        return true;\n', '    }\n', '    function transfer(address _to, uint256 _amount) public returns (bool _success) {\n', '        _transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '    function bulkTransfer(address[] memory _to, uint256[] memory _amount) public returns (bool _success) {\n', '        uint256 i;\n', '        require( _to.length == _amount.length );\n', '        require( db.bulkTransfer(msg.sender, _to, _amount) );\n', '        for ( i=0 ; i<_to.length ; i++ ) {\n', '            require( _amount[i] > 0 && _to[i] != 0x00 && msg.sender != _to[i] );\n', '            emit Transfer(msg.sender, _to[i], _amount[i]);\n', '        }\n', '        return true;\n', '    }\n', '    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool _success) {\n', '        bool    _subResult;\n', '        uint256 _remaining;\n', '        if ( _from != msg.sender ) {\n', '            (_subResult, _remaining) = db.getAllowance(_from, msg.sender);\n', '            require( _subResult );\n', '            _remaining = _remaining.sub(_amount);\n', '            require( db.setAllowance(_from, msg.sender, _remaining) );\n', '            emit AllowanceUsed(msg.sender, _from, _amount);\n', '        }\n', '        _transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    function setVesting(address _beneficiary, uint256 _amount, uint256 _startBlock, uint256 _endBlock) {\n', '        require( _beneficiary != 0x00 );\n', '        if ( _amount == 0 ) {\n', '            _startBlock = 0;\n', '            _endBlock = 0;\n', '        } else {\n', '            require( _endBlock > _startBlock );\n', '        }\n', '        require( db.setVesting(_beneficiary, _amount, _startBlock, _endBlock, 0) );\n', '        emit VestingDefined(_beneficiary, _amount, _startBlock, _endBlock);\n', '    }\n', '    function claimVesting() public {\n', '        uint256 _amount;\n', '        uint256 _startBlock;\n', '        uint256 _endBlock;\n', '        uint256 _claimedAmount;\n', '        uint256 _reward;\n', '        ( _amount, _startBlock, _endBlock, _claimedAmount ) = _getVesting(msg.sender);\n', '        _reward = _calcVesting(_amount, _startBlock, _endBlock, _claimedAmount);\n', '        require( _reward > 0 );\n', '        _claimedAmount = _claimedAmount.add(_reward);\n', '        if ( _claimedAmount == _amount ) {\n', '            require( db.setVesting(msg.sender, 0, 0, 0, 0) );\n', '            emit VestingDefined(msg.sender, 0, 0, 0);\n', '        } else {\n', '            require( db.setVesting(msg.sender, _amount, _startBlock, _endBlock, _claimedAmount) );\n', '            emit VestingDefined(msg.sender, _amount, _startBlock, _endBlock);\n', '        }\n', '        _transfer(address(this), msg.sender, _reward);\n', '        emit VestingClaimed(msg.sender, _reward);\n', '    }\n', '    /* Constants */\n', '    function allowance(address _owner, address _spender) public constant returns (uint256 _remaining) {\n', '        bool _subResult;\n', '        (_subResult, _remaining) = db.getAllowance(_owner, _spender);\n', '        require( _subResult );\n', '    }\n', '    function balanceOf(address _owner) public constant returns (uint256 _balance) {\n', '        bool _subResult;\n', '        (_subResult, _balance) = db.getBalance(_owner);\n', '        require( _subResult );\n', '    }\n', '    function totalSupply() public constant returns (uint256 _totalSupply) {\n', '        bool _subResult;\n', '        (_subResult, _totalSupply) = db.getTotalSupply();\n', '        require( _subResult );\n', '    }\n', '    function totalVesting() public constant returns (uint256 _totalVesting) {\n', '        bool _subResult;\n', '        (_subResult, _totalVesting) = db.getTotalVesting();\n', '        require( _subResult );\n', '    }\n', '    function getVesting(address _owner) public constant returns(uint256 _amount, uint256 _startBlock, uint256 _endBlock, uint256 _claimedAmount) {\n', '        return _getVesting(_owner);\n', '    }\n', '    function calcVesting(address _owner) public constant returns(uint256 _reward) {\n', '        uint256 _amount;\n', '        uint256 _startBlock;\n', '        uint256 _endBlock;\n', '        uint256 _claimedAmount;\n', '        ( _amount, _startBlock, _endBlock, _claimedAmount ) = _getVesting(_owner);\n', '        return _calcVesting(_amount, _startBlock, _endBlock, _claimedAmount);\n', '    }\n', '    /* Internals */\n', '    function _transfer(address _from, address _to, uint256 _amount) internal {\n', '        require( _amount > 0 && _from != 0x00 && _to != 0x00 && _from != _to );\n', '        require( db.transfer(_from, _to, _amount) );\n', '        emit Transfer(_from, _to, _amount);\n', '    }\n', '    function _approve(address _spender, uint256 _amount) internal {\n', '        require( msg.sender != _spender );\n', '        require( db.setAllowance(msg.sender, _spender, _amount) );\n', '        emit Approval(msg.sender, _spender, _amount);\n', '    }\n', '    function _getVesting(address _owner) internal constant returns(uint256 _amount, uint256 _startBlock, uint256 _endBlock, uint256 _claimedAmount) {\n', '        bool _subResult;\n', '        bool _valid;\n', '        ( _subResult, _amount, _startBlock, _endBlock, _claimedAmount, _valid ) = db.getVesting(_owner);\n', '        require( _subResult );\n', '    }\n', '    function _calcVesting(uint256 _amount, uint256 _startBlock, uint256 _endBlock, uint256 _claimedAmount) internal constant returns(uint256 _reward) {\n', '        if ( _amount > 0 && block.number > _startBlock ) {\n', '            _reward = _amount.mul( block.number.sub(_startBlock) ).div( _endBlock.sub(_startBlock) );\n', '            if ( _reward > _amount ) {\n', '                _reward = _amount;\n', '            }\n', '            if ( _reward <= _claimedAmount ) {\n', '                _reward = 0;\n', '            } else {\n', '                _reward = _reward.sub(_claimedAmount);\n', '            }\n', '        }\n', '    }\n', '}']