['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.3;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./IATokenV1.sol";\n', 'import "./ICToken.sol";\n', 'import "./IComptroller.sol";\n', 'import "./ISushiBar.sol";\n', 'import "./ILendingPoolV1.sol";\n', 'import "./ICompoundLens.sol";\n', 'import "./IUniswapV2.sol";\n', 'import "./IBasket.sol";\n', 'import "./IBasicIssuanceModule.sol";\n', '\n', 'import "./SafeMath.sol";\n', 'import "./ERC20.sol";\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', '\n', 'import "./BDIMarketMaker.sol";\n', '\n', '// Mint tokens with a delay\n', 'contract DelayedMinter is MarketMakerMinter {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // Can only mint after 20 mins, and only has a 20 mins window to mint\n', '    // 20 min window to mint\n', '    uint256 public mintDelaySeconds = 1200;\n', '    uint256 public maxMintDelaySeconds = 2400;\n', '\n', '    address public governance;\n', '\n', '    // User deposited\n', '    mapping(address => uint256) public deposits;\n', '\n', '    // When user deposited\n', '    mapping(address => uint256) public timestampWhenDeposited;\n', '\n', '    // Blacklist\n', '    mapping(address => bool) public isBlacklisted;\n', '\n', '    // **** Constructor and modifiers ****\n', '\n', '    constructor(address _governance) {\n', '        governance = _governance;\n', '\n', '        // Enter compound markets\n', '        address[] memory markets = new address[](2);\n', '        markets[0] = CUNI;\n', '        markets[0] = CCOMP;\n', '        enterMarkets(markets);\n', '\n', '        IERC20(WETH).safeApprove(SUSHISWAP_ROUTER, uint256(-1));\n', '        IERC20(WETH).safeApprove(UNIV2_ROUTER, uint256(-1));\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    // **** Modifiers ****\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == governance, "!governance");\n', '        _;\n', '    }\n', '\n', '    modifier onlyEOA() {\n', '        require(msg.sender == tx.origin, "!eoa");\n', '        _;\n', '    }\n', '\n', '    modifier notBlacklisted() {\n', '        require(!isBlacklisted[msg.sender], "blacklisted");\n', '        _;\n', '    }\n', '\n', '    // **** Restricted functions ****\n', '\n', '    function setGov(address _governance) public onlyGov {\n', '        governance = _governance;\n', '    }\n', '\n', '    function recoverERC20(address _token) public onlyGov {\n', '        IERC20(_token).safeTransfer(governance, IERC20(_token).balanceOf(address(this)));\n', '    }\n', '\n', '    function recoverERC20s(address[] memory _tokens) public onlyGov {\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            recoverERC20(_tokens[i]);\n', '        }\n', '    }\n', '\n', '    function setMintDelaySeconds(uint256 _seconds) public onlyGov {\n', '        mintDelaySeconds = _seconds;\n', '    }\n', '\n', '    function setMaxMintDelaySeconds(uint256 _seconds) public onlyGov {\n', '        maxMintDelaySeconds = _seconds;\n', '    }\n', '\n', '    function setBlacklist(address _user, bool _b) public onlyGov {\n', '        isBlacklisted[_user] = _b;\n', '    }\n', '\n', '    // **** Public Functions ****\n', '\n', '    function deposit() public payable {\n', '        require(msg.value > 0, "!value");\n', '\n', '        deposits[msg.sender] = deposits[msg.sender].add(msg.value);\n', '        timestampWhenDeposited[msg.sender] = block.timestamp;\n', '    }\n', '\n', '    function withdraw(uint256 _amount) public {\n', '        deposits[msg.sender] = deposits[msg.sender].sub(_amount);\n', '\n', '        (bool success, ) = msg.sender.call{ value: _amount }("");\n', '        require(success, "!eth-transfer");\n', '    }\n', '\n', '    function mintWithETH(\n', '        address[] memory routers,\n', '        bytes[] memory routerCalldata,\n', '        address[] memory constituents,\n', '        address[] memory underlyings,\n', '        uint256[] memory underlyingsWeights,\n', '        uint256 minMintAmount,\n', '        uint256 deadline\n', '    ) public onlyEOA notBlacklisted returns (uint256) {\n', '        require(block.timestamp <= deadline, "expired");\n', '\n', '        // Memory\n', '        bytes memory mmParams =\n', '            abi.encode(\n', '                MMParams({\n', '                    routers: routers,\n', '                    routerCalldata: routerCalldata,\n', '                    constituents: constituents,\n', '                    underlyings: underlyings,\n', '                    underlyingsWeights: underlyingsWeights\n', '                })\n', '            );\n', '\n', '        uint256 _amount = deposits[msg.sender];\n', '\n', '        require(_amount > 0, "!amount");\n', '        require(_canMint(timestampWhenDeposited[msg.sender]), "!timestamp");\n', '\n', '        uint256 sum = 0;\n', '        for (uint256 i = 0; i < underlyingsWeights.length; i++) {\n', '            sum = sum.add(underlyingsWeights[i]);\n', '        }\n', '        // Sum should be between 0.999 and 1.000\n', '        assert(sum <= 1e18);\n', '        assert(sum >= 999e15);\n', '\n', '        // Wrap user amount ETH to WETH\n', '        IWETH(WETH).deposit{ value: deposits[msg.sender] }();\n', '\n', '        // BDPI to mint\n', '        uint256 bdiMinted = _mintBDIWithWETH(deposits[msg.sender], mmParams);\n', '\n', '        // Reset deposit\n', '        deposits[msg.sender] = 0;\n', '\n', '        require(bdiMinted >= minMintAmount, "!mint-min-amount");\n', '\n', '        // Mint tokens and transfer to user\n', '        IERC20(address(BDPI)).safeTransfer(msg.sender, bdiMinted);\n', '\n', '        return bdiMinted;\n', '    }\n', '\n', '    // **** Internal functions ****\n', '\n', '    function _canMint(uint256 _depositTime) public view returns (bool) {\n', '        return\n', '            block.timestamp >= _depositTime + mintDelaySeconds && block.timestamp <= _depositTime + maxMintDelaySeconds;\n', '    }\n', '}']