['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'pragma abicoder v2;\n', '\n', 'import "./ReentrancyGuard.sol";\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./XIVInterface.sol";\n', '\n', 'contract XIVBettingFlexible is Ownable,ReentrancyGuard{\n', '    \n', '    using SafeMath for uint256;\n', '    address public databaseContractAddress=0x09eD6f016178cF5Aed0bda43A7131B775042a3c6;\n', '    uint256 constant secondsInADay=24 hours;\n', '    \n', '    function betFlexible(uint256 amountOfXIV, uint16 typeOfBet, address _betContractAddress, uint256 betSlabeIndex, uint256 _days) external nonReentrant{\n', '         /* 0-> defi fixed, 1-> defi flexible, 2-> defi index fixed, 3-> defi index flexible, \n', '        * 4-> chain coin fixed, 5-> chain coin flexible, 6-> chain index fixed, 7-> chain index flexible\n', '        * 8-> NFT fixed, 9-> NFT flexible, 10-> NFT index fixed, 11-> NFT index flexible\n', '        */\n', '        require(typeOfBet==1 || typeOfBet==3  || typeOfBet==5 || typeOfBet==7 || typeOfBet==9  || typeOfBet==11, "Invalid bet Type");\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        require(!dContract.getExistingBetCheckMapping(msg.sender,typeOfBet,_betContractAddress),"you can\'t place bet using these values.");\n', '        Token tokenObj = Token(dContract.getXIVTokenContractAddress());\n', '        require((dContract.getBetFactorLP()).mul(dContract.getTokenStakedAmount())>=\n', '                        ((tokenObj.balanceOf(databaseContractAddress)).sub(dContract.getTokenStakedAmount())).add(amountOfXIV),\n', '                        "Staking Vaults Have EXCEEDED CAPACITY. Please Check Back in 24hrs?");\n', '       \n', '        require(amountOfXIV>=dContract.getMinStakeXIVAmount() && amountOfXIV<=dContract.getMaxStakeXIVAmount(),"Please enter amount in the specified range");\n', '       \n', '        require(checkTimeForBet(_days),"Staking time closed for the selected day");\n', '        uint256 _currentPrice;\n', '        XIVDatabaseLib.FlexibleInfo memory flexInfo;\n', '        uint256 _coinType;\n', '        if(typeOfBet==1 || typeOfBet==3){\n', '            _coinType=1;\n', '        }else if(typeOfBet==5 || typeOfBet==7){\n', '            _coinType=2;\n', '        }else if(typeOfBet==9 || typeOfBet==11){\n', '            _coinType=3;\n', '        }\n', '        if(typeOfBet==1 || typeOfBet==5 || typeOfBet==9){\n', '            //defi flexible\n', '            require(dContract.getFlexibleMapping(_betContractAddress,_coinType).status,"The currency is currently disabled.");\n', '            require(dContract.getFlexibleDefiCoinArray().length>betSlabeIndex,"Day does not exists.");\n', '            OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n', '            _currentPrice=uint256(oWObject.getPrice(dContract.getFlexibleMapping(_betContractAddress,_coinType).currencySymbol, dContract.getFlexibleMapping(_betContractAddress,_coinType).oracleType));\n', '            flexInfo=dContract.getFlexibleDefiCoinArray()[betSlabeIndex];\n', '        }else{\n', '            //index flexible\n', '            require(dContract.getFlexibleIndexArray().length>betSlabeIndex,"Day does not exists.");\n', '            _currentPrice=uint256(calculateIndexValueForFlexibleInternal(dContract.getBetId(),_coinType));\n', '            flexInfo=dContract.getFlexibleIndexArray()[betSlabeIndex];\n', '        }\n', '        XIVDatabaseLib.BetInfo memory binfo=XIVDatabaseLib.BetInfo({\n', '            id:uint128(dContract.getBetId()),\n', '            principalAmount:amountOfXIV,\n', '            amount:amountOfXIV,\n', '            userAddress:msg.sender,\n', '            contractAddress:typeOfBet==3?address(0):_betContractAddress,\n', '            betType:typeOfBet,\n', '            currentPrice:_currentPrice,\n', '            betTimePeriod:_days.mul(1 days),\n', '            checkpointPercent:flexInfo.upDownPercentage,\n', '            rewardFactor:flexInfo.rewardFactor,\n', '            riskFactor:flexInfo.riskFactor,\n', '            timestamp:block.timestamp,\n', '            coinType:_coinType,\n', '            status:0\n', '        });\n', '        \n', '        saveBetInfo(binfo);\n', '    }\n', '    function saveBetInfo(XIVDatabaseLib.BetInfo memory binfo) internal{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        dContract.updateBetArray(binfo);\n', '        dContract.updateFindBetInArrayUsingBetIdMapping(dContract.getBetId(),dContract.getBetArray().length.sub(1));\n', '        if(dContract.getBetsAccordingToUserAddress(binfo.userAddress).length==0){\n', '            dContract.addUserAddressUsedForBetting(binfo.userAddress);\n', '        }\n', '        dContract.updateBetAddressesArray(binfo.userAddress,dContract.getBetId());\n', '        dContract.updateBetId(dContract.getBetId().add(1));\n', '        uint256 betEndTime=(((((binfo.timestamp).div(secondsInADay)).mul(secondsInADay))).add(secondsInADay.div(2)).add(binfo.betTimePeriod).sub(1));\n', '        dContract.emitBetDetails(binfo.id,binfo.status,betEndTime);\n', '        \n', '        dContract.transferFromTokens(dContract.getXIVTokenContractAddress(),binfo.userAddress,databaseContractAddress,binfo.amount);\n', '        dContract.updateTotalTransactions(dContract.getTotalTransactions().add(binfo.amount));\n', '        dContract.updateExistingBetCheckMapping(binfo.userAddress,binfo.betType,binfo.contractAddress,true);\n', '    }\n', '    function checkTimeForBet(uint256 _days) internal view returns(bool){\n', '        uint256 currentTime=block.timestamp;\n', '        uint256 utcNoon=((currentTime.div(secondsInADay)).mul(secondsInADay)).add(secondsInADay.div(2));\n', '        if(_days==1){\n', '            if(((utcNoon).add(4 hours))>currentTime && utcNoon<currentTime){\n', '                return true;\n', '            }else{\n', '                return false;\n', '            }\n', '        }else if(_days==3){\n', '            if(((utcNoon).add(12 hours))>currentTime && utcNoon<currentTime){\n', '                return true;\n', '            }else{\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '    \n', '   function calculateIndexValueForBetActual(uint256 coinType) public view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap;\n', '        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray(coinType).length;i++){\n', '            Token tObj=Token(dContract.getAllIndexContractAddressArray(coinType)[i]);\n', '            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getIndexMapping(dContract.getAllIndexContractAddressArray(coinType)[i],coinType);\n', '            if(iCObj.status){\n', '                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n', '            }\n', '        }\n', '        return totalMarketcap;\n', '    }\n', '    function calculateIndexValueForBetBase(uint256 coinType) external view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap=calculateIndexValueForBetActual(coinType);\n', '         if(dContract.getBetBaseIndexValue(coinType)==0){\n', '            return (10**11);\n', '        }else{\n', '            if(totalMarketcap>dContract.getBetActualIndexValue(coinType)){\n', '                return (dContract.getBetBaseIndexValue(coinType).add((\n', '                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue(coinType)))\n', '                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue(coinType))));\n', '            }else if(totalMarketcap<dContract.getBetActualIndexValue(coinType)){\n', '                return (dContract.getBetBaseIndexValue(coinType).sub((\n', '                                                     (dContract.getBetActualIndexValue(coinType).sub(totalMarketcap))\n', '                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue(coinType))));\n', '            }\n', '        }\n', '        return (10**11);\n', '    }\n', '    \n', '    function calculateIndexValueForFlexibleInternal(uint256 _betId,uint256 coinType) internal returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap;\n', '        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray(coinType).length;i++){\n', '            Token tObj=Token(dContract.getAllIndexContractAddressArray(coinType)[i]);\n', '            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getIndexMapping(dContract.getAllIndexContractAddressArray(coinType)[i],coinType);\n', '            if(iCObj.status){\n', '                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n', '                dContract.updateBetIndexArray(_betId,iCObj);\n', '            }\n', '        }\n', '        XIVDatabaseLib.BetPriceHistory memory bPHObj=XIVDatabaseLib.BetPriceHistory({\n', '            baseIndexValue:uint128(dContract.getBetBaseIndexValue(coinType)==0?10**11:dContract.getBetBaseIndexValue(coinType)),\n', '            actualIndexValue:uint128(totalMarketcap)\n', '        });\n', '        dContract.updateBetPriceHistoryMapping(_betId,bPHObj);\n', '        if(dContract.getBetBaseIndexValue(coinType)==0){\n', '            dContract.updateBetBaseIndexValue(10**11,coinType);\n', '        }else{\n', '            if(totalMarketcap>dContract.getBetActualIndexValue(coinType)){\n', '                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue(coinType).add((\n', '                                                     (totalMarketcap.sub(dContract.getBetActualIndexValue(coinType)))\n', '                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue(coinType))),coinType);\n', '            }else if(totalMarketcap<dContract.getBetActualIndexValue(coinType)){\n', '                dContract.updateBetBaseIndexValue(dContract.getBetBaseIndexValue(coinType).sub((\n', '                                                     (dContract.getBetActualIndexValue(coinType).sub(totalMarketcap))\n', '                                                     .mul(100*10**8)).div(dContract.getBetActualIndexValue(coinType))),coinType);\n', '            }\n', '        }\n', '        dContract.updateBetActualIndexValue(totalMarketcap,coinType);\n', '        return totalMarketcap;\n', '    }\n', '    \n', '    function claimBet(uint256 userBetId) external nonReentrant{\n', '        // 0-> defi Fixed, 1->defi flexible, 2-> index Fixed and 3-> index flexible\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 index=dContract.getFindBetInArrayUsingBetIdMapping(userBetId);\n', '        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        require((bObject.status==0) \n', '                || (bObject.status==1)\n', '                || (bObject.status==2),"bet is closed.");\n', '        if(bObject.status==0){\n', '           if(block.timestamp.sub(bObject.timestamp) > 6 days){\n', '                plentyFinal(index,7);\n', '                return;\n', '            }else if(block.timestamp.sub(bObject.timestamp) > 5 days){\n', '                plentyFinal(index,6);\n', '                return;\n', '            }else if(block.timestamp.sub(bObject.timestamp) > 4 days){\n', '                plentyFinal(index,5);\n', '                return;\n', '            }else if(block.timestamp.sub(bObject.timestamp) > 3 days){\n', '                plentyFinal(index,4);\n', '                return;\n', '            }else if(block.timestamp.sub(bObject.timestamp) > 2 days){\n', '                plentyFinal(index,3);\n', '                return;\n', '            }else if(block.timestamp.sub(bObject.timestamp) > 1 days){\n', '                plentyFinal(index,2);\n', '                return;\n', '            }else{\n', '                plentyFinal(index,1);\n', '                return;\n', '            }\n', '        }else{\n', '            claimBetFinal(index);\n', '        }\n', '    }\n', '    \n', '    function claimBetFinal(uint256 index) internal{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        require(bObject.userAddress==msg.sender,"Authentication failure");\n', '        require(bObject.amount!=0,"Your bet amount is 0");\n', '        dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,(bObject.amount)); \n', '        bObject.amount=0; // return 3 times\n', '        dContract.updateBetArrayIndex(bObject,index);\n', '    }\n', '    function plentyFinal(uint256 index, uint256 _days) internal{\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        XIVDatabaseLib.BetInfo memory bObject=dContract.getBetArray()[index];\n', '        uint256 plentyPercentage;\n', '        if(bObject.betTimePeriod==1 days){\n', '            plentyPercentage=dContract.getPlentyOneDayPercentage();\n', '        }else if(bObject.betTimePeriod==3 days){\n', '            plentyPercentage=dContract.getPlentyThreeDayPercentage(_days);\n', '        }else if(bObject.betTimePeriod==7 days){\n', '            plentyPercentage=dContract.getPlentySevenDayPercentage(_days);\n', '        }\n', '        if(plentyPercentage!=0){\n', '            uint256 plentyAmount=((plentyPercentage.mul(bObject.amount)).div(10**4));\n', '            uint256 userAmount=(bObject.amount).sub(plentyAmount);\n', '            if(userAmount!=0){\n', '                dContract.transferTokens(dContract.getXIVTokenContractAddress(),msg.sender,userAmount); \n', '            }\n', '            if(plentyAmount!=0){\n', '                dContract.transferTokens(dContract.getXIVTokenContractAddress(),dContract.getAdminAddress(),plentyAmount); \n', '            }\n', '            bObject.status=3;\n', '            bObject.amount=0;\n', '            dContract.updateBetArrayIndex(bObject,index);\n', '            dContract.updateExistingBetCheckMapping(bObject.userAddress,bObject.betType,bObject.contractAddress,false);\n', '        }\n', '    }\n', '    \n', '    function marketCapValue(XIVDatabaseLib.IndexCoin memory iCObj,Token tObj) internal view returns(uint256){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        OracleWrapper oWObject=OracleWrapper(dContract.getOracleWrapperContractAddress());\n', '         if((keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked("ETH"))) || (keccak256(abi.encodePacked(iCObj.currencySymbol))) == (keccak256(abi.encodePacked("BTC")))){\n', '            return ((((oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n', '                                        /* .mul(iCObj.contributionPercentage)*/)\n', '                                        .div(10**2)));\n', '        }else{\n', '            return (((tObj.totalSupply().mul(oWObject.getPrice(iCObj.currencySymbol,iCObj.oracleType))\n', '                                /*.mul(iCObj.contributionPercentage)*/)\n', '                                .div((10**tObj.decimals()).mul(10**2))));\n', '        }\n', '    }\n', '    function getPieChartValue(uint256 coinType) external view returns(XIVDatabaseLib.IndexCoin[] memory){\n', '        DatabaseContract dContract=DatabaseContract(databaseContractAddress);\n', '        uint256 totalMarketcap;\n', '        XIVDatabaseLib.IndexCoin[] memory tempIndexArray=new XIVDatabaseLib.IndexCoin[](dContract.getAllIndexContractAddressArray(coinType).length);\n', '        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray(coinType).length;i++){\n', '            Token tObj=Token(dContract.getAllIndexContractAddressArray(coinType)[i]);\n', '            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getIndexMapping(dContract.getAllIndexContractAddressArray(coinType)[i],coinType);\n', '            if(iCObj.status){\n', '                totalMarketcap=totalMarketcap.add(marketCapValue(iCObj,tObj));\n', '            }\n', '        }\n', '        for(uint256 i=0;i<dContract.getAllIndexContractAddressArray(coinType).length;i++){\n', '            Token tObj=Token(dContract.getAllIndexContractAddressArray(coinType)[i]);\n', '            XIVDatabaseLib.IndexCoin memory iCObj=dContract.getIndexMapping(dContract.getAllIndexContractAddressArray(coinType)[i],coinType);\n', '            if(iCObj.status){\n', '                iCObj.contributionPercentage=(marketCapValue(iCObj,tObj).mul(10**4))/totalMarketcap;\n', '                tempIndexArray[i]=iCObj;\n', '            }\n', '        }\n', '        return tempIndexArray;\n', '    }\n', '    \n', '    function updateDatabaseAddress(address _databaseContractAddress) external onlyOwner{\n', '        databaseContractAddress=_databaseContractAddress;\n', '    }\n', '    \n', '}']