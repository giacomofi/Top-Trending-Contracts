['# @version 0.2.11\n', '"""\n', '@title Curve Registry Exchange Contract\n', '@license MIT\n', '@author Curve.Fi\n', '@notice Find pools, query exchange rates and perform swaps\n', '"""\n', '\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', '\n', 'interface AddressProvider:\n', '    def admin() -> address: view\n', '    def get_registry() -> address: view\n', '    def get_address(idx: uint256) -> address: view\n', '\n', 'interface CurvePool:\n', '    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\n', '    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\n', '    def get_dy(i: int128, j: int128, amount: uint256) -> uint256: view\n', '    def get_dy_underlying(i: int128, j: int128, amount: uint256) -> uint256: view\n', '\n', 'interface Registry:\n', '    def address_provider() -> address: view\n', '    def get_A(_pool: address) -> uint256: view\n', '    def get_fees(_pool: address) -> uint256[2]: view\n', '    def get_coin_indices(_pool: address, _from: address, _to: address) -> (int128, int128, bool): view\n', '    def get_n_coins(_pool: address) -> uint256[2]: view\n', '    def get_balances(_pool: address) -> uint256[MAX_COINS]: view\n', '    def get_underlying_balances(_pool: address) -> uint256[MAX_COINS]: view\n', '    def get_rates(_pool: address) -> uint256[MAX_COINS]: view\n', '    def get_decimals(_pool: address) -> uint256[MAX_COINS]: view\n', '    def get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]: view\n', '    def find_pool_for_coins(_from: address, _to: address, i: uint256) -> address: view\n', '    def get_lp_token(_pool: address) -> address: view\n', '\n', 'interface Calculator:\n', '    def get_dx(n_coins: uint256, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\n', '               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS],\n', '               i: int128, j: int128, dx: uint256) -> uint256: view\n', '    def get_dy(n_coins: uint256, balances: uint256[MAX_COINS], amp: uint256, fee: uint256,\n', '               rates: uint256[MAX_COINS], precisions: uint256[MAX_COINS],\n', '               i: int128, j: int128, dx: uint256[CALC_INPUT_SIZE]) -> uint256[CALC_INPUT_SIZE]: view\n', '\n', '\n', 'event TokenExchange:\n', '    buyer: indexed(address)\n', '    receiver: indexed(address)\n', '    pool: indexed(address)\n', '    token_sold: address\n', '    token_bought: address\n', '    amount_sold: uint256\n', '    amount_bought: uint256\n', '\n', '\n', 'ETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n', 'MAX_COINS: constant(int128) = 8\n', 'CALC_INPUT_SIZE: constant(uint256) = 100\n', '\n', '\n', 'address_provider: AddressProvider\n', 'registry: public(address)\n', 'factory_registry: public(address)\n', '\n', 'default_calculator: public(address)\n', 'is_killed: public(bool)\n', 'pool_calculator: HashMap[address, address]\n', '\n', 'is_approved: HashMap[address, HashMap[address, bool]]\n', '\n', '\n', '@external\n', 'def __init__(_address_provider: address, _calculator: address):\n', '    """\n', '    @notice Constructor function\n', '    """\n', '    self.address_provider = AddressProvider(_address_provider)\n', '    self.registry = AddressProvider(_address_provider).get_registry()\n', '    self.factory_registry = AddressProvider(_address_provider).get_address(3)\n', '    self.default_calculator = _calculator\n', '\n', '\n', '@external\n', '@payable\n', 'def __default__():\n', '    pass\n', '\n', '\n', '@view\n', '@internal\n', 'def _get_exchange_amount(\n', '    _registry: address,\n', '    _pool: address,\n', '    _from: address,\n', '    _to: address,\n', '    _amount: uint256\n', ') -> uint256:\n', '    """\n', '    @notice Get the current number of coins received in an exchange\n', '    @param _registry Registry address\n', '    @param _pool Pool address\n', '    @param _from Address of coin to be sent\n', '    @param _to Address of coin to be received\n', '    @param _amount Quantity of `_from` to be sent\n', '    @return Quantity of `_to` to be received\n', '    """\n', '    i: int128 = 0\n', '    j: int128 = 0\n', '    is_underlying: bool = False\n', '    i, j, is_underlying = Registry(_registry).get_coin_indices(_pool, _from, _to) # dev: no market\n', '\n', '    if is_underlying:\n', '        return CurvePool(_pool).get_dy_underlying(i, j, _amount)\n', '\n', '    return CurvePool(_pool).get_dy(i, j, _amount)\n', '\n', '\n', '@internal\n', 'def _exchange(\n', '    _registry: address,\n', '    _pool: address,\n', '    _from: address,\n', '    _to: address,\n', '    _amount: uint256,\n', '    _expected: uint256,\n', '    _sender: address,\n', '    _receiver: address,\n', ') -> uint256:\n', '\n', '    assert not self.is_killed\n', '\n', '    initial_balance: uint256 = 0\n', '    eth_amount: uint256 = 0\n', '    received_amount: uint256 = 0\n', '\n', '    i: int128 = 0\n', '    j: int128 = 0\n', '    is_underlying: bool = False\n', '    i, j, is_underlying = Registry(_registry).get_coin_indices(_pool, _from, _to)  # dev: no market\n', '\n', '    # record initial balance\n', '    if _to == ETH_ADDRESS:\n', '        initial_balance = self.balance\n', '    else:\n', '        initial_balance = ERC20(_to).balanceOf(self)\n', '\n', '    # perform / verify input transfer\n', '    if _from == ETH_ADDRESS:\n', '        eth_amount = _amount\n', '    else:\n', '        response: Bytes[32] = raw_call(\n', '            _from,\n', '            concat(\n', '                method_id("transferFrom(address,address,uint256)"),\n', '                convert(_sender, bytes32),\n', '                convert(self, bytes32),\n', '                convert(_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(response) != 0:\n', '            assert convert(response, bool)\n', '\n', '    # approve input token\n', '    if not self.is_approved[_from][_pool]:\n', '        response: Bytes[32] = raw_call(\n', '            _from,\n', '            concat(\n', '                method_id("approve(address,uint256)"),\n', '                convert(_pool, bytes32),\n', '                convert(MAX_UINT256, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(response) != 0:\n', '            assert convert(response, bool)\n', '        self.is_approved[_from][_pool] = True\n', '\n', '    # perform coin exchange\n', '    if is_underlying:\n', '        CurvePool(_pool).exchange_underlying(i, j, _amount, _expected, value=eth_amount)\n', '    else:\n', '        CurvePool(_pool).exchange(i, j, _amount, _expected, value=eth_amount)\n', '\n', '    # perform output transfer\n', '    if _to == ETH_ADDRESS:\n', '        received_amount = self.balance - initial_balance\n', '        raw_call(_receiver, b"", value=received_amount)\n', '    else:\n', '        received_amount = ERC20(_to).balanceOf(self) - initial_balance\n', '        response: Bytes[32] = raw_call(\n', '            _to,\n', '            concat(\n', '                method_id("transfer(address,uint256)"),\n', '                convert(_receiver, bytes32),\n', '                convert(received_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(response) != 0:\n', '            assert convert(response, bool)\n', '\n', '    log TokenExchange(_sender, _receiver, _pool, _from, _to, _amount, received_amount)\n', '\n', '    return received_amount\n', '\n', '\n', '@payable\n', '@external\n', '@nonreentrant("lock")\n', 'def exchange_with_best_rate(\n', '    _from: address,\n', '    _to: address,\n', '    _amount: uint256,\n', '    _expected: uint256,\n', '    _receiver: address = msg.sender,\n', ') -> uint256:\n', '    """\n', '    @notice Perform an exchange using the pool that offers the best rate\n', '    @dev Prior to calling this function, the caller must approve\n', '         this contract to transfer `_amount` coins from `_from`\n', '         Does NOT check rates in factory-deployed pools\n', '    @param _from Address of coin being sent\n', '    @param _to Address of coin being received\n', '    @param _amount Quantity of `_from` being sent\n', '    @param _expected Minimum quantity of `_from` received\n', '           in order for the transaction to succeed\n', '    @param _receiver Address to transfer the received tokens to\n', '    @return uint256 Amount received\n', '    """\n', '    if _from == ETH_ADDRESS:\n', '        assert _amount == msg.value, "Incorrect ETH amount"\n', '    else:\n', '        assert msg.value == 0, "Incorrect ETH amount"\n', '\n', '    registry: address = self.registry\n', '    best_pool: address = ZERO_ADDRESS\n', '    max_dy: uint256 = 0\n', '    for i in range(65536):\n', '        pool: address = Registry(registry).find_pool_for_coins(_from, _to, i)\n', '        if pool == ZERO_ADDRESS:\n', '            break\n', '        dy: uint256 = self._get_exchange_amount(registry, pool, _from, _to, _amount)\n', '        if dy > max_dy:\n', '            best_pool = pool\n', '            max_dy = dy\n', '\n', '    return self._exchange(registry, best_pool, _from, _to, _amount, _expected, msg.sender, _receiver)\n', '\n', '\n', '@payable\n', '@external\n', '@nonreentrant("lock")\n', 'def exchange(\n', '    _pool: address,\n', '    _from: address,\n', '    _to: address,\n', '    _amount: uint256,\n', '    _expected: uint256,\n', '    _receiver: address = msg.sender,\n', ') -> uint256:\n', '    """\n', '    @notice Perform an exchange using a specific pool\n', '    @dev Prior to calling this function, the caller must approve\n', '         this contract to transfer `_amount` coins from `_from`\n', '         Works for both regular and factory-deployed pools\n', '    @param _pool Address of the pool to use for the swap\n', '    @param _from Address of coin being sent\n', '    @param _to Address of coin being received\n', '    @param _amount Quantity of `_from` being sent\n', '    @param _expected Minimum quantity of `_from` received\n', '           in order for the transaction to succeed\n', '    @param _receiver Address to transfer the received tokens to\n', '    @return uint256 Amount received\n', '    """\n', '    if _from == ETH_ADDRESS:\n', '        assert _amount == msg.value, "Incorrect ETH amount"\n', '    else:\n', '        assert msg.value == 0, "Incorrect ETH amount"\n', '\n', '    registry: address = self.registry\n', '    if Registry(registry).get_lp_token(_pool) == ZERO_ADDRESS:\n', '        registry = self.factory_registry\n', '    return self._exchange(registry, _pool, _from, _to, _amount, _expected, msg.sender, _receiver)\n', '\n', '\n', '@view\n', '@external\n', 'def get_best_rate(_from: address, _to: address, _amount: uint256) -> (address, uint256):\n', '    """\n', '    @notice Find the pool offering the best rate for a given swap.\n', '    @dev Checks rates for regular and factory pools\n', '    @param _from Address of coin being sent\n', '    @param _to Address of coin being received\n', '    @param _amount Quantity of `_from` being sent\n', '    @return Pool address, amount received\n', '    """\n', '    best_pool: address = ZERO_ADDRESS\n', '    max_dy: uint256 = 0\n', '    for registry in [self.registry, self.factory_registry]:\n', '        for i in range(65536):\n', '            pool: address = Registry(registry).find_pool_for_coins(_from, _to, i)\n', '            if pool == ZERO_ADDRESS:\n', '                break\n', '\n', '            dy: uint256 = self._get_exchange_amount(registry, pool, _from, _to, _amount)\n', '            if dy > max_dy:\n', '                best_pool = pool\n', '                max_dy = dy\n', '\n', '    return best_pool, max_dy\n', '\n', '\n', '@view\n', '@external\n', 'def get_exchange_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\n', '    """\n', '    @notice Get the current number of coins received in an exchange\n', '    @dev Works for both regular and factory-deployed pools\n', '    @param _pool Pool address\n', '    @param _from Address of coin to be sent\n', '    @param _to Address of coin to be received\n', '    @param _amount Quantity of `_from` to be sent\n', '    @return Quantity of `_to` to be received\n', '    """\n', '    registry: address = self.registry\n', '    if Registry(registry).get_lp_token(_pool) == ZERO_ADDRESS:\n', '        registry = self.factory_registry\n', '    return self._get_exchange_amount(registry, _pool, _from, _to, _amount)\n', '\n', '\n', '@view\n', '@external\n', 'def get_input_amount(_pool: address, _from: address, _to: address, _amount: uint256) -> uint256:\n', '    """\n', '    @notice Get the current number of coins required to receive the given amount in an exchange\n', '    @param _pool Pool address\n', '    @param _from Address of coin to be sent\n', '    @param _to Address of coin to be received\n', '    @param _amount Quantity of `_to` to be received\n', '    @return Quantity of `_from` to be sent\n', '    """\n', '    registry: address = self.registry\n', '\n', '    i: int128 = 0\n', '    j: int128 = 0\n', '    is_underlying: bool = False\n', '    i, j, is_underlying = Registry(registry).get_coin_indices(_pool, _from, _to)\n', '    amp: uint256 = Registry(registry).get_A(_pool)\n', '    fee: uint256 = Registry(registry).get_fees(_pool)[0]\n', '\n', '    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    n_coins: uint256 = Registry(registry).get_n_coins(_pool)[convert(is_underlying, uint256)]\n', '    if is_underlying:\n', '        balances = Registry(registry).get_underlying_balances(_pool)\n', '        decimals = Registry(registry).get_underlying_decimals(_pool)\n', '        for x in range(MAX_COINS):\n', '            if x == n_coins:\n', '                break\n', '            rates[x] = 10**18\n', '    else:\n', '        balances = Registry(registry).get_balances(_pool)\n', '        decimals = Registry(registry).get_decimals(_pool)\n', '        rates = Registry(registry).get_rates(_pool)\n', '\n', '    for x in range(MAX_COINS):\n', '        if x == n_coins:\n', '            break\n', '        decimals[x] = 10 ** (18 - decimals[x])\n', '\n', '    calculator: address = self.pool_calculator[_pool]\n', '    if calculator == ZERO_ADDRESS:\n', '        calculator = self.default_calculator\n', '    return Calculator(calculator).get_dx(n_coins, balances, amp, fee, rates, decimals, i, j, _amount)\n', '\n', '\n', '@view\n', '@external\n', 'def get_exchange_amounts(\n', '    _pool: address,\n', '    _from: address,\n', '    _to: address,\n', '    _amounts: uint256[CALC_INPUT_SIZE]\n', ') -> uint256[CALC_INPUT_SIZE]:\n', '    """\n', '    @notice Get the current number of coins required to receive the given amount in an exchange\n', '    @param _pool Pool address\n', '    @param _from Address of coin to be sent\n', '    @param _to Address of coin to be received\n', '    @param _amounts Quantity of `_to` to be received\n', '    @return Quantity of `_from` to be sent\n', '    """\n', '    registry: address = self.registry\n', '\n', '    i: int128 = 0\n', '    j: int128 = 0\n', '    is_underlying: bool = False\n', '    balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    rates: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\n', '\n', '    amp: uint256 = Registry(registry).get_A(_pool)\n', '    fee: uint256 = Registry(registry).get_fees(_pool)[0]\n', '    i, j, is_underlying = Registry(registry).get_coin_indices(_pool, _from, _to)\n', '    n_coins: uint256 = Registry(registry).get_n_coins(_pool)[convert(is_underlying, uint256)]\n', '\n', '    if is_underlying:\n', '        balances = Registry(registry).get_underlying_balances(_pool)\n', '        decimals = Registry(registry).get_underlying_decimals(_pool)\n', '        for x in range(MAX_COINS):\n', '            if x == n_coins:\n', '                break\n', '            rates[x] = 10**18\n', '    else:\n', '        balances = Registry(registry).get_balances(_pool)\n', '        decimals = Registry(registry).get_decimals(_pool)\n', '        rates = Registry(registry).get_rates(_pool)\n', '\n', '    for x in range(MAX_COINS):\n', '        if x == n_coins:\n', '            break\n', '        decimals[x] = 10 ** (18 - decimals[x])\n', '\n', '    calculator: address = self.pool_calculator[_pool]\n', '    if calculator == ZERO_ADDRESS:\n', '        calculator = self.default_calculator\n', '    return Calculator(calculator).get_dy(n_coins, balances, amp, fee, rates, decimals, i, j, _amounts)\n', '\n', '\n', '@view\n', '@external\n', 'def get_calculator(_pool: address) -> address:\n', '    """\n', '    @notice Set calculator contract\n', '    @dev Used to calculate `get_dy` for a pool\n', '    @param _pool Pool address\n', '    @return `CurveCalc` address\n', '    """\n', '    calculator: address = self.pool_calculator[_pool]\n', '    if calculator == ZERO_ADDRESS:\n', '        return self.default_calculator\n', '    else:\n', '        return calculator\n', '\n', '\n', '@external\n', 'def update_registry_address() -> bool:\n', '    """\n', '    @notice Update registry address\n', '    @dev The registry address is kept in storage to reduce gas costs.\n', '         If a new registry is deployed this function should be called\n', '         to update the local address from the address provider.\n', '    @return bool success\n', '    """\n', '    address_provider: address = self.address_provider.address\n', '    self.registry = AddressProvider(address_provider).get_registry()\n', '    self.factory_registry = AddressProvider(address_provider).get_address(3)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def set_calculator(_pool: address, _calculator: address) -> bool:\n', '    """\n', '    @notice Set calculator contract\n', '    @dev Used to calculate `get_dy` for a pool\n', '    @param _pool Pool address\n', '    @param _calculator `CurveCalc` address\n', '    @return bool success\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '\n', '    self.pool_calculator[_pool] = _calculator\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def set_default_calculator(_calculator: address) -> bool:\n', '    """\n', '    @notice Set default calculator contract\n', '    @dev Used to calculate `get_dy` for a pool\n', '    @param _calculator `CurveCalc` address\n', '    @return bool success\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '\n', '    self.default_calculator = _calculator\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def claim_balance(_token: address) -> bool:\n', '    """\n', '    @notice Transfer an ERC20 or ETH balance held by this contract\n', '    @dev The entire balance is transferred to the owner\n', '    @param _token Token address\n', '    @return bool success\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '\n', '    if _token == ETH_ADDRESS:\n', '        raw_call(msg.sender, b"", value=self.balance)\n', '    else:\n', '        amount: uint256 = ERC20(_token).balanceOf(self)\n', '        response: Bytes[32] = raw_call(\n', '            _token,\n', '            concat(\n', '                method_id("transfer(address,uint256)"),\n', '                convert(msg.sender, bytes32),\n', '                convert(amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(response) != 0:\n', '            assert convert(response, bool)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def set_killed(_is_killed: bool) -> bool:\n', '    """\n', '    @notice Kill or unkill the contract\n', '    @param _is_killed Killed status of the contract\n', '    @return bool success\n', '    """\n', '    assert msg.sender == self.address_provider.admin()  # dev: admin-only function\n', '    self.is_killed = _is_killed\n', '\n', '    return True']