['pragma solidity ^0.6.12;\n', '\n', "import './TransferHelper.sol';\n", "import './SafeMath.sol';\n", '\n', 'contract TubeChief {\n', '    using SafeMath for uint;\n', '\n', '    uint constant DECIMAL = 18;\n', '    uint constant FARMER  = 750000000000000000;\n', '    uint constant DEV     = 100000000000000000;\n', '    uint constant LOTTERY = 150000000000000000;\n', '\n', '    struct PoolInfo {\n', '        address lpTokenAddress; // the LP token pair address\n', '        uint rewardPerBlock;    // number of TUBE will mint per block\n', '        uint lastBlockNo;       // record pool mint finish last block number\n', '        uint lastDevBlockNo;    // record token mint to development last block number\n', '        uint lastLotBlockNo;    // record token mint to lottery last block number\n', '        uint accLpStaked;       // accumulate number of LP token user staked\n', '        uint accLastBlockNo;    // record last pass in block number\n', '        uint multiplier;        // reward multiplier\n', '        uint accTokenPerShare;  // accumulated token per share\n', '        bool locked;            // pool is locked\n', '        bool finished;          // pool is stop mint token. disable deposit. only allow claim\n', '    }\n', '\n', '    struct UserPoolInfo {\n', '        uint lpStaked;       // user staked LP\n', '        uint rewardDebt;     // user debt\n', '        uint lastClaimBlock; // last block number user retrieve reward\n', '    }\n', '\n', '    mapping(uint => PoolInfo) public pools; // dynamic pool container (pool ID => pool related data)\n', '    mapping(address => uint[]) poolIdByLp;  // pool ids recorder (LP token => pool ids)\n', '\n', '    // user pool allocate (user addr => (<pool ID> => user pool data))\n', '    mapping(address => mapping(uint => UserPoolInfo)) public users;\n', '\n', '    address public owner;   // owner of tube chief\n', '    address public tube;    // the TUBE token\n', '    address public devaddr; // development address\n', '    address public lotaddr; // lottery address\n', '    uint public poolLength; // next pool id. current length is (poolLength - 1)\n', '\n', '    event CreatePool(address lpTokenAddress, uint rewardPerBlock, uint poolId);\n', '    event UpdatePool(uint poolId, uint rewardPerBlock, uint multiplier, bool locked);\n', '    event Claim(uint poolId, uint amount, uint claimable);\n', '    event TransferCompany(address old_owner, address new_owner);\n', '\n', '    modifier onlyOwner {\n', "        require(msg.sender == owner, 'NOT OWNER');\n", '        _;\n', '    }\n', '\n', '    constructor (address _tube, address _devaddr, address _lotaddr) public {\n', '        owner   = msg.sender;\n', '        tube    = _tube;\n', '        devaddr = _devaddr;\n', '        lotaddr = _lotaddr;\n', '    }\n', '\n', '    // create new pool. only owner executable\n', '    // XX do not create twice on same LP token. reward will mess up if you do\n', '    function createPool(address _lpTokenAddress, uint _rewardPerBlock, uint _multiplier) public onlyOwner {\n', "        require(_lpTokenAddress != address(0), 'CREATE_POOL_EMPTY_ADDRESS');\n", '\n', '        emit CreatePool(_lpTokenAddress, _rewardPerBlock, poolLength);\n', '        pools[poolLength].lpTokenAddress = _lpTokenAddress;\n', '        pools[poolLength].rewardPerBlock = _rewardPerBlock;\n', '        pools[poolLength].multiplier     = _multiplier;\n', '        pools[poolLength].accLastBlockNo = block.number;\n', '        pools[poolLength].lastDevBlockNo = block.number;\n', '        pools[poolLength].lastLotBlockNo = block.number;\n', '        poolIdByLp[_lpTokenAddress].push(poolLength);\n', '        poolLength = poolLength.add(1);\n', '    }\n', '\n', '    // update pool setting, edit wisely. only owner executable\n', '    function updatePool(uint poolId, uint _rewardPerBlock, uint _multiplier, bool _locked) public onlyOwner {\n', '        _updateAccTokenPerShare(poolId);\n', '        pools[poolId].rewardPerBlock = _rewardPerBlock;\n', '        pools[poolId].multiplier     = _multiplier;\n', '        pools[poolId].locked         = _locked;\n', '        emit UpdatePool(poolId, _rewardPerBlock, _multiplier, _locked);\n', '    }\n', '\n', '    // update development address. only owner executable\n', '    function updateDevAddr(address _address) public onlyOwner {\n', '        devaddr = _address;\n', '    }\n', '\n', '    // update lottery address. only owner executable\n', '    function updateLotAddr(address _address) public onlyOwner {\n', '        lotaddr = _address;\n', '    }\n', '\n', '    // set pool stop mint token. claim reward based on last block number recorded. only owner executable\n', '    function updatePoolFinish(uint poolId, bool _finished) public onlyOwner {\n', '        pools[poolId].finished    = _finished;\n', '        pools[poolId].lastBlockNo = _finished ? block.number : 0;\n', '    }\n', '\n', '    // stake LP token to earn TUBE\n', '    function stake(uint poolId, uint amount) public {\n', "        require(pools[poolId].lpTokenAddress != address(0), 'STAKE_POOL_NOT_EXIST');\n", "        require(pools[poolId].locked == false, 'STAKE_POOL_LOCKED');\n", "        require(pools[poolId].finished == false, 'STAKE_POOL_FINISHED');\n", '\n', '        claim(poolId, 0);\n', '        TransferHelper.safeTransferFrom(pools[poolId].lpTokenAddress, msg.sender, address(this), amount);\n', '        pools[poolId].accLpStaked = pools[poolId].accLpStaked.add(amount);\n', '        users[msg.sender][poolId].lpStaked       = users[msg.sender][poolId].lpStaked.add(amount);\n', '        users[msg.sender][poolId].lastClaimBlock = block.number;\n', '        users[msg.sender][poolId].rewardDebt     = pools[poolId].accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL);\n', '    }\n', '\n', '    // claim TUBE token. input LP token to exit pool\n', '    function claim(uint poolId, uint amount) public {\n', "        require(pools[poolId].lpTokenAddress != address(0), 'CLAIM_POOL_NOT_EXIST');\n", "        require(pools[poolId].locked == false, 'CLAIM_POOL_LOCKED');\n", '        \n', '        _updateAccTokenPerShare(poolId);\n', '\n', '        uint claimable = _getRewardAmount(poolId);\n', '        if (claimable > 0) {\n', '            ITubeToken(tube).farmMint(address(this), claimable);\n', '            TransferHelper.safeTransfer(tube, msg.sender, claimable);\n', '            users[msg.sender][poolId].lastClaimBlock = block.number;\n', '        }\n', '\n', '        if (amount > 0) {\n', '            TransferHelper.safeTransfer(pools[poolId].lpTokenAddress, msg.sender, amount);\n', '            users[msg.sender][poolId].lpStaked = users[msg.sender][poolId].lpStaked.sub(amount);\n', '            pools[poolId].accLpStaked = pools[poolId].accLpStaked.sub(amount);\n', '        }\n', '\n', '        // emit if necessary. cost saving\n', '        if (claimable > 0 || amount > 0) {\n', '            emit Claim(poolId, amount, claimable);\n', '        }\n', '\n', '        // update the user reward debt at this moment\n', '        users[msg.sender][poolId].rewardDebt = pools[poolId].accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL);\n', '    }\n', '\n', '    // get token per share with current block number\n', '    function getAccTokenInfo(uint poolId) public view returns (uint) {\n', '        if (pools[poolId].accLpStaked <= 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint reward_block = pools[poolId].rewardPerBlock;\n', '        uint multiplier   = pools[poolId].multiplier;\n', '        uint total_staked = pools[poolId].accLpStaked;\n', '        uint pending      = block.number.sub(pools[poolId].accLastBlockNo);\n', '        pending           = pending * 10**DECIMAL; // cast to "wei" unit\n', '        uint result       = reward_block.mul(multiplier, DECIMAL).mul(pending, DECIMAL).mul(FARMER, DECIMAL);\n', '\n', '        return result.div(total_staked, DECIMAL);\n', '    }\n', '\n', '    // emergency collect token from the contract. only owner executable\n', '    function emergencyCollectToken(address token, uint amount) public onlyOwner {\n', '        IERC20(token).transfer(owner, amount);\n', '    }\n', '\n', '    // emergency collect eth from the contract. only owner executable\n', '    function emergencyCollectEth(uint amount) public onlyOwner {\n', '        address payable owner_address = payable(owner);\n', '        owner_address.send(amount);\n', '    }\n', '\n', '    // transfer ownership. proceed wisely. only owner executable\n', '    function transferCompany(address new_owner) public onlyOwner {\n', '        owner = new_owner;\n', '        emit TransferCompany(owner, new_owner);\n', '    }\n', '\n', '    // transfer mintable token to development address\n', '    function transferDev(uint poolId) public onlyOwner {\n', '        uint mintable = getExMintable(poolId, true);\n', "        require(mintable > 0, 'TRANSFER_DEV_EMPTY');\n", '        ITubeToken(tube).farmMint(address(this), mintable);\n', '        TransferHelper.safeTransfer(tube, devaddr, mintable);\n', '        pools[poolId].lastDevBlockNo = block.number;\n', '    }\n', '\n', '    // transfer mintable token to lottery address\n', '    function transferLottery(uint poolId) public onlyOwner {\n', '        uint mintable = getExMintable(poolId, false);\n', "        require(mintable > 0, 'TRANSFER_LOT_EMPTY');\n", '        ITubeToken(tube).farmMint(address(this), mintable);\n', '        TransferHelper.safeTransfer(tube, lotaddr, mintable);\n', '        pools[poolId].lastLotBlockNo = block.number;\n', '    }\n', '\n', '    // retrieve the mintable amount for development or lottery\n', '    function getExMintable(uint poolId, bool is_dev) public view returns (uint) {\n', '        uint last_block   = 0;\n', '        uint rate         = 0;\n', '\n', '        if (is_dev) {\n', '            last_block = pools[poolId].lastDevBlockNo;\n', '            rate       = DEV;\n', '        } else {\n', '            last_block = pools[poolId].lastLotBlockNo;\n', '            rate       = LOTTERY;\n', '        }\n', '\n', '        uint block_diff = block.number.sub(last_block);\n', '        block_diff      = block_diff * 10**DECIMAL;\n', '\n', '        return block_diff.mul(pools[poolId].rewardPerBlock, DECIMAL).mul(pools[poolId].multiplier, DECIMAL).mul(rate, DECIMAL);\n', '    }\n', '\n', '    // retrieve pool ids by LP token address\n', '    function getPidByLpToken(address _lpTokenAddress) public view returns (uint[] memory) {\n', '        return poolIdByLp[_lpTokenAddress];\n', '    }\n', '\n', '    // retrieve user reward info on the pool with current block number\n', '    function getUserReward(uint poolId) public view returns (uint, uint, uint, uint, uint) {\n', '        uint accTokenPerShare = getAccTokenInfo(poolId);\n', '        accTokenPerShare      = accTokenPerShare.add(pools[poolId].accTokenPerShare);\n', '        \n', '        uint claimable = accTokenPerShare.mul(users[msg.sender][poolId].lpStaked, DECIMAL).sub(users[msg.sender][poolId].rewardDebt);\n', '        return (block.number, claimable, accTokenPerShare, users[msg.sender][poolId].lpStaked, users[msg.sender][poolId].rewardDebt);\n', '    }\n', '    \n', '    function _updateAccTokenPerShare(uint poolId) internal {\n', '        uint result = getAccTokenInfo(poolId);\n', '        pools[poolId].accTokenPerShare = pools[poolId].accTokenPerShare.add(result);\n', '        pools[poolId].accLastBlockNo   = block.number;\n', '    }\n', '\n', '    function _getRewardAmount(uint poolId) view internal returns (uint) {\n', '        if (pools[poolId].accLpStaked <= 0) {\n', '            return (0);\n', '        }\n', '\n', '        uint user_staked = users[msg.sender][poolId].lpStaked;\n', '        uint user_debt   = users[msg.sender][poolId].rewardDebt;\n', '        uint claimable   = pools[poolId].accTokenPerShare.mul(user_staked, DECIMAL).sub(user_debt);\n', '\n', '        return (claimable);\n', '    }\n', '\n', '    fallback() external payable {\n', '    }\n', '}\n', '\n', 'interface ITubeToken {\n', '    function farmMint(address _address, uint amount) external;\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '}']