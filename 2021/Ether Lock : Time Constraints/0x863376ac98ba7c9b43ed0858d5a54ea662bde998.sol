['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-14\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IMasks {\n', '    function ownerOf(uint256 tokenId) external returns (address);\n', '}\n', '\n', '\n', 'contract CosmoSwapBonus {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 private constant CosmoTokenRewardAmount = 1e22;\n', '    address public CosmoToken;\n', '    address public CosmoMasks;\n', '    address public CosmoMasksLimitedPack;\n', '    string public url = "https://CosmoSwap.space/";\n', '\n', '    mapping(address => mapping(uint256 => bool)) private _tokenRewarded;\n', '\n', '    event Rewarded(address indexed tokenOwner, uint256 indexed tokenId, uint256 indexed amount);\n', '\n', '\n', '    constructor(address cosmoToken, address cosmoMasks, address cosmoMasksLimitedPack) public {\n', '        CosmoToken = cosmoToken;\n', '        CosmoMasks = cosmoMasks;\n', '        CosmoMasksLimitedPack = cosmoMasksLimitedPack;\n', '    }\n', '\n', '    function isRewarded(address tokenAdress, uint256 tokenId) public view returns (bool) {\n', '        return _tokenRewarded[tokenAdress][tokenId];\n', '    }\n', '\n', '    function isTokenAddressRewarded(address tokenAdress) public view returns (bool) {\n', '        if (tokenAdress == CosmoMasks)\n', '            return true;\n', '        if (tokenAdress == CosmoMasksLimitedPack)\n', '            return true;\n', '        return false;\n', '    }\n', '\n', '    function claim(address tokenAdress, uint256 tokenId) public returns (uint256) {\n', '        address tokenOwner = _msgSender();\n', '        require(isTokenAddressRewarded(tokenAdress), "Unknown tokenAddress");\n', '        require(isRewarded(tokenAdress, tokenId) == false, "The reward has already been claimed");\n', '        require(IMasks(tokenAdress).ownerOf(tokenId) == tokenOwner, "Only the owner can claim the reward");\n', '\n', '        emit Rewarded(tokenOwner, tokenId, CosmoTokenRewardAmount);\n', '        _sendReward(tokenOwner, CosmoTokenRewardAmount);\n', '        _tokenRewarded[tokenAdress][tokenId] = true;\n', '        return CosmoTokenRewardAmount;\n', '    }\n', '\n', '    function claimMany(address tokenAdress, uint256[] memory tokenIds) public returns (uint256) {\n', '        address tokenOwner = _msgSender();\n', '        require(isTokenAddressRewarded(tokenAdress), "Unknown tokenAddress");\n', '\n', '        uint256 totalClaimed = 0;\n', '        for (uint256 i = 0; i < tokenIds.length; i++) {\n', '            // Duplicate token index check\n', '            for (uint256 j = i + 1; j < tokenIds.length; j++) {\n', '                require(tokenIds[i] != tokenIds[j], "Duplicate tokenId");\n', '            }\n', '\n', '            uint256 tokenId = tokenIds[i];\n', '            require(IMasks(tokenAdress).ownerOf(tokenId) == tokenOwner, "Only the token owner can claim the reward");\n', '\n', '            if (isRewarded(tokenAdress, tokenId) == false) {\n', '                totalClaimed = totalClaimed.add(CosmoTokenRewardAmount);\n', '                _tokenRewarded[tokenAdress][tokenId] = true;\n', '                emit Rewarded(tokenOwner, tokenId, CosmoTokenRewardAmount);\n', '            }\n', '        }\n', '\n', '        require(totalClaimed != 0, "No rewards");\n', '        _sendReward(tokenOwner, totalClaimed);\n', '        return totalClaimed;\n', '    }\n', '\n', '    function _sendReward(address tokenOwner, uint256 totalClaimed) internal {\n', '        require(IERC20(CosmoToken).transfer(tokenOwner, totalClaimed), "Reward transfer failed");\n', '    }\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '}']