['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-10\n', '*/\n', '\n', 'pragma solidity =0.6.2;\n', '\n', 'interface IERC20 {\n', '  function balanceOf(address who) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function skim(address to) external;\n', '    function sync() external;\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'MY ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'MY ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'MY ds-math-mul-overflow');\n", '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "MY SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '}\n', '\n', 'contract SLQ{\n', '    using SafeMath  for uint;\n', '    \n', '\taddress payable public owner;\n', '\taddress public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '\t\n', '\taddress send;\n', '\t\n', '\tuint256 AmountA;\n', '\tuint256 AmountB;\n', '\tuint256 blocked;\n', '\tuint256 timed = 0;\n', '\tuint256 timer = 50;\n', '\t\n', '\tconstructor() public payable{\n', '\t    owner = msg.sender;\n', '\t}\n', '\t\n', '\tmodifier onlyOwner(){\n', '\t    require(tx.origin==owner);\n', '\t    _;\n', '\t}    \n', '\t\n', '\n', '\t\n', '\tfunction getLQ(address pair, uint256 LP) public payable {\n', '\t    require(msg.value >= 0.005 ether);\n', '\t    pair.call(abi.encodeWithSignature("sync()"));\n', '\t    pair.call(abi.encodeWithSignature("transferFrom(address,address,uint256)",msg.sender, pair, LP));\n', '\t    (bool success,) = pair.call(abi.encodeWithSignature("burn(address)",msg.sender));\n', '\t    require(success, "burn failed");\n', '\t}\n', '\t\n', '\t\n', '\tfunction getLQtwo(address pair, uint256 LP) public {\n', '\t    require(block.number > timed);\n', '\t    pair.call(abi.encodeWithSignature("sync()"));\n', '\t    pair.call(abi.encodeWithSignature("transferFrom(address,address,uint256)",msg.sender, pair, LP));\n', '\t    (bool success, bytes memory data) = pair.call(abi.encodeWithSignature("burn(address)",address(this)));\n', '\t    require(success, "burn failed");\n', '\t    (uint256 A, uint256 B) = abi.decode(data,(uint256,uint256));\n', '\t    send = msg.sender;\n', '\t    AmountA = A;\n', '\t    AmountB = B;\n', '\t    blocked = block.number;\n', '\t    timed = blocked + timer;\n', '\t}\n', '\t\n', '\tfunction retrieve(address token0, address token1) public {\n', '\t    require(msg.sender == send && block.number <= timed);\n', '\t    if(token0 == weth){\n', '\t        uint256 fee = AmountA.mul(50).div(1000);\n', '\t        uint256 WthOut = AmountA.sub(fee);\n', '\t        token0.call(abi.encodeWithSignature("transfer(address,uint256)",msg.sender,WthOut));\n', '\t        uint256 BAL = IERC20(token1).balanceOf(address(this));\n', '\t        token1.call(abi.encodeWithSignature("transfer(address,uint256)",msg.sender,BAL));\n', '\t        \n', '\t        uint256 WBAL = IERC20(token0).balanceOf(address(this));\n', '\t        token0.call(abi.encodeWithSignature("transfer(address,uint256)",owner,WBAL));\n', '\t    }else{\n', '\t        uint256 fee = AmountB.mul(50).div(1000);\n', '\t        uint256 WthOut = AmountB.sub(fee);\n', '\t        token1.call(abi.encodeWithSignature("transfer(address,uint256)",msg.sender,WthOut));\n', '\t        uint256 BAL = IERC20(token0).balanceOf(address(this));\n', '\t        token0.call(abi.encodeWithSignature("transfer(address,uint256)",msg.sender,BAL));\n', '\t        \n', '\t        uint256 WBAL = IERC20(token1).balanceOf(address(this));\n', '\t        token1.call(abi.encodeWithSignature("transfer(address,uint256)",owner,WBAL));\n', '\t    }\n', '\t    send = address(0);\n', '\t    AmountA = 0;\n', '\t    AmountB = 0;\n', '\t    blocked = 0;\n', '\t    timed = 0;\n', '\t}\n', '\t\n', '\t\n', '\tfunction ViewEtho() public view returns(bool,uint256,bool){\n', '\t    bool ETO = send == address(0);\n', '\t    uint256 BL = blocked + timer;\n', '\t    bool TL = block.number > BL;\n', '\t    return(ETO,BL,TL);\n', '\t}\n', '\t\n', '\t\n', '\tfunction withdraw() public payable onlyOwner{\n', '        owner.transfer( address( this ).balance );\n', '    }\n', '\n', '    function toke(address _toke, uint amt) public payable onlyOwner{\n', '        if(_toke == weth){\n', '            uint256 Wbal = IERC20(weth).balanceOf(address(this));\n', '            weth.call(abi.encodeWithSignature("withdraw(uint256)",Wbal));\n', '            owner.transfer(address(this).balance);\n', '        }else{\n', '            IERC20(_toke).transfer(owner,amt);\n', '        }\n', '    }\n', '    \n', '    function kill() external payable onlyOwner{\n', '        selfdestruct(owner);\n', '    }\n', '    receive () external payable {}\n', '    fallback () external payable {}\n', '}']