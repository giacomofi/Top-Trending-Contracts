['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.7.4;\n', '\n', 'import "./IERC677.sol";\n', 'import "./IOffchainAggregator.sol";\n', 'import "./Sweeper.sol";\n', '\n', '/**\n', ' * @title OffchainAggregatorSweeper\n', ' * @dev Handles withdrawing of rewards from OCR Chainlink contracts.\n', ' */\n', 'contract OffchainAggregatorSweeper is Sweeper {\n', '    IERC677 public token;\n', '    address public transmitter;\n', '\n', '    constructor(\n', '        address _nodeRewards,\n', '        uint256 _minToWithdraw,\n', '        address _transmitter,\n', '        address _token\n', '    ) Sweeper(_nodeRewards, _minToWithdraw) {\n', '        transmitter = _transmitter;\n', '        token = IERC677(_token);\n', '    }\n', '\n', '    /**\n', '     * @dev returns withdrawable amount for each offchain aggregator\n', '     * @return withdrawable balance of each offchain aggregator\n', '     **/\n', '    function withdrawable() external view override returns (uint256[] memory) {\n', '        uint256[] memory _withdrawable = new uint256[](contracts.length);\n', '        for (uint i = 0; i < contracts.length; i++) {\n', '            _withdrawable[i] = IOffchainAggregator(contracts[i]).owedPayment(transmitter);\n', '        }\n', '        return _withdrawable;\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw rewards from offchain aggregators\n', '     * @param _contractIdxs indexes corresponding to the offchain aggregators\n', '     **/\n', '    function _withdraw(uint256[] calldata _contractIdxs) internal override {\n', '        for (uint i = 0; i < _contractIdxs.length; i++) {\n', '            require(_contractIdxs[i] < contracts.length, "contractIdx must be < contracts length");\n', '            IOffchainAggregator aggregator = IOffchainAggregator(contracts[_contractIdxs[i]]);\n', '            if (aggregator.owedPayment(transmitter) >= minToWithdraw) {\n', '                aggregator.withdrawPayment(transmitter);\n', '            }\n', '        }\n', '        if (token.balanceOf(address(this)) > 0) {\n', '            token.transfer(nodeRewards, token.balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev transfers admin to new address for selected offchain aggregators\n', '     * @param _contractIdxs indexes corresponsing to offchain aggregators\n', '     * @param _newAdmin address to transfer admin to\n', '     **/\n', '    function _transferAdmin(uint256[] calldata _contractIdxs, address _newAdmin) internal override {\n', '        for (uint i = 0; i < _contractIdxs.length; i++) {\n', '            require(_contractIdxs[i] < contracts.length, "contractIdx must be < contracts length");\n', '            IOffchainAggregator(contracts[_contractIdxs[i]]).transferPayeeship(transmitter, _newAdmin);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev accepts payeeship for offchain aggregators\n', '     * @param _contractIdxs indexes corresponding to the offchain aggregators\n', '     **/\n', '    function _acceptAdmin(uint256[] calldata _contractIdxs) internal override {\n', '        for (uint i = 0; i < _contractIdxs.length; i++) {\n', '            require(_contractIdxs[i] < contracts.length, "contractIdx must be < contracts length");\n', '            IOffchainAggregator(contracts[_contractIdxs[i]]).acceptPayeeship(transmitter);\n', '        }\n', '    }\n', '}']