['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ERC20.sol";\n', 'import "./SafeMath.sol";\n', '\n', '\n', 'contract KtlyoStaking {\n', '\n', '    address public token1;\n', '\taddress public token2;\n', '\tuint256 public apy;\n', '\tuint256 public duration;\n', '\tuint256 public maxStakeAmt1;\n', '\tuint256 public maxStakeAmt2;\n', '    uint256 private interestRate;\n', '\tuint256 private tokenRatio;\n', '\tuint256 public rewardAmt1;\n', '\tuint256 public rewardAmt2;\n', '\tuint256 private amtRewardRemainingBalance1;\n', '\tuint256 private amtRewardRemainingBalance2;\n', '\tuint256 private totalStaked1;\n', '\tuint256 private totalStaked2;\n', '\tuint256 private totalRedeemed1;\n', '\tuint256 private totalRedeemed2;\n', '\tuint256 private openRewards1;\n', '\tuint256 private openRewards2;\n', '\taddress public owner;\n', '    uint256 public createdAt;\n', '\tuint256 private daysInYear;\n', '\tuint256 private secondsInYear;\n', '\tuint256 private precision = 1000000000000000000;\n', '\tbool private stakingStarted;\n', '\tstruct Transaction { \n', '\t\taddress wallet;\n', '\t\taddress token;\n', '\t\tuint256 amount;\n', '\t\tuint256 createdAt;\n', '\t\tbool redeemed;\n', '\t\tuint256 rewardAmt1;\n', '\t\tuint256 rewardAmt2;\n', '\t\tuint256 redeemedAt;\n', '\t\tuint256 stakeEnd;\n', '\t}\n', '\tmapping(address => Transaction[]) transactions;\n', '\t\n', '\tstruct MaxLimit { \n', '\t\tuint256 limit1;\n', '\t\tuint256 limit2;\n', '\t}\n', '\t\n', '\tmapping(address => bool) blackListed;\n', '\tmapping(address => MaxLimit) limits;\n', '\t\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address _token1,\n', '\t\taddress _token2,\n', '\t\tuint256 _apy,\n', '\t\tuint256 _duration,\n', '\t\tuint256 _tokenRatio,\n', '\t\tuint256 _maxStakeAmt1,\n', '\t\tuint256 _rewardAmt1,\n', '        address _owner\n', '\t\t\n', '    ) {\n', '        token1 = _token1;\n', '\t\ttoken2 = _token2;\n', '\t\tapy = _apy;\n', '\t\tduration = _duration;\n', '\t\ttokenRatio = _tokenRatio;\n', '\t\tmaxStakeAmt1 = _maxStakeAmt1;\n', '\t\tmaxStakeAmt2 = SafeMath.div(SafeMath.mul(maxStakeAmt1,tokenRatio),precision);\n', '\t\trewardAmt1 = _rewardAmt1;\n', '\t\trewardAmt2 = SafeMath.div(SafeMath.mul(rewardAmt1,tokenRatio),precision);\n', '        owner = _owner;\n', '        createdAt = block.timestamp;\n', '\t\tstakingStarted = false;\n', '\t\tdaysInYear = uint256(365);\n', '\t\tsecondsInYear = daysInYear*24*60*60;\n', '\t\tinterestRate = SafeMath.div(SafeMath.div(SafeMath.mul(apy,duration),secondsInYear),100);\n', '\t\temit CreatedContract(token1,token2,apy,duration,maxStakeAmt1,maxStakeAmt2, rewardAmt1,rewardAmt2,msg.sender,block.timestamp,interestRate,tokenRatio);\n', '\t\t\n', '\t\t\n', '    }\n', '\t\n', '\t// return ETH\n', '    receive() external payable {\n', '\t\t\n', '        emit Reverted(msg.sender, msg.value);\n', '\t\trevert("ETH is not accepted");\n', '    }\n', '\t\n', '    // return ETH\n', '    fallback() external payable { \n', '      \n', '\t   emit Reverted(msg.sender, msg.value);\n', '\t   revert("ETH is not accepted");\n', '    }\n', '\t\n', '\t// callable by owner only\n', '    function activate() onlyOwner public {\n', '      \n', '\t\t//check for rewards\n', '\t\tERC20 tokenOne = ERC20(token1);\n', '\t\tERC20 tokenTwo = ERC20(token2);\n', '\t\tuint256 tenPerc=10;\n', '\t\tuint256 balanceForToken1= tokenOne.balanceOf(address(this));\n', '\t\tuint256 balanceForToken2= tokenTwo.balanceOf(address(this));\n', '\t\tuint256 token1CheckAmount;\n', '\t\tuint256 token2CheckAmount;\n', '\t\tuint256 rewardBalance1;\n', '\t\tuint256 rewardBalance2;\n', '\t\t\n', '\t\ttoken1CheckAmount = SafeMath.sub(balanceForToken1,totalStaked1);\n', '\t\ttoken2CheckAmount = SafeMath.sub(balanceForToken2,totalStaked2);\n', '\t\t\n', '\t\trewardBalance1 = SafeMath.sub(SafeMath.sub(rewardAmt1,totalRedeemed1),openRewards1);\n', '\t\trewardBalance2 = SafeMath.sub(SafeMath.sub(rewardAmt2,totalRedeemed2),openRewards2);\n', '\t\t\n', '\t\trequire (token1CheckAmount>=SafeMath.div(rewardBalance1,tenPerc),"Activation error. Insufficient balance of rewards for token1");\n', '\t\trequire (token2CheckAmount>=SafeMath.div(rewardBalance2,tenPerc),"Activation error. Insufficient balance of rewards for token2");\n', '\t\t//activate staking\n', '\t\tstakingStarted = true;\n', '\t\temit StartStaking(msg.sender,block.timestamp);\n', '    }\n', '\t\n', '\t// callable by owner only\n', '    function deActivate() onlyOwner public {\n', '      \n', '\t\t\n', '\t\t//de-activate staking\n', '\t\tstakingStarted = false;\n', '\t\temit StopStaking(msg.sender,block.timestamp);\n', '    }\n', '\t\n', '\t// callable by owner only\n', '    function blackList(address[] memory addressList,bool blStatus) onlyOwner public {\n', '\t\t\n', '\t\tuint256 i;\n', '\t\t\n', '\t\tfor (i=0;i<addressList.length;i++)\n', '\t\t{\n', '\t\t\tblackListed[addressList[i]]=blStatus;\n', '\t\t}\n', '\t\tif (blStatus) emit AddedToBlackList(msg.sender,block.timestamp);\n', '\t\telse emit RemovedFromBlackList(msg.sender,block.timestamp);\n', '    }\n', '\t\n', '\t\n', '\t// function to stake\n', '    function stake(address tokenContract, uint256 amt) public {\n', '       \n', '\t   uint256 amount_reward1;\n', '\t   uint256 amount_reward2;\n', '\t   uint256 limit1;\n', '\t   uint256 limit2;\n', '\t   \n', '\t   require(stakingStarted,"Staking not active");\n', '\t   require(rewardAmt1>SafeMath.add(totalRedeemed1,openRewards1) && rewardAmt2>SafeMath.add(totalRedeemed2,openRewards2),"Rewards are spent. Staking contract is closed.");\n', '\t   require(amtRewardRemainingBalance1 > 0 && amtRewardRemainingBalance2 > 0,"Staking rewards are 0");\n', '\t   require(tokenContract==token1 || tokenContract==token2,"Invalid token contract");\n', '\t   \n', '\t   limit1 = limits[msg.sender].limit1;\n', '\t   limit2 = limits[msg.sender].limit2;\n', '\t   \n', '\t   if (token1==tokenContract) \n', '\t   {\n', '\t    \n', '\t\tif (SafeMath.add(amt,limit1)>maxStakeAmt1) amt = SafeMath.sub(maxStakeAmt1,limit1);\n', '\t\tlimits[msg.sender].limit1 = SafeMath.add(limits[msg.sender].limit1,amt);\n', '\t\tamount_reward1 = SafeMath.div(SafeMath.mul(amt,interestRate),precision);\n', '\t\tif (amtRewardRemainingBalance1<amount_reward1)\n', '\t    {\n', '\t\t\tamount_reward1 = amtRewardRemainingBalance1;\n', '\t\t\tamt = SafeMath.div(SafeMath.mul(amount_reward1,precision),interestRate);\n', '\t    }\n', '\t\t\n', '\t\tamount_reward2 = SafeMath.div(SafeMath.mul(amount_reward1,tokenRatio),precision);\n', '\t\ttotalStaked1+=amt;\n', '\t   }\n', '\t   \n', '\t   if (token2==tokenContract) \n', '\t   {\n', '\t\tif (amt+limit2>maxStakeAmt2) amt = SafeMath.sub(maxStakeAmt2,limit2);\n', '\t\t\n', '\t\tlimits[msg.sender].limit2 = SafeMath.add(limits[msg.sender].limit2, amt);\n', '\t\t\n', '\t\tamount_reward2 = SafeMath.div(SafeMath.mul(amt,interestRate),precision);\n', '\t\t\n', '\t\tif (amtRewardRemainingBalance2<amount_reward2)\n', '\t    {\n', '\t\t\tamount_reward2 = amtRewardRemainingBalance2;\n', '\t\t\tamt = SafeMath.div(SafeMath.mul(amount_reward2,precision),interestRate);\n', '\t    }\n', '\t\tamount_reward1 = SafeMath.div(SafeMath.mul(amount_reward2,precision),tokenRatio);\n', '\t\ttotalStaked2+=amt;\n', '\t   }\n', '\t   \n', '\t   require(amt>0,"Amount is equal to 0");\n', '\t   \n', '\t   \n', '\t   amtRewardRemainingBalance1 = SafeMath.sub(amtRewardRemainingBalance1, amount_reward1,"Insufficient rewards balance for token 1");\n', '\t   amtRewardRemainingBalance2 = SafeMath.sub(amtRewardRemainingBalance2, amount_reward2,"Insufficient rewards balance for token 2");\n', '\t   \n', '\t   ERC20 tokenERC20 = ERC20(tokenContract);\n', '\t   //transfer token\n', '\t   require(tokenERC20.transferFrom(msg.sender, address(this), amt),"Token transfer for staking not approved!");\n', '\t   \n', '\t   //create transaction\n', '\t   Transaction memory trx = Transaction(\n', '\t   {\n', '\t\t   wallet : msg.sender,\n', '\t\t   token : tokenContract,\n', '\t\t   amount : amt,\n', '\t\t   createdAt:block.timestamp,\n', '\t\t   redeemed : false,\n', '\t\t   rewardAmt1 : amount_reward1,\n', '\t\t   rewardAmt2 : amount_reward2,\n', '\t\t   stakeEnd: SafeMath.add(block.timestamp,duration),\n', '\t\t   redeemedAt : 0\n', '\t   });\n', '\t   openRewards1+=amount_reward1;\n', '\t   openRewards2+=amount_reward2;\n', '\t   transactions[msg.sender].push(trx);\n', '\t   \n', '\t   emit Staked(msg.sender,tokenContract, amt);\n', '    }\n', '\tfunction redeemTrx(address requestor, uint256 indexId) \n', '\tinternal \n', '\treturns (uint256 returnAmount, uint256 returnAmount2) \n', '\t{\n', '\t   \n', '\t    \n', '\t\t\n', '\t\tif (transactions[requestor][indexId].token==token1)\n', '\t\t{\n', '\t\t\treturnAmount = transactions[requestor][indexId].amount;\n', '\t\t\tif (transactions[requestor][indexId].stakeEnd < block.timestamp && blackListed[requestor]!=true)\n', '\t\t\t{\n', '\t\t\t\treturnAmount = SafeMath.add(returnAmount,transactions[requestor][indexId].rewardAmt1);\n', '\t\t\t\treturnAmount2 = transactions[requestor][indexId].rewardAmt2;\n', '\t\t\t}\n', '\t\t\tlimits[requestor].limit1-=transactions[requestor][indexId].amount;\n', '\t\t}else\n', '\t\t{\n', '\t\t\t\n', '\t\t\treturnAmount2 = transactions[requestor][indexId].amount;\n', '\t\t\tif (transactions[requestor][indexId].stakeEnd < block.timestamp && blackListed[requestor]!=true)\n', '\t\t\t{\n', '\t\t\t\treturnAmount2 = SafeMath.add(returnAmount2,transactions[requestor][indexId].rewardAmt2);\n', '\t\t\t\treturnAmount = transactions[requestor][indexId].rewardAmt1;\n', '\t\t\t}\n', '\t\t\tlimits[requestor].limit2-=transactions[requestor][indexId].amount;\n', '\t\t\t\n', '\t\t}\n', '\t\t\n', '\t\ttransactions[requestor][indexId].redeemed = true;\n', '\t\ttransactions[requestor][indexId].redeemedAt = block.timestamp;\n', '\t\topenRewards1-=transactions[requestor][indexId].rewardAmt1;\n', '\t\topenRewards2-=transactions[requestor][indexId].rewardAmt2;\n', '\t\treturn (returnAmount,returnAmount2);\n', '\t  \n', '\t   \n', '    }\n', '\tfunction redeem(uint256 indexId) public {\n', '\t   uint256 returnAmount;\n', '\t   uint256 returnAmount2;\n', '\t   require(transactions[msg.sender][indexId].redeemed==false && transactions[msg.sender][indexId].stakeEnd<block.timestamp ,"Stake is already redeemed or end_date not reached");\n', '\t   \n', '\t   (returnAmount,returnAmount2) = redeemTrx(msg.sender,indexId);\n', '\t   ERC20 tokenERC20 = ERC20(token1);\n', '\t   ERC20 tokenERC20t2 = ERC20(token2);\n', '\t   if (returnAmount>0) tokenERC20.transfer(msg.sender, returnAmount);\n', '\t   if (returnAmount2>0) tokenERC20t2.transfer(msg.sender, returnAmount2);\n', '\t   if (transactions[msg.sender][indexId].token==token1) totalStaked1-=transactions[msg.sender][indexId].amount;\n', '\t   else totalStaked2-=transactions[msg.sender][indexId].amount;\n', '\t   totalRedeemed1+=transactions[msg.sender][indexId].rewardAmt1;\n', '       totalRedeemed2+=transactions[msg.sender][indexId].rewardAmt2;\n', '\t   emit Redeemed(msg.sender,block.timestamp, returnAmount,returnAmount2);\n', '    }\n', '\t\n', '\tfunction redeemAll() public {\n', '\t\t//check if available to redeem and transfer if available\n', '\t\tuint256 returnAmount;\n', '\t\tuint256 returnAmount2;\n', '\t\tuint256 returnAmountTotal;\n', '\t\tuint256 returnAmountTotal2;\n', '\t\tuint256 i;\n', '\t\tERC20 tokenERC20t2;\n', '\t\tERC20 tokenERC20;\n', '\t\treturnAmountTotal = 0;\n', '\t\treturnAmountTotal2 = 0;\n', '\t   \n', '\t\tfor (i=0;i<transactions[msg.sender].length;i++)\n', '\t\t{\n', '\t\t\tif (transactions[msg.sender][i].redeemed==false && transactions[msg.sender][i].stakeEnd<block.timestamp)\n', '\t\t\t{\n', '\t\t\t\t(returnAmount,returnAmount2) = redeemTrx(msg.sender,i);\n', '\t\t\t\t\n', '\t\t\t\treturnAmountTotal = returnAmountTotal + returnAmount;\n', '\t\t\t\treturnAmountTotal2 = returnAmountTotal2 + returnAmount2;\n', '\t\t\t\tif (transactions[msg.sender][i].token==token1) \n', '\t\t\t    {\n', '\t\t\t\t totalStaked1-=transactions[msg.sender][i].amount;\n', '\t\t\t\t totalRedeemed1+=transactions[msg.sender][i].rewardAmt1; \n', '\t\t\t    }\n', '\t\t\t    else\n', '\t\t\t    {\n', '\t\t\t\t totalStaked2-=transactions[msg.sender][i].amount;\n', '\t\t\t\t totalRedeemed2+=transactions[msg.sender][i].rewardAmt2;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\ttokenERC20 = ERC20(token1);\n', '\t\tif (returnAmountTotal>0) tokenERC20.transfer(msg.sender, returnAmountTotal);\n', '\t\ttokenERC20t2 = ERC20(token2);\n', '\t\tif (returnAmountTotal2>0) tokenERC20t2.transfer(msg.sender, returnAmountTotal2);\n', '\t\temit RedeemedAll(msg.sender,block.timestamp, returnAmountTotal,returnAmountTotal2);\n', '\t   \n', '    }\n', '\t\n', '\tfunction redeemEarly(uint256 indexId) public {\n', '\t\n', '       uint256 returnAmount;\n', '\t   uint256 returnAmount2;\n', '\t   \n', '\t   require(transactions[msg.sender][indexId].redeemed==false,"Stake is already redeemed");\n', '\t   \n', '\t   (returnAmount,returnAmount2) = redeemTrx(msg.sender,indexId);\n', '\t   \n', '\t   if (transactions[msg.sender][indexId].stakeEnd>block.timestamp)\n', '\t   {\n', '\t\t   amtRewardRemainingBalance1 = SafeMath.add(amtRewardRemainingBalance1, transactions[msg.sender][indexId].rewardAmt1);\n', '\t\t   amtRewardRemainingBalance2 = SafeMath.add(amtRewardRemainingBalance2, transactions[msg.sender][indexId].rewardAmt2);\n', '\t\t   \n', '\t\t   if (transactions[msg.sender][indexId].token==token1) totalStaked1-=transactions[msg.sender][indexId].amount;\n', '\t\t   else \n', '\t\t   {\n', '\t\t\ttotalStaked2-=transactions[msg.sender][indexId].amount;\n', '\t\t\treturnAmount = returnAmount2;\n', '\t\t   }\n', '\t\t   \n', '\t\t   ERC20 tokenERC20 = ERC20(transactions[msg.sender][indexId].token);\n', '\t\t   if (returnAmount>0) tokenERC20.transfer(msg.sender, returnAmount);\n', '\t\t   emit EarlyRedeemed(msg.sender,block.timestamp, returnAmount);\n', '\t   }else{\n', '\t\t\n', '\t\t\tERC20 tokenERC20 = ERC20(token1);\n', '\t\t\tERC20 tokenERC20t2 = ERC20(token2);\n', '\t\t\tif (returnAmount>0) tokenERC20.transfer(msg.sender, returnAmount);\n', '\t\t\tif (returnAmount2>0) tokenERC20t2.transfer(msg.sender, returnAmount2);\n', '\t\t\tif (transactions[msg.sender][indexId].token==token1) totalStaked1-=transactions[msg.sender][indexId].amount;\n', '\t\t\telse totalStaked2-=transactions[msg.sender][indexId].amount;\n', '\t\t\ttotalRedeemed1+=transactions[msg.sender][indexId].rewardAmt1;\n', '\t\t\ttotalRedeemed2+=transactions[msg.sender][indexId].rewardAmt2;\n', '\t\t\temit Redeemed(msg.sender,block.timestamp, returnAmount,returnAmount2);\n', '\t   }\n', '    }\n', '\t\n', '\tfunction redeemEarlyAll() public {\n', '\t   //check if available to redeem and transfer if available\n', '       uint256 returnAmount;\n', '\t   uint256 returnAmount2;\n', '\t   uint256 returnAmountTotal;\n', '\t   uint256 returnAmountTotal2;\n', '\t   uint i;\n', '\t   ERC20 tokenERC20t2;\n', '\t   ERC20 tokenERC20;\n', '\t  \n', '\t   for (i=0;i<transactions[msg.sender].length;i++)\n', '\t   {\n', '\t\t\tif (transactions[msg.sender][i].redeemed==false)\n', '\t\t\t{\n', '\t\t\t\t(returnAmount,returnAmount2) = redeemTrx(msg.sender,i);\n', '\t\t\t\t\n', '\t\t\t\treturnAmountTotal+= returnAmount;\n', '\t\t\t\treturnAmountTotal2+= returnAmount2;\n', '\t\t\t\t\n', '\t\t\t\tif (transactions[msg.sender][i].stakeEnd>block.timestamp)\n', '\t\t\t\t{\n', '\t\t\t\t\tif (transactions[msg.sender][i].token==token1) totalStaked1-=transactions[msg.sender][i].amount;\n', '\t\t\t\t\telse totalStaked2-=transactions[msg.sender][i].amount;\n', '\t\t\t\t\n', '\t\t\t\t}else{\n', '\t\t\t\t\t\n', '\t\t\t\t\tif (transactions[msg.sender][i].token==token1) \n', '\t\t\t\t\t{\n', '\t\t\t\t\t totalStaked1-=transactions[msg.sender][i].amount;\n', '\t\t\t\t\t totalRedeemed1+=transactions[msg.sender][i].rewardAmt1; \n', '\t\t\t\t\t}\n', '\t\t\t\t\telse\n', '\t\t\t\t\t{\n', '\t\t\t\t\t totalStaked2-=transactions[msg.sender][i].amount;\n', '\t\t\t\t\t totalRedeemed2+=transactions[msg.sender][i].rewardAmt2;\n', '\t\t\t\t\t}\n', '\t\t\t\t\t\n', '\t\t\t\t}\n', '\t\t\t\t\n', '\t\t\t\t\n', '\t\t\t}\n', '\t   }\n', '\t   \n', '\t    tokenERC20 = ERC20(token1);\n', '\t\tif (returnAmountTotal>0) tokenERC20.transfer(msg.sender, returnAmountTotal);\n', '\t\ttokenERC20t2 = ERC20(token2);\n', '\t\tif (returnAmountTotal2>0) tokenERC20t2.transfer(msg.sender, returnAmountTotal2);\n', '\t   \n', '\t   emit EarlyRedeemedAll(msg.sender,block.timestamp, returnAmountTotal,returnAmountTotal2);\n', '\t\t\n', '    }\n', '\t\n', '\tfunction transferReward(address token, uint256 reward_amount) public {\n', '\t\n', '\t   require(reward_amount>0,"Reward amount is 0");\n', '\t   \n', '\t   ERC20 tokenERC20 = ERC20(token);\n', '\t   //uint256 allowance = tokenERC20.allowance(msg.sender,address(this));\n', '\t   //require(allowance>=reward_amount,"Transfer not approved!");\n', '\t   tokenERC20.transferFrom(msg.sender,address(this), reward_amount);\n', '\t   if (token==token1) amtRewardRemainingBalance1 = SafeMath.add(amtRewardRemainingBalance1, reward_amount);\n', '\t   if (token==token2) amtRewardRemainingBalance2 = SafeMath.add(amtRewardRemainingBalance2, reward_amount);\n', '\t  \n', '\t   emit TransferReward(msg.sender,block.timestamp, reward_amount);\n', '    }\n', '\t\n', '\tfunction transferBackReward(address token, uint256 reward_amount) onlyOwner public {\n', '\t\n', '\t   require(reward_amount>0 && stakingStarted==false,"Reward amount is 0 or staking is activated");\n', '\t   require(openRewards1==0 && openRewards2==0,"There are open rewards");\n', '\t   \n', '\t   ERC20 tokenERC20 = ERC20(token);\n', '\t  \n', '\t   if (token==token1) \n', '\t   {\n', '\t\tif (reward_amount>SafeMath.sub(amtRewardRemainingBalance1, openRewards1)) reward_amount = SafeMath.sub(amtRewardRemainingBalance1, openRewards1);\n', '\t\tamtRewardRemainingBalance1 = SafeMath.sub(amtRewardRemainingBalance1, reward_amount);\n', '\t\t\n', '\t   }\n', '\t   if (token==token2) \n', '\t   {\n', '\t\tif (reward_amount>SafeMath.sub(amtRewardRemainingBalance2, openRewards2)) reward_amount = SafeMath.sub(amtRewardRemainingBalance2, openRewards2);\n', '\t    amtRewardRemainingBalance2 = SafeMath.sub(amtRewardRemainingBalance2, reward_amount);\n', '\t   }\n', '\t   tokenERC20.transfer(msg.sender, reward_amount);\n', '\t   \n', '\t   emit TransferBackReward(msg.sender,block.timestamp, reward_amount);\n', '    }\n', '\t\n', '    \n', '    function info() public view returns(address,uint256,uint256,uint256,uint256,uint256,uint256){\n', '        return (owner,createdAt,apy,duration,rewardAmt1,interestRate,tokenRatio);\n', '    }\n', '\tfunction getRewardsInfo() public view returns(address,address,uint256,uint256,uint256,uint256){ \n', '        return (token1,token2,rewardAmt1,rewardAmt2,amtRewardRemainingBalance1,amtRewardRemainingBalance2);\n', '    }\n', '\tfunction getStakeRewardAmounts() public view returns(uint256,uint256,uint256,uint256,uint256,uint256){ \n', '        return (totalStaked1,totalStaked2,openRewards1,openRewards2,maxStakeAmt1,maxStakeAmt2);\n', '    }\n', '\tfunction getMyInfo() public view returns(Transaction [] memory,MaxLimit memory){ \n', '        return (transactions[msg.sender],limits[msg.sender]);\n', '    }\n', '\tfunction getMyStakings() public view returns(Transaction [] memory){ \n', '        return (transactions[msg.sender]);\n', '    }\n', '\tfunction getStakings(address wallet) public view onlyOwner returns(Transaction [] memory){ \n', '        return (transactions[wallet]);\n', '    }\n', '\tfunction getMyLimits() public view returns(MaxLimit memory){ \n', '        return (limits[msg.sender]);\n', '    }\n', '\tfunction getBlackListedStatus(address wallet) public view returns(bool){ \n', '        \n', '\t\treturn (blackListed[wallet]);\n', '    }\n', '\t\n', '\tevent CreatedContract(address token1,address token2,uint256 apy,uint256 duration,uint256 maxStakeAmt1, uint256 maxStakeAmt2, uint256 rewardAmt1,uint256 rewardAmt2,address owner,uint256 createdAt,uint256 interestRate,uint256 tokenRatio);\n', '    event Received(address from, uint256 amount);\n', '\tevent Reverted(address from, uint256 amount);\n', '\tevent StartStaking(address from,uint256 startDate);\n', '\tevent StopStaking(address from,uint256 stopDate);\n', '\tevent Staked(address from,address tokenCtr,uint256 amount);\n', '\tevent EarlyRedeemed(address to,uint256 redeemedDate,uint256 amount);\n', '\tevent EarlyRedeemedAll(address to,uint256 redeemedDate,uint256 amount1,uint256 amount2);\n', '\tevent Redeemed(address to,uint256 redeemedDate,uint256 amount1,uint256 amount2);\n', '\tevent RedeemedAll(address to,uint256 redeemedDate,uint256 amount1,uint256 amount2);\n', '\tevent TransferReward(address from,uint256 sentDate,uint256 amount);\n', '\tevent TransferBackReward(address to,uint256 sentDate,uint256 amount);\n', '\tevent AddedToBlackList(address from, uint256 sentDate);\n', '\tevent RemovedFromBlackList(address from, uint256 sentDate);\n', '}']