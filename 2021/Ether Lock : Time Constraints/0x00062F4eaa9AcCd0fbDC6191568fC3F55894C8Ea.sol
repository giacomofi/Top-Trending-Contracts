['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../vendors/libraries/SafeMath.sol";\n', 'import "../vendors/libraries/SafeERC20.sol";\n', 'import "../vendors/interfaces/IERC20.sol";\n', 'import "./UsersStorage.sol";\n', 'import "./StagesStorage.sol";\n', '\n', 'abstract contract AbstractFarm is UsersStorage, StagesStorage {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    constructor(IERC20 pact_, uint256 totalRewardAmount_) LpTokensStorage(pact_) StagesStorage(totalRewardAmount_) public {}\n', '\n', '////////////////////////////////////////////////////////////\n', '\n', '    struct PoolInfoInFarmStage {\n', '        uint256 lastRewardBlock;    // Last block number that ERC20s distribution occurs.\n', '        uint256 accERC20PerShare;   // Accumulated ERC20s per share, times 1e36.\n', '    }\n', '    // stageId => poolId => PoolInfoInFarmStage\n', '    mapping (uint256 => mapping (uint256 => PoolInfoInFarmStage)) public _poolInfoInFarmStages;\n', '\n', '    // Update reward variables for all pools. Be careful of gas spending!\n', '    function massUpdatePools() public {\n', '        for (uint256 poolId = 0; poolId < _poolInfoCount; ++poolId) {\n', '            updatePool(poolId);\n', '        }\n', '    }\n', '\n', '    // poolId => firstNotFinishedStage\n', '    mapping (uint256 => uint256) _firstNotFinishedStages;\n', '\n', '    function updatePool(uint256 poolId) public {\n', '        require(poolId < _poolInfoCount, "updatePool: Pool is not exists");\n', '        PoolInfo storage pool = _poolInfo[poolId];\n', '        _updatePool(pool);\n', '    }\n', '    function _updatePool(PoolInfo storage pool) internal {\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '\n', '        StageInfo storage stage;\n', '        for (uint256 stageId = _firstNotFinishedStages[pool.id]; stageId < _stageInfoCount; ++stageId) {\n', '            stage = _stageInfo[stageId];\n', '\n', '            if (stage.startBlock > block.number) {\n', '                return;\n', '            }\n', '\n', '            if (_updatePoolInfoInFarmStage(stage, pool, lpSupply)) {\n', '                _firstNotFinishedStages[pool.id] = stageId.add(1);\n', '            }\n', '        }\n', '    }\n', '    function _updatePoolInfoInFarmStage(\n', '        StageInfo storage stage,\n', '        PoolInfo storage pool,\n', '        uint256 lpSupply\n', '    ) internal returns (bool) {\n', '        uint256 lastBlock = block.number < stage.endBlock ? block.number : stage.endBlock;\n', '\n', '        PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stage.id][pool.id];\n', '        if (poolInFarmStage.lastRewardBlock < stage.startBlock) {\n', '            poolInFarmStage.lastRewardBlock = stage.startBlock;\n', '        }\n', '\n', '        if (lastBlock <= poolInFarmStage.lastRewardBlock) {\n', '            return true;\n', '        }\n', '\n', '        if (lpSupply == 0) {\n', '            poolInFarmStage.lastRewardBlock = lastBlock;\n', '            return false;\n', '        }\n', '\n', '        uint256 nrOfBlocks = lastBlock.sub(poolInFarmStage.lastRewardBlock);\n', '        uint256 erc20Reward = nrOfBlocks.mul(stage.rewardPerBlock).mul(pool.allocPoint).div(_totalAllocPoint);\n', '\n', '        poolInFarmStage.accERC20PerShare = poolInFarmStage.accERC20PerShare.add(erc20Reward.mul(1e36).div(lpSupply));\n', '        poolInFarmStage.lastRewardBlock = block.number;\n', '        return false;\n', '    }\n', '\n', '////////////////////////////////////////////////////////////\n', '\n', '    function pending(uint256 poolId, address account) external view returns (uint256) {\n', '        require(poolId < _poolInfoCount, "pending: Pool is not exists");\n', '        PoolInfo storage pool = _poolInfo[poolId];\n', '        UserInfo storage user = _userInfo[poolId][account];\n', '        uint256 rewardPending = user.rewardPending;\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '\n', '        for (uint256 stageId = 0; stageId < _stageInfoCount; ++stageId) {\n', '            StageInfo storage stage = _stageInfo[stageId];\n', '\n', '            if (stage.startBlock > block.number) {\n', '                break;\n', '            }\n', '\n', '            PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stageId][poolId];\n', '\n', '            uint256 accERC20PerShare = poolInFarmStage.accERC20PerShare;\n', '            uint256 lastBlock = block.number < stage.endBlock ? block.number : stage.endBlock;\n', '\n', '            if (lastBlock > poolInFarmStage.lastRewardBlock && lpSupply != 0) {\n', '                uint256 startBlock = poolInFarmStage.lastRewardBlock < stage.startBlock ? stage.startBlock : poolInFarmStage.lastRewardBlock;\n', '\n', '                uint256 nrOfBlocks = lastBlock.sub(startBlock);\n', '                uint256 erc20Reward = nrOfBlocks.mul(stage.rewardPerBlock).mul(pool.allocPoint).div(_totalAllocPoint);\n', '\n', '                accERC20PerShare = accERC20PerShare.add(erc20Reward.mul(1e36).div(lpSupply));\n', '            }\n', '\n', '            uint256 pendingAmount = user.amount.mul(accERC20PerShare).div(1e36).sub(_userRewardDebt[stageId][poolId][account]);\n', '            rewardPending = rewardPending.add(pendingAmount);\n', '        }\n', '\n', '        return rewardPending;\n', '    }\n', '\n', '////////////////////////////////////////////////////////////\n', '\n', '    function _addLpToken(uint256 allocPoint, IUniswapV2Pair lpToken, bool withUpdate) internal {\n', '        if (withUpdate) {\n', '            massUpdatePools();\n', '        }\n', '        _addLpToken(allocPoint, lpToken);\n', '    }\n', '\n', '    function _updateLpToken(uint256 poolId, uint256 allocPoint, bool withUpdate) internal {\n', '        if (withUpdate) {\n', '            massUpdatePools();\n', '        }\n', '        _updateLpToken(poolId, allocPoint);\n', '    }\n', '\n', '////////////////////////////////////////////////////////////\n', '\n', '    uint256 _totalRewardPending;\n', '\n', '    // stageId => poolId => account => userRewardDebt\n', '    mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public _userRewardDebt;\n', '\n', '    function _beforeBalanceChange(PoolInfo storage pool, address account) internal virtual override {\n', '        _updatePool(pool);\n', '        UserInfo storage user = _userInfo[pool.id][account];\n', '\n', '        StageInfo storage stage;\n', '        for (uint256 stageId = 0; stageId < _stageInfoCount; ++stageId) {\n', '            stage = _stageInfo[stageId];\n', '            if (stage.startBlock > block.number) {\n', '                return;\n', '            }\n', '            PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stage.id][pool.id];\n', '\n', '            uint256 pendingAmount = user.amount\n', '                .mul(poolInFarmStage.accERC20PerShare)\n', '                .div(1e36)\n', '                .sub(_userRewardDebt[stage.id][pool.id][account]);\n', '\n', '            user.rewardPending = user.rewardPending.add(pendingAmount);\n', '            _totalRewardPending = _totalRewardPending.add(pendingAmount);\n', '        }\n', '    }\n', '    function _afterBalanceChange(PoolInfo storage pool, address account) internal virtual override {\n', '        UserInfo storage user = _userInfo[pool.id][account];\n', '\n', '        StageInfo storage stage;\n', '        for (uint256 stageId = 0; stageId < _stageInfoCount; ++stageId) {\n', '            stage = _stageInfo[stageId];\n', '            if (stage.startBlock > block.number) {\n', '                return;\n', '            }\n', '\n', '            PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stage.id][pool.id];\n', '            _userRewardDebt[stage.id][pool.id][account] = user.amount.mul(poolInFarmStage.accERC20PerShare).div(1e36);\n', '        }\n', '    }\n', '\n', '    function _updateUserRewardDebtAndPending(PoolInfo storage pool, address account) internal {\n', '        _updatePool(pool);\n', '        UserInfo storage user = _userInfo[pool.id][account];\n', '\n', '        StageInfo storage stage;\n', '        for (uint256 stageId = 0; stageId < _stageInfoCount; ++stageId) {\n', '            stage = _stageInfo[stageId];\n', '            if (stage.startBlock > block.number) {\n', '                return;\n', '            }\n', '            PoolInfoInFarmStage storage poolInFarmStage = _poolInfoInFarmStages[stage.id][pool.id];\n', '\n', '            uint256 pendingAmount = user.amount\n', '                .mul(poolInFarmStage.accERC20PerShare)\n', '                .div(1e36)\n', '                .sub(_userRewardDebt[stage.id][pool.id][account])\n', '            ;\n', '\n', '            user.rewardPending = user.rewardPending.add(pendingAmount);\n', '            _totalRewardPending = _totalRewardPending.add(pendingAmount);\n', '            _userRewardDebt[stage.id][pool.id][account] = user.amount.mul(poolInFarmStage.accERC20PerShare).div(1e36);\n', '        }\n', '    }\n', '\n', '////////////////////////////////////////////////////////////\n', '\n', '    event Harvest(address indexed user, uint256 indexed poolId, uint256 amount);\n', '    // Withdraw LP tokens from Farm.\n', '    function withdrawAndHarvest(uint256 poolId, uint256 amount) public {\n', '        require(poolId < _poolInfoCount, "withdrawAndHarvest: Pool is not exists");\n', '        PoolInfo storage pool = _poolInfo[poolId];\n', '        require(amount > 0, "withdrawAndHarvest: can\'t withdraw zero amount");\n', '        UserInfo storage user = _userInfo[poolId][msg.sender];\n', '        require(user.amount >= amount, "withdrawAndHarvest: can\'t withdraw more than deposit");\n', '\n', '        _beforeBalanceChange(pool, msg.sender);\n', '\n', '        user.amount = user.amount.sub(amount);\n', '        pool.lpToken.safeTransfer(address(msg.sender), amount);\n', '        emit Withdraw(msg.sender, poolId, amount);\n', '\n', '        _pact.transfer(msg.sender, user.rewardPending);\n', '        _totalRewardPending = _totalRewardPending.sub(user.rewardPending);\n', '\n', '        emit Harvest(msg.sender, poolId, user.rewardPending);\n', '        user.rewardPending = 0;\n', '\n', '        _afterBalanceChange(pool, msg.sender);\n', '    }\n', '    // Harvest PACTs from Farm.\n', '    function harvest(uint256 poolId) public {\n', '        require(poolId < _poolInfoCount, "harvest: Pool is not exists");\n', '        PoolInfo storage pool = _poolInfo[poolId];\n', '        UserInfo storage user = _userInfo[poolId][msg.sender];\n', '        require(user.userExists, "harvest: can\'t harvest from new user");\n', '\n', '        _updateUserRewardDebtAndPending(pool, msg.sender);\n', '\n', '        _pact.transfer(msg.sender, user.rewardPending);\n', '        _totalRewardPending = _totalRewardPending.sub(user.rewardPending);\n', '\n', '        emit Harvest(msg.sender, poolId, user.rewardPending);\n', '        user.rewardPending = 0;\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./AbstractFarm.sol";\n', 'import "../vendors/libraries/SafeMath.sol";\n', 'import "../vendors/contracts/access/GovernanceOwnable.sol";\n', '\n', '// Cloned and modified from https://github.com/ltonetwork/uniswap-farming/blob/master/contracts/Farm.sol\n', 'contract FarmPACT is GovernanceOwnable, AbstractFarm {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 _blockGenerationFrequency;\n', '    function blockGenerationFrequency() public view returns (uint256) {\n', '        return _blockGenerationFrequency;\n', '    }\n', '\n', '    // etherium - block_generation_frequency_ ~ 15s\n', '    // binance smart chain - block_generation_frequency_ ~ 4s\n', '    constructor(\n', '        address governance_,\n', '        IERC20 pact_,\n', '        uint256 blockGenerationFrequency_,\n', '        uint256 totalRewardAmount_\n', '    ) GovernanceOwnable(governance_) AbstractFarm(pact_, totalRewardAmount_) public {\n', '        require(blockGenerationFrequency_ > 0, "constructor: blockGenerationFrequency is empty");\n', '        _blockGenerationFrequency = blockGenerationFrequency_;\n', '    }\n', '\n', '    function startFarming(uint256 startBlock) public onlyGovernance {\n', '        require(_lastStageEndBlock == 0, "startFarming: already started");\n', '        uint currentBalance = _pact.balanceOf(address(this));\n', '        require(currentBalance >= _totalRewardAmount, "startFarming: currentBalance is not enough");\n', '\n', '        _addFirstStage(startBlock, 10 days / _blockGenerationFrequency, _totalRewardAmount / 8);\n', '        _addStage(20 days / _blockGenerationFrequency, _totalRewardAmount / 8);\n', '        _addStage(150 days / _blockGenerationFrequency, _totalRewardAmount / 8);\n', '        _addStage(180 days / _blockGenerationFrequency, _totalRewardAmount / 8);\n', '        _addStage(1080 days / _blockGenerationFrequency, _totalRewardAmount / 2);\n', '    }\n', '\n', '    function addLpToken(uint256 _allocPoint, address _lpToken, bool _withUpdate) public onlyGovernance {\n', '        _addLpToken(_allocPoint, IUniswapV2Pair(_lpToken), _withUpdate);\n', '    }\n', '\n', '    function updateLpToken(uint256 poolId, uint256 allocPoint, bool withUpdate) public onlyGovernance {\n', '        _updateLpToken(poolId, allocPoint, withUpdate);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../vendors/libraries/SafeMath.sol";\n', 'import "../vendors/interfaces/IERC20.sol";\n', 'import "../vendors/interfaces/IUniswapV2Pair.sol";\n', '\n', 'abstract contract LpTokensStorage {\n', '    using SafeMath for uint256;\n', '\n', '    // Address of the ERC20 Token contract.\n', '    IERC20 _pact;\n', '    constructor(IERC20 pact_) public {\n', '        require(address(pact_) != address(0), "LpTokensStorage::constructor: pact_ - is empty");\n', '        _pact = pact_;\n', '    }\n', '\n', '    function pact() public view returns (address) {\n', '        return address(_pact);\n', '    }\n', '\n', '    struct PoolInfo {\n', '        uint256 id;\n', '        IUniswapV2Pair lpToken;    // Address of LP token contract.\n', '        uint256 allocPoint;         // How many allocation points assigned to this pool. ERC20s to distribute per block.\n', '    }\n', '    // poolId => PoolInfo\n', '    PoolInfo[] _poolInfo;\n', '    uint256 _poolInfoCount = 0;\n', '    mapping (address => bool) _lpTokensList;\n', '    // Total allocation points. Must be the sum of all allocation points in all pools.\n', '    uint256 _totalAllocPoint = 0;\n', '\n', '\n', '    function poolInfoCount() public view returns (uint256) {\n', '        return _poolInfoCount;\n', '    }\n', '    function poolInfo(uint256 poolId) public view returns (PoolInfo memory) {\n', '        return _poolInfo[poolId];\n', '    }\n', '    function totalAllocPoint() public view returns (uint256) {\n', '        return _totalAllocPoint;\n', '    }\n', '\n', '    function _addLpToken(uint256 allocPoint, IUniswapV2Pair lpToken) internal {\n', '        require(_lpTokensList[address(lpToken)] == false, "_addLpToken: LP Token exists");\n', '\n', '        _totalAllocPoint = _totalAllocPoint.add(allocPoint);\n', '\n', '        _poolInfo.push(PoolInfo({\n', '            id: _poolInfoCount,\n', '            lpToken: lpToken,\n', '            allocPoint: allocPoint\n', '        }));\n', '        ++_poolInfoCount;\n', '        _lpTokensList[address(lpToken)] = true;\n', '    }\n', '\n', '    function _updateLpToken(uint256 poolId, uint256 allocPoint) internal {\n', '        require(poolId < _poolInfoCount, "_updateLpToken: Pool is not exists");\n', '        PoolInfo storage pool = _poolInfo[poolId];\n', '\n', '        _totalAllocPoint = _totalAllocPoint.sub(pool.allocPoint).add(allocPoint);\n', '        pool.allocPoint = allocPoint;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../vendors/libraries/SafeMath.sol";\n', '\n', 'abstract contract StagesStorage {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 _totalRewardAmount;\n', '    function totalRewardAmount() public view returns (uint256) {\n', '        return _totalRewardAmount;\n', '    }\n', '\n', '    constructor(\n', '        uint256 totalRewardAmount_\n', '    ) public {\n', '        require(totalRewardAmount_ > 0, "constructor: totalRewardAmount is empty");\n', '        _totalRewardAmount = totalRewardAmount_;\n', '    }\n', '\n', '    struct StageInfo {\n', '        uint256 id;\n', '        uint256 startBlock;\n', '        uint256 endBlock;\n', '        uint256 rewardPerBlock;\n', '    }\n', '    // stageId => StageInfo\n', '    StageInfo[] _stageInfo;\n', '    uint256 _stageInfoCount = 0;\n', '    uint256 _totalRewardInStages;\n', '    uint256 _lastStageEndBlock;\n', '\n', '    function stageInfo(uint256 stageId) public view returns (StageInfo memory) {\n', '        return _stageInfo[stageId];\n', '    }\n', '    function stageInfoCount() public view returns (uint256) {\n', '        return _stageInfoCount;\n', '    }\n', '    function totalRewardInStages() public view returns (uint256) {\n', '        return _totalRewardInStages;\n', '    }\n', '\n', '    function _addFirstStage(\n', '        uint256 startBlock,\n', '        uint256 periodInBlocks,\n', '        uint256 rewardAmount\n', '    ) internal {\n', '        require(_lastStageEndBlock == 0, "_addFirstStage: first stage is already installed");\n', '        startBlock = block.number > startBlock ? block.number : startBlock;\n', '        __addStage(\n', '            startBlock,\n', '            periodInBlocks,\n', '            rewardAmount\n', '        );\n', '    }\n', '\n', '    function _addStage(\n', '        uint256 periodInBlocks,\n', '        uint256 rewardAmount\n', '    ) internal {\n', '        require(_lastStageEndBlock > 0, "_addStage: first stage is not installed yet");\n', '        __addStage(\n', '            _lastStageEndBlock,\n', '            periodInBlocks,\n', '            rewardAmount\n', '        );\n', '    }\n', '\n', '    function __addStage(\n', '        uint256 startBlock,\n', '        uint256 periodInBlocks,\n', '        uint256 rewardAmount\n', '    ) private {\n', '        StageInfo memory newStage = StageInfo({\n', '            id: _stageInfoCount,\n', '            startBlock: startBlock,\n', '            endBlock: startBlock.add(periodInBlocks),\n', '            rewardPerBlock: rewardAmount.div(periodInBlocks)\n', '        });\n', '        ++_stageInfoCount;\n', '        _stageInfo.push(newStage);\n', '\n', '        _lastStageEndBlock = newStage.endBlock.add(1);\n', '        _totalRewardInStages = _totalRewardInStages.add(rewardAmount);\n', '        require(_totalRewardInStages <= _totalRewardAmount, "__addStage: _totalRewardInStages > _totalRewardAmount");\n', '    }\n', '\n', '    function stagesLength() external view returns (uint256) {\n', '        return _stageInfo.length;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../vendors/libraries/SafeMath.sol";\n', 'import "../vendors/libraries/SafeERC20.sol";\n', 'import "../vendors/interfaces/IUniswapV2Pair.sol";\n', 'import "./LpTokensStorage.sol";\n', '\n', 'abstract contract UsersStorage is LpTokensStorage {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IUniswapV2Pair;\n', '\n', '    struct UserInfo {\n', '        bool userExists;\n', '        uint256 amount;\n', '        uint256 rewardPending;\n', '    }\n', '    // poolId => account => UserInfo\n', '    mapping (uint256 => mapping (address => UserInfo)) public _userInfo;\n', '\n', '    event Deposit(address indexed user, uint256 indexed poolId, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 indexed poolId, uint256 amount);\n', '\n', '    // Deposit LP tokens to Farm for ERC20 allocation.\n', '    function deposit(uint256 poolId, uint256 amount) public {\n', '        require(poolId < _poolInfoCount, "deposit: Pool is not exists");\n', '        PoolInfo storage pool = _poolInfo[poolId];\n', '        require(amount > 0, "deposit: can\'t deposit zero amount");\n', '        UserInfo storage user = _userInfo[poolId][msg.sender];\n', '        user.userExists = true;\n', '\n', '        _beforeBalanceChange(pool, msg.sender);\n', '\n', '        user.amount = user.amount.add(amount);\n', '        pool.lpToken.safeTransferFrom(address(msg.sender), amount);\n', '        emit Deposit(msg.sender, poolId, amount);\n', '\n', '        _afterBalanceChange(pool, msg.sender);\n', '    }\n', '    // Withdraw LP tokens from Farm.\n', '    function withdraw(uint256 poolId, uint256 amount) public {\n', '        require(poolId < _poolInfoCount, "withdraw: Pool is not exists");\n', '        PoolInfo storage pool = _poolInfo[poolId];\n', '        require(amount > 0, "withdraw: can\'t withdraw zero amount");\n', '        UserInfo storage user = _userInfo[poolId][msg.sender];\n', '        require(user.amount >= amount, "withdraw: can\'t withdraw more than deposit");\n', '\n', '        _beforeBalanceChange(pool, msg.sender);\n', '\n', '        user.amount = user.amount.sub(amount);\n', '        pool.lpToken.safeTransfer(address(msg.sender), amount);\n', '        emit Withdraw(msg.sender, poolId, amount);\n', '\n', '        _afterBalanceChange(pool, msg.sender);\n', '    }\n', '    function _beforeBalanceChange(PoolInfo storage pool, address account) internal virtual {}\n', '    function _afterBalanceChange(PoolInfo storage pool, address account) internal virtual {}\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "../../interfaces/IGovernanceOwnable.sol";\n', '\n', 'abstract contract GovernanceOwnable is IGovernanceOwnable {\n', '    address private _governanceAddress;\n', '\n', '    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\n', '\n', '    constructor (address governance_) public {\n', '        require(governance_ != address(0), "Governance address should be not null");\n', '        _governanceAddress = governance_;\n', '        emit GovernanceSetTransferred(address(0), governance_);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current governanceAddress.\n', '     */\n', '    function governance() public view override returns (address) {\n', '        return _governanceAddress;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the governanceAddress.\n', '     */\n', '    modifier onlyGovernance() {\n', '        require(_governanceAddress == msg.sender, "Governance: caller is not the governance");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev SetGovernance of the contract to a new account (`newGovernance`).\n', '     * Can only be called by the current onlyGovernance.\n', '     */\n', '    function setGovernance(address newGovernance) public virtual override onlyGovernance {\n', '        require(newGovernance != address(0), "GovernanceOwnable: new governance is the zero address");\n', '        emit GovernanceSetTransferred(_governanceAddress, newGovernance);\n', '        _governanceAddress = newGovernance;\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IGovernanceOwnable {\n', '    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\n', '\n', '    function governance() external view returns (address);\n', '    function setGovernance(address newGovernance) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IERC20.sol";\n', '\n', 'interface IUniswapV2ERC20 is IERC20 {\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IUniswapV2ERC20.sol";\n', '\n', 'interface IUniswapV2Pair is IUniswapV2ERC20 {\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "../interfaces/IERC20.sol";\n', '\n', 'library SafeERC20 {\n', '    function safeSymbol(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeName(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeDecimals(IERC20 token) public view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: Transfer failed");\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return add(a, b, "SafeMath: Add Overflow");\n', '    }\n', '    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);// "SafeMath: Add Overflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: Underflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;// "SafeMath: Underflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mul(a, b, "SafeMath: Mul Overflow");\n', '    }\n', '    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMessage);// "SafeMath: Mul Overflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']