['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-15\n', '*/\n', '\n', 'pragma solidity 0.4.25;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error.\n', ' */\n', 'library SafeMath {\n', '  /**\n', '   * @dev Multiplies two unsigned integers, reverts on overflow.\n', '   */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath mul error");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '   */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Solidity only automatically asserts when dividing by 0\n', '    require(b > 0, "SafeMath div error");\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '   */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "SafeMath sub error");\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two unsigned integers, reverts on overflow.\n', '   */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath add error");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '   * reverts when dividing by zero.\n', '   */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0, "SafeMath mod error");\n', '    return a % b;\n', '  }\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'contract IERC20 {\n', '    function transfer(address to, uint256 value) public returns (bool);\n', '\n', '    function approve(address spender, uint256 value) public returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '\n', '    function balanceOf(address who) public view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256);\n', '\n', '    function totalSupply() public view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract ILPToken is IERC20 {\n', '  function getReserves() public returns (uint112, uint112, uint32);\n', '}\n', '\n', 'contract ELDFarm {\n', '  using SafeMath for uint;\n', '\n', '  IERC20 constant eldToken = IERC20(0xf0C6521b1F8ad9C33a99Aaf056F6C6247A3862BA);\n', '  ILPToken constant lpToken = ILPToken(0x54d5230d16033eb03ffbaB29FCc09Ac54Df6F812);\n', '\n', '  uint constant blockPerDay = 5760;\n', '\n', '  address admin;\n', '  uint eldPrice = 9230; // decimal 6\n', '\n', '  struct UserInfo {\n', '    uint usdtAmount;\n', '    uint lpTokenAmount;\n', '    uint lastRewardBlock;\n', '  }\n', '\n', '  mapping(address => UserInfo) public userInfo;\n', '  event Deposit(address indexed user, uint lpTokenAmount, uint usdtAmount);\n', '  event Withdraw(address indexed user, uint lpTokenAmount);\n', '  event Reward(address indexed user, uint eldAmount);\n', '  event EmergencyWithdraw(address indexed user, uint lpTokenAmount);\n', '\n', '  modifier onlyAdmin() {\n', "    require(msg.sender == admin, 'onlyAdmin');\n", '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    admin = msg.sender;\n', '  }\n', '\n', '  function setELDPrice(uint _price) external onlyAdmin {\n', '    eldPrice = _price;\n', '  }\n', '\n', '  function deposit(uint _lpTokenAmount) external {\n', "    require(_lpTokenAmount > 0, 'Invalid amount');\n", "    require(lpToken.transferFrom(msg.sender, address(this), _lpTokenAmount), 'You are not approve lpToken to this contract');\n", '    UserInfo storage user = userInfo[msg.sender];\n', '    if (user.usdtAmount > 0 && block.number > user.lastRewardBlock) {\n', '      uint rewardedBlock = block.number - user.lastRewardBlock;\n', '      user.lastRewardBlock = block.number;\n', '      uint pendingRewardBalance = getPendingReward(rewardedBlock, user.usdtAmount);\n', '      safeELDTransfer(msg.sender, pendingRewardBalance);\n', '      emit Reward(msg.sender, pendingRewardBalance);\n', '    } else {\n', '      user.lastRewardBlock = block.number;\n', '    }\n', '    user.lpTokenAmount = user.lpTokenAmount.add(_lpTokenAmount);\n', '    uint usdtAmount = getUSDTFromLPToken(_lpTokenAmount);\n', '    user.usdtAmount = user.usdtAmount.add(usdtAmount);\n', '    emit Deposit(msg.sender, _lpTokenAmount, usdtAmount);\n', '  }\n', '\n', '  function withdraw() external {\n', '    UserInfo storage user = userInfo[msg.sender];\n', "    require (user.lpTokenAmount > 0, 'You have no farming');\n", '    if (user.usdtAmount > 0 && block.number > user.lastRewardBlock) {\n', '      uint rewardedBlock = block.number - user.lastRewardBlock;\n', '      user.lastRewardBlock = block.number;\n', '      uint userUsdtAmount = user.usdtAmount;\n', '      user.usdtAmount = 0;\n', '      uint userLPTokenAmount = user.lpTokenAmount;\n', '      user.lpTokenAmount = 0;\n', '      uint pendingRewardBalance = getPendingReward(rewardedBlock, userUsdtAmount);\n', '      safeELDTransfer(msg.sender, pendingRewardBalance);\n', '      safeLPTokenTransfer(msg.sender, userLPTokenAmount);\n', '      emit Reward(msg.sender, pendingRewardBalance);\n', '      emit Withdraw(msg.sender, userLPTokenAmount);\n', '    }\n', '  }\n', '\n', '  function reward() public {\n', '    UserInfo storage user = userInfo[msg.sender];\n', "    require (user.lpTokenAmount > 0, 'You have no farming');\n", '    if (user.usdtAmount > 0 && block.number > user.lastRewardBlock) {\n', '      uint rewardedBlock = block.number - user.lastRewardBlock;\n', '      user.lastRewardBlock = block.number;\n', '      uint pendingRewardBalance = getPendingReward(rewardedBlock, user.usdtAmount);\n', '      safeELDTransfer(msg.sender, pendingRewardBalance);\n', '      emit Reward(msg.sender, pendingRewardBalance);\n', '    }\n', '  }\n', '\n', '  function safeELDTransfer(address _to, uint256 _amount) internal {\n', '    uint256 eldBalance = eldToken.balanceOf(address(this));\n', "    require(eldBalance > 0, 'Contract is insufficient balance');\n", '    if (_amount > eldBalance) {\n', '      eldToken.transfer(_to, eldBalance);\n', '    } else {\n', '      eldToken.transfer(_to, _amount);\n', '    }\n', '  }\n', '\n', '  function safeLPTokenTransfer(address _to, uint256 _amount) internal {\n', '    uint256 lpBalance = lpToken.balanceOf(address(this));\n', "    require(lpBalance > 0, 'Contract is insufficient balance');\n", '    if (_amount > lpBalance) {\n', '      lpToken.transfer(_to, lpBalance);\n', '    } else {\n', '      lpToken.transfer(_to, _amount);\n', '    }\n', '  }\n', '\n', '  function getUSDTFromLPToken(uint _lpTokenAmount) public returns (uint) {\n', '    uint totalSupply = lpToken.totalSupply();\n', '    uint112 reserveUSDT;\n', '    uint112 _reserveELD;\n', '    uint32 _no;\n', '    (reserveUSDT, _reserveELD, _no) = lpToken.getReserves();\n', '    return _lpTokenAmount * uint(reserveUSDT) / totalSupply;\n', '  }\n', '\n', '  function getPendingReward(uint _rewardedBlock, uint _usdtAmount) public view returns (uint) {\n', '    return _rewardedBlock * _usdtAmount * 1e12 / eldPrice * 1e6 * 5 / 1e3 / blockPerDay;\n', '  }\n', '\n', '  function emergencyWithdraw() public {\n', '    UserInfo storage user = userInfo[msg.sender];\n', "    require (user.lpTokenAmount > 0, 'You have no farming');\n", '    user.lastRewardBlock = block.number;\n', '    user.usdtAmount = 0;\n', '    uint userLPTokenAmount = user.lpTokenAmount;\n', '    user.lpTokenAmount = 0;\n', '    safeLPTokenTransfer(msg.sender, userLPTokenAmount);\n', '    emit EmergencyWithdraw(msg.sender, user.lpTokenAmount);\n', '  }\n', '}']