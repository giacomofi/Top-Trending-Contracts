['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-10\n', '*/\n', '\n', '/*\n', 'https://powerpool.finance/\n', '\n', '          wrrrw r wrr\n', '         ppwr rrr wppr0       prwwwrp                                 prwwwrp                   wr0\n', '        rr 0rrrwrrprpwp0      pp   pr  prrrr0 pp   0r  prrrr0  0rwrrr pp   pr  prrrr0  prrrr0    r0\n', '        rrp pr   wr00rrp      prwww0  pp   wr pp w00r prwwwpr  0rw    prwww0  pp   wr pp   wr    r0\n', '        r0rprprwrrrp pr0      pp      wr   pr pp rwwr wr       0r     pp      wr   pr wr   pr    r0\n', '         prwr wrr0wpwr        00        www0   0w0ww    www0   0w     00        www0    www0   0www0\n', '          wrr ww0rrrr\n', '\n', '*/\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '// File: @openzeppelin/upgrades-core/contracts/Initializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IPowerPokeStaking.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IPowerPokeStaking {\n', '  enum UserStatus { UNAUTHORIZED, HDH, MEMBER }\n', '\n', '  /*** User Interface ***/\n', '  function createDeposit(uint256 userId_, uint256 amount_) external;\n', '\n', '  function executeDeposit(uint256 userId_) external;\n', '\n', '  function createWithdrawal(uint256 userId_, uint256 amount_) external;\n', '\n', '  function executeWithdrawal(uint256 userId_, address to_) external;\n', '\n', '  function createUser(\n', '    address adminKey_,\n', '    address reporterKey_,\n', '    uint256 depositAmount\n', '  ) external;\n', '\n', '  function updateUser(\n', '    uint256 userId,\n', '    address adminKey_,\n', '    address reporterKey_\n', '  ) external;\n', '\n', '  /*** Owner Interface ***/\n', '  function setSlasher(address slasher) external;\n', '\n', '  function setSlashingPct(uint256 slasherRewardPct, uint256 reservoirRewardPct) external;\n', '\n', '  function setTimeouts(uint256 depositTimeout_, uint256 withdrawalTimeout_) external;\n', '\n', '  function pause() external;\n', '\n', '  function unpause() external;\n', '\n', '  /*** PowerOracle Contract Interface ***/\n', '  function slashHDH(uint256 slasherId_, uint256 times_) external;\n', '\n', '  /*** Permissionless Interface ***/\n', '  function setHDH(uint256 candidateId_) external;\n', '\n', '  /*** Viewers ***/\n', '  function getHDHID() external view returns (uint256);\n', '\n', '  function getHighestDeposit() external view returns (uint256);\n', '\n', '  function getDepositOf(uint256 userId) external view returns (uint256);\n', '\n', '  function getPendingDepositOf(uint256 userId_) external view returns (uint256 balance, uint256 timeout);\n', '\n', '  function getPendingWithdrawalOf(uint256 userId_) external view returns (uint256 balance, uint256 timeout);\n', '\n', '  function getSlashAmount(uint256 slasheeId_, uint256 times_)\n', '    external\n', '    view\n', '    returns (\n', '      uint256 slasherReward,\n', '      uint256 reservoirReward,\n', '      uint256 totalSlash\n', '    );\n', '\n', '  function getUserStatus(\n', '    uint256 userId_,\n', '    address reporterKey_,\n', '    uint256 minDeposit_\n', '  ) external view returns (UserStatus);\n', '\n', '  function authorizeHDH(uint256 userId_, address reporterKey_) external view;\n', '\n', '  function authorizeNonHDH(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view;\n', '\n', '  function authorizeMember(\n', '    uint256 userId_,\n', '    address reporterKey_,\n', '    uint256 minDeposit_\n', '  ) external view;\n', '\n', '  function requireValidAdminKey(uint256 userId_, address adminKey_) external view;\n', '\n', '  function requireValidAdminOrPokerKey(uint256 userId_, address adminOrPokerKey_) external view;\n', '\n', '  function getLastDepositChange(uint256 userId_) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/utils/PowerOwnable.sol\n', '\n', '// A modified version of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/access/Ownable.sol\n', '// with no GSN Context support and _transferOwnership internal method\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract PowerOwnable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev Initializes the contract setting the deployer as the initial owner.\n', '   */\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(_owner == msg.sender, "NOT_THE_OWNER");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Leaves the contract without owner. It will not be possible to call\n', '   * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '   *\n', '   * NOTE: Renouncing ownership will leave the contract without an owner,\n', '   * thereby removing any functionality that is only available to the owner.\n', '   */\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "NEW_OWNER_IS_NULL");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0), "NEW_OWNER_IS_NULL");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/utils/PowerPausable.sol\n', '\n', '// A modified version of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/utils/Pausable.sol\n', '// with no GSN Context support and no construct\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'contract PowerPausable {\n', '  /**\n', '   * @dev Emitted when the pause is triggered by `account`.\n', '   */\n', '  event Paused(address account);\n', '\n', '  /**\n', '   * @dev Emitted when the pause is lifted by `account`.\n', '   */\n', '  event Unpaused(address account);\n', '\n', '  bool private _paused;\n', '\n', '  /**\n', '   * @dev Returns true if the contract is paused, and false otherwise.\n', '   */\n', '  function paused() public view returns (bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must not be paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused, "PAUSED");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must be paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused, "NOT_PAUSED");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Triggers stopped state.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must not be paused.\n', '   */\n', '  function _pause() internal virtual whenNotPaused {\n', '    _paused = true;\n', '    emit Paused(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns to normal state.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must be paused.\n', '   */\n', '  function _unpause() internal virtual whenPaused {\n', '    _paused = false;\n', '    emit Unpaused(msg.sender);\n', '  }\n', '}\n', '\n', '// File: contracts/PowerPokeStakingStorageV1.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'contract PowerPokeStakingStorageV1 {\n', '  struct User {\n', '    address adminKey;\n', '    address pokerKey;\n', '    uint256 deposit;\n', '    uint256 pendingDeposit;\n', '    uint256 pendingDepositTimeout;\n', '    uint256 pendingWithdrawal;\n', '    uint256 pendingWithdrawalTimeout;\n', '  }\n', '\n', '  /// @notice The deposit timeout in seconds\n', '  uint256 public depositTimeout;\n', '\n', '  /// @notice The withdrawal timeout in seconds\n', '  uint256 public withdrawalTimeout;\n', '\n', '  /// @notice The reservoir which holds CVP tokens\n', '  address public reservoir;\n', '\n', '  /// @notice The slasher address (PowerPoke)\n', '  address public slasher;\n', '\n', '  /// @notice The total amount of all deposits\n', '  uint256 public totalDeposit;\n', '\n', '  /// @notice The share of a slasher in slashed deposit per one outdated asset (1 eth == 1%)\n', '  uint256 public slasherSlashingRewardPct;\n', '\n', '  /// @notice The share of the protocol(reservoir) in slashed deposit per one outdated asset (1 eth == 1%)\n', '  uint256 public protocolSlashingRewardPct;\n', '\n', '  /// @notice The incremented user ID counter. Is updated only within createUser function call\n', '  uint256 public userIdCounter;\n', '\n', '  /// @dev The highest deposit. Usually of the current reporterId. Is safe to be outdated.\n', '  uint256 internal _highestDeposit;\n', '\n', '  /// @dev The current highest deposit holder ID.\n', '  uint256 internal _hdhId;\n', '\n', "  /// @notice User details by it's ID\n", '  mapping(uint256 => User) public users;\n', '\n', '  /// @dev Last deposit change timestamp by user ID\n', '  mapping(uint256 => uint256) internal _lastDepositChange;\n', '}\n', '\n', '// File: contracts/PowerPokeStaking.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PowerPokeStaking is IPowerPokeStaking, PowerOwnable, Initializable, PowerPausable, PowerPokeStakingStorageV1 {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public constant HUNDRED_PCT = 100 ether;\n', '\n', '  /// @notice The event emitted when a new user is created\n', '  event CreateUser(uint256 indexed userId, address indexed adminKey, address indexed pokerKey, uint256 initialDeposit);\n', '\n', '  /// @notice The event emitted when an existing user is updated\n', '  event UpdateUser(uint256 indexed userId, address indexed adminKey, address indexed pokerKey);\n', '\n', '  /// @notice The event emitted when the user creates pending deposit\n', '  event CreateDeposit(\n', '    uint256 indexed userId,\n', '    address indexed depositor,\n', '    uint256 pendingTimeout,\n', '    uint256 amount,\n', '    uint256 pendingDepositAfter\n', '  );\n', '\n', '  /// @notice The event emitted when the user transfers his deposit from pending to the active\n', '  event ExecuteDeposit(uint256 indexed userId, uint256 pendingTimeout, uint256 amount, uint256 depositAfter);\n', '\n', '  /// @notice The event emitted when the user creates pending deposit\n', '  event CreateWithdrawal(\n', '    uint256 indexed userId,\n', '    uint256 pendingTimeout,\n', '    uint256 amount,\n', '    uint256 pendingWithdrawalAfter,\n', '    uint256 depositAfter\n', '  );\n', '\n', '  /// @notice The event emitted when a valid admin key withdraws funds from\n', '  event ExecuteWithdrawal(uint256 indexed userId, address indexed to, uint256 pendingTimeout, uint256 amount);\n', '\n', '  /// @notice The event emitted when the owner sets new slashing percent values, where 1ether == 1%\n', '  event SetSlashingPct(uint256 slasherSlashingRewardPct, uint256 protocolSlashingRewardPct);\n', '\n', '  /// @notice The event emitted when the owner sets new deposit and withdrawal timeouts\n', '  event SetTimeouts(uint256 depositTimeout, uint256 withdrawalTimeout);\n', '\n', '  /// @notice The event emitted when the owner sets a new PowerOracle linked contract\n', '  event SetSlasher(address powerOracle);\n', '\n', '  /// @notice The event emitted when an arbitrary user fixes an outdated reporter userId record\n', '  event SetReporter(uint256 indexed reporterId, address indexed msgSender);\n', '\n', '  /// @notice The event emitted when the PowerOracle contract requests to slash a user with the given ID\n', '  event Slash(uint256 indexed slasherId, uint256 indexed reporterId, uint256 slasherReward, uint256 reservoirReward);\n', '\n', '  /// @notice The event emitted when the existing reporter is replaced with a new one due some reason\n', '  event ReporterChange(\n', '    uint256 indexed prevId,\n', '    uint256 indexed nextId,\n', '    uint256 highestDepositPrev,\n', '    uint256 actualDepositPrev,\n', '    uint256 actualDepositNext\n', '  );\n', '\n', '  /// @notice CVP token address\n', '  IERC20 public immutable CVP_TOKEN;\n', '\n', '  constructor(address cvpToken_) public {\n', '    require(cvpToken_ != address(0), "CVP_ADDR_IS_0");\n', '\n', '    CVP_TOKEN = IERC20(cvpToken_);\n', '  }\n', '\n', '  function initialize(\n', '    address owner_,\n', '    address reservoir_,\n', '    address slasher_,\n', '    uint256 slasherSlashingRewardPct_,\n', '    uint256 reservoirSlashingRewardPct_,\n', '    uint256 depositTimeout_,\n', '    uint256 withdrawTimeout_\n', '  ) external initializer {\n', '    require(depositTimeout_ > 0, "DEPOSIT_TIMEOUT_IS_0");\n', '    require(withdrawTimeout_ > 0, "WITHDRAW_TIMEOUT_IS_0");\n', '\n', '    _transferOwnership(owner_);\n', '    reservoir = reservoir_;\n', '    slasher = slasher_;\n', '    slasherSlashingRewardPct = slasherSlashingRewardPct_;\n', '    protocolSlashingRewardPct = reservoirSlashingRewardPct_;\n', '    depositTimeout = depositTimeout_;\n', '    withdrawalTimeout = withdrawTimeout_;\n', '  }\n', '\n', '  /*** User Interface ***/\n', '\n', '  /**\n', '   * @notice An arbitrary user deposits CVP stake to the contract for the given user ID\n', '   * @param userId_ The user ID to make deposit for\n', '   * @param amount_ The amount in CVP tokens to deposit\n', '   */\n', '  function createDeposit(uint256 userId_, uint256 amount_) external override whenNotPaused {\n', '    require(amount_ > 0, "MISSING_AMOUNT");\n', '\n', '    User storage user = users[userId_];\n', '\n', '    require(user.adminKey != address(0), "INVALID_USER");\n', '\n', '    _createDeposit(userId_, amount_);\n', '  }\n', '\n', '  function _createDeposit(uint256 userId_, uint256 amount_) internal {\n', '    User storage user = users[userId_];\n', '\n', '    uint256 pendingDepositAfter = user.pendingDeposit.add(amount_);\n', '    uint256 timeout = block.timestamp.add(depositTimeout);\n', '\n', '    user.pendingDeposit = pendingDepositAfter;\n', '    user.pendingDepositTimeout = timeout;\n', '\n', '    emit CreateDeposit(userId_, msg.sender, timeout, amount_, pendingDepositAfter);\n', '    CVP_TOKEN.transferFrom(msg.sender, address(this), amount_);\n', '  }\n', '\n', '  function executeDeposit(uint256 userId_) external override {\n', '    User storage user = users[userId_];\n', '    uint256 amount = user.pendingDeposit;\n', '    uint256 pendingDepositTimeout = user.pendingDepositTimeout;\n', '\n', '    // check\n', '    require(user.adminKey == msg.sender, "ONLY_ADMIN_ALLOWED");\n', '    require(amount > 0, "NO_PENDING_DEPOSIT");\n', '    require(block.timestamp >= pendingDepositTimeout, "TIMEOUT_NOT_PASSED");\n', '\n', '    // increment deposit\n', '    uint256 depositAfter = user.deposit.add(amount);\n', '    user.deposit = depositAfter;\n', '    totalDeposit = totalDeposit.add(amount);\n', '\n', '    // reset pending deposit\n', '    user.pendingDeposit = 0;\n', '    user.pendingDepositTimeout = 0;\n', '\n', '    _lastDepositChange[userId_] = block.timestamp;\n', '\n', '    _trySetHighestDepositHolder(userId_, depositAfter);\n', '\n', '    emit ExecuteDeposit(userId_, pendingDepositTimeout, amount, depositAfter);\n', '  }\n', '\n', '  function _trySetHighestDepositHolder(uint256 candidateId_, uint256 candidateDepositAfter_) internal {\n', '    uint256 prevHdhID = _hdhId;\n', '    uint256 prevDeposit = users[prevHdhID].deposit;\n', '\n', '    if (candidateDepositAfter_ > prevDeposit && prevHdhID != candidateId_) {\n', '      emit ReporterChange(prevHdhID, candidateId_, _highestDeposit, users[prevHdhID].deposit, candidateDepositAfter_);\n', '\n', '      _highestDeposit = candidateDepositAfter_;\n', '      _hdhId = candidateId_;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice A valid users admin key withdraws the deposited stake form the contract\n', '   * @param userId_ The user ID to withdraw deposit from\n', '   * @param amount_ The amount in CVP tokens to withdraw\n', '   */\n', '  function createWithdrawal(uint256 userId_, uint256 amount_) external override {\n', '    require(amount_ > 0, "MISSING_AMOUNT");\n', '\n', '    User storage user = users[userId_];\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '\n', '    // decrement deposit\n', '    uint256 depositBefore = user.deposit;\n', '    require(amount_ <= depositBefore, "AMOUNT_EXCEEDS_DEPOSIT");\n', '\n', '    uint256 depositAfter = depositBefore - amount_;\n', '    user.deposit = depositAfter;\n', '    totalDeposit = totalDeposit.sub(amount_);\n', '\n', '    // increment pending withdrawal\n', '    uint256 pendingWithdrawalAfter = user.pendingWithdrawal.add(amount_);\n', '    uint256 timeout = block.timestamp.add(withdrawalTimeout);\n', '    user.pendingWithdrawal = pendingWithdrawalAfter;\n', '    user.pendingWithdrawalTimeout = timeout;\n', '\n', '    _lastDepositChange[userId_] = block.timestamp;\n', '\n', '    emit CreateWithdrawal(userId_, timeout, amount_, pendingWithdrawalAfter, depositAfter);\n', '  }\n', '\n', '  function executeWithdrawal(uint256 userId_, address to_) external override {\n', '    require(to_ != address(0), "CANT_WITHDRAW_TO_0");\n', '\n', '    User storage user = users[userId_];\n', '\n', '    uint256 pendingWithdrawalTimeout = user.pendingWithdrawalTimeout;\n', '    uint256 amount = user.pendingWithdrawal;\n', '\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '    require(amount > 0, "NO_PENDING_WITHDRAWAL");\n', '    require(block.timestamp >= pendingWithdrawalTimeout, "TIMEOUT_NOT_PASSED");\n', '\n', '    user.pendingWithdrawal = 0;\n', '    user.pendingWithdrawalTimeout = 0;\n', '\n', '    emit ExecuteWithdrawal(userId_, to_, pendingWithdrawalTimeout, amount);\n', '    CVP_TOKEN.transfer(to_, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Creates a new user ID and stores the given keys\n', '   * @param adminKey_ The admin key for the new user\n', '   * @param pokerKey_ The poker key for the new user\n', '   * @param initialDeposit_ The initial deposit to be transferred to this contract\n', '   */\n', '  function createUser(\n', '    address adminKey_,\n', '    address pokerKey_,\n', '    uint256 initialDeposit_\n', '  ) external override whenNotPaused {\n', '    uint256 userId = ++userIdCounter;\n', '\n', '    users[userId] = User(adminKey_, pokerKey_, 0, 0, 0, 0, 0);\n', '\n', '    emit CreateUser(userId, adminKey_, pokerKey_, initialDeposit_);\n', '\n', '    if (initialDeposit_ > 0) {\n', '      _createDeposit(userId, initialDeposit_);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Updates an existing user, only the current adminKey is eligible calling this method.\n', '   * @param adminKey_ The new admin key for the user\n', '   * @param pokerKey_ The new poker key for the user\n', '   */\n', '  function updateUser(\n', '    uint256 userId_,\n', '    address adminKey_,\n', '    address pokerKey_\n', '  ) external override {\n', '    User storage user = users[userId_];\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '\n', '    if (adminKey_ != user.adminKey) {\n', '      user.adminKey = adminKey_;\n', '    }\n', '    if (pokerKey_ != user.pokerKey) {\n', '      user.pokerKey = pokerKey_;\n', '    }\n', '\n', '    emit UpdateUser(userId_, adminKey_, pokerKey_);\n', '  }\n', '\n', '  /*** SLASHER INTERFACE ***/\n', '\n', '  /**\n', '   * @notice Slashes the current reporter if it did not make poke() call during the given report interval\n', '   * @param slasherId_ The slasher ID\n', '   * @param times_ The multiplier for a single slashing percent\n', '   */\n', '  function slashHDH(uint256 slasherId_, uint256 times_) external virtual override {\n', '    require(msg.sender == slasher, "ONLY_SLASHER_ALLOWED");\n', '\n', '    uint256 hdhId = _hdhId;\n', '    uint256 hdhDeposit = users[hdhId].deposit;\n', '\n', '    (uint256 slasherReward, uint256 reservoirReward, ) = getSlashAmount(hdhId, times_);\n', '\n', '    uint256 amount = slasherReward.add(reservoirReward);\n', '    require(hdhDeposit >= amount, "INSUFFICIENT_HDH_DEPOSIT");\n', '\n', '    // users[reporterId].deposit = reporterDeposit - slasherReward - reservoirReward;\n', '    users[hdhId].deposit = hdhDeposit.sub(amount);\n', '\n', '    // totalDeposit = totalDeposit - reservoirReward; (slasherReward is kept on the contract)\n', '    totalDeposit = totalDeposit.sub(reservoirReward);\n', '\n', '    if (slasherReward > 0) {\n', '      // uint256 slasherDepositAfter = users[slasherId_].deposit + slasherReward\n', '      uint256 slasherDepositAfter = users[slasherId_].deposit.add(slasherReward);\n', '      users[slasherId_].deposit = slasherDepositAfter;\n', '      _trySetHighestDepositHolder(slasherId_, slasherDepositAfter);\n', '    }\n', '\n', '    if (reservoirReward > 0) {\n', '      CVP_TOKEN.transfer(reservoir, reservoirReward);\n', '    }\n', '\n', '    emit Slash(slasherId_, hdhId, slasherReward, reservoirReward);\n', '  }\n', '\n', '  /*** OWNER INTERFACE ***/\n', '\n', '  /**\n', '   * @notice The owner sets a new slasher address\n', '   * @param slasher_ The slasher address to set\n', '   */\n', '  function setSlasher(address slasher_) external override onlyOwner {\n', '    slasher = slasher_;\n', '    emit SetSlasher(slasher_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner sets the new slashing percent values\n', "   * @param slasherSlashingRewardPct_ The slasher share will be accrued on the slasher's deposit\n", '   * @param protocolSlashingRewardPct_ The protocol share will immediately be transferred to reservoir\n', '   */\n', '  function setSlashingPct(uint256 slasherSlashingRewardPct_, uint256 protocolSlashingRewardPct_)\n', '    external\n', '    override\n', '    onlyOwner\n', '  {\n', '    require(slasherSlashingRewardPct_.add(protocolSlashingRewardPct_) <= HUNDRED_PCT, "INVALID_SUM");\n', '\n', '    slasherSlashingRewardPct = slasherSlashingRewardPct_;\n', '    protocolSlashingRewardPct = protocolSlashingRewardPct_;\n', '    emit SetSlashingPct(slasherSlashingRewardPct_, protocolSlashingRewardPct_);\n', '  }\n', '\n', '  function setTimeouts(uint256 depositTimeout_, uint256 withdrawalTimeout_) external override onlyOwner {\n', '    depositTimeout = depositTimeout_;\n', '    withdrawalTimeout = withdrawalTimeout_;\n', '    emit SetTimeouts(depositTimeout_, withdrawalTimeout_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner pauses poke*-operations\n', '   */\n', '  function pause() external override onlyOwner {\n', '    _pause();\n', '  }\n', '\n', '  /**\n', '   * @notice The owner unpauses poke*-operations\n', '   */\n', '  function unpause() external override onlyOwner {\n', '    _unpause();\n', '  }\n', '\n', '  /*** PERMISSIONLESS INTERFACE ***/\n', '\n', '  /**\n', '   * @notice Set a given address as a reporter if his deposit is higher than the current highestDeposit\n', '   * @param candidateId_ Te candidate address to try\n', '   */\n', '  function setHDH(uint256 candidateId_) external override {\n', '    uint256 candidateDeposit = users[candidateId_].deposit;\n', '    uint256 prevHdhId = _hdhId;\n', '    uint256 currentReporterDeposit = users[prevHdhId].deposit;\n', '\n', '    require(candidateDeposit > currentReporterDeposit, "INSUFFICIENT_CANDIDATE_DEPOSIT");\n', '\n', '    emit ReporterChange(prevHdhId, candidateId_, _highestDeposit, currentReporterDeposit, candidateDeposit);\n', '    emit SetReporter(candidateId_, msg.sender);\n', '\n', '    _highestDeposit = candidateDeposit;\n', '    _hdhId = candidateId_;\n', '  }\n', '\n', '  /*** VIEWERS ***/\n', '\n', '  function getHDHID() external view override returns (uint256) {\n', '    return _hdhId;\n', '  }\n', '\n', '  function getHighestDeposit() external view override returns (uint256) {\n', '    return _highestDeposit;\n', '  }\n', '\n', '  function getDepositOf(uint256 userId_) external view override returns (uint256) {\n', '    return users[userId_].deposit;\n', '  }\n', '\n', '  function getPendingDepositOf(uint256 userId_) external view override returns (uint256 balance, uint256 timeout) {\n', '    return (users[userId_].pendingDeposit, users[userId_].pendingDepositTimeout);\n', '  }\n', '\n', '  function getPendingWithdrawalOf(uint256 userId_) external view override returns (uint256 balance, uint256 timeout) {\n', '    return (users[userId_].pendingWithdrawal, users[userId_].pendingWithdrawalTimeout);\n', '  }\n', '\n', '  function getSlashAmount(uint256 slasheeId_, uint256 times_)\n', '    public\n', '    view\n', '    override\n', '    returns (\n', '      uint256 slasherReward,\n', '      uint256 reservoirReward,\n', '      uint256 totalSlash\n', '    )\n', '  {\n', '    uint256 product = times_.mul(users[slasheeId_].deposit);\n', '    // slasherReward = times_ * reporterDeposit * slasherRewardPct / HUNDRED_PCT;\n', '    slasherReward = product.mul(slasherSlashingRewardPct) / HUNDRED_PCT;\n', '    // reservoirReward = times_ * reporterDeposit * reservoirSlashingRewardPct / HUNDRED_PCT;\n', '    reservoirReward = product.mul(protocolSlashingRewardPct) / HUNDRED_PCT;\n', '    // totalSlash = slasherReward + reservoirReward\n', '    totalSlash = slasherReward.add(reservoirReward);\n', '  }\n', '\n', '  function getUserStatus(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view override returns (UserStatus) {\n', '    if (userId_ == _hdhId && users[userId_].pokerKey == pokerKey_) {\n', '      return UserStatus.HDH;\n', '    }\n', '    if (users[userId_].deposit >= minDeposit_ && users[userId_].pokerKey == pokerKey_) {\n', '      return UserStatus.MEMBER;\n', '    }\n', '    return UserStatus.UNAUTHORIZED;\n', '  }\n', '\n', '  function authorizeHDH(uint256 userId_, address pokerKey_) external view override {\n', '    require(userId_ == _hdhId, "NOT_HDH");\n', '    require(users[userId_].pokerKey == pokerKey_, "INVALID_POKER_KEY");\n', '  }\n', '\n', '  function authorizeNonHDH(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view override {\n', '    require(userId_ != _hdhId, "IS_HDH");\n', '    authorizeMember(userId_, pokerKey_, minDeposit_);\n', '  }\n', '\n', '  function authorizeMember(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) public view override {\n', '    require(users[userId_].deposit >= minDeposit_, "INSUFFICIENT_DEPOSIT");\n', '    require(users[userId_].pokerKey == pokerKey_, "INVALID_POKER_KEY");\n', '  }\n', '\n', '  function requireValidAdminKey(uint256 userId_, address adminKey_) external view override {\n', '    require(users[userId_].adminKey == adminKey_, "INVALID_AMIN_KEY");\n', '  }\n', '\n', '  function requireValidAdminOrPokerKey(uint256 userId_, address adminOrPokerKey_) external view override {\n', '    require(\n', '      users[userId_].adminKey == adminOrPokerKey_ || users[userId_].pokerKey == adminOrPokerKey_,\n', '      "INVALID_AMIN_OR_POKER_KEY"\n', '    );\n', '  }\n', '\n', '  function getLastDepositChange(uint256 userId_) external view override returns (uint256) {\n', '    return _lastDepositChange[userId_];\n', '  }\n', '}']