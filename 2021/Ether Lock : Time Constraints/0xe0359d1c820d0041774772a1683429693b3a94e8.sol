['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-23\n', '*/\n', '\n', 'pragma solidity ^0.5.2;\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract Manageable is Ownable {\n', '    event ManagerAdded(address indexed manager);\n', '    event ManagerRemoved(address indexed manager);\n', '    event ManagementRenounced(address indexed manager);\n', '    event ManagementTransferred(address indexed previousManager, address indexed newManager);\n', '\n', '    mapping (address => bool) private _managers;\n', '\n', '    function addManager(address manager) public onlyOwner {\n', '        if (!isManager(manager)) {\n', '            _managers[manager] = true;\n', '            emit ManagerAdded(manager);\n', '        }\n', '    }\n', '\n', '    function removeManager(address manager) public onlyOwner {\n', '        if (isManager(manager)) {\n', '            _managers[manager] = false;\n', '            emit ManagerRemoved(manager);\n', '        }\n', '    }\n', '\n', '    function transferManagement(address manager) public onlyManager {\n', '        if (!isManager(manager)) {\n', '            _managers[manager] = true;\n', '            _managers[msg.sender] = false;\n', '            emit ManagementTransferred(msg.sender, manager);\n', '        }\n', '    }\n', '\n', '    function renounceManagement() public onlyManager {\n', '        _managers[msg.sender] = false;\n', '        emit ManagementRenounced(msg.sender);\n', '    }\n', '\n', '    function isManager(address client) public view returns (bool) {\n', '        return _managers[client];\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require(isManager(msg.sender));\n', '        _;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.2;\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // benefit is lost if 'b' is also tested.\n", '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'pragma solidity ^0.5.2;\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', 'contract Vault is Ownable, Manageable {\n', '    using SafeMath for uint256;\n', '\n', '    event Deposit(address indexed token, address indexed client, uint256 amount, uint256 fee, uint256 balance);\n', '    event Withdrawal(address indexed token, address indexed client, uint256 amount, uint256 fee, uint256 balance);\n', '    event Transfer(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 fromFee, uint256 toFee);\n', '    event BankChanged(address indexed bank);\n', '    event PermissionChanged(address indexed token, bool depositPermission, bool withdrawalPermission);\n', '    event FeeRateChanged(address indexed token, uint256 depositFeeRate, uint256 withdrawalFeeRate);\n', '    event BlacklistChanged(address indexed client, bool depositBlacklist, bool withdrawalBlacklist);\n', '\n', '    address private _bank;\n', '    mapping (address => mapping (address => uint256)) private _balances;\n', '    mapping (address => bool) private _depositPermissions;\n', '    mapping (address => bool) private _withdrawalPermissions;\n', '    mapping (address => bool) private _depositBlacklist;\n', '    mapping (address => bool) private _withdrawalBlacklist;\n', '    mapping (address => uint256) private _depositFeeRates;\n', '    mapping (address => uint256) private _withdrawalFeeRates;\n', '\n', '    constructor () public {\n', '        addManager(msg.sender);\n', '    } \n', '    \n', '    function renounceOwnership() public onlyOwner {\n', '        revert();\n', '    }\n', '\n', '    function bank() public view returns (address) {\n', '        return _bank;\n', '    }\n', '\n', '    function setBank(address account) public onlyManager {\n', '        if (bank() != account) {\n', '            _bank = account;\n', '            emit BankChanged(bank());\n', '        }\n', '    }\n', '\n', '    function balanceOf(address token, address client) public view returns (uint256) {\n', '        return _balances[token][client];\n', '    }\n', '\n', '    function _setBalance(address token, address client, uint256 amount) private {\n', '        _balances[token][client] = amount;\n', '    }\n', '\n', '    function isDepositPermitted(address token) public view returns (bool) {\n', '        return _depositPermissions[token];\n', '    }\n', '\n', '    function isWithdrawalPermitted(address token) public view returns (bool) {\n', '        return _withdrawalPermissions[token];\n', '    }\n', '\n', '    function setPermission(address token, bool depositPermission, bool withdrawalPermission) public onlyManager {\n', '        if (isDepositPermitted(token) != depositPermission || isWithdrawalPermitted(token) != withdrawalPermission) {\n', '            _depositPermissions[token] = depositPermission;\n', '            _withdrawalPermissions[token] = withdrawalPermission;\n', '            emit PermissionChanged(token, isDepositPermitted(token), isWithdrawalPermitted(token));\n', '        }\n', '    }\n', '\n', '    function multiSetPermission(address[] memory tokens, bool[] memory depositPermissions, bool[] memory withdrawalPermissions) public onlyManager {\n', '        require(tokens.length == depositPermissions.length && tokens.length == withdrawalPermissions.length);\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            setPermission(tokens[i], depositPermissions[i], withdrawalPermissions[i]);\n', '        }\n', '    }\n', '\n', '    function isDepositBlacklisted(address client) public view returns (bool) {\n', '        return _depositBlacklist[client];\n', '    }\n', '\n', '    function isWithdrawalBlacklisted(address client) public view returns (bool) {\n', '        return _withdrawalBlacklist[client];\n', '    }\n', '\n', '    function setBlacklist(address client, bool depositBlacklist, bool withdrawalBlacklist) public onlyManager {\n', '        if (isDepositBlacklisted(client) != depositBlacklist || isWithdrawalBlacklisted(client) != withdrawalBlacklist) {\n', '            _depositBlacklist[client] = depositBlacklist;\n', '            _withdrawalBlacklist[client] = withdrawalBlacklist;\n', '            emit BlacklistChanged(client, isDepositBlacklisted(client), isWithdrawalBlacklisted(client));\n', '        }\n', '    }\n', '    \n', '    function multiSetBlacklist(address[] memory clients, bool[] memory depositBlacklists, bool[] memory withdrawalBlacklists) public onlyManager {\n', '        require(clients.length == depositBlacklists.length && clients.length == withdrawalBlacklists.length);\n', '        for (uint256 i = 0; i < clients.length; i++) {\n', '            setBlacklist(clients[i], depositBlacklists[i], withdrawalBlacklists[i]);\n', '        }\n', '    }\n', '\n', '    function depositFeeRateOf(address token) public view returns (uint256) {\n', '        return _depositFeeRates[token];\n', '    }    \n', '\n', '    function withdrawalFeeRateOf(address token) public view returns (uint256) {\n', '        return _withdrawalFeeRates[token];\n', '    }    \n', '\n', '    function setFeeRate(address token, uint256 depositFeeRate, uint256 withdrawalFeeRate) public onlyManager {\n', '        if (depositFeeRateOf(token) != depositFeeRate || withdrawalFeeRateOf(token) != withdrawalFeeRate) {\n', '            _depositFeeRates[token] = depositFeeRate;\n', '            _withdrawalFeeRates[token] = withdrawalFeeRate;\n', '            emit FeeRateChanged(token, depositFeeRateOf(token), withdrawalFeeRateOf(token));\n', '        }\n', '    }\n', '    \n', '    function multiSetFeeRate(address[] memory tokens, uint256[] memory depositFees, uint256[] memory withdrawalFees) public onlyManager {\n', '        require(tokens.length == depositFees.length && tokens.length == withdrawalFees.length);\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            setFeeRate(tokens[i], depositFees[i], withdrawalFees[i]);\n', '        }\n', '    }\n', '\n', '    function () payable external {\n', '        deposit(address(0x0), msg.value);\n', '    }\n', '\n', '    function deposit(address token, uint256 amount) payable public {\n', '        if (token == address(0x0)) {\n', '            require(amount == msg.value);\n', '        }\n', '        else {\n', '            IERC20(token).transferFrom(msg.sender, address(this), amount);\n', '        }\n', '        require(amount > 0 && isDepositPermitted(token) && !isDepositBlacklisted(msg.sender));\n', '        uint256 fee = calculateFee(amount, depositFeeRateOf(token));\n', '        _setBalance(token, msg.sender, balanceOf(token, msg.sender).add(amount.sub(fee)));\n', '        _setBalance(token, bank(), balanceOf(token, bank()).add(fee));\n', '        emit Deposit(token, msg.sender, amount, fee, balanceOf(token, msg.sender));\n', '    }\n', '\n', '    function multiDeposit(address[] memory tokens, uint256[] memory amounts) payable public {\n', '        require(tokens.length == amounts.length);\n', '        bool etherProcessed = false;\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            bool isEther = tokens[i] == address(0x0);\n', '            require(!isEther || !etherProcessed);\n', '            deposit(tokens[i], amounts[i]);\n', '            if (isEther) {\n', '                etherProcessed = true;\n', '            }\n', '        }\n', '    }\n', '\n', '    function withdraw(address token, uint256 amount) public {\n', '        require(amount > 0 && isWithdrawalPermitted(token) && !isWithdrawalBlacklisted(msg.sender) && balanceOf(token, msg.sender) >= amount);\n', '        uint256 fee = calculateFee(amount, withdrawalFeeRateOf(token));\n', '        if (token == address(0x0)) {\n', '            msg.sender.transfer(amount - fee);\n', '        }\n', '        else {\n', '            IERC20(token).transfer(msg.sender, amount - fee);\n', '        }\n', '        _setBalance(token, msg.sender, balanceOf(token, msg.sender).sub(amount));\n', '        _setBalance(token, bank(), balanceOf(token, bank()).add(fee));\n', '        emit Withdrawal(token, msg.sender, amount, fee, balanceOf(token, msg.sender));\n', '    }\n', '\n', '    function multiWithdraw(address[] memory tokens, uint256[] memory amounts) public {\n', '        require(tokens.length == amounts.length);\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            withdraw(tokens[i], amounts[i]);\n', '        }\n', '    }\n', '\n', '    function transfer(address token, address from, address to, uint256 amount, uint256 fromFeeRate, uint256 toFeeRate) public onlyManager {\n', '        uint256 fromFee = calculateFee(amount, fromFeeRate);\n', '        uint256 toFee = calculateFee(amount, toFeeRate);\n', '        require (amount > 0 && balanceOf(token, from) >= amount.add(fromFee));\n', '        _setBalance(token, from, balanceOf(token, from).sub(amount.add(fromFee)));\n', '        _setBalance(token, to, balanceOf(token, to).add(amount.sub(toFee)));\n', '        _setBalance(token, bank(), balanceOf(token, bank()).add(fromFee).add(toFee));\n', '        emit Transfer(token, from, to, amount, fromFee, toFee);\n', '    }\n', '\n', '    function multiTransfer(address[] memory tokens, address[] memory froms, address[] memory tos, uint256[] memory amounts, uint256[] memory fromFeeRates, uint256[] memory toFeeRates) public onlyManager {\n', '        require (tokens.length == froms.length && tokens.length == tos.length && tokens.length == amounts.length && tokens.length == fromFeeRates.length && tokens.length == toFeeRates.length);\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            transfer(tokens[i], froms[i], tos[i], amounts[i], fromFeeRates[i], toFeeRates[i]);\n', '        }\n', '    }\n', '\n', '    function calculateFee(uint256 amount, uint256 feeRate) public pure returns (uint256) {\n', '        return amount.mul(feeRate).div(1 ether);\n', '    }\n', '}']