['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./Ownable.sol";\n', 'import "./Math.sol";\n', 'import "./ERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./Pausable.sol";\n', '\n', 'import "./IMasterChef.sol";\n', '\n', '// https://docs.synthetix.io/contracts/source/contracts/stakingrewards\n', 'contract StakingRewardsWithMasterChef is ReentrancyGuard, Pausable, Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    address public timelock;\n', '\n', '    IERC20 public rewardsToken;\n', '    IERC20 public stakingToken;\n', '\n', '    IERC20 public sushiToken = IERC20(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n', '    IMasterChef public sushiMasterChef = IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\n', '    uint256 public masterchefPID;\n', '\n', '    uint256 public periodFinish = 0;\n', '    uint256 public rewardRate = 0;\n', '    uint256 public rewardsDuration = 30 days;\n', '    uint256 public lastUpdateTime;\n', '    uint256 public rewardPerTokenStored;\n', '\n', '    uint256 public sushiPerTokenStored;\n', '    uint256 public sushiBalanceAtLastUpdate;\n', '\n', '    mapping(address => uint256) public userRewardPerTokenPaid;\n', '    mapping(address => uint256) public userSushiPerTokenPaid;\n', '\n', '    mapping(address => uint256) public rewards;\n', '    mapping(address => uint256) public sushiRewards;\n', '\n', '    uint256 private _totalSupply;\n', '    mapping(address => uint256) private _balances;\n', '\n', '    /* ========== CONSTRUCTOR ========== */\n', '\n', '    constructor(\n', '        address _timelock,\n', '        address _owner,\n', '        address _rewardsToken,\n', '        address _stakingToken,\n', '        uint256 _masterchefPID\n', '    ) {\n', '        timelock = _timelock;\n', '\n', '        rewardsToken = IERC20(_rewardsToken);\n', '        stakingToken = IERC20(_stakingToken);\n', '\n', '        masterchefPID = _masterchefPID;\n', '\n', '        transferOwnership(_owner);\n', '    }\n', '\n', '    /* ========== VIEWS ========== */\n', '\n', '    function totalSupply() external view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) external view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint256) {\n', '        return Math.min(block.timestamp, periodFinish);\n', '    }\n', '\n', '    function rewardPerToken() public view returns (uint256) {\n', '        if (_totalSupply == 0) {\n', '            return rewardPerTokenStored;\n', '        }\n', '        return\n', '            rewardPerTokenStored.add(\n', '                lastTimeRewardApplicable().sub(lastUpdateTime).mul(rewardRate).mul(1e18).div(_totalSupply)\n', '            );\n', '    }\n', '\n', '    function sushiPerToken() public view returns (uint256) {\n', '        if (_totalSupply == 0) {\n', '            return sushiPerTokenStored;\n', '        }\n', '\n', '        uint256 pendingSushi = sushiMasterChef.pendingSushi(masterchefPID, address(this));\n', '        return\n', '            sushiPerTokenStored.add(\n', '                sushiToken.balanceOf(address(this)).add(pendingSushi).sub(sushiBalanceAtLastUpdate).mul(1e18).div(\n', '                    _totalSupply\n', '                )\n', '            );\n', '    }\n', '\n', '    function earned(address account) public view returns (uint256) {\n', '        return\n', '            _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(\n', '                rewards[account]\n', '            );\n', '    }\n', '\n', '    function sushiEarned(address account) public view returns (uint256) {\n', '        return\n', '            _balances[account].mul(sushiPerToken().sub(userSushiPerTokenPaid[account])).div(1e18).add(\n', '                sushiRewards[account]\n', '            );\n', '    }\n', '\n', '    function getRewardForDuration() external view returns (uint256) {\n', '        return rewardRate.mul(rewardsDuration);\n', '    }\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    function stake(uint256 amount) external nonReentrant whenNotPaused updateReward(msg.sender) {\n', '        require(amount > 0, "Cannot stake 0");\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[msg.sender] = _balances[msg.sender].add(amount);\n', '        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n', '\n', '        // Deposit into masterchef\n', '        stakingToken.safeApprove(address(sushiMasterChef), 0);\n', '        stakingToken.safeApprove(address(sushiMasterChef), amount);\n', '        sushiMasterChef.deposit(masterchefPID, amount);\n', '\n', '        emit Staked(msg.sender, amount);\n', '    }\n', '\n', '    function withdraw(uint256 amount) public nonReentrant updateReward(msg.sender) {\n', '        require(amount > 0, "Cannot withdraw 0");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '\n', '        // Withdraw from masterchef\n', '        sushiMasterChef.withdraw(masterchefPID, amount);\n', '\n', '        // Send to user\n', '        stakingToken.safeTransfer(msg.sender, amount);\n', '\n', '        emit Withdrawn(msg.sender, amount);\n', '    }\n', '\n', '    function getReward() public nonReentrant updateReward(msg.sender) {\n', '        uint256 reward = rewards[msg.sender];\n', '        uint256 sushiReward = sushiRewards[msg.sender];\n', '\n', '        if (reward > 0) {\n', '            rewards[msg.sender] = 0;\n', '            rewardsToken.safeTransfer(msg.sender, reward);\n', '        }\n', '\n', '        if (sushiReward > 0) {\n', '            sushiRewards[msg.sender] = 0;\n', '            sushiToken.safeTransfer(msg.sender, sushiReward);\n', '\n', '            // Remember to update sushi balance\n', '            sushiBalanceAtLastUpdate = sushiBalanceAtLastUpdate.sub(sushiReward);\n', '        }\n', '\n', '        emit RewardPaid(msg.sender, reward, sushiReward);\n', '    }\n', '\n', '    function exit() external {\n', '        withdraw(_balances[msg.sender]);\n', '        getReward();\n', '    }\n', '\n', '    /* ========== RESTRICTED FUNCTIONS ========== */\n', '\n', '    function notifyRewardAmount(uint256 reward) external onlyOwner updateReward(address(0)) {\n', '        if (block.timestamp >= periodFinish) {\n', '            rewardRate = reward.div(rewardsDuration);\n', '        } else {\n', '            uint256 remaining = periodFinish.sub(block.timestamp);\n', '            uint256 leftover = remaining.mul(rewardRate);\n', '            rewardRate = reward.add(leftover).div(rewardsDuration);\n', '        }\n', '\n', '        // Ensure the provided reward amount is not more than the balance in the contract.\n', '        // This keeps the reward rate in the right range, preventing overflows due to\n', '        // very high values of rewardRate in the earned and rewardsPerToken functions;\n', '        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n', '        uint256 balance = rewardsToken.balanceOf(address(this));\n', '        require(rewardRate <= balance.div(rewardsDuration), "Provided reward too high");\n', '\n', '        lastUpdateTime = block.timestamp;\n', '        periodFinish = block.timestamp.add(rewardsDuration);\n', '\n', '        emit RewardAdded(reward);\n', '    }\n', '\n', '    // Added to support recovering LP Rewards from other systems such as BAL to be distributed to holders\n', '    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\n', '        require(tokenAddress != address(stakingToken), "Cannot withdraw the staking token");\n', '        IERC20(tokenAddress).safeTransfer(owner(), tokenAmount);\n', '        emit Recovered(tokenAddress, tokenAmount);\n', '    }\n', '\n', '    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n', '        require(\n', '            block.timestamp > periodFinish,\n', '            "Previous rewards period must be complete before changing the duration for the new period"\n', '        );\n', '        rewardsDuration = _rewardsDuration;\n', '        emit RewardsDurationUpdated(rewardsDuration);\n', '    }\n', '\n', '    function setPaused(bool _p) external onlyOwner {\n', '        if (_p) {\n', '            _pause();\n', '        } else {\n', '            _unpause();\n', '        }\n', '    }\n', '\n', '    function emergencyWithdraw(address _destination) external {\n', '        require(msg.sender == timelock);\n', '\n', '        sushiMasterChef.emergencyWithdraw(masterchefPID);\n', '        stakingToken.transfer(_destination, stakingToken.balanceOf(address(this)));\n', '    }\n', '\n', '    /* ========== MODIFIERS ========== */\n', '\n', '    modifier updateReward(address account) {\n', '        rewardPerTokenStored = rewardPerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '\n', '        // Get rewards from masterchef first\n', '        // to store the delta\n', '        sushiMasterChef.withdraw(masterchefPID, 0);\n', '        sushiPerTokenStored = sushiPerToken();\n', '        sushiBalanceAtLastUpdate = sushiToken.balanceOf(address(this));\n', '\n', '        if (account != address(0)) {\n', '            rewards[account] = earned(account);\n', '            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n', '\n', '            sushiRewards[account] = sushiEarned(account);\n', '            userSushiPerTokenPaid[account] = sushiPerTokenStored;\n', '        }\n', '\n', '        _;\n', '    }\n', '\n', '    /* ========== EVENTS ========== */\n', '\n', '    event RewardAdded(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward, uint256 sushiReward);\n', '    event RewardsDurationUpdated(uint256 newDuration);\n', '    event Recovered(address token, uint256 amount);\n', '}']