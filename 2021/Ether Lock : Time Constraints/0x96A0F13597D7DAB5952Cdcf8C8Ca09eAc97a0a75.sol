['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'pragma abicoder v2;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol"; \n', 'import "./InlineInterface.sol";\n', 'import "./TransferHelper.sol";\n', '\n', 'contract InlineDatabase is Ownable{\n', '    \n', '    using SafeMath for uint256;\n', '    mapping (address=>uint256) tokensStaked; //amount of XIV staked by user + incentive from betting\n', '    mapping(address=> uint256) actualAmountStakingByUser; // XIV staked by users.\n', "    address[] userStakedAddress; // array of user's address who has staked..\n", '    address[] tempArray;\n', '    uint256 tokenStakedAmount; // total Amount currently staked by all users.\n', '    uint256 minStakeXIVAmount; // min amount that user can bet on.\n', '    uint256 maxStakeXIVAmount; // max amount that user can bet on.\n', '    uint256 totalTransactions; // sum of all transactions\n', '    uint256 maxLPLimit; // totalamount that can be staked in LP\n', '    mapping(address=>bool) isStakeMapping;\n', '    \n', '    uint256 minLPvalue; // min amount of token that user can stake in LP\n', '    mapping(address=>InlineDatabaseLib.LPLockedInfo) lockingPeriodForLPMapping; // time for which staked value is locked \n', '    \n', '    uint256 betFactorLP; // this is the ratio according to which users can bet considering the amount staked..\n', '    \n', '    address  public XIVMainContractAddress;\n', '    address  public XIVBettingFixedContractAddress;\n', '    address  public XIVBettingFlexibleContractAddress;\n', '    \n', '    //mainnet\n', '    address oracleWrapperContractAddress = 0x70A89e52faEFe600A2a0f6D12804CB613F61BE61; //address of oracle wrapper from where the prices would be fetched\n', '    address XIVTokenContractAddress = 0x44f262622248027f8E2a8Fb1090c4Cf85072392C; //XIV contract address\n', '    address public adminAddress=0x1Cff36DeBD53EEB3264fD75497356132C4067632;\n', '    \n', '  \n', '    // // mapping and arry of the currencies in the flash individuals vaults.\n', '    // mapping(address=>InlineDatabaseLib.DefiCoin) flashVaultMapping;\n', '    // address[] flashVaultContractAddressArray;\n', '   /*\n', '    * 1--> defi coins, 2--> chain coins, 3--> nft coins \n', '    */\n', '   /*\n', '   * fixed individuals starts\n', '   */\n', '    // mapping and arry of the currencies in the fixed individuals vaults.\n', '    mapping(uint256=>mapping(address=>InlineDatabaseLib.DefiCoin)) fixedMapping;\n', '    \n', '    address[] allDefiCoinFixedContractAddressArray;\n', '    address[] allChainCoinFixedContractAddressArray;\n', '    address[] allNftCoinFixedContractAddressArray;\n', '    \n', '    // array of daysCount and its % drop and other values for fixed\n', '    InlineDatabaseLib.FixedInfo[] fixedDefiCoinArray;\n', '   \n', '    /*\n', '   * flexible individuals starts\n', '   */\n', '    // mapping and arry of the currencies in the flexible individuals vaults.\n', '    mapping(uint256=>mapping(address=>InlineDatabaseLib.DefiCoin)) flexibleMapping;\n', '    \n', '    address[] allDefiCoinFlexibleContractAddressArray;\n', '    address[] allChainCoinFlexibleContractAddressArray;\n', '    address[] allNftCoinFlexibleContractAddressArray;\n', '    \n', '    // flexible individual dropvalue and other values\n', '    InlineDatabaseLib.FlexibleInfo[]  flexibleDefiCoinArray;\n', '    // flexible individual time periods days\n', '    InlineDatabaseLib.TimePeriod[] flexibleDefiCoinTimePeriodArray;\n', '    \n', '    \n', '    /*\n', '   * fixed and flexible adding currency index starts\n', '   */\n', '    // mapping and arry of the currencies for all index vaults.\n', '    mapping(uint256=>mapping(address=>InlineDatabaseLib.IndexCoin)) indexMapping;\n', '    address[]  allIndexDefiCoinContractAddressArray;\n', '    address[]  allIndexChainCoinContractAddressArray;\n', '    address[]  allIndexNftCoinContractAddressArray;\n', '    \n', '    /*\n', '   * flexible index starts\n', '   */\n', '    // flexible index dropvalue and other values\n', '    InlineDatabaseLib.FlexibleInfo[]  flexibleIndexArray;\n', '    // flexible index time periods days\n', '    InlineDatabaseLib.TimePeriod[]  flexibleIndexTimePeriodArray;\n', '    \n', '    /*\n', '   * fixed index starts\n', '   */\n', '    InlineDatabaseLib.FixedInfo[]  fixedDefiIndexArray;  \n', '    \n', '    \n', '    // this contains the values on which index bet is placed\n', '    mapping(uint256=>InlineDatabaseLib.BetPriceHistory) betPriceHistoryMapping;\n', '    \n', '    \n', '    // this include array of imdex on which bet is placed. key will be betId and value will be array of all index...\n', '    mapping(uint256=>InlineDatabaseLib.IndexCoin[]) betIndexArray;\n', '    \n', '    mapping(uint256=>uint256) betBaseIndexValue; //10**8 index value \n', '    mapping(uint256=>uint256) betActualIndexValue; // marketcap value\n', '    \n', '    uint256 betid;\n', '    \n', '    InlineDatabaseLib.BetInfo[]  betArray;\n', '    mapping(uint256=>uint256)  findBetInArrayUsingBetIdMapping; // getting the bet index using betid... Key is betId and value will be index in the betArray...\n', '    mapping(address=> uint256[])  betAddressesArray;\n', '    \n', '    uint256 plentyOneDayPercentage; // percentage in 10**2\n', '    mapping(uint256=>uint256)  plentyThreeDayPercentage; // key is day and value is percentage in 10**2\n', '    mapping(uint256=>uint256)  plentySevenDayPercentage; // key is day and value is percentage in 10**2\n', '    \n', '    uint256[] daysArray;\n', '    \n', '    address[] userAddressUsedForBetting;\n', '    \n', '    \n', '    mapping(address=>mapping(uint256=>mapping(address=>bool))) existingBetCheckMapping;\n', '    \n', '    event BetDetails(uint256 indexed betId, uint256 indexed status, uint256 indexed betEndTime);\n', '    event LPEvent(uint256 typeOfLP, address indexed userAddress, uint256 amount, uint256 timestamp);\n', '    \n', '    function emitBetDetails(uint256  betId, uint256  status, uint256  betEndTime) external onlyMyContracts{\n', '        emit BetDetails( betId, status, betEndTime);\n', '    }\n', '    function emitLPEvent(uint256 typeOfLP, address userAddress, uint256 amount, uint256 timestamp) external onlyMyContracts{\n', '        emit LPEvent(typeOfLP,  userAddress, amount, timestamp);\n', '    }\n', '    function updateExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress,bool status) external onlyMyContracts{\n', '        existingBetCheckMapping[_userAddress][_betType][_BetContractAddress]=status;\n', '    }\n', '    function getExistingBetCheckMapping(address _userAddress,uint256 _betType, address _BetContractAddress) external view returns(bool){\n', '        return (existingBetCheckMapping[_userAddress][_betType][_BetContractAddress]);\n', '    }\n', '    \n', '     function addFixedDefiCoinArray(uint64 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n', '         bool isAvailable=false;\n', '         for(uint256 i=0;i<fixedDefiCoinArray.length;i++){\n', '             if(fixedDefiCoinArray[i].daysCount==_daysCount){\n', '                 isAvailable=true;\n', '                 break;\n', '             }\n', '         }\n', '        require(!isAvailable,"Already have this data.");\n', '        InlineDatabaseLib.FixedInfo memory fobject=InlineDatabaseLib.FixedInfo({\n', '            id:(uint128)(fixedDefiCoinArray.length),\n', '            daysCount:_daysCount,\n', '            upDownPercentage:_upDownPercentage,\n', '            riskFactor:_riskFactor,\n', '            rewardFactor:_rewardFactor,\n', '            status:true\n', '        });\n', '        fixedDefiCoinArray.push(fobject);\n', '        addDaysToDayArray(_daysCount);\n', '    }\n', '    function updateFixedDefiCoinArray(uint256 index,uint64 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n', '        fixedDefiCoinArray[index].daysCount=_daysCount;\n', '        fixedDefiCoinArray[index].upDownPercentage=_upDownPercentage;\n', '        fixedDefiCoinArray[index].riskFactor=_riskFactor;\n', '        fixedDefiCoinArray[index].rewardFactor=_rewardFactor;\n', '        fixedDefiCoinArray[index].status=_status;\n', '        addDaysToDayArray(_daysCount);\n', '    }\n', '    \n', '    function addUpdateForFixedCoin(address _ContractAddress,  string memory _currencySymbol,\n', '                                            uint16 _OracleType, bool _Status, uint256 coinType) public onlyOwner{\n', '        require(coinType>0 && coinType<=3,"Please enter valid CoinType");\n', '        // add update defi felxible coin\n', '        InlineDatabaseLib.DefiCoin memory dCoin=InlineDatabaseLib.DefiCoin({\n', '            oracleType:_OracleType,\n', '            currencySymbol:_currencySymbol,\n', '            status:_Status\n', '        });\n', '            fixedMapping[coinType][_ContractAddress]=dCoin;\n', '        // check wheather contract exists in allFlexibleContractAddressArray array\n', '        if(!contractAvailableInArray(_ContractAddress,\n', '        coinType==1?allDefiCoinFixedContractAddressArray:(coinType==2?allChainCoinFixedContractAddressArray:allNftCoinFixedContractAddressArray))){\n', '            (coinType==1?allDefiCoinFixedContractAddressArray:(coinType==2?allChainCoinFixedContractAddressArray:allNftCoinFixedContractAddressArray)).push(_ContractAddress);\n', '        }\n', '    }\n', '    \n', '    function getFixedMapping(address _betContractAddress, uint256 coinType) external view returns(InlineDatabaseLib.DefiCoin memory){\n', '        return (fixedMapping[coinType][_betContractAddress]);\n', '    }\n', '    function getFixedContractAddressArray(uint256 coinType) external view returns(address[] memory){\n', '        return ((coinType==1?allDefiCoinFixedContractAddressArray:(coinType==2?allChainCoinFixedContractAddressArray:allNftCoinFixedContractAddressArray)));\n', '    }\n', '    \n', '    function addUpdateForFlexible(address _ContractAddress,  string memory _currencySymbol,\n', '                                            uint16 _OracleType, bool _Status, uint256 coinType) public onlyOwner{\n', '        require(coinType>0 && coinType<=3,"Please enter valid CoinType");\n', '        // add update defi felxible coin\n', '        InlineDatabaseLib.DefiCoin memory dCoin=InlineDatabaseLib.DefiCoin({\n', '            oracleType:_OracleType,\n', '            currencySymbol:_currencySymbol,\n', '            status:_Status\n', '        });\n', '        flexibleMapping[coinType][_ContractAddress]=dCoin;\n', '        // check wheather contract exists in allFlexibleContractAddressArray array\n', '        if(!contractAvailableInArray(_ContractAddress,\n', '        coinType==1?allDefiCoinFlexibleContractAddressArray:(coinType==2?allChainCoinFlexibleContractAddressArray:allNftCoinFlexibleContractAddressArray))){\n', '            (coinType==1?allDefiCoinFlexibleContractAddressArray:(coinType==2?allChainCoinFlexibleContractAddressArray:allNftCoinFlexibleContractAddressArray)).push(_ContractAddress);\n', '        }\n', '    }\n', '    \n', '    function getFlexibleMapping(address _betContractAddress, uint256 coinType) external view returns(InlineDatabaseLib.DefiCoin memory){\n', '        return (flexibleMapping[coinType][_betContractAddress]);\n', '    }\n', '    function getFlexibleContractAddressArray(uint256 coinType) external view returns(address[] memory){\n', '        return (coinType==1?allDefiCoinFlexibleContractAddressArray:(coinType==2?allChainCoinFlexibleContractAddressArray:allNftCoinFlexibleContractAddressArray));\n', '    }\n', '    function addflexibleDefiCoinArray(uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n', '        InlineDatabaseLib.FlexibleInfo memory fobject=InlineDatabaseLib.FlexibleInfo({\n', '            id:(uint128)(flexibleDefiCoinArray.length),\n', '            upDownPercentage:_upDownPercentage,\n', '            riskFactor:_riskFactor,\n', '            rewardFactor:_rewardFactor,\n', '            status:true\n', '        });\n', '        flexibleDefiCoinArray.push(fobject);\n', '    }\n', '    function updateflexibleDefiCoinArray(uint256 index,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n', '        flexibleDefiCoinArray[index].upDownPercentage=_upDownPercentage;\n', '        flexibleDefiCoinArray[index].riskFactor=_riskFactor;\n', '        flexibleDefiCoinArray[index].rewardFactor=_rewardFactor;\n', '        flexibleDefiCoinArray[index].status=_status;\n', '    }\n', '     function addFlexibleDefiCoinTimePeriodArray(uint64 _tdays) public onlyOwner{\n', '         bool isAvailable=false;\n', '         for(uint64 i=0;i<flexibleDefiCoinTimePeriodArray.length;i++){\n', '             if(flexibleDefiCoinTimePeriodArray[i]._days==_tdays){\n', '                 isAvailable=true;\n', '                 break;\n', '             }\n', '         }\n', '        require(!isAvailable,"Already have this data.");\n', '         InlineDatabaseLib.TimePeriod memory tobject= InlineDatabaseLib.TimePeriod({\n', '             _days:_tdays,\n', '             status:true\n', '         });\n', '        flexibleDefiCoinTimePeriodArray.push(tobject);\n', '        addDaysToDayArray(_tdays);\n', '    }\n', '    function updateFlexibleDefiCoinTimePeriodArray(uint256 index, uint64 _tdays, bool _status) public onlyOwner{\n', '        flexibleDefiCoinTimePeriodArray[index]._days=_tdays;\n', '        flexibleDefiCoinTimePeriodArray[index].status=_status;\n', '        addDaysToDayArray(_tdays);\n', '    }\n', '    \n', '    function getFlexibleDefiCoinTimePeriodArray() external view returns(InlineDatabaseLib.TimePeriod[] memory){\n', '        return flexibleDefiCoinTimePeriodArray;\n', '    }\n', '    \n', '     function addUpdateForIndexCoin(InlineDatabaseLib.IndexCoin[] memory tupleCoinArray, uint256 coinType) public onlyOwner{\n', '        // add update index fixed coin\n', '        tempArray=new address[](0);\n', '        if(coinType==1){\n', '            allIndexDefiCoinContractAddressArray=tempArray;\n', '        }else if(coinType==2){\n', '            allIndexChainCoinContractAddressArray=tempArray;\n', '        }else{\n', '            allIndexNftCoinContractAddressArray=tempArray;\n', '        }\n', '        for(uint256 i=0;i<tupleCoinArray.length;i++){\n', '            indexMapping[coinType][tupleCoinArray[i].contractAddress]=tupleCoinArray[i];\n', '            // check wheather contract exists in allFixedContractAddressArray array\n', '            if(!contractAvailableInArray(tupleCoinArray[i].contractAddress,\n', '            coinType==1?allIndexDefiCoinContractAddressArray:(coinType==2?allIndexChainCoinContractAddressArray:allIndexNftCoinContractAddressArray))){\n', '                if(coinType==1){\n', '                    allIndexDefiCoinContractAddressArray.push(tupleCoinArray[i].contractAddress);\n', '                }else if(coinType==2){\n', '                    allIndexChainCoinContractAddressArray.push(tupleCoinArray[i].contractAddress);\n', '                }else{\n', '                    allIndexNftCoinContractAddressArray.push(tupleCoinArray[i].contractAddress);\n', '                }\n', '                \n', '            }\n', '        }\n', '    }\n', '    \n', '    function getAllIndexContractAddressArray(uint256 coinType) external view returns(address[] memory){\n', '        return (coinType==1?allIndexDefiCoinContractAddressArray:(coinType==2?allIndexChainCoinContractAddressArray:allIndexNftCoinContractAddressArray));\n', '    }\n', '    function getIndexMapping(address _ContractAddress, uint256 coinType) external view returns(InlineDatabaseLib.IndexCoin memory){\n', '        return (indexMapping[coinType][_ContractAddress]);\n', '    }\n', '    function addflexibleIndexCoinArray(uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n', '        InlineDatabaseLib.FlexibleInfo memory fobject=InlineDatabaseLib.FlexibleInfo({\n', '            id:(uint128)(flexibleIndexArray.length),\n', '            upDownPercentage:_upDownPercentage,\n', '            riskFactor:_riskFactor,\n', '            rewardFactor:_rewardFactor,\n', '            status:true\n', '        });\n', '        flexibleIndexArray.push(fobject);\n', '    }\n', '    function updateflexibleIndexCoinArray(uint256 index,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n', '        flexibleIndexArray[index].upDownPercentage=_upDownPercentage;\n', '        flexibleIndexArray[index].riskFactor=_riskFactor;\n', '        flexibleIndexArray[index].rewardFactor=_rewardFactor;\n', '        flexibleIndexArray[index].status=_status;\n', '    }\n', '    \n', '    function addFlexibleIndexTimePeriodArray(uint64 _tdays) public onlyOwner{\n', '         bool isAvailable=false;\n', '         for(uint64 i=0;i<flexibleIndexTimePeriodArray.length;i++){\n', '             if(flexibleIndexTimePeriodArray[i]._days==_tdays){\n', '                 isAvailable=true;\n', '                 break;\n', '             }\n', '         }\n', '        require(!isAvailable,"Already have this data.");\n', '         InlineDatabaseLib.TimePeriod memory tobject= InlineDatabaseLib.TimePeriod({\n', '             _days:_tdays,\n', '             status:true\n', '         });\n', '        flexibleIndexTimePeriodArray.push(tobject);\n', '        addDaysToDayArray(_tdays);\n', '    }\n', '    function updateFlexibleIndexTimePeriodArray(uint256 index, uint64 _tdays, bool _status) public onlyOwner{\n', '        flexibleIndexTimePeriodArray[index]._days=_tdays;\n', '        flexibleIndexTimePeriodArray[index].status=_status;\n', '        addDaysToDayArray(_tdays);\n', '    }\n', '    function getFlexibleIndexTimePeriodArray() external view returns(InlineDatabaseLib.TimePeriod[] memory){\n', '        return flexibleIndexTimePeriodArray;\n', '    }\n', '   function addFixedDefiIndexArray(uint64 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor) public onlyOwner{\n', '         bool isAvailable=false;\n', '         for(uint64 i=0;i<fixedDefiIndexArray.length;i++){\n', '             if(fixedDefiIndexArray[i].daysCount==_daysCount){\n', '                 isAvailable=true;\n', '                 break;\n', '             }\n', '         }\n', '        require(!isAvailable,"Already have this data.");\n', '        InlineDatabaseLib.FixedInfo memory fobject=InlineDatabaseLib.FixedInfo({\n', '            id:(uint128)(fixedDefiIndexArray.length),\n', '            daysCount:_daysCount,\n', '            upDownPercentage:_upDownPercentage,\n', '            riskFactor:_riskFactor,\n', '            rewardFactor:_rewardFactor,\n', '            status:true\n', '        });\n', '        fixedDefiIndexArray.push(fobject);\n', '        addDaysToDayArray(_daysCount);\n', '    }\n', '    function updateFixedDefiIndexArray(uint256 index,uint64 _daysCount,uint16 _upDownPercentage, uint16 _riskFactor, uint16 _rewardFactor, bool _status) public onlyOwner{\n', '        fixedDefiIndexArray[index].daysCount=_daysCount;\n', '        fixedDefiIndexArray[index].upDownPercentage=_upDownPercentage;\n', '        fixedDefiIndexArray[index].riskFactor=_riskFactor;\n', '        fixedDefiIndexArray[index].rewardFactor=_rewardFactor;\n', '        fixedDefiIndexArray[index].status=_status;\n', '        addDaysToDayArray(_daysCount);\n', '    }\n', '    function contractAvailableInArray(address _ContractAddress,address[] memory _contractArray) internal pure returns(bool){\n', '        for(uint256 i=0;i<_contractArray.length;i++){\n', '            if(_ContractAddress==_contractArray[i]){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }  \n', '    \n', '    function updateMaxStakeXIVAmount(uint256 _maxStakeXIVAmount) external onlyOwner{\n', '        maxStakeXIVAmount=_maxStakeXIVAmount;\n', '    }\n', '    function getMaxStakeXIVAmount() external view returns(uint256){\n', '        return maxStakeXIVAmount;\n', '    }\n', '    function updateMinStakeXIVAmount(uint256 _minStakeXIVAmount) external onlyOwner{\n', '        minStakeXIVAmount=_minStakeXIVAmount;\n', '    }\n', '    function getMinStakeXIVAmount() external view returns(uint256){\n', '        return minStakeXIVAmount;\n', '    }\n', '    function updateMinLPvalue(uint256 _minLPvalue) external onlyOwner{\n', '        minLPvalue=_minLPvalue;\n', '    }\n', '    function getMinLPvalue() external view returns(uint256){\n', '        return minLPvalue;\n', '    }\n', '    function updateBetFactorLP(uint256 _betFactorLP) external onlyOwner{\n', '        betFactorLP=_betFactorLP;\n', '    }\n', '    function getBetFactorLP() external view returns(uint256){\n', '        return betFactorLP;\n', '    }\n', '    \n', '    function updateTotalTransactions(uint256 _totalTransactions) external onlyMyContracts{\n', '        totalTransactions=_totalTransactions;\n', '    }\n', '    function getTotalTransactions() external view returns(uint256){\n', '        return totalTransactions;\n', '    }\n', '    function updateMaxLPLimit(uint256 _maxLPLimit) external onlyOwner{\n', '        maxLPLimit=_maxLPLimit;\n', '    }\n', '    function getMaxLPLimit() external view returns(uint256){\n', '        return maxLPLimit;\n', '    }\n', '    \n', '    function updateXIVMainContractAddress(address _XIVMainContractAddress) external onlyOwner{\n', '        XIVMainContractAddress=_XIVMainContractAddress;\n', '    }\n', '    function updateXIVBettingFixedContractAddress(address _XIVBettingFixedContractAddress) external onlyOwner{\n', '        XIVBettingFixedContractAddress=_XIVBettingFixedContractAddress;\n', '    }\n', '    function updateXIVBettingFlexibleContractAddress(address _XIVBettingFlexibleContractAddress) external onlyOwner{\n', '        XIVBettingFlexibleContractAddress=_XIVBettingFlexibleContractAddress;\n', '    }\n', '    function updateXIVTokenContractAddress(address _XIVTokenContractAddress) external onlyOwner{\n', '        XIVTokenContractAddress=_XIVTokenContractAddress;\n', '    }\n', '    function getXIVTokenContractAddress() external view returns(address){\n', '        return XIVTokenContractAddress;\n', '    }\n', '    function updateBetBaseIndexValue(uint256 _betBaseIndexValue, uint256 coinType) external onlyMyContracts{\n', '        betBaseIndexValue[coinType]=_betBaseIndexValue;\n', '    }\n', '    function getBetBaseIndexValue(uint256 coinType) external view returns(uint256){\n', '        return betBaseIndexValue[coinType];\n', '    }\n', '    function updateBetActualIndexValue(uint256 _betActualIndexValue, uint256 coinType) external onlyMyContracts{\n', '        betActualIndexValue[coinType]=_betActualIndexValue;\n', '    }\n', '    function getBetActualIndexValue(uint256 coinType) external view returns(uint256){\n', '        return betActualIndexValue[coinType];\n', '    }\n', '    function transferTokens(address contractAddress,address userAddress,uint256 amount) external onlyMyContracts {\n', '        Token tokenObj=Token(contractAddress);\n', '        require(tokenObj.balanceOf(address(this))>= amount, "Tokens not available");\n', '        TransferHelper.safeTransfer(contractAddress,userAddress, amount);\n', '    }\n', '    function transferFromTokens(address contractAddress,address fromAddress, address toAddress,uint256 amount) external onlyMyContracts {\n', '        require(checkTokens(contractAddress,amount,fromAddress));\n', '        TransferHelper.safeTransferFrom(contractAddress,fromAddress, toAddress, amount);\n', '    }\n', '    function checkTokens(address contractAddress,uint256 amount, address fromAddress) internal view returns(bool){\n', '         Token tokenObj = Token(contractAddress);\n', '        //check if user has balance\n', '        require(tokenObj.balanceOf(fromAddress) >= amount, "You don\'t have enough XIV balance");\n', '        //check if user has provided allowance\n', '        require(tokenObj.allowance(fromAddress,address(this)) >= amount, \n', '        "Please allow smart contract to spend on your behalf");\n', '        return true;\n', '    }\n', '    function getTokensStaked(address userAddress) external view returns(uint256){\n', '        return (tokensStaked[userAddress]);\n', '    }\n', '    function updateTokensStaked(address userAddress, uint256 amount) external onlyMyContracts{\n', '        tokensStaked[userAddress]=amount;\n', '    }\n', '    function getActualAmountStakedByUser(address userAddress) external view returns(uint256){\n', '        return (actualAmountStakingByUser[userAddress]);\n', '    } \n', '    function updateIsStakeMapping(address userAddress,bool isStake) external onlyMyContracts{\n', '        isStakeMapping[userAddress]=(isStake);\n', '    }\n', '    function getIsStakeMapping(address userAddress) external view returns(bool){\n', '        return (isStakeMapping[userAddress]);\n', '    }\n', '    function updateActualAmountStakedByUser(address userAddress, uint256 amount) external onlyMyContracts{\n', '        actualAmountStakingByUser[userAddress]=amount;\n', '    }\n', '    \n', '    function getLockingPeriodForLPMapping(address userAddress) external view returns(InlineDatabaseLib.LPLockedInfo memory){\n', '        return (lockingPeriodForLPMapping[userAddress]);\n', '    }\n', '    function updateLockingPeriodForLPMapping(address userAddress, uint256 _amountLocked, uint256 _lockedTimeStamp) external onlyMyContracts{\n', '        InlineDatabaseLib.LPLockedInfo memory lpLockedInfo= InlineDatabaseLib.LPLockedInfo({\n', '            lockedTimeStamp:_lockedTimeStamp,\n', '            amountLocked:_amountLocked\n', '        });\n', '        lockingPeriodForLPMapping[userAddress]=lpLockedInfo;\n', '    }\n', '    \n', '    function getTokenStakedAmount() external view returns(uint256){\n', '        return (tokenStakedAmount);\n', '    }\n', '    function updateTokenStakedAmount(uint256 _tokenStakedAmount) external onlyMyContracts{\n', '        tokenStakedAmount=_tokenStakedAmount;\n', '    }\n', '    function getBetId() external view returns(uint256){\n', '        return betid;\n', '    }\n', '    function updateBetId(uint256 _userBetId) external onlyMyContracts{\n', '        betid=_userBetId;\n', '    }\n', '    function updateBetArray(InlineDatabaseLib.BetInfo memory bObject) external onlyMyContracts{\n', '        betArray.push(bObject);\n', '    }\n', '    function updateBetArrayIndex(InlineDatabaseLib.BetInfo memory bObject, uint256 index) external onlyMyContracts{\n', '        betArray[index]=bObject;\n', '    }\n', '    function getBetArray() external view returns(InlineDatabaseLib.BetInfo[] memory){\n', '        return betArray;\n', '    }\n', '    function getFindBetInArrayUsingBetIdMapping(uint256 _betid) external view returns(uint256){\n', '        return findBetInArrayUsingBetIdMapping[_betid];\n', '    }\n', '    function updateFindBetInArrayUsingBetIdMapping(uint256 _betid, uint256 value) external onlyMyContracts{\n', '        findBetInArrayUsingBetIdMapping[_betid]=value;\n', '    }\n', '    function updateUserStakedAddress(address _address) external onlyMyContracts{\n', '        userStakedAddress.push(_address);\n', '    }\n', '    function getUserStakedAddress() external view returns(address[] memory){\n', '        return userStakedAddress;\n', '    }\n', '    function updateUserStakedAddress(address[] memory _userStakedAddress) external onlyMyContracts{\n', '        userStakedAddress=_userStakedAddress;\n', '    }\n', '    function getFlexibleDefiCoinArray() external view returns(InlineDatabaseLib.FlexibleInfo[] memory){\n', '        return flexibleDefiCoinArray;\n', '    }\n', '    \n', '    function getFlexibleIndexArray() external view returns(InlineDatabaseLib.FlexibleInfo[] memory){\n', '        return flexibleIndexArray;\n', '    }\n', '    \n', '    function getFixedDefiCoinArray() external view returns(InlineDatabaseLib.FixedInfo[] memory){\n', '        return fixedDefiCoinArray;\n', '    }\n', '    \n', '    function getFixedDefiIndexArray() external view returns(InlineDatabaseLib.FixedInfo[] memory){\n', '        return fixedDefiIndexArray;\n', '    }\n', '    function updateBetIndexForFixedArray(uint256 _betId, InlineDatabaseLib.IndexCoin memory iCArray) external onlyMyContracts{\n', '        betIndexArray[_betId].push(iCArray);\n', '    }\n', '    function getBetIndexForFixedArray(uint256 _betId) external view returns(InlineDatabaseLib.IndexCoin[] memory){\n', '        return (betIndexArray[_betId]);\n', '    }\n', '    function updateBetIndexArray(uint256 _betId, InlineDatabaseLib.IndexCoin memory iCArray) external onlyMyContracts{\n', '        betIndexArray[_betId].push(iCArray);\n', '    }\n', '    function getBetIndexArray(uint256 _betId) external view returns(InlineDatabaseLib.IndexCoin[] memory){\n', '        return (betIndexArray[_betId]);\n', '    }\n', '    function updateBetPriceHistoryMapping(uint256 _betId, InlineDatabaseLib.BetPriceHistory memory bPHObj) external onlyMyContracts{\n', '        betPriceHistoryMapping[_betId]=bPHObj;\n', '    }\n', '    function getBetPriceHistoryMapping(uint256 _betId) external view returns(InlineDatabaseLib.BetPriceHistory memory){\n', '        return (betPriceHistoryMapping[_betId]);\n', '    }\n', '    function addUpdatePlentyOneDayPercentage(uint256 percentage) public onlyOwner{\n', '        plentyOneDayPercentage=percentage;\n', '    }\n', '    function getPlentyOneDayPercentage() external view returns(uint256){\n', '        return (plentyOneDayPercentage);\n', '    }\n', '    \n', '    function addUpdatePlentyThreeDayPercentage(uint256 _days, uint256 percentage) public onlyOwner{\n', '        plentyThreeDayPercentage[_days]=percentage;\n', '    }\n', '    function getPlentyThreeDayPercentage(uint256 _days) external view returns(uint256){\n', '        return (plentyThreeDayPercentage[_days]);\n', '    }\n', '    \n', '    function addUpdatePlentySevenDayPercentage(uint256 _days, uint256 percentage) public onlyOwner{\n', '        plentySevenDayPercentage[_days]=percentage;\n', '    }\n', '    function getPlentySevenDayPercentage(uint256 _days) external view returns(uint256){\n', '        return (plentySevenDayPercentage[_days]);\n', '    }\n', '    function updateOrcaleAddress(address oracleAddress) external onlyOwner{\n', '        oracleWrapperContractAddress=oracleAddress;\n', '    }\n', '    function getOracleWrapperContractAddress() external view returns(address){\n', '        return oracleWrapperContractAddress;\n', '    }\n', '    function getBetsAccordingToUserAddress(address userAddress) external view returns(uint256[] memory){\n', '        return betAddressesArray[userAddress];\n', '    }\n', '    function getUserBetCount(address userAddress) external view returns(uint256){\n', '        return betAddressesArray[userAddress].length;\n', '    }\n', '    function getUserBetArray(address userAddress, uint256 pageNo, uint256 pageSize) external view returns(InlineDatabaseLib.BetInfo[] memory){\n', '        uint256[] memory betIndexes=betAddressesArray[userAddress];\n', '        if(betIndexes.length>0){\n', '            uint256 startIndex=(((betIndexes.length).sub(pageNo.mul(pageSize))).sub(1));\n', '            uint256 endIndex;\n', '            uint256 pageCount=startIndex.add(1);\n', '            if(pageSize.sub(1)<startIndex){\n', '                endIndex=(startIndex.sub(pageSize.sub(1)));\n', '                pageCount=pageSize;\n', '            }\n', '            InlineDatabaseLib.BetInfo[] memory bArray=new InlineDatabaseLib.BetInfo[](pageCount);\n', '            uint256 value;\n', '            for(uint256 i=endIndex;i<=startIndex;i++){\n', '                bArray[value]=betArray[findBetInArrayUsingBetIdMapping[betIndexes[i]]];\n', '                value++;\n', '            }\n', '            return bArray;\n', '        }\n', '        return new InlineDatabaseLib.BetInfo[](0);\n', '    }\n', '    function updateBetAddressesArray(address userAddress, uint256 _betId) external onlyMyContracts{\n', '        betAddressesArray[userAddress].push(_betId);\n', '    }\n', '    \n', '    function addUserAddressUsedForBetting(address userAddress) external onlyMyContracts{\n', '        userAddressUsedForBetting.push(userAddress);\n', '    }\n', '    function getUserAddressUsedForBetting() external view returns(address[] memory){\n', '        return userAddressUsedForBetting;\n', '    }\n', '    function addDaysToDayArray(uint256 _days) internal{\n', '        bool isAvailable;\n', '        for(uint256 i=0;i<daysArray.length;i++){\n', '            if(daysArray[i]==_days){\n', '                isAvailable=true;\n', '                break;\n', '            }\n', '        }\n', '        if(!isAvailable){\n', '            daysArray.push(_days);\n', '        }\n', '    }\n', '    function isDaysAvailable(uint256 _days) external view returns(bool){\n', '        for(uint256 i=0;i<daysArray.length;i++){\n', '            if(daysArray[i]==_days){\n', '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    function getDaysArray() external view returns(uint256[] memory){\n', '        return daysArray;\n', '    }\n', '    \n', '    function getAdminAddress() external view returns(address){\n', '        return adminAddress;\n', '    }\n', '    function updateAdminAddress(address _adminAddress) external onlyOwner{\n', '        adminAddress=_adminAddress;\n', '    }\n', '    \n', '    modifier onlyMyContracts() {\n', '        require(msg.sender == XIVMainContractAddress || msg.sender==XIVBettingFixedContractAddress || msg.sender== XIVBettingFlexibleContractAddress);\n', '        _;\n', '    }\n', '    // fallback function\n', '    receive() external payable {}\n', '}']