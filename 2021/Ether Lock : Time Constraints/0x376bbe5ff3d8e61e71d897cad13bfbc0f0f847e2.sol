['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-17\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.8.4 <0.9.0;\n', 'interface I {\n', '\tfunction balanceOf(address a) external view returns (uint);\n', '\tfunction transfer(address recipient, uint amount) external returns (bool);\n', '\tfunction transferFrom(address sender,address recipient, uint amount) external returns (bool);\n', '\tfunction totalSupply() external view returns (uint);\n', '//\tfunction getLastVoted(address account) external view returns (uint lastVoted); function changeAddress(address acc,address acc1) external;\n', '\tfunction getRewards(address a,uint rewToClaim) external returns(bool);\n', '\tfunction contributions(address a) external view returns(uint);\n', '//\tfunction providerMigr(address a,uint lpShare,uint lastClaim,uint lastEpoch,uint tknAmount,bool status) external;function lockerMigr(address a,uint amount,uint lockUpTo) external;\n', '}\n', '\n', '// did change it a small bit: founders are unable to stake generic liquidity on top of their share, or it will be too expensive to sload\n', '// for that they will have to use another address\n', '\n', 'contract StakingContract {\n', '\tuint128 private _foundingETHDeposited;\n', '\tuint128 private _foundingLPtokensMinted;\n', '\taddress private _tokenETHLP;\n', '\tbool private _init;\n', '\tuint88 private _genLPtokens;\n', '\n', '\tstruct LPProvider {uint32 lastClaim; uint16 lastEpoch; bool founder; uint128 tknAmount; uint128 lpShare;uint128 lockedAmount;uint128 lockUpTo;}\n', '\tstruct TokenLocker {uint128 amount;uint128 lockUpTo;}\n', '\n', '\tbytes32[] private _epochs;\n', '\tbytes32[] private _founderEpochs;\n', '\n', '\tmapping(address => LPProvider) private _ps;\n', '\tmapping(address => TokenLocker) private _ls;\n', '//\tmapping(address => address) public newAddresses;\n', '//\tmapping(address => bool) private _takenNew;\n', '\n', '\tfunction init(uint foundingETH, address tkn) public {\n', '\t\trequire(msg.sender == 0x901628CF11454AFF335770e8a9407CccAb3675BE && _init == false);\n', '\t\t_foundingETHDeposited = uint128(foundingETH);\n', '\t\t_foundingLPtokensMinted = uint128(I(tkn).balanceOf(address(this)));\n', '\t\t_tokenETHLP = tkn;\n', '\t\t_init = true;\n', '\t\t_createEpoch(0,false);\n', '\t\t_createEpoch(1e24,true);\n', '\t}\n', '\n', '\tfunction claimFounderStatus() public {\n', '\t\tuint ethContributed = I(0x901628CF11454AFF335770e8a9407CccAb3675BE).contributions(msg.sender);\n', '\t\trequire(ethContributed > 0);\n', '\t\trequire(_init == true && _ps[msg.sender].founder == false);\n', '\t\t_ps[msg.sender].founder = true;\n', '\t\tuint foundingETH = _foundingETHDeposited;\n', '\t\tuint lpShare = _foundingLPtokensMinted*ethContributed/foundingETH;\n', '\t\tuint tknAmount = ethContributed*1e24/foundingETH;\n', '\t\t_ps[msg.sender].lpShare = uint128(lpShare);\n', '\t\t_ps[msg.sender].tknAmount = uint128(tknAmount);\n', '\t\t_ps[msg.sender].lastClaim = 1264e4;\n', '\t}\n', '\n', '\tfunction unstakeLp(bool ok,uint amount) public {\n', '\t\t(uint lastClaim,bool status,uint tknAmount,uint lpShare,uint lockedAmount) = getProvider(msg.sender);\n', '\t\trequire(lpShare-lockedAmount >= amount && ok == true);\n', '\t\tif (lastClaim != block.number) {_getRewards(msg.sender);}\n', '\t\t_ps[msg.sender].lpShare = uint128(lpShare - amount);\n', '\t\tuint toSubtract = tknAmount*amount/lpShare; // not an array of deposits. if a provider stakes and then stakes again, and then unstakes - he loses share as if he staked only once at lowest price he had\n', '\t\t_ps[msg.sender].tknAmount = uint128(tknAmount-toSubtract);\n', '\t\tbytes32 epoch; uint length;\n', '\t\tif (status == true) {length = _founderEpochs.length; epoch = _founderEpochs[length-1];}\n', '\t\telse{length = _epochs.length; epoch = _epochs[length-1];_genLPtokens -= uint88(amount/1e10);}\n', '\t\t(uint80 eBlock,uint96 eAmount,) = _extractEpoch(epoch);\n', '\t\teAmount -= uint96(toSubtract);\n', '\t\t_storeEpoch(eBlock,eAmount,status,length);\n', '\t\tI(_tokenETHLP).transfer(address(msg.sender), amount);\n', '\t}\n', '\n', '\tfunction getRewards() public {_getRewards(msg.sender);}\n', '\n', '\tfunction _getRewards(address a) internal {\n', '\t\tuint lastClaim = _ps[a].lastClaim;\n', '\t\tuint epochToClaim = _ps[a].lastEpoch;\n', '\t\tbool status = _ps[a].founder;\n', '\t\tuint tknAmount = _ps[a].tknAmount;\n', '\t\trequire(block.number>lastClaim);\n', '\t\t_ps[a].lastClaim = uint32(block.number);\n', '\t\tuint rate = _getRate();\n', '\t\tuint eBlock; uint eAmount; uint eEnd; bytes32 epoch; uint length; uint toClaim;\n', '\t\tif (status) {length = _founderEpochs.length;} else {length = _epochs.length;}\n', '\t\tif (length>0 && epochToClaim < length-1) {\n', '\t\t\tfor (uint i = epochToClaim; i<length;i++) {\n', '\t\t\t\tif (status) {epoch = _founderEpochs[i];} else {epoch = _epochs[i];}\n', '\t\t\t\t(eBlock,eAmount,eEnd) = _extractEpoch(epoch);\n', '\t\t\t\tif(i == length-1) {eBlock = lastClaim;}\n', '\t\t\t\ttoClaim += _computeRewards(eBlock,eAmount,eEnd,tknAmount,rate);\n', '\t\t\t}\n', '\t\t\t_ps[a].lastEpoch = uint16(length-1);\n', '\t\t} else {\n', '\t\t\tif(status){epoch = _founderEpochs[length-1];} else {epoch = _epochs[length-1];}\n', '\t\t\teAmount = uint96(bytes12(epoch << 80)); toClaim = _computeRewards(lastClaim,eAmount,block.number,tknAmount,rate);\n', '\t\t}\n', '\t\tbool success = I(0x3E6AE87673424B1a1111E7F8180294B57be36476).getRewards(a, toClaim); require(success == true);\n', '\t}\n', '\n', '\tfunction _getRate() internal view returns(uint){uint rate = 84e15; uint halver = block.number/1e7;if (halver>1) {for (uint i=1;i<halver;i++) {rate=rate*3/4;}}return rate;}\n', '\n', '\tfunction _computeRewards(uint eBlock, uint eAmount, uint eEnd, uint tknAmount, uint rate) internal view returns(uint){\n', '\t\tif(eEnd==0){eEnd = block.number;} uint blocks = eEnd - eBlock; return (blocks*tknAmount*rate/eAmount);\n', '\t}\n', '\n', '// this function has to be expensive as an alert of something fishy just in case\n', '// metamask has to somehow provide more info about a transaction\n', '/*\tfunction newAddress(address a) public {\n', '\t\trequire(_takenNew[a] == false && _ps[a].lpShare == 0 && _ls[a].amount == 0);\n', '\t\tif(_ps[msg.sender].lockedAmount>0||_ls[msg.sender].amount>0){require(_isContract(msg.sender) == false);}\n', '\t\t_takenNew[a] = true;\n', '\t\tnewAddresses[msg.sender] = a;\n', '\t}\n', '// nobody should trust dapp interface. maybe a function like this should not be provided through dapp at all\n', '\tfunction changeAddress(address ad) public { // while user can confirm newAddress by public method, still has to enter the same address second time\n', '\t\taddress S = msg.sender;\taddress a = newAddresses[S];\n', '\t\trequire(a != address(0) && a == ad && a != msg.sender && block.number - 172800 > I(0xaE9564269B75f67510Bf20a512632869e3d42217).getLastVoted(S));\n', '\t\tif (_ps[S].lpShare > 0) {\n', '\t\t\t_ps[a].lastClaim = _ps[S].lastClaim;_ps[a].lastEpoch = _ps[S].lastEpoch;_ps[a].founder = _ps[S].founder;_ps[a].tknAmount = _ps[S].tknAmount;\n', '\t\t\t_ps[a].lpShare = _ps[S].lpShare;_ps[a].lockUpTo = _ps[S].lockUpTo;_ps[a].lockedAmount = _ps[S].lockedAmount;delete _ps[S];\n', '\t\t}\n', '\t\tif (_ls[S].amount > 0) {_ls[a].amount=_ls[S].amount;_ls[a].lockUpTo=_ls[S].lockUpTo;delete _ls[S];}\n', '\t}*/\n', '\n', '\tfunction lockFor6Months(bool ok, address tkn, uint amount) public {\n', '\t\trequire(ok==true && amount>0);\n', '\t\tif(tkn ==_tokenETHLP) {\n', '\t\t\trequire(_ps[msg.sender].lpShare-_ps[msg.sender].lockedAmount>=amount); _ps[msg.sender].lockUpTo=uint128(block.number+1e6);_ps[msg.sender].lockedAmount+=uint128(amount);\t\n', '\t\t}\n', '\t\tif(tkn == 0x1565616E3994353482Eb032f7583469F5e0bcBEC) {\n', '\t\t\trequire(I(tkn).balanceOf(msg.sender)>=amount);\n', '\t\t\t_ls[msg.sender].lockUpTo=uint128(block.number+1e6);\n', '\t\t\t_ls[msg.sender].amount+=uint128(amount);\n', '\t\t\tI(tkn).transferFrom(msg.sender,address(this),amount);\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unlock() public {\n', '\t\tif (_ps[msg.sender].lockedAmount > 0 && block.number>=_ps[msg.sender].lockUpTo) {_ps[msg.sender].lockedAmount = 0;}\n', '\t\tuint amount = _ls[msg.sender].amount;\n', '\t\tif (amount > 0 && block.number>=_ls[msg.sender].lockUpTo) {I(0x1565616E3994353482Eb032f7583469F5e0bcBEC).transfer(msg.sender,amount);_ls[msg.sender].amount = 0;}\n', '\t}\n', '\n', '\tfunction stake(uint amount) public {\n', '\t\taddress tkn = _tokenETHLP;\n', '\t\tuint length = _epochs.length;\n', '\t\tuint lastClaim = _ps[msg.sender].lastClaim;\n', '\t\trequire(_ps[msg.sender].founder==false && I(tkn).balanceOf(msg.sender)>=amount);\n', '\t\tI(tkn).transferFrom(msg.sender,address(this),amount);\n', '\t\tif(lastClaim==0){_ps[msg.sender].lastClaim = uint32(block.number);}\n', '\t\telse if (lastClaim != block.number) {_getRewards(msg.sender);}\n', '\t\tbytes32 epoch = _epochs[length-1];\n', '\t\t(uint80 eBlock,uint96 eAmount,) = _extractEpoch(epoch);\n', '\t\teAmount += uint96(amount);\n', '\t\t_storeEpoch(eBlock,eAmount,false,length);\n', '\t\t_ps[msg.sender].lastEpoch = uint16(_epochs.length);\n', '\t\tuint genLPtokens = _genLPtokens*1e10;\n', '\t\tgenLPtokens += amount;\n', '\t\t_genLPtokens = uint88(genLPtokens/1e10);\n', '\t\tuint share = amount*I(0x1565616E3994353482Eb032f7583469F5e0bcBEC).balanceOf(tkn)/genLPtokens;\n', '\t\t_ps[msg.sender].tknAmount += uint128(share);\n', '\t\t_ps[msg.sender].lpShare += uint128(amount);\n', '\t}\n', '\n', '\tfunction _extractEpoch(bytes32 epoch) internal pure returns (uint80,uint96,uint80){\n', '\t\tuint80 eBlock = uint80(bytes10(epoch));\n', '\t\tuint96 eAmount = uint96(bytes12(epoch << 80));\n', '\t\tuint80 eEnd = uint80(bytes10(epoch << 176));\n', '\t\treturn (eBlock,eAmount,eEnd);\n', '\t}\n', ' \n', '\tfunction _storeEpoch(uint80 eBlock, uint96 eAmount, bool founder, uint length) internal {\n', '\t\tuint eEnd;\n', "\t\tif(block.number-80640>eBlock){eEnd = block.number-1;}// so an epoch can be bigger than 2 weeks, it's normal behavior and even desirable\n", '\t\tbytes memory by = abi.encodePacked(eBlock,eAmount,uint80(eEnd));\n', '\t\tbytes32 epoch; assembly {epoch := mload(add(by, 32))}\n', '\t\tif (founder) {_founderEpochs[length-1] = epoch;} else {_epochs[length-1] = epoch;}\n', '\t\tif (eEnd>0) {_createEpoch(eAmount,founder);}\n', '\t}\n', '\n', '\tfunction _createEpoch(uint amount, bool founder) internal {\n', '\t\tbytes memory by = abi.encodePacked(uint80(block.number),uint96(amount),uint80(0));\n', '\t\tbytes32 epoch; assembly {epoch := mload(add(by, 32))}\n', '\t\tif (founder == true){_founderEpochs.push(epoch);} else {_epochs.push(epoch);}\n', '\t}\n', '\n', '/*\tfunction migrate(address contr,address tkn,uint amount) public lock {//can support any amount of bridges\n', '\t\tif (tkn == _tokenETHLP) {\n', '\t\t\t(uint lastClaim,bool status,uint tknAmount,uint lpShare,uint lockedAmount) = getProvider(msg.sender);\n', '\t\t\tif (lastClaim != block.number) {_getRewards(msg.sender);}\n', '\t\t\trequire(lpShare-lockedAmount >= amount);\n', '\t\t\t_ps[msg.sender].lpShare = uint128(lpShare - amount);\n', '\t\t\tuint toSubtract = amount*tknAmount/lpShare;\n', '\t\t\t_ps[msg.sender].tknAmount = uint128(tknAmount-toSubtract);\n', '\t\t\tuint length; bytes32 epoch;\n', '\t\t\tif (status == true){length = _founderEpochs.length; epoch = _founderEpochs[length-1];}\n', '\t\t\telse{length = _epochs.length; epoch = _epochs[length-1]; _genLPtokens -= uint88(amount/1e10);}\n', '\t\t\t(uint80 eBlock, uint96 eAmount,) = _extractEpoch(epoch);\n', '\t\t\teAmount -= uint96(toSubtract);\n', '\t\t\t_storeEpoch(eBlock,eAmount,status,length);\n', '\t\t\tI(tkn).transfer(contr, amount);\n', '\t\t\tI(contr).provider(msg.sender,amount,_ps[msg.sender].lastClaim,_ps[msg.sender].lastEpoch,toSubtract,status);\n', '\t\t}\n', '\t\tif (tkn == 0x1565616E3994353482Eb032f7583469F5e0bcBEC) {\n', '\t\t\tuint lockedAmount = _ls[msg.sender].amount;\n', '\t\t\trequire(lockedAmount >= amount);\n', '\t\t\tI(tkn).transfer(contr, amount);\n', '\t\t\t_ls[msg.sender].amount = uint128(lockedAmount-amount);\n', '\t\t\tI(contr).locker(msg.sender,amount,_ls[msg.sender].lockUpTo);\n', '\t\t}\n', '\t}*/\n', '// VIEW FUNCTIONS ==================================================\n', '\tfunction getVoter(address a) external view returns (uint128,uint128,uint128,uint128,uint128,uint128) {\n', '\t\treturn (_ps[a].tknAmount,_ps[a].lpShare,_ps[a].lockedAmount,_ps[a].lockUpTo,_ls[a].amount,_ls[a].lockUpTo);\n', '\t}\n', '\n', '\tfunction getProvider(address a)public view returns(uint,bool,uint,uint,uint){return(_ps[a].lastClaim,_ps[a].founder,_ps[a].tknAmount,_ps[a].lpShare,_ps[a].lockedAmount);}\n', '}']