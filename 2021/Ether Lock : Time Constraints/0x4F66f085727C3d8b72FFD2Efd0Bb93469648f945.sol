['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-17\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', '\n', 'pragma solidity 0.7.4;\n', '\n', 'library SafeMathLib {\n', '  function times(uint a, uint b) public pure returns (uint) {\n', '    uint c = a * b;\n', "    require(a == 0 || c / a == b, 'Overflow detected');\n", '    return c;\n', '  }\n', '\n', '  function minus(uint a, uint b) public pure returns (uint) {\n', "    require(b <= a, 'Underflow detected');\n", '    return a - b;\n', '  }\n', '\n', '  function plus(uint a, uint b) public pure returns (uint) {\n', '    uint c = a + b;\n', "    require(c>=a && c>=b, 'Overflow detected');\n", '    return c;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface Token {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// This contract is inspired by the harberger tax idea, it rewards people with FVT for burning their liquidity provider\n', '// tokens.\n', 'contract LiquidityMining {\n', '    using SafeMathLib for uint;\n', '\n', '    // this represents a single recipient of token rewards on a fixed schedule that does not depend on deposit or burn rate\n', '    // it specifies an id (key to a map below) an marker for the last time it was updated, a deposit (of LP tokens) and a\n', '    // burn rate of those LP tokens per block, and finally, the owner of the slot, who will receive the rewards\n', '    struct Slot {\n', '        uint id;\n', '        uint lastUpdatedBlock;\n', '        uint deposit;\n', '        uint burnRate;\n', '        address owner;\n', '    }\n', '\n', '    // privileged key that can change key parameters, will change to dao later\n', '    address public management;\n', '\n', '    // the token that the rewards are made in\n', '    Token public rewardToken;\n', '\n', '    // the liquidity provider (LP) token\n', '    Token public liquidityToken;\n', '\n', '    // address to which taxes are sent\n', '    address public taxAddress;\n', '\n', '    // is the contract paused?\n', '    bool public paused = false;\n', '\n', '    // when was the contract paused?\n', '    uint public pausedBlock = 0;\n', '\n', '    // maximum number of slots, changeable by management key\n', '    uint public maxStakers = 0;\n', '\n', '    // current number of stakers\n', '    uint public numStakers = 0;\n', '\n', '    // minimum deposit allowable to claim a slot\n', '    uint public minimumDeposit = 0;\n', '\n', '    // maximum deposit allowable (used to limit risk)\n', '    uint public maximumDeposit = 1000 ether;\n', '\n', '    // minimum burn rate allowable to claim a slot\n', '    uint public minimumBurnRate = 0;\n', '\n', '    // total liquidity tokens staked\n', '    uint public totalStaked = 0;\n', '\n', '    // total rewards distributed\n', '    uint public totalRewards = 0;\n', '\n', '    // total LP tokens burned\n', '    uint public totalBurned = 0;\n', '\n', '    // start block used to compute rewards\n', '    uint public pulseStartBlock;\n', '\n', '    // the length of a single pulse of rewards, in blocks\n', '    uint public pulseWavelengthBlocks = 0;\n', '\n', '    // the amount of the highest per-block reward, in FVT\n', '    uint public pulseAmplitudeFVT = 0;\n', '\n', '    // computed constants for deferred computation\n', '    uint public pulseIntegral = 0;\n', '    uint public pulseConstant = 0;\n', '\n', '    // map of slot ids to slots\n', '    mapping (uint => Slot) public slots;\n', '\n', '    // map of addresses to amount staked\n', '    mapping (address => uint) public totalStakedFor;\n', '\n', '    // map of total rewards by address\n', '    mapping (address => uint) public totalRewardsFor;\n', '\n', '    // map of rewards for session slotId -> rewardsForThisSession\n', '    mapping (uint => uint) public rewardsForSession;\n', '\n', '    // map of total burned by address\n', '    mapping (address => uint) public totalBurnedFor;\n', '\n', '    event ManagementUpdated(address oldMgmt, address newMgmt);\n', '    event ContractPaused();\n', '    event ContractUnpaused();\n', '    event WavelengthUpdated(uint oldWavelength, uint newWavelength);\n', '    event AmplitudeUpdated(uint oldAmplitude, uint newAmplitude);\n', '    event MaxStakersUpdated(uint oldMaxStakers, uint newMaxStakers);\n', '    event MinDepositUpdated(uint oldMinDeposit, uint newMinDeposit);\n', '    event MaxDepositUpdated(uint oldMaxDeposit, uint newMaxDeposit);\n', '    event MinBurnRateUpdated(uint oldMinBurnRate, uint newMinBurnRate);\n', '    event SlotChangedHands(uint slotId, uint deposit, uint burnRate, address owner);\n', '\n', '    modifier managementOnly() {\n', "        require (msg.sender == management, 'Only management may call this');\n", '        _;\n', '    }\n', '\n', '    constructor(\n', '        address rewardTokenAddr,\n', '        address liquidityTokenAddr,\n', '        address mgmt,\n', '        address taxAddr,\n', '        uint pulseLengthBlocks,\n', '        uint pulseAmplitude,\n', '        uint mxStkrs) {\n', '        rewardToken = Token(rewardTokenAddr);\n', '        liquidityToken = Token(liquidityTokenAddr);\n', '        management = mgmt;\n', '        pulseStartBlock = block.number;\n', '        pulseWavelengthBlocks = pulseLengthBlocks;\n', '        pulseAmplitudeFVT = pulseAmplitude;\n', '        pulseConstant = pulseAmplitudeFVT / pulseWavelengthBlocks.times(pulseWavelengthBlocks);\n', '        pulseIntegral = pulseSum(pulseWavelengthBlocks);\n', '        maxStakers = mxStkrs;\n', '        taxAddress = taxAddr;\n', '    }\n', '\n', '    // only management can reset management key\n', '    function setManagement(address newMgmt) public managementOnly {\n', '        address oldMgmt = management;\n', '        management = newMgmt;\n', '        emit ManagementUpdated(oldMgmt, newMgmt);\n', '    }\n', '\n', '    function pauseContract() public managementOnly {\n', "        require(paused == false, 'Already paused');\n", '        paused = true;\n', '        pausedBlock = block.number;\n', '        emit ContractPaused();\n', '    }\n', '\n', '    function unpauseContract() public managementOnly {\n', "        require(paused == true, 'Already unpaused');\n", "        require(numStakers == 0, 'Must kick everyone out before unpausing');\n", '        paused = false;\n', '        pausedBlock = 0;\n', '        emit ContractUnpaused();\n', '    }\n', '\n', '    // change the number of slots, should be done with care\n', '    function setMaxStakers(uint newMaxStakers) public managementOnly {\n', '        uint oldMaxStakers = maxStakers;\n', '        maxStakers = newMaxStakers;\n', '        emit MaxStakersUpdated(oldMaxStakers, maxStakers);\n', '    }\n', '\n', '    // change the minimum deposit to acquire a slot\n', '    function setMinDeposit(uint newMinDeposit) public managementOnly {\n', '        uint oldMinDeposit = minimumDeposit;\n', '        minimumDeposit = newMinDeposit;\n', '        emit MinDepositUpdated(oldMinDeposit, newMinDeposit);\n', '    }\n', '\n', '    // change the maximum deposit\n', '    function setMaxDeposit(uint newMaxDeposit) public managementOnly {\n', '        uint oldMaxDeposit = maximumDeposit;\n', '        maximumDeposit = newMaxDeposit;\n', '        emit MaxDepositUpdated(oldMaxDeposit, newMaxDeposit);\n', '    }\n', '\n', '    // change the minimum burn rate to acquire a slot\n', '    function setMinBurnRate(uint newMinBurnRate) public managementOnly {\n', '        uint oldMinBurnRate = minimumBurnRate;\n', '        minimumBurnRate = newMinBurnRate;\n', '        emit MinBurnRateUpdated(oldMinBurnRate, newMinBurnRate);\n', '    }\n', '\n', '    // change the length of a pulse, should be done with care, probably should update all slots simultaneously\n', '    function setPulseWavelength(uint newWavelength) public managementOnly {\n', '        uint oldWavelength = pulseWavelengthBlocks;\n', '        pulseWavelengthBlocks = newWavelength;\n', '        pulseConstant = pulseAmplitudeFVT / pulseWavelengthBlocks.times(pulseWavelengthBlocks);\n', '        pulseIntegral = pulseSum(newWavelength);\n', '        emit WavelengthUpdated(oldWavelength, newWavelength);\n', '    }\n', '\n', '    // change the maximum height of the reward curve\n', '    function setPulseAmplitude(uint newAmplitude) public managementOnly {\n', '        uint oldAmplitude = pulseAmplitudeFVT;\n', '        pulseAmplitudeFVT = newAmplitude;\n', '        pulseConstant = pulseAmplitudeFVT / pulseWavelengthBlocks.times(pulseWavelengthBlocks);\n', '        pulseIntegral = pulseSum(pulseWavelengthBlocks);\n', '        emit AmplitudeUpdated(oldAmplitude, newAmplitude);\n', '    }\n', '\n', '    // compute the sum of the rewards per pulse\n', '    function pulseSum(uint wavelength) public view returns (uint) {\n', '        // sum of squares formula\n', '        return pulseConstant.times(wavelength.times(wavelength.plus(1))).times(wavelength.times(2).plus(1)) / 6;\n', '    }\n', '\n', '    // compute the undistributed rewards for a slot\n', '    function getRewards(uint slotId) public view returns (uint) {\n', '        Slot storage slot = slots[slotId];\n', '        if (slot.owner == address(0)) {\n', '            return 0;\n', '        }\n', '        uint referenceBlock = block.number;\n', '        if (paused) {\n', '            referenceBlock = pausedBlock;\n', '        }\n', '        // three parts, incomplete beginning, incomplete end and complete middle\n', '        uint rewards;\n', '\n', '        // complete middle\n', '        // trim off overhang on both ends\n', '        uint startPhase = slot.lastUpdatedBlock.minus(pulseStartBlock) % pulseWavelengthBlocks;\n', '        uint startOverhang = pulseWavelengthBlocks.minus(startPhase);\n', '        uint startSum = pulseSum(startOverhang);\n', '\n', '        uint blocksDiffTotal = referenceBlock.minus(slot.lastUpdatedBlock);\n', '\n', '        uint endPhase = referenceBlock.minus(pulseStartBlock) % pulseWavelengthBlocks;\n', '        uint endingBlocks = pulseWavelengthBlocks.minus(endPhase);\n', '        uint leftoverSum = pulseSum(endingBlocks);\n', '\n', "        // if we haven't made it to phase 0 yet\n", '        if (blocksDiffTotal < startOverhang) {\n', '            rewards = startSum.minus(leftoverSum);\n', '        } else {\n', '            uint blocksDiff = blocksDiffTotal.minus(endPhase).minus(startOverhang);\n', '            uint wavelengths = blocksDiff / pulseWavelengthBlocks;\n', '            rewards = wavelengths.times(pulseIntegral);\n', '\n', '            // incomplete beginning of reward cycle, end of pulse\n', '            if (startPhase > 0) {\n', '                rewards = rewards.plus(pulseSum(startOverhang));\n', '            }\n', '\n', '            // incomplete ending of reward cycle, beginning of pulse\n', '            if (endPhase > 0) {\n', '                rewards = rewards.plus(pulseIntegral.minus(leftoverSum));\n', '            }\n', '        }\n', '\n', '        return rewards;\n', '    }\n', '\n', '    // compute the unapplied burn to the deposit\n', '    function getBurn(uint slotId) public view returns (uint) {\n', '        Slot storage slot = slots[slotId];\n', '        uint referenceBlock = block.number;\n', '        if (paused) {\n', '            referenceBlock = pausedBlock;\n', '        }\n', '        uint burn = slot.burnRate * (referenceBlock - slot.lastUpdatedBlock);\n', '        if (burn > slot.deposit) {\n', '            burn = slot.deposit;\n', '        }\n', '        return burn;\n', '    }\n', '\n', '    // this must be idempotent, it syncs both the rewards and the deposit burn atomically, and updates lastUpdatedBlock\n', '    function updateSlot(uint slotId) public {\n', '        Slot storage slot = slots[slotId];\n', '\n', '        // burn and rewards always have to update together, since they both depend on lastUpdatedBlock\n', '        uint burn = getBurn(slotId);\n', '        uint rewards = getRewards(slotId);\n', '\n', '        // update this first to make burn and reward zero in the case of re-entrance\n', '        slot.lastUpdatedBlock = block.number;\n', '\n', '        if (burn > 0) {\n', '            // adjust deposit first\n', '            slot.deposit = slot.deposit.minus(burn);\n', '\n', '            // bookkeeping\n', '            totalBurned = totalBurned.plus(burn);\n', '            totalBurnedFor[slot.owner] = totalBurnedFor[slot.owner].plus(burn);\n', '\n', '            // burn them!\n', '            liquidityToken.transfer(taxAddress, burn);\n', '        }\n', '\n', '        if (rewards > 0) {\n', '            // bookkeeping\n', '            totalRewards = totalRewards.plus(rewards);\n', '            totalRewardsFor[slot.owner] = totalStakedFor[slot.owner].plus(rewards);\n', '            rewardsForSession[slotId] = rewardsForSession[slotId].plus(rewards);\n', '\n', '            rewardToken.transfer(slot.owner, rewards);\n', '        }\n', '    }\n', '\n', '    // most important function for users, allows them to start receiving rewards\n', '    function claimSlot(uint slotId, uint newBurnRate, uint deposit) external {\n', "        require(slotId > 0, 'Slot id must be positive');\n", "        require(slotId <= maxStakers, 'Slot id out of range');\n", "        require(newBurnRate >= minimumBurnRate, 'Burn rate must meet or exceed minimum');\n", "        require(deposit >= minimumDeposit, 'Deposit must meet or exceed minimum');\n", "        require(deposit <= maximumDeposit, 'Deposit must not exceed maximum');\n", "        require(paused == false, 'Must be unpaused');\n", '\n', '        Slot storage slot = slots[slotId];\n', '\n', '        // count the stakers\n', '        if (slot.owner == address(0)) {\n', '            // assign id since this may be the first time\n', '            slot.id = slotId;\n', '            numStakers = numStakers.plus(1);\n', '            slot.lastUpdatedBlock = block.number;\n', '        } else {\n', '            updateSlot(slotId);\n', '\n', '            bool betterDeal = newBurnRate > slot.burnRate && (deposit > slot.deposit || deposit == maximumDeposit);\n', "            require(betterDeal || slot.deposit == 0, 'You must outbid the current owner');\n", '\n', '            // bookkeeping\n', '            totalStaked = totalStaked.minus(slot.deposit);\n', '            totalStakedFor[slot.owner] = totalStakedFor[slot.owner].minus(slot.deposit);\n', '\n', '            // withdraw current owner\n', '            withdrawFromSlotInternal(slotId);\n', '        }\n', '\n', '        // set new owner, burn rate\n', '        slot.owner = msg.sender;\n', '        slot.burnRate = newBurnRate;\n', '        slot.deposit = deposit;\n', '\n', '        // bookkeeping\n', '        totalStaked = totalStaked.plus(deposit);\n', '        totalStakedFor[msg.sender] = totalStakedFor[msg.sender].plus(deposit);\n', '\n', '        // transfer the tokens!\n', '        if (deposit > 0) {\n', '            liquidityToken.transferFrom(msg.sender, address(this), deposit);\n', '        }\n', '\n', '        emit SlotChangedHands(slotId, deposit, newBurnRate, msg.sender);\n', '    }\n', '\n', '    // separates user from slot, if either voluntary or delinquent\n', '    function withdrawFromSlot(uint slotId) external {\n', '        Slot storage slot = slots[slotId];\n', '        bool withdrawable = slot.owner == msg.sender || slot.deposit == 0;\n', "        require(withdrawable || paused, 'Only owner can call this unless user is delinquent or contract is paused');\n", '        updateSlot(slotId);\n', '        withdrawFromSlotInternal(slotId);\n', '\n', '        // zero out owner and burn rate\n', '        slot.owner = address(0);\n', '        slot.burnRate = 0;\n', '        numStakers = numStakers.minus(1);\n', '        emit SlotChangedHands(slotId, 0, 0, address(0));\n', '    }\n', '\n', '    // internal function for withdrawing from a slot\n', '    function withdrawFromSlotInternal(uint slotId) internal {\n', '        Slot storage slot = slots[slotId];\n', '\n', '        rewardsForSession[slotId] = 0;\n', '\n', "        // if there's any deposit left,\n", '        if (slot.deposit > 0) {\n', '            uint deposit = slot.deposit;\n', '            slot.deposit = 0;\n', '            liquidityToken.transfer(slot.owner, deposit);\n', '        }\n', '    }\n', '\n', '}']