['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./Context.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Address.sol";\n', 'import "./IERC20.sol";\n', 'import "./Ownable.sol";\n', '\n', 'contract SwipeIWO is Ownable {\n', '    struct WhiteList {\n', '        bool isWhite;\n', '        uint256 maxAllowance;\n', '    }\n', '\n', '    // Use SafeMath for uint256 and SafeERC20 for IERC20\n', '    using SafeMath for uint256;\n', '\n', '    // Address For BaseToken. e.x: SXP\n', '    address private _baseToken;\n', '    // Address For SaleToken. e.x: STRK\n', '    address private _saleToken;\n', '    // Rate STRK To SXP\n', '    uint256 private _saleRate;\n', '    // Is Sale, Only set with owner\n', '    bool private _isSale;\n', '    // Sale Start Time\n', '    uint256 private _startTime;\n', '    // Sale End Time\n', '    uint256 private _endTime;\n', '    // Maximum Base Token Amount\n', '    uint256 private _maxBaseAmount;\n', '    // Minimum Base Token Amount\n', '    uint256 private _minBaseAmount;\n', '    // Limit Base Token Amount\n', '    uint256 private _limitBaseAmount;\n', '\n', '    // baseAmount with each address\n', '    mapping(address => uint256) _baseAmounts;\n', '    mapping(address => WhiteList) _whiteList;\n', '\n', '    modifier isNoContract() {\n', '        require(\n', '            Address.isContract(_msgSender()) == false,\n', '            "Contract is not allowed on SwipeIWO"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier isWhite(uint256 newSaleAmount) {\n', '        require(_whiteList[_msgSender()].isWhite, "You\'re not allowed to purchased");\n', '        require(\n', '            _baseAmounts[_msgSender()].add(newSaleAmount) <= _whiteList[_msgSender()].maxAllowance,\n', '            "You can not purchase more than maxAllowance"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Check IWO is not Over\n', '     */\n', '    modifier isNotOver() {\n', '        require(_isSale, "SwipeIWO is sale over");\n', '        require(block.timestamp >= _startTime, "SwipeIWO is not started yet");\n', '        require(block.timestamp <= _endTime, "SwipeIWO is already finished");\n', '        require(IERC20(_baseToken).balanceOf(address(this)) <= _limitBaseAmount, "Already sold out.");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Check IWO is Over\n', '     */\n', '    modifier isOver() {\n', '        require(!_isSale || block.timestamp < _startTime || block.timestamp > _endTime || IERC20(_baseToken).balanceOf(address(this)) > _limitBaseAmount, "SwipeIWO is not finished yet");\n', '        _;\n', '    }\n', '\n', '    event PurchaseToken(address indexed account, uint256 baseAmount, uint256 saleAmount);\n', '    \n', '    constructor() {\n', '        // Initialize the base&sale Tokens\n', '        _baseToken = address(0);\n', '        _saleToken = address(0);\n', '\n', '        // // Initialize the rate&isSale, should be divide 1e18 when purchase\n', '        // _saleRate = 1e18;\n', '        // _isSale = false;\n', '\n', '        // // Initialize the start&end time\n', '        // _startTime = block.timestamp;\n', '        // _endTime = block.timestamp;\n', '\n', '        // // Initialize the max&min base amount\n', '        // _minBaseAmount = 1e18;\n', '        // _maxBaseAmount = 1e18;\n', '\n', '        // // Initialize the baseLimitAmount\n', '        // _limitBaseAmount = 1e18;\n', '\n', '        // Initialize the rate&isSale, should be divide 1e18 when purchase\n', '        _saleRate = 10e18;\n', '        _isSale = true;\n', '\n', '        // Initialize the start&end time\n', '        _startTime = uint256(block.timestamp).sub(10000);\n', '        _endTime = uint256(block.timestamp).add(10000);\n', '\n', '        // Initialize the max&min base amount\n', '        _minBaseAmount = 1e18;\n', '        _maxBaseAmount = 10e18;\n', '\n', '        // Initialize the baseLimitAmount\n', '        _limitBaseAmount = 100e18;\n', '    }\n', '\n', '    /**\n', '     * @dev Get White Status\n', '     */\n', '    function getWhiteStatus(address userAddress) public view returns (bool, uint256) {\n', '        return (\n', '            _whiteList[userAddress].isWhite,\n', '            _whiteList[userAddress].maxAllowance\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Set White Statuses, only owner call it\n', '     */\n', '    function setWhiteStatus(address[] memory userAddressList, WhiteList[] memory userInfoList) external onlyOwner returns (bool) {\n', '        require(userAddressList.length == userInfoList.length, "The lengths of arrays should be same.");\n', '\n', '        for (uint i = 0; i < userAddressList.length; i += 1) {\n', '            _whiteList[userAddressList[i]] = userInfoList[i];\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Get Base Token\n', '     */\n', '    function getBaseToken() public view returns (address) {\n', '        return _baseToken;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Base Token, only owner call it\n', '     */\n', '    function setBaseToken(address baseToken) external onlyOwner {\n', '        require(baseToken != address(0), "BaseToken should be not 0x0");\n', '        _baseToken = baseToken;\n', '    }\n', '\n', '    /**\n', '     * @dev Get Sale Token\n', '     */\n', '    function getSaleToken() public view returns (address) {\n', '        return _saleToken;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Sale Token, only owner call it\n', '     */\n', '    function setSaleToken(address saleToken) external onlyOwner {\n', '        require(saleToken != address(0), "SaleToken should be not 0x0");\n', '        _saleToken = saleToken;\n', '    }\n', '\n', '    /**\n', '     * @dev Get Sale Rate\n', '     */\n', '    function getSaleRate() public view returns (uint256) {\n', '        return _saleRate;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Sale Rate, only owner call it\n', '     */\n', '    function setSaleRate(uint256 saleRate) external onlyOwner {\n', '        _saleRate = saleRate;\n', '    }\n', '\n', '    /**\n', '     * @dev Get IsSale\n', '     */\n', '    function getIsSale() public view returns (bool) {\n', '        return _isSale;\n', '    }\n', '\n', '    /**\n', '     * @dev Set IsSale, only owner call it\n', '     */\n', '    function setIsSale(bool isSale) external onlyOwner {\n', '        _isSale = isSale;\n', '    }\n', '\n', '    /**\n', '     * @dev Get IWO Start Time\n', '     */\n', '    function getStartTime() public view returns (uint256) {\n', '        return _startTime;\n', '    }\n', '\n', '    /**\n', '     * @dev Set IWO Start Time, only owner call it\n', '     */\n', '    function setStartTime(uint256 startTime) external onlyOwner {\n', '        _startTime = startTime;\n', '    }\n', '\n', '    /**\n', '     * @dev Get IWO End Time\n', '     */\n', '    function getEndTime() public view returns (uint256) {\n', '        return _endTime;\n', '    }\n', '\n', '    /**\n', '     * @dev Set End Time, only owner call it\n', '     */\n', '    function setEndTime(uint256 endTime) external onlyOwner {\n', '        require(endTime > _startTime, "EndTime should be over than startTime");\n', '        _endTime = endTime;\n', '    }\n', '\n', '    /**\n', '     * @dev Get MinBase Amount\n', '     */\n', '    function getMinBaseAmount() public view returns (uint256) {\n', '        return _minBaseAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Set MinBase Amount, only owner call it\n', '     */\n', '    function setMinBaseAmount(uint256 minBaseAmount) external onlyOwner {\n', '        _minBaseAmount = minBaseAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Get MaxBase Amount\n', '     */\n', '    function getMaxBaseAmount() public view returns (uint256) {\n', '        return _maxBaseAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Set MaxBase Amount, only owner call it\n', '     */\n', '    function setMaxBaseAmount(uint256 maxBaseAmount) external onlyOwner {\n', '        require(maxBaseAmount > _minBaseAmount, "MaxBaseAmount should be over than minBaseAmount");\n', '        _maxBaseAmount = maxBaseAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Get LimitBase Amount\n', '     */\n', '    function getLimitBaseAmount() public view returns (uint256) {\n', '        return _limitBaseAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Set LimitBase Amount, only owner call it\n', '     */\n', '    function setLimitBaseAmount(uint256 limitBaseAmount) external onlyOwner {\n', '        _limitBaseAmount = limitBaseAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Check IsIWO On Status\n', '     */\n', '    function isIWOOn() public view returns (bool) {\n', '        if (_isSale &&\n', '            block.timestamp >= _startTime &&\n', '            block.timestamp <= _endTime &&\n', '            IERC20(_baseToken).balanceOf(address(this)) <= _limitBaseAmount) {\n', '                return true;\n', '            }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @dev Set Allocation Amount with Sale Token, only owner call it\n', '            Should approve the amount before call this function\n', '     */\n', '    function allocationAmount(uint256 amount) external onlyOwner returns (bool) {\n', '        require(IERC20(_saleToken).balanceOf(address(_msgSender())) >= amount, "Owner should have more than amount with Sale Token");\n', '\n', '        IERC20(_saleToken).transferFrom(\n', '            _msgSender(),\n', '            address(this),\n', '            amount\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Burn baseToken, only owner call it\n', '     */\n', '    function burnBaseToken(uint256 burnAmount) external onlyOwner returns (bool) {\n', '        require(IERC20(_baseToken).balanceOf(address(this)) >= burnAmount, "Burn Amount should be less than balance of contract");\n', '\n', '        // IERC20(_baseToken).burn(burnAmount);\n', '        IERC20(_baseToken).transfer(address(0), burnAmount);\n', '\n', '        return true;\n', '    }   \n', '\n', '    /**\n', '     * @dev Withdraw Base Token, only owner call it\n', '     */\n', '    function withdrawBaseToken(address withdrawAddress, uint256 withdrawAmount) external onlyOwner returns (bool) {\n', '        uint256 baseBalance = IERC20(_baseToken).balanceOf(address(this));\n', '        require(withdrawAmount <= baseBalance, "The withdrawAmount should be less than balance");\n', '\n', '        IERC20(_baseToken).transfer(withdrawAddress, withdrawAmount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw Sale Token, only owner call it\n', '     */\n', '    function withdrawSaleToken(address withdrawAddress, uint256 withdrawAmount) external onlyOwner returns (bool) {\n', '        uint256 saleBalance = IERC20(_saleToken).balanceOf(address(this));\n', '        require(withdrawAmount <= saleBalance, "The withdrawAmount should be less than balance");\n', '\n', '        IERC20(_saleToken).transfer(withdrawAddress, withdrawAmount);\n', '\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @dev Purchase Sale Token\n', '            Should approve the baseToken before purchase\n', '     */\n', '    function purchaseSaleToken(uint256 baseAmountForSale)\n', '        external\n', '        isNoContract\n', '        isNotOver\n', '        isWhite(baseAmountForSale)\n', '        returns (bool)\n', '    {\n', '        // Check min&max base amount\n', '        uint256 currentBaseTotalAmount = IERC20(_baseToken).balanceOf(address(this));\n', '        // Get Sale Amount\n', '        uint256 saleAmount = baseAmountForSale.mul(_saleRate).div(1e18);\n', '\n', '        require(baseAmountForSale >= _minBaseAmount, "Purchase Amount should be more than minBaseAmount");\n', '        require(_baseAmounts[_msgSender()].add(baseAmountForSale) <= _maxBaseAmount, "Purchase Amount should be less than maxBaseAmount");\n', '        require(currentBaseTotalAmount.add(baseAmountForSale) <= _limitBaseAmount, "Total Base Amount shoould be less than baseLimitAmount");\n', '        require(IERC20(_saleToken).balanceOf(address(this)) >= saleAmount, "The contract should have saleAmount with saleToken at least");\n', '\n', '        // Update baseAmounts\n', '        _baseAmounts[_msgSender()] = _baseAmounts[_msgSender()].add(baseAmountForSale);\n', '\n', '        // TransferFrom baseToken from msgSender to Contract\n', '        IERC20(_baseToken).transferFrom(\n', '            _msgSender(),\n', '            address(this),\n', '            baseAmountForSale\n', '        );\n', '\n', '        // Send Sale Token to msgSender\n', '        IERC20(_saleToken).transfer(\n', '            _msgSender(),\n', '            saleAmount\n', '        );\n', '\n', '        emit PurchaseToken(_msgSender(), baseAmountForSale, saleAmount);\n', '\n', '        return true;\n', '    }\n', '}']