['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.3;\n', '\n', 'struct ReleaseSchedule {\n', '    uint releaseCount;\n', '    uint delayUntilFirstReleaseInSeconds;\n', '    uint initialReleasePortionInBips;\n', '    uint periodBetweenReleasesInSeconds;\n', '}\n', '\n', 'struct Timelock {\n', '    uint scheduleId;\n', '    uint commencementTimestamp;\n', '    uint tokensTransferred;\n', '    uint totalAmount;\n', '}\n', '\n', 'library ScheduleCalc {\n', '    uint constant BIPS_PRECISION = 10000;\n', '\n', '    function calculateUnlocked(uint commencedTimestamp, uint currentTimestamp, uint amount, ReleaseSchedule memory releaseSchedule) external pure returns (uint unlocked) {\n', '        if(commencedTimestamp > currentTimestamp) {\n', '            return 0;\n', '        }\n', '        uint secondsElapsed = currentTimestamp - commencedTimestamp;\n', '\n', '        // return the full amount if the total lockup period has expired\n', '        // unlocked amounts in each period are truncated and round down remainders smaller than the smallest unit\n', '        // unlocking the full amount unlocks any remainder amounts in the final unlock period\n', '        // this is done first to reduce computation\n', '        if (secondsElapsed >= releaseSchedule.delayUntilFirstReleaseInSeconds +\n', '        (releaseSchedule.periodBetweenReleasesInSeconds * (releaseSchedule.releaseCount - 1))) {\n', '            return amount;\n', '        }\n', '\n', '        // unlock the initial release if the delay has elapsed\n', '        if (secondsElapsed >= releaseSchedule.delayUntilFirstReleaseInSeconds) {\n', '            unlocked = (amount * releaseSchedule.initialReleasePortionInBips) / BIPS_PRECISION;\n', '\n', '            // if at least one period after the delay has passed\n', '            if (secondsElapsed - releaseSchedule.delayUntilFirstReleaseInSeconds\n', '                >= releaseSchedule.periodBetweenReleasesInSeconds) {\n', '\n', '                // calculate the number of additional periods that have passed (not including the initial release)\n', '                // this discards any remainders (ie it truncates / rounds down)\n', '                uint additionalUnlockedPeriods =\n', '                (secondsElapsed - releaseSchedule.delayUntilFirstReleaseInSeconds) /\n', '                releaseSchedule.periodBetweenReleasesInSeconds;\n', '\n', '                // calculate the amount of unlocked tokens for the additionalUnlockedPeriods\n', '                // multiplication is applied before division to delay truncating to the smallest unit\n', '                // this distributes unlocked tokens more evenly across unlock periods\n', '                // than truncated division followed by multiplication\n', '                unlocked += ((amount - unlocked) * additionalUnlockedPeriods) / (releaseSchedule.releaseCount - 1);\n', '            }\n', '        }\n', '\n', '        return unlocked;\n', '    }\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 1000\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']