['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.7.0;\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(\n', '            address(this).balance >= amount,\n', '            "Address: insufficient balance"\n', '        );\n', '        (bool success, ) = recipient.call{value: amount}("");\n', '        require(\n', '            success,\n', '            "Address: unable to send value, recipient may have reverted"\n', '        );\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data)\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value\n', '    ) internal returns (bytes memory) {\n', '        return\n', '            functionCallWithValue(\n', '                target,\n', '                data,\n', '                value,\n', '                "Address: low-level call with value failed"\n', '            );\n', '    }\n', '\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(\n', '            address(this).balance >= value,\n', '            "Address: insufficient balance for call"\n', '        );\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 weiValue,\n', '        string memory errorMessage\n', '    ) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '        (bool success, bytes memory returndata) =\n', '            target.call{value: weiValue}(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(\n', '        uint256 a,\n', '        uint256 b,\n', '        string memory errorMessage\n', '    ) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transfer.selector, to, value)\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n', '        );\n', '    }\n', '\n', '    function safeApprove(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        require(\n', '            (value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.approve.selector, spender, value)\n', '        );\n', '    }\n', '\n', '    function safeIncreaseAllowance(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        uint256 newAllowance =\n', '            token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(\n', '                token.approve.selector,\n', '                spender,\n', '                newAllowance\n', '            )\n', '        );\n', '    }\n', '\n', '    function safeDecreaseAllowance(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        uint256 newAllowance =\n', '            token.allowance(address(this), spender).sub(\n', '                value,\n', '                "SafeERC20: decreased allowance below zero"\n', '            );\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(\n', '                token.approve.selector,\n', '                spender,\n', '                newAllowance\n', '            )\n', '        );\n', '    }\n', '\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        bytes memory returndata =\n', '            address(token).functionCall(\n', '                data,\n', '                "SafeERC20: low-level call failed"\n', '            );\n', '        if (returndata.length > 0) {\n', '            require(\n', '                abi.decode(returndata, (bool)),\n', '                "SafeERC20: ERC20 operation did not succeed"\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', 'library TransferHelper {\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) =\n', '            token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', '            "TransferHelper: APPROVE_FAILED"\n', '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) =\n', '            token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', '            "TransferHelper: TRANSFER_FAILED"\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) =\n', '            token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', '            "TransferHelper: TRANSFER_FROM_FAILED"\n', '        );\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', 'interface IFarmFactory {\n', '    function userEnteredFarm(address _user) external;\n', '\n', '    function userLeftFarm(address _user) external;\n', '\n', '    function registerFarm(address _farmAddress) external;\n', '}\n', '\n', 'contract FarmUniswap {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    /// @notice information stuct on each user than stakes LP tokens.\n', '    struct UserInfo {\n', '        uint256 amount; // How many LP tokens the user has provided.\n', '        uint256 rewardDebt; // Reward debt.\n', '    }\n', '\n', '    /// @notice all the settings for this farm in one struct\n', '    struct FarmInfo {\n', '        IERC20 lpToken;\n', '        IERC20 rewardToken;\n', '        uint256 startBlock;\n', '        uint256 blockReward;\n', '        uint256 bonusEndBlock;\n', '        uint256 bonus;\n', '        uint256 endBlock;\n', '        uint256 lastRewardBlock; // Last block number that reward distribution occurs.\n', '        uint256 accRewardPerShare; // Accumulated Rewards per share, times 1e12\n', '        uint256 farmableSupply; // set in init, total amount of tokens farmable\n', '        uint256 numFarmers;\n', '    }\n', '\n', '    /// @notice farm type id. Useful for back-end systems to know how to read the contract (ABI) as we plan to launch multiple farm types\n', '    uint256 public farmType = 1;\n', '\n', '    IFarmFactory public factory;\n', '    address public farmGenerator;\n', '\n', '    FarmInfo public farmInfo;\n', '\n', '    /// @notice information on each user than stakes LP tokens\n', '    mapping(address => UserInfo) public userInfo;\n', '\n', '    event Deposit(address indexed user, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 amount);\n', '    event EmergencyWithdraw(address indexed user, uint256 amount);\n', '\n', '    constructor(address _factory, address _farmGenerator) public {\n', '        factory = IFarmFactory(_factory);\n', '        farmGenerator = _farmGenerator;\n', '    }\n', '\n', '    /**\n', '     * @notice initialize the farming contract. This is called only once upon farm creation and the FarmGenerator ensures the farm has the correct paramaters\n', '     */\n', '    function init(\n', '        IERC20 _rewardToken,\n', '        uint256 _amount,\n', '        IERC20 _lpToken,\n', '        uint256 _blockReward,\n', '        uint256 _startBlock,\n', '        uint256 _endBlock,\n', '        uint256 _bonusEndBlock,\n', '        uint256 _bonus\n', '    ) public {\n', '        address msgSender = _msgSender();\n', '        require(msgSender == address(farmGenerator), "FORBIDDEN");\n', '\n', '        TransferHelper.safeTransferFrom(\n', '            address(_rewardToken),\n', '            msgSender,\n', '            address(this),\n', '            _amount\n', '        );\n', '        farmInfo.rewardToken = _rewardToken;\n', '\n', '        farmInfo.startBlock = _startBlock;\n', '        farmInfo.blockReward = _blockReward;\n', '        farmInfo.bonusEndBlock = _bonusEndBlock;\n', '        farmInfo.bonus = _bonus;\n', '\n', '        uint256 lastRewardBlock =\n', '            block.number > _startBlock ? block.number : _startBlock;\n', '        farmInfo.lpToken = _lpToken;\n', '        farmInfo.lastRewardBlock = lastRewardBlock;\n', '        farmInfo.accRewardPerShare = 0;\n', '\n', '        farmInfo.endBlock = _endBlock;\n', '        farmInfo.farmableSupply = _amount;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the reward multiplier over the given _from_block until _to block\n', '     * @param _from_block the start of the period to measure rewards for\n', '     * @param _to the end of the period to measure rewards for\n', '     * @return The weighted multiplier for the given period\n', '     */\n', '    function getMultiplier(uint256 _from_block, uint256 _to)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 _from =\n', '            _from_block >= farmInfo.startBlock\n', '                ? _from_block\n', '                : farmInfo.startBlock;\n', '        uint256 to = farmInfo.endBlock > _to ? _to : farmInfo.endBlock;\n', '        //\n', '        if (to <= farmInfo.bonusEndBlock) {\n', '            return to.sub(_from).mul(farmInfo.bonus);\n', '        } else if (_from >= farmInfo.bonusEndBlock) {\n', '            return to.sub(_from);\n', '        } else {\n', '            return\n', '                farmInfo.bonusEndBlock.sub(_from).mul(farmInfo.bonus).add(\n', '                    to.sub(farmInfo.bonusEndBlock)\n', '                );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice function to see accumulated balance of reward token for specified user\n', '     * @param _user the user for whom unclaimed tokens will be shown\n', '     * @return total amount of withdrawable reward tokens\n', '     */\n', '    function pendingReward(address _user) external view returns (uint256) {\n', '        UserInfo storage user = userInfo[_user];\n', '        uint256 accRewardPerShare = farmInfo.accRewardPerShare;\n', '        uint256 lpSupply = farmInfo.lpToken.balanceOf(address(this));\n', '        if (block.number > farmInfo.lastRewardBlock && lpSupply != 0) {\n', '            uint256 multiplier =\n', '                getMultiplier(farmInfo.lastRewardBlock, block.number);\n', '            uint256 tokenReward = multiplier.mul(farmInfo.blockReward);\n', '            accRewardPerShare = accRewardPerShare.add(\n', '                tokenReward.mul(1e12).div(lpSupply)\n', '            );\n', '        }\n', '        return\n', '            user.amount.mul(accRewardPerShare).div(1e12).sub(user.rewardDebt);\n', '    }\n', '\n', '    /**\n', '     * @notice updates pool information to be up to date to the current block\n', '     */\n', '    function updatePool() public {\n', '        if (block.number <= farmInfo.lastRewardBlock) {\n', '            return;\n', '        }\n', '        uint256 lpSupply = farmInfo.lpToken.balanceOf(address(this));\n', '        if (lpSupply == 0) {\n', '            farmInfo.lastRewardBlock = block.number < farmInfo.endBlock\n', '                ? block.number\n', '                : farmInfo.endBlock;\n', '            return;\n', '        }\n', '        uint256 multiplier =\n', '            getMultiplier(farmInfo.lastRewardBlock, block.number);\n', '        uint256 tokenReward = multiplier.mul(farmInfo.blockReward);\n', '        farmInfo.accRewardPerShare = farmInfo.accRewardPerShare.add(\n', '            tokenReward.mul(1e12).div(lpSupply)\n', '        );\n', '        farmInfo.lastRewardBlock = block.number < farmInfo.endBlock\n', '            ? block.number\n', '            : farmInfo.endBlock;\n', '    }\n', '\n', '    /**\n', '     * @notice deposit LP token function for msgSender\n', '     * @param _amount the total deposit amount\n', '     */\n', '    function deposit(uint256 _amount) public {\n', '        address msgSender = _msgSender();\n', '        UserInfo storage user = userInfo[msgSender];\n', '        updatePool();\n', '        if (user.amount > 0) {\n', '            uint256 pending =\n', '                user.amount.mul(farmInfo.accRewardPerShare).div(1e12).sub(\n', '                    user.rewardDebt\n', '                );\n', '            safeRewardTransfer(msgSender, pending);\n', '        }\n', '        if (user.amount == 0 && _amount > 0) {\n', '            factory.userEnteredFarm(msgSender);\n', '            farmInfo.numFarmers = farmInfo.numFarmers.add(1);\n', '        }\n', '        farmInfo.lpToken.safeTransferFrom(\n', '            address(msgSender),\n', '            address(this),\n', '            _amount\n', '        );\n', '        user.amount = user.amount.add(_amount);\n', '        user.rewardDebt = user.amount.mul(farmInfo.accRewardPerShare).div(1e12);\n', '        emit Deposit(msgSender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice withdraw LP token function for msgSender\n', '     * @param _amount the total withdrawable amount\n', '     */\n', '    function withdraw(uint256 _amount) public {\n', '        address msgSender = _msgSender();\n', '        UserInfo storage user = userInfo[msgSender];\n', '        require(user.amount >= _amount, "INSUFFICIENT");\n', '        updatePool();\n', '        if (user.amount == _amount && _amount > 0) {\n', '            factory.userLeftFarm(msgSender);\n', '            farmInfo.numFarmers = farmInfo.numFarmers.sub(1);\n', '        }\n', '        uint256 pending =\n', '            user.amount.mul(farmInfo.accRewardPerShare).div(1e12).sub(\n', '                user.rewardDebt\n', '            );\n', '        safeRewardTransfer(msgSender, pending);\n', '        user.amount = user.amount.sub(_amount);\n', '        user.rewardDebt = user.amount.mul(farmInfo.accRewardPerShare).div(1e12);\n', '        farmInfo.lpToken.safeTransfer(address(msgSender), _amount);\n', '        emit Withdraw(msgSender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice emergency functoin to withdraw LP tokens and forego harvest rewards. Important to protect users LP tokens\n', '     */\n', '    function emergencyWithdraw() public {\n', '        address msgSender = _msgSender();\n', '        UserInfo storage user = userInfo[msgSender];\n', '        farmInfo.lpToken.safeTransfer(address(msgSender), user.amount);\n', '        emit EmergencyWithdraw(msgSender, user.amount);\n', '        if (user.amount > 0) {\n', '            factory.userLeftFarm(msgSender);\n', '            farmInfo.numFarmers = farmInfo.numFarmers.sub(1);\n', '        }\n', '        user.amount = 0;\n', '        user.rewardDebt = 0;\n', '    }\n', '\n', '    /**\n', '     * @notice Safe reward transfer function, just in case a rounding error causes pool to not have enough reward tokens\n', '     * @param _to the user address to transfer tokens to\n', '     * @param _amount the total amount of tokens to transfer\n', '     */\n', '    function safeRewardTransfer(address _to, uint256 _amount) internal {\n', '        uint256 rewardBal = farmInfo.rewardToken.balanceOf(address(this));\n', '        if (_amount > rewardBal) {\n', '            farmInfo.rewardToken.transfer(_to, rewardBal);\n', '        } else {\n', '            farmInfo.rewardToken.transfer(_to, _amount);\n', '        }\n', '    }\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.7.0;\n', 'import "./FarmUniswap.sol";\n', '\n', 'interface IUniFactory {\n', '  function getPair(address tokenA, address tokenB) external view returns (address);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '  function name() external pure returns (string memory);\n', '  function symbol() external pure returns (string memory);\n', '  function decimals() external pure returns (uint8);\n', '  function totalSupply() external view returns (uint);\n', '  function balanceOf(address owner) external view returns (uint);\n', '  function allowance(address owner, address spender) external view returns (uint);\n', '\n', '  function approve(address spender, uint value) external returns (bool);\n', '  function transfer(address to, uint value) external returns (bool);\n', '  function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '  function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '  function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '  function nonces(address owner) external view returns (uint);\n', '\n', '  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '  event Mint(address indexed sender, uint amount0, uint amount1);\n', '  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '  event Swap(\n', '    address indexed sender,\n', '    uint amount0In,\n', '    uint amount1In,\n', '    uint amount0Out,\n', '    uint amount1Out,\n', '    address indexed to\n', '  );\n', '  event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '  function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '  function factory() external view returns (address);\n', '  function token0() external view returns (address);\n', '  function token1() external view returns (address);\n', '  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '  function price0CumulativeLast() external view returns (uint);\n', '  function price1CumulativeLast() external view returns (uint);\n', '  function kLast() external view returns (uint);\n', '\n', '  function mint(address to) external returns (uint liquidity);\n', '  function burn(address to) external returns (uint amount0, uint amount1);\n', '  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '  function skim(address to) external;\n', '  function sync() external;\n', '\n', '  function initialize(address, address) external;\n', '}\n', '\n', 'abstract contract Context {\n', '  function _msgSender() internal view virtual returns (address payable) {\n', '    return msg.sender;\n', '  }\n', '}\n', '\n', 'abstract contract Ownable is Context {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor () internal {\n', '    address msgSender = _msgSender();\n', '    _owner = msgSender;\n', '    emit OwnershipTransferred(address(0), msgSender);\n', '  }\n', '\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', 'contract FarmUniswapGenerator is Context, Ownable {\n', '  using SafeMath for uint256;\n', '  IFarmFactory public factory;\n', '\n', '  struct FarmParameters {\n', '    uint256 bonusBlocks;\n', '    uint256 totalBonusReward;\n', '    uint256 numBlocks;\n', '    uint256 endBlock;\n', '    uint256 requiredAmount;\n', '  }\n', '\n', '  constructor(IFarmFactory _factory) public {\n', '    factory = _factory;\n', '  }\n', '\n', '  /**\n', '   * @notice Determine the endBlock based on inputs. Used on the front end to show the exact settings the Farm contract will be deployed with\n', '   */\n', '  function determineEndBlock(uint256 _amount, uint256 _blockReward, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus) public pure returns (uint256, uint256) {\n', '    FarmParameters memory params;\n', '    params.bonusBlocks = _bonusEndBlock.sub(_startBlock);\n', '    params.totalBonusReward = params.bonusBlocks.mul(_bonus).mul(_blockReward);\n', '    params.numBlocks = _amount.sub(params.totalBonusReward).div(_blockReward);\n', '    params.endBlock = params.numBlocks.add(params.bonusBlocks).add(_startBlock);\n', '\n', '    uint256 nonBonusBlocks = params.endBlock.sub(_bonusEndBlock);\n', '    uint256 effectiveBlocks = params.bonusBlocks.mul(_bonus).add(nonBonusBlocks);\n', '    uint256 requiredAmount = _blockReward.mul(effectiveBlocks);\n', '    return (params.endBlock, requiredAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Determine the blockReward based on inputs specifying an end date. Used on the front end to show the exact settings the Farm contract will be deployed with\n', '   */\n', '  function determineBlockReward(uint256 _amount, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus, uint256 _endBlock) public pure returns (uint256, uint256) {\n', '    uint256 bonusBlocks = _bonusEndBlock.sub(_startBlock);\n', '    uint256 nonBonusBlocks = _endBlock.sub(_bonusEndBlock);\n', '    uint256 effectiveBlocks = bonusBlocks.mul(_bonus).add(nonBonusBlocks);\n', '    uint256 blockReward = _amount.div(effectiveBlocks);\n', '    uint256 requiredAmount = blockReward.mul(effectiveBlocks);\n', '    return (blockReward, requiredAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Creates a new FarmUniswap contract and registers it in the \n', '   * .sol. All farming rewards are locked in the FarmUniswap Contract\n', '   */\n', '  function createFarmUniswap(IERC20 _rewardToken, uint256 _amount, IERC20 _lpToken, IUniFactory _swapFactory, uint256 _blockReward, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus) public onlyOwner returns (address){\n', "    require(_startBlock > block.number, 'START'); // ideally at least 24 hours more to give farmers time\n", "    require(_bonus > 0, 'BONUS');\n", "    require(address(_rewardToken) != address(0), 'REWARD TOKEN');\n", "    require(_blockReward > 1000, 'BLOCK REWARD'); // minimum 1000 divisibility per block reward\n", '    IUniFactory swapFactory = _swapFactory;\n', '    // ensure this pair is on swapFactory by querying the factory\n', '    IUniswapV2Pair lpair = IUniswapV2Pair(address(_lpToken));\n', '    address factoryPairAddress = swapFactory.getPair(lpair.token0(), lpair.token1());\n', "    require(factoryPairAddress == address(_lpToken), 'This pair is not on _swapFactory exchange');\n", '\n', '    FarmParameters memory params;\n', '    (params.endBlock, params.requiredAmount) = determineEndBlock(_amount, _blockReward, _startBlock, _bonusEndBlock, _bonus);\n', '\n', '    TransferHelper.safeTransferFrom(address(_rewardToken), address(_msgSender()), address(this), params.requiredAmount);\n', '    FarmUniswap newFarm = new FarmUniswap(address(factory), address(this));\n', '    TransferHelper.safeApprove(address(_rewardToken), address(newFarm), params.requiredAmount);\n', '    newFarm.init(_rewardToken, params.requiredAmount, _lpToken, _blockReward, _startBlock, params.endBlock, _bonusEndBlock, _bonus);\n', '\n', '    factory.registerFarm(address(newFarm));\n', '    return (address(newFarm));\n', '  }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 999999\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']