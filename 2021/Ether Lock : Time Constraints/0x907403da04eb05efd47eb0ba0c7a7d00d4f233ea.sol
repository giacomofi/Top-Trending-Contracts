['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-26\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-25\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'contract ComptrollerLike {\n', '    function getAllMarkets() public view returns (address[] memory);\n', '    function allMarkets(uint m) public view returns(address);\n', '    function markets(address cTokenAddress) public view returns (bool, uint, bool);\n', '    function oracle() public view returns(address);\n', '    function claimComp(address holder) public;    \n', '    function compAccrued(address holder) public view returns(uint);\n', '    function getCompAddress() public view returns (address);\n', '    function getAssetsIn(address account) public view returns(address[] memory);\n', '}\n', '\n', 'contract BComptrollerLike {\n', '    function c2b(address ctoken) public view returns(address);\n', '}\n', '\n', 'contract OracleLike {\n', '    function getUnderlyingPrice(address cToken) external view returns (uint);\n', '}\n', '\n', 'contract ERC20Like {\n', '    function decimals() public returns(uint);\n', '    function name() public returns(string memory);\n', '    function balanceOf(address user) public returns(uint);\n', '    function allowance(address owner, address spender) public returns(uint);\n', '}\n', '\n', 'contract CTokenLike {\n', '    function underlying() public returns(address);\n', '    function exchangeRateCurrent() public returns (uint);\n', '    function borrowRatePerBlock() public returns (uint);\n', '    function supplyRatePerBlock() public returns (uint);\n', '    function borrowBalanceCurrent(address account) public returns (uint);\n', '    function totalSupply() public returns (uint);\n', '}\n', '\n', 'contract RegistryLike {\n', '    function getAvatar(address user) public returns(address);\n', '    function avatarLength() public view returns(uint);\n', '    function avatars(uint i) public view returns(address);\n', '    function comptroller() public view returns(address);\n', '    function score() public view returns(address);\n', '}\n', '\n', 'contract JarConnectorLike {\n', '    function getUserScore(address user) external view returns (uint);\n', '    function getGlobalScore() external view returns (uint);    \n', '    function getUserScoreProgressPerSec(address user) external view returns (uint);\n', '}\n', '\n', 'contract ScoreLike {\n', '    function updateIndex(address[] calldata cTokens) external;\n', '}\n', '\n', '\n', 'contract UserInfo {\n', '    struct TokenInfo {\n', '        address[] btoken;\n', '        address[] ctoken;\n', '        uint[] ctokenDecimals;\n', '        address[] underlying;\n', '        uint[] underlyingDecimals;\n', '        uint[] ctokenExchangeRate;\n', '        uint[] underlyingPrice;\n', '        uint[] borrowRate;\n', '        uint[] supplyRate;\n', '        bool[] listed;\n', '        uint[] collateralFactor;\n', '        uint[] bTotalSupply;\n', '    }\n', '    \n', '    struct PerUserInfo {\n', '        uint[] ctokenBalance;\n', '        uint[] ctokenBorrowBalance;\n', '        uint[] underlyingWalletBalance;\n', '        uint[] underlyingAllowance;\n', '    }\n', '\n', '    struct ScoreInfo {\n', '        uint userScore;\n', '        uint userScoreProgressPerSec;        \n', '        uint totalScore;\n', '    }\n', '\n', '    struct ImportInfo {\n', '        address avatar;\n', '        uint[]  ctokenAllowance;\n', '        uint    availableEthBalance; \n', '    }\n', '\n', '    struct CompTokenInfo {\n', '        uint    compBalance;\n', '        address comp;\n', '    }\n', '\n', '    struct JarInfo {\n', '        uint[] ctokenBalance;\n', '    }\n', '    \n', '    struct TvlInfo {\n', '        uint numAccounts;\n', '        uint[] ctokenBalance;\n', '    }\n', '\n', '    struct Info {\n', '        TokenInfo     tokenInfo;\n', '        PerUserInfo   cUser; // data on compound\n', '        PerUserInfo   bUser; // data on B\n', '        ImportInfo    importInfo;\n', '        ScoreInfo     scoreInfo;\n', '        CompTokenInfo compTokenInfo;\n', '        JarInfo       jarInfo;\n', '        TvlInfo       tvlInfo;\n', '    }\n', '    \n', '    address constant ETH = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '    \n', '    function isCETH(address ctoken) internal returns(bool) {\n', '        string memory name = ERC20Like(ctoken).name();\n', '        if(keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked("Compound ETH"))) return true;\n', '        if(keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked("Compound Ether"))) return true;\n', '        \n', '        return false;\n', '    }\n', '    \n', '    function getNumMarkets(address comptroller) public returns(uint) {\n', '        bool succ = true;\n', '        uint i;\n', '        for(i = 0 ; ; i++) {\n', '            (succ,) = comptroller.call.gas(1e6)(abi.encodeWithSignature("allMarkets(uint256)", i));\n', '            \n', '            if(! succ) return i;\n', '        }\n', '        \n', '        return 0;\n', '    }\n', '    \n', '    function getTokenInfo(address comptroller, address bComptroller) public returns(TokenInfo memory info) {\n', '        address[] memory markets = ComptrollerLike(comptroller).getAllMarkets();\n', '        uint numMarkets = markets.length;\n', '        info.btoken = new address[](numMarkets);        \n', '        info.ctoken = new address[](numMarkets);\n', '        for(uint m = 0 ; m < numMarkets ; m++) {\n', '            info.ctoken[m] = markets[m];\n', '            info.btoken[m] = BComptrollerLike(bComptroller).c2b(info.ctoken[m]);\n', '        }\n', '        info.ctokenDecimals = new uint[](info.ctoken.length);\n', '        info.underlying = new address[](info.ctoken.length);\n', '        info.underlyingDecimals = new uint[](info.ctoken.length);\n', '        info.ctokenExchangeRate = new uint[](info.ctoken.length);\n', '        info.underlyingPrice = new uint[](info.ctoken.length);\n', '        info.borrowRate = new uint[](info.ctoken.length);\n', '        info.supplyRate = new uint[](info.ctoken.length);\n', '        info.listed = new bool[](info.ctoken.length);\n', '        info.collateralFactor = new uint[](info.ctoken.length);\n', '        info.bTotalSupply = new uint[](info.ctoken.length);\n', '\n', '        for(uint i = 0 ; i < info.ctoken.length ; i++) {\n', '            info.ctokenDecimals[i] = ERC20Like(info.ctoken[i]).decimals();\n', '            if(isCETH(info.ctoken[i])) {\n', '                info.underlying[i] = ETH;\n', '                info.underlyingDecimals[i] = 18;\n', '            }\n', '            else {\n', '                info.underlying[i] = CTokenLike(info.ctoken[i]).underlying();\n', '                info.underlyingDecimals[i] = ERC20Like(info.underlying[i]).decimals();\n', '            }\n', '            \n', '            info.ctokenExchangeRate[i] = CTokenLike(info.ctoken[i]).exchangeRateCurrent();\n', '            info.underlyingPrice[i] = OracleLike(ComptrollerLike(comptroller).oracle()).getUnderlyingPrice(info.ctoken[i]);\n', '            info.borrowRate[i] = CTokenLike(info.ctoken[i]).borrowRatePerBlock();\n', '            info.supplyRate[i] = CTokenLike(info.ctoken[i]).supplyRatePerBlock();\n', '            \n', '            (info.listed[i], info.collateralFactor[i], ) = ComptrollerLike(comptroller).markets(info.ctoken[i]);\n', '\n', '            if(info.btoken[i] != address(0)) info.bTotalSupply[i] = CTokenLike(info.btoken[i]).totalSupply();\n', '        }\n', '        \n', '        return info;\n', '    }\n', '    \n', '    function isIn(address[] memory array, address elm) internal pure returns(bool) {\n', '        for(uint i = 0 ; i < array.length ; i++) {\n', '            if(elm == array[i]) return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function getPerUserInfo(address user, address[] memory ctoken, address[] memory assetsIn, address[] memory underlying) public returns(PerUserInfo memory info) {\n', '        info.ctokenBalance = new uint[](ctoken.length);\n', '        info.ctokenBorrowBalance = new uint[](ctoken.length);\n', '        info.underlyingWalletBalance = new uint[](ctoken.length);\n', '        info.underlyingAllowance = new uint[](ctoken.length);\n', '\n', '        \n', '        for(uint i = 0 ; i < ctoken.length ; i++) {\n', '            if(ctoken[i] == address(0)) continue;\n', '\n', '            info.ctokenBalance[i] = isIn(assetsIn, ctoken[i]) ? ERC20Like(ctoken[i]).balanceOf(user) : 0;\n', '            info.ctokenBorrowBalance[i] = CTokenLike(ctoken[i]).borrowBalanceCurrent(user);\n', '            if(underlying[i] == ETH) {\n', '                info.underlyingWalletBalance[i] = user.balance;\n', '                info.underlyingAllowance[i] = uint(-1);\n', '            }\n', '            else {\n', '                info.underlyingWalletBalance[i] = ERC20Like(underlying[i]).balanceOf(user);\n', '                info.underlyingAllowance[i] = ERC20Like(underlying[i]).allowance(user, ctoken[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function getImportInfo(address user, address[] memory ctoken, address registry, address sugarDaddy) public returns(ImportInfo memory info) {\n', '        info.avatar = RegistryLike(registry).getAvatar(user);\n', '        info.ctokenAllowance = new uint[](ctoken.length);\n', '        for(uint i = 0 ; i < ctoken.length ; i++) {\n', '            info.ctokenAllowance[i] = ERC20Like(ctoken[i]).allowance(user, info.avatar);\n', '        }\n', '        info.availableEthBalance = sugarDaddy.balance;\n', '    }\n', '\n', '    function getScoreInfo(address user, address jarConnector) public view returns(ScoreInfo memory info) {\n', '        info.userScore = JarConnectorLike(jarConnector).getUserScore(user);\n', '        info.userScoreProgressPerSec = JarConnectorLike(jarConnector).getUserScoreProgressPerSec(user);\n', '        info.totalScore = JarConnectorLike(jarConnector).getGlobalScore();\n', '    }\n', '\n', '\n', '    function getCompTokenInfo(address user, address comptroller, address registry) public returns(CompTokenInfo memory info) {\n', '        address avatar = RegistryLike(registry).getAvatar(user);\n', '        address comp = ComptrollerLike(comptroller).getCompAddress();\n', '        ComptrollerLike(comptroller).claimComp(avatar);\n', '        uint heldComp = ComptrollerLike(comptroller).compAccrued(avatar);\n', '\n', '        info.compBalance = ERC20Like(comp).balanceOf(avatar) + heldComp;\n', '        info.comp = comp;\n', '    }\n', '\n', '    function getJarInfo(address jar, address[] memory ctoken) public returns(JarInfo memory info) {\n', '        info.ctokenBalance = new uint[](ctoken.length);\n', '        for(uint i = 0 ; i < ctoken.length ; i++) {\n', '            info.ctokenBalance[i] = ERC20Like(ctoken[i]).balanceOf(jar); \n', '        }\n', '    }\n', '\n', '    function getTvlInfo(address[] memory ctokens, address registry) public returns(TvlInfo memory info) {\n', '        info.ctokenBalance = new uint[](ctokens.length);\n', '        uint numAvatars = RegistryLike(registry).avatarLength();\n', '        for(uint i = 0 ; i < numAvatars ; i++) {\n', '            address avatar = RegistryLike(registry).avatars(i);\n', '            for(uint j = 0 ; j < ctokens.length ; j++) {\n', '                info.ctokenBalance[j] += ERC20Like(ctokens[j]).balanceOf(avatar);\n', '            }\n', '        }\n', '        \n', '        info.numAccounts = numAvatars;\n', '    }\n', '\n', '    function getUserInfo(address user,\n', '                         address comptroller,\n', '                         address bComptroller,\n', '                         address registry,\n', '                         address sugarDaddy,\n', '                         address jarConnector,\n', '                         address jar,\n', '                         bool    getTvl) public returns(Info memory info) {\n', '        info.tokenInfo = getTokenInfo(comptroller, bComptroller);\n', '        // check which assets are in\n', '        address avatar = RegistryLike(registry).getAvatar(user);\n', '        address[] memory assetsIn = ComptrollerLike(comptroller).getAssetsIn(avatar);\n', '        address[] memory bAssetsIn = new address[](assetsIn.length);\n', '        for(uint i = 0 ; i < assetsIn.length ; i++) {\n', '            bAssetsIn[i] = BComptrollerLike(bComptroller).c2b(assetsIn[i]);\n', '        }\n', '        info.bUser = getPerUserInfo(user, info.tokenInfo.btoken, bAssetsIn, info.tokenInfo.underlying);\n', '        // all tokens are assumed to be in - since we want to import all of them\n', '        info.cUser = getPerUserInfo(user, info.tokenInfo.ctoken, info.tokenInfo.ctoken, info.tokenInfo.underlying);\n', '        info.importInfo = getImportInfo(user, info.tokenInfo.ctoken, registry, sugarDaddy);\n', '\n', '        address score = RegistryLike(registry).score();\n', '        ScoreLike(score).updateIndex(info.tokenInfo.ctoken);\n', '        info.scoreInfo = getScoreInfo(user, jarConnector);\n', '        info.compTokenInfo = getCompTokenInfo(user, comptroller, registry);\n', '        info.jarInfo = getJarInfo(jar, info.tokenInfo.ctoken);\n', '        if(getTvl) info.tvlInfo = getTvlInfo(info.tokenInfo.ctoken, registry);\n', '    }\n', '}\n', '\n', 'contract FakeBComptroller {\n', '    function c2b(address a) pure public returns(address) { return a;}\n', '}']