['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-14\n', '*/\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', 'pragma solidity <0.6 >=0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '\n', '  /*@CTK SafeMath_mul\n', '    @tag spec\n', '    @post __reverted == __has_assertion_failure\n', '    @post __has_assertion_failure == __has_overflow\n', '    @post __reverted == false -> c == a * b\n', '    @post msg == msg__post\n', '   */\n', '  /* CertiK Smart Labelling, for more details visit: https://certik.org */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  /*@CTK SafeMath_div\n', '    @tag spec\n', '    @pre b != 0\n', '    @post __reverted == __has_assertion_failure\n', '    @post __has_overflow == true -> __has_assertion_failure == true\n', '    @post __reverted == false -> __return == a / b\n', '    @post msg == msg__post\n', '   */\n', '  /* CertiK Smart Labelling, for more details visit: https://certik.org */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  /*@CTK SafeMath_sub\n', '    @tag spec\n', '    @post __reverted == __has_assertion_failure\n', '    @post __has_overflow == true -> __has_assertion_failure == true\n', '    @post __reverted == false -> __return == a - b\n', '    @post msg == msg__post\n', '   */\n', '  /* CertiK Smart Labelling, for more details visit: https://certik.org */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  /*@CTK SafeMath_add\n', '    @tag spec\n', '    @post __reverted == __has_assertion_failure\n', '    @post __has_assertion_failure == __has_overflow\n', '    @post __reverted == false -> c == a + b\n', '    @post msg == msg__post\n', '   */\n', '  /* CertiK Smart Labelling, for more details visit: https://certik.org */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity <6.0 >=0.4.0;\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '  address public owner;\n', '\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '\n', '  /**\n', '   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '   * account.\n', '   */\n', '  constructor() public {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(msg.sender == owner);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    require(newOwner != address(0));\n', '    emit OwnershipTransferred(owner, newOwner);\n', '    owner = newOwner;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/token/IERC20Basic.sol\n', '\n', 'pragma solidity <0.6 >=0.4.21;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract IERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/token/IERC20.sol\n', '\n', 'pragma solidity <0.6 >=0.4.21;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract IERC20 is IERC20Basic {\n', '  function name() external view returns (string memory);\n', '  function symbol() external view returns (string memory);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/token/IMintableToken.sol\n', '\n', 'pragma solidity <0.6 >=0.4.24;\n', '\n', '\n', 'contract IMintableToken is IERC20 {\n', '    function mint(address, uint) external returns (bool);\n', '    function burn(uint) external returns (bool);\n', '\n', '    event Minted(address indexed to, uint256 amount);\n', '    event Burned(address indexed from, uint256 amount);\n', '    event MinterAdded(address indexed minter);\n', '    event MinterRemoved(address indexed minter);\n', '}\n', '\n', '// File: contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type,\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', "     * execution of a contract's constructor, its address will be reported as\n", '     * not containing a contract.\n', '     *\n', '     * > It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/token/SafeERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/uniswapv2/IRouter.sol\n', '\n', 'pragma solidity >=0.5.0 <0.8.0;\n', '\n', 'interface IRouter {\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function swapETHForExactTokens(\n', '        uint amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint[] memory amounts);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n', '}\n', '\n', '// File: contracts/AeolusV2dot1.sol\n', '\n', 'pragma solidity <0.6 >=0.4.24;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// Aeolus is the master of Cyclone tokens. He can distribute CYC and he is a fair guy.\n', '//\n', "// Note that it's ownable and the owner wields tremendous power. The ownership\n", '// will be transferred to a governance smart contract once CYC is sufficiently\n', '// distributed and the community can show to govern itself.\n', '//\n', "// Have fun reading it. Hopefully it's bug-free. God bless.\n", 'contract AeolusV2dot1 is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // Info of each user.\n', '    struct UserInfo {\n', '        uint256 amount;     // How many LP tokens the user has provided.\n', '        uint256 rewardDebt; // Reward debt. See explanation below.\n', '        //\n', '        // We do some fancy math here. Basically, any point in time, the amount of CYCs\n', '        // entitled to a user but is pending to be distributed is:\n', '        //\n', '        //   pending reward = (user.amount * accCYCPerShare) - user.rewardDebt\n', '        //\n', "        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n", '        //   1. Update accCYCPerShare and lastRewardBlock\n', '        //   2. User receives the pending reward sent to his/her address.\n', "        //   3. User's `amount` gets updated.\n", "        //   4. User's `rewardDebt` gets updated.\n", '    }\n', '\n', '\n', '    // Address of LP token contract.\n', '    IERC20 public lpToken;\n', '    // Accumulated CYCs per share, times 1e12. See below.\n', '    uint256 public accCYCPerShare;\n', '    // Last block reward block height\n', '    uint256 public lastRewardBlock;\n', '    // Reward per block\n', '    uint256 public rewardPerBlock;\n', '    // Reward to distribute\n', '    uint256 public rewardToDistribute;\n', '    // Entrance Fee Rate\n', '    uint256 public entranceFeeRate;\n', '\n', '    IERC20 public wrappedCoin;\n', '    IRouter public router;\n', '    // The Cyclone TOKEN\n', '    IMintableToken public cycToken;\n', '\n', '    // Info of each user that stakes LP tokens.\n', '    mapping (address => UserInfo) public userInfo;\n', '\n', '    event RewardAdded(uint256 amount, bool isBlockReward);\n', '    event Deposit(address indexed user, uint256 amount, uint256 fee);\n', '    event Withdraw(address indexed user, uint256 amount);\n', '    event EmergencyWithdraw(address indexed user, uint256 amount);\n', '\n', '    constructor(IMintableToken _cycToken, IERC20 _lpToken, address _router, IERC20 _wrappedCoin) public {\n', '        cycToken = _cycToken;\n', '        lastRewardBlock = block.number;\n', '        lpToken = _lpToken;\n', '        router = IRouter(_router);\n', '        wrappedCoin = _wrappedCoin;\n', '        require(_lpToken.approve(_router, uint256(-1)), "failed to approve router");\n', '        require(_wrappedCoin.approve(_router, uint256(-1)), "failed to approve router");\n', '    }\n', '\n', '    function setEntranceFeeRate(uint256 _entranceFeeRate) public onlyOwner {\n', '        require(_entranceFeeRate < 10000, "invalid entrance fee rate");\n', '        entranceFeeRate = _entranceFeeRate;\n', '    }\n', '\n', '    function setRewardPerBlock(uint256 _rewardPerBlock) public onlyOwner {\n', '        updateBlockReward();\n', '        rewardPerBlock = _rewardPerBlock;\n', '    }\n', '\n', '    function rewardPending() internal view returns (uint256) {\n', '        uint256 reward = block.number.sub(lastRewardBlock).mul(rewardPerBlock);\n', '        uint256 cycBalance = cycToken.balanceOf(address(this)).sub(rewardToDistribute);\n', '        if (cycBalance < reward) {\n', '            return cycBalance;\n', '        }\n', '        return reward;\n', '    }\n', '\n', '    // View function to see pending reward on frontend.\n', '    function pendingReward(address _user) external view returns (uint256) {\n', '        UserInfo storage user = userInfo[_user];\n', '        uint256 acps = accCYCPerShare;\n', '        if (rewardPerBlock > 0) {\n', '            uint256 lpSupply = lpToken.balanceOf(address(this));\n', '            if (block.number > lastRewardBlock && lpSupply > 0) {\n', '                acps = acps.add(rewardPending().mul(1e12).div(lpSupply));\n', '            }\n', '        }\n', '\n', '        return user.amount.mul(acps).div(1e12).sub(user.rewardDebt);\n', '    }\n', '\n', '    // Update reward variables to be up-to-date.\n', '    function updateBlockReward() public {\n', '        if (block.number <= lastRewardBlock || rewardPerBlock == 0) {\n', '            return;\n', '        }\n', '        uint256 lpSupply = lpToken.balanceOf(address(this));\n', '        uint256 reward = rewardPending();\n', '        if (lpSupply == 0 || reward == 0) {\n', '            lastRewardBlock = block.number;\n', '            return;\n', '        }\n', '        rewardToDistribute = rewardToDistribute.add(reward);\n', '        emit RewardAdded(reward, true);\n', '        lastRewardBlock = block.number;\n', '        accCYCPerShare = accCYCPerShare.add(reward.mul(1e12).div(lpSupply));\n', '    }\n', '\n', '    // Deposit LP tokens to Aeolus for CYC allocation.\n', '    function deposit(uint256 _amount) public {\n', '        updateBlockReward();\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        uint256 originAmount = user.amount;\n', '        uint256 acps = accCYCPerShare;\n', '        if (originAmount > 0) {\n', '            uint256 pending = originAmount.mul(acps).div(1e12).sub(user.rewardDebt);\n', '            if (pending > 0) {\n', '                safeCYCTransfer(msg.sender, pending);\n', '            }\n', '        }\n', '        uint256 feeInCYC = 0;\n', '        if (_amount > 0) {\n', '            lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\n', '            uint256 entranceFee = _amount.mul(entranceFeeRate).div(10000);\n', '            if (entranceFee > 0) {\n', '                IERC20 wct = wrappedCoin;\n', '                (uint256 wcAmount, uint256 cycAmount) = router.removeLiquidity(address(wct), address(cycToken), entranceFee, 0, 0, address(this), block.timestamp.mul(2));\n', '                if (wcAmount > 0) {\n', '                    address[] memory path = new address[](2);\n', '                    path[0] = address(wct);\n', '                    path[1] = address(cycToken);\n', '                    uint256[] memory amounts = router.swapExactTokensForTokens(wcAmount, 0, path, address(this), block.timestamp.mul(2));\n', '                    feeInCYC = cycAmount.add(amounts[1]);\n', '                } else {\n', '                    feeInCYC = cycAmount;\n', '                }\n', '                if (feeInCYC > 0) {\n', '                    require(cycToken.burn(feeInCYC), "failed to burn cyc token");\n', '                }\n', '                _amount = _amount.sub(entranceFee);\n', '            }\n', '            user.amount = originAmount.add(_amount);\n', '        }\n', '        user.rewardDebt = user.amount.mul(acps).div(1e12);\n', '        emit Deposit(msg.sender, _amount, feeInCYC);\n', '    }\n', '\n', '    // Withdraw LP tokens from Aeolus.\n', '    function withdraw(uint256 _amount) public {\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        uint256 originAmount = user.amount;\n', '        require(originAmount >= _amount, "withdraw: not good");\n', '        updateBlockReward();\n', '        uint256 acps = accCYCPerShare;\n', '        uint256 pending = originAmount.mul(acps).div(1e12).sub(user.rewardDebt);\n', '        if (pending > 0) {\n', '            safeCYCTransfer(msg.sender, pending);\n', '        }\n', '        if (_amount > 0) {\n', '            user.amount = originAmount.sub(_amount);\n', '            lpToken.safeTransfer(address(msg.sender), _amount);\n', '        }\n', '        user.rewardDebt = user.amount.mul(acps).div(1e12);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw() public {\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        uint256 amount = user.amount;\n', '        user.amount = 0;\n', '        user.rewardDebt = 0;\n', '        lpToken.safeTransfer(address(msg.sender), amount);\n', '        emit EmergencyWithdraw(msg.sender, amount);\n', '    }\n', '\n', '    // Safe CYC transfer function, just in case if rounding error causes pool to not have enough CYCs.\n', '    function safeCYCTransfer(address _to, uint256 _amount) internal {\n', '        IMintableToken token = cycToken;\n', '        uint256 cycBalance = token.balanceOf(address(this));\n', '        if (_amount > cycBalance) {\n', '            _amount = cycBalance;\n', '        }\n', '        rewardToDistribute = rewardToDistribute.sub(_amount);\n', '        require(token.transfer(_to, _amount), "failed to transfer cyc token");\n', '    }\n', '}']