['// SPDX-License-Identifier: LGPL-3.0-or-later\n', 'pragma solidity 0.5.17;\n', '\n', 'import "./Math.sol";\n', 'import "./SafeMath.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./Owned.sol";\n', 'import "./Context.sol";\n', '\n', '\n', 'contract IRewardPool {\n', '    function notifyRewards(uint reward) external;\n', '}\n', '\n', 'contract Aggregator is Ownable, ReentrancyGuard {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '\n', '    /// Protocol developers rewards\n', '    uint public constant FEE_FACTOR = 3;\n', '\n', '    // Beneficial address\n', '    address public beneficial;\n', '\n', '    /// Reward token\n', '    IERC20 public rewardToken;\n', '\n', '    // Reward pool address\n', '    address public rewardPool;\n', '\n', '    constructor(address _token1, address _rewardPool) public {\n', '        beneficial = msg.sender;\n', '        \n', '        rewardToken = IERC20(_token1);\n', '        rewardPool = _rewardPool;\n', '    }\n', '\n', '    /// Capture tokens or any other tokens\n', '    function capture(address _token) onlyOwner external {\n', '        require(_token != address(rewardToken), "capture: can not capture reward tokens");\n', '\n', '        uint balance = IERC20(_token).balanceOf(address(this));\n', '        IERC20(_token).safeTransfer(beneficial, balance);\n', '    }  \n', '\n', '    function notifyRewards() onlyOwner nonReentrant external {\n', '        uint reward = rewardToken.balanceOf(address(this));\n', '\n', '        /// Split the governance and protocol developers rewards\n', '        uint _developerRewards = reward.div(FEE_FACTOR);\n', '        uint _governanceRewards = reward.sub(_developerRewards);\n', '\n', '        rewardToken.safeTransfer(beneficial, _developerRewards);\n', '        rewardToken.safeTransfer(rewardPool, _governanceRewards);\n', '\n', '        IRewardPool(rewardPool).notifyRewards(_governanceRewards);\n', '    }\n', '}\n', '\n', 'contract RewardPool is Ownable, ReentrancyGuard {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '\n', '    event TokenDeposit(address account, uint amount);\n', '    event TokenWithdraw(address account, uint amount);\n', '    event TokenClaim(address account, uint amount);\n', '    event RewardAdded(uint reward);\n', '\n', '    bytes32 public merkleRoot;\n', '\n', '    uint public periodFinish = 0;\n', '    uint public rewardRate = 0;\n', '    uint public lastUpdateTime;\n', '    uint public rewardPerTokenStored = 0;\n', '    uint public rewardsDuration = 7 days;\n', '\n', '    // Beneficial address\n', '    address public beneficial = address(this);\n', '\n', '    // User award balance\n', '    mapping(address => uint) public rewards;\n', '    mapping(address => uint) public userRewardPerTokenPaid;\n', '\n', '    /// Staking token\n', '    IERC20 private _token0;\n', '\n', '    /// Reward token\n', '    IERC20 private _token1;\n', '\n', '    /// Total rewards\n', '    uint private _rewards;\n', '    uint private _remainingRewards;\n', '\n', '    /// Total amount of user staking tokens\n', '    uint private _totalSupply;\n', '\n', '    /// The amount of tokens staked\n', '    mapping(address => uint) private _balances;\n', '\n', '    /// The remaining withdrawals of staked tokens\n', '    mapping(address => uint) internal withdrawalOf;  \n', '\n', '    /// The remaining withdrawals of reward tokens\n', '    mapping(address => uint) internal claimOf;\n', '\n', '    address public rewardDistribution;\n', '\n', '    modifier updateReward(address account) {\n', '        rewardPerTokenStored = rewardPerToken();\n', '        lastUpdateTime = lastTimeRewardApplicable();\n', '        if (account != address(0)) {\n', '            rewards[account] = earned(account);\n', '            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n', '        }\n', '        _;\n', '    }\n', '\n', '    modifier onlyRewardDistribution() {\n', '        require(msg.sender == rewardDistribution, "Caller is not reward distribution");\n', '        _;\n', '    }\n', '    \n', '    constructor (address token0, address token1) public {\n', '        require(token0 != address(0), "FeePool: zero address");\n', '        require(token1 != address(0), "FeePool: zero address");\n', '\n', '        _token0 = IERC20(token0);\n', '        _token1 = IERC20(token1);\n', '    }\n', '\n', '    function setBeneficial(address _beneficial) onlyOwner external {\n', '        require(_beneficial != address(this), "setBeneficial: can not send to self");\n', '        require(_beneficial != address(0), "setBeneficial: can not burn tokens");\n', '        beneficial = _beneficial;\n', '    }\n', '\n', '    function setRewardDistribution(address _rewardDistribution)\n', '        external\n', '        onlyOwner\n', '    {\n', '        rewardDistribution = _rewardDistribution;\n', '    }\n', '    \n', '    /// Capture tokens or any other tokens\n', '    function capture(address _token) onlyOwner external {\n', '        require(_token != address(_token0), "capture: can not capture staking tokens");\n', '        require(_token != address(_token1), "capture: can not capture reward tokens");\n', '        require(beneficial != address(this), "capture: can not send to self");\n', '        require(beneficial != address(0), "capture: can not burn tokens");\n', '        uint balance = IERC20(_token).balanceOf(address(this));\n', '        IERC20(_token).safeTransfer(beneficial, balance);\n', '    }  \n', '\n', '    function _setMerkleRoot(bytes32 merkleRoot_) internal {\n', '        merkleRoot = merkleRoot_;\n', '    }\n', '\n', '    function notifyRewards(uint reward)\n', '        external\n', '        onlyRewardDistribution\n', '        updateReward(address(0))\n', '    {\n', '        if (block.timestamp >= periodFinish) {\n', '            rewardRate = reward.div(rewardsDuration);\n', '        } else {\n', '            uint remaining = periodFinish.sub(block.timestamp);\n', '            uint leftover = remaining.mul(rewardRate);\n', '            rewardRate = reward.add(leftover).div(rewardsDuration);\n', '        }\n', '\n', '        // Ensure the provided reward amount is not more than the balance in the contract.\n', '        // This keeps the reward rate in the right range, preventing overflows due to\n', '        // very high values of rewardRate in the earned and rewardsPerToken functions;\n', '        // Reward + leftover must be less than 2^256 / 10^18 to avoid overflow.\n', '        uint balance = _token1.balanceOf(address(this));\n', '        require(rewardRate <= balance.div(rewardsDuration), "notifyRewards: provided reward too high");\n', '\n', '        lastUpdateTime = block.timestamp;\n', '        periodFinish = block.timestamp.add(rewardsDuration);\n', '        emit RewardAdded(reward);\n', '    }\n', '\n', '    /// Deposit staking tokens\n', '    function deposit(uint amount) \n', '        external \n', '        nonReentrant\n', '        updateReward(msg.sender)\n', '    {\n', '        /// Verify the eligible wallet        \n', '        require(amount > 0, "deposit: cannot stake 0");\n', '        require(_token0.balanceOf(msg.sender) >= amount, "deposit: insufficient balance");\n', '        \n', '        _totalSupply = _totalSupply.add(amount);          \n', '        _balances[msg.sender] = _balances[msg.sender].add(amount);\n', '        _token0.safeTransferFrom(msg.sender, address(this), amount);\n', '        \n', '        emit TokenDeposit(msg.sender, amount);\n', '    }\n', '\n', '    /// Withdraw staked tokens\n', '    function withdraw(uint amount) \n', '        external \n', '        nonReentrant\n', '        updateReward(msg.sender)\n', '    {\n', '        require(amount > 0, "withdraw: amount invalid");\n', '        require(msg.sender != address(0), "withdraw: zero address");\n', '        /// Not overflow\n', '        require(_balances[msg.sender] >= amount);\n', '        _totalSupply = _totalSupply.sub(amount);                \n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '        /// Keep track user withdraws\n', '        withdrawalOf[msg.sender] = withdrawalOf[msg.sender].add(amount); \n', '        _token0.safeTransfer(msg.sender, amount);\n', '        emit TokenWithdraw(msg.sender, amount);\n', '    }\n', '\n', '    /// Claim reward tokens\n', '    function claim() \n', '        external \n', '        nonReentrant\n', '        updateReward(msg.sender)\n', '    {\n', '        require(msg.sender != address(0), "claim: zero address");        \n', '        uint reward = rewards[msg.sender];\n', '        require(reward > 0, "claim: zero rewards");        \n', '        require(_token1.balanceOf(address(this)) >= reward, "claim: insufficient balance");        \n', '\n', '        rewards[msg.sender] = 0;\n', '        claimOf[msg.sender] = claimOf[msg.sender].add(reward);\n', '        _token1.safeTransfer(msg.sender, reward);\n', '        emit TokenClaim(msg.sender, reward);\n', '    }\n', '\n', '    function getWithdrawalOf(address _stakeholder) external view returns (uint) {\n', '        return withdrawalOf[_stakeholder];\n', '    }\n', '\n', '    function getClaimOf(address _stakeholder) external view returns (uint) {\n', '        return claimOf[_stakeholder];\n', '    }\n', '\n', '    /// Get remaining rewards of the time period\n', '    function remainingRewards() external view returns(uint) {\n', '        return _remainingRewards;\n', '    }\n', '\n', '    /// Retrieve the stake for a stakeholder\n', '    function stakeOf(address _stakeholder) external view returns (uint) {\n', '        return _balances[_stakeholder];\n', '    }\n', '\n', '    /// Retrieve the stake for a stakeholder\n', '    function rewardOf(address _stakeholder) external view returns (uint) {\n', '        return earned(_stakeholder);\n', '    }\n', '\n', '    function lastTimeRewardApplicable() public view returns (uint) {\n', '        return Math.min(block.timestamp, periodFinish);\n', '    }\n', '\n', '    function rewardPerToken() public view returns (uint) {\n', '        if (getTotalStakes() == 0) {\n', '            return rewardPerTokenStored;\n', '        }\n', '        return\n', '            rewardPerTokenStored.add(\n', '                lastTimeRewardApplicable()\n', '                    .sub(lastUpdateTime)\n', '                    .mul(rewardRate)\n', '                    .mul(1e18)\n', '                    .div(getTotalStakes())\n', '            );\n', '    }\n', '\n', '    function earned(address account) public view returns (uint) {\n', '        return balanceOf(account)\n', '            .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n', '            .div(1e18)\n', '            .add(rewards[account]);\n', '    }\n', '\n', '    /// The total supply of all staked tokens\n', '    function getTotalStakes() public view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint) {\n', '        return _balances[account];\n', '    }     \n', '}']