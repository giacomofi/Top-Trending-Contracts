['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.7.3;\n', 'import {\n', '    IERC20,\n', '    ISafeMath,\n', '    IChainlinkOracle,\n', '    IKladeDiffToken\n', '} from "./Interfaces.sol";\n', '\n', '\n', 'contract ChainlinkReceiver {\n', '    uint256 constant multiple = 10**7;\n', '    uint256 constant initial_factor = 1396984; // initial_factor =  600 * 10^13 / 2^32 rounded to nearest whole number\n', '    // factor = block_reward * seconds_per_block * Hashes_per_second * WBTC_adjustment_factor / constant\n', '    // Formula for Earnings Per Block in BTC = block_reward * 600 * hash_rate / (2^32 * difficulty)\n', '    uint256 constant Q3_end_unix = 1632960000;\n', '\n', '    uint256 constant secondsInDay = 86400; // Number of seconds in a day\n', '    uint256 constant blocksBetweenHalvings = 210000; // Number of blocks between each bitcoin block reward halving ie 12.5 BTC/block -> 6.25 BTC/block\n', '    uint256 constant initialBlockReward = 5000000000; // Initial bitcoin block reward in satoshis\n', '    uint256 constant numBlockBetweenDiffChanges = 2016; // Number of Blocks between each BTC difficulty adjustment(~2 weeks or 2016 blocks)\n', '\n', '    //Static Variable used to check validity of data given by the chainlink oracle\n', '                                          \n', '    uint256 constant minValidDifficulty = 500000000000; // Minimum valid difficulty for Q32021\n', '    uint256 constant maxValidDifficulty = 600000000000000; // Maximum valid difficulty for Q32021\n', '\n', '    uint256 constant minValidBlockNum = 663904; // Minimum valid block number for Q32021\n', '    uint256 constant maxValidBlockNum = 1000000; // Maximum valid block number for Q32021\n', '    uint256 constant maxValidBlockNumberIncrease = 10000; // Maximum valid block number between Chainlink Updates\n', '\n', '    uint256 immutable factor;\n', '\n', '    address public immutable KladeAddress1;\n', '    address public immutable KladeAddress2;\n', '    ISafeMath public immutable safemath;\n', '\n', '    struct ChainlinkUpdate {\n', '        uint256 block_number;\n', '        uint256 difficulty;\n', '        uint80 blocknum_roundID;\n', '        uint80 diff_roundID;\n', '    }\n', '\n', '    struct quarter_details {\n', '        IKladeDiffToken alpha_token;\n', '        IKladeDiffToken omega_token;\n', '        IChainlinkOracle chainlink_diff_oracle;\n', '        IChainlinkOracle chainlink_blocknum_oracle;\n', '        uint256 required_collateral;\n', '        uint256 hedged_revenue;\n', '        uint256 end_unix;\n', '        uint256 intermediateActualMinerEarnings;\n', '        uint256 number_of_updates;\n', '    }\n', '\n', '    quarter_details public Q3_details;\n', '    bool public Q3_set;\n', '    mapping(uint256 => ChainlinkUpdate) public chainlink_data;\n', '\n', '    constructor(\n', '        address klade_address1,\n', '        address klade_address2,\n', '        ISafeMath safemath_contract\n', '    ) {\n', '        KladeAddress1 = klade_address1;\n', '        KladeAddress2 = klade_address2;\n', '        safemath = safemath_contract;\n', '        factor = safemath_contract.mul(initial_factor, multiple);\n', '    }\n', '\n', '    /**\n', '     * Set basic quarter details for Chainlink Receiver\n', '     * @param alpha_token_contract IKladeDiffToken - Klade Alpha Token Contract\n', '     * @param omega_token_contract IKladeDifFToken - Klade Omega Token Contract\n', '     * @param chainlink_diff_oracle IChainlinkOracle - Chainlink oracle contract that provides difficulty information\n', '     * @param chainlink_blocknum_oracle IChainlinkOracle - Chainlink oracle contract that provides difficulty information\n', '     * @param required_collateral uint - required collateral to mint a single pair of Klade Alpha/Omega tokens\n', '     * @param hedged_revenue uint - hedged revenue for bitcoin miners for single pair of tokens\n', '     * @param miner_earnings uint - miner earnings for single pair of tokens\n', '     */\n', '    function set_quarter_details(\n', '        IKladeDiffToken alpha_token_contract,\n', '        IKladeDiffToken omega_token_contract,\n', '        IChainlinkOracle chainlink_diff_oracle,\n', '        IChainlinkOracle chainlink_blocknum_oracle,\n', '        uint256 required_collateral,\n', '        uint256 hedged_revenue,\n', '        uint256 miner_earnings\n', '    ) external {\n', '        require(\n', '            msg.sender == KladeAddress1 || msg.sender == KladeAddress2,\n', '            "Only Klade can set quarter details"\n', '        );\n', '        require(Q3_set == false, "Quarter details already set");\n', '        Q3_details = quarter_details(\n', '            alpha_token_contract,\n', '            omega_token_contract,\n', '            chainlink_diff_oracle,\n', '            chainlink_blocknum_oracle,\n', '            required_collateral,\n', '            hedged_revenue,\n', '            Q3_end_unix,\n', '            miner_earnings,\n', '            0\n', '        );\n', '        Q3_set = true;\n', '    }\n', '\n', '    /**\n', '     * At the call to getChainlinkUpdate at the beginning or end of the quarter, the current_block_number should\n', '     * be passed in as the block number at the beginning or end of the quarter.\n', '     * On all other calls, current_block_number should be fed as the block number\n', '     * at the most recent time the Oracle has updated its data\n', '     */\n', '    function getChainlinkUpdate() external returns (bool updated) {\n', '        require(Q3_set, "Quarter details not set yet");\n', '        uint256 i = Q3_details.number_of_updates;\n', '        require(i < 13, "All datapoints for the quarter have been collected");\n', '\n', '        ChainlinkUpdate memory current_update =\n', '            read_chainlink(\n', '                Q3_details.chainlink_blocknum_oracle,\n', '                Q3_details.chainlink_diff_oracle\n', '            );\n', '        require(\n', '            check_reasonable_values(current_update),\n', '            "Unreasonable Chainlink Data"\n', '        );\n', '        if (\n', '            (i == 0) ||\n', '            new_chainlink_data(\n', '                chainlink_data[safemath.sub(i, 1)],\n', '                current_update\n', '            )\n', '        ) {\n', '            chainlink_data[i] = current_update;\n', '            Q3_details.number_of_updates = safemath.add(\n', '                Q3_details.number_of_updates,\n', '                1\n', '            );\n', '            if (i > 0) {\n', '                Q3_details.intermediateActualMinerEarnings = safemath.add(\n', '                    Q3_details.intermediateActualMinerEarnings,\n', '                    additional_miner_earnings(\n', '                        chainlink_data[safemath.sub(i, 1)],\n', '                        current_update\n', '                    )\n', '                );\n', '            }\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * Checks if the current_update has updated difficulty and block_number values\n', '     * compared to last_update. If either the difficulty or the block_number has\n', '     * not been updated by Chainlink, this returns false.\n', '     * @param last_update ChainlinkUpdate - previous update data returned by Chainlink Oracle\n', '     * @param current_update ChainlinkUpdate - most recent update data returned by Chainlink Oracle\n', '     */\n', '    function new_chainlink_data(\n', '        ChainlinkUpdate memory last_update,\n', '        ChainlinkUpdate memory current_update\n', '    ) internal pure returns (bool new_data) {\n', '        bool new_difficulty_data =\n', '            current_update.diff_roundID != last_update.diff_roundID;\n', '        bool new_blocknum_data =\n', '            current_update.blocknum_roundID != last_update.blocknum_roundID;\n', '        return new_difficulty_data && new_blocknum_data;\n', '    }\n', '\n', '    /**\n', "     * Calls Chainlink's Oracles, gets the latest data, and returns it.\n", '     * @param blocknum_oracle IChainlinkOracle - Chainlink block number oracle\n', '     * @param diff_oracle IChainlinkOracle - Chainlink difficulty number oracle\n', '     */\n', '    function read_chainlink(\n', '        IChainlinkOracle blocknum_oracle,\n', '        IChainlinkOracle diff_oracle\n', '    ) internal view returns (ChainlinkUpdate memory latest) {\n', '        uint80 updated_roundID_diff;\n', '        int256 current_diff;\n', '        uint256 startedAt;\n', '        uint256 updatedAt;\n', '        uint80 answeredInRound;\n', '        int256 current_blocknum;\n', '        uint80 updated_roundID_blocknum;\n', '\n', '        (\n', '            updated_roundID_blocknum,\n', '            current_blocknum,\n', '            startedAt,\n', '            updatedAt,\n', '            answeredInRound\n', '        ) = blocknum_oracle.latestRoundData();\n', '\n', '        (\n', '            updated_roundID_diff,\n', '            current_diff,\n', '            startedAt,\n', '            updatedAt,\n', '            answeredInRound\n', '        ) = diff_oracle.latestRoundData();\n', '\n', '        return\n', '            ChainlinkUpdate(\n', '                uint256(current_blocknum),\n', '                uint256(current_diff),\n', '                updated_roundID_blocknum,\n', '                updated_roundID_diff\n', '            );\n', '    }\n', '\n', '    /**\n', '     * Revenue (in WBTC base units) for 10 TH/s over the blocks from startBlock to endBlock\n', '     * does not account for if there is a halving in between a difficulty update.\n', '     * should not be relevant for Q3 2021\n', '     * @param last_update ChainlinkUpdate - previous update data returned by Chainlink Oracle\n', '     * @param current_update ChainlinkUpdate - most recent update data returned by Chainlink Oracle\n', '     */\n', '    function additional_miner_earnings(\n', '        ChainlinkUpdate memory last_update,\n', '        ChainlinkUpdate memory current_update\n', '    ) internal view returns (uint256 earnings) {\n', '        uint256 startBlock = last_update.block_number;\n', '        uint256 startDiff = last_update.difficulty;\n', '        uint256 endBlock = current_update.block_number;\n', '        uint256 endDiff = current_update.difficulty;\n', '\n', '        require(\n', '            endBlock >= startBlock,\n', '            "Latest Block Number is less than last block number"\n', '        );\n', '        uint256 last_diff_update_block = get_last_diff_update(endBlock);\n', '        if (last_diff_update_block <= startBlock) {\n', '            return\n', '                safemath.mul(\n', '                    safemath.sub(endBlock, startBlock),\n', '                    earnings_on_block(endDiff, startBlock)\n', '                );\n', '        } else {\n', '            uint256 total =\n', '                safemath.mul(\n', '                    safemath.sub(last_diff_update_block, startBlock),\n', '                    earnings_on_block(startDiff, startBlock)\n', '                );\n', '            total = safemath.add(\n', '                total,\n', '                safemath.mul(\n', '                    safemath.sub(endBlock, last_diff_update_block),\n', '                    earnings_on_block(endDiff, endBlock)\n', '                )\n', '            );\n', '            return total;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Returns the Bitcoin block number when difficulty was last updated prior to the given block_num\n', '     * @param block_num uint - bitcoin block number\n', '     */\n', '    function get_last_diff_update(uint256 block_num)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return\n', '            safemath.sub(\n', '                block_num,\n', '                safemath.mod(block_num, numBlockBetweenDiffChanges)\n', '            );\n', '    }\n', '\n', '    /**\n', '     * Returns earnings in WBTC base units\n', '     * @param difficulty uint - bitcoin network difficulty\n', '     * @param block_number uint - bitcoin block number\n', '     */\n', '    function earnings_on_block(uint256 difficulty, uint256 block_number)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 numerator =\n', '            safemath.mul(factor, block_reward_on_block(block_number));\n', '        return safemath.div(numerator, difficulty);\n', '    }\n', '\n', '    /**\n', '     * Returns bitcoin block reward in WBTC base units\n', '     * @param block_number uint - bitcoin block number\n', '     */\n', '    function block_reward_on_block(uint256 block_number)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 divisor =\n', '            2**(safemath.div(block_number, blocksBetweenHalvings));\n', '        return safemath.div(initialBlockReward, divisor);\n', '    }\n', '\n', '    /**\n', '     * Check that the values that are trying to be added to the ChainlinkData \n', '     * for a quarter actually makes sense. \n', '     * Returns True if the update seems reasonable and returns false if the update\n', '     * values seems unreasonable\n', '     * Very generous constraints that are just sanity checks.\n', '     * @param update ChainlinkUpdate - A chainlink update with block number and difficulty data\n', '     */\n', '    function check_reasonable_values(ChainlinkUpdate memory update)\n', '        internal\n', '        view\n', '        returns (bool reasonable)\n', '    {\n', '        uint256 update_diff = update.difficulty;\n', '        uint256 update_block_number = update.block_number;\n', '        uint256 number_of_updates = Q3_details.number_of_updates;\n', '        if (\n', '            (update_diff > maxValidDifficulty) ||\n', '            (update_diff < minValidDifficulty)\n', '        ) {\n', '            return false;\n', '        }\n', '        if (\n', '            (update_block_number > maxValidBlockNum) ||\n', '            (update_block_number < minValidBlockNum)\n', '        ) {\n', '            return false;\n', '        }\n', '        if (number_of_updates > 0) {\n', '            uint256 last_update_block_number =\n', '                chainlink_data[safemath.sub(number_of_updates, 1)].block_number;\n', '            if (update_block_number <= last_update_block_number) {\n', '                return false;\n', '            }\n', '            if (\n', '                update_block_number >\n', '                safemath.add(\n', '                    last_update_block_number,\n', '                    maxValidBlockNumberIncrease\n', '                )\n', '            ) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // payouts are set in WBTC base units for 1.0 tokens\n', '    function set_payouts() public {\n', '        require(\n', '            Q3_details.number_of_updates == 13,\n', '            "Need 13 datapoints before setting payout"\n', '        );\n', '        require(\n', '            (block.timestamp >= Q3_details.end_unix),\n', '            "You cannot set a payout yet"\n', '        );\n', '\n', '        uint256 hedged_revenue = Q3_details.hedged_revenue;\n', '        uint256 required_collateral = Q3_details.required_collateral;\n', '\n', '        uint256 miner_revenue =\n', '            safemath.div(Q3_details.intermediateActualMinerEarnings, multiple);\n', '        if ((hedged_revenue > miner_revenue)) {\n', '            uint256 alpha_token_payout =\n', '                safemath.min(\n', '                    safemath.sub(hedged_revenue, miner_revenue),\n', '                    required_collateral\n', '                );\n', '            uint256 omega_token_payout =\n', '                safemath.sub(required_collateral, alpha_token_payout);\n', '            Q3_details.alpha_token.set_payout(alpha_token_payout);\n', '            Q3_details.omega_token.set_payout(omega_token_payout);\n', '        } else {\n', '            Q3_details.alpha_token.set_payout(0);\n', '            Q3_details.omega_token.set_payout(required_collateral);\n', '        }\n', '    }\n', '\n', '    // If any address accidentally sends any ERC20 token to this address,\n', '    // they can contact us. Off-chain we will verify that the address did\n', '    // in fact accidentally send tokens and return them.\n', '    function anyTokenTransfer(\n', '        IERC20 token,\n', '        uint256 num,\n', '        address to\n', '    ) external returns (bool success) {\n', '        require(\n', '            (msg.sender == KladeAddress1 || msg.sender == KladeAddress2),\n', '            "Only Klade can recover tokens"\n', '        );\n', '        return token.transfer(to, num);\n', '    }\n', '}']