['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-04\n', '*/\n', '\n', 'pragma solidity >=0.7.0 <0.8.0;\n', '\n', '// IN THE FIRST VERSION, CLAIMED BLOCK NONCE IS NOT VERIFIED\n', '// THIS CONTRACT ASSUMES THAT MEV PRODUCER COMPLETELY TRUSTS POOL OPERATOR THAT:\n', '// (1) PROVIDED NONCE IS VALID\n', '// (2) PROVIDED NONCE WAS BROADCASTED WITHOUT DELAY TO MEV PRODUCER/MEMPOOL\n', "// In the next version we're planning to introduce trustless approach to verify submited nonce onchain(see smartpool) and verify delay in seconds for share submission(with oracles)\n", 'contract LogOfClaimedMEVBlocks {\n', '    mapping (address => uint) public timestampOfPossibleExit;\n', '    mapping (address => uint) public depositedEther;\n', '    mapping (bytes32 => uint) public claimedBlockNonce;\n', '    mapping (bytes32 => uint) public claimedBlockCost;\n', '    \n', '    event Deposit(address user, uint amount);\n', '    event Withdraw(address user, uint amount);\n', '    event BlockClaimed(bytes32 blockHeader, bytes32 seedHash, bytes32 target, uint blockNumber, uint blockPayment, address poolOperator, uint blockNonce, address mevProducer);\n', '    \n', '    fallback () payable external {\n', '        this.depositAndLock(msg.value, 24 * 60 * 60);\n', '    }\n', '    function depositAndLock(uint depositAmount, uint depositDuration) payable external {\n', '        require(depositAmount == msg.value);\n', '        // Enforcing min and max lockup durations\n', '        require(depositDuration >= 24 * 60 * 60 && depositDuration < 365 * 24 * 60 * 60);\n', '        timestampOfPossibleExit[msg.sender] = block.timestamp + depositDuration;\n', '        if (msg.value > 0) {\n', '            depositedEther[msg.sender] += msg.value;\n', '        }\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '    \n', '    function withdrawUpTo(uint etherAmount) external {\n', '        // User previously deposited into contract\n', '        require(depositedEther[msg.sender] > 0);\n', '        // Full 1 day passed after last deposit\n', '        require(block.timestamp > timestampOfPossibleExit[msg.sender]);\n', '        if (depositedEther[msg.sender] < etherAmount)\n', '            etherAmount = depositedEther[msg.sender];\n', '        require(address(this).balance >= etherAmount);\n', '        depositedEther[msg.sender] -= etherAmount;\n', '        msg.sender.transfer(etherAmount);\n', '        emit Withdraw(msg.sender, etherAmount);\n', '    }\n', '\n', '    function submitClaim(\n', '        bytes32 blockHeader,\n', '        bytes32 seedHash,\n', '        bytes32 target,\n', '        uint blockNumber,\n', '        uint blockPayment,\n', '        address poolOperator,\n', '        uint blockNonce,\n', '        address mevProducer,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public {\n', '        require(msg.sender == poolOperator);\n', '        bytes32 hash = sha256(abi.encode(blockHeader, seedHash, target, blockNumber, blockPayment, poolOperator));\n', '        if (claimedBlockCost[hash] == 0) {\n', '            if (ecrecover(keccak256(abi.encode("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) == mevProducer) {\n', '                require(depositedEther[mevProducer] >= blockPayment);\n', '                claimedBlockCost[hash] = blockPayment;\n', '                claimedBlockNonce[hash] = blockNonce;\n', '                depositedEther[mevProducer] -= blockPayment;\n', '                depositedEther[poolOperator] += blockPayment;\n', '                emit BlockClaimed(blockHeader, seedHash, target, blockNumber, blockPayment, poolOperator, blockNonce, mevProducer);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function remainingDurationForWorkClaim(\n', '        bytes32 blockHeader,\n', '        bytes32 seedHash,\n', '        bytes32 target,\n', '        uint blockNumber,\n', '        uint blockPayment,\n', '        address poolOperator,\n', '        address mevProducer,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public view returns (uint) {\n', '        bytes32 hash = sha256(abi.encode(blockHeader, seedHash, target, blockNumber, blockPayment, poolOperator));\n', '        if (claimedBlockCost[hash] != 0) return 0;\n', '        if (ecrecover(keccak256(abi.encode("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) != mevProducer) return 0;\n', '        if (depositedEther[mevProducer] < blockPayment) return 0;\n', '        if (block.timestamp >= timestampOfPossibleExit[mevProducer]) return 0;\n', '        return timestampOfPossibleExit[mevProducer] - block.timestamp;\n', '    }\n', '}']