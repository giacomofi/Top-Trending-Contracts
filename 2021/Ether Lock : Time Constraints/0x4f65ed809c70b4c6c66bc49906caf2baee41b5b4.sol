['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', "import './ECDSA.sol';\n", "import './IERC20.sol';\n", "import './Context.sol';\n", '\n', 'contract ZefuVaultETH is Context{\n', '    using ECDSA for bytes32;\n', '    \n', '    struct Cross {\n', '        uint256 nonce;\n', '        mapping (uint256 => uint256) amount;\n', '    }\n', '    \n', '    \n', '    mapping(address => Cross) private _transferIn;\n', '    mapping(address => Cross) private _transferOut;\n', '    \n', '    \n', '    IERC20 private ZEFU;\n', '    address private _validator;\n', '    \n', '    \n', '    \n', '    constructor(IERC20 token, address validator) {\n', '        ZEFU = token;\n', '        _validator = validator;\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    function vaultBalance() public view returns (uint256) {\n', '        return ZEFU.balanceOf(address(this));\n', '    }\n', '    \n', '    function getNonceIn(address user) public view returns (uint256) {\n', '        return _transferIn[user].nonce;\n', '    }\n', '    \n', '    function getNonceOut(address user) public view returns (uint256) {\n', '        return _transferOut[user].nonce;\n', '    }\n', '    \n', '    function getAmountIn(address user, uint256 nonce) public view returns (uint256) {\n', '        return _transferIn[user].amount[nonce];\n', '    }\n', '    \n', '    function getAmountOut(address user, uint256 nonce) public view returns (uint256) {\n', '        return _transferOut[user].amount[nonce];\n', '    }\n', '    \n', '    function getValidator() public view returns (address) {\n', '        return _validator;\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    function setValidator(address validator) public {\n', '        require(_msgSender() == _validator, "Valut: Invalid Validator.");\n', '        _validator = validator;\n', '    }\n', '    \n', '    function getHash(address user, uint256 nonce, uint256 amount) public pure returns (bytes32 hash) {\n', '        hash = keccak256(abi.encodePacked(user, nonce, amount));\n', '    }\n', '    \n', '    \n', '    \n', '    function swapToBSC(uint256 amount) public virtual {\n', '        address user = _msgSender();\n', '        ZEFU.transferFrom(user, address(this), amount);\n', '        uint256 nonce = getNonceOut(user);\n', '        _transferOut[user].amount[nonce] = amount;\n', '        _transferOut[user].nonce++;\n', '        \n', '    }\n', '    \n', '    \n', '    function swapFromBSC(uint256 amount, bytes memory signature) public virtual {\n', '        address user = _msgSender();\n', '        uint256 nonce = getNonceIn(user);\n', '        bytes32 hash = keccak256(abi.encodePacked(user, nonce, amount));\n', '        require(hash.recover(signature) == getValidator(), "Vault: Invalid transaction.");\n', '        _transferIn[user].amount[nonce] = amount;\n', '        _transferOut[user].nonce++;\n', '        ZEFU.transfer(_msgSender(), amount);\n', '    }\n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '    \n', '}']