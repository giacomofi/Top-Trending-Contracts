['pragma solidity ^0.7.5;\n', '\n', '// ----------------------------------------------------------------------------\n', "// BokkyPooBah's DateTime Library v1.01\n", '//\n', '// A gas-efficient Solidity date and time library\n', '//\n', '// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n', '//\n', '// Tested date range 1970/01/01 to 2345/12/31\n', '//\n', '// Conventions:\n', '// Unit      | Range         | Notes\n', '// :-------- |:-------------:|:-----\n', '// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\n', '// year      | 1970 ... 2345 |\n', '// month     | 1 ... 12      |\n', '// day       | 1 ... 31      |\n', '// hour      | 0 ... 23      |\n', '// minute    | 0 ... 59      |\n', '// second    | 0 ... 59      |\n', '// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\n', '//\n', '//\n', '// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\n', '// ----------------------------------------------------------------------------\n', '\n', 'library BokkyPooBahsDateTimeLibrary {\n', '\n', '    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n', '    uint constant SECONDS_PER_HOUR = 60 * 60;\n', '    uint constant SECONDS_PER_MINUTE = 60;\n', '    int constant OFFSET19700101 = 2440588;\n', '\n', '    uint constant DOW_MON = 1;\n', '    uint constant DOW_TUE = 2;\n', '    uint constant DOW_WED = 3;\n', '    uint constant DOW_THU = 4;\n', '    uint constant DOW_FRI = 5;\n', '    uint constant DOW_SAT = 6;\n', '    uint constant DOW_SUN = 7;\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Calculate the number of days from 1970/01/01 to year/month/day using\n', '    // the date conversion algorithm from\n', '    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n', '    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n', '    //\n', '    // days = day\n', '    //      - 32075\n', '    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n', '    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n', '    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n', '    //      - offset\n', '    // ------------------------------------------------------------------------\n', '    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n', '        require(year >= 1970);\n', '        int _year = int(year);\n', '        int _month = int(month);\n', '        int _day = int(day);\n', '\n', '        int __days = _day\n', '          - 32075\n', '          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n', '          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n', '          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n', '          - OFFSET19700101;\n', '\n', '        _days = uint(__days);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Calculate year/month/day from the number of days since 1970/01/01 using\n', '    // the date conversion algorithm from\n', '    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n', '    // and adding the offset 2440588 so that 1970/01/01 is day 0\n', '    //\n', '    // int L = days + 68569 + offset\n', '    // int N = 4 * L / 146097\n', '    // L = L - (146097 * N + 3) / 4\n', '    // year = 4000 * (L + 1) / 1461001\n', '    // L = L - 1461 * year / 4 + 31\n', '    // month = 80 * L / 2447\n', '    // dd = L - 2447 * month / 80\n', '    // L = month / 11\n', '    // month = month + 2 - 12 * L\n', '    // year = 100 * (N - 49) + year + L\n', '    // ------------------------------------------------------------------------\n', '    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n', '        int __days = int(_days);\n', '\n', '        int L = __days + 68569 + OFFSET19700101;\n', '        int N = 4 * L / 146097;\n', '        L = L - (146097 * N + 3) / 4;\n', '        int _year = 4000 * (L + 1) / 1461001;\n', '        L = L - 1461 * _year / 4 + 31;\n', '        int _month = 80 * L / 2447;\n', '        int _day = L - 2447 * _month / 80;\n', '        L = _month / 11;\n', '        _month = _month + 2 - 12 * L;\n', '        _year = 100 * (N - 49) + _year + L;\n', '\n', '        year = uint(_year);\n', '        month = uint(_month);\n', '        day = uint(_day);\n', '    }\n', '\n', '    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n', '        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n', '    }\n', '    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n', '        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n', '    }\n', '    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n', '        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        uint secs = timestamp % SECONDS_PER_DAY;\n', '        hour = secs / SECONDS_PER_HOUR;\n', '        secs = secs % SECONDS_PER_HOUR;\n', '        minute = secs / SECONDS_PER_MINUTE;\n', '        second = secs % SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n', '        if (year >= 1970 && month > 0 && month <= 12) {\n', '            uint daysInMonth = _getDaysInMonth(year, month);\n', '            if (day > 0 && day <= daysInMonth) {\n', '                valid = true;\n', '            }\n', '        }\n', '    }\n', '    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n', '        if (isValidDate(year, month, day)) {\n', '            if (hour < 24 && minute < 60 && second < 60) {\n', '                valid = true;\n', '            }\n', '        }\n', '    }\n', '    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n', '        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        leapYear = _isLeapYear(year);\n', '    }\n', '    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n', '        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n', '    }\n', '    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n', '        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n', '    }\n', '    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n', '        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n', '    }\n', '    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n', '        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        daysInMonth = _getDaysInMonth(year, month);\n', '    }\n', '    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n', '        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n', '            daysInMonth = 31;\n', '        } else if (month != 2) {\n', '            daysInMonth = 30;\n', '        } else {\n', '            daysInMonth = _isLeapYear(year) ? 29 : 28;\n', '        }\n', '    }\n', '    // 1 = Monday, 7 = Sunday\n', '    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n', '        uint _days = timestamp / SECONDS_PER_DAY;\n', '        dayOfWeek = (_days + 3) % 7 + 1;\n', '    }\n', '\n', '    function getYear(uint timestamp) internal pure returns (uint year) {\n', '        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '    function getMonth(uint timestamp) internal pure returns (uint month) {\n', '        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '    function getDay(uint timestamp) internal pure returns (uint day) {\n', '        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '    }\n', '    function getHour(uint timestamp) internal pure returns (uint hour) {\n', '        uint secs = timestamp % SECONDS_PER_DAY;\n', '        hour = secs / SECONDS_PER_HOUR;\n', '    }\n', '    function getMinute(uint timestamp) internal pure returns (uint minute) {\n', '        uint secs = timestamp % SECONDS_PER_HOUR;\n', '        minute = secs / SECONDS_PER_MINUTE;\n', '    }\n', '    function getSecond(uint timestamp) internal pure returns (uint second) {\n', '        second = timestamp % SECONDS_PER_MINUTE;\n', '    }\n', '\n', '    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n', '        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        year += _years;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n', '        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        month += _months;\n', '        year += (month - 1) / 12;\n', '        month = (month - 1) % 12 + 1;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp + _seconds;\n', '        require(newTimestamp >= timestamp);\n', '    }\n', '\n', '    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n', '        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        year -= _years;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n', '        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n', '        uint yearMonth = year * 12 + (month - 1) - _months;\n', '        year = yearMonth / 12;\n', '        month = yearMonth % 12 + 1;\n', '        uint daysInMonth = _getDaysInMonth(year, month);\n', '        if (day > daysInMonth) {\n', '            day = daysInMonth;\n', '        }\n', '        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n', '        newTimestamp = timestamp - _seconds;\n', '        require(newTimestamp <= timestamp);\n', '    }\n', '\n', '    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n', '        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n', '        _years = toYear - fromYear;\n', '    }\n', '    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n', '        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n', '        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n', '    }\n', '    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n', '    }\n', '    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n', '    }\n', '    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n', '    }\n', '    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n', '        require(fromTimestamp <= toTimestamp);\n', '        _seconds = toTimestamp - fromTimestamp;\n', '    }\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'import "@openzeppelin/contracts/proxy/TransparentUpgradeableProxy.sol";\n', 'import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";\n', 'import "./vaults/StakingData.sol";\n', '\n', 'contract ITrustVaultFactory is Initializable {\n', '  \n', '  address[] internal _VaultProxies;\n', '  mapping (address => bool) internal _AdminList;\n', '  mapping (address => bool) internal _TrustedSigners;\n', '  mapping(address => bool) internal _VaultStatus;\n', '  address internal _roundDataImplementationAddress;\n', '  address internal _stakeDataImplementationAddress;\n', '  address internal _stakingDataAddress;\n', '  address internal _burnAddress;\n', '  address internal _governanceDistributionAddress;\n', '  address internal _governanceTokenAddress;\n', '  address internal _stakingCalculationAddress;\n', '\n', '  function initialize(\n', '      address admin, \n', '      address trustedSigner, \n', '      address roundDataImplementationAddress, \n', '      address stakeDataImplementationAddress, \n', '      address governanceTokenAddress,\n', '      address stakingCalculationAddress\n', '    ) initializer external {\n', '    require(admin != address(0));\n', '    _AdminList[admin] = true;\n', '    _AdminList[msg.sender] = true;\n', '    _TrustedSigners[trustedSigner] = true;\n', '    _roundDataImplementationAddress = roundDataImplementationAddress;\n', '    _stakeDataImplementationAddress = stakeDataImplementationAddress;\n', '    _governanceTokenAddress = governanceTokenAddress;\n', '    _stakingCalculationAddress = stakingCalculationAddress;\n', '  }\n', '\n', '  modifier onlyAdmin() {\n', '    require(_AdminList[msg.sender] == true, "Not Factory Admin");\n', '    _;\n', '  }\n', '\n', '  function createVault(\n', '    address contractAddress, \n', '    bytes memory data\n', '  ) external onlyAdmin {\n', '    TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(contractAddress, msg.sender, data );\n', '    require(address(proxy) != address(0));\n', '    _VaultProxies.push(address(proxy));\n', '    _VaultStatus[address(proxy)] = true;\n', '    StakingData stakingDataContract = StakingData(_stakingDataAddress);\n', '    stakingDataContract.addVault(address(proxy));\n', '  }\n', '\n', '  function getVaultaddresses() external view returns (address[] memory vaults, bool[] memory status) {\n', '\n', '    vaults = _VaultProxies;\n', '    status = new bool[](vaults.length);\n', '\n', '    for(uint i = 0; i < vaults.length; i++){\n', '      status[i] = _VaultStatus[vaults[i]];\n', '    }\n', '\n', '    return (vaults, status);\n', '  }\n', '\n', '  function pauseVault(address vaultAddress) external onlyAdmin {\n', '    _VaultStatus[vaultAddress] = false;\n', '  }\n', '\n', '  function unPauseVault(address vaultAddress) external onlyAdmin {\n', '    _VaultStatus[vaultAddress] = true;\n', '  }\n', '\n', '  function addAdminAddress(address newAddress) external onlyAdmin {\n', '      require(_AdminList[newAddress] == false, "Already Admin");\n', '      _AdminList[newAddress] = true;\n', '  }\n', '\n', '  /**\n', '    * @dev revoke admin\n', '    */\n', '  function revokeAdminAddress(address newAddress) external onlyAdmin {\n', '      require(msg.sender != newAddress);\n', '      _AdminList[newAddress] = false;\n', '  }\n', '\n', '  function addTrustedSigner(address newAddress) external onlyAdmin{\n', '      require(_TrustedSigners[newAddress] == false);\n', '      _TrustedSigners[newAddress] = true;\n', '  }\n', '\n', '  function isTrustedSignerAddress(address account) external view returns (bool) {\n', '      return _TrustedSigners[account] == true;\n', '  }\n', '\n', '  function updateRoundDataImplementationAddress(address newAddress) external onlyAdmin {\n', '      _roundDataImplementationAddress = newAddress;\n', '  }\n', '\n', '  function getRoundDataImplementationAddress() external view returns(address){\n', '      return _roundDataImplementationAddress;\n', '  }\n', '\n', '  function updateStakeDataImplementationAddress(address newAddress) external onlyAdmin {\n', '      _stakeDataImplementationAddress = newAddress;\n', '  }\n', '\n', '  function getStakeDataImplementationAddress() external view returns(address){\n', '      return _stakeDataImplementationAddress;\n', '  }\n', '\n', '  function updateStakingDataAddress(address newAddress) external onlyAdmin {\n', '      _stakingDataAddress = newAddress;\n', '  }\n', '\n', '  function getStakingDataAddress() external view returns(address){\n', '      return _stakingDataAddress;\n', '  }\n', '\n', '  function isStakingDataAddress(address addressToCheck) external view returns (bool) {\n', '      return _stakingDataAddress == addressToCheck;\n', '  }\n', '\n', '  function updateBurnAddress(address newAddress) external onlyAdmin {\n', '      _burnAddress = newAddress;\n', '  }\n', '\n', '  function getBurnAddress() external view returns(address){\n', '      return _burnAddress;\n', '  }\n', '\n', '  function isBurnAddress(address addressToCheck) external view returns (bool) {\n', '      return _burnAddress == addressToCheck;\n', '  }\n', '\n', '  function updateGovernanceDistributionAddress(address newAddress) external onlyAdmin {\n', '      _governanceDistributionAddress = newAddress;\n', '  }\n', '\n', '  function getGovernanceDistributionAddress() external view returns(address){\n', '      return _governanceDistributionAddress;\n', '  }\n', '\n', '  function updateGovernanceTokenAddress(address newAddress) external onlyAdmin {\n', '      _governanceTokenAddress = newAddress;\n', '  }\n', '\n', '  function getGovernanceTokenAddress() external view returns(address){\n', '      return _governanceTokenAddress;\n', '  }\n', '\n', '  function updateStakingCalculationsAddress(address newAddress) external onlyAdmin {\n', '      _stakingCalculationAddress = newAddress;\n', '  }\n', '\n', '  function getStakingCalculationsAddress() external view returns(address){\n', '      return _stakingCalculationAddress;\n', '  }\n', '\n', '  /**\n', '    * @dev revoke admin\n', '    */\n', '  function revokeTrustedSigner(address newAddress) external onlyAdmin {\n', '      require(msg.sender != newAddress);\n', '      _TrustedSigners[newAddress] = false;\n', '  }\n', '\n', '  function isAdmin() external view returns (bool) {\n', '      return isAddressAdmin(msg.sender);\n', '  }\n', '\n', '  function isAddressAdmin(address account) public view returns (bool) {\n', '      return _AdminList[account] == true;\n', '  }\n', '\n', '  function isActiveVault(address vaultAddress) external view returns (bool) {\n', '    return _VaultStatus[vaultAddress] == true;\n', '  }   \n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', 'library ITrustVaultLib {\n', '    using SafeMath for uint;\n', '\n', '    struct RewardTokenRoundData{\n', '        address tokenAddress;\n', '        uint amount;\n', '        uint commissionAmount;\n', '        uint tokenPerBlock; \n', '        uint totalSupply;\n', '        bool ignoreUnstakes;\n', '    }\n', '\n', '    struct RewardTokenRound{\n', '        mapping(address => RewardTokenRoundData) roundData;\n', '        uint startBlock;\n', '        uint endBlock;\n', '    }\n', '\n', '    struct AccountStaking {\n', '        uint32 startRound;\n', '        uint endDate;\n', '        uint total;\n', '        Staking[] stakes;\n', '    }\n', '\n', '    struct Staking {\n', '        uint startTime;\n', '        uint startBlock;\n', '        uint amount;\n', '        uint total;\n', '    }\n', '\n', '    struct UnStaking {\n', '        address account; \n', '        uint amount;\n', '        uint startDateTime;   \n', '        uint startBlock;     \n', '        uint endBlock;    \n', '    }\n', '\n', '    struct ClaimedReward {\n', '        uint amount;\n', '        uint lastClaimedRound;\n', '    }\n', '\n', '    function divider(uint numerator, uint denominator, uint precision) internal pure returns(uint) {        \n', '        return numerator*(uint(10)**uint(precision))/denominator;\n', '    }\n', '\n', '    function getUnstakingsForBlockRange(\n', '        UnStaking[] memory unStakes, \n', '        uint startBlock, \n', '        uint endBlock) internal pure returns (uint){\n', '         // If we have bad data, no supply data or it starts after the block we are looking for then we can return zero\n', '        if(endBlock < startBlock \n', '            || unStakes.length == 0 \n', '            || unStakes[0].startBlock > endBlock)\n', '        {         \n', '            return 0;\n', '        }\n', '\n', '        uint lastIndex = unStakes.length - 1;\n', '        uint diff = 0;\n', '        uint stakeEnd;\n', '        uint stakeStart;\n', '\n', '        uint total;\n', '        diff = 0;\n', '        stakeEnd = 0; \n', '        stakeStart = 0;\n', '        //last index should now be in our range so loop through until all block numbers are covered\n', '      \n', '        while(lastIndex >= 0) {  \n', '\n', '            if( (unStakes[lastIndex].endBlock != 0 && unStakes[lastIndex].endBlock < startBlock)\n', '                || unStakes[lastIndex].startBlock > endBlock) {\n', '                if(lastIndex == 0){\n', '                    break;\n', '                } \n', '                lastIndex = lastIndex.sub(1);\n', '                continue;\n', '            }\n', '            \n', '            stakeEnd = unStakes[lastIndex].endBlock == 0 \n', '                ? endBlock : unStakes[lastIndex].endBlock;\n', '\n', '            stakeEnd = (stakeEnd >= endBlock ? endBlock : stakeEnd);\n', '\n', '            stakeStart = unStakes[lastIndex].startBlock < startBlock \n', '                ? startBlock : unStakes[lastIndex].startBlock;\n', '            \n', '            diff = (stakeEnd == stakeStart ? 1 : stakeEnd.sub(stakeStart));\n', '\n', '            total = total.add(unStakes[lastIndex].amount.mul(diff));\n', '\n', '            if(lastIndex == 0){\n', '                break;\n', '            } \n', '\n', '            lastIndex = lastIndex.sub(1); \n', '        }\n', ' \n', '        return total;\n', '    }\n', '\n', 'function getHoldingsForBlockRange(\n', '        Staking[] memory stakes,\n', '        uint startBlock, \n', '        uint endBlock) internal pure returns (uint){\n', '        \n', '        // If we have bad data, no supply data or it starts after the block we are looking for then we can return zero\n', '        if(endBlock < startBlock \n', '            || stakes.length == 0 \n', '            || stakes[0].startBlock > endBlock){\n', '            return 0;\n', '        }\n', '        uint lastIndex = stakes.length - 1;\n', '    \n', '        uint diff;\n', '        // If the last total supply is before the start we are looking for we can take the last value\n', '        if(stakes[lastIndex].startBlock <= startBlock){\n', '            diff =  endBlock.sub(startBlock) == 0 ? 1 : endBlock.sub(startBlock);\n', '            return stakes[lastIndex].total.mul(diff);\n', '        }\n', ' \n', '        // working our way back we need to get the first index that falls into our range\n', '        // This could be large so need to think of a better way to get here\n', '        while(lastIndex > 0 && stakes[lastIndex].startBlock > endBlock){\n', '            lastIndex = lastIndex.sub(1);\n', '        }\n', ' \n', '        uint total;\n', '        diff = 0;\n', '        //last index should now be in our range so loop through until all block numbers are covered\n', '        while(stakes[lastIndex].startBlock >= startBlock ) {  \n', '            diff = 1;\n', '            if(stakes[lastIndex].startBlock <= startBlock){\n', '                diff = endBlock.sub(startBlock) == 0 ? 1 : endBlock.sub(startBlock);\n', '                total = total.add(stakes[lastIndex].total.mul(diff));\n', '                break;\n', '            }\n', ' \n', '            diff = endBlock.sub(stakes[lastIndex].startBlock) == 0 \n', '                            ? 1 \n', '                            : endBlock.sub(stakes[lastIndex].startBlock);\n', '            total = total.add(stakes[lastIndex].total.mul(diff));\n', '            endBlock = stakes[lastIndex].startBlock;\n', ' \n', '            if(lastIndex == 0){\n', '                break;\n', '            } \n', ' \n', '            lastIndex = lastIndex.sub(1); \n', '        }\n', ' \n', '        // If the last total supply is before the start we are looking for we can take the last value\n', '        if(stakes[lastIndex].startBlock <= startBlock && startBlock <= endBlock){\n', '            diff =  endBlock.sub(startBlock) == 0 ? 1 : endBlock.sub(startBlock);\n', '            total = total.add(stakes[lastIndex].total.mul(diff));\n', '\n', '        }\n', ' \n', '        return total;\n', '    }\n', '\n', '    function splitSignature(bytes memory sig)\n', '        internal\n', '        pure\n', '        returns (uint8, bytes32, bytes32)\n', '    {\n', '        require(sig.length == 65);\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        assembly {\n', '            // first 32 bytes, after the length prefix\n', '            r := mload(add(sig, 32))\n', '            // second 32 bytes\n', '            s := mload(add(sig, 64))\n', '            // final byte (first byte of the next 32 bytes)\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '\n', '        return (v, r, s);\n', '    }\n', '\n', '    function recoverSigner(bytes32 message, bytes memory sig)\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        (v, r, s) = splitSignature(sig);\n', '\n', '        return ecrecover(message, v, r, s);\n', '    }\n', '\n', '    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20CappedUpgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";\n', '\n', 'contract iTrustGovernanceToken is ERC20CappedUpgradeable, OwnableUpgradeable, PausableUpgradeable {\n', '\n', '    using SafeMathUpgradeable for uint;\n', '\n', '    address internal _treasuryAddress;\n', '    uint internal _yearOneSupply;\n', '    uint internal _yearTwoSupply;\n', '    uint internal _yearThreeSupply;\n', '    uint internal _yearFourSupply;\n', '    uint internal _yearFiveSupply;\n', '    \n', '    function initialize(\n', '        address payable treasuryAddress, \n', '        uint cap_,\n', '        uint yearOneSupply, \n', '        uint yearTwoSupply, \n', '        uint yearThreeSupply, \n', '        uint yearFourSupply, \n', '        uint yearFiveSupply) initializer public {\n', '\n', '        require(yearOneSupply.add(yearTwoSupply).add(yearThreeSupply).add(yearFourSupply).add(yearFiveSupply) == cap_);\n', '\n', '        __ERC20_init("iTrust Governance Token", "$ITG");\n', '        __ERC20Capped_init(cap_);\n', '        __Ownable_init();\n', '        __Pausable_init();\n', '\n', '        _treasuryAddress = treasuryAddress;\n', '        _yearOneSupply = yearOneSupply;\n', '        _yearTwoSupply = yearTwoSupply;\n', '        _yearThreeSupply = yearThreeSupply;\n', '        _yearFourSupply = yearFourSupply;\n', '        _yearFiveSupply = yearFiveSupply;\n', '\n', '        \n', '    }\n', '\n', '    function mintYearOne() external onlyOwner {\n', '        require(totalSupply() == 0);\n', '        _mint(_treasuryAddress, _yearOneSupply);\n', '    }\n', '\n', '    function mintYearTwo() external onlyOwner {\n', '        require(totalSupply() == _yearOneSupply);\n', '        _mint(_treasuryAddress, _yearTwoSupply);\n', '    }\n', '\n', '    function mintYearThree() external onlyOwner {\n', '        require(totalSupply() == _yearOneSupply.add(_yearTwoSupply));\n', '        _mint(_treasuryAddress, _yearThreeSupply);\n', '    }\n', '\n', '    function mintYearFour() external onlyOwner {\n', '        require(totalSupply() == _yearOneSupply.add(_yearTwoSupply).add(_yearThreeSupply));\n', '        _mint(_treasuryAddress, _yearFourSupply);\n', '    }\n', '\n', '    function mintYearFive() external onlyOwner {\n', '        require(totalSupply() == _yearOneSupply.add(_yearTwoSupply).add(_yearThreeSupply).add(_yearFourSupply));\n', '        _mint(_treasuryAddress, _yearFiveSupply);\n', '    }\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";\n', '\n', 'import { ITrustVaultLib as VaultLib } from "./../libraries/ItrustVaultLib.sol"; \n', '\n', 'abstract contract BaseContract is Initializable, ContextUpgradeable\n', '{\n', '    uint8 internal constant FALSE = 0;\n', '    uint8 internal constant TRUE = 1;\n', '\n', '    uint8 internal _locked;\n', '    address internal _iTrustFactoryAddress;\n', '\n', '    mapping (address => uint32) internal _CurrentRoundNumbers;\n', '    mapping (address => uint) internal _TotalUnstakedWnxm;\n', '    mapping (address => uint[]) internal _TotalSupplyKeys;\n', '    mapping (address => uint[]) internal _TotalUnstakingKeys;\n', '    mapping (address => uint[]) internal _TotalSupplyForDayKeys;\n', '   \n', '    mapping (address => address[]) public totalRewardTokenAddresses;\n', '    mapping (address => address[]) internal _UnstakingAddresses;\n', '    mapping (address => address[]) internal _AccountStakesAddresses;\n', '\n', '    mapping (address => VaultLib.UnStaking[]) internal _UnstakingRequests;\n', '    mapping (address => mapping (address => uint32)) internal _RewardStartingRounds;\n', '    mapping (address => mapping (address => VaultLib.AccountStaking)) internal _AccountStakes;\n', '    mapping (address => mapping (address => VaultLib.UnStaking[])) internal _AccountUnstakings;\n', '\n', '    mapping (address => mapping (address => uint8)) internal _RewardTokens;\n', '    mapping (address => mapping (address => uint)) internal _AccountUnstakingTotals;\n', '    mapping (address => mapping (address => uint)) internal _AccountUnstakedTotals;\n', '    mapping (address => mapping (uint => uint)) internal _TotalSupplyHistory;\n', '    mapping (address => mapping (address => mapping (address => VaultLib.ClaimedReward))) internal _AccountRewards;\n', '    mapping (address => mapping (uint => VaultLib.RewardTokenRound)) internal _Rounds;\n', '\n', '    mapping (address => mapping (uint => uint)) internal _TotalSupplyForDayHistory;\n', '    \n', '\n', '\n', '    mapping (address => mapping (uint => VaultLib.UnStaking)) internal _TotalUnstakingHistory;\n', '    \n', '    function _nonReentrant() internal view {\n', '        require(_locked == FALSE);  \n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";\n', '\n', 'import "./../iTrustVaultFactory.sol";\n', 'import "./../tokens/iTrustGovernanceToken.sol";\n', 'import "./Vault.sol";\n', 'import {\n', '    BokkyPooBahsDateTimeLibrary as DateTimeLib\n', '} from "./../3rdParty/BokkyPooBahsDateTimeLibrary.sol";\n', '\n', 'contract GovernanceDistribution is Initializable, ContextUpgradeable\n', '{\n', '    using SafeMathUpgradeable for uint;\n', '\n', '    uint8 internal constant FALSE = 0;\n', '    uint8 internal constant TRUE = 1;\n', '\n', '    uint8 internal _locked;\n', '    uint internal _tokenPerHour;\n', '    address internal _iTrustFactoryAddress;\n', '    uint[] internal _totalSupplyKeys;\n', '    mapping (uint => uint) internal _totalSupplyHistory;\n', '    mapping (address => uint[]) internal _totalStakedKeys;\n', '    mapping (address => mapping (uint => uint)) internal _totalStakedHistory;\n', '    mapping (address => uint) internal _lastClaimedTimes;\n', '    mapping(address => mapping(string => bool)) _UsedNonces;\n', '\n', '    function initialize(\n', '        address iTrustFactoryAddress,\n', '        uint tokenPerDay\n', '    ) \n', '        initializer \n', '        external \n', '    {\n', '        _iTrustFactoryAddress = iTrustFactoryAddress;\n', '        _tokenPerHour = tokenPerDay.div(24);\n', '    }\n', '\n', '    /**\n', '     * Public functions\n', '     */\n', '\n', '     function totalStaked(address account) external view returns(uint) {\n', '         _onlyAdmin();\n', '\n', '         if(_totalStakedKeys[account].length == 0){\n', '             return 0;\n', '         }\n', '\n', '        return _totalStakedHistory[account][_totalStakedKeys[account][_totalStakedKeys[account].length.sub(1)]];\n', '    }\n', '\n', '    function totalSupply() external view returns(uint) {\n', '         _onlyAdmin();\n', '\n', '         if(_totalSupplyKeys.length == 0){\n', '             return 0;\n', '         }\n', '\n', '        return _totalSupplyHistory[_totalSupplyKeys[_totalSupplyKeys.length.sub(1)]];\n', '    }\n', '\n', '    function calculateRewards() external view returns(uint amount, uint claimedUntil) {\n', '        (amount, claimedUntil) = _calculateRewards(_msgSender());\n', '        return(amount, claimedUntil);\n', '    }\n', '\n', '    function calculateRewardsForAccount(address account) external view returns(uint amount, uint claimedUntil) {\n', '        _isTrustedSigner(_msgSender());\n', '        (amount, claimedUntil) = _calculateRewards(account);\n', '        return(amount, claimedUntil);\n', '    }\n', '\n', '    function removeStake(address account, uint value) external {\n', '        _validateStakingDataAddress();\n', '        require(_totalStakedKeys[account].length != 0);\n', '        uint currentTime = _getStartOfHourTimeStamp(block.timestamp);\n', '        uint lastStakedIndex = _totalStakedKeys[account][_totalStakedKeys[account].length.sub(1)];\n', '        if(lastStakedIndex > currentTime){\n', '            if(_totalStakedKeys[account].length == 1 || _totalStakedKeys[account][_totalStakedKeys[account].length.sub(2)] != currentTime){\n', '                _totalStakedKeys[account][_totalStakedKeys[account].length.sub(1)] = currentTime;\n', '                _totalStakedHistory[account][currentTime] = _totalStakedKeys[account].length == 1 ? 0 : _totalStakedHistory[account][_totalStakedKeys[account][_totalStakedKeys[account].length.sub(2)]];\n', '                _totalStakedKeys[account].push(lastStakedIndex);\n', '            }\n', '            _totalStakedHistory[account][lastStakedIndex] = _totalStakedHistory[account][lastStakedIndex].sub(value);\n', '            lastStakedIndex = _totalStakedKeys[account][_totalStakedKeys[account].length.sub(2)];\n', '        }\n', '        require(value <= _totalStakedHistory[account][lastStakedIndex]);\n', '        uint newValue = _totalStakedHistory[account][lastStakedIndex].sub(value);\n', '        if(lastStakedIndex != currentTime){\n', '            _totalStakedKeys[account].push(currentTime);\n', '        }\n', '        _totalStakedHistory[account][currentTime] = newValue;\n', '        require(_totalSupplyKeys.length != 0);\n', '        uint lastSupplyIndex = _totalSupplyKeys[_totalSupplyKeys.length.sub(1)];\n', '        if(lastSupplyIndex > currentTime){\n', '            if(_totalSupplyKeys.length == 1 || _totalSupplyKeys[_totalSupplyKeys.length.sub(2)] != currentTime){\n', '                _totalSupplyKeys[_totalSupplyKeys.length.sub(1)] = currentTime;\n', '                _totalSupplyHistory[currentTime] = _totalSupplyKeys.length == 1 ? 0 : _totalSupplyHistory[_totalSupplyKeys[_totalSupplyKeys.length.sub(2)]];\n', '                _totalSupplyKeys.push(lastSupplyIndex);\n', '            }\n', '            \n', '            _totalSupplyHistory[lastSupplyIndex] = _totalSupplyHistory[lastSupplyIndex].sub(value);\n', '            lastSupplyIndex = _totalSupplyKeys[_totalSupplyKeys.length.sub(2)];\n', '        }\n', '        if(lastSupplyIndex != currentTime){\n', '            _totalSupplyKeys.push(currentTime);\n', '        }\n', '        _totalSupplyHistory[currentTime] = _totalSupplyHistory[lastSupplyIndex].sub(value);\n', '    }\n', '\n', '    function addStake(address account, uint value) external {\n', '        _validateStakingDataAddress();\n', '        uint currentTime = _getStartOfNextHourTimeStamp(block.timestamp);\n', '\n', '        if(_totalStakedKeys[account].length == 0){\n', '            _totalStakedKeys[account].push(currentTime);\n', '            _totalStakedHistory[account][currentTime] = value;\n', '        } else {\n', '            uint lastStakedIndex = _totalStakedKeys[account].length.sub(1);\n', '            uint lastTimestamp = _totalStakedKeys[account][lastStakedIndex];\n', '\n', '            if(lastTimestamp != currentTime){\n', '                _totalStakedKeys[account].push(currentTime);\n', '            }\n', '\n', '            _totalStakedHistory[account][currentTime] = _totalStakedHistory[account][lastTimestamp].add(value);\n', '        }\n', '\n', '        if(_totalSupplyKeys.length == 0){\n', '            _totalSupplyKeys.push(currentTime);\n', '            _totalSupplyHistory[currentTime] = value;\n', '        } else {\n', '            uint lastSupplyIndex = _totalSupplyKeys.length.sub(1);\n', '            uint lastSupplyTimestamp = _totalSupplyKeys[lastSupplyIndex];\n', '\n', '            if(lastSupplyTimestamp != currentTime){\n', '                _totalSupplyKeys.push(currentTime);\n', '            }\n', '\n', '            _totalSupplyHistory[currentTime] = _totalSupplyHistory[lastSupplyTimestamp].add(value);\n', '        }\n', '    }\n', '\n', '    function withdrawTokens(uint amount, uint claimedUntil, string memory nonce, bytes memory sig) external {\n', '        _nonReentrant();\n', '        require(amount != 0);\n', '        require(claimedUntil != 0);\n', '        require(!_UsedNonces[_msgSender()][nonce]);\n', '        _locked = TRUE;\n', '        bytes32 abiBytes = keccak256(abi.encodePacked(_msgSender(), amount, claimedUntil, nonce, address(this)));\n', '        bytes32 message = _prefixed(abiBytes);\n', '\n', '        address signer = _recoverSigner(message, sig);\n', '        _isTrustedSigner(signer);\n', '\n', '        _lastClaimedTimes[_msgSender()] = claimedUntil;\n', '        _UsedNonces[_msgSender()][nonce] = true;\n', '\n', '        _getiTrustGovernanceToken().transfer(_msgSender(), amount);\n', '        _locked = FALSE;\n', '    }\n', '\n', '    /**\n', '     * Internal functions\n', '     */\n', '\n', '    function _calculateRewards(address account) internal view returns(uint, uint) {\n', '\n', '        if(_totalStakedKeys[account].length == 0 || _totalSupplyKeys.length == 0){\n', '            return (0, 0);\n', '        }\n', '\n', '        uint currentTime = _getStartOfHourTimeStamp(block.timestamp);\n', '        uint claimedUntil = _getStartOfHourTimeStamp(block.timestamp);\n', '        uint lastClaimedTimestamp = _lastClaimedTimes[account];\n', '\n', '        // if 0 they have never staked go back to the first stake\n', '        if(lastClaimedTimestamp == 0){\n', '            lastClaimedTimestamp = _totalStakedKeys[account][0];\n', '        }\n', '\n', '        uint totalRewards = 0;\n', '        uint stakedStartingIndex = _totalStakedKeys[account].length.sub(1);\n', '        uint supplyStartingIndex = _totalSupplyKeys.length.sub(1);\n', '        uint hourReward = 0;\n', '\n', '        while(currentTime > lastClaimedTimestamp) {\n', '            (hourReward, stakedStartingIndex, supplyStartingIndex) = _getTotalRewardHour(account, currentTime, stakedStartingIndex, supplyStartingIndex);\n', '            totalRewards = totalRewards.add(hourReward);\n', '            currentTime = DateTimeLib.subHours(currentTime, 1);\n', '        }\n', '\n', '        return (totalRewards, claimedUntil);\n', '    }\n', '\n', '    function _getTotalRewardHour(address account, uint hourTimestamp, uint stakedStartingIndex, uint supplyStartingIndex) internal view returns(uint, uint, uint) {\n', '\n', '        (uint totalStakedForHour, uint returnedStakedStartingIndex) =  _getTotalStakedForHour(account, hourTimestamp, stakedStartingIndex);\n', '        (uint totalSupplyForHour, uint returnedSupplyStartingIndex) =  _getTotalSupplyForHour(hourTimestamp, supplyStartingIndex);\n', '        uint reward = 0;\n', '        \n', '        if(totalSupplyForHour > 0 && totalStakedForHour > 0){\n', '            uint govTokenPerTokenPerHour = _divider(_tokenPerHour, totalSupplyForHour, 18); // _tokenPerHour.div(totalSupplyForHour);\n', '            reward = reward.add(totalStakedForHour.mul(govTokenPerTokenPerHour).div(1e18)); \n', '        }\n', '\n', '        return (reward, returnedStakedStartingIndex, returnedSupplyStartingIndex);\n', '    }\n', '\n', '    function _getTotalStakedForHour(address account, uint hourTimestamp, uint startingIndex) internal view returns(uint, uint) {\n', '\n', '        while(startingIndex != 0 && hourTimestamp <= _totalStakedKeys[account][startingIndex]) {\n', '            startingIndex = startingIndex.sub(1);\n', '        }\n', '\n', '        // We never got far enough back before hitting 0, meaning we staked after the hour we are looking up\n', '        if(hourTimestamp < _totalStakedKeys[account][startingIndex]){\n', '            return (0, startingIndex);\n', '        }\n', '\n', '        return (_totalStakedHistory[account][_totalStakedKeys[account][startingIndex]], startingIndex);\n', '    }\n', '\n', '    function _getTotalSupplyForHour(uint hourTimestamp, uint startingIndex) internal view returns(uint, uint) {\n', '\n', '        \n', '\n', '        while(startingIndex != 0 && hourTimestamp <= _totalSupplyKeys[startingIndex]) {\n', '            startingIndex = startingIndex.sub(1);\n', '        }\n', '\n', '        // We never got far enough back before hitting 0, meaning we staked after the hour we are looking up\n', '        if(hourTimestamp < _totalSupplyKeys[startingIndex]){\n', '            return (0, startingIndex);\n', '        }\n', '\n', '        return (_totalSupplyHistory[_totalSupplyKeys[startingIndex]], startingIndex);\n', '    }\n', '\n', '    function _getStartOfHourTimeStamp(uint nowDateTime) internal pure returns (uint) {\n', '        (uint year, uint month, uint day, uint hour, ,) = DateTimeLib.timestampToDateTime(nowDateTime);\n', '        return DateTimeLib.timestampFromDateTime(year, month, day, hour, 0, 0);\n', '    }\n', '\n', '    function _getStartOfNextHourTimeStamp(uint nowDateTime) internal pure returns (uint) {\n', '        (uint year, uint month, uint day, uint hour, ,) = DateTimeLib.timestampToDateTime(nowDateTime);\n', '        return DateTimeLib.timestampFromDateTime(year, month, day, hour.add(1), 0, 0);\n', '    }\n', '\n', '    function _getITrustVaultFactory() internal view returns(ITrustVaultFactory) {\n', '        return ITrustVaultFactory(_iTrustFactoryAddress);\n', '    }\n', '\n', '    function _governanceTokenAddress() internal view returns(address) {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        return vaultFactory.getGovernanceTokenAddress();\n', '    }\n', '\n', '    function _getiTrustGovernanceToken() internal view returns(iTrustGovernanceToken) {\n', '        return iTrustGovernanceToken(_governanceTokenAddress());\n', '    }\n', '\n', '    function _divider(uint numerator, uint denominator, uint precision) internal pure returns(uint) {        \n', '        return numerator*(uint(10)**uint(precision))/denominator;\n', '    }\n', '\n', '    /**\n', '     * Validate functions\n', '     */\n', '\n', '     function _nonReentrant() internal view {\n', '        require(_locked == FALSE);  \n', '    }\n', '\n', '    function _onlyAdmin() internal view {\n', '        require(\n', '            _getITrustVaultFactory().isAddressAdmin(_msgSender()),\n', '            "Not admin"\n', '        );\n', '    }\n', '\n', '    function _isTrustedSigner(address signer) internal view {\n', '        require(\n', '            _getITrustVaultFactory().isTrustedSignerAddress(signer),\n', '            "Not trusted signer"\n', '        );\n', '    }\n', '\n', '    function _validateStakingDataAddress() internal view {\n', '        _validateStakingDataAddress(_msgSender());\n', '    }\n', '\n', '    function _validateStakingDataAddress(address contractAddress) internal view {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        require(vaultFactory.isStakingDataAddress(contractAddress));\n', '    }\n', '\n', '    function _splitSignature(bytes memory sig)\n', '        internal\n', '        pure\n', '        returns (uint8, bytes32, bytes32)\n', '    {\n', '        require(sig.length == 65);\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        assembly {\n', '            // first 32 bytes, after the length prefix\n', '            r := mload(add(sig, 32))\n', '            // second 32 bytes\n', '            s := mload(add(sig, 64))\n', '            // final byte (first byte of the next 32 bytes)\n', '            v := byte(0, mload(add(sig, 96)))\n', '        }\n', '\n', '        return (v, r, s);\n', '    }\n', '\n', '    function _recoverSigner(bytes32 message, bytes memory sig)\n', '        internal\n', '        pure\n', '        returns (address)\n', '    {\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '\n', '        (v, r, s) = _splitSignature(sig);\n', '\n', '        return ecrecover(message, v, r, s);\n', '    }\n', '\n', '    function _prefixed(bytes32 hash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', 'import "./../iTrustVaultFactory.sol";\n', 'import "./BaseContract.sol";\n', 'import "./StakingDataController/StakeData.sol";\n', '\n', 'import { ITrustVaultLib as VaultLib } from "./../libraries/ItrustVaultLib.sol"; \n', '\n', 'contract StakingCalculation\n', '{\n', '    using SafeMath for uint;\n', '\n', '    // function getRoundDataForAccount(\n', '    //     VaultLib.Staking[] memory stakes,\n', '    //     VaultLib.UnStaking[] memory unstakes,\n', '    //     uint startBlock, \n', '    //     uint endBlock) external pure \n', '    //     returns (uint totalHoldings, uint[] memory stakeBlocks, uint[] memory stakeAmounts, uint[] memory unstakeStartBlocks, uint[] memory unstakeEndBlocks, uint[] memory unstakeAmounts)\n', '    // {\n', '        \n', '    //     totalHoldings = VaultLib.getHoldingsForBlockRange(stakes, startBlock, endBlock);\n', '\n', '    //     (stakeBlocks, stakeAmounts) = VaultLib.getRoundDataStakesForAccount(stakes, startBlock, endBlock);\n', '\n', '    //     (unstakeStartBlocks, unstakeEndBlocks, unstakeAmounts) = VaultLib.getRoundDataUnstakesForAccount(unstakes, startBlock, endBlock);\n', '\n', '    //     return (totalHoldings, stakeBlocks, stakeAmounts, unstakeStartBlocks, unstakeEndBlocks, unstakeAmounts);\n', '    // }\n', '\n', '    function getUnstakingsForBlockRange(\n', '        VaultLib.UnStaking[] memory unStakes, \n', '        uint startBlock, \n', '        uint endBlock) external pure returns (uint){\n', '        return VaultLib.getUnstakingsForBlockRange(\n', '                        unStakes, \n', '                        startBlock, \n', '                        endBlock\n', '                    );\n', '    }\n', '\n', '    function getHoldingsForBlockRange(\n', '        VaultLib.Staking[] memory stakes,\n', '        uint startBlock, \n', '        uint endBlock) external pure returns (uint){\n', '        \n', '        return VaultLib.getHoldingsForBlockRange(\n', '                    stakes, \n', '                    startBlock, \n', '                    endBlock);\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "@openzeppelin/contracts-upgradeable/GSN/ContextUpgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";\n', '\n', 'import "./../iTrustVaultFactory.sol";\n', 'import "./BaseContract.sol";\n', 'import "./StakingDataController/StakeData.sol";\n', 'import "./StakingCalculation.sol";\n', 'import "./StakingDataController/RoundData.sol";\n', '\n', 'contract StakingData is BaseContract\n', '{\n', '    using SafeMathUpgradeable for uint;\n', '\n', '    function initialize(\n', '        address iTrustFactoryAddress\n', '    ) \n', '        initializer \n', '        external \n', '    {\n', '        _iTrustFactoryAddress = iTrustFactoryAddress;\n', '        _locked = FALSE;\n', '    }\n', '\n', '    /**\n', '     * Public functions\n', '     */\n', '\n', '     function _getTotalSupplyForBlockRange(address vaultAddress, uint endBlock, uint startBlock) internal returns(uint) {\n', '\n', '        (bool success, bytes memory result) = \n', '            _stakeDataImplementationAddress()\n', '                .delegatecall(\n', '                    abi.encodeWithSelector(\n', '                        StakeData.getTotalSupplyForBlockRange.selector,                       \n', '                        vaultAddress, \n', '                        endBlock,\n', '                        startBlock\n', '                    )\n', '                );\n', '        require(success);\n', '        return abi.decode(result, (uint256));\n', '    }\n', '\n', '    function _getTotalUnstakingsForBlockRange(address vaultAddress, uint endBlock, uint startBlock) internal returns(uint) {\n', '\n', '        (bool success, bytes memory result) = \n', '            _stakeDataImplementationAddress()\n', '                .delegatecall(\n', '                    abi.encodeWithSelector(\n', '                         StakeData.getTotalUnstakingsForBlockRange.selector,\n', '                        vaultAddress, \n', '                        endBlock,\n', '                        startBlock\n', '                    )\n', '                );\n', '        require(success);\n', '        return abi.decode(result, (uint256));\n', '    }\n', '\n', '    \n', '\n', '     function addVault(address vaultAddress) external  {\n', '        _validateFactory();\n', '        _CurrentRoundNumbers[vaultAddress] = 1;\n', '        _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].startBlock = block.number;\n', '        _updateTotalSupplyForBlock(0);\n', '    }\n', '\n', '    function endRound(address[] calldata tokens, uint[] calldata tokenAmounts,  bool[] calldata ignoreUnstakes, uint commission) external returns(bool) {\n', '        _validateVault();\n', '\n', '        address vaultAddress = _vaultAddress();\n', ' \n', '        uint startBlock = _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].startBlock;\n', '        (bool result, ) = _roundDataImplementationAddress()\n', '            .delegatecall(\n', '                abi.encodeWithSelector(\n', '                RoundData.endRound.selector,\n', '                vaultAddress, \n', '                tokens, \n', '                tokenAmounts, \n', '                ignoreUnstakes, \n', '                _getTotalSupplyForBlockRange(\n', '                    vaultAddress, \n', '                    block.number, \n', '                    startBlock\n', '                ),\n', '                _getTotalUnstakingsForBlockRange(\n', '                        vaultAddress, \n', '                        block.number, \n', '                        startBlock\n', '                    ), \n', '                commission)\n', '            );\n', '      \n', '        require(result);\n', '        return true;\n', '    }\n', '\n', '    function getCurrentRoundData() external view returns(uint, uint, uint) {\n', '        _validateVault();\n', '        return _getRoundDataForAddress(_vaultAddress(), _CurrentRoundNumbers[_vaultAddress()]);\n', '    }\n', '\n', '    function getRoundData(uint roundNumberIn) external view returns(uint, uint, uint) {\n', '        _validateVault();\n', '        return _getRoundDataForAddress(_vaultAddress(), roundNumberIn);\n', '    }\n', '\n', '    function getRoundRewards(uint roundNumber) external  view \n', '    returns(\n', '        address[] memory rewardTokens,\n', '        uint[] memory rewardAmounts,\n', '        uint[] memory commisionAmounts,\n', '        uint[] memory tokenPerBlock, \n', '        uint[] memory totalSupply\n', '    ) {\n', '        _validateVault();\n', '        return _getRoundRewardsForAddress(_vaultAddress(), roundNumber);\n', '    }\n', '\n', '    function startUnstake(address account, uint256 value) external returns(bool) {\n', '        _validateVault();\n', '        (bool result, ) = _stakeDataImplementationAddress()\n', '            .delegatecall(abi.encodeWithSelector(StakeData.startUnstakeForAddress.selector, _vaultAddress(), account, value));\n', '        return result;\n', '    }\n', '\n', '    function getAccountStakes(address account) external view \n', '    returns(\n', '        uint stakingTotal,\n', '        uint unStakingTotal,\n', '        uint[] memory unStakingAmounts,\n', '        uint[] memory unStakingStarts            \n', '    ) {\n', '        _validateVault();\n', '        return _getAccountStakesForAddress(_vaultAddress(), account);\n', '    }\n', '\n', '    function getAccountStakingTotal(address account) external view returns (uint) {\n', '        _validateVault();\n', '        return _AccountStakes[_vaultAddress()][account].total.sub(_AccountUnstakingTotals[_vaultAddress()][account]);\n', '    }\n', '\n', '    function getAllAcountUnstakes() external view returns (address[] memory accounts, uint[] memory startTimes, uint[] memory values) {\n', '        _validateVault();\n', '        return _getAllAcountUnstakesForAddress(_vaultAddress());\n', '    }\n', '\n', '    function getAccountUnstakedTotal(address account) external view  returns (uint) {\n', '        _validateVault();\n', '        return _AccountUnstakedTotals[_vaultAddress()][account];\n', '    }\n', '\n', '    function authoriseUnstakes(address[] memory account, uint[] memory timestamp) external returns(bool) {\n', '        _validateVault();\n', '        require(account.length <= 10);        \n', '        for(uint8 i = 0; i < account.length; i++) {\n', '            _authoriseUnstake(_vaultAddress(), account[i], timestamp[i]);\n', '        }        \n', '        return true;\n', '    }\n', '\n', '    function withdrawUnstakedToken(address account, uint amount) external returns(bool)  {\n', '        _validateVault();\n', '        _nonReentrant();\n', '        _locked = TRUE;\n', '\n', '        address vaultAddress = _vaultAddress();\n', '        require(_AccountUnstakedTotals[vaultAddress][account] > 0);\n', '        require(amount <= _AccountUnstakedTotals[vaultAddress][account]);\n', '        _AccountUnstakedTotals[vaultAddress][account] = _AccountUnstakedTotals[vaultAddress][account].sub(amount);\n', '        _TotalUnstakedWnxm[vaultAddress] = _TotalUnstakedWnxm[vaultAddress].sub(amount);\n', '\n', '        _locked = FALSE;\n', '        return true;\n', '    }\n', '\n', '    function createStake(uint amount, address account) external returns(bool) {\n', '        _validateVault();\n', '        (bool result, ) = _stakeDataImplementationAddress()\n', '            .delegatecall(abi.encodeWithSelector(StakeData.createStake.selector,_vaultAddress(),amount,account));\n', '        return result;\n', '    }\n', '\n', '    function removeStake(uint amount, address account) external returns(bool) {\n', '        _validateVault();\n', '        (bool result, ) = _stakeDataImplementationAddress()\n', '            .delegatecall(abi.encodeWithSelector(StakeData.removeStake.selector, _vaultAddress(), amount, account));\n', '        return result;\n', '    }\n', '\n', '    function calculateRewards(address account) external view returns (address[] memory rewardTokens, uint[] memory rewards) {\n', '        _validateVault();\n', '        return _calculateRewards(account);\n', '    }\n', '\n', '    function withdrawRewards(address account, address[] memory rewardTokens, uint[] memory rewards) external returns(bool) {\n', '        _validateVault();\n', '        _nonReentrant();\n', '        _locked = TRUE;\n', '        _withdrawRewards(_vaultAddress(), rewardTokens, rewards, account);\n', '        _locked = FALSE;\n', '        return true;\n', '    }\n', '\n', '    function updateTotalSupplyForDayAndBlock(uint totalSupply) external returns(bool) {\n', '        _validateVault();\n', '        _updateTotalSupplyForBlock(totalSupply);\n', '        return true;\n', '    }\n', '\n', '    function getTotalSupplyForAccountBlock(address vaultAddress, uint date) external view returns(uint) {\n', '        _validateBurnContract();\n', '        return _getTotalSupplyForAccountBlock(vaultAddress, date);\n', '    }\n', '\n', '    function getHoldingsForIndexAndBlockForVault(address vaultAddress, uint index, uint blockNumber) external view returns(address indexAddress, uint addressHoldings) {\n', '        _validateBurnContract();\n', '        return _getHoldingsForIndexAndBlock(vaultAddress, index, blockNumber);\n', '    }\n', '\n', '    function getNumberOfStakingAddressesForVault(address vaultAddress) external view returns(uint) {\n', '        _validateBurnContract();\n', '        return _AccountStakesAddresses[vaultAddress].length;\n', '    }\n', '\n', '    /**\n', '     * Internal functions\n', '     */\n', '\n', '     function _getHoldingsForIndexAndBlock(address vaultAddress, uint index, uint blockNumber) internal view returns(address indexAddress, uint addressHoldings) {\n', '        require(_AccountStakesAddresses[vaultAddress].length - 1 >= index);\n', '        indexAddress = _AccountStakesAddresses[vaultAddress][index];\n', '        bytes memory data = abi.encodeWithSelector(StakingCalculation.getHoldingsForBlockRange.selector, _AccountStakes[vaultAddress][indexAddress].stakes, blockNumber, blockNumber);        \n', '        (, bytes memory resultData) = _stakingCalculationsAddress().staticcall(data);\n', '        addressHoldings = abi.decode(resultData, (uint256));\n', '        return(indexAddress, addressHoldings);\n', '    }\n', '\n', '     function _getTotalSupplyForAccountBlock(address vaultAddress, uint blockNumber) internal view returns(uint) {\n', '        uint index =  _getIndexForBlock(vaultAddress, blockNumber, 0);\n', '        return _TotalSupplyHistory[vaultAddress][_TotalSupplyKeys[vaultAddress][index]];\n', '    }\n', '\n', '     function _authoriseUnstake(address vaultAddress, address account, uint timestamp) internal {\n', '        (bool result, ) = _stakeDataImplementationAddress()\n', '            .delegatecall(abi.encodeWithSelector(StakeData.authoriseUnstake.selector, vaultAddress, account, timestamp));            \n', '        require(result);\n', '    }\n', '\n', '    function _updateTotalSupplyForBlock(uint totalSupply) public returns(bool) {\n', '        if(_TotalSupplyHistory[_vaultAddress()][block.number] == 0){  // Assumes there will never be 0, could use the array itself to check will look at this again\n', '            _TotalSupplyKeys[_vaultAddress()].push(block.number);\n', '        }\n', '\n', '        _TotalSupplyHistory[_vaultAddress()][block.number] = totalSupply;\n', '        return true;\n', '    }\n', '\n', '\n', '    function _getRoundDataForAddress(address vaultAddress, uint roundNumberIn) internal view returns(uint roundNumber, uint startBlock, uint endBlock) {\n', '        roundNumber = roundNumberIn;\n', '        startBlock = _Rounds[vaultAddress][roundNumber].startBlock;\n', '        endBlock = _Rounds[vaultAddress][roundNumber].endBlock;\n', '        return( \n', '            roundNumber,\n', '            startBlock,\n', '            endBlock\n', '        );\n', '    }\n', '\n', '    function _getRoundRewardsForAddress(address vaultAddress, uint roundNumber) internal view \n', '    returns(\n', '        address[] memory rewardTokens,\n', '        uint[] memory rewardAmounts,\n', '        uint[] memory commissionAmounts,\n', '        uint[] memory tokenPerBlock,        \n', '        uint[] memory totalSupply\n', '    ) {\n', '        rewardTokens = new address[](totalRewardTokenAddresses[vaultAddress].length);\n', '        rewardAmounts = new uint[](totalRewardTokenAddresses[vaultAddress].length);\n', '        commissionAmounts = new uint[](totalRewardTokenAddresses[vaultAddress].length);\n', '        tokenPerBlock = new uint[](totalRewardTokenAddresses[vaultAddress].length);\n', '        totalSupply  = new uint[](totalRewardTokenAddresses[vaultAddress].length);\n', '        for(uint i = 0; i < totalRewardTokenAddresses[vaultAddress].length; i++){\n', '            rewardTokens[i] = totalRewardTokenAddresses[vaultAddress][i];\n', '            rewardAmounts[i] = _Rounds[vaultAddress][roundNumber].roundData[totalRewardTokenAddresses[vaultAddress][i]].amount;\n', '            commissionAmounts[i] = _Rounds[vaultAddress][roundNumber].roundData[totalRewardTokenAddresses[vaultAddress][i]].commissionAmount;\n', '            tokenPerBlock[i] = _Rounds[vaultAddress][roundNumber].roundData[totalRewardTokenAddresses[vaultAddress][i]].tokenPerBlock;\n', '            totalSupply[i] = _Rounds[vaultAddress][roundNumber].roundData[totalRewardTokenAddresses[vaultAddress][i]].totalSupply;\n', '        }\n', '        return( \n', '            rewardTokens,\n', '            rewardAmounts,\n', '            commissionAmounts,\n', '            tokenPerBlock,\n', '            totalSupply\n', '        );\n', '    }\n', '\n', '    function _getIndexForBlock(address vaultAddress, uint startBlock, uint startIndex) internal view returns(uint) {\n', '        uint i = startIndex == 0 ? _TotalSupplyKeys[vaultAddress].length.sub(1) : startIndex;\n', '        uint blockForIndex = _TotalSupplyKeys[vaultAddress][i];\n', '        \n', '        if(_TotalSupplyKeys[vaultAddress][0] > startBlock){\n', '            return 0;\n', '        }\n', '\n', '        if(blockForIndex < startBlock){\n', '            return i;\n', '        }\n', '\n', '        while(blockForIndex > startBlock){\n', '            i = i.sub(1);\n', '            blockForIndex = _TotalSupplyKeys[vaultAddress][i];\n', '        }\n', '\n', '        return i;\n', '    }\n', '\n', '    function _getAccountStakesForAddress(address vaultAddress, address account) internal view \n', '    returns(\n', '        uint stakingTotal,\n', '        uint unStakingTotal,\n', '        uint[] memory unStakingAmounts,\n', '        uint[] memory unStakingStarts            \n', '    ) {\n', '        unStakingAmounts = new uint[](_AccountUnstakings[vaultAddress][account].length);\n', '        unStakingStarts = new uint[](_AccountUnstakings[vaultAddress][account].length);\n', '        for(uint i = 0; i < _AccountUnstakings[vaultAddress][account].length; i++){\n', '            if(_AccountUnstakings[vaultAddress][account][i].endBlock == 0){\n', '                unStakingAmounts[i] = _AccountUnstakings[vaultAddress][account][i].amount;\n', '                unStakingStarts[i] = _AccountUnstakings[vaultAddress][account][i].startDateTime;\n', '            }\n', '        }\n', '        return( \n', '            _AccountStakes[vaultAddress][account].total.sub(_AccountUnstakingTotals[vaultAddress][account]),\n', '            _AccountUnstakingTotals[vaultAddress][account],\n', '            unStakingAmounts,\n', '            unStakingStarts\n', '        );\n', '    }\n', '\n', '    function _getAllAcountUnstakesForAddress(address vaultAddress) internal view returns (address[] memory accounts, uint[] memory startTimes, uint[] memory values) {\n', '        accounts = new address[](_UnstakingRequests[vaultAddress].length);\n', '        startTimes = new uint[](_UnstakingRequests[vaultAddress].length);\n', '        values = new uint[](_UnstakingRequests[vaultAddress].length);\n', '        for(uint i = 0; i < _UnstakingRequests[vaultAddress].length; i++) {\n', '            if(_UnstakingRequests[vaultAddress][i].endBlock == 0 ) {\n', '                accounts[i] = _UnstakingRequests[vaultAddress][i].account;\n', '                startTimes[i] = _UnstakingRequests[vaultAddress][i].startDateTime;\n', '                values[i] = _UnstakingRequests[vaultAddress][i].amount;\n', '            }\n', '        }        \n', '        return(accounts, startTimes, values);\n', '    }\n', '\n', '    function getUnstakedWxnmTotal() external view returns(uint total) {\n', '        _validateVault();\n', '        total = _TotalUnstakedWnxm[_vaultAddress()];\n', '    }\n', '\n', '    function _calculateRewards(address account) internal view  returns (address[] memory rewardTokens, uint[] memory rewards) {\n', '        rewardTokens = totalRewardTokenAddresses[_vaultAddress()];\n', '        rewards = new uint[](rewardTokens.length);\n', '\n', '        for(uint x = 0; x < totalRewardTokenAddresses[_vaultAddress()].length; x++){            \n', '            (rewards[x]) = _calculateReward(_vaultAddress(), account, rewardTokens[x]);            \n', '            rewards[x] = rewards[x].div(1 ether);\n', '        }\n', '\n', '        return (rewardTokens, rewards);\n', '    }\n', '\n', '     function _calculateReward(address vaultAddress, address account, address rewardTokenAddress) internal view returns (uint reward){\n', '        VaultLib.ClaimedReward memory claimedReward = _AccountRewards[vaultAddress][account][rewardTokenAddress];\n', '\n', '        if(_RewardStartingRounds[vaultAddress][rewardTokenAddress] == 0){            \n', '            return(0);\n', '        }\n', '\n', '        uint futureRoundNumber = _CurrentRoundNumbers[vaultAddress] - 1;// one off as the current hasnt closed\n', '        address calcContract = _stakingCalculationsAddress();\n', '        while(claimedReward.lastClaimedRound < futureRoundNumber \n', '                && _RewardStartingRounds[vaultAddress][rewardTokenAddress] <= futureRoundNumber\n', '                && futureRoundNumber != 0 )\n', '        {\n', '\n', '            if(_Rounds[vaultAddress][futureRoundNumber].roundData[rewardTokenAddress].amount == 0){\n', '                futureRoundNumber--;\n', '                continue;\n', '            }\n', '\n', '            (, bytes memory resultData) = calcContract.staticcall(abi.encodeWithSignature(\n', '                "getHoldingsForBlockRange((uint256,uint256,uint256,uint256)[],uint256,uint256)", \n', '                _AccountStakes[vaultAddress][account].stakes, \n', '                _Rounds[vaultAddress][futureRoundNumber].startBlock, \n', '                _Rounds[vaultAddress][futureRoundNumber].endBlock\n', '            ));\n', '            uint holdingsForRound = abi.decode(resultData, (uint256));\n', '\n', '            if (!(_Rounds[vaultAddress][futureRoundNumber].roundData[rewardTokenAddress].ignoreUnstakes)) {\n', '                (, bytes memory unstakedResultData) = calcContract.staticcall(abi.encodeWithSignature(\n', '                    "getUnstakingsForBlockRange((address,uint256,uint256,uint256,uint256)[],uint256,uint256)", \n', '                    _AccountUnstakings[vaultAddress][account], \n', '                    _Rounds[vaultAddress][futureRoundNumber].startBlock, \n', '                    _Rounds[vaultAddress][futureRoundNumber].endBlock\n', '                ));\n', '                holdingsForRound = holdingsForRound.sub(abi.decode(unstakedResultData, (uint256)));\n', '            }\n', '           \n', '            holdingsForRound = VaultLib.divider(\n', '                     holdingsForRound, \n', '                     _Rounds[vaultAddress][futureRoundNumber].roundData[rewardTokenAddress].totalSupply, \n', '                     18)\n', '                     .mul(_Rounds[vaultAddress][futureRoundNumber].roundData[rewardTokenAddress].amount);\n', '            reward = reward.add(holdingsForRound);\n', '            futureRoundNumber--;\n', '        }\n', '\n', '        return (reward);\n', '    }\n', '\n', '    function _withdrawRewards(address vaultAddress, address[] memory rewardTokens, uint[] memory rewards, address account) internal {\n', '          \n', '        for (uint x = 0; x < rewardTokens.length; x++){\n', '            _AccountRewards[vaultAddress][account][rewardTokens[x]].amount = _AccountRewards[vaultAddress][account][rewardTokens[x]].amount + rewards[x];\n', '            _AccountRewards[vaultAddress][account][rewardTokens[x]].lastClaimedRound = _CurrentRoundNumbers[vaultAddress] - 1;\n', '        }\n', '\n', '    }\n', '\n', '    function _vaultAddress() internal view returns(address) {\n', '        return _msgSender();\n', '    }\n', '\n', '    function _roundDataImplementationAddress() internal view returns(address) {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        return vaultFactory.getRoundDataImplementationAddress();\n', '    }\n', '\n', '    function _stakeDataImplementationAddress() internal view returns(address) {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        return vaultFactory.getStakeDataImplementationAddress();\n', '    }\n', '\n', '    function _stakingCalculationsAddress() internal view returns(address) {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        return address(vaultFactory.getStakingCalculationsAddress());\n', '    }\n', '\n', '    /**\n', '     * Validate functions\n', '     */\n', '\n', '    function _validateVault() internal view {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        require(vaultFactory.isActiveVault(_vaultAddress()));\n', '    }\n', '\n', '    function _validateBurnContract() internal view {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        require(vaultFactory.isBurnAddress(_msgSender()));\n', '    }\n', '\n', '    function _validateFactory() internal view {\n', '        require(_msgSender() == _iTrustFactoryAddress);\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";\n', 'import "./../BaseContract.sol";\n', '\n', 'contract RoundData is BaseContract\n', '{\n', '    using SafeMathUpgradeable for uint;\n', '    \n', '    function endRound(\n', '        address vaultAddress, \n', '        address[] memory tokens, \n', '        uint[] memory tokenAmounts, \n', '        bool[] memory ignoreUnstakes,        \n', '        uint totalSupplyForBlockRange, \n', '        uint totalUnstakings,\n', '        uint commissionValue) \n', '        external \n', '    {\n', '        require( _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].startBlock < block.number);       \n', '        uint32 roundNumber = _CurrentRoundNumbers[vaultAddress];\n', '        uint rewardAmount;\n', '        uint commissionAmount;\n', '        uint tokensPerBlock; //Amoun\n', '\n', '        for (uint i=0; i < tokens.length; i++) {    \n', '              \n', '            rewardAmount = tokenAmounts[i].sub(tokenAmounts[i].mul(commissionValue).div(10000));\n', '            commissionAmount = tokenAmounts[i].mul(commissionValue).div(10000);\n', '            tokensPerBlock = VaultLib.divider(rewardAmount, _getAdjustedTotalSupply(totalSupplyForBlockRange, totalUnstakings, ignoreUnstakes[i]), 18);\n', '            VaultLib.RewardTokenRoundData memory tokenData = VaultLib.RewardTokenRoundData(\n', '                {\n', '                    tokenAddress: tokens[i],\n', '                    amount: rewardAmount,\n', '                    commissionAmount: commissionAmount,\n', '                    tokenPerBlock: tokensPerBlock,//.div(1e18),\n', '                    totalSupply: _getAdjustedTotalSupply(totalSupplyForBlockRange, totalUnstakings, ignoreUnstakes[i]),  \n', '                    ignoreUnstakes: ignoreUnstakes[i]\n', '                }\n', '            );\n', '\n', '            _Rounds[vaultAddress][roundNumber].roundData[tokens[i]] = tokenData;            \n', '           \n', '            if(_RewardTokens[vaultAddress][tokens[i]] != TRUE){\n', '                _RewardStartingRounds[vaultAddress][tokens[i]] = roundNumber;\n', '                totalRewardTokenAddresses[vaultAddress].push(tokens[i]);\n', '                _RewardTokens[vaultAddress][tokens[i]] = TRUE;\n', '            }\n', '        }\n', '\n', '        //do this last\n', '         _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].endBlock = block.number;\n', '        _CurrentRoundNumbers[vaultAddress]++;\n', '        _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].startBlock = block.number;\n', '        \n', '    }\n', '\n', '    function _getAdjustedTotalSupply(uint totalSupply, uint totalUnstaking, bool ignoreUnstaking) internal pure returns(uint) {\n', '        if(ignoreUnstaking) {\n', '            return totalSupply;\n', '        }\n', '        return (totalUnstaking > totalSupply ? 0 : totalSupply.sub(totalUnstaking));\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";\n', '\n', 'import "./../BaseContract.sol";\n', 'import "./../GovernanceDistribution.sol";\n', '\n', 'contract StakeData is BaseContract\n', '{    \n', '    using SafeMathUpgradeable for uint;\n', '\n', '    function startUnstakeForAddress(address vaultAddress, address account, uint256 value) external  {\n', '        require( \n', '            ( _AccountStakes[vaultAddress][account].total.sub(_AccountUnstakingTotals[vaultAddress][account]) ) \n', '            >= value);\n', '\n', '        _AccountUnstakingTotals[vaultAddress][account] =_AccountUnstakingTotals[vaultAddress][account].add(value);\n', '        VaultLib.UnStaking memory unstaking = VaultLib.UnStaking(account, value, block.timestamp, block.number, 0 );\n', '        _AccountUnstakings[vaultAddress][account].push(unstaking);\n', '        _UnstakingRequests[vaultAddress].push(unstaking);\n', '        _UnstakingAddresses[vaultAddress].push(account);\n', '        _TotalUnstakingKeys[vaultAddress].push(block.number);\n', '        _TotalUnstakingHistory[vaultAddress][block.number]  = unstaking;\n', '    }\n', '\n', '    function authoriseUnstake(address vaultAddress, address account, uint timestamp) external {\n', '        uint amount = 0;        \n', '        for(uint i = 0; i < _AccountUnstakings[vaultAddress][account].length; i++){\n', '            if(_AccountUnstakings[vaultAddress][account][i].startDateTime == timestamp) {\n', '                amount = _AccountUnstakings[vaultAddress][account][i].amount;\n', '                _AccountUnstakedTotals[vaultAddress][account] = _AccountUnstakedTotals[vaultAddress][account] + amount;\n', '                _AccountUnstakings[vaultAddress][account][i].endBlock = block.number;\n', '                _AccountUnstakingTotals[vaultAddress][account] = _AccountUnstakingTotals[vaultAddress][account] - amount;\n', '                _TotalUnstakedWnxm[vaultAddress] = _TotalUnstakedWnxm[vaultAddress].add(amount);\n', '                break;\n', '            }\n', '        }\n', '\n', '        for(uint i = 0; i < _UnstakingRequests[vaultAddress].length; i++){\n', '            if(_UnstakingRequests[vaultAddress][i].startDateTime == timestamp &&\n', '                _UnstakingRequests[vaultAddress][i].amount == amount &&\n', '                _UnstakingRequests[vaultAddress][i].endBlock == 0 &&\n', '                _UnstakingAddresses[vaultAddress][i] == account) \n', '            {\n', '                    delete _UnstakingAddresses[vaultAddress][i];\n', '                    _UnstakingRequests[vaultAddress][i].endBlock = block.number;\n', '                    _TotalUnstakingHistory[vaultAddress]\n', '                        [_UnstakingRequests[vaultAddress][i].startBlock].endBlock = block.number;\n', '            }\n', '        }\n', '        \n', '        _AccountStakes[vaultAddress][account].total = _AccountStakes[vaultAddress][account].total.sub(amount);\n', '        _AccountStakes[vaultAddress][account].stakes.push(VaultLib.Staking(block.timestamp, block.number, amount, _AccountStakes[vaultAddress][account].total));\n', '        _governanceDistributionContract().removeStake(account, amount);\n', '        \n', '    }\n', '\n', '    function createStake(address vaultAddress, uint amount, address account) external {\n', '\n', '        if( _AccountStakes[vaultAddress][account].startRound == 0) {\n', '            _AccountStakes[vaultAddress][account].startRound = _CurrentRoundNumbers[vaultAddress];\n', '            _AccountStakesAddresses[vaultAddress].push(account);\n', '        }\n', '\n', '        _AccountStakes[vaultAddress][account].total = _AccountStakes[vaultAddress][account].total.add(amount);\n', '        // block number is being used to record the block at which staking started for governance token distribution\n', '        _AccountStakes[vaultAddress][account].stakes.push(\n', '            VaultLib.Staking(block.timestamp, block.number, amount, _AccountStakes[vaultAddress][account].total)\n', '        );\n', '        _governanceDistributionContract().addStake(account, amount);\n', '    }\n', '\n', '    function removeStake(address vaultAddress, uint amount, address account) external {\n', '\n', '        if( _AccountStakes[vaultAddress][account].startRound == 0) {\n', '            _AccountStakes[vaultAddress][account].startRound = _CurrentRoundNumbers[vaultAddress];\n', '             _AccountStakesAddresses[vaultAddress].push(account);\n', '        }\n', '\n', '        require(_AccountStakes[vaultAddress][account].total >= amount);\n', '\n', '        _AccountStakes[vaultAddress][account].total = _AccountStakes[vaultAddress][account].total.sub(amount);\n', '        // block number is being used to record the block at which staking started for governance token distribution\n', '        _AccountStakes[vaultAddress][account].stakes.push(\n', '            VaultLib.Staking(block.timestamp, block.number, amount, _AccountStakes[vaultAddress][account].total)\n', '        );\n', '        _governanceDistributionContract().removeStake(account, amount);\n', '    }\n', '\n', '    function _governanceDistributionAddress() internal view returns(address) {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        return vaultFactory.getGovernanceDistributionAddress();\n', '    }\n', '\n', '    function _governanceDistributionContract() internal view returns(GovernanceDistribution) {\n', '        return GovernanceDistribution(_governanceDistributionAddress());\n', '    }\n', '\n', '    function getTotalUnstakingsForBlockRange(address vaultAddress, uint endBlock, uint startBlock) external view returns(uint) {\n', '         // If we have bad data, no supply data or it starts after the block we are looking for then we can return zero\n', '        if(endBlock < startBlock \n', '            || _TotalUnstakingKeys[vaultAddress].length == 0 \n', '            || _TotalUnstakingKeys[vaultAddress][0] > endBlock){\n', '            return 0;\n', '        }\n', '\n', '        uint lastIndex = _TotalUnstakingKeys[vaultAddress].length - 1;\n', '        uint total;\n', '        uint diff;\n', '        uint stakeEnd;\n', '        uint stakeStart;\n', '        if(_TotalUnstakingHistory[vaultAddress][_TotalUnstakingKeys[vaultAddress][lastIndex]].endBlock < startBlock\n', '            && lastIndex == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        //last index should now be in our range so loop through until all block numbers are covered\n', '        while( lastIndex >= 0 ) {\n', '\n', '            if( _TotalUnstakingHistory[vaultAddress][_TotalUnstakingKeys[vaultAddress][lastIndex]].endBlock < startBlock &&\n', '                _TotalUnstakingHistory[vaultAddress][_TotalUnstakingKeys[vaultAddress][lastIndex]].endBlock != 0 )\n', '            {\n', '                if (lastIndex == 0) {\n', '                    break;\n', '                }\n', '                lastIndex = lastIndex.sub(1);\n', '                continue;\n', '            }\n', '\n', '            stakeEnd = _TotalUnstakingHistory[vaultAddress][_TotalUnstakingKeys[vaultAddress][lastIndex]].endBlock == 0 \n', '                ? endBlock : _TotalUnstakingHistory[vaultAddress][_TotalUnstakingKeys[vaultAddress][lastIndex]].endBlock;\n', '\n', '            stakeEnd = (stakeEnd >= endBlock ? endBlock : stakeEnd);\n', '\n', '            stakeStart = _TotalUnstakingHistory[vaultAddress][_TotalUnstakingKeys[vaultAddress][lastIndex]].startBlock < startBlock \n', '                ? startBlock : _TotalUnstakingHistory[vaultAddress][_TotalUnstakingKeys[vaultAddress][lastIndex]].startBlock;\n', '            \n', '            diff = (stakeEnd == stakeStart ? 1 : stakeEnd.sub(stakeStart));\n', '           \n', '            total = total.add(_TotalUnstakingHistory[vaultAddress][_TotalUnstakingKeys[vaultAddress][lastIndex]].amount.mul(diff));\n', '           \n', '\n', '            if(lastIndex == 0){\n', '                break;\n', '            } \n', '\n', '            lastIndex = lastIndex.sub(1); \n', '        }\n', '\n', '        return total;\n', '    }\n', '\n', '    function getTotalSupplyForBlockRange(address vaultAddress, uint endBlock, uint startBlock) external view returns(uint) {\n', '\n', '        // If we have bad data, no supply data or it starts after the block we are looking for then we can return zero\n', '        if(endBlock < startBlock \n', '            || _TotalSupplyKeys[vaultAddress].length == 0 \n', '            || _TotalSupplyKeys[vaultAddress][0] > endBlock){\n', '            return 0;\n', '        }\n', '        uint lastIndex = _TotalSupplyKeys[vaultAddress].length - 1;\n', '        \n', '        // If the last total supply is before the start we are looking for we can take the last value\n', '        if(_TotalSupplyKeys[vaultAddress][lastIndex] <= startBlock){\n', '            return _TotalSupplyHistory[vaultAddress][_TotalSupplyKeys[vaultAddress][lastIndex]].mul(endBlock.sub(startBlock));\n', '        }\n', '\n', '        // working our way back we need to get the first index that falls into our range\n', '        // This could be large so need to think of a better way to get here\n', '        while(lastIndex > 0 && _TotalSupplyKeys[vaultAddress][lastIndex] > endBlock){\n', '            if(lastIndex == 0){\n', '                break;\n', '            } \n', '            lastIndex = lastIndex.sub(1);\n', '        }\n', '\n', '        uint total;\n', '        uint diff;\n', '        //last index should now be in our range so loop through until all block numbers are covered\n', '       \n', '        while(_TotalSupplyKeys[vaultAddress][lastIndex] >= startBlock) {  \n', '            diff = 0;\n', '            if(_TotalSupplyKeys[vaultAddress][lastIndex] <= startBlock){\n', '                diff = endBlock.sub(startBlock) == 0 ? 1 : endBlock.sub(startBlock);\n', '                total = total.add(_TotalSupplyHistory[vaultAddress][_TotalSupplyKeys[vaultAddress][lastIndex]].mul(diff));\n', '                break;\n', '            }\n', '            \n', '            diff = endBlock.sub(_TotalSupplyKeys[vaultAddress][lastIndex]) == 0 ? 1 : endBlock.sub(_TotalSupplyKeys[vaultAddress][lastIndex]);\n', '            total = total.add(_TotalSupplyHistory[vaultAddress][_TotalSupplyKeys[vaultAddress][lastIndex]].mul(diff));\n', '            endBlock = _TotalSupplyKeys[vaultAddress][lastIndex];\n', '\n', '            if(lastIndex == 0){\n', '                break;\n', '            } \n', '\n', '            lastIndex = lastIndex.sub(1); \n', '        }\n', '\n', '        // If the last total supply is before the start we are looking for we can take the last value\n', '        if(_TotalSupplyKeys[vaultAddress][lastIndex] <= startBlock && startBlock < endBlock){\n', '            total = total.add(_TotalSupplyHistory[vaultAddress][_TotalSupplyKeys[vaultAddress][lastIndex]].mul(endBlock.sub(startBlock)));\n', '        }\n', ' \n', '        return total;\n', '    }\n', '\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', 'pragma abicoder v2;\n', '\n', 'import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";\n', 'import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";\n', 'import "./StakingData.sol";\n', 'import "./../iTrustVaultFactory.sol";\n', 'import { ITrustVaultLib as VaultLib } from "./../libraries/ItrustVaultLib.sol"; \n', 'contract Vault is  \n', '    ERC20Upgradeable \n', '{\n', '    using SafeMathUpgradeable for uint;\n', '\n', '    uint8 internal constant FALSE = 0;\n', '    uint8 internal constant TRUE = 1;\n', '    uint8 internal _Locked;\n', '\n', '    uint internal _RewardCommission;\n', '    uint internal _AdminFee;    \n', '    address internal _NXMAddress;\n', '    address internal _WNXMAddress;\n', '    address payable internal _VaultWalletAddress;\n', '    address payable internal _TreasuryAddress;\n', '    address internal _StakingDataAddress;\n', '    address internal _BurnDataAddress;\n', '    address internal _iTrustFactoryAddress;\n', '    mapping (address => uint256) internal _ReentrantCheck;\n', '    mapping(address => mapping(string => bool)) internal _UsedNonces;\n', '\n', '    event Stake(address indexed account, address indexed tokenAddress, uint amount, uint balance, uint totalStaked);\n', '    event UnstakedRequest(address indexed  account, uint amount, uint balance, uint totalStaked);\n', '    event UnstakedApproved(address indexed  account, uint amount, uint balance, uint totalStaked);\n', '    event TransferITV(\n', '        address indexed  fromAccount, \n', '        address indexed toAccount, \n', '        uint amount, \n', '        uint fromBalance, \n', '        uint fromTotalStaked,\n', '        uint toBalance, \n', '        uint toTotalStaked);\n', '    \n', '    function initialize(\n', '        address nxmAddress,\n', '        address wnxmAddress,\n', '        address vaultWalletAddress,\n', '        address stakingDataAddress,\n', '        address burnDataAddress,\n', '        string memory tokenName,\n', '        string memory tokenSymbol,\n', '        uint adminFee,\n', '        uint commission,\n', '        address treasuryAddress\n', '    ) \n', '        initializer \n', '        external \n', '    {\n', '        __ERC20_init(tokenName, tokenSymbol); \n', '        _Locked = FALSE;\n', '        _NXMAddress = nxmAddress;\n', '        _WNXMAddress = wnxmAddress;\n', '        _VaultWalletAddress = payable(vaultWalletAddress);\n', '        _StakingDataAddress = stakingDataAddress;\n', '        _BurnDataAddress = burnDataAddress;\n', '        _AdminFee = adminFee;\n', '        _iTrustFactoryAddress = _msgSender();\n', '        _RewardCommission = commission;\n', '        _TreasuryAddress = payable(treasuryAddress);\n', '    }\n', '\n', '    /**\n', '     * Public functions\n', '     */\n', '\n', '    function getAdminFee() external view returns (uint) {\n', '        return _AdminFee;\n', '    }\n', '\n', '    function SetAdminFee(uint newFee) external {\n', '        _onlyAdmin();\n', '        _AdminFee = newFee;\n', '    }\n', '\n', '    function setCommission(uint newCommission) external {\n', '        _onlyAdmin();\n', '        _RewardCommission = newCommission;\n', '    }\n', '\n', '    function setTreasury(address newTreasury) external {\n', '        _onlyAdmin();\n', '        _TreasuryAddress = payable(newTreasury);\n', '    }\n', '\n', '    function depositNXM(uint256 value) external  {\n', '        _valueCheck(value);\n', '        _nonReentrant();\n', '        _Locked = TRUE;\n', '        IERC20Upgradeable nxmToken = IERC20Upgradeable(_NXMAddress);        \n', '\n', '        _mint(\n', '            _msgSender(),\n', '            value\n', '        );\n', '        \n', '        require(_getStakingDataContract().createStake(value, _msgSender()));\n', '        require(nxmToken.transferFrom(_msgSender(), _VaultWalletAddress, value));        \n', '        emit Stake(\n', '            _msgSender(), \n', '            _NXMAddress, \n', '            value,\n', '            balanceOf(_msgSender()),\n', '            _getStakingDataContract().getAccountStakingTotal(_msgSender()));\n', '\n', '        _Locked = FALSE;\n', '    }\n', '\n', '    function _depositRewardToken(address token, uint amount) internal {        \n', '        require(token != address(0));   \n', '        uint commission = 0;\n', '        uint remain = amount;\n', '        if (_RewardCommission != 0) {\n', '            commission = amount.mul(_RewardCommission).div(10000);\n', '            remain = amount.sub(commission);            \n', '        }       \n', '\n', '        IERC20Upgradeable tokenContract = IERC20Upgradeable(token);\n', '        if (commission != 0) {\n', '            require(tokenContract.transferFrom(msg.sender, _TreasuryAddress, commission));  \n', '        }\n', '        require(tokenContract.transferFrom(msg.sender, address(this), remain));  \n', '    }\n', '\n', '    function endRound(address[] calldata tokens, uint[] calldata tokenAmounts, bool[] calldata ignoreUnstakes) external {\n', '        _onlyAdmin();\n', '        require(tokens.length == tokenAmounts.length);\n', '        \n', '        require(_getStakingDataContract().endRound(tokens, tokenAmounts, ignoreUnstakes, _RewardCommission));\n', '        for(uint i = 0; i < tokens.length; i++) {\n', '            _depositRewardToken(tokens[i], tokenAmounts[i]);\n', '        }\n', '    }\n', '\n', '    function getCurrentRoundData() external view returns(uint roundNumber, uint startBlock, uint endBlock) {\n', '        _onlyAdmin();\n', '       \n', '        return _getStakingDataContract().getCurrentRoundData();\n', '    }\n', '\n', '    function getRoundData(uint roundNumberIn) external view returns(uint roundNumber, uint startBlock, uint endBlock) {\n', '        _onlyAdmin();\n', '        \n', '        return _getStakingDataContract().getRoundData(roundNumberIn);\n', '    }\n', '\n', '    function getRoundRewards(uint roundNumber) external view \n', '    returns(\n', '        address[] memory rewardTokens,\n', '        uint[] memory rewardAmounts ,\n', '        uint[] memory commissionAmounts,\n', '        uint[] memory tokenPerDay,\n', '        uint[] memory totalSupply              \n', '    ) {\n', '        _onlyAdmin();\n', '        \n', '        return _getStakingDataContract().getRoundRewards(roundNumber);\n', '    }\n', '\n', '    function depositWNXM(uint256 value) external {\n', '        _valueCheck(value);\n', '        _nonReentrant();\n', '        _Locked = TRUE;\n', '        IERC20Upgradeable wnxmToken = IERC20Upgradeable(_WNXMAddress);\n', '        \n', '        _mint(\n', '            _msgSender(),\n', '            value\n', '        );\n', '\n', '        require(_getStakingDataContract().createStake(value, _msgSender()));\n', '        require(wnxmToken.transferFrom(_msgSender(), _VaultWalletAddress, value));        \n', '        emit Stake(\n', '            _msgSender(), \n', '            _WNXMAddress, \n', '            value,\n', '            balanceOf(_msgSender()),\n', '            _getStakingDataContract().getAccountStakingTotal(_msgSender()));\n', '        _Locked = FALSE;\n', '    }\n', '\n', '    function startUnstake(uint256 value) external payable  {\n', '        _nonReentrant();\n', '        _Locked = TRUE;\n', '        uint adminFee = _AdminFee;\n', '        if(adminFee != 0) {\n', '            require(msg.value == _AdminFee);\n', '        }\n', '        \n', '        require(_getStakingDataContract().startUnstake(_msgSender(), value));\n', '        if(adminFee != 0) {\n', '            (bool sent, ) = _VaultWalletAddress.call{value: adminFee}("");\n', '            require(sent);\n', '        }\n', '        emit UnstakedRequest(\n', '            _msgSender(), \n', '            value,\n', '            balanceOf(_msgSender()),\n', '            _getStakingDataContract().getAccountStakingTotal(_msgSender()));\n', '\n', '        _Locked = FALSE;\n', '    }\n', '\n', '    function getAccountStakes() external  view \n', '    returns(\n', '        uint stakingTotal,\n', '        uint unStakingTotal,\n', '        uint[] memory unStakingAmounts,\n', '        uint[] memory unStakingStarts            \n', '    ) {       \n', '        return _getStakingDataContract().getAccountStakes(_msgSender());\n', '    }\n', '\n', '    function getAllAcountUnstakes() external view returns (address[] memory accounts, uint[] memory startTimes, uint[] memory values) {\n', '        _onlyAdmin();\n', '        return _getStakingDataContract().getAllAcountUnstakes();\n', '    }\n', '\n', '    function getAccountUnstakedTotal() external view  returns (uint) {\n', '        return _getStakingDataContract().getAccountUnstakedTotal(_msgSender());\n', '    }\n', '\n', '    function getUnstakedwNXMTotal() external view returns (uint) {\n', '        return _getStakingDataContract().getUnstakedWxnmTotal();\n', '    }\n', '\n', '\n', '    function authoriseUnstakes(address[] memory account, uint[] memory timestamp, uint[] memory amounts) external {\n', '        _onlyAdmin();        \n', '        require(_getStakingDataContract().authoriseUnstakes(account, timestamp));  \n', '        //for each unstake burn\n', '        for(uint i = 0; i < account.length; i++) {\n', '            _burn(account[i], amounts[i]); \n', '            emit UnstakedApproved(\n', '                account[i], \n', '                amounts[i],\n', '                balanceOf(account[i]),\n', '                _getStakingDataContract().getAccountStakingTotal(account[i]));\n', '        }             \n', '    }\n', '\n', '    function withdrawUnstakedwNXM(uint amount) external {\n', '        _nonReentrant();\n', '        _Locked = TRUE;\n', '        IERC20Upgradeable wnxm = IERC20Upgradeable(_WNXMAddress);\n', '       \n', '        uint balance = wnxm.balanceOf(address(this));\n', '        \n', '        require(amount <= balance);\n', '        require(_getStakingDataContract().withdrawUnstakedToken(_msgSender(), amount));\n', '\n', '        require(wnxm.transfer(msg.sender, amount));\n', '       \n', '      //  emit ClaimUnstaked(msg.sender, amount);\n', '        _Locked = FALSE;\n', '    }\n', '\n', '    function isAdmin() external view returns (bool) {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        return vaultFactory.isAddressAdmin(_msgSender());\n', '    }\n', '    function calculateRewards() external view returns (address[] memory rewardTokens, uint[] memory rewards) {        \n', '        return _getStakingDataContract().calculateRewards(_msgSender());\n', '    }\n', '\n', '    function calculateRewardsForAccount(address account) external view returns (address[] memory rewardTokens, uint[] memory rewards) {\n', '        _isTrustedSigner(_msgSender());\n', '       \n', '        return _getStakingDataContract().calculateRewards(account);\n', '    }\n', '\n', '    function withdrawRewards(address[] memory tokens, uint[] memory rewards, string memory nonce, bytes memory sig) external returns (bool) {\n', '        require(!_UsedNonces[_msgSender()][nonce]);\n', '        _nonReentrant();\n', '        _Locked = TRUE;\n', '        bool toClaim = false;\n', '        for(uint x = 0; x < tokens.length; x++){\n', '            if(rewards[x] != 0) {\n', '                toClaim = true;\n', '            }\n', '        }\n', '        require(toClaim == true);\n', '        bytes32 abiBytes = keccak256(abi.encodePacked(_msgSender(), tokens, rewards, nonce, address(this)));\n', '        bytes32 message = VaultLib.prefixed(abiBytes);\n', '\n', '        address signer = VaultLib.recoverSigner(message, sig);\n', '        _isTrustedSigner(signer);\n', '\n', '       \n', '        require(_getStakingDataContract().withdrawRewards(_msgSender(), tokens, rewards));\n', '        _UsedNonces[_msgSender()][nonce] = true;\n', '\n', '        for(uint x = 0; x < tokens.length; x++){\n', '            if(rewards[x] != 0) {\n', '                IERC20Upgradeable token = IERC20Upgradeable(tokens[x]); \n', '                require(token.balanceOf(address(this)) >= rewards[x]);\n', '                require(token.transfer(_msgSender() ,rewards[x]));\n', '            }\n', '        }\n', '        _Locked = FALSE;\n', '        return true;\n', '    }\n', '\n', '    function burnTokensForAccount(address account, uint tokensToBurn) external returns(bool) {\n', '        _nonReentrant();\n', '        _validBurnSender();\n', '        require(tokensToBurn > 0);\n', '        _Locked = TRUE;\n', '         _burn(account, tokensToBurn);\n', '        require(_getStakingDataContract().removeStake(tokensToBurn, account));\n', '        _Locked = FALSE;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20Upgradeable-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) { \n', '        _transfer(_msgSender(), recipient, amount);\n', '                \n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20Upgradeable-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(sender, recipient, amount);   \n', '        _approve(sender, _msgSender(), allowance(_msgSender(), sender).sub(amount));     \n', '        return true;    \n', '    }\n', '\n', '    /**\n', '     * @dev required to be allow for receiving ETH claim payouts\n', '     */\n', '    receive() external payable {}\n', '\n', '    /**\n', '     * Private functions\n', '     */\n', '\n', '     /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal override {\n', '        super._mint(account, amount);\n', '        _updateTotalSupplyForBlock();\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal override {\n', '        super._burn(account, amount);\n', '        _updateTotalSupplyForBlock();\n', '    }\n', '\n', '    function _getStakingDataContract() internal view returns (StakingData){\n', '        return StakingData(_StakingDataAddress);\n', '    }\n', '    function _updateTotalSupplyForBlock() internal {\n', '        require(_getStakingDataContract().updateTotalSupplyForDayAndBlock(totalSupply()));\n', '    }\n', '\n', '\n', '     /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal override {\n', '\n', '        require(_getStakingDataContract().removeStake(amount, sender));\n', '        require(_getStakingDataContract().createStake(amount, recipient));\n', '        \n', '        super._transfer(sender, recipient, amount);\n', '        emit TransferITV(\n', '            sender,\n', '            recipient,\n', '            amount,            \n', '            balanceOf(sender),\n', '            _getStakingDataContract().getAccountStakingTotal(sender),\n', '            balanceOf(recipient),\n', '            _getStakingDataContract().getAccountStakingTotal(recipient));            \n', '        _updateTotalSupplyForBlock();\n', '    }\n', '\n', '     /**\n', '     * Private validation functions\n', '     */\n', '\n', '    function _valueCheck(uint value) internal pure {\n', '        require(value != 0, "!");\n', '    }\n', '\n', '    function _onlyAdmin() internal view {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        require(\n', '            vaultFactory.isAddressAdmin(_msgSender()),\n', '            "NTA"\n', '        );\n', '    }\n', '\n', '    function _validBurnSender() internal view {\n', '        require(\n', '            _BurnDataAddress == _msgSender(),\n', '            "NTB"\n', '        );\n', '    }\n', '\n', '    function _isTrustedSigner(address signer) internal view {\n', '        ITrustVaultFactory vaultFactory = ITrustVaultFactory(_iTrustFactoryAddress);\n', '        require(\n', '            vaultFactory.isTrustedSignerAddress(signer),\n', '            "NTS"\n', '        );\n', '    }\n', '\n', '\n', '    function _nonReentrant() internal view {\n', '        require(_Locked == FALSE);\n', '    }  \n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', 'import "../proxy/Initializable.sol";\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract ContextUpgradeable is Initializable {\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '    }\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '    uint256[50] private __gap;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "../GSN/ContextUpgradeable.sol";\n', 'import "../proxy/Initializable.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMathUpgradeable {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity >=0.4.24 <0.8.0;\n', '\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' * \n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n', ' * \n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || _isConstructor() || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function _isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { cs := extcodesize(self) }\n', '        return cs == 0;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./ERC20Upgradeable.sol";\n', 'import "../../proxy/Initializable.sol";\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n', ' */\n', 'abstract contract ERC20CappedUpgradeable is Initializable, ERC20Upgradeable {\n', '    using SafeMathUpgradeable for uint256;\n', '\n', '    uint256 private _cap;\n', '\n', '    /**\n', '     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n', '     * set once during construction.\n', '     */\n', '    function __ERC20Capped_init(uint256 cap_) internal initializer {\n', '        __Context_init_unchained();\n', '        __ERC20Capped_init_unchained(cap_);\n', '    }\n', '\n', '    function __ERC20Capped_init_unchained(uint256 cap_) internal initializer {\n', '        require(cap_ > 0, "ERC20Capped: cap is 0");\n', '        _cap = cap_;\n', '    }\n', '\n', '    /**\n', "     * @dev Returns the cap on the token's total supply.\n", '     */\n', '    function cap() public view returns (uint256) {\n', '        return _cap;\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20-_beforeTokenTransfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - minted tokens must not cause the total supply to go over the cap.\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n', '        super._beforeTokenTransfer(from, to, amount);\n', '\n', '        if (from == address(0)) { // When minting tokens\n', '            require(totalSupply().add(amount) <= _cap, "ERC20Capped: cap exceeded");\n', '        }\n', '    }\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "../../GSN/ContextUpgradeable.sol";\n', 'import "./IERC20Upgradeable.sol";\n', 'import "../../math/SafeMathUpgradeable.sol";\n', 'import "../../proxy/Initializable.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable {\n', '    using SafeMathUpgradeable for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '     * a default value of 18.\n', '     *\n', '     * To select a different value for {decimals}, use {_setupDecimals}.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n', '        __Context_init_unchained();\n', '        __ERC20_init_unchained(name_, symbol_);\n', '    }\n', '\n', '    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '        _decimals = 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '    uint256[44] private __gap;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20Upgradeable {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "../GSN/ContextUpgradeable.sol";\n', 'import "../proxy/Initializable.sol";\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'abstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state.\n', '     */\n', '    function __Pausable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Pausable_init_unchained();\n', '    }\n', '\n', '    function __Pausable_init_unchained() internal initializer {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '    uint256[49] private __gap;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n', ' * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n', ' * be specified by overriding the virtual {_implementation} function.\n', ' * \n', ' * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n', ' * different contract through the {_delegate} function.\n', ' * \n', ' * The success and return data of the delegated call will be returned back to the caller of the proxy.\n', ' */\n', 'abstract contract Proxy {\n', '    /**\n', '     * @dev Delegates the current call to `implementation`.\n', '     * \n', '     * This function does not return to its internall call site, it will return directly to the external caller.\n', '     */\n', '    function _delegate(address implementation) internal {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            // Copy msg.data. We take full control of memory in this inline assembly\n', '            // block because it will not return to Solidity code. We overwrite the\n', '            // Solidity scratch pad at memory position 0.\n', '            calldatacopy(0, 0, calldatasize())\n', '\n', '            // Call the implementation.\n', "            // out and outsize are 0 because we don't know the size yet.\n", '            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n', '\n', '            // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize())\n', '\n', '            switch result\n', '            // delegatecall returns 0 on error.\n', '            case 0 { revert(0, returndatasize()) }\n', '            default { return(0, returndatasize()) }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n', '     * and {_fallback} should delegate.\n', '     */\n', '    function _implementation() internal virtual view returns (address);\n', '\n', '    /**\n', '     * @dev Delegates the current call to the address returned by `_implementation()`.\n', '     * \n', '     * This function does not return to its internall call site, it will return directly to the external caller.\n', '     */\n', '    function _fallback() internal {\n', '        _beforeFallback();\n', '        _delegate(_implementation());\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n', '     * function in the contract matches the call data.\n', '     */\n', '    fallback () external payable {\n', '        _fallback();\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n', '     * is empty.\n', '     */\n', '    receive () external payable {\n', '        _fallback();\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n', '     * call, or as part of the Solidity `fallback` or `receive` functions.\n', '     * \n', '     * If overriden should call `super._beforeFallback()`.\n', '     */\n', '    function _beforeFallback() internal virtual {\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./UpgradeableProxy.sol";\n', '\n', '/**\n', ' * @dev This contract implements a proxy that is upgradeable by an admin.\n', ' * \n', ' * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n', ' * clashing], which can potentially be used in an attack, this contract uses the\n', ' * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n', ' * things that go hand in hand:\n', ' * \n', ' * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n', ' * that call matches one of the admin functions exposed by the proxy itself.\n', ' * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n', ' * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n', ' * "admin cannot fallback to proxy target".\n', ' * \n', ' * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n', " * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n", ' * to sudden errors when trying to call a function from the proxy implementation.\n', ' * \n', ' * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n', ' * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n', ' */\n', 'contract TransparentUpgradeableProxy is UpgradeableProxy {\n', '    /**\n', '     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n', '     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.\n', '     */\n', '    constructor(address _logic, address admin_, bytes memory _data) public payable UpgradeableProxy(_logic, _data) {\n', '        assert(_ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));\n', '        _setAdmin(admin_);\n', '    }\n', '\n', '    /**\n', '     * @dev Emitted when the admin account has changed.\n', '     */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev Storage slot with the admin of the contract.\n', '     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n', '\n', '    /**\n', '     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n', '     */\n', '    modifier ifAdmin() {\n', '        if (msg.sender == _admin()) {\n', '            _;\n', '        } else {\n', '            _fallback();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current admin.\n', '     * \n', '     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n', '     * \n', '     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n', '     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n', '     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n', '     */\n', '    function admin() external ifAdmin returns (address admin_) {\n', '        admin_ = _admin();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current implementation.\n', '     * \n', '     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n', '     * \n', '     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n', '     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n', '     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n', '     */\n', '    function implementation() external ifAdmin returns (address implementation_) {\n', '        implementation_ = _implementation();\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of the proxy.\n', '     * \n', '     * Emits an {AdminChanged} event.\n', '     * \n', '     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n', '     */\n', '    function changeAdmin(address newAdmin) external ifAdmin {\n', '        require(newAdmin != address(0), "TransparentUpgradeableProxy: new admin is the zero address");\n', '        emit AdminChanged(_admin(), newAdmin);\n', '        _setAdmin(newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrade the implementation of the proxy.\n', '     * \n', '     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n', '     */\n', '    function upgradeTo(address newImplementation) external ifAdmin {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n', '     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n', '     * proxied contract.\n', '     * \n', '     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n', '     */\n', '    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n', '        _upgradeTo(newImplementation);\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success,) = newImplementation.delegatecall(data);\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the current admin.\n', '     */\n', '    function _admin() internal view returns (address adm) {\n', '        bytes32 slot = _ADMIN_SLOT;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            adm := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new address in the EIP1967 admin slot.\n', '     */\n', '    function _setAdmin(address newAdmin) private {\n', '        bytes32 slot = _ADMIN_SLOT;\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            sstore(slot, newAdmin)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n', '     */\n', '    function _beforeFallback() internal override virtual {\n', '        require(msg.sender != _admin(), "TransparentUpgradeableProxy: admin cannot fallback to proxy target");\n', '        super._beforeFallback();\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./Proxy.sol";\n', 'import "../utils/Address.sol";\n', '\n', '/**\n', ' * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n', ' * implementation address that can be changed. This address is stored in storage in the location specified by\n', " * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n", ' * implementation behind the proxy.\n', ' * \n', ' * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n', ' * {TransparentUpgradeableProxy}.\n', ' */\n', 'contract UpgradeableProxy is Proxy {\n', '    /**\n', '     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n', '     * \n', "     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n", '     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n', '     */\n', '    constructor(address _logic, bytes memory _data) public payable {\n', '        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));\n', '        _setImplementation(_logic);\n', '        if(_data.length > 0) {\n', '            // solhint-disable-next-line avoid-low-level-calls\n', '            (bool success,) = _logic.delegatecall(_data);\n', '            require(success);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    /**\n', '     * @dev Returns the current implementation address.\n', '     */\n', '    function _implementation() internal override view returns (address impl) {\n', '        bytes32 slot = _IMPLEMENTATION_SLOT;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Upgrades the proxy to a new implementation.\n', '     * \n', '     * Emits an {Upgraded} event.\n', '     */\n', '    function _upgradeTo(address newImplementation) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new address in the EIP1967 implementation slot.\n', '     */\n', '    function _setImplementation(address newImplementation) private {\n', '        require(Address.isContract(newImplementation), "UpgradeableProxy: new implementation is not a contract");\n', '\n', '        bytes32 slot = _IMPLEMENTATION_SLOT;\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            sstore(slot, newImplementation)\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": false,\n', '    "runs": 200\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']