['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-03\n', '*/\n', '\n', '//Audit report available at https://www.tkd-coop.com/files/audit.pdf\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', 'abstract contract ITACData {\n', '    function transfer(address recipient, uint256 amount) public virtual returns (bool) ;\n', '}\n', '\n', ' //Control who can access various functions.\n', 'contract AccessControl {\n', '    address payable public creatorAddress;\n', '    uint16 public totalDirectors = 0;\n', '    mapping (address => bool) public directors;\n', '\n', '   modifier onlyCREATOR() {\n', '        require(msg.sender == creatorAddress, "You are not the creator of the contract.");\n', '        _;\n', '    }\n', '\n', '   // Constructor\n', '    constructor()  {\n', '        creatorAddress = 0x813dd04A76A716634968822f4D30Dfe359641194;\n', '    }\n', '}\n', '\n', '//Interface to TAC Contract\n', 'abstract contract ITAC {\n', '     function awardTAC(address winner, address loser, address referee) public virtual;\n', '     function transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);\n', '     function balanceOf(address account) external virtual view returns (uint256);\n', '}\n', '\n', 'contract TACLockup is AccessControl  {\n', '\n', '     /////////////////////////////////////////////////DATA STRUCTURES AND GLOBAL VARIABLES ///////////////////////////////////////////////////////////////////////\n', '\n', '    // Lockup duration in seconds for each time period\n', '    uint64 public lockupDuration = 604800;\n', '\n', '    // Hardcoded limits that cannot be changed by admin. \n', '    // Time is in seconds. \n', '    uint64 public minLockupDuration = 1;\n', '    uint64 public maxLockupDuration = 2592000;\n', '\n', '    // 100/removalFactor = % of TAC that can be removed each time.\n', '    uint64 public removalFactor = 10;\n', '\n', '    // minimum amount of a removal if they have that much balance\n', '    uint256 public minRemovalAmount = 5000000000000000000;\n', '\n', '    uint64 public minRemovalFactor = 1; //100% removal, no limit \n', '    uint64 public maxRemovalFactor = 100; //1% removal\n', '\n', '    mapping (address => uint256) public lockedTACForUser;\n', '    mapping (address => uint64) public lastRemovalTime;\n', '\n', '    address TACContract = address(0); //Will be changed by admin once TACContract is deployed.\n', '\n', '    //This function is separate from setParameters to lower the chance of accidental override. \n', '    function setTACAddress(address _TACContract) public onlyCREATOR {\n', '        TACContract = _TACContract;\n', '    }\n', '\n', '    //Admin function to adjust the lockup duration. Adjustments must stay within pre-defined limits. \n', '    function setParameters(uint64 _lockupDuration, uint64 _removalFactor, uint256 _minRemovalAmount) public onlyCREATOR {\n', '        if ((_lockupDuration <= maxLockupDuration) && (_lockupDuration >= minLockupDuration)) {\n', '        lockupDuration = _lockupDuration;\n', '        }\n', '\n', '        if ((_removalFactor <= maxRemovalFactor) && (_removalFactor >= minRemovalFactor)) {\n', '         removalFactor = _removalFactor;\n', '        }\n', '        minRemovalAmount = _minRemovalAmount;\n', '    }\n', '\n', '    //Returns current valued\n', '    function getValues() public view returns (uint64 _lockupDuration, uint64 _removalFactor) {\n', '        _lockupDuration = lockupDuration;\n', '        _removalFactor = removalFactor;\n', '    }\n', '\n', '    //Function called by the TAC contract to adjust the locked up balance of a user.\n', '    function adjustBalance(address user, uint256 amount) public  {\n', '        require(msg.sender == TACContract, "Only the TAC Contract can call this function");\n', '        lockedTACForUser[user] += amount;\n', '        //If the user has no balance, we need to set this as the current last removal time. \n', '        if (lastRemovalTime[user] == 0) {\n', '            lastRemovalTime[user] = uint64(block.timestamp);\n', '        }\n', '    }\n', '    //Function to lock your own TAC. \n', '    //Users must have previously approved this contract.\n', '    function lockMyTAC(uint256 amount) public {\n', '        ITAC TAC = ITAC(TACContract);\n', '        TAC.transferFrom(msg.sender, address(this), amount);\n', '        lockedTACForUser[msg.sender] += amount;\n', '        //If the user has no balance, we need to set this as the current last removal time. \n', '        if (lastRemovalTime[msg.sender] == 0) {\n', '            lastRemovalTime[msg.sender] = uint64(block.timestamp);\n', '        }\n', '    }\n', '\n', '    // Returns returns the amount of TAC a user has locked as well as the last removal time.\n', '    function getUserInfo(address user) public view returns (uint256 lockedAmount , uint64 time) {\n', '        lockedAmount = lockedTACForUser[user];\n', '        time = lastRemovalTime[user];\n', '    }\n', '\n', '    // Returns the amount of locked TAC a user has\n', '    function getTACLocked(address user) public view returns (uint256 lockedAmount) {\n', '          lockedAmount = lockedTACForUser[user];\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '// Function any user can call to receive their TAC allocation. \n', '    function claimTAC() public  {\n', '      require(lockedTACForUser[msg.sender] > 0, "You need to have received some TAC first");\n', '      require(block.timestamp > lastRemovalTime[msg.sender] + lockupDuration, "You need to wait a bit longer");\n', '      ITACData TAC = ITACData(TACContract);\n', '\n', '      //Calculate amount to transfer and adjust removal time\n', '      uint256 transferAmount = div(lockedTACForUser[msg.sender], removalFactor);\n', '      lastRemovalTime[msg.sender] = uint64(block.timestamp);\n', '      \n', '      //If they have enough balance but the transfer amount is small, transfer the min amount. \n', '      if ((transferAmount <= minRemovalAmount) && (lockedTACForUser[msg.sender] > minRemovalAmount)) {\n', '          transferAmount = minRemovalAmount;\n', '      }\n', '\n', '      //Transfer entire balance if min transfer amount is greater than their balance. \n', '      if (minRemovalAmount > lockedTACForUser[msg.sender]) {\n', '        transferAmount = lockedTACForUser[msg.sender];\n', '      }\n', "      //Decrement user's balance and transfer\n", '      lockedTACForUser[msg.sender] = lockedTACForUser[msg.sender] - transferAmount;\n', '      TAC.transfer(msg.sender, transferAmount);\n', '    }\n', '\n', '}']