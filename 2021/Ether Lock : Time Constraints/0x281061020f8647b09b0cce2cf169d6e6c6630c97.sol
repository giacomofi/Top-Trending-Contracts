['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./ECDSA.sol";\n', 'import "./Ownable.sol";\n', 'import "./Context.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Token.sol";\n', 'import "./VerifySignature.sol";\n', '\n', 'contract Rewards is Context, Ownable {\n', '  using SafeMath for uint256;\n', '  \n', '  struct RewardClaim {\n', '    /* Account Key & Signature */\n', '    address accountKey;\n', '    uint128 gameUuid;\n', '    uint256 oldBalance;\n', '    uint256 newBalance;\n', '    string signature;\n', '  }\n', '  \n', '  // Game UUID > Rewarded\n', '  mapping (uint128 => uint256) private _gameRewarded;\n', '  \n', '  // Account > Running Balance\n', '  mapping (address => uint256) private _balances;\n', '  \n', '  Token _rewardToken;\n', '  \n', '  // Total Reward Supply (All Games)\n', '  uint256 private _totalRewardSupply;\n', '  \n', '  // Total Rewarded (All Games)\n', '  uint256 private _totalRewarded;\n', '\n', '  /**\n', '   * Event for a Reward Claim\n', '   */\n', '  event RewardClaimed(address indexed receiver, address indexed account, uint256 value);\n', '\n', '  /**\n', '   * Event for a Reward Withdrawal\n', '   */\n', '  event RewardWithdrawn(address indexed receiver, uint256 value);\n', '\n', '  constructor(address rewardToken, uint256 totalSupply) {\n', '    _rewardToken = Token(rewardToken);\n', '    _totalRewardSupply = totalSupply;\n', '  }\n', '  \n', '  /**\n', '   * @dev Returns the contract owner.\n', '   */\n', '  function getOwner() external view returns (address) {\n', '    return owner();\n', '  }\n', '  \n', '  /**\n', '   * Claim Reward via Hash & Signature\n', '   */\n', '  function claimReward(RewardClaim[] memory rewardClaims) public returns (uint256) {\n', '    // Receiver of Reward Tokens\n', '    address receiver = _msgSender();\n', '    \n', '    // For transfer at the end\n', '    uint256 totalReward = 0;\n', '    \n', '    for (uint i=0; i<rewardClaims.length; i++) {\n', '        RewardClaim memory rewardClaim = rewardClaims[i];\n', '        \n', '        bool signatureVerified = VerifySignature.verify(\n', '            rewardClaim.accountKey,\n', '            receiver,\n', '            rewardClaim.gameUuid,\n', '            rewardClaim.oldBalance,\n', '            rewardClaim.newBalance,\n', '            rewardClaim.signature\n', '        );\n', '        \n', '        // New Balance must be Greater than the Old\n', '        require(\n', '            rewardClaim.newBalance > rewardClaim.oldBalance, \n', '            "Rewards: New Balance must be Greater than Old Balance"\n', '        );\n', '        \n', '        // Verify that the Signature Matches\n', '        require(\n', '            signatureVerified, \n', '            "Rewards: Signature Invalid"\n', '        );\n', '        \n', "        // Verify that the balance hasn't changed since the hash was generated.\n", '        require(\n', '            _balances[rewardClaim.accountKey] == rewardClaim.oldBalance, \n', '            "Rewards: Balance Changed Since Hash Generated"\n', '        );\n', '        \n', '        // Get Reward (newBalance - oldBalance)\n', '        uint256 reward = rewardClaim.newBalance.sub(rewardClaim.oldBalance);\n', '        \n', '        // Update Total Rewarded\n', '        _totalRewarded = _totalRewarded.add(reward);\n', '        \n', '        // Update Game Rewarded Total\n', '        _gameRewarded[rewardClaim.gameUuid] = _gameRewarded[rewardClaim.gameUuid].add(reward);\n', '        \n', '        // Add to Historical Balances\n', '        _balances[rewardClaim.accountKey] = _balances[rewardClaim.accountKey].add(reward);\n', '        \n', '        // Verify that the new Balance is in expected state \n', '        require(\n', '            _balances[rewardClaim.accountKey] == rewardClaim.newBalance, \n', '            "Rewards: New Balance is not in Expected State"\n', '        );\n', '        \n', '        // Add to Total Reward (for Transfer at the end)\n', '        totalReward = totalReward.add(reward);\n', '    \n', '        // Emit Success Claimed (for Account & Receiver)\n', '        emit RewardClaimed(receiver, rewardClaim.accountKey, reward);\n', '    }\n', '        \n', '    // Emit Success (for Receiver)\n', '    emit RewardWithdrawn(receiver, totalReward);\n', '    \n', '    _rewardToken.transfer(receiver, totalReward);\n', '    \n', '    return totalReward;\n', '  }\n', '  \n', '  /**\n', '   * Total Rewards Claimed by Account\n', '   */\n', '  function accountBalance(address accountKey) external view returns (uint256) {\n', '    return _balances[accountKey];\n', '  }\n', '  \n', '  /**\n', '   * Retrieve Game Rewarded Supply\n', '   */\n', '  function gameRewardedSupply(uint128 gameUuid) external view returns (uint256) {\n', '    return _gameRewarded[gameUuid];\n', '  }\n', '  \n', '  /**\n', '   * Retrieve Total Token Reward Supply\n', '   */\n', '  function totalRewardSupply() external view returns (uint256) {\n', '    return _totalRewardSupply;\n', '  }\n', '  \n', '  /**\n', '   * Retrieve Total Tokens Rewarded\n', '   */\n', '  function totalRewarded() external view returns (uint256) {\n', '    return _totalRewarded;\n', '  }\n', '  \n', '  /**\n', '   * Retrieve Total Game Remaining Supply\n', '   */\n', '  function totalRemainingSupply() external view returns (uint256) {\n', '    return _totalRewardSupply.sub(_totalRewarded);\n', '  }\n', '  \n', '  /*\n', '   * Return Tokens back to Owner (useful if a contract upgrade takes place)\n', '   */\n', '  function transferBackToOwner() public onlyOwner returns (uint256) {\n', '    address selfAddress = address(this);\n', '    uint256 balanceOfContract = _rewardToken.balanceOf(selfAddress);\n', '    _rewardToken.transfer(owner(), balanceOfContract);\n', '    return balanceOfContract;\n', '  }\n', '}']