['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-23\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketManagerInterface  {\n', '\tfunction setBreakerTable(address _target, bool _status) external returns (bool);\n', '\n', '\tfunction getCircuitBreaker() external view returns (bool);\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address, string memory);\n', '\n', '\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr) external returns (bool);\n', '\n', '\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256, uint256, uint256, uint256);\n', '\n', '\tfunction getTokenHandlerPrice(uint256 handlerID) external view returns (uint256);\n', '\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view returns (uint256);\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\n', '\n', '\tfunction getTokenHandlersLength() external view returns (uint256);\n', '\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) external returns (bool);\n', '\n', '\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\n', '\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view returns (uint256);\n', '\n', '\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserLimitIntraAsset(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\n', '\n', '\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view returns (uint256);\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\n', '\n', '\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view returns (uint256);\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) external returns (uint256);\n', '\n', '\tfunction setLiquidationManager(address liquidationManagerAddr) external returns (bool);\n', '\n', '\tfunction rewardClaimAll(address payable userAddr) external returns (bool);\n', '\n', '\tfunction updateRewardParams(address payable userAddr) external returns (bool);\n', '\tfunction interestUpdateReward() external returns (bool);\n', '\tfunction getGlobalRewardInfo() external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction setOracleProxy(address oracleProxyAddr) external returns (bool);\n', '\n', '\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external returns (bool);\n', '\tfunction ownerRewardTransfer(uint256 _amount) external returns (bool);\n', '}\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface managerDataStorageInterface  {\n', '\tfunction getGlobalRewardPerBlock() external view returns (uint256);\n', '\tfunction setGlobalRewardPerBlock(uint256 _globalRewardPerBlock) external returns (bool);\n', '\n', '\tfunction getGlobalRewardDecrement() external view returns (uint256);\n', '\tfunction setGlobalRewardDecrement(uint256 _globalRewardDecrement) external returns (bool);\n', '\n', '\tfunction getGlobalRewardTotalAmount() external view returns (uint256);\n', '\tfunction setGlobalRewardTotalAmount(uint256 _globalRewardTotalAmount) external returns (bool);\n', '\n', '\tfunction getAlphaRate() external view returns (uint256);\n', '\tfunction setAlphaRate(uint256 _alphaRate) external returns (bool);\n', '\n', '\tfunction getAlphaLastUpdated() external view returns (uint256);\n', '\tfunction setAlphaLastUpdated(uint256 _alphaLastUpdated) external returns (bool);\n', '\n', '\tfunction getRewardParamUpdateRewardPerBlock() external view returns (uint256);\n', '\tfunction setRewardParamUpdateRewardPerBlock(uint256 _rewardParamUpdateRewardPerBlock) external returns (bool);\n', '\n', '\tfunction getRewardParamUpdated() external view returns (uint256);\n', '\tfunction setRewardParamUpdated(uint256 _rewardParamUpdated) external returns (bool);\n', '\n', '\tfunction getInterestUpdateRewardPerblock() external view returns (uint256);\n', '\tfunction setInterestUpdateRewardPerblock(uint256 _interestUpdateRewardPerblock) external returns (bool);\n', '\n', '\tfunction getInterestRewardUpdated() external view returns (uint256);\n', '\tfunction setInterestRewardUpdated(uint256 _interestRewardLastUpdated) external returns (bool);\n', '\n', '\tfunction setTokenHandler(uint256 handlerID, address handlerAddr) external returns (bool);\n', '\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address);\n', '\n', '\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\n', '\n', '\tfunction getTokenHandlerAddr(uint256 handlerID) external view returns (address);\n', '\tfunction setTokenHandlerAddr(uint256 handlerID, address handlerAddr) external returns (bool);\n', '\n', '\tfunction getTokenHandlerExist(uint256 handlerID) external view returns (bool);\n', '\tfunction setTokenHandlerExist(uint256 handlerID, bool exist) external returns (bool);\n', '\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\n', '\tfunction setTokenHandlerSupport(uint256 handlerID, bool support) external returns (bool);\n', '\n', '\tfunction setLiquidationManagerAddr(address _liquidationManagerAddr) external returns (bool);\n', '\tfunction getLiquidationManagerAddr() external view returns (address);\n', '\n', '\tfunction setManagerAddr(address _managerAddr) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/marketHandlerInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface marketHandlerInterface  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\tfunction setCircuitBreakWithOwner(bool _emergency) external returns (bool);\n', '\n', '\tfunction getTokenName() external view returns (string memory);\n', '\n', '\tfunction ownershipTransfer(address payable newOwner) external returns (bool);\n', '\n', '\tfunction deposit(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\tfunction withdraw(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction borrow(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction repay(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) external returns (uint256);\n', '\n', '\tfunction getTokenHandlerLimit() external view returns (uint256, uint256);\n', '    function getTokenHandlerBorrowLimit() external view returns (uint256);\n', '\tfunction getTokenHandlerMarginCallLimit() external view returns (uint256);\n', '\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) external returns (bool);\n', '\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) external returns (bool);\n', '\n', '\tfunction getUserAmountWithInterest(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserMaxBorrowAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxRepayAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction checkFirstAction() external returns (bool);\n', '\tfunction applyInterest(address payable userAddr) external returns (uint256, uint256);\n', '\n', '\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable returns (bool);\n', '\tfunction reserveWithdraw(uint256 unifiedTokenAmount) external returns (bool);\n', '\n', '\tfunction getDepositTotalAmount() external view returns (uint256);\n', '\tfunction getBorrowTotalAmount() external view returns (uint256);\n', '\n', '\tfunction getSIRandBIR() external view returns (uint256, uint256);\n', '}\n', '\n', '// File: contracts/interfaces/oracleProxyInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface oracleProxyInterface  {\n', '\tfunction getTokenPrice(uint256 tokenID) external view returns (uint256);\n', '\n', '\tfunction getOracleFeed(uint256 tokenID) external view returns (address, uint256);\n', '\tfunction setOracleFeed(uint256 tokenID, address feedAddr, uint256 decimals) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/liquidationManagerInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface liquidationManagerInterface  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\tfunction partialLiquidation(address payable delinquentBorrower, uint256 targetHandler, uint256 liquidateAmount, uint256 receiveHandler) external returns (uint256);\n', '\tfunction checkLiquidation(address payable userAddr) external view returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/proxyContractInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface proxyContractInterface  {\n', '\tfunction handlerProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction handlerViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '\tfunction siProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction siViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '}\n', '\n', '// File: contracts/interfaces/tokenInterface.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external ;\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external view returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external ;\n', '}\n', '\n', '// File: contracts/Errors.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract Modifier {\n', '    string internal constant ONLY_OWNER = "O";\n', '    string internal constant ONLY_MANAGER = "M";\n', '    string internal constant CIRCUIT_BREAKER = "emergency";\n', '}\n', '\n', 'contract ManagerModifier is Modifier {\n', '    string internal constant ONLY_HANDLER = "H";\n', '    string internal constant ONLY_LIQUIDATION_MANAGER = "LM";\n', '    string internal constant ONLY_BREAKER = "B";\n', '}\n', '\n', 'contract HandlerDataStorageModifier is Modifier {\n', '    string internal constant ONLY_BIFI_CONTRACT = "BF";\n', '}\n', '\n', 'contract SIDataStorageModifier is Modifier {\n', '    string internal constant ONLY_SI_HANDLER = "SI";\n', '}\n', '\n', 'contract HandlerErrors is Modifier {\n', '    string internal constant USE_VAULE = "use value";\n', '    string internal constant USE_ARG = "use arg";\n', '    string internal constant EXCEED_LIMIT = "exceed limit";\n', '    string internal constant NO_LIQUIDATION = "no liquidation";\n', '    string internal constant NO_LIQUIDATION_REWARD = "no enough reward";\n', '    string internal constant NO_EFFECTIVE_BALANCE = "not enough balance";\n', '    string internal constant TRANSFER = "err transfer";\n', '}\n', '\n', 'contract SIErrors is Modifier { }\n', '\n', 'contract InterestErrors is Modifier { }\n', '\n', 'contract LiquidationManagerErrors is Modifier {\n', '    string internal constant NO_DELINQUENT = "not delinquent";\n', '}\n', '\n', 'contract ManagerErrors is ManagerModifier {\n', '    string internal constant REWARD_TRANSFER = "RT";\n', '    string internal constant UNSUPPORTED_TOKEN = "UT";\n', '}\n', '\n', 'contract OracleProxyErrors is Modifier {\n', '    string internal constant ZERO_PRICE = "price zero";\n', '}\n', '\n', 'contract RequestProxyErrors is Modifier { }\n', '\n', 'contract ManagerDataStorageErrors is ManagerModifier {\n', '    string internal constant NULL_ADDRESS = "err addr null";\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', '// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'library SafeMath {\n', '    uint256 internal constant unifiedPoint = 10 ** 18;\n', '\n', '\t/******************** Safe Math********************/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "a");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _sub(a, b, "s");\n', '\t}\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _mul(a, b);\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(a, b, "d");\n', '\t}\n', '\n', '\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b <= a, errorMessage);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a* b;\n', '\t\trequire((c / a) == b, "m");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b > 0, errorMessage);\n', '\t\treturn a / b;\n', '\t}\n', '\n', '\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, unifiedPoint), b, "d");\n', '\t}\n', '\n', '\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, b), unifiedPoint, "m");\n', '\t}\n', '}\n', '\n', '// File: contracts/marketManager/tokenManager.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title Bifi's marketManager contract\n", ' * @notice Implement business logic and manage handlers\n', ' * @author Bifi\n', ' */\n', 'contract etherManager is marketManagerInterface, ManagerErrors {\n', '\tusing SafeMath for uint256;\n', '\taddress public owner;\n', '\n', '\tbool public emergency = false;\n', '\n', '\tmanagerDataStorageInterface internal dataStorageInstance;\n', '\n', '\toracleProxyInterface internal oracleProxy;\n', '\n', '\t/* feat: manager reward token instance*/\n', '\tIERC20 internal rewardErc20Instance;\n', '\n', '\tstring internal constant updateRewardLane = "updateRewardLane(address)";\n', '\n', '\tmapping(address => Breaker) internal breakerTable;\n', '\n', '\tstruct UserAssetsInfo {\n', '\t\tuint256 depositAssetSum;\n', '\t\tuint256 borrowAssetSum;\n', '\t\tuint256 marginCallLimitSum;\n', '\t\tuint256 depositAssetBorrowLimitSum;\n', '\t\tuint256 depositAsset;\n', '\t\tuint256 borrowAsset;\n', '\t\tuint256 price;\n', '\t\tuint256 callerPrice;\n', '\t\tuint256 depositAmount;\n', '\t\tuint256 borrowAmount;\n', '\t\tuint256 borrowLimit;\n', '\t\tuint256 marginCallLimit;\n', '\t\tuint256 callerBorrowLimit;\n', '\t\tuint256 userBorrowableAsset;\n', '\t\tuint256 withdrawableAsset;\n', '\t}\n', '\n', '\tstruct Breaker {\n', '\t\tbool auth;\n', '\t\tbool tried;\n', '\t}\n', '\n', '\tstruct HandlerInfo {\n', '\t\tbool support;\n', '\t\taddress addr;\n', '\n', '\t\tproxyContractInterface tokenHandler;\n', '\t\tbytes data;\n', '\t}\n', '\n', '\tuint256 public tokenHandlerLength;\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner, ONLY_OWNER);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyHandler(uint256 handlerID) {\n', '\t\t_isHandler(handlerID);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isHandler(uint256 handlerID) internal view {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == dataStorageInstance.getTokenHandlerAddr(handlerID)) || (msgSender == owner), ONLY_HANDLER);\n', '\t}\n', '\n', '\tmodifier onlyLiquidationManager {\n', '\t\t_isLiquidationManager();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isLiquidationManager() internal view {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == dataStorageInstance.getLiquidationManagerAddr()) || (msgSender == owner), ONLY_LIQUIDATION_MANAGER);\n', '\t}\n', '\n', '\tmodifier circuitBreaker {\n', '\t\t_isCircuitBreak();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isCircuitBreak() internal view {\n', '\t\trequire((!emergency) || (msg.sender == owner), CIRCUIT_BREAKER);\n', '\t}\n', '\n', '\tmodifier onlyBreaker {\n', '\t\t_isBreaker();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isBreaker() internal view {\n', '\t\trequire(breakerTable[msg.sender].auth, ONLY_BREAKER);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Constructor for marketManager\n', '\t* @param managerDataStorageAddr The address of the manager storage contract\n', '\t* @param oracleProxyAddr The address of oracle proxy contract (e.g., price feeds)\n', '\t* @param breaker The address of default circuit breaker\n', '\t* @param erc20Addr The address of reward token (ERC-20)\n', '\t*/\n', '\tconstructor (address managerDataStorageAddr, address oracleProxyAddr, address breaker, address erc20Addr) public\n', '\t{\n', '\t\towner = msg.sender;\n', '\t\tdataStorageInstance = managerDataStorageInterface(managerDataStorageAddr);\n', '\t\toracleProxy = oracleProxyInterface(oracleProxyAddr);\n', '\t\trewardErc20Instance = IERC20(erc20Addr);\n', '\t\tbreakerTable[owner].auth = true;\n', '\t\tbreakerTable[breaker].auth = true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer ownership\n', '\t* @param _owner the address of the new owner\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction ownershipTransfer(address payable _owner) onlyOwner public returns (bool)\n', '\t{\n', '\t\towner = _owner;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the address of oracleProxy contract\n', '\t* @param oracleProxyAddr The address of oracleProxy contract\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setOracleProxy(address oracleProxyAddr) onlyOwner external override returns (bool)\n', '\t{\n', '\t\toracleProxy = oracleProxyInterface(oracleProxyAddr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the address of BiFi reward token contract\n', '\t* @param erc20Addr The address of BiFi reward token contract\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setRewardErc20(address erc20Addr) onlyOwner public returns (bool)\n', '\t{\n', '\t\trewardErc20Instance = IERC20(erc20Addr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Authorize admin user for circuitBreaker\n', '\t* @param _target The address of the circuitBreaker admin user.\n', '\t* @param _status The boolean status of circuitBreaker (on/off)\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setBreakerTable(address _target, bool _status) onlyOwner external override returns (bool)\n', '\t{\n', '\t\tbreakerTable[_target].auth = _status;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set circuitBreak to freeze/unfreeze all handlers\n', '\t* @param _emergency The boolean status of circuitBreaker (on/off)\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setCircuitBreaker(bool _emergency) onlyBreaker external override returns (bool)\n', '\t{\n', '\t\tbytes memory data;\n', '\n', '\t\tfor (uint256 handlerID = 0; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\taddress tokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(handlerID);\n', '\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(tokenHandlerAddr);\n', '\n', '\t\t\t// use delegate call via handler proxy\n', '\t\t\t// for token handlers\n', '\t\t\tbytes memory callData = abi.encodeWithSignature("setCircuitBreaker(bool)", _emergency);\n', '\n', '\t\t\ttokenHandler.handlerProxy(callData);\n', '\t\t\ttokenHandler.siProxy(callData);\n', '\t\t}\n', '\n', '\t\taddress liquidationManagerAddr = dataStorageInstance.getLiquidationManagerAddr();\n', '\t\tliquidationManagerInterface liquidationManager = liquidationManagerInterface(liquidationManagerAddr);\n', '\t\tliquidationManager.setCircuitBreaker(_emergency);\n', '\t\temergency = _emergency;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the circuitBreak status\n', '\t* @return The circuitBreak status\n', '\t*/\n', '\tfunction getCircuitBreaker() external view override returns (bool)\n', '\t{\n', '\t\treturn emergency;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get information for a handler\n', '\t* @param handlerID Handler ID\n', '\t* @return (success or failure, handler address, handler name)\n', '\t*/\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view override returns (bool, address, string memory)\n', '\t{\n', '\t\tbool support;\n', '\t\taddress tokenHandlerAddr;\n', '\t\tstring memory tokenName;\n', '\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\n', '\t\t{\n', '\t\t\ttokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(handlerID);\n', '\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(tokenHandlerAddr);\n', '\t\t\tbytes memory data;\n', '\t\t\t(, data) = tokenHandler.handlerViewProxy(abi.encodeWithSignature("getTokenName()"));\n', '\t\t\ttokenName = abi.decode(data, (string));\n', '\t\t\tsupport = true;\n', '\t\t}\n', '\n', '\t\treturn (support, tokenHandlerAddr, tokenName);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Register a handler\n', '\t* @param handlerID Handler ID and address\n', '\t* @param tokenHandlerAddr The handler address\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr) onlyOwner external override returns (bool)\n', '\t{\n', '\t\treturn _handlerRegister(handlerID, tokenHandlerAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set a liquidation manager contract\n', '\t* @param liquidationManagetAddr The address of liquidiation manager\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setLiquidationManager(address liquidationManagetAddr) onlyOwner external override returns (bool)\n', '\t{\n', '\t\tdataStorageInstance.setLiquidationManagerAddr(liquidationManagetAddr);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update the (SI) rewards for a user\n', '\t* @param userAddr The address of the user\n', '\t* @param callerID The handler ID\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external override returns (bool)\n', '\t{\n', '\t\tHandlerInfo memory handlerInfo;\n', '\t\t(handlerInfo.support, handlerInfo.addr) = dataStorageInstance.getTokenHandlerInfo(callerID);\n', '\t\tif (handlerInfo.support)\n', '\t\t{\n', '\t\t\tproxyContractInterface tokenHandler;\n', '\t\t\ttokenHandler = proxyContractInterface(handlerInfo.addr);\n', '\t\t\ttokenHandler.siProxy(abi.encodeWithSignature(updateRewardLane, userAddr));\n', '\t\t}\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update interest of a user for a handler (internal)\n', '\t* @param userAddr The user address\n', '\t* @param callerID The handler ID\n', '\t* @param allFlag Flag for the full calculation mode (calculting for all handlers)\n', '\t* @return (uint256, uint256, uint256, uint256, uint256, uint256)\n', '\t*/\n', '\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external override returns (uint256, uint256, uint256, uint256, uint256, uint256)\n', '\t{\n', '\t\tUserAssetsInfo memory userAssetsInfo;\n', '\t\tHandlerInfo memory handlerInfo;\n', '\t\toracleProxyInterface _oracleProxy = oracleProxy;\n', '\t\tmanagerDataStorageInterface _dataStorage = dataStorageInstance;\n', '\n', '\t\t/* From all handlers, get the token price, margin call limit, borrow limit */\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\t(handlerInfo.support, handlerInfo.addr) = _dataStorage.getTokenHandlerInfo(handlerID);\n', '\t\t\tif (handlerInfo.support)\n', '\t\t\t{\n', '\t\t\t\thandlerInfo.tokenHandler = proxyContractInterface(handlerInfo.addr);\n', '\n', '\t\t\t\t/* If the full-calculation mode is not set, work on the given handler only */\n', '\t\t\t\tif ((handlerID == callerID) || allFlag)\n', '\t\t\t\t{\n', '\t\t\t\t\thandlerInfo.tokenHandler.siProxy( abi.encodeWithSignature("updateRewardLane(address)", userAddr) );\n', '\t\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerProxy( abi.encodeWithSignature("applyInterest(address)", userAddr) );\n', '\n', '\t\t\t\t\t(userAssetsInfo.depositAmount, userAssetsInfo.borrowAmount) = abi.decode(handlerInfo.data, (uint256, uint256));\n', '\t\t\t\t}\n', '\t\t\t\telse\n', '\t\t\t\t{\n', '\t\t\t\t\t/* Get the deposit and borrow amount for the user */\n', '\t\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy( abi.encodeWithSignature("getUserAmount(address)", userAddr) );\n', '\t\t\t\t\t(userAssetsInfo.depositAmount, userAssetsInfo.borrowAmount) = abi.decode(handlerInfo.data, (uint256, uint256));\n', '\t\t\t\t}\n', '\n', '\t\t\t\t(, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy( abi.encodeWithSignature("getTokenHandlerLimit()") );\n', '\t\t\t\t(userAssetsInfo.borrowLimit, userAssetsInfo.marginCallLimit) = abi.decode(handlerInfo.data, (uint256, uint256));\n', '\n', '\t\t\t\t/* Get the token price */\n', '\t\t\t\tif (handlerID == callerID)\n', '\t\t\t\t{\n', '\t\t\t\t\tuserAssetsInfo.price = _oracleProxy.getTokenPrice(handlerID);\n', '\t\t\t\t\tuserAssetsInfo.callerPrice = userAssetsInfo.price;\n', '\t\t\t\t\tuserAssetsInfo.callerBorrowLimit = userAssetsInfo.borrowLimit;\n', '\t\t\t\t}\n', '\n', '\t\t\t\t/* If the user has no balance, the token handler can be ignored.*/\n', '\t\t\t\tif ((userAssetsInfo.depositAmount > 0) || (userAssetsInfo.borrowAmount > 0))\n', '\t\t\t\t{\n', '\t\t\t\t\tif (handlerID != callerID)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuserAssetsInfo.price = _oracleProxy.getTokenPrice(handlerID);\n', '\t\t\t\t\t}\n', '\n', '\t\t\t\t\t/* Compute the deposit parameters */\n', '\t\t\t\t\tif (userAssetsInfo.depositAmount > 0)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuserAssetsInfo.depositAsset = userAssetsInfo.depositAmount.unifiedMul(userAssetsInfo.price);\n', '\t\t\t\t\t\tuserAssetsInfo.depositAssetBorrowLimitSum = userAssetsInfo.depositAssetBorrowLimitSum.add(userAssetsInfo.depositAsset.unifiedMul(userAssetsInfo.borrowLimit));\n', '\t\t\t\t\t\tuserAssetsInfo.marginCallLimitSum = userAssetsInfo.marginCallLimitSum.add(userAssetsInfo.depositAsset.unifiedMul(userAssetsInfo.marginCallLimit));\n', '\t\t\t\t\t\tuserAssetsInfo.depositAssetSum = userAssetsInfo.depositAssetSum.add(userAssetsInfo.depositAsset);\n', '\t\t\t\t\t}\n', '\n', '\t\t\t\t\t/* Compute the borrow parameters */\n', '\t\t\t\t\tif (userAssetsInfo.borrowAmount > 0)\n', '\t\t\t\t\t{\n', '\t\t\t\t\t\tuserAssetsInfo.borrowAsset = userAssetsInfo.borrowAmount.unifiedMul(userAssetsInfo.price);\n', '\t\t\t\t\t\tuserAssetsInfo.borrowAssetSum = userAssetsInfo.borrowAssetSum.add(userAssetsInfo.borrowAsset);\n', '\t\t\t\t\t}\n', '\n', '\t\t\t\t}\n', '\n', '\t\t\t}\n', '\n', '\t\t}\n', '\n', '\t\tif (userAssetsInfo.depositAssetBorrowLimitSum > userAssetsInfo.borrowAssetSum)\n', '\t\t{\n', '\t\t\t/* Set the amount that the user can borrow from the borrow limit and previous borrows. */\n', '\t\t\tuserAssetsInfo.userBorrowableAsset = userAssetsInfo.depositAssetBorrowLimitSum.sub(userAssetsInfo.borrowAssetSum);\n', '\n', '\t\t\t/* Set the allowed amount that the user can withdraw based on the user borrow */\n', '\t\t\tuserAssetsInfo.withdrawableAsset = userAssetsInfo.depositAssetBorrowLimitSum.sub(userAssetsInfo.borrowAssetSum).unifiedDiv(userAssetsInfo.callerBorrowLimit);\n', '\t\t}\n', '\n', '\t\t/* Return the calculated parameters */\n', '\t\treturn (userAssetsInfo.userBorrowableAsset.unifiedDiv(userAssetsInfo.callerPrice), userAssetsInfo.withdrawableAsset.unifiedDiv(userAssetsInfo.callerPrice), userAssetsInfo.marginCallLimitSum, userAssetsInfo.depositAssetSum, userAssetsInfo.borrowAssetSum, userAssetsInfo.callerPrice);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Reward the user (msg.sender) with the reward token after calculating interest.\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction interestUpdateReward() external override returns (bool)\n', '\t{\n', '\t\tuint256 thisBlock = block.number;\n', '\t\tuint256 interestRewardUpdated = dataStorageInstance.getInterestRewardUpdated();\n', '\t\tuint256 delta = thisBlock - interestRewardUpdated;\n', '\t\tif (delta == 0)\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\n', '\t\tdataStorageInstance.setInterestRewardUpdated(thisBlock);\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\t\tbytes memory data;\n', '\t\t\t(, data) = tokenHandler.handlerProxy(abi.encodeWithSignature("checkFirstAction()"));\n', '\t\t}\n', '\n', '\t\tuint256 globalRewardPerBlock = dataStorageInstance.getInterestUpdateRewardPerblock();\n', '\t\tuint256 rewardAmount = delta.mul(globalRewardPerBlock);\n', '\n', '\t\t/* transfer reward tokens */\n', '\t\treturn _rewardTransfer(msg.sender, rewardAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev (Update operation) update the rewards parameters.\n', '\t* @param userAddr The address of operator\n', '\t* @return Whether or not the operation succeed\n', '\t*/\n', '\tfunction updateRewardParams(address payable userAddr) external override returns (bool)\n', '\t{\n', '\t\tif (_determineRewardParams(userAddr))\n', '\t\t{\n', '\t\t\treturn _calcRewardParams(userAddr);\n', '\t\t}\n', '\n', '\t\treturn false;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Claim all rewards for the user\n', '\t* @param userAddr The user address\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction rewardClaimAll(address payable userAddr) external override returns (bool)\n', '\t{\n', '\t\tuint256 handlerID;\n', '\t\tuint256 claimAmountSum;\n', '\t\tbytes memory data;\n', '\t\tfor (handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\t\t(, data) = tokenHandler.siProxy(abi.encodeWithSignature(updateRewardLane, userAddr));\n', '\n', '\t\t\t/* Claim reward for a token handler */\n', '\t\t\t(, data) = tokenHandler.siProxy(abi.encodeWithSignature("claimRewardAmountUser(address)", userAddr));\n', '\t\t\tclaimAmountSum = claimAmountSum.add(abi.decode(data, (uint256)));\n', '\t\t}\n', '\n', '\t\treturn _rewardTransfer(userAddr, claimAmountSum);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer reward tokens to owner (for administration)\n', '\t* @param _amount The amount of the reward token\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction ownerRewardTransfer(uint256 _amount) onlyOwner external override returns (bool)\n', '\t{\n', '\t\treturn _rewardTransfer(address(uint160(owner)), _amount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer reward tokens to a user\n', '\t* @param userAddr The address of recipient\n', '\t* @param _amount The amount of the reward token\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction _rewardTransfer(address payable userAddr, uint256 _amount) internal returns (bool)\n', '\t{\n', '\t\tuint256 beforeBalance = rewardErc20Instance.balanceOf(userAddr);\n', '\t\trewardErc20Instance.transfer(userAddr, _amount);\n', '\t\tuint256 afterBalance = rewardErc20Instance.balanceOf(userAddr);\n', '\t\trequire(_amount == afterBalance.sub(beforeBalance), REWARD_TRANSFER);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev (Update operation) update the rewards parameters (by using alpha- and\n', '\t  beta-score).\n', '\t* @param userAddr The address of the operator\n', '\t* @return Whether or not this process succeed\n', '\t*/\n', '\tfunction _determineRewardParams(address payable userAddr) internal returns (bool)\n', '\t{\n', '\t\tuint256 thisBlockNum = block.number;\n', '\t\tmanagerDataStorageInterface _dataStorageInstance = dataStorageInstance;\n', '\t\t/* The inactive period (delta) since the last action happens */\n', '\t\tuint256 delta = thisBlockNum - _dataStorageInstance.getRewardParamUpdated();\n', '\t\t_dataStorageInstance.setRewardParamUpdated(thisBlockNum);\n', '\t\tif (delta == 0)\n', '\t\t{\n', '\t\t\treturn false;\n', '\t\t}\n', '\n', '\t\t/* Rewards assigned for a block */\n', '\t\tuint256 globalRewardPerBlock = _dataStorageInstance.getGlobalRewardPerBlock();\n', '\t\t/* Rewards decrement for a block. (Rewards per block monotonically decreases) */\n', '\t\tuint256 globalRewardDecrement = _dataStorageInstance.getGlobalRewardDecrement();\n', '\t\t/* Total amount of rewards */\n', '\t\tuint256 globalRewardTotalAmount = _dataStorageInstance.getGlobalRewardTotalAmount();\n', '\n', '\t\t/* Remaining periods for reward distribution */\n', '\t\tuint256 remainingPeriod = globalRewardPerBlock.unifiedDiv(globalRewardDecrement);\n', '\n', '\t\tif (remainingPeriod >= delta.mul(SafeMath.unifiedPoint))\n', '\t\t{\n', '\t\t\tremainingPeriod = remainingPeriod.sub(delta.mul(SafeMath.unifiedPoint));\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn _epilogueOfDetermineRewardParams(_dataStorageInstance, userAddr, delta, 0, globalRewardDecrement, 0);\n', '\t\t}\n', '\n', '\t\tif (globalRewardTotalAmount >= globalRewardPerBlock.mul(delta))\n', '\t\t{\n', '\t\t\tglobalRewardTotalAmount = globalRewardTotalAmount - globalRewardPerBlock.mul(delta);\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn _epilogueOfDetermineRewardParams(_dataStorageInstance, userAddr, delta, 0, globalRewardDecrement, 0);\n', '\t\t}\n', '\n', '\t\tglobalRewardPerBlock = globalRewardTotalAmount.mul(2).unifiedDiv(remainingPeriod.add(SafeMath.unifiedPoint));\n', '\t\t/* To incentivze the update operation, the operator get paid with the\n', '\t\treward token */\n', '\t\treturn _epilogueOfDetermineRewardParams(_dataStorageInstance, userAddr, delta, globalRewardPerBlock, globalRewardDecrement, globalRewardTotalAmount);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Epilogue of _determineRewardParams for code-size savings\n', '\t* @param _dataStorageInstance interface of Manager Data Storage\n', '\t* @param userAddr User Address for Reward token transfer\n', '\t* @param _delta The inactive period (delta) since the last action happens\n', '\t* @param _globalRewardPerBlock Reward per block\n', '\t* @param _globalRewardDecrement Rewards decrement for a block\n', '\t* @param _globalRewardTotalAmount Total amount of rewards\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction _epilogueOfDetermineRewardParams(\n', '\t\tmanagerDataStorageInterface _dataStorageInstance,\n', '\t\taddress payable userAddr,\n', '\t\tuint256 _delta,\n', '\t\tuint256 _globalRewardPerBlock,\n', '\t\tuint256 _globalRewardDecrement,\n', '\t\tuint256 _globalRewardTotalAmount\n', '\t) internal returns (bool) {\n', '\t\t_updateDeterminedRewardModelParam(_globalRewardPerBlock, _globalRewardDecrement, _globalRewardTotalAmount);\n', '\t\tuint256 rewardAmount = _delta.mul(_dataStorageInstance.getRewardParamUpdateRewardPerBlock());\n', '\t\t/* To incentivze the update operation, the operator get paid with the\n', '\t\treward token */\n', '\t\t_rewardTransfer(userAddr, rewardAmount);\n', '\t\treturn true;\n', '\t}\n', '\t/**\n', '\t* @dev Set the reward model parameters\n', '\t* @param _rewardPerBlock Reward per block\n', '\t* @param _dcrement Rewards decrement for a block\n', '\t* @param _total Total amount of rewards\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction _updateDeterminedRewardModelParam(uint256 _rewardPerBlock, uint256 _dcrement, uint256 _total) internal returns (bool)\n', '\t{\n', '\t\tdataStorageInstance.setGlobalRewardPerBlock(_rewardPerBlock);\n', '\t\tdataStorageInstance.setGlobalRewardDecrement(_dcrement);\n', '\t\tdataStorageInstance.setGlobalRewardTotalAmount(_total);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update rewards paramters of token handlers.\n', '\t* @param userAddr The address of operator\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction _calcRewardParams(address payable userAddr) internal returns (bool)\n', '\t{\n', '\t\tuint256 handlerLength = tokenHandlerLength;\n', '\t\tbytes memory data;\n', '\t\tuint256[] memory handlerAlphaRateBaseAsset = new uint256[](handlerLength);\n', '\t\tuint256 handlerID;\n', '\t\tuint256 alphaRateBaseGlobalAssetSum;\n', '\t\tfor (handlerID; handlerID < handlerLength; handlerID++)\n', '\t\t{\n', '\t\t\thandlerAlphaRateBaseAsset[handlerID] = _getAlphaBaseAsset(handlerID);\n', '\t\t\talphaRateBaseGlobalAssetSum = alphaRateBaseGlobalAssetSum.add(handlerAlphaRateBaseAsset[handlerID]);\n', '\t\t}\n', '\n', '\t\thandlerID = 0;\n', '\t\tfor (handlerID; handlerID < handlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\t\t(, data) = tokenHandler.siProxy(abi.encodeWithSignature(updateRewardLane, userAddr));\n', '\n', '\t\t\t/* Update reward parameter for the token handler */\n', '\t\t\tdata = abi.encodeWithSignature("updateRewardPerBlockLogic(uint256)",\n', '\t\t\t\t\t\t\tdataStorageInstance.getGlobalRewardPerBlock()\n', '\t\t\t\t\t\t\t.unifiedMul(\n', '\t\t\t\t\t\t\t\thandlerAlphaRateBaseAsset[handlerID]\n', '\t\t\t\t\t\t\t\t.unifiedDiv(alphaRateBaseGlobalAssetSum)\n', '\t\t\t\t\t\t\t\t)\n', '\t\t\t\t\t\t\t);\n', '\t\t\t(, data) = tokenHandler.siProxy(data);\n', '\t\t}\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculate the alpha-score for the handler (in USD price)\n', '\t* @param _handlerID The handler ID\n', '\t* @return The alpha-score of the handler\n', '\t*/\n', '\tfunction _getAlphaBaseAsset(uint256 _handlerID) internal view returns (uint256)\n', '\t{\n', '\t\tbytes memory data;\n', '\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(_handlerID));\n', '\t\t(, data) = tokenHandler.handlerViewProxy(abi.encodeWithSignature("getDepositTotalAmount()"));\n', '\t\tuint256 _depositAmount = abi.decode(data, (uint256));\n', '\n', '\t\t(, data) = tokenHandler.handlerViewProxy(abi.encodeWithSignature("getBorrowTotalAmount()"));\n', '\t\tuint256 _borrowAmount = abi.decode(data, (uint256));\n', '\n', '\t\tuint256 _alpha = dataStorageInstance.getAlphaRate();\n', '\t\tuint256 _price = _getTokenHandlerPrice(_handlerID);\n', '\t\treturn _calcAlphaBaseAmount(_alpha, _depositAmount, _borrowAmount).unifiedMul(_price);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Calculate the alpha-score for the handler (in token amount)\n', '\t* @param _alpha The alpha parameter\n', '\t* @param _depositAmount The total amount of deposit\n', '\t* @param _borrowAmount The total amount of borrow\n', '\t* @return The alpha-score of the handler (in token amount)\n', '\t*/\n', '\tfunction _calcAlphaBaseAmount(uint256 _alpha, uint256 _depositAmount, uint256 _borrowAmount) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _depositAmount.unifiedMul(_alpha).add(_borrowAmount.unifiedMul(SafeMath.unifiedPoint.sub(_alpha)));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the token price of the handler\n', '\t* @param handlerID The handler ID\n', '\t* @return The token price of the handler\n', '\t*/\n', '\tfunction getTokenHandlerPrice(uint256 handlerID) external view override returns (uint256)\n', '\t{\n', '\t\treturn _getTokenHandlerPrice(handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the margin call limit of the handler (external)\n', '\t* @param handlerID The handler ID\n', '\t* @return The margin call limit\n', '\t*/\n', '\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view override returns (uint256)\n', '\t{\n', '\t\treturn _getTokenHandlerMarginCallLimit(handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the margin call limit of the handler (internal)\n', '\t* @param handlerID The handler ID\n', '\t* @return The margin call limit\n', '\t*/\n', '\tfunction _getTokenHandlerMarginCallLimit(uint256 handlerID) internal view returns (uint256)\n', '\t{\n', '\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\tbytes memory data;\n', '\t\t(, data) = tokenHandler.handlerViewProxy(abi.encodeWithSignature("getTokenHandlerMarginCallLimit()"));\n', '\t\treturn abi.decode(data, (uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the borrow limit of the handler (external)\n', '\t* @param handlerID The handler ID\n', '\t* @return The borrow limit\n', '\t*/\n', '\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view override returns (uint256)\n', '\t{\n', '\t\treturn _getTokenHandlerBorrowLimit(handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the borrow limit of the handler (internal)\n', '\t* @param handlerID The handler ID\n', '\t* @return The borrow limit\n', '\t*/\n', '\tfunction _getTokenHandlerBorrowLimit(uint256 handlerID) internal view returns (uint256)\n', '\t{\n', '\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\n', '\t\tbytes memory data;\n', '\t\t(, data) = tokenHandler.handlerViewProxy(abi.encodeWithSignature("getTokenHandlerBorrowLimit()"));\n', '\t\treturn abi.decode(data, (uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the handler status of whether the handler is supported or not.\n', '\t* @param handlerID The handler ID\n', '\t* @return Whether the handler is supported or not\n', '\t*/\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view override returns (bool)\n', '\t{\n', '\t\treturn dataStorageInstance.getTokenHandlerSupport(handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the length of the handler list\n', '\t* @param _tokenHandlerLength The length of the handler list\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) onlyOwner external override returns (bool)\n', '\t{\n', '\t\ttokenHandlerLength = _tokenHandlerLength;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the length of the handler list\n', '\t* @return the length of the handler list\n', '\t*/\n', '\tfunction getTokenHandlersLength() external view override returns (uint256)\n', '\t{\n', '\t\treturn tokenHandlerLength;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the handler ID at the index in the handler list\n', '\t* @param index The index of the handler list (array)\n', '\t* @return The handler ID\n', '\t*/\n', '\tfunction getTokenHandlerID(uint256 index) external view override returns (uint256)\n', '\t{\n', '\t\treturn dataStorageInstance.getTokenHandlerID(index);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the amount of token that the user can borrow more\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The amount of token that user can borrow more\n', '\t*/\n', '\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view override returns (uint256)\n', '\t{\n', '\t\tuint256 depositCredit;\n', '\t\tuint256 borrowCredit;\n', '\t\t(depositCredit, borrowCredit) = _getUserTotalIntraCreditAsset(userAddr);\n', '\t\tif (depositCredit == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tif (depositCredit > borrowCredit)\n', '\t\t{\n', '\t\t\treturn depositCredit.sub(borrowCredit).unifiedDiv(_getTokenHandlerPrice(handlerID));\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the deposit and borrow amount of the user with interest added\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The deposit and borrow amount of the user with interest\n', '\t*/\n', '\t/* about user market Information function*/\n', '\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view override returns (uint256, uint256)\n', '\t{\n', '\t\treturn _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the depositTotalCredit and borrowTotalCredit\n', '\t* @param userAddr The address of the user\n', '\t* @return depositTotalCredit The amount that users can borrow (i.e. deposit * borrowLimit)\n', '\t* @return borrowTotalCredit The sum of borrow amount for all handlers\n', '\t*/\n', '\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view override returns (uint256, uint256)\n', '\t{\n', '\t\treturn _getUserTotalIntraCreditAsset(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the borrow and margin call limits of the user for all handlers\n', '\t* @param userAddr The address of the user\n', '\t* @return userTotalBorrowLimitAsset the sum of borrow limit for all handlers\n', '\t* @return userTotalMarginCallLimitAsset the sume of margin call limit for handlers\n', '\t*/\n', '\tfunction getUserLimitIntraAsset(address payable userAddr) external view override returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 userTotalBorrowLimitAsset;\n', '\t\tuint256 userTotalMarginCallLimitAsset;\n', '\t\t(userTotalBorrowLimitAsset, userTotalMarginCallLimitAsset) = _getUserLimitIntraAsset(userAddr);\n', '\t\treturn (userTotalBorrowLimitAsset, userTotalMarginCallLimitAsset);\n', '\t}\n', '\n', '\n', '\t/**\n', '\t* @dev Get the maximum allowed amount to borrow of the user from the given handler\n', '\t* @param userAddr The address of the user\n', '\t* @param callerID The target handler to borrow\n', '\t* @return extraCollateralAmount The maximum allowed amount to borrow from\n', '\t  the handler.\n', '\t*/\n', '\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 callerID) external view override returns (uint256)\n', '\t{\n', '\t\tuint256 userTotalBorrowAsset;\n', '\t\tuint256 depositAssetBorrowLimitSum;\n', '\t\tuint256 depositHandlerAsset;\n', '\t\tuint256 borrowHandlerAsset;\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\n', '\t\t\t{\n', '\n', '\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\n', '\t\t\t\tuserTotalBorrowAsset = userTotalBorrowAsset.add(borrowHandlerAsset);\n', '\t\t\t\tdepositAssetBorrowLimitSum = depositAssetBorrowLimitSum\n', '\t\t\t\t\t\t\t\t\t\t\t\t.add(\n', '\t\t\t\t\t\t\t\t\t\t\t\t\tdepositHandlerAsset\n', '\t\t\t\t\t\t\t\t\t\t\t\t\t.unifiedMul( _getTokenHandlerBorrowLimit(handlerID) )\n', '\t\t\t\t\t\t\t\t\t\t\t\t);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tif (depositAssetBorrowLimitSum > userTotalBorrowAsset)\n', '\t\t{\n', '\t\t\treturn depositAssetBorrowLimitSum\n', '\t\t\t\t\t.sub(userTotalBorrowAsset)\n', '\t\t\t\t\t.unifiedDiv( _getTokenHandlerBorrowLimit(callerID) )\n', '\t\t\t\t\t.unifiedDiv( _getTokenHandlerPrice(callerID) );\n', '\t\t}\n', '\t\treturn 0;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Partial liquidation for a user\n', '\t* @param delinquentBorrower The address of the liquidation target\n', '\t* @param liquidateAmount The amount to liquidate\n', '\t* @param liquidator The address of the liquidator (liquidation operator)\n', '\t* @param liquidateHandlerID The hander ID of the liquidating asset\n', '\t* @param rewardHandlerID The handler ID of the reward token for the liquidator\n', '\t* @return (uint256, uint256, uint256)\n', '\t*/\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) onlyLiquidationManager external override returns (uint256, uint256, uint256)\n', '\t{\n', '\t\taddress tokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(liquidateHandlerID);\n', '\t\tproxyContractInterface tokenHandler = proxyContractInterface(tokenHandlerAddr);\n', '\t\tbytes memory data;\n', '\n', '\t\tdata = abi.encodeWithSignature("partialLiquidationUser(address,uint256,address,uint256)", delinquentBorrower, liquidateAmount, liquidator, rewardHandlerID);\n', '\t\t(, data) = tokenHandler.handlerProxy(data);\n', '\n', '\t\treturn abi.decode(data, (uint256, uint256, uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum liquidation reward by checking sufficient reward\n', '\t  amount for the liquidator.\n', '\t* @param delinquentBorrower The address of the liquidation target\n', '\t* @param liquidateHandlerID The hander ID of the liquidating asset\n', '\t* @param liquidateAmount The amount to liquidate\n', '\t* @param rewardHandlerID The handler ID of the reward token for the liquidator\n', '\t* @param rewardRatio delinquentBorrowAsset / delinquentDepositAsset\n', '\t* @return The maximum reward token amount for the liquidator\n', '\t*/\n', '\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view override returns (uint256)\n', '\t{\n', '\t\tuint256 liquidatePrice = _getTokenHandlerPrice(liquidateHandlerID);\n', '\t\tuint256 rewardPrice = _getTokenHandlerPrice(rewardHandlerID);\n', '\t\tuint256 delinquentBorrowerRewardDeposit;\n', '\t\t(delinquentBorrowerRewardDeposit, ) = _getHandlerAmount(delinquentBorrower, rewardHandlerID);\n', '\t\tuint256 rewardAsset = delinquentBorrowerRewardDeposit.unifiedMul(rewardPrice).unifiedMul(rewardRatio);\n', '\t\tif (liquidateAmount.unifiedMul(liquidatePrice) > rewardAsset)\n', '\t\t{\n', '\t\t\treturn rewardAsset.unifiedDiv(liquidatePrice);\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn liquidateAmount;\n', '\t\t}\n', '\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Reward the liquidator\n', '\t* @param delinquentBorrower The address of the liquidation target\n', '\t* @param rewardAmount The amount of reward token\n', '\t* @param liquidator The address of the liquidator (liquidation operator)\n', '\t* @param handlerID The handler ID of the reward token for the liquidator\n', '\t* @return The amount of reward token\n', '\t*/\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) onlyLiquidationManager external override returns (uint256)\n', '\t{\n', '\t\taddress tokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(handlerID);\n', '\t\tproxyContractInterface tokenHandler = proxyContractInterface(tokenHandlerAddr);\n', '\t\tbytes memory data;\n', '\t\tdata = abi.encodeWithSignature("partialLiquidationUserReward(address,uint256,address)", delinquentBorrower, rewardAmount, liquidator);\n', '\t\t(, data) = tokenHandler.handlerProxy(data);\n', '\n', '\t\treturn abi.decode(data, (uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the deposit and borrow amount of the user for the handler (internal)\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The deposit and borrow amount\n', '\t*/\n', '\tfunction _getHandlerAmount(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\tbytes memory data;\n', '\t\t(, data) = tokenHandler.handlerViewProxy(abi.encodeWithSignature("getUserAmount(address)", userAddr));\n', '\t\treturn abi.decode(data, (uint256, uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the support stauts for the handler\n', '\t* @param handlerID the handler ID\n', '\t* @param support the support status (boolean)\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setHandlerSupport(uint256 handlerID, bool support) onlyOwner public returns (bool)\n', '\t{\n', '\t\trequire(!dataStorageInstance.getTokenHandlerExist(handlerID), UNSUPPORTED_TOKEN);\n', '\t\t/* activate or inactivate anyway*/\n', '\t\tdataStorageInstance.setTokenHandlerSupport(handlerID, support);\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get owner's address of the manager contract\n", '\t* @return The address of owner\n', '\t*/\n', '\tfunction getOwner() public view returns (address)\n', '\t{\n', '\t\treturn owner;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Register a handler\n', '\t* @param handlerID The handler ID\n', '\t* @param handlerAddr The handler address\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction _handlerRegister(uint256 handlerID, address handlerAddr) internal returns (bool)\n', '\t{\n', '\t\tdataStorageInstance.setTokenHandler(handlerID, handlerAddr);\n', '\t\ttokenHandlerLength = tokenHandlerLength + 1;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the deposit and borrow amount of the user with interest added\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The deposit and borrow amount of the user with interest\n', '\t*/\n', '\tfunction _getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 price = _getTokenHandlerPrice(handlerID);\n', '\t\tproxyContractInterface tokenHandler = proxyContractInterface(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\tuint256 depositAmount;\n', '\t\tuint256 borrowAmount;\n', '\n', '\t\tbytes memory data;\n', '\t\t(, data) = tokenHandler.handlerViewProxy(abi.encodeWithSignature("getUserAmountWithInterest(address)", userAddr));\n', '\t\t(depositAmount, borrowAmount) = abi.decode(data, (uint256, uint256));\n', '\n', '\t\tuint256 depositAsset = depositAmount.unifiedMul(price);\n', '\t\tuint256 borrowAsset = borrowAmount.unifiedMul(price);\n', '\t\treturn (depositAsset, borrowAsset);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the borrow and margin call limits of the user for all handlers (internal)\n', '\t* @param userAddr The address of the user\n', '\t* @return userTotalBorrowLimitAsset the sum of borrow limit for all handlers\n', '\t* @return userTotalMarginCallLimitAsset the sume of margin call limit for handlers\n', '\t*/\n', '\tfunction _getUserLimitIntraAsset(address payable userAddr) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 userTotalBorrowLimitAsset;\n', '\t\tuint256 userTotalMarginCallLimitAsset;\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\n', '\t\t\t{\n', '\t\t\t\tuint256 depositHandlerAsset;\n', '\t\t\t\tuint256 borrowHandlerAsset;\n', '\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\n', '\t\t\t\tuint256 borrowLimit = _getTokenHandlerBorrowLimit(handlerID);\n', '\t\t\t\tuint256 marginCallLimit = _getTokenHandlerMarginCallLimit(handlerID);\n', '\t\t\t\tuint256 userBorrowLimitAsset = depositHandlerAsset.unifiedMul(borrowLimit);\n', '\t\t\t\tuint256 userMarginCallLimitAsset = depositHandlerAsset.unifiedMul(marginCallLimit);\n', '\t\t\t\tuserTotalBorrowLimitAsset = userTotalBorrowLimitAsset.add(userBorrowLimitAsset);\n', '\t\t\t\tuserTotalMarginCallLimitAsset = userTotalMarginCallLimitAsset.add(userMarginCallLimitAsset);\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\n', '\t\t}\n', '\n', '\t\treturn (userTotalBorrowLimitAsset, userTotalMarginCallLimitAsset);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the depositTotalCredit and borrowTotalCredit\n', '\t* @param userAddr The address of the user\n', '\t* @return depositTotalCredit The amount that users can borrow (i.e. deposit * borrowLimit)\n', '\t* @return borrowTotalCredit The sum of borrow amount for all handlers\n', '\t*/\n', '\tfunction _getUserTotalIntraCreditAsset(address payable userAddr) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 depositTotalCredit;\n', '\t\tuint256 borrowTotalCredit;\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\n', '\t\t\t{\n', '\t\t\t\tuint256 depositHandlerAsset;\n', '\t\t\t\tuint256 borrowHandlerAsset;\n', '\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\n', '\t\t\t\tuint256 borrowLimit = _getTokenHandlerBorrowLimit(handlerID);\n', '\t\t\t\tuint256 depositHandlerCredit = depositHandlerAsset.unifiedMul(borrowLimit);\n', '\t\t\t\tdepositTotalCredit = depositTotalCredit.add(depositHandlerCredit);\n', '\t\t\t\tborrowTotalCredit = borrowTotalCredit.add(borrowHandlerAsset);\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\n', '\t\t}\n', '\n', '\t\treturn (depositTotalCredit, borrowTotalCredit);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the token price for the handler\n', '\t* @param handlerID The handler id\n', '\t* @return The token price of the handler\n', '\t*/\n', '\tfunction _getTokenHandlerPrice(uint256 handlerID) internal view returns (uint256)\n', '\t{\n', '\t\treturn (oracleProxy.getTokenPrice(handlerID));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the address of reward token\n', '\t* @return The address of reward token\n', '\t*/\n', '\tfunction getRewardErc20() public view returns (address)\n', '\t{\n', '\t\treturn address(rewardErc20Instance);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the reward parameters\n', '\t* @return (uint256,uint256,uint256) rewardPerBlock, rewardDecrement, rewardTotalAmount\n', '\t*/\n', '\tfunction getGlobalRewardInfo() external view override returns (uint256, uint256, uint256)\n', '\t{\n', '\t\tmanagerDataStorageInterface _dataStorage = dataStorageInstance;\n', '\t\treturn (_dataStorage.getGlobalRewardPerBlock(), _dataStorage.getGlobalRewardDecrement(), _dataStorage.getGlobalRewardTotalAmount());\n', '\t}\n', '}']