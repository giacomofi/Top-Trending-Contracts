['// SPDX-License-Identifier: MIT\n', '/*\n', 'A simple gauge contract to measure the amount of tokens locked, and reward users in a different token.\n', 'Updated for MATIC Sushi LP Emission. Just overwrite constants for new distriution/chains.\n', '*/\n', '\n', 'pragma solidity ^0.6.11;\n', '\n', 'import "SafeERC20.sol"; // call ERC20 safely\n', 'import "SafeMath.sol";\n', 'import "Address.sol";\n', '\n', 'import "ReentrancyGuard.sol";\n', '\n', 'contract ETH_SVC001_Gauge is ReentrancyGuard {\n', '\tusing SafeERC20 for IERC20;\n', '\tusing Address for address;\n', '    using SafeMath for uint256;\n', '\n', '    address payable public governance = 0xdD7A75CC6c04031629f13848Bc0D07e89C3961Be; // STACK DAO Agent address\n', '    address public constant acceptToken = 0xa92E747Ba0fA6802db123a699eAEb4D1f6F8b80B; // SVC001/ETH Sushiswap LP Token\n', '\n', '    address public constant STACK = 0xe0955F26515d22E347B17669993FCeFcc73c3a0a; // STACK DAO Token\n', '\n', '    uint256 public emissionRate = 2100774135268846; // 50k STACK / delta blocks\n', '\n', '    uint256 public deposited;\n', '\n', '    uint256 public constant startBlock = 12505856;\n', '    \n', '    uint256 public endBlock = startBlock + 2380075;\n', '                                           \n', '\n', '    uint256 public lastBlock; // last block the distribution has ran\n', '    uint256 public tokensAccrued; // tokens to distribute per weight scaled by 1e18\n', '\n', '    struct DepositState {\n', '    \tuint256 balance;\n', '    \tuint256 tokensAccrued;\n', '    }\n', '\n', '    mapping(address => DepositState) public balances;\n', '\n', '    event Deposit(address indexed from, uint256 amount);\n', '    event Withdraw(address indexed to, uint256 amount);\n', '    event STACKClaimed(address indexed to, uint256 amount);\n', '\n', '    constructor() public {\n', '    }\n', '\n', '    function setGovernance(address payable _new) external {\n', '    \trequire(msg.sender == governance);\n', '    \tgovernance = _new;\n', '    }\n', '\n', '    function setEmissionRate(uint256 _new) external {\n', '    \trequire(msg.sender == governance, "LPGAUGE: !governance");\n', '    \t_kick(); // catch up the contract to the current block for old rate\n', '    \temissionRate = _new;\n', '    }\n', '\n', '    function setEndBlock(uint256 _block) external {\n', '    \trequire(msg.sender == governance, "LPGAUGE: !governance");\n', '    \trequire(block.number <= endBlock, "LPGAUGE: distribution already done, must start another");\n', '        require(block.number <= _block, "LPGAUGE: can\'t set endBlock to past block");\n', '    \t\n', '    \tendBlock = _block;\n', '    }\n', '\n', '    function deposit(uint256 _amount) nonReentrant external {\n', '    \trequire(block.number <= endBlock, "LPGAUGE: distribution over");\n', '\n', '    \t_claimSTACK(msg.sender);\n', '\n', '    \tIERC20(acceptToken).safeTransferFrom(msg.sender, address(this), _amount);\n', '\n', '    \tDepositState memory _state = balances[msg.sender];\n', '    \t_state.balance = _state.balance.add(_amount);\n', '    \tdeposited = deposited.add(_amount);\n', '\n', '    \temit Deposit(msg.sender, _amount);\n', '    \tbalances[msg.sender] = _state;\n', '    }\n', '\n', '    function withdraw(uint256 _amount) nonReentrant external {\n', '    \t_claimSTACK(msg.sender);\n', '\n', '    \tDepositState memory _state = balances[msg.sender];\n', '\n', '    \trequire(_amount <= _state.balance, "LPGAUGE: insufficient balance");\n', '\n', '    \t_state.balance = _state.balance.sub(_amount);\n', '    \tdeposited = deposited.sub(_amount);\n', '\n', '    \temit Withdraw(msg.sender, _amount);\n', '    \tbalances[msg.sender] = _state;\n', '\n', '    \tIERC20(acceptToken).safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    function claimSTACK() nonReentrant external returns (uint256) {\n', '    \treturn _claimSTACK(msg.sender);\n', '    }\n', '\n', '    function _claimSTACK(address _user) internal returns (uint256) {\n', '    \t_kick();\n', '\n', '    \tDepositState memory _state = balances[_user];\n', "    \tif (_state.tokensAccrued == tokensAccrued){ // user doesn't have any accrued tokens\n", '    \t\treturn 0;\n', '    \t}\n', '    \telse {\n', '    \t\tuint256 _tokensAccruedDiff = tokensAccrued.sub(_state.tokensAccrued);\n', '    \t\tuint256 _tokensGive = _tokensAccruedDiff.mul(_state.balance).div(1e18);\n', '\n', '    \t\t_state.tokensAccrued = tokensAccrued;\n', '    \t\tbalances[_user] = _state;\n', '\n', '            // if the guage has enough tokens to grant the user, then send their tokens\n', "            // otherwise, don't fail, just log STACK claimed, and a reimbursement can be done via chain events\n", '            if (IERC20(STACK).balanceOf(address(this)) >= _tokensGive){\n', '                IERC20(STACK).safeTransfer(_user, _tokensGive);\n', '            }\n', '\n', '            // log event\n', '            emit STACKClaimed(_user, _tokensGive);\n', '\n', '            return _tokensGive;\n', '    \t}\n', '    }\n', '\n', '    function _kick() internal {\n', '    \tuint256 _totalDeposited = deposited;\n', "    \t// if there are no tokens committed, then don't kick.\n", '    \tif (_totalDeposited == 0){\n', '    \t\treturn;\n', '    \t}\n', '    \t// already done for this block || already did all blocks || not started yet\n', '    \tif (lastBlock == block.number || lastBlock >= endBlock || block.number < startBlock){\n', '    \t\treturn;\n', '    \t}\n', '\n', '\t\tuint256 _deltaBlock;\n', '\t\t// edge case where kick was not called for entire period of blocks.\n', '\t\tif (lastBlock <= startBlock && block.number >= endBlock){\n', '\t\t\t_deltaBlock = endBlock.sub(startBlock);\n', '\t\t}\n', '\t\t// where block.number is past the endBlock\n', '\t\telse if (block.number >= endBlock){\n', '\t\t\t_deltaBlock = endBlock.sub(lastBlock);\n', '\t\t}\n', '\t\t// where last block is before start\n', '\t\telse if (lastBlock <= startBlock){\n', '\t\t\t_deltaBlock = block.number.sub(startBlock);\n', '\t\t}\n', '\t\t// normal case, where we are in the middle of the distribution\n', '\t\telse {\n', '\t\t\t_deltaBlock = block.number.sub(lastBlock);\n', '\t\t}\n', '\n', '\t\tuint256 _tokensToAccrue = _deltaBlock.mul(emissionRate);\n', '\t\ttokensAccrued = tokensAccrued.add(_tokensToAccrue.mul(1e18).div(_totalDeposited));\n', '\n', "    \t// if not allowed to mint it's just like the emission rate = 0. So just update the lastBlock.\n", '    \t// always update last block \n', '    \tlastBlock = block.number;\n', '    }\n', '\n', '    // decentralized rescue function for any stuck tokens, will return to governance\n', '    function rescue(address _token, uint256 _amount) nonReentrant external {\n', '        require(msg.sender == governance, "LPGAUGE: !governance");\n', '\n', '        if (_token != address(0)){\n', '            IERC20(_token).safeTransfer(governance, _amount);\n', '        }\n', '        else { // if _tokenContract is 0x0, then escape ETH\n', '            governance.transfer(_amount);\n', '        }\n', '    }\n', '}']