['// SPDX-License-Identifier: --GRISE--\n', '\n', 'pragma solidity =0.7.6;\n', '\n', 'import "./Utils.sol";\n', '\n', 'contract GriseToken is Utils {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    address public LIQUIDITY_GATEKEEPER;\n', '    address public STAKE_GATEKEEPER;\n', '    address public VAULT_GATEKEEPER;\n', '\n', '    address private liquidtyGateKeeper;\n', '    address private stakeGateKeeper;\n', '    address private vaultGateKeeper;\n', '\n', '    /**\n', '     * @dev initial private\n', '     */\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimal = 18;\n', '\n', '    /**\n', '     * @dev ðŸ‘» Initial supply \n', '     */\n', '    uint256 private _totalSupply = 0;\n', '\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 value\n', '    );\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '    constructor (string memory tokenName, string memory tokenSymbol) {\n', '        _name = tokenName;\n', '        _symbol = tokenSymbol;\n', '        liquidtyGateKeeper = _msgSender();\n', '        stakeGateKeeper = _msgSender();\n', '        vaultGateKeeper = _msgSender();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token.\n', '     */\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the decimals of the token.\n', '     */\n', '    function decimals() external view returns (uint8) {\n', '        return _decimal;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the total supply of the token.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the token balance of specific address.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(\n', '        address recipient,\n', '        uint256 amount\n', '    )\n', '        external\n', '        returns (bool)\n', '    {  \n', '        _transfer(\n', '            _msgSender(),\n', '            recipient,\n', '            amount\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns approved balance to be spent by another address\n', '     * by using transferFrom method\n', '     */\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '    )\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the token allowance to another spender\n', '     */\n', '    function approve(\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        external\n', '        returns (bool)\n', '    {\n', '        _approve(\n', '            _msgSender(),\n', '            spender,\n', '            amount\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows to transfer tokens on senders behalf\n', '     * based on allowance approved for the executer\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    )\n', '        external\n', '        returns (bool)\n', '    {    \n', '        _approve(sender,\n', '            _msgSender(), _allowances[sender][_msgSender()].sub(\n', '                amount\n', '            )\n', '        );\n', '\n', '        _transfer(\n', '            sender,\n', '            recipient,\n', '            amount\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        virtual\n', '    {\n', '        require(\n', '            sender != address(0x0)\n', '        );\n', '\n', '        require(\n', '            recipient != address(0x0)\n', '        );\n', '\n', '        uint256 stFee;\n', '        uint256 btFee;\n', '        uint256 teamReward;\n', '        uint256 currentGriseDay = _currentGriseDay();\n', '\n', '        if (staker[sender] == 0) {\n', '            stFee = _calculateSellTranscFee(amount);\n', '\n', '            sellTranscFee[currentGriseDay] = \n', '            sellTranscFee[currentGriseDay]\n', '                        .add(stFee);\n', '                \n', '            reservoirRewardPerShare[currentGriseDay] = \n', '            reservoirRewardPerShare[currentGriseDay]\n', '                        .add(stFee.mul(TRANSC_RESERVOIR_REWARD)\n', '                        .div(REWARD_PRECISION_RATE)\n', '                        .div(mediumTermShares));\n', '                \n', '            stakerRewardPerShare[currentGriseDay] = \n', '            stakerRewardPerShare[currentGriseDay]\n', '                        .add(stFee.mul(TRANSC_STAKER_REWARD)\n', '                        .div(REWARD_PRECISION_RATE)\n', '                        .div(mediumTermShares));\n', '                \n', '            tokenHolderReward[currentGriseDay] = \n', '            tokenHolderReward[currentGriseDay]\n', '                        .add(stFee.mul(TRANSC_TOKEN_HOLDER_REWARD)\n', '                        .div(REWARD_PRECISION_RATE));\n', '            \n', '            teamReward = stFee.mul(TEAM_SELL_TRANSC_REWARD)\n', '                              .div(REWARD_PRECISION_RATE);\n', '        }\n', '\n', '        btFee = _calculateBuyTranscFee(amount);\n', '        \n', '        _balances[sender] =\n', '        _balances[sender].sub(amount);\n', '\n', '        _balances[recipient] =\n', '        _balances[recipient].add(amount.sub(btFee).sub(stFee));\n', '\n', '        teamReward += btFee.mul(TEAM_BUY_TRANS_REWARD)\n', '                           .div(REWARD_PRECISION_RATE);\n', '        \n', '        _balances[TEAM_ADDRESS] = \n', '        _balances[TEAM_ADDRESS].add(teamReward.mul(90).div(100));\n', '\n', '        _balances[DEVELOPER_ADDRESS] = \n', '        _balances[DEVELOPER_ADDRESS].add(teamReward.mul(10).div(100));\n', '\n', '        // Burn Transction fee\n', '        // We will mint token when user comes\n', '        // to claim transction fee reward.\n', '        _totalSupply =\n', '        _totalSupply.sub(stFee.add(btFee).sub(teamReward));\n', '\n', '        totalToken[currentGriseDay] = totalSupply().add(stakedToken);\n', '        \n', '        emit Transfer(\n', '            sender,\n', '            recipient,\n', '            amount\n', '        );\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(\n', '        address account,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        virtual\n', '    {\n', '        require(\n', '            account != address(0x0)\n', '        );\n', '        \n', '        _totalSupply =\n', '        _totalSupply.add(amount);\n', '\n', '        _balances[account] =\n', '        _balances[account].add(amount);\n', '\n', '        totalToken[currentGriseDay()] = totalSupply().add(stakedToken);\n', '        \n', '        emit Transfer(\n', '            address(0x0),\n', '            account,\n', '            amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(\n', '        address account,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        virtual\n', '    {\n', '        require(\n', '            account != address(0x0)\n', '        );\n', '    \n', '        _balances[account] =\n', '        _balances[account].sub(amount);\n', '\n', '        _totalSupply =\n', '        _totalSupply.sub(amount);\n', '\n', '        totalToken[currentGriseDay()] = _totalSupply.add(stakedToken);\n', '        \n', '        emit Transfer(\n', '            account,\n', '            address(0x0),\n', '            amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount\n', '    )\n', '        internal\n', '        virtual\n', '    {\n', '        require(\n', '            owner != address(0x0)\n', '        );\n', '\n', '        require(\n', '            spender != address(0x0)\n', '        );\n', '\n', '        _allowances[owner][spender] = amount;\n', '\n', '        emit Approval(\n', '            owner,\n', '            spender,\n', '            amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice ability to define liquidity transformer contract\n', '     * @dev this method renounce liquidtyGateKeeper access\n', '     * @param _immutableGateKeeper contract address\n', '     */\n', '    function setLiquidtyGateKeeper(\n', '        address _immutableGateKeeper\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            liquidtyGateKeeper == _msgSender(),\n', "            'GRISE: Operation not allowed'\n", '        );\n', '\n', '        LIQUIDITY_GATEKEEPER = _immutableGateKeeper;\n', '        liquidtyGateKeeper = address(0x0);\n', '    }\n', '\n', '    /**\n', '     * @notice ability to define Staker contract\n', '     * @dev this method renounce stakeGateKeeper access\n', '     * @param _immutableGateKeeper contract address\n', '     */\n', '    function setStakeGateKeeper(\n', '        address _immutableGateKeeper\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            stakeGateKeeper == _msgSender(),\n', "            'GRISE: Operation not allowed'\n", '        );\n', '\n', '        STAKE_GATEKEEPER = _immutableGateKeeper;\n', '        stakeGateKeeper = address(0x0);\n', '    }\n', '\n', '    /**\n', '     * @notice ability to define vault contract\n', '     * @dev this method renounce vaultGateKeeper access\n', '     * @param _immutableGateKeeper contract address\n', '     */\n', '    function setVaultGateKeeper(\n', '        address _immutableGateKeeper\n', '    )\n', '        external\n', '    {\n', '        require(\n', '            vaultGateKeeper == _msgSender(),\n', "            'GRISE: Operation not allowed'\n", '        );\n', '\n', '        VAULT_GATEKEEPER = _immutableGateKeeper;\n', '        vaultGateKeeper = address(0x0);\n', '    }\n', '\n', '    modifier interfaceValidator() {\n', '        require (\n', '            _msgSender() == LIQUIDITY_GATEKEEPER ||\n', '            _msgSender() == STAKE_GATEKEEPER ||\n', '            _msgSender() == VAULT_GATEKEEPER,\n', "            'GRISE: Operation not allowed'\n", '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice allows interfaceValidator to mint supply\n', '     * @param _investorAddress address for minting GRISE tokens\n', '     * @param _amount of tokens to mint for _investorAddress\n', '     */\n', '    function mintSupply(\n', '        address _investorAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '        interfaceValidator\n', '    {       \n', '        _mint(\n', '            _investorAddress,\n', '            _amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice allows interfaceValidator to burn supply\n', '     * @param _investorAddress address for minting GRISE tokens\n', '     * @param _amount of tokens to mint for _investorAddress\n', '     */\n', '    function burnSupply(\n', '        address _investorAddress,\n', '        uint256 _amount\n', '    )\n', '        external\n', '        interfaceValidator\n', '    {\n', '        _burn(\n', '            _investorAddress,\n', '            _amount\n', '        );\n', '    }\n', '    \n', '    function viewTokenHolderTranscReward() \n', '        external \n', '        view \n', '        returns (uint256 rewardAmount) \n', '    {\n', '        \n', '        uint256 _day = currentGriseDay();\n', '        \n', '        if( (balanceOf(_msgSender()) <= 0) ||\n', '            isTranscFeeClaimed[_msgSender()][calculateGriseWeek(_day)] ||  \n', '            calculateGriseWeek(_day) != currentGriseWeek())\n', '        {\n', '            rewardAmount = 0;\n', '        }\n', '        else\n', '        {    \n', '            uint256 calculationDay = _day.mod(GRISE_WEEK) > 0 ? \n', '                                    _day.sub(_day.mod(GRISE_WEEK)) :\n', '                                    _day.sub(GRISE_WEEK);\n', '\n', '            for (uint256 day = calculationDay; day < _day; day++)\n', '            {\n', '                rewardAmount += tokenHolderReward[day]\n', '                                            .mul(_balances[_msgSender()])\n', '                                            .div(totalToken[day]);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function claimTokenHolderTranscReward()\n', '        external \n', '        returns (uint256 rewardAmount)\n', '    {    \n', '        uint256 _day = currentGriseDay();\n', '        require( \n', '            balanceOf(_msgSender()) > 0,\n', "            'GRISE - Token holder doesnot enough balance to claim reward'\n", '        );\n', '        \n', '        require(\n', '            (currentGriseDay().mod(GRISE_WEEK)) == 0,\n', "            'GRISE - Transcation Reward window is not yeat open'\n", '        );\n', '        \n', '        require(\n', '            calculateGriseWeek(_day) == currentGriseWeek(),\n', "            'GRISE - You are late/early to claim reward'\n", '        );\n', '        \n', '        require( \n', '            !isTranscFeeClaimed[_msgSender()][currentGriseWeek()],\n', "            'GRISE - Transcation Reward is already been claimed'\n", '        );\n', '\n', '        for (uint256 day = _day.sub(GRISE_WEEK); day < _day; day++)\n', '        {\n', '            rewardAmount += tokenHolderReward[day]\n', '                                        .mul(_balances[_msgSender()])\n', '                                        .div(totalToken[day]);\n', '        }\n', '                                        \n', '        _mint(\n', '            _msgSender(),\n', '            rewardAmount\n', '        );\n', '        \n', '        isTranscFeeClaimed[_msgSender()][currentGriseWeek()] = true;\n', '\n', '        TranscFeeClaimed(_msgSender(), currentGriseWeek(), rewardAmount);\n', '    }\n', '\n', '    function setStaker(\n', '        address _staker\n', '    ) \n', '        external\n', '    {    \n', '        require(\n', '            _msgSender() == STAKE_GATEKEEPER,\n', "            'GRISE: Operation not allowed'\n", '        );\n', '        \n', '        staker[_staker] = staker[_staker] + 1;\n', '    }\n', '    \n', '    function resetStaker(\n', '        address _staker\n', '    ) \n', '        external\n', '    {    \n', '        require(\n', '            _msgSender() == STAKE_GATEKEEPER,\n', "            'GRISE: Operation not allowed'\n", '        );\n', '        \n', '        if (staker[_staker] > 0)\n', '        {\n', '            staker[_staker] = staker[_staker] - 1;\n', '        }\n', '    }\n', '\n', '    function updateStakedToken(\n', '        uint256 _stakedToken\n', '    ) \n', '        external\n', '    {\n', '        require(\n', '            _msgSender() == STAKE_GATEKEEPER,\n', "            'GRISE: Operation not allowed'\n", '        );\n', '            \n', '        stakedToken = _stakedToken;\n', '        totalToken[currentGriseDay()] = totalSupply().add(stakedToken);\n', '    }\n', '\n', '    function updateMedTermShares(\n', '        uint256 _shares\n', '    ) \n', '        external\n', '    {    \n', '        require(\n', '            _msgSender() == STAKE_GATEKEEPER,\n', "            'GRISE: Operation not allowed'\n", '        );\n', '        \n', '        mediumTermShares = _shares;\n', '    }\n', '\n', '    function getTransFeeReward(\n', '        uint256 _fromDay,\n', '        uint256 _toDay\n', '    ) \n', '        external \n', '        view \n', '        returns (uint256 rewardAmount)\n', '    {\n', '        require(\n', '            _msgSender() == STAKE_GATEKEEPER,\n', "            'GRISE: Operation not allowed'\n", '        );\n', '\n', '        for(uint256 day = _fromDay; day < _toDay; day++)\n', '        {\n', '            rewardAmount += stakerRewardPerShare[day];\n', '        }\n', '    }\n', '\n', '    function getReservoirReward(\n', '        uint256 _fromDay,\n', '        uint256 _toDay\n', '    ) \n', '        external\n', '        view \n', '        returns (uint256 rewardAmount)\n', '    {\n', '        require(\n', '            _msgSender() == STAKE_GATEKEEPER,\n', "            'GRISE: Operation not allowed'\n", '        );\n', '\n', '        for(uint256 day = _fromDay; day < _toDay; day++)\n', '        {\n', '            rewardAmount += reservoirRewardPerShare[day];\n', '        }\n', '    }\n', '\n', '    function getTokenHolderReward(\n', '        uint256 _fromDay,\n', '        uint256 _toDay\n', '    ) \n', '        external\n', '        view \n', '        returns (uint256 rewardAmount)\n', '    {\n', '\n', '        require(\n', '            _msgSender() == STAKE_GATEKEEPER,\n', "            'GRISE: Operation not allowed'\n", '        );\n', '\n', '        for(uint256 day = _fromDay; day < _toDay; day++)\n', '        {\n', '            rewardAmount += tokenHolderReward[day]\n', '                            .mul(PRECISION_RATE)\n', '                            .div(totalToken[day]);\n', '        }\n', '    }\n', '\n', '    function timeToClaimWeeklyReward() \n', '        public\n', '        view\n', '        returns (uint256 _days)\n', '    {\n', '        _days = currentGriseDay().mod(GRISE_WEEK) > 0 ?\n', '                    GRISE_WEEK - currentGriseDay().mod(GRISE_WEEK) :\n', '                    0;\n', '    }\n', '\n', '    function timeToClaimMonthlyReward() \n', '        public \n', '        view \n', '        returns (uint256 _days)\n', '    {\n', '        _days = currentGriseDay().mod(GRISE_MONTH) > 0 ?\n', '                    GRISE_MONTH - currentGriseDay().mod(GRISE_MONTH) :\n', '                    0;\n', '    }\n', '\n', '    function balanceOfStaker(\n', '        address account\n', '    ) \n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _balances[account];\n', '    }\n', '\n', '    function getEpocTime() \n', '        external\n', '        view \n', '        returns (uint256)\n', '    {\n', '        return block.timestamp;\n', '    }\n', '\n', '    function getLaunchTime()\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return LAUNCH_TIME;\n', '    }\n', '\n', '    function getLPLaunchTime()\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return LP_LAUNCH_TIME;\n', '    }\n', '\n', '    function isStaker(\n', '        address _staker\n', '    ) \n', '        external\n', '        view\n', '        returns (bool status)\n', '    {\n', '        status = (staker[_staker] > 0) ? true : false;\n', '    }\n', '}']