['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.6.0 <0.7.0;\n', 'import "./FarmUniswap.sol";\n', '\n', 'interface IUniFactory {\n', '  function getPair(address tokenA, address tokenB) external view returns (address);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '  function name() external pure returns (string memory);\n', '  function symbol() external pure returns (string memory);\n', '  function decimals() external pure returns (uint8);\n', '  function totalSupply() external view returns (uint);\n', '  function balanceOf(address owner) external view returns (uint);\n', '  function allowance(address owner, address spender) external view returns (uint);\n', '\n', '  function approve(address spender, uint value) external returns (bool);\n', '  function transfer(address to, uint value) external returns (bool);\n', '  function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '  function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '  function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '  function nonces(address owner) external view returns (uint);\n', '\n', '  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '  event Mint(address indexed sender, uint amount0, uint amount1);\n', '  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '  event Swap(\n', '    address indexed sender,\n', '    uint amount0In,\n', '    uint amount1In,\n', '    uint amount0Out,\n', '    uint amount1Out,\n', '    address indexed to\n', '  );\n', '  event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '  function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '  function factory() external view returns (address);\n', '  function token0() external view returns (address);\n', '  function token1() external view returns (address);\n', '  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '  function price0CumulativeLast() external view returns (uint);\n', '  function price1CumulativeLast() external view returns (uint);\n', '  function kLast() external view returns (uint);\n', '\n', '  function mint(address to) external returns (uint liquidity);\n', '  function burn(address to) external returns (uint amount0, uint amount1);\n', '  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '  function skim(address to) external;\n', '  function sync() external;\n', '\n', '  function initialize(address, address) external;\n', '}\n', '\n', 'abstract contract Context {\n', '  function _msgSender() internal view virtual returns (address payable) {\n', '    return msg.sender;\n', '  }\n', '}\n', '\n', 'abstract contract Ownable is Context {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor () internal {\n', '    address msgSender = _msgSender();\n', '    _owner = msgSender;\n', '    emit OwnershipTransferred(address(0), msgSender);\n', '  }\n', '\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '\n', 'contract FarmUniswapGenerator is Context, Ownable {\n', '  using SafeMath for uint256;\n', '  IFarmFactory public factory;\n', '\n', '  struct FarmParameters {\n', '    uint256 bonusBlocks;\n', '    uint256 totalBonusReward;\n', '    uint256 numBlocks;\n', '    uint256 endBlock;\n', '    uint256 requiredAmount;\n', '  }\n', '\n', '  constructor(IFarmFactory _factory) public {\n', '    factory = _factory;\n', '  }\n', '\n', '  /**\n', '   * @notice Determine the endBlock based on inputs. Used on the front end to show the exact settings the Farm contract will be deployed with\n', '   */\n', '  function determineEndBlock(uint256 _amount, uint256 _blockReward, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus) public pure returns (uint256, uint256) {\n', '    FarmParameters memory params;\n', '    params.bonusBlocks = _bonusEndBlock.sub(_startBlock);\n', '    params.totalBonusReward = params.bonusBlocks.mul(_bonus).mul(_blockReward);\n', '    params.numBlocks = _amount.sub(params.totalBonusReward).div(_blockReward);\n', '    params.endBlock = params.numBlocks.add(params.bonusBlocks).add(_startBlock);\n', '\n', '    uint256 nonBonusBlocks = params.endBlock.sub(_bonusEndBlock);\n', '    uint256 effectiveBlocks = params.bonusBlocks.mul(_bonus).add(nonBonusBlocks);\n', '    uint256 requiredAmount = _blockReward.mul(effectiveBlocks);\n', '    return (params.endBlock, requiredAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Determine the blockReward based on inputs specifying an end date. Used on the front end to show the exact settings the Farm contract will be deployed with\n', '   */\n', '  function determineBlockReward(uint256 _amount, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus, uint256 _endBlock) public pure returns (uint256, uint256) {\n', '    uint256 bonusBlocks = _bonusEndBlock.sub(_startBlock);\n', '    uint256 nonBonusBlocks = _endBlock.sub(_bonusEndBlock);\n', '    uint256 effectiveBlocks = bonusBlocks.mul(_bonus).add(nonBonusBlocks);\n', '    uint256 blockReward = _amount.div(effectiveBlocks);\n', '    uint256 requiredAmount = blockReward.mul(effectiveBlocks);\n', '    return (blockReward, requiredAmount);\n', '  }\n', '\n', '  /**\n', '   * @notice Creates a new FarmUniswap contract and registers it in the \n', '   * .sol. All farming rewards are locked in the FarmUniswap Contract\n', '   */\n', '  function createFarmUniswap(IERC20 _rewardToken, uint256 _amount, IERC20 _lpToken, IUniFactory _swapFactory, uint256 _blockReward, uint256 _startBlock, uint256 _bonusEndBlock, uint256 _bonus) public onlyOwner returns (address){\n', "    require(_startBlock > block.number, 'START'); // ideally at least 24 hours more to give farmers time\n", "    require(_bonus > 0, 'BONUS');\n", "    require(address(_rewardToken) != address(0), 'REWARD TOKEN');\n", "    require(_blockReward > 1000, 'BLOCK REWARD'); // minimum 1000 divisibility per block reward\n", '    IUniFactory swapFactory = _swapFactory;\n', '    // ensure this pair is on swapFactory by querying the factory\n', '    IUniswapV2Pair lpair = IUniswapV2Pair(address(_lpToken));\n', '    address factoryPairAddress = swapFactory.getPair(lpair.token0(), lpair.token1());\n', "    require(factoryPairAddress == address(_lpToken), 'This pair is not on _swapFactory exchange');\n", '\n', '    FarmParameters memory params;\n', '    (params.endBlock, params.requiredAmount) = determineEndBlock(_amount, _blockReward, _startBlock, _bonusEndBlock, _bonus);\n', '\n', '    TransferHelper.safeTransferFrom(address(_rewardToken), address(_msgSender()), address(this), params.requiredAmount);\n', '    FarmUniswap newFarm = new FarmUniswap(address(factory), address(this));\n', '    TransferHelper.safeApprove(address(_rewardToken), address(newFarm), params.requiredAmount);\n', '    newFarm.init(_rewardToken, params.requiredAmount, _lpToken, _blockReward, _startBlock, params.endBlock, _bonusEndBlock, _bonus);\n', '\n', '    factory.registerFarm(address(newFarm));\n', '    return (address(newFarm));\n', '  }\n', '}']