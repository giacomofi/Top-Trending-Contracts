['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-24\n', '*/\n', '\n', 'pragma solidity ^0.4.19;\n', '\n', '/* Interface for ERC20 Tokens */\n', 'contract Token {\n', '    bytes32 public standard;\n', '    bytes32 public name;\n', '    bytes32 public symbol;\n', '    uint256 public totalSupply;\n', '    uint8 public decimals;\n', '    bool public allowTransactions;\n', '    mapping (address => uint256) public balanceOf;\n', '    mapping (address => mapping (address => uint256)) public allowance;\n', '    function transfer(address _to, uint256 _value) returns (bool success);\n', '    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success);\n', '    function approve(address _spender, uint256 _value) returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n', '}\n', '\n', '/* Interface for pTokens contract */\n', 'contract pToken {\n', '    function redeem(uint256 _value, string memory _btcAddress) public returns (bool _success);\n', '}\n', '\n', 'interface IAMB {\n', '    function messageSender() external view returns (address);\n', '    function maxGasPerTx() external view returns (uint256);\n', '    function transactionHash() external view returns (bytes32);\n', '    function messageId() external view returns (bytes32);\n', '    function messageSourceChainId() external view returns (bytes32);\n', '    function messageCallStatus(bytes32 _messageId) external view returns (bool);\n', '    function failedMessageDataHash(bytes32 _messageId) external view returns (bytes32);\n', '    function failedMessageReceiver(bytes32 _messageId) external view returns (address);\n', '    function failedMessageSender(bytes32 _messageId) external view returns (address);\n', '    function requireToPassMessage(address _contract, bytes _data, uint256 _gas) external returns (bytes32);\n', '    function requireToConfirmMessage(address _contract, bytes _data, uint256 _gas) external returns (bytes32);\n', '    function sourceChainId() external view returns (uint256);\n', '    function destinationChainId() external view returns (uint256);\n', '}\n', '\n', 'interface DOGEMEXXDAI {\n', '    function depositTokenForUser(address token, uint128 amount, address user);\n', '}\n', '\n', '// The DOGEMEX base Contract\n', 'contract DOGEMEX_Base {\n', '    address public owner; // holds the address of the contract owner\n', '    mapping (address => bool) public admins; // mapping of admin addresses\n', '    address public AMBBridgeContract;\n', '    address public DOGEMEX_XDAI_CONTRACT;\n', '\n', '    uint256 public inactivityReleasePeriod; // period in blocks before a user can use the withdraw() function\n', '\n', '    bool public destroyed = false; // contract is destoryed\n', '    uint256 public destroyDelay = 1000000; // number of blocks after destroy, the contract is still active (aprox 6 monthds)\n', '    uint256 public destroyBlock;\n', '\n', '    uint256 public ambInstructionGas = 2000000;\n', '\n', '    mapping (bytes32 => bool) public processedMessages; // records processed bridge messages, so the same message is not executed twice\n', '\n', '    \n', '    /**\n', '     *\n', '     *  BALNCE FUNCTIONS\n', '     *\n', '     **/\n', '\n', '    // Deposit ETH to contract\n', '    function deposit() payable {\n', '        if (destroyed) revert();\n', '        \n', '        sendDepositInstructionToAMBBridge(msg.sender, address(0), msg.value);\n', '    }\n', '\n', '    // Deposit token to contract\n', '    function depositToken(address token, uint128 amount) {\n', '        if (destroyed) revert();\n', '        if (!Token(token).transferFrom(msg.sender, this, amount)) throw; // attempts to transfer the token to this contract, if fails throws an error\n', '        sendDepositInstructionToAMBBridge(msg.sender, token, amount);\n', '    }\n', '\n', '    // Deposit token to contract for a user\n', '    function depositTokenForUser(address token, uint128 amount, address user) {    \n', '        if (destroyed) revert();    \n', '\n', '        if (!Token(token).transferFrom(msg.sender, this, amount)) throw; // attempts to transfer the token to this contract, if fails throws an error\n', '        sendDepositInstructionToAMBBridge(user, token, amount);\n', '    }\n', '\n', '\n', '    function pTokenRedeem(address token, uint256 amount, string destinationAddress) onlyAMBBridge returns (bool success) {\n', '        if (!pToken(token).redeem(amount, destinationAddress)) revert();\n', '        bytes32 msgId = IAMB(AMBBridgeContract).messageId();\n', '        processedMessages[msgId] = true;\n', '        emit pTokenRedeemEvent(token, msg.sender, amount, destinationAddress);\n', '    }\n', '\n', '\n', '    function sendDepositInstructionToAMBBridge(address user, address token, uint256 amount) internal\n', '    {\n', '        bytes4 methodSelector = DOGEMEXXDAI(0).depositTokenForUser.selector;\n', '        bytes memory data = abi.encodeWithSelector(methodSelector, token, amount, user);\n', '\n', '        uint256 gas = ambInstructionGas;\n', '\n', '        // send AMB bridge instruction\n', '        bytes32 msgId = IAMB(AMBBridgeContract).requireToPassMessage(DOGEMEX_XDAI_CONTRACT, data, gas);\n', '\n', '        emit Deposit(token, user, amount, msgId); // fires the deposit event\n', '    }    \n', ' \n', '\n', '\n', '    // Withdrawal function used by the server to execute withdrawals\n', '    function withdrawForUser(\n', '        address token, // the address of the token to be withdrawn\n', '        uint256 amount, // the amount to be withdrawn\n', '        address user // address of the user\n', '    ) onlyAMBBridge returns (bool success) {\n', '        if (token == address(0)) { // checks if the withdrawal is in ETH or Tokens\n', '            if (!user.send(amount)) throw; // sends ETH\n', '        } else {\n', '            if (!Token(token).transfer(user, amount)) throw; // sends tokens\n', '        }\n', '\n', '        bytes32 msgId = IAMB(AMBBridgeContract).messageId();\n', '        processedMessages[msgId] = true;\n', '        emit Withdraw(token, user, amount, msgId); // fires the withdraw event\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     *\n', '     *  HELPER FUNCTIONS\n', '     *\n', '     **/\n', '\n', '    // Event fired when the owner of the contract is changed\n', '    event SetOwner(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // Allows only the owner of the contract to execute the function\n', '    modifier onlyOwner {\n', '        assert(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    // Changes the owner of the contract\n', '    function setOwner(address newOwner) onlyOwner {\n', '        SetOwner(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    // Owner getter function\n', '    function getOwner() returns (address out) {\n', '        return owner;\n', '    }\n', '\n', '    // Adds or disables an admin account\n', '    function setAdmin(address admin, bool isAdmin) onlyOwner {\n', '        admins[admin] = isAdmin;\n', '    }\n', '\n', '\n', '    // Allows for admins only to call the function\n', '    modifier onlyAdmin {\n', '        if (msg.sender != owner && !admins[msg.sender]) throw;\n', '        _;\n', '    }\n', '\n', '\n', '    // Allows for AMB Bridge only to call the function\n', '    modifier onlyAMBBridge {\n', '        if (msg.sender != AMBBridgeContract) throw;\n', '\n', '        bytes32 msgId = IAMB(AMBBridgeContract).messageId();\n', '        require(!processedMessages[msgId], "Error: message already processed");\n', '        _;\n', '    }\n', '\n', '    function() external {\n', '        throw;\n', '    }\n', '\n', '    function assert(bool assertion) {\n', '        if (!assertion) throw;\n', '    }\n', '\n', '    // Safe Multiply Function - prevents integer overflow \n', '    function safeMul(uint a, uint b) returns (uint) {\n', '        uint c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    // Safe Subtraction Function - prevents integer overflow \n', '    function safeSub(uint a, uint b) returns (uint) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    // Safe Addition Function - prevents integer overflow \n', '    function safeAdd(uint a, uint b) returns (uint) {\n', '        uint c = a + b;\n', '        assert(c>=a && c>=b);\n', '        return c;\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     *\n', '     *  ADMIN FUNCTIONS\n', '     *\n', '     **/\n', '    // Deposit event fired when a deposit takes place\n', '    event Deposit(address indexed token, address indexed user, uint256 amount, bytes32 msgId);\n', '\n', '    // Withdraw event fired when a withdrawal id executed\n', '    event Withdraw(address indexed token, address indexed user, uint256 amount, bytes32 msgId);\n', '    \n', '    // pTokenRedeemEvent event fired when a pToken withdrawal is executed\n', '    event pTokenRedeemEvent(address indexed token, address indexed user, uint256 amount, string destinationAddress);\n', '\n', '    // Change inactivity release period event\n', '    event InactivityReleasePeriodChange(uint256 value);\n', '\n', '    // Fee account changed event\n', '    event FeeAccountChanged(address indexed newFeeAccount);\n', '\n', '\n', '\n', '    // Constructor function, initializes the contract and sets the core variables\n', '    function DOGEMEX_Base(uint256 inactivityReleasePeriod_, address AMBBridgeContract_, address DOGEMEX_XDAI_CONTRACT_) {\n', '        owner = msg.sender;\n', '        inactivityReleasePeriod = inactivityReleasePeriod_;\n', '        AMBBridgeContract = AMBBridgeContract_;\n', '        DOGEMEX_XDAI_CONTRACT = DOGEMEX_XDAI_CONTRACT_;\n', '    }\n', '\n', '    // Sets the inactivity period before a user can withdraw funds manually\n', '    function destroyContract() onlyOwner returns (bool success) {\n', '        if (destroyed) throw;\n', '        destroyBlock = block.number;\n', '\n', '        return true;\n', '    }\n', '\n', '    // Sets the inactivity period before a user can withdraw funds manually\n', '    function setInactivityReleasePeriod(uint256 expiry) onlyOwner returns (bool success) {\n', '        if (expiry > 1000000) throw;\n', '        inactivityReleasePeriod = expiry;\n', '\n', '        emit InactivityReleasePeriodChange(expiry);\n', '        return true;\n', '    }\n', '\n', '    // Returns the inactivity release perios\n', '    function getInactivityReleasePeriod() view returns (uint256)\n', '    {\n', '        return inactivityReleasePeriod;\n', '    }\n', '\n', '\n', '    function releaseFundsAfterDestroy(address token, uint256 amount) onlyOwner returns (bool success) {\n', '        if (!destroyed) throw;\n', '        if (safeAdd(destroyBlock, destroyDelay) > block.number) throw; // destroy delay not yet passed\n', '\n', '        if (token == address(0)) { // checks if withdrawal is a token or ETH, ETH has address 0x00000... \n', '            if (!msg.sender.send(amount)) throw; // send ETH\n', '        } else {\n', '            if (!Token(token).transfer(msg.sender, amount)) throw; // Send token\n', '        }\n', '    }\n', '\n', '    function setAmbInstructionGas(uint256 newGas) onlyOwner {\n', '        ambInstructionGas = newGas;\n', '    }\n', '}']