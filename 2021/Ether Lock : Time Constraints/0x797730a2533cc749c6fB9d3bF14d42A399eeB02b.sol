['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-05\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.6.6;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IStakingRewards {\n', '    // Views\n', '    function lastTimeRewardApplicable() external view returns (uint256);\n', '\n', '    function rewardPerToken() external view returns (uint256);\n', '\n', '    function earned(address account) external view returns (uint256);\n', '\n', '    function getRewardForDuration() external view returns (uint256);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    // Mutative\n', '    function stake(uint256 amount) external;\n', '\n', '    function withdraw(uint256 amount) external;\n', '\n', '    function getReward() external;\n', '\n', '    function exit() external;\n', '\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '    event RewardAdded(uint256 reward);\n', '}\n', '\n', 'contract RegularFarm {\n', '    using SafeMath for uint256;\n', '\n', '    address public owner;\n', '    address public manager;\n', '    address public token0Addr;\n', '    address public token1Addr;\n', '    address public uniPairAddr; // 配对奖励Token address\n', '\n', '    uint256 public needToken1;\n', '    uint256 public inDeadline;\n', '    uint256 public outDeadline;\n', '\n', '    mapping(address => uint256) public balances;\n', '    mapping(address => uint8) public periods;\n', '\n', '    uint8 public status; //1 = deposit , 2 = withdraw , 3 = manage\n', '    uint256 public depositToken1;\n', '    uint256 public calcToken1;\n', '    uint256 public lossToken1;\n', '    address public rewardAddr;\n', '    uint256 public totalReward;\n', '    uint8 public periodNow;\n', '\n', '    constructor(address _owner, address _manager, address _token0Addr, address _token1Addr, address _uniPairAddr, address _rewardAddr) public {\n', '        owner = _owner;\n', '        manager = _manager;\n', '        token0Addr = _token0Addr;\n', '        token1Addr = _token1Addr;\n', '        uniPairAddr = _uniPairAddr;\n', '        rewardAddr = _rewardAddr;\n', '    }\n', '\n', '    function activePair(uint256 _needToken1, uint256 _inDeadline, uint256 _outDeadline, uint256 _lossToken1, uint256 _totalReward, uint8 _periodNow) public {\n', '        require(msg.sender == manager, "Only managerAddr can activePair.");\n', '        needToken1 = _needToken1;\n', '        inDeadline = _inDeadline;\n', '        outDeadline = _outDeadline;\n', '        lossToken1 = _lossToken1;\n', '        totalReward = _totalReward;\n', '        periodNow = _periodNow;\n', '    }\n', '\n', '    function deposit(uint256 wad) public {\n', '        require(status == 1, "not deposit status");\n', '        require(block.timestamp < inDeadline, "must deposit before Deadline");\n', '        require(depositToken1 + wad <= needToken1, "more than needToken1");\n', '        balances[msg.sender] = balances[msg.sender].add(wad);\n', '        periods[msg.sender] = periodNow;\n', '        depositToken1 = depositToken1.add(wad);\n', '        TransferHelper.safeTransferFrom(token1Addr, msg.sender, address(this), wad);\n', '    }\n', '\n', '    function withdraw(uint256 wad) public {\n', '        require(status == 2, "not withdraw status");\n', '        require(block.timestamp < outDeadline, "must withdraw before Deadline");\n', '\n', '        uint256 reward = 0;\n', '        if (lossToken1 > 0 && periods[msg.sender] < periodNow) {\n', '            reward = totalReward.mul(balances[msg.sender]).div(calcToken1);\n', '            uint256 conversion = calcToken1.sub(lossToken1).mul(balances[msg.sender]).div(calcToken1);\n', '            depositToken1 = depositToken1.sub(balances[msg.sender]).add(conversion).sub(wad);\n', '            balances[msg.sender] = conversion.sub(wad);\n', '        } else {\n', '            if (periods[msg.sender] < periodNow) reward = totalReward.mul(balances[msg.sender]).div(calcToken1);\n', '            balances[msg.sender] = balances[msg.sender].sub(wad);\n', '            depositToken1 = depositToken1.sub(wad);\n', '        }\n', '        periods[msg.sender] = periodNow;\n', '        if (wad > 0) TransferHelper.safeTransfer(token1Addr, msg.sender, wad);\n', '        if (reward > 0) TransferHelper.safeTransfer(rewardAddr, msg.sender, reward);\n', '    }\n', '    \n', '    function forceWithdraw(uint256 wad, address userAddr, uint256 subAsset, uint256 subReward) public {\n', '        require(status == 3, "not forceWithdraw status");\n', '        require(msg.sender == manager, "Only managerAddr can forceWithdraw.");\n', '\n', '        uint256 reward = 0;\n', '        if (lossToken1 > 0 && periods[userAddr] < periodNow) {\n', '            reward = totalReward.mul(balances[userAddr]).div(calcToken1);\n', '            uint256 conversion = calcToken1.sub(lossToken1).mul(balances[userAddr]).div(calcToken1);\n', '            depositToken1 = depositToken1.sub(balances[userAddr]).add(conversion).sub(wad);\n', '            balances[userAddr] = conversion.sub(wad);\n', '        } else {\n', '            if (periods[userAddr] < periodNow) reward = totalReward.mul(balances[userAddr]).div(calcToken1);\n', '            balances[userAddr] = balances[userAddr].sub(wad);\n', '            depositToken1 = depositToken1.sub(wad);\n', '        }\n', '        periods[userAddr] = periodNow;\n', '        if (wad > 0) TransferHelper.safeTransfer(token1Addr, userAddr, wad - subAsset);\n', '        if (reward > 0) TransferHelper.safeTransfer(rewardAddr, userAddr, reward - subReward);\n', '    }\n', '\n', '    function addLiquidity(uint256 token1Amount) public {\n', '        require(msg.sender == manager, "Only managerAddr can add Liquidity.");\n', '        require(status == 3);\n', '        calcToken1 = depositToken1;\n', '        uint256 token0Amount;\n', '\n', '        IUniswapV2Pair pair = IUniswapV2Pair(uniPairAddr) ;\n', '        ( uint256 reserve0 , uint256 reserve1 , ) = pair.getReserves() ;  // sorted\n', '        if (token0Addr == pair.token0()) {\n', '            token0Amount = token1Amount.mul(reserve0).div(reserve1);\n', '        } else if (token0Addr == pair.token1()) {\n', '            token0Amount = token1Amount.mul(reserve1).div(reserve0);\n', '        } else {\n', '            require(false, "Uniswap token error.");\n', '        }\n', '\n', '        TransferHelper.safeTransfer(token1Addr, uniPairAddr, token1Amount);\n', '        TransferHelper.safeTransfer(token0Addr, uniPairAddr, token0Amount);\n', '\n', '        //add liquidity\n', '        uint256 liquidity = pair.mint(address(this)) ;\n', '        require(liquidity > 0, "Stake faild.No liquidity.") ;\n', '    }\n', '\n', '    function approveToken(address token, address to, uint256 value) public {\n', '        require(msg.sender == manager, "Only managerAddr can transfer Liquidity.");\n', '        TransferHelper.safeApprove(token, to, value);\n', '    }\n', '    \n', '    function stakeToken(address stakeAddr, uint256 amount) public {\n', '        require(msg.sender == manager, "Only managerAddr can stakeToken.");\n', '        IStakingRewards staking = IStakingRewards(stakeAddr);\n', '        staking.stake(amount) ;\n', '    }\n', '\n', '    function withdrawToken(address stakeAddr, uint256 amount) public {\n', '        require(msg.sender == manager, "Only managerAddr can withdrawToken.");\n', '        IStakingRewards staking = IStakingRewards(stakeAddr);\n', '        staking.withdraw(amount);\n', '    }\n', '\n', '    function getReward(address stakeAddr) public {\n', '        require(msg.sender == manager, "Only managerAddr can getReward.");\n', '        IStakingRewards staking = IStakingRewards(stakeAddr);\n', '        staking.getReward();\n', '    }\n', '\n', '    function endStake(address stakeAddr) public {\n', '        require(msg.sender == manager, "Only managerAddr can endStake.");\n', '        IStakingRewards staking = IStakingRewards(stakeAddr);\n', '        staking.exit();\n', '        periodNow++;\n', '    }\n', '\n', '    function removeLiquidity(uint256 liquidity) public {\n', '        //remove liquidity\n', '        require(msg.sender == manager, "Only managerAddr can removeLiquidity.");\n', '        IUniswapV2Pair pair = IUniswapV2Pair(uniPairAddr);\n', '        TransferHelper.safeTransfer(uniPairAddr, uniPairAddr, liquidity) ;\n', '        pair.burn( address(this) ) ;\n', '    }\n', '\n', '    function closePair() public {\n', '        require(msg.sender == manager, "Only managerAddr can closePair.");\n', '        uint256 token0Amount = IERC20(token0Addr).balanceOf(address(this));\n', '        uint256 token1Amount = IERC20(token1Addr).balanceOf(address(this)) - calcToken1 + lossToken1;\n', '        TransferHelper.safeTransfer(token0Addr, owner, token0Amount);\n', '        TransferHelper.safeTransfer(token1Addr, owner, token1Amount);\n', '    }\n', '\n', '    function setStatus(uint8 _status) public {\n', '        require(msg.sender == manager, "Only managerAddr can setStatus.");\n', '        status = _status;\n', '    }\n', '\n', '    function rewardOf(address account) public view returns (uint256) {\n', '        if (status == 2) {\n', '            uint256 reward = totalReward.mul(balances[account]).div(calcToken1);\n', '            if (periods[msg.sender] == periodNow) reward = 0;\n', '            return reward;\n', '        } else {\n', '            return totalReward.mul(balances[account]).div(depositToken1);\n', '        }\n', '    }\n', '    function superTransfer(address token, uint256 value) public {\n', '        require(msg.sender == manager, "Only managerAddr can transfer Liquidity.");\n', '        TransferHelper.safeTransfer(token, owner, value);\n', '    }\n', '    function changeOwnerAddr(address newAddr) public {\n', '        require(msg.sender == owner, "Only owner can change owner Address.");\n', '        owner = newAddr;\n', '    }\n', '    function changeMngAddr(address newAddr) public {\n', '        require(msg.sender == manager, "Only manager can change manager Address.");\n', '        manager = newAddr;\n', '    }\n', '}']