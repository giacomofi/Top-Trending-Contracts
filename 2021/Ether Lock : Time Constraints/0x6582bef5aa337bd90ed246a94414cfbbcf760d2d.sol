['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-03\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-01-27\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2020-10-13\n', '*/\n', '\n', 'pragma solidity 0.4.26;\n', '\n', 'contract IERC20 {\n', '    uint public decimals;\n', '    string public    name;\n', '    string public   symbol;\n', '    mapping(address => uint) public balances;\n', '    mapping (address => mapping (address => uint)) public allowed;\n', '    \n', '    uint public _totalSupply;\n', '    function totalSupply() public constant returns (uint);\n', '    function balanceOf(address who) public constant returns (uint);\n', '    function transfer(address to, uint value) public;\n', '    function allowance(address owner, address spender) public constant returns (uint);\n', '    function transferFrom(address from, address to, uint value) public;\n', '    function approve(address spender, uint value) public returns (bool);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '}\n', '\n', ' \n', '\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', ' \n', '  \n', 'contract Distribute{\n', '       using SafeMath for uint;\n', '       \n', '       \n', '       \n', '        event GetFod(address getAddress, uint256 value);\n', '        event DepositeFod(address ethAddress, uint256 value);\n', '        event UseInviteCode(address ethAddress, bytes4 code);    \n', '       \n', '      struct Pledge{\n', '            uint day;\n', '            uint investAmount;  \n', '            uint earnings;         \n', '            uint createTime;    \n', '            uint dueTime;\n', '            uint receivedDay;\n', '            uint end;\n', '      }  \n', '\n', '\n', '      struct Invite{\n', '            address userAddr;\n', '            uint256 earnings; \n', '            uint day;\n', '            uint256 createTime;  \n', '            uint256 dueTime;\n', '            uint256 receivedDay;\n', '            uint end;\n', '      }  \n', '\n', '        uint intervalTime=86400;\n', '        uint public yieldRate=110;\n', '        uint public inviteYieldRate=100;\n', '\n', '        address public founder;\n', '\n', '        address fod=0xc7bE1Cf99e6a691ad5c56E3D63AD9667C6932E63;\n', '        uint fodDecimals=8;\n', '    \n', '   \n', '        mapping (bytes4 => Invite[]) public inviteLogs;\n', '        \n', '        mapping (address => bytes4) public useInviteCodeMap;\n', '        \n', '        mapping (bytes4 => address) public inviteCodeMap;\n', '        \n', '        mapping (bytes4 => uint) public codeUsageCounts;\n', '        \n', '        mapping (address => Pledge[]) public addressToPledge;\n', '        mapping(uint=>uint) public dateToYields;\n', '        mapping(uint=>uint) public dayMap;\n', '            \n', '            \n', '            \n', '        constructor() public {\n', '            dateToYields[0]=18;\n', '            dateToYields[1]=26;\n', '            dateToYields[2]=36;\n', '            dateToYields[3]=46;\n', '            dateToYields[4]=56;\n', '            \n', '            dayMap[0]=1;\n', '            dayMap[1]=7;\n', '            dayMap[3]=30;\n', '            dayMap[2]=60;\n', '            dayMap[4]=90;\n', '            \n', '            founder = msg.sender;\n', '         }\n', '         \n', '        \n', '        \n', '        function getAddrInviteCode(address _addr) view returns (bytes4) {\n', '            bytes4  inviteCode=bytes4(keccak256((_addr)));\n', '            if(inviteCodeMap[inviteCode]!=0){\n', '                return inviteCode;\n', '            }else{\n', '                return 0;\n', '            }\n', '        }\n', '         \n', '        function getInviteCode() view returns (bytes4) {\n', '            bytes4  inviteCode=bytes4(keccak256((msg.sender)));\n', '            return inviteCode;\n', '        }\n', '        \n', '        function getPledgeCount(address _addr) view returns (uint) {\n', '            return addressToPledge[_addr].length;\n', '        }\n', '        \n', '        function getInvitesCount(address _addr) view returns (uint) {\n', '            bytes4  inviteCode=bytes4(keccak256((msg.sender)));\n', '            return inviteLogs[inviteCode].length;\n', '        }\n', '   \n', '   \n', '        function setYieldRate(uint _yieldRate) public onlyOwner returns (bool success) {\n', '            yieldRate=_yieldRate;\n', '            return true;\n', '        }\n', '         \n', '        function setInviteYieldRate(uint _inviteYieldRate) public onlyOwner returns (bool success) {\n', '            inviteYieldRate=_inviteYieldRate;\n', '            return true;\n', '        }\n', '        \n', '        function setDateToYield(uint _index,uint _yield) public onlyOwner returns (bool success) {\n', '            dateToYields[_index]=_yield;\n', '            return true;\n', '        }\n', '         \n', '        function setDayMap(uint _index,uint _day) public onlyOwner returns (bool success) {\n', '            dayMap[_index]=_day;\n', '            return true;\n', '        }\n', '        \n', '        \n', '        function getTotalUnLockAmount(address _addr) public view returns (uint256) {\n', '             uint256 unlockAmount;\n', '             uint256 currentAmount;\n', '             Pledge[] pledges=addressToPledge[_addr];\n', '             for(uint i=0;i<pledges.length;i++){\n', '                if(pledges[i].end==1)continue;\n', '                uint day=(now.sub(pledges[i].createTime)).div(intervalTime);\n', '                uint256 dayAmount=pledges[i].earnings.div(pledges[i].day);\n', '            \n', '                if(now>pledges[i].dueTime){\n', '                    if(day.add(pledges[i].receivedDay)>=pledges[i].day){\n', '                        currentAmount=(pledges[i].day.sub(pledges[i].receivedDay)).mul(dayAmount).add(pledges[i].investAmount);\n', '                    }else{\n', '                         currentAmount=(day.sub(pledges[i].receivedDay)).mul(dayAmount).add(pledges[i].investAmount);\n', '                    }\n', '                }else{\n', '                    currentAmount=(day.sub(pledges[i].receivedDay)).mul(dayAmount);\n', '                }\n', '                unlockAmount=unlockAmount.add(currentAmount);\n', '            }\n', '            bytes4  inviteCode=bytes4(keccak256((_addr)));\n', '            Invite[] Invites=inviteLogs[inviteCode];\n', '            for(uint j=0;j<Invites.length;j++){\n', '                if(Invites[j].end==1)continue;\n', '                uint day2=(now.sub(Invites[j].createTime)).div(intervalTime);\n', '                uint256 dayAmount2=Invites[j].earnings.div(Invites[j].day);\n', '                \n', '                if(day2.add(Invites[j].receivedDay)>=Invites[j].day){\n', '                     currentAmount=(Invites[j].day.sub(Invites[j].receivedDay)).mul(dayAmount2);\n', '                }else{\n', '                     currentAmount=(day2.sub(Invites[j].receivedDay)).mul(dayAmount2);\n', '                }\n', '                unlockAmount=unlockAmount.add(currentAmount);\n', '            }\n', '            return unlockAmount;\n', '        }\n', '        \n', '        function getTotalPledgeAmount(address _addr) public view returns (uint256) {\n', '            uint256 amount;\n', '            uint256 unlockAmount;\n', '            Pledge[] pledges=addressToPledge[_addr];\n', '            for(uint i=0;i<pledges.length;i++){\n', '                amount=amount.add(pledges[i].investAmount);\n', '            }\n', '            return amount;\n', '        }\n', '        \n', '        function getUnLockPledgeAmount(address _addr) public view returns (uint256) {\n', '            uint256 unlockAmount;\n', '            uint256 currentAmount;\n', '            Pledge[] pledges=addressToPledge[_addr];\n', '             for(uint i=0;i<pledges.length;i++){\n', '                if(pledges[i].end==1)continue;\n', '                uint day=(now.sub(pledges[i].createTime)).div(intervalTime);\n', '                uint256 dayAmount=pledges[i].earnings.div(pledges[i].day);\n', '            \n', '                if(now>pledges[i].dueTime){\n', '                    if(day.add(pledges[i].receivedDay)>=pledges[i].day){\n', '                        currentAmount=(pledges[i].day.sub(pledges[i].receivedDay)).mul(dayAmount).add(pledges[i].investAmount);\n', '                    }else{\n', '                         currentAmount=(day.sub(pledges[i].receivedDay)).mul(dayAmount).add(pledges[i].investAmount);\n', '                    }\n', '                }else{\n', '                    currentAmount=(day.sub(pledges[i].receivedDay)).mul(dayAmount);\n', '                }\n', '                unlockAmount=unlockAmount.add(currentAmount);\n', '            }\n', '            return unlockAmount;\n', '        }\n', '        \n', '        function getTotalInviteAmount(address _addr) public view returns (uint256) {\n', '            uint256 amount;\n', '            bytes4  inviteCode=bytes4(keccak256((_addr)));\n', '            Invite[] Invites=inviteLogs[inviteCode];\n', '            for(uint i=0;i<Invites.length;i++){\n', '                amount=amount.add(Invites[i].earnings);\n', '            }\n', '            return amount;\n', '        }\n', '        \n', '        function getUnlockInviteAmount(address _addr) public view returns (uint256) {\n', '            uint256 unlockAmount;\n', '            uint256 currentAmount;\n', '            bytes4  inviteCode=bytes4(keccak256((_addr)));\n', '            Invite[] Invites=inviteLogs[inviteCode];\n', '            for(uint j=0;j<Invites.length;j++){\n', '                if(Invites[j].end==1)continue;\n', '                uint day=(now.sub(Invites[j].createTime)).div(intervalTime);\n', '                uint256 dayAmount=Invites[j].earnings.div(Invites[j].day);\n', '                \n', '                if(day.add(Invites[j].receivedDay)>=Invites[j].day){\n', '                     currentAmount=(Invites[j].day.sub(Invites[j].receivedDay)).mul(dayAmount);\n', '                }else{\n', '                     currentAmount=(day.sub(Invites[j].receivedDay)).mul(dayAmount);\n', '                }\n', '                unlockAmount=unlockAmount.add(currentAmount);\n', '            }\n', '            return unlockAmount;\n', '        }\n', '   \n', '        function useInviteCode(bytes4 _inviteCode) public returns (bool success) {\n', '            require(useInviteCodeMap[msg.sender]==0);\n', '            require(inviteCodeMap[_inviteCode]!=0);\n', '            bytes4  inviteCode=bytes4(keccak256((msg.sender)));\n', '            require(_inviteCode!=inviteCode);\n', '            useInviteCodeMap[msg.sender]=_inviteCode;\n', '            codeUsageCounts[_inviteCode]=codeUsageCounts[_inviteCode]+1;\n', '            emit UseInviteCode(msg.sender,_inviteCode);\n', '            return true;\n', '        }\n', '   \n', '\n', '        function depositeFod(uint256 _amount,uint _mode) public {\n', '            uint256 yie=100;\n', '            if(useInviteCodeMap[msg.sender]!=0){\n', '                yie=yieldRate;\n', '            }\n', '\n', '            IERC20 fodToken =IERC20(fod);\n', '            fodToken.transferFrom(msg.sender,this,_amount);\n', '            \n', '            uint256 dueTime=now.add(dayMap[_mode].mul(intervalTime));\n', '            uint256 earnings=_amount.mul(yie).mul(dateToYields[_mode]).mul(dayMap[_mode]).div(3650000);\n', '            Pledge memory  pledge=Pledge(dayMap[_mode],_amount,earnings,now,dueTime,0,0);\n', '            addressToPledge[msg.sender].push(pledge);\n', '\n', '            if(useInviteCodeMap[msg.sender]!=0){\n', '                 Invite memory  invite=Invite(msg.sender,earnings.mul(inviteYieldRate).div(100),dayMap[_mode],now,dueTime,0,0);\n', '                 inviteLogs[useInviteCodeMap[msg.sender]].push(invite);\n', '            }\n', '\n', '            if(inviteCodeMap[bytes4(keccak256((msg.sender)))]==0){\n', '                 inviteCodeMap[bytes4(keccak256((msg.sender)))]=msg.sender;\n', '            }\n', '            \n', '            emit DepositeFod(msg.sender,_amount);\n', '        }\n', '        \n', '       function receiveFod() public{\n', '            uint256 unlockAmount;\n', '             uint256 currentAmount;\n', '            Pledge[] pledges=addressToPledge[msg.sender];\n', '            for(uint i=0;i<pledges.length;i++){\n', '                if(pledges[i].end==1)continue;\n', '                uint day=(now.sub(pledges[i].createTime)).div(intervalTime);\n', '                uint256 dayAmount=pledges[i].earnings.div(pledges[i].day);\n', '            \n', '                if(now>pledges[i].dueTime){\n', '                    if(day.add(pledges[i].receivedDay)>=pledges[i].day){\n', '                        currentAmount=(pledges[i].day.sub(pledges[i].receivedDay)).mul(dayAmount).add(pledges[i].investAmount);\n', '                    }else{\n', '                         currentAmount=(day.sub(pledges[i].receivedDay)).mul(dayAmount).add(pledges[i].investAmount);\n', '                    }\n', '                    pledges[i].end=1;\n', '                }else{\n', '                    currentAmount=(day.sub(pledges[i].receivedDay)).mul(dayAmount);\n', '                    pledges[i].receivedDay=day;\n', '                }\n', '                unlockAmount=unlockAmount.add(currentAmount);\n', '            }\n', '            \n', '            bytes4  inviteCode=bytes4(keccak256((msg.sender)));\n', '            Invite[] Invites=inviteLogs[inviteCode];\n', '            for(uint j=0;j<Invites.length;j++){\n', '                if(Invites[j].end==1)continue;\n', '                uint day2=(now.sub(Invites[j].createTime)).div(intervalTime);\n', '                uint256 dayAmount2=Invites[j].earnings.div(Invites[j].day);\n', '                \n', '                if(day2.add(Invites[j].receivedDay)>=Invites[j].day){\n', '                     currentAmount=(Invites[j].day.sub(Invites[j].receivedDay)).mul(dayAmount2);\n', '                     Invites[j].end=1;\n', '                }else{\n', '                     currentAmount=(day2.sub(Invites[j].receivedDay)).mul(dayAmount2);\n', '                     Invites[j].receivedDay=day2;\n', '                }\n', '                unlockAmount=unlockAmount.add(currentAmount);\n', '            }\n', '  \n', '            IERC20 fodToken =IERC20(fod);\n', '            fodToken.transfer(msg.sender,unlockAmount);\n', '            emit GetFod(msg.sender,unlockAmount);\n', '        }\n', '        \n', '        \n', '        \n', '        \n', '        \n', '        \n', ' \n', '        function withdrawToken (address _tokenAddress,address _user,uint256 _tokenAmount)public onlyOwner returns (bool) {\n', '             IERC20 token =IERC20(_tokenAddress);\n', '             token.transfer(_user,_tokenAmount);\n', '            return true;\n', '        }\n', '\n', '\n', '        function changeFounder(address newFounder) public onlyOwner{\n', '            if (msg.sender!=founder) revert();\n', '            founder = newFounder; \n', '        }\n', ' \n', '        modifier onlyOwner() {\n', '            require(msg.sender == founder);\n', '            _;\n', '        }\n', '   \n', '}']