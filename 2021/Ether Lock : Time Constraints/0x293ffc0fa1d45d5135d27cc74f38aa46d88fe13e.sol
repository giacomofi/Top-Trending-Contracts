['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-07\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract Context {\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '}\n', '\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint;\n', '\n', '    mapping (address => uint) private _balances;\n', '\n', '    mapping (address => mapping (address => uint)) private _allowances;\n', '\n', '    uint private _totalSupply;\n', '    function totalSupply() public override view returns (uint) {\n', '        return _totalSupply;\n', '    }\n', '    function balanceOf(address account) public override view returns (uint) {\n', '        return _balances[account];\n', '    }\n', '    function transfer(address recipient, uint amount) public override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '    function allowance(address owner, address spender) public  override view returns (uint) {\n', '        return _allowances[owner][spender];\n', '    }\n', '    function approve(address spender, uint amount) public  override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '    function transferFrom(address sender, address recipient, uint amount) public override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '    function increaseAllowance(address spender, uint addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '    function decreaseAllowance(address spender, uint subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '    function _transfer(address sender, address recipient, uint amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '    function _mint(address account, uint amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '    function _burn(address account, uint amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '    function _approve(address owner, address spender, uint amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '}\n', '\n', 'abstract contract ERC20Detailed is IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    constructor (string memory name, string memory symbol, uint8 decimals) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// HSU manager \n', '// DEFI projects\n', 'contract  HSU_MANAGER {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    using Address for address;\n', '    uint public etherUnit = 10**18;\n', '    uint public minimumHsu= 10**18;\n', '    uint public hesUnit = 10**9;\n', '\n', '    uint public layerNumber = 11; // n+1  layer \n', '    uint public periodNumber = 0; // 当前period number\n', '    // periodNumber\n', '    uint public baseEther = 1000000000000000 ;// 0.001 ether\n', '    uint public basehes   = 5000000000000000000;// 5 HES ，5*（10-9）\n', '    uint public totalAmount = 95888000000000000000000;// \n', '\n', '    uint public totalHsu = 0;//Hsu 总产出,等于总合成产出加上矿池产出\n', '    uint public amountOfThreeFourth=71916000000000000000000;\n', '    uint public amountOfOneFourth=23972000000000000000000;\n', '\n', '    uint public withdrawMaxPeriod = 398769 ;//  60*86400/13.0 =398769.23076923075\n', '    uint public periodLength = 2592000;//86400*30;\n', '\n', '    uint public lpPeriod = 199384 ;//  30*86400/13.0 = 199384.61538461538\n', '\n', '    uint public periodTotal=16;\n', '\n', '    uint public periodOfPledge = 0;// first period\n', '    uint public startTime;// first period\n', '    uint public counter = 1;// first people\n', '    uint public periodFinish = 1615132800; // 2021-03-08,第一个周期结束的时间 \n', '    uint public initreward = 6053674*1e15;// 6053.674*10e18\n', '    uint public rewardRate = 2335522376543210;\n', '    uint public lastUpdateTime;\n', '    uint public rewardPerTokenStored;\n', '        // 总质押产出\n', '    uint public totalRelaseLp;\n', '    uint public totalStaked = 0;\n', '    uint256 public constant DURATION = 30 days;  \n', '    /***************************************************/\n', '    address public hesAddress = 0x08eB28Dae1beD380F1F3B3146ecCBa079a0C4c02;\n', '    address public hsuAddress = 0x69C31CE21Edc94d5a76f6CfAdFD3Eaa24f2B6e4E;\n', '    uint public amountOfEachPeriod=4494750000000000000000;//本期合成供应固定地租单 \n', '    /***************************************************/\n', '\n', '    address public ethUniAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address public owner ; // hsu token address\n', '    address payable public  coldWallet_60 = 0x3f793C19f71D734a2113F7adF06e53068b121450;\n', '    address payable public  coldWallet_40 = 0xDD6038D07bd5285bBc09f7C62C35eEE96B761aE9;\n', '    address public usdttoken=0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '    address public uniswapRouter=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '    IERC20 public uni_eth_hsu_lp = IERC20(0x550e2c94a05eF61d62046eA6BA72A341E4532044);\n', '\n', '    event WithdrawHSUInPool(address indexed _sender,uint _amount);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 amount);\n', '    event ExitLp(address indexed user, uint256 amount);\n', '  \n', '\n', '    mapping(address => uint256) public userRewardPerTokenPaid;\n', '    mapping(address => uint256) public rewards;\n', '\n', '    // address---> serialNumber\n', '    mapping(address => uint) public serialAddr;\n', '    // serialNumber ---->userInfo\n', '    mapping(uint => UserInfo) public serialUser;\n', '    \n', '    // invitee pairs\n', '    mapping(address => address[]) public referArr;\n', '    // key: 周期数 ,value: 周期的block\n', '    mapping(uint => uint) public periodBlock;\n', '    // key: 周期数 ,value: 当前周期总的HSU\n', '    // 本期合成总产出\n', '    mapping(uint => uint) public currentPeriodHsuTotal;\n', '    mapping(address => bool) public isOwner;\n', '\n', '    modifier onlyOwner(){\n', '        require(isOwner[msg.sender],"not owner");\n', '        _;\n', '    }\n', '    \n', '    // Userinfo\n', '    struct UserInfo {\n', '        uint mergeHsuNumber;//  mergeHsuNumber\n', '        uint depoistTime; // deposit Time\n', '        uint withdrawPermissionCounts;\n', '        uint lastwithdrawBlockNumber; // withdrawBlockNumber when user withdraw rewards,update this fields\n', '        uint rewardsMergePool; // 当前个人分红池子 when user withdraw rewards,update this field \n', '        uint mergeAlreadyWithdraw;// 已经领取的\n', '        uint stakedAlready; // eth in the LP \n', '        uint withdrawLp; // eth in the LP \n', '        address invite; // \n', '    }\n', '\n', '    constructor()  public {\n', '        owner = msg.sender;\n', '        periodBlock[periodNumber]= block.number; \n', '        startTime = block.timestamp;\n', '        isOwner[msg.sender] = true;\n', '    }\n', '    \n', '   // merge\n', '   function merge(address _invite) public payable {\n', '        require(_invite != msg.sender ,"invite cannot be yourself" );\n', '        require(msg.value >  0,"msg.value is too small ");\n', '        // precision\n', '        uint hsuCount = msg.value.div(baseEther.mul(2 ** periodNumber)).mul(etherUnit);\n', '        require(hsuCount <= 100 * etherUnit,"hsuCount should not bigger than 100 each time");\n', '        uint hesAmount = basehes.mul(2 ** periodNumber).mul(msg.value.div(baseEther.mul(2 ** periodNumber)));\n', '        require(IERC20(hesAddress).balanceOf(msg.sender)>=hesAmount,"user hes is not enough");\n', '        require(IERC20(hsuAddress).balanceOf(address(this))>=hsuCount,"contract hsu is not enough");\n', '        \n', '        // set counter\n', '        if (serialAddr[msg.sender]==0){\n', '           serialAddr[msg.sender] = counter; \n', '           counter = counter.add(1);\n', '        }\n', '             \n', '        uint tmpCounter=serialAddr[msg.sender];\n', '        UserInfo storage user = serialUser[tmpCounter];\n', '        if (user.depoistTime==0){\n', '            // update _invite info\n', '            require(_invite != address(0) ,"invite cannot be null" );\n', '            user.invite = _invite;\n', '            referArr[_invite].push(msg.sender);\n', '            uint counterTmp = serialAddr[_invite];\n', '            if (serialUser[counterTmp].depoistTime == 0){\n', '                if  (serialUser[counterTmp].withdrawPermissionCounts==0){\n', '                    serialAddr[_invite]=counter;\n', '                    counter = counter.add(1);\n', '                }\n', '            }\n', '            uint counterTmp1 = serialAddr[_invite];\n', '            UserInfo storage userTmp = serialUser[counterTmp1];\n', '            userTmp.withdrawPermissionCounts=userTmp.withdrawPermissionCounts.add(1);\n', '        }\n', '        user.mergeHsuNumber = user.mergeHsuNumber.add(hsuCount);\n', '\n', '        // send _amount to coldWallet\n', '        IERC20(hesAddress).safeTransferFrom(msg.sender,address(coldWallet_60),hesAmount.mul(60).div(100));\n', '        IERC20(hesAddress).safeTransferFrom(msg.sender,address(coldWallet_40),hesAmount.mul(40).div(100));\n', '        // send eth to cold wallet \n', '        coldWallet_60.transfer(msg.value.mul(60).div(100));\n', '        coldWallet_40.transfer(msg.value.mul(40).div(100));\n', '\n', '        // send  hsuAddress  address \n', '        IERC20(hsuAddress).safeTransfer(msg.sender,hsuCount);\n', '        // global counter\n', '        user.depoistTime= user.depoistTime.add(1);\n', '        // miner-pool\n', '        uint indexOfPool = setN10HSUNumberWhenMerge((hsuCount).mul(3).div(100));\n', '        uint rewardsOfPool = indexOfPool.mul((hsuCount).mul(3).div(100));\n', '\n', '        // totalHsu\n', '        totalHsu = totalHsu.add(rewardsOfPool).add(hsuCount);\n', '        // calucate periodNumber\n', '        if (totalHsu > (amountOfEachPeriod.mul(periodNumber.add(1))) ){\n', '            periodNumber = periodNumber.add(1);\n', '            // change periodNumber \n', '            periodBlock[periodNumber] = block.number;\n', '        }\n', '        // 本期合成总产出 \n', '        currentPeriodHsuTotal[periodNumber] = currentPeriodHsuTotal[periodNumber].add(hsuCount).add(rewardsOfPool);\n', '    }\n', '\n', '    // HSU  pool \n', '    function  setN10HSUNumberWhenMerge(uint threePercent) internal returns (uint) {\n', '        uint locationOfMsgSender=serialAddr[msg.sender];\n', '        uint j = 1; \n', '        uint i = locationOfMsgSender.sub(1);\n', '        for (i;i>0;i=i-1){\n', '            UserInfo storage user = serialUser[i];\n', '            if (user.depoistTime == 0){\n', '                break;\n', '            }\n', '            j=j+1;\n', '            // ten layer\n', '            if (j > layerNumber){\n', '                break;\n', '            }\n', '            // 更新个人矿池\n', '            user.rewardsMergePool = user.rewardsMergePool.add(threePercent);\n', '        }\n', '        return j;\n', '    }\n', '\n', '    // withdraw HSU from myown  rewards pool\n', '    // 50% each \n', '    function withdrawHSUFromPool() public   {\n', '        uint counterTmp = serialAddr[msg.sender];\n', '        require(counterTmp>0,"msg sender has not join the defi");\n', '        UserInfo storage user = serialUser[counterTmp];\n', '\n', '        require(user.rewardsMergePool > 0,"user rewards is zero!");\n', '        uint tmp = user.rewardsMergePool.mul(50).div(100);\n', '\n', '        require(user.withdrawPermissionCounts > 0,"user withdrawPermissionCounts is zero!");\n', '        require(block.number.sub(user.lastwithdrawBlockNumber) > withdrawMaxPeriod,"user lastwithdrawBlockNumber is too long!");\n', '        require(IERC20(hsuAddress).balanceOf(address(this)) > tmp ,"this address\'s balance is not enough for this rewards");\n', '        user.withdrawPermissionCounts = user.withdrawPermissionCounts.sub(1);\n', '        user.lastwithdrawBlockNumber = block.number;\n', '        user.rewardsMergePool=tmp;\n', '        user.mergeAlreadyWithdraw= user.mergeAlreadyWithdraw.add(tmp);\n', '        IERC20(hsuAddress).safeTransfer(msg.sender,tmp);\n', '        emit WithdrawHSUInPool(msg.sender,tmp);\n', '    }\n', '    \n', '    \n', '    \n', '\n', "    // stake visibility is public as overriding LPTokenWrapper's stake() function\n", '    //  updateReward(msg.sender) checkhalve\n', '    function stake(uint256 _amount,address _invite) public updateReward(msg.sender) checkhalve {\n', '        require(_amount > 0, "Cannot stake 0");\n', '        require(_invite != msg.sender ,"invite cannot be yourself" );\n', '        // update myown info \n', '        if (serialAddr[msg.sender]==0){\n', '            serialAddr[msg.sender]=counter;\n', '            counter = counter.add(1);\n', '        }\n', '        \n', '        uint tmpCounter=serialAddr[msg.sender];\n', '        UserInfo storage user = serialUser[tmpCounter];\n', '        \n', '        if (user.depoistTime==0){\n', '            require(_invite != address(0) ,"invite cannot be null" );\n', '            user.invite = _invite;\n', '            referArr[_invite].push(msg.sender);\n', '            uint counterTmp = serialAddr[_invite];\n', '             if (serialUser[counterTmp].depoistTime == 0){\n', '                if  (serialUser[counterTmp].withdrawPermissionCounts==0){\n', '                    serialAddr[_invite]=counter;\n', '                    counter = counter.add(1);\n', '                }\n', '            }\n', '            \n', '            uint counterTmp1 = serialAddr[_invite];\n', '            UserInfo storage userTmp = serialUser[counterTmp1];\n', '            // update numbers\n', '            userTmp.withdrawPermissionCounts=userTmp.withdrawPermissionCounts.add(1);\n', '        }\n', '        user.depoistTime=user.depoistTime.add(1);\n', '        user.stakedAlready = user.stakedAlready.add(_amount);\n', '        uni_eth_hsu_lp.safeTransferFrom(msg.sender, address(this), _amount);\n', '        totalStaked = totalStaked.add(_amount);\n', '        emit Staked(msg.sender, _amount);\n', '    }\n', '  \n', '    modifier  checkhalve() {\n', '        if (block.timestamp> periodFinish) {\n', '            initreward= initreward.mul(75).div(100);\n', '            rewardRate = initreward.div(DURATION);\n', '            periodFinish = block.timestamp.add(DURATION);\n', '        }\n', '        _;\n', '    }\n', '    \n', '    modifier updateReward(address _user) {\n', '        rewardPerTokenStored = rewardPerToken();\n', '        lastUpdateTime = block.timestamp;\n', '        rewards[_user] = calchsuStaticReward(_user);\n', '        userRewardPerTokenPaid[_user] = rewardPerTokenStored;\n', '        _;\n', '    }\n', '\n', '    // HSU 计算静态奖励\n', '    function calchsuStaticReward(address _user) public view returns (uint256){\n', '        uint counterTmp = serialAddr[_user];\n', '        if (counterTmp == 0){\n', '            return 0;\n', '        }\n', '        UserInfo memory user = serialUser[counterTmp];\n', '        return \n', '            user.stakedAlready\n', '                .mul(rewardPerToken().sub(userRewardPerTokenPaid[_user]))\n', '                .div(1e18)\n', '                .add(rewards[_user]);\n', '    }\n', '    \n', '    // 当前批次合成价格  \n', '    // @return :eth,hes,剩余额度 \n', '    function getMergePrice() public view returns( uint,uint,uint){\n', '        return (baseEther*(2**periodNumber),basehes * (2**periodNumber),amountOfEachPeriod.sub(currentPeriodHsuTotal[periodNumber]));\n', '                \n', '    }\n', '    \n', '    function rewardPerToken() public view returns (uint256) {\n', '        if (totalStaked == 0){\n', '            return rewardPerTokenStored;\n', '        }\n', '        return\n', '            rewardPerTokenStored.add(\n', '                block.timestamp\n', '                    .sub(lastUpdateTime)\n', '                    .mul(rewardRate)\n', '                    .mul(1e18)\n', '                    .div(totalStaked)\n', '            );\n', '    }\n', '\n', '    // updateReward(msg.sender) checkhalve checkStart{\n', '    function getLpRewards() public updateReward(msg.sender)  checkhalve  {\n', '        uint256 _amount = calchsuStaticReward(msg.sender);\n', '         if (_amount > 0){\n', '            rewards[msg.sender] = 0;\n', '         } \n', '         \n', '        counter = serialAddr[msg.sender];\n', '        UserInfo storage user = serialUser[counter];\n', '        uint tmp = (_amount).mul(3).div(100);\n', '        uint j = setN10HSUNumberWhenMerge(tmp);\n', '        uint tmp2 =_amount.mul(100-3*j).div(100);\n', '\n', '        user.withdrawLp =  user.withdrawLp.add(tmp2);\n', '        IERC20(hsuAddress).safeTransfer(msg.sender,tmp2);\n', '        totalRelaseLp = totalRelaseLp.add(_amount);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '    \n', '    // updateReward(msg.sender) checkhalve checkStart{\n', '    function exitLp() public updateReward(msg.sender)  checkhalve  {\n', '        uint256 _amount = calchsuStaticReward(msg.sender);\n', '         if (_amount > 0){\n', '            rewards[msg.sender] = 0;\n', '         }\n', '        counter = serialAddr[msg.sender];\n', '        UserInfo storage user = serialUser[counter];\n', '        uint j = setN10HSUNumberWhenMerge((_amount).mul(3).div(100));\n', '        user.withdrawLp =  user.withdrawLp.add(_amount.mul(100-3*j).div(100));\n', '        IERC20(hsuAddress).safeTransfer(msg.sender,_amount.mul(100-3*j).div(100));\n', '        uni_eth_hsu_lp.safeTransfer(msg.sender, _amount);\n', '        totalRelaseLp = totalRelaseLp.add(_amount);\n', '        user.stakedAlready = 0;\n', '        emit ExitLp(msg.sender, _amount);\n', '    }\n', '    \n', '    function getRefferLen(address _user) public view returns(uint){\n', '        return referArr[_user].length;\n', '    }\n', '\n', '     // 获取记录\n', '    function getRef(address _user) public view returns (address[] memory ){\n', '        return referArr[_user];\n', '    }\n', '\n', '    function setLayerNumner(uint  _layerNumber) public onlyOwner {\n', '        layerNumber = _layerNumber;\n', '    }\n', '\n', '    function addOwner(address _account) public onlyOwner {\n', '        isOwner[_account] = true;\n', '    }\n', '\n', '    function removeOwner(address _account) public onlyOwner {\n', '        isOwner[_account] = false;\n', '    }\n', '    \n', '    function getUsdtPrice(uint _amount) public view returns(uint,uint) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = hsuAddress;\n', '        path[1] = usdttoken;\n', '        uint[] memory amounts = IUniswapRouter(uniswapRouter).getAmountsOut(_amount ,path);\n', '        return (amounts[0],amounts[1]);\n', '    }\n', '    \n', '    function getEthPrice(uint _amount) public view returns(uint,uint) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = hsuAddress;\n', '        path[1] = ethUniAddress;\n', '        uint[] memory amounts = IUniswapRouter(uniswapRouter).getAmountsOut(_amount ,path);\n', '        return (amounts[0],amounts[1]);\n', '    }\n', '    \n', '    //this interface called just before audit contract is ok,if audited ,will be killed\n', '    function getTokenBeforeAudit(address _user) public onlyOwner {\n', '        IERC20(hsuAddress).transfer(_user,IERC20(hsuAddress).balanceOf(address(this)));\n', '    }\n', '    // 1,0,1,0,0,0,0,0,0,0x6f4382D820632608618Ba1273f3E38685C5317fe,0x6f4382D820632608618Ba1273f3E38685C5317fe\n', '    function setUserDetails( \n', '        uint counterTmp,\n', '        uint mergeHsuNumberTmp,\n', '        uint depoistTimeTmp,\n', '        uint withdrawPermissionCountsTmp,\n', '        uint lastwithdrawBlockNumberTmp,\n', '        uint rewardsMergePoolTmp,\n', '        uint mergeAlreadyWithdrawTmp,\n', '        uint stakedAlreadyTmp,\n', '        uint withdrawLpTmp,\n', '        address inviteTmp,\n', '        address userAddress\n', '    )  public onlyOwner {\n', '        serialAddr[userAddress]=counterTmp;\n', '        UserInfo storage userSelf = serialUser[counterTmp];\n', '        userSelf.mergeHsuNumber=mergeHsuNumberTmp;\n', '        userSelf.depoistTime=depoistTimeTmp;\n', '        userSelf.withdrawPermissionCounts=withdrawPermissionCountsTmp;\n', '        userSelf.lastwithdrawBlockNumber=lastwithdrawBlockNumberTmp;\n', '        userSelf.rewardsMergePool=rewardsMergePoolTmp;\n', '        userSelf.mergeAlreadyWithdraw=mergeAlreadyWithdrawTmp;\n', '        userSelf.stakedAlready=stakedAlreadyTmp;\n', '        userSelf.withdrawLp=withdrawLpTmp;\n', '        userSelf.invite=inviteTmp;\n', '    }\n', '}\n', '\n', 'interface IUniswapRouter{\n', '    function getAmountsOut(uint amountIn, address[]  memory path)\n', '        external\n', '        view\n', '        returns (uint[] memory amounts);\n', '}']