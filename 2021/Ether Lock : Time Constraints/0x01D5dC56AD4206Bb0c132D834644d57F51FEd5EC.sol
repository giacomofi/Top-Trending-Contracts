['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-26\n', '*/\n', '\n', '// File: contracts/common/governance/IGovernance.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'interface IGovernance {\n', '    function update(address target, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts/common/governance/Governable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract Governable {\n', '    IGovernance public governance;\n', '\n', '    constructor(address _governance) public {\n', '        governance = IGovernance(_governance);\n', '    }\n', '\n', '    modifier onlyGovernance() {\n', '        _assertGovernance();\n', '        _;\n', '    }\n', '\n', '    function _assertGovernance() private view {\n', '        require(\n', '            msg.sender == address(governance),\n', '            "Only governance contract is authorized"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/root/withdrawManager/IWithdrawManager.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract IWithdrawManager {\n', '    function createExitQueue(address token) external;\n', '\n', '    function verifyInclusion(\n', '        bytes calldata data,\n', '        uint8 offset,\n', '        bool verifyTxInclusion\n', '    ) external view returns (uint256 age);\n', '\n', '    function addExitToQueue(\n', '        address exitor,\n', '        address childToken,\n', '        address rootToken,\n', '        uint256 exitAmountOrTokenId,\n', '        bytes32 txHash,\n', '        bool isRegularExit,\n', '        uint256 priority\n', '    ) external;\n', '\n', '    function addInput(\n', '        uint256 exitId,\n', '        uint256 age,\n', '        address utxoOwner,\n', '        address token\n', '    ) external;\n', '\n', '    function challengeExit(\n', '        uint256 exitId,\n', '        uint256 inputId,\n', '        bytes calldata challengeData,\n', '        address adjudicatorPredicate\n', '    ) external;\n', '}\n', '\n', '// File: contracts/common/Registry.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', 'contract Registry is Governable {\n', '    // @todo hardcode constants\n', '    bytes32 private constant WETH_TOKEN = keccak256("wethToken");\n', '    bytes32 private constant DEPOSIT_MANAGER = keccak256("depositManager");\n', '    bytes32 private constant STAKE_MANAGER = keccak256("stakeManager");\n', '    bytes32 private constant VALIDATOR_SHARE = keccak256("validatorShare");\n', '    bytes32 private constant WITHDRAW_MANAGER = keccak256("withdrawManager");\n', '    bytes32 private constant CHILD_CHAIN = keccak256("childChain");\n', '    bytes32 private constant STATE_SENDER = keccak256("stateSender");\n', '    bytes32 private constant SLASHING_MANAGER = keccak256("slashingManager");\n', '\n', '    address public erc20Predicate;\n', '    address public erc721Predicate;\n', '\n', '    mapping(bytes32 => address) public contractMap;\n', '    mapping(address => address) public rootToChildToken;\n', '    mapping(address => address) public childToRootToken;\n', '    mapping(address => bool) public proofValidatorContracts;\n', '    mapping(address => bool) public isERC721;\n', '\n', '    enum Type {Invalid, ERC20, ERC721, Custom}\n', '    struct Predicate {\n', '        Type _type;\n', '    }\n', '    mapping(address => Predicate) public predicates;\n', '\n', '    event TokenMapped(address indexed rootToken, address indexed childToken);\n', '    event ProofValidatorAdded(address indexed validator, address indexed from);\n', '    event ProofValidatorRemoved(address indexed validator, address indexed from);\n', '    event PredicateAdded(address indexed predicate, address indexed from);\n', '    event PredicateRemoved(address indexed predicate, address indexed from);\n', '    event ContractMapUpdated(bytes32 indexed key, address indexed previousContract, address indexed newContract);\n', '\n', '    constructor(address _governance) public Governable(_governance) {}\n', '\n', '    function updateContractMap(bytes32 _key, address _address) external onlyGovernance {\n', '        emit ContractMapUpdated(_key, contractMap[_key], _address);\n', '        contractMap[_key] = _address;\n', '    }\n', '\n', '    /**\n', '     * @dev Map root token to child token\n', '     * @param _rootToken Token address on the root chain\n', '     * @param _childToken Token address on the child chain\n', '     * @param _isERC721 Is the token being mapped ERC721\n', '     */\n', '    function mapToken(\n', '        address _rootToken,\n', '        address _childToken,\n', '        bool _isERC721\n', '    ) external onlyGovernance {\n', '        require(_rootToken != address(0x0) && _childToken != address(0x0), "INVALID_TOKEN_ADDRESS");\n', '        rootToChildToken[_rootToken] = _childToken;\n', '        childToRootToken[_childToken] = _rootToken;\n', '        isERC721[_rootToken] = _isERC721;\n', '        IWithdrawManager(contractMap[WITHDRAW_MANAGER]).createExitQueue(_rootToken);\n', '        emit TokenMapped(_rootToken, _childToken);\n', '    }\n', '\n', '    function addErc20Predicate(address predicate) public onlyGovernance {\n', '        require(predicate != address(0x0), "Can not add null address as predicate");\n', '        erc20Predicate = predicate;\n', '        addPredicate(predicate, Type.ERC20);\n', '    }\n', '\n', '    function addErc721Predicate(address predicate) public onlyGovernance {\n', '        erc721Predicate = predicate;\n', '        addPredicate(predicate, Type.ERC721);\n', '    }\n', '\n', '    function addPredicate(address predicate, Type _type) public onlyGovernance {\n', '        require(predicates[predicate]._type == Type.Invalid, "Predicate already added");\n', '        predicates[predicate]._type = _type;\n', '        emit PredicateAdded(predicate, msg.sender);\n', '    }\n', '\n', '    function removePredicate(address predicate) public onlyGovernance {\n', '        require(predicates[predicate]._type != Type.Invalid, "Predicate does not exist");\n', '        delete predicates[predicate];\n', '        emit PredicateRemoved(predicate, msg.sender);\n', '    }\n', '\n', '    function getValidatorShareAddress() public view returns (address) {\n', '        return contractMap[VALIDATOR_SHARE];\n', '    }\n', '\n', '    function getWethTokenAddress() public view returns (address) {\n', '        return contractMap[WETH_TOKEN];\n', '    }\n', '\n', '    function getDepositManagerAddress() public view returns (address) {\n', '        return contractMap[DEPOSIT_MANAGER];\n', '    }\n', '\n', '    function getStakeManagerAddress() public view returns (address) {\n', '        return contractMap[STAKE_MANAGER];\n', '    }\n', '\n', '    function getSlashingManagerAddress() public view returns (address) {\n', '        return contractMap[SLASHING_MANAGER];\n', '    }\n', '\n', '    function getWithdrawManagerAddress() public view returns (address) {\n', '        return contractMap[WITHDRAW_MANAGER];\n', '    }\n', '\n', '    function getChildChainAndStateSender() public view returns (address, address) {\n', '        return (contractMap[CHILD_CHAIN], contractMap[STATE_SENDER]);\n', '    }\n', '\n', '    function isTokenMapped(address _token) public view returns (bool) {\n', '        return rootToChildToken[_token] != address(0x0);\n', '    }\n', '\n', '    function isTokenMappedAndIsErc721(address _token) public view returns (bool) {\n', '        require(isTokenMapped(_token), "TOKEN_NOT_MAPPED");\n', '        return isERC721[_token];\n', '    }\n', '\n', '    function isTokenMappedAndGetPredicate(address _token) public view returns (address) {\n', '        if (isTokenMappedAndIsErc721(_token)) {\n', '            return erc721Predicate;\n', '        }\n', '        return erc20Predicate;\n', '    }\n', '\n', '    function isChildTokenErc721(address childToken) public view returns (bool) {\n', '        address rootToken = childToRootToken[childToken];\n', '        require(rootToken != address(0x0), "Child token is not mapped");\n', '        return isERC721[rootToken];\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '/**\n', ' * @title Standard ERC20 token\n', ' *\n', ' * @dev Implementation of the basic standard token.\n', ' * https://eips.ethereum.org/EIPS/eip-20\n', ' * Originally based on code by FirstBlood:\n', ' * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n', ' *\n', ' * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n', " * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n", ' * compliant implementations may not do it.\n', ' */\n', 'contract ERC20 is IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev Total number of tokens in existence\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param owner The address to query the balance of.\n', '     * @return A uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token to a specified address\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 value) public returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n', '     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n', "     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n", '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     * @param spender The address which will spend the funds.\n', '     * @param value The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 value) public returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another.\n', '     * Note that while this function emits an Approval event, this is not required as per the specification,\n', '     * and other compliant implementations may not emit the event.\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to tr vbmansfer to\n', '     * @param value uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n', '        _transfer(from, to, value);\n', '        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Increase the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param addedValue The amount of tokens to increase the allowance by.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n', '     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n', '     * allowed value is better to use this function to avoid 2 calls (and wait until\n', '     * the first transaction is mined)\n', '     * From MonolithDAO Token.sol\n', '     * Emits an Approval event.\n', '     * @param spender The address which will spend the funds.\n', '     * @param subtractedValue The amount of tokens to decrease the allowance by.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer token for a specified addresses\n', '     * @param from The address to transfer from.\n', '     * @param to The address to transfer to.\n', '     * @param value The amount to be transferred.\n', '     */\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        require(to != address(0));\n', '\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that mints an amount of the token and assigns it to\n', '     * an account. This encapsulates the modification of balances such that the\n', '     * proper events are emitted.\n', '     * @param account The account that will receive the created tokens.\n', '     * @param value The amount that will be created.\n', '     */\n', '    function _mint(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.add(value);\n', '        _balances[account] = _balances[account].add(value);\n', '        emit Transfer(address(0), account, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', '     * account.\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burn(address account, uint256 value) internal {\n', '        require(account != address(0));\n', '\n', '        _totalSupply = _totalSupply.sub(value);\n', '        _balances[account] = _balances[account].sub(value);\n', '        emit Transfer(account, address(0), value);\n', '    }\n', '\n', '    /**\n', "     * @dev Approve an address to spend another addresses' tokens.\n", '     * @param owner The address that owns the tokens.\n', '     * @param spender The address that will spend the tokens.\n', '     * @param value The number of tokens that can be spent.\n', '     */\n', '    function _approve(address owner, address spender, uint256 value) internal {\n', '        require(spender != address(0));\n', '        require(owner != address(0));\n', '\n', '        _allowed[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function that burns an amount of the token of a given\n', "     * account, deducting from the sender's allowance for said account. Uses the\n", '     * internal burn function.\n', '     * Emits an Approval event (reflecting the reduced allowance).\n', '     * @param account The account whose tokens will be burnt.\n', '     * @param value The amount that will be burnt.\n', '     */\n', '    function _burnFrom(address account, uint256 value) internal {\n', '        _burn(account, value);\n', '        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n', '    }\n', '}\n', '\n', '// File: contracts/common/tokens/ERC20NonTradable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', 'contract ERC20NonTradable is ERC20 {\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        revert("disabled");\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     * @notice Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/StakingInfo.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', '\n', '\n', '// dummy interface to avoid cyclic dependency\n', 'contract IStakeManagerLocal {\n', '    enum Status {Inactive, Active, Locked, Unstaked}\n', '\n', '    struct Validator {\n', '        uint256 amount;\n', '        uint256 reward;\n', '        uint256 activationEpoch;\n', '        uint256 deactivationEpoch;\n', '        uint256 jailTime;\n', '        address signer;\n', '        address contractAddress;\n', '        Status status;\n', '    }\n', '\n', '    mapping(uint256 => Validator) public validators;\n', '    bytes32 public accountStateRoot;\n', '    uint256 public activeAmount; // delegation amount from validator contract\n', '    uint256 public validatorRewards;\n', '\n', '    function currentValidatorSetTotalStake() public view returns (uint256);\n', '\n', '    // signer to Validator mapping\n', '    function signerToValidator(address validatorAddress)\n', '        public\n', '        view\n', '        returns (uint256);\n', '\n', '    function isValidator(uint256 validatorId) public view returns (bool);\n', '}\n', '\n', 'contract StakingInfo is Ownable {\n', '    using SafeMath for uint256;\n', '    mapping(uint256 => uint256) public validatorNonce;\n', '\n', "    /// @dev Emitted when validator stakes in '_stakeFor()' in StakeManager.\n", '    /// @param signer validator address.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', "    /// @param activationEpoch validator's first epoch as proposer.\n", '    /// @param amount staking amount.\n', '    /// @param total total staking amount.\n', '    /// @param signerPubkey public key of the validator\n', '    event Staked(\n', '        address indexed signer,\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        uint256 indexed activationEpoch,\n', '        uint256 amount,\n', '        uint256 total,\n', '        bytes signerPubkey\n', '    );\n', '\n', "    /// @dev Emitted when validator unstakes in 'unstakeClaim()'\n", '    /// @param user address of the validator.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param amount staking amount.\n', '    /// @param total total staking amount.\n', '    event Unstaked(\n', '        address indexed user,\n', '        uint256 indexed validatorId,\n', '        uint256 amount,\n', '        uint256 total\n', '    );\n', '\n', "    /// @dev Emitted when validator unstakes in '_unstake()'.\n", '    /// @param user address of the validator.\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param deactivationEpoch last epoch for validator.\n', '    /// @param amount staking amount.\n', '    event UnstakeInit(\n', '        address indexed user,\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        uint256 deactivationEpoch,\n', '        uint256 indexed amount\n', '    );\n', '\n', "    /// @dev Emitted when the validator public key is updated in 'updateSigner()'.\n", '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param oldSigner old address of the validator.\n', '    /// @param newSigner new address of the validator.\n', '    /// @param signerPubkey public key of the validator.\n', '    event SignerChange(\n', '        uint256 indexed validatorId,\n', '        uint256 nonce,\n', '        address indexed oldSigner,\n', '        address indexed newSigner,\n', '        bytes signerPubkey\n', '    );\n', '    event Restaked(uint256 indexed validatorId, uint256 amount, uint256 total);\n', '    event Jailed(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed exitEpoch,\n', '        address indexed signer\n', '    );\n', '    event UnJailed(uint256 indexed validatorId, address indexed signer);\n', '    event Slashed(uint256 indexed nonce, uint256 indexed amount);\n', '    event ThresholdChange(uint256 newThreshold, uint256 oldThreshold);\n', '    event DynastyValueChange(uint256 newDynasty, uint256 oldDynasty);\n', '    event ProposerBonusChange(\n', '        uint256 newProposerBonus,\n', '        uint256 oldProposerBonus\n', '    );\n', '\n', '    event RewardUpdate(uint256 newReward, uint256 oldReward);\n', '\n', '    /// @dev Emitted when validator confirms the auction bid and at the time of restaking in confirmAuctionBid() and restake().\n', '    /// @param validatorId unique integer to identify a validator.\n', '    /// @param nonce to synchronize the events in heimdal.\n', '    /// @param newAmount the updated stake amount.\n', '    event StakeUpdate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed nonce,\n', '        uint256 indexed newAmount\n', '    );\n', '    event ClaimRewards(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed amount,\n', '        uint256 indexed totalAmount\n', '    );\n', '    event StartAuction(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed amount,\n', '        uint256 indexed auctionAmount\n', '    );\n', '    event ConfirmAuction(\n', '        uint256 indexed newValidatorId,\n', '        uint256 indexed oldValidatorId,\n', '        uint256 indexed amount\n', '    );\n', '    event TopUpFee(address indexed user, uint256 indexed fee);\n', '    event ClaimFee(address indexed user, uint256 indexed fee);\n', '    // Delegator events\n', '    event ShareMinted(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens\n', '    );\n', '    event ShareBurned(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens\n', '    );\n', '    event DelegatorClaimedRewards(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed rewards\n', '    );\n', '    event DelegatorRestaked(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed totalStaked\n', '    );\n', '    event DelegatorUnstaked(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 amount\n', '    );\n', '    event UpdateCommissionRate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed newCommissionRate,\n', '        uint256 indexed oldCommissionRate\n', '    );\n', '\n', '    Registry public registry;\n', '\n', '    modifier onlyValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        (, , , , , , _contract, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '        require(_contract == msg.sender,\n', '        "Invalid sender, not validator");\n', '        _;\n', '    }\n', '\n', '    modifier StakeManagerOrValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        address _stakeManager = registry.getStakeManagerAddress();\n', '        (, , , , , , _contract, ) = IStakeManagerLocal(_stakeManager).validators(\n', '            validatorId\n', '        );\n', '        require(_contract == msg.sender || _stakeManager == msg.sender,\n', '        "Invalid sender, not stake manager or validator contract");\n', '        _;\n', '    }\n', '\n', '    modifier onlyStakeManager() {\n', '        require(registry.getStakeManagerAddress() == msg.sender,\n', '        "Invalid sender, not stake manager");\n', '        _;\n', '    }\n', '    modifier onlySlashingManager() {\n', '        require(registry.getSlashingManagerAddress() == msg.sender,\n', '        "Invalid sender, not slashing manager");\n', '        _;\n', '    }\n', '\n', '    constructor(address _registry) public {\n', '        registry = Registry(_registry);\n', '    }\n', '\n', '    function updateNonce(\n', '        uint256[] calldata validatorIds,\n', '        uint256[] calldata nonces\n', '    ) external onlyOwner {\n', '        require(validatorIds.length == nonces.length, "args length mismatch");\n', '\n', '        for (uint256 i = 0; i < validatorIds.length; ++i) {\n', '            validatorNonce[validatorIds[i]] = nonces[i];\n', '        }\n', '    } \n', '\n', '    function logStaked(\n', '        address signer,\n', '        bytes memory signerPubkey,\n', '        uint256 validatorId,\n', '        uint256 activationEpoch,\n', '        uint256 amount,\n', '        uint256 total\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit Staked(\n', '            signer,\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            activationEpoch,\n', '            amount,\n', '            total,\n', '            signerPubkey\n', '        );\n', '    }\n', '\n', '    function logUnstaked(\n', '        address user,\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 total\n', '    ) public onlyStakeManager {\n', '        emit Unstaked(user, validatorId, amount, total);\n', '    }\n', '\n', '    function logUnstakeInit(\n', '        address user,\n', '        uint256 validatorId,\n', '        uint256 deactivationEpoch,\n', '        uint256 amount\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit UnstakeInit(\n', '            user,\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            deactivationEpoch,\n', '            amount\n', '        );\n', '    }\n', '\n', '    function logSignerChange(\n', '        uint256 validatorId,\n', '        address oldSigner,\n', '        address newSigner,\n', '        bytes memory signerPubkey\n', '    ) public onlyStakeManager {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit SignerChange(\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            oldSigner,\n', '            newSigner,\n', '            signerPubkey\n', '        );\n', '    }\n', '\n', '    function logRestaked(uint256 validatorId, uint256 amount, uint256 total)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit Restaked(validatorId, amount, total);\n', '    }\n', '\n', '    function logJailed(uint256 validatorId, uint256 exitEpoch, address signer)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit Jailed(validatorId, exitEpoch, signer);\n', '    }\n', '\n', '    function logUnjailed(uint256 validatorId, address signer)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit UnJailed(validatorId, signer);\n', '    }\n', '\n', '    function logSlashed(uint256 nonce, uint256 amount)\n', '        public\n', '        onlySlashingManager\n', '    {\n', '        emit Slashed(nonce, amount);\n', '    }\n', '\n', '    function logThresholdChange(uint256 newThreshold, uint256 oldThreshold)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit ThresholdChange(newThreshold, oldThreshold);\n', '    }\n', '\n', '    function logDynastyValueChange(uint256 newDynasty, uint256 oldDynasty)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit DynastyValueChange(newDynasty, oldDynasty);\n', '    }\n', '\n', '    function logProposerBonusChange(\n', '        uint256 newProposerBonus,\n', '        uint256 oldProposerBonus\n', '    ) public onlyStakeManager {\n', '        emit ProposerBonusChange(newProposerBonus, oldProposerBonus);\n', '    }\n', '\n', '    function logRewardUpdate(uint256 newReward, uint256 oldReward)\n', '        public\n', '        onlyStakeManager\n', '    {\n', '        emit RewardUpdate(newReward, oldReward);\n', '    }\n', '\n', '    function logStakeUpdate(uint256 validatorId)\n', '        public\n', '        StakeManagerOrValidatorContract(validatorId)\n', '    {\n', '        validatorNonce[validatorId] = validatorNonce[validatorId].add(1);\n', '        emit StakeUpdate(\n', '            validatorId,\n', '            validatorNonce[validatorId],\n', '            totalValidatorStake(validatorId)\n', '        );\n', '    }\n', '\n', '    function logClaimRewards(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 totalAmount\n', '    ) public onlyStakeManager {\n', '        emit ClaimRewards(validatorId, amount, totalAmount);\n', '    }\n', '\n', '    function logStartAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        uint256 auctionAmount\n', '    ) public onlyStakeManager {\n', '        emit StartAuction(validatorId, amount, auctionAmount);\n', '    }\n', '\n', '    function logConfirmAuction(\n', '        uint256 newValidatorId,\n', '        uint256 oldValidatorId,\n', '        uint256 amount\n', '    ) public onlyStakeManager {\n', '        emit ConfirmAuction(newValidatorId, oldValidatorId, amount);\n', '    }\n', '\n', '    function logTopUpFee(address user, uint256 fee) public onlyStakeManager {\n', '        emit TopUpFee(user, fee);\n', '    }\n', '\n', '    function logClaimFee(address user, uint256 fee) public onlyStakeManager {\n', '        emit ClaimFee(user, fee);\n', '    }\n', '\n', '    function getStakerDetails(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (\n', '            uint256 amount,\n', '            uint256 reward,\n', '            uint256 activationEpoch,\n', '            uint256 deactivationEpoch,\n', '            address signer,\n', '            uint256 _status\n', '        )\n', '    {\n', '        IStakeManagerLocal stakeManager = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        );\n', '        address _contract;\n', '        IStakeManagerLocal.Status status;\n', '        (\n', '            amount,\n', '            reward,\n', '            activationEpoch,\n', '            deactivationEpoch,\n', '            ,\n', '            signer,\n', '            _contract,\n', '            status\n', '        ) = stakeManager.validators(validatorId);\n', '        _status = uint256(status);\n', '        if (_contract != address(0x0)) {\n', '            reward += IStakeManagerLocal(_contract).validatorRewards();\n', '        }\n', '    }\n', '\n', '    function totalValidatorStake(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (uint256 validatorStake)\n', '    {\n', '        address contractAddress;\n', '        (validatorStake, , , , , , contractAddress, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '        if (contractAddress != address(0x0)) {\n', '            validatorStake += IStakeManagerLocal(contractAddress).activeAmount();\n', '        }\n', '    }\n', '\n', '    function getAccountStateRoot()\n', '        public\n', '        view\n', '        returns (bytes32 accountStateRoot)\n', '    {\n', '        accountStateRoot = IStakeManagerLocal(registry.getStakeManagerAddress())\n', '            .accountStateRoot();\n', '    }\n', '\n', '    function getValidatorContractAddress(uint256 validatorId)\n', '        public\n', '        view\n', '        returns (address ValidatorContract)\n', '    {\n', '        (, , , , , , ValidatorContract, ) = IStakeManagerLocal(\n', '            registry.getStakeManagerAddress()\n', '        )\n', '            .validators(validatorId);\n', '    }\n', '\n', '    // validator Share contract logging func\n', '    function logShareMinted(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareMinted(validatorId, user, amount, tokens);\n', '    }\n', '\n', '    function logShareBurned(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareBurned(validatorId, user, amount, tokens);\n', '    }\n', '\n', '    function logDelegatorClaimRewards(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 rewards\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorClaimedRewards(validatorId, user, rewards);\n', '    }\n', '\n', '    function logDelegatorRestaked(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 totalStaked\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorRestaked(validatorId, user, totalStaked);\n', '    }\n', '\n', '    function logDelegatorUnstaked(uint256 validatorId, address user, uint256 amount)\n', '        public\n', '        onlyValidatorContract(validatorId)\n', '    {\n', '        emit DelegatorUnstaked(validatorId, user, amount);\n', '    }\n', '\n', '    // deprecated\n', '    function logUpdateCommissionRate(\n', '        uint256 validatorId,\n', '        uint256 newCommissionRate,\n', '        uint256 oldCommissionRate\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit UpdateCommissionRate(\n', '            validatorId,\n', '            newCommissionRate,\n', '            oldCommissionRate\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/Initializable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Initializable {\n', '    bool inited = false;\n', '\n', '    modifier initializer() {\n', '        require(!inited, "already inited");\n', '        inited = true;\n', '        \n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/staking/EventsHub.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract IStakeManagerEventsHub {\n', '    struct Validator {\n', '        uint256 amount;\n', '        uint256 reward;\n', '        uint256 activationEpoch;\n', '        uint256 deactivationEpoch;\n', '        uint256 jailTime;\n', '        address signer;\n', '        address contractAddress;\n', '    }\n', '\n', '    mapping(uint256 => Validator) public validators;\n', '}\n', '\n', 'contract EventsHub is Initializable {\n', '    Registry public registry;\n', '\n', '    modifier onlyValidatorContract(uint256 validatorId) {\n', '        address _contract;\n', '        (, , , , , , _contract) = IStakeManagerEventsHub(registry.getStakeManagerAddress()).validators(validatorId);\n', '        require(_contract == msg.sender, "not validator");\n', '        _;\n', '    }\n', '\n', '    modifier onlyStakeManager() {\n', '        require(registry.getStakeManagerAddress() == msg.sender,\n', '        "Invalid sender, not stake manager");\n', '        _;\n', '    }\n', '\n', '    function initialize(Registry _registry) external initializer {\n', '        registry = _registry;\n', '    }\n', '\n', '    event ShareBurnedWithId(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 indexed amount,\n', '        uint256 tokens,\n', '        uint256 nonce\n', '    );\n', '\n', '    function logShareBurnedWithId(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 tokens,\n', '        uint256 nonce\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit ShareBurnedWithId(validatorId, user, amount, tokens, nonce);\n', '    }\n', '\n', '    event DelegatorUnstakeWithId(\n', '        uint256 indexed validatorId,\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 nonce\n', '    );\n', '\n', '    function logDelegatorUnstakedWithId(\n', '        uint256 validatorId,\n', '        address user,\n', '        uint256 amount,\n', '        uint256 nonce\n', '    ) public onlyValidatorContract(validatorId) {\n', '        emit DelegatorUnstakeWithId(validatorId, user, amount, nonce);\n', '    }\n', '\n', '    event RewardParams(\n', '        uint256 rewardDecreasePerCheckpoint,\n', '        uint256 maxRewardedCheckpoints,\n', '        uint256 checkpointRewardDelta\n', '    );\n', '\n', '    function logRewardParams(\n', '        uint256 rewardDecreasePerCheckpoint,\n', '        uint256 maxRewardedCheckpoints,\n', '        uint256 checkpointRewardDelta\n', '    ) public onlyStakeManager {\n', '        emit RewardParams(rewardDecreasePerCheckpoint, maxRewardedCheckpoints, checkpointRewardDelta);\n', '    }\n', '\n', '    event UpdateCommissionRate(\n', '        uint256 indexed validatorId,\n', '        uint256 indexed newCommissionRate,\n', '        uint256 indexed oldCommissionRate\n', '    );\n', '\n', '    function logUpdateCommissionRate(\n', '        uint256 validatorId,\n', '        uint256 newCommissionRate,\n', '        uint256 oldCommissionRate\n', '    ) public onlyStakeManager {\n', '        emit UpdateCommissionRate(\n', '            validatorId,\n', '            newCommissionRate,\n', '            oldCommissionRate\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/Lockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', 'contract Lockable {\n', '    bool public locked;\n', '\n', '    modifier onlyWhenUnlocked() {\n', '        _assertUnlocked();\n', '        _;\n', '    }\n', '\n', '    function _assertUnlocked() private view {\n', '        require(!locked, "locked");\n', '    }\n', '\n', '    function lock() public {\n', '        locked = true;\n', '    }\n', '\n', '    function unlock() public {\n', '        locked = false;\n', '    }\n', '}\n', '\n', '// File: contracts/common/mixin/OwnableLockable.sol\n', '\n', 'pragma solidity ^0.5.2;\n', '\n', '\n', '\n', 'contract OwnableLockable is Lockable, Ownable {\n', '    function lock() public onlyOwner {\n', '        super.lock();\n', '    }\n', '\n', '    function unlock() public onlyOwner {\n', '        super.unlock();\n', '    }\n', '}\n', '\n', '// File: contracts/staking/stakeManager/IStakeManager.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'contract IStakeManager {\n', '    // validator replacement\n', '    function startAuction(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external;\n', '\n', '    function confirmAuctionBid(uint256 validatorId, uint256 heimdallFee) external;\n', '\n', '    function transferFunds(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool);\n', '\n', '    function delegationDeposit(\n', '        uint256 validatorId,\n', '        uint256 amount,\n', '        address delegator\n', '    ) external returns (bool);\n', '\n', '    function unstake(uint256 validatorId) external;\n', '\n', '    function totalStakedFor(address addr) external view returns (uint256);\n', '\n', '    function stakeFor(\n', '        address user,\n', '        uint256 amount,\n', '        uint256 heimdallFee,\n', '        bool acceptDelegation,\n', '        bytes memory signerPubkey\n', '    ) public;\n', '\n', '    function checkSignatures(\n', '        uint256 blockInterval,\n', '        bytes32 voteHash,\n', '        bytes32 stateRoot,\n', '        address proposer,\n', '        uint[3][] calldata sigs\n', '    ) external returns (uint256);\n', '\n', '    function updateValidatorState(uint256 validatorId, int256 amount) public;\n', '\n', '    function ownerOf(uint256 tokenId) public view returns (address);\n', '\n', '    function slash(bytes calldata slashingInfoList) external returns (uint256);\n', '\n', '    function validatorStake(uint256 validatorId) public view returns (uint256);\n', '\n', '    function epoch() public view returns (uint256);\n', '\n', '    function getRegistry() public view returns (address);\n', '\n', '    function withdrawalDelay() public view returns (uint256);\n', '\n', '    function delegatedAmount(uint256 validatorId) public view returns(uint256);\n', '\n', '    function decreaseValidatorDelegatedAmount(uint256 validatorId, uint256 amount) public;\n', '\n', '    function withdrawDelegatorsReward(uint256 validatorId) public returns(uint256);\n', '\n', '    function delegatorsReward(uint256 validatorId) public view returns(uint256);\n', '\n', '    function dethroneAndStake(\n', '        address auctionUser,\n', '        uint256 heimdallFee,\n', '        uint256 validatorId,\n', '        uint256 auctionAmount,\n', '        bool acceptDelegation,\n', '        bytes calldata signerPubkey\n', '    ) external;\n', '}\n', '\n', '// File: contracts/staking/validatorShare/IValidatorShare.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '// note this contract interface is only for stakeManager use\n', 'contract IValidatorShare {\n', '    function withdrawRewards() public;\n', '\n', '    function unstakeClaimTokens() public;\n', '\n', '    function getLiquidRewards(address user) public view returns (uint256);\n', '    \n', '    function owner() public view returns (address);\n', '\n', '    function restake() public returns(uint256, uint256);\n', '\n', '    function unlock() external;\n', '\n', '    function lock() external;\n', '\n', '    function drain(\n', '        address token,\n', '        address payable destination,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function slash(uint256 valPow, uint256 delegatedAmount, uint256 totalAmountToSlash) external returns (uint256);\n', '\n', '    function updateDelegation(bool delegation) external;\n', '\n', '    function migrateOut(address user, uint256 amount) external;\n', '\n', '    function migrateIn(address user, uint256 amount) external;\n', '}\n', '\n', '// File: contracts/staking/validatorShare/ValidatorShare.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ValidatorShare is IValidatorShare, ERC20NonTradable, OwnableLockable, Initializable {\n', '    struct DelegatorUnbond {\n', '        uint256 shares;\n', '        uint256 withdrawEpoch;\n', '    }\n', '\n', '    uint256 constant EXCHANGE_RATE_PRECISION = 100;\n', '    // maximum matic possible, even if rate will be 1 and all matic will be staken in one go, it will result in 10 ^ 58 shares\n', '    uint256 constant EXCHANGE_RATE_HIGH_PRECISION = 10**29;\n', '    uint256 constant MAX_COMMISION_RATE = 100;\n', '    uint256 constant REWARD_PRECISION = 10**25;\n', '\n', '    StakingInfo public stakingLogger;\n', '    IStakeManager public stakeManager;\n', '    uint256 public validatorId;\n', '    uint256 public validatorRewards_deprecated;\n', '    uint256 public commissionRate_deprecated;\n', '    uint256 public lastCommissionUpdate_deprecated;\n', '    uint256 public minAmount;\n', '\n', '    uint256 public totalStake_deprecated;\n', '    uint256 public rewardPerShare;\n', '    uint256 public activeAmount;\n', '\n', '    bool public delegation;\n', '\n', '    uint256 public withdrawPool;\n', '    uint256 public withdrawShares;\n', '\n', '    mapping(address => uint256) amountStaked_deprecated; // deprecated, keep for foundation delegators\n', '    mapping(address => DelegatorUnbond) public unbonds;\n', '    mapping(address => uint256) public initalRewardPerShare;\n', '\n', '    mapping(address => uint256) public unbondNonces;\n', '    mapping(address => mapping(uint256 => DelegatorUnbond)) public unbonds_new;\n', '\n', '    EventsHub public eventsHub;\n', '\n', "    // onlyOwner will prevent this contract from initializing, since it's owner is going to be 0x0 address\n", '    function initialize(\n', '        uint256 _validatorId,\n', '        address _stakingLogger,\n', '        address _stakeManager\n', '    ) external initializer {\n', '        validatorId = _validatorId;\n', '        stakingLogger = StakingInfo(_stakingLogger);\n', '        stakeManager = IStakeManager(_stakeManager);\n', '        _transferOwnership(_stakeManager);\n', '        _getOrCacheEventsHub();\n', '\n', '        minAmount = 10**18;\n', '        delegation = true;\n', '    }\n', '\n', '    /**\n', '        Public View Methods\n', '    */\n', '\n', '    function exchangeRate() public view returns (uint256) {\n', '        uint256 totalShares = totalSupply();\n', '        uint256 precision = _getRatePrecision();\n', '        return totalShares == 0 ? precision : stakeManager.delegatedAmount(validatorId).mul(precision).div(totalShares);\n', '    }\n', '\n', '    function getTotalStake(address user) public view returns (uint256, uint256) {\n', '        uint256 shares = balanceOf(user);\n', '        uint256 rate = exchangeRate();\n', '        if (shares == 0) {\n', '            return (0, rate);\n', '        }\n', '\n', '        return (rate.mul(shares).div(_getRatePrecision()), rate);\n', '    }\n', '\n', '    function withdrawExchangeRate() public view returns (uint256) {\n', '        uint256 precision = _getRatePrecision();\n', '        if (validatorId < 8) {\n', '            // fix of potentially broken withdrawals for future unbonding\n', '            // foundation validators have no slashing enabled and thus we can return default exchange rate\n', '            // because without slashing rate will stay constant\n', '            return precision;\n', '        }\n', '\n', '        uint256 _withdrawShares = withdrawShares;\n', '        return _withdrawShares == 0 ? precision : withdrawPool.mul(precision).div(_withdrawShares);\n', '    }\n', '\n', '    function getLiquidRewards(address user) public view returns (uint256) {\n', '        return _calculateReward(user, getRewardPerShare());\n', '    }\n', '\n', '    function getRewardPerShare() public view returns (uint256) {\n', '        return _calculateRewardPerShareWithRewards(stakeManager.delegatorsReward(validatorId));\n', '    }\n', '\n', '    /**\n', '        Public Methods\n', '     */\n', '\n', '    function buyVoucher(uint256 _amount, uint256 _minSharesToMint) public returns(uint256 amountToDeposit) {\n', '        _withdrawAndTransferReward(msg.sender);\n', '        \n', '        amountToDeposit = _buyShares(_amount, _minSharesToMint, msg.sender);\n', '        require(stakeManager.delegationDeposit(validatorId, amountToDeposit, msg.sender), "deposit failed");\n', '        \n', '        return amountToDeposit;\n', '    }\n', '\n', '    function restake() public returns(uint256, uint256) {\n', '        address user = msg.sender;\n', '        uint256 liquidReward = _withdrawReward(user);\n', '        uint256 amountRestaked;\n', '\n', '        require(liquidReward >= minAmount, "Too small rewards to restake");\n', '\n', '        if (liquidReward != 0) {\n', '            amountRestaked = _buyShares(liquidReward, 0, user);\n', '\n', '            if (liquidReward > amountRestaked) {\n', '                // return change to the user\n', '                require(\n', '                    stakeManager.transferFunds(validatorId, liquidReward - amountRestaked, user),\n', '                    "Insufficent rewards"\n', '                );\n', '                stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidReward - amountRestaked);\n', '            }\n', '\n', '            (uint256 totalStaked, ) = getTotalStake(user);\n', '            stakingLogger.logDelegatorRestaked(validatorId, user, totalStaked);\n', '        }\n', '        \n', '        return (amountRestaked, liquidReward);\n', '    }\n', '\n', '    function sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) public {\n', '        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);\n', '\n', '        DelegatorUnbond memory unbond = unbonds[msg.sender];\n', '        unbond.shares = unbond.shares.add(_withdrawPoolShare);\n', '        // refresh undond period\n', '        unbond.withdrawEpoch = stakeManager.epoch();\n', '        unbonds[msg.sender] = unbond;\n', '\n', '        StakingInfo logger = stakingLogger;\n', '        logger.logShareBurned(validatorId, msg.sender, claimAmount, shares);\n', '        logger.logStakeUpdate(validatorId);\n', '    }\n', '\n', '    function withdrawRewards() public {\n', '        uint256 rewards = _withdrawAndTransferReward(msg.sender);\n', '        require(rewards >= minAmount, "Too small rewards amount");\n', '    }\n', '\n', '    function migrateOut(address user, uint256 amount) external onlyOwner {\n', '        _withdrawAndTransferReward(user);\n', '        (uint256 totalStaked, uint256 rate) = getTotalStake(user);\n', '        require(totalStaked >= amount, "Migrating too much");\n', '\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = amount.mul(precision).div(rate);\n', '        _burn(user, shares);\n', '\n', '        stakeManager.updateValidatorState(validatorId, -int256(amount));\n', '        activeAmount = activeAmount.sub(amount);\n', '\n', '        stakingLogger.logShareBurned(validatorId, user, amount, shares);\n', '        stakingLogger.logStakeUpdate(validatorId);\n', '        stakingLogger.logDelegatorUnstaked(validatorId, user, amount);\n', '    }\n', '\n', '    function migrateIn(address user, uint256 amount) external onlyOwner {\n', '        _withdrawAndTransferReward(user);\n', '        _buyShares(amount, 0, user);\n', '    }\n', '\n', '    function unstakeClaimTokens() public {\n', '        DelegatorUnbond memory unbond = unbonds[msg.sender];\n', '        uint256 amount = _unstakeClaimTokens(unbond);\n', '        delete unbonds[msg.sender];\n', '        stakingLogger.logDelegatorUnstaked(validatorId, msg.sender, amount);\n', '    }\n', '\n', '    function slash(\n', '        uint256 validatorStake,\n', '        uint256 delegatedAmount,\n', '        uint256 totalAmountToSlash\n', '    ) external onlyOwner returns (uint256) {\n', '        uint256 _withdrawPool = withdrawPool;\n', '        uint256 delegationAmount = delegatedAmount.add(_withdrawPool);\n', '        if (delegationAmount == 0) {\n', '            return 0;\n', '        }\n', '        // total amount to be slashed from delegation pool (active + inactive)\n', '        uint256 _amountToSlash = delegationAmount.mul(totalAmountToSlash).div(validatorStake.add(delegationAmount));\n', '        uint256 _amountToSlashWithdrawalPool = _withdrawPool.mul(_amountToSlash).div(delegationAmount);\n', '\n', '        // slash inactive pool\n', '        uint256 stakeSlashed = _amountToSlash.sub(_amountToSlashWithdrawalPool);\n', '        stakeManager.decreaseValidatorDelegatedAmount(validatorId, stakeSlashed);\n', '        activeAmount = activeAmount.sub(stakeSlashed);\n', '\n', '        withdrawPool = withdrawPool.sub(_amountToSlashWithdrawalPool);\n', '        return _amountToSlash;\n', '    }\n', '\n', '    function updateDelegation(bool _delegation) external onlyOwner {\n', '        delegation = _delegation;\n', '    }\n', '\n', '    function drain(\n', '        address token,\n', '        address payable destination,\n', '        uint256 amount\n', '    ) external onlyOwner {\n', '        if (token == address(0x0)) {\n', '            destination.transfer(amount);\n', '        } else {\n', '            require(ERC20(token).transfer(destination, amount), "Drain failed");\n', '        }\n', '    }\n', '\n', '    /**\n', '        New shares exit API\n', '     */\n', '\n', '    function sellVoucher_new(uint256 claimAmount, uint256 maximumSharesToBurn) public {\n', '        (uint256 shares, uint256 _withdrawPoolShare) = _sellVoucher(claimAmount, maximumSharesToBurn);\n', '\n', '        uint256 unbondNonce = unbondNonces[msg.sender].add(1);\n', '\n', '        DelegatorUnbond memory unbond = DelegatorUnbond({\n', '            shares: _withdrawPoolShare,\n', '            withdrawEpoch: stakeManager.epoch()\n', '        });\n', '        unbonds_new[msg.sender][unbondNonce] = unbond;\n', '        unbondNonces[msg.sender] = unbondNonce;\n', '\n', '        _getOrCacheEventsHub().logShareBurnedWithId(validatorId, msg.sender, claimAmount, shares, unbondNonce);\n', '        stakingLogger.logStakeUpdate(validatorId);\n', '    }\n', '\n', '    function unstakeClaimTokens_new(uint256 unbondNonce) public {\n', '        DelegatorUnbond memory unbond = unbonds_new[msg.sender][unbondNonce];\n', '        uint256 amount = _unstakeClaimTokens(unbond);\n', '        delete unbonds_new[msg.sender][unbondNonce];\n', '        _getOrCacheEventsHub().logDelegatorUnstakedWithId(validatorId, msg.sender, amount, unbondNonce);\n', '    }\n', '\n', '    /**\n', '        Private Methods\n', '     */\n', '\n', '    function _getOrCacheEventsHub() private returns(EventsHub) {\n', '        EventsHub _eventsHub = eventsHub;\n', '        if (_eventsHub == EventsHub(0x0)) {\n', '            _eventsHub = EventsHub(Registry(stakeManager.getRegistry()).contractMap(keccak256("eventsHub")));\n', '            eventsHub = _eventsHub;\n', '        }\n', '        return _eventsHub;\n', '    }\n', '\n', '    function _sellVoucher(uint256 claimAmount, uint256 maximumSharesToBurn) private returns(uint256, uint256) {\n', '        // first get how much staked in total and compare to target unstake amount\n', '        (uint256 totalStaked, uint256 rate) = getTotalStake(msg.sender);\n', '        require(totalStaked != 0 && totalStaked >= claimAmount, "Too much requested");\n', '\n', '        // convert requested amount back to shares\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = claimAmount.mul(precision).div(rate);\n', '        require(shares <= maximumSharesToBurn, "too much slippage");\n', '\n', '        _withdrawAndTransferReward(msg.sender);\n', '\n', '        _burn(msg.sender, shares);\n', '        stakeManager.updateValidatorState(validatorId, -int256(claimAmount));\n', '        activeAmount = activeAmount.sub(claimAmount);\n', '\n', '        uint256 _withdrawPoolShare = claimAmount.mul(precision).div(withdrawExchangeRate());\n', '        withdrawPool = withdrawPool.add(claimAmount);\n', '        withdrawShares = withdrawShares.add(_withdrawPoolShare);\n', '\n', '        return (shares, _withdrawPoolShare);\n', '    }\n', '\n', '    function _unstakeClaimTokens(DelegatorUnbond memory unbond) private returns(uint256) {\n', '        uint256 shares = unbond.shares;\n', '        require(\n', '            unbond.withdrawEpoch.add(stakeManager.withdrawalDelay()) <= stakeManager.epoch() && shares > 0,\n', '            "Incomplete withdrawal period"\n', '        );\n', '\n', '        uint256 _amount = withdrawExchangeRate().mul(shares).div(_getRatePrecision());\n', '        withdrawShares = withdrawShares.sub(shares);\n', '        withdrawPool = withdrawPool.sub(_amount);\n', '\n', '        require(stakeManager.transferFunds(validatorId, _amount, msg.sender), "Insufficent rewards");\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function _getRatePrecision() private view returns (uint256) {\n', '        // if foundation validator, use old precision\n', '        if (validatorId < 8) {\n', '            return EXCHANGE_RATE_PRECISION;\n', '        }\n', '\n', '        return EXCHANGE_RATE_HIGH_PRECISION;\n', '    }\n', '\n', '    function _calculateRewardPerShareWithRewards(uint256 accumulatedReward) private view returns (uint256) {\n', '        uint256 _rewardPerShare = rewardPerShare;\n', '        if (accumulatedReward != 0) {\n', '            uint256 totalShares = totalSupply();\n', '            \n', '            if (totalShares != 0) {\n', '                _rewardPerShare = _rewardPerShare.add(accumulatedReward.mul(REWARD_PRECISION).div(totalShares));\n', '            }\n', '        }\n', '\n', '        return _rewardPerShare;\n', '    }\n', '\n', '    function _calculateReward(address user, uint256 _rewardPerShare) private view returns (uint256) {\n', '        uint256 shares = balanceOf(user);\n', '        if (shares == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 _initialRewardPerShare = initalRewardPerShare[user];\n', '\n', '        if (_initialRewardPerShare == _rewardPerShare) {\n', '            return 0;\n', '        }\n', '\n', '        return _rewardPerShare.sub(_initialRewardPerShare).mul(shares).div(REWARD_PRECISION);\n', '    }\n', '\n', '    function _withdrawReward(address user) private returns (uint256) {\n', '        uint256 _rewardPerShare = _calculateRewardPerShareWithRewards(\n', '            stakeManager.withdrawDelegatorsReward(validatorId)\n', '        );\n', '        uint256 liquidRewards = _calculateReward(user, _rewardPerShare);\n', '        \n', '        rewardPerShare = _rewardPerShare;\n', '        initalRewardPerShare[user] = _rewardPerShare;\n', '        return liquidRewards;\n', '    }\n', '\n', '    function _withdrawAndTransferReward(address user) private returns (uint256) {\n', '        uint256 liquidRewards = _withdrawReward(user);\n', '        if (liquidRewards != 0) {\n', '            require(stakeManager.transferFunds(validatorId, liquidRewards, user), "Insufficent rewards");\n', '            stakingLogger.logDelegatorClaimRewards(validatorId, user, liquidRewards);\n', '        }\n', '        return liquidRewards;\n', '    }\n', '\n', '    function _buyShares(\n', '        uint256 _amount,\n', '        uint256 _minSharesToMint,\n', '        address user\n', '    ) private onlyWhenUnlocked returns (uint256) {\n', '        require(delegation, "Delegation is disabled");\n', '\n', '        uint256 rate = exchangeRate();\n', '        uint256 precision = _getRatePrecision();\n', '        uint256 shares = _amount.mul(precision).div(rate);\n', '        require(shares >= _minSharesToMint, "Too much slippage");\n', '        require(unbonds[user].shares == 0, "Ongoing exit");\n', '\n', '        _mint(user, shares);\n', '\n', '        // clamp amount of tokens in case resulted shares requires less tokens than anticipated\n', '        _amount = rate.mul(shares).div(precision);\n', '\n', '        stakeManager.updateValidatorState(validatorId, int256(_amount));\n', '        activeAmount = activeAmount.add(_amount);\n', '\n', '        StakingInfo logger = stakingLogger;\n', '        logger.logShareMinted(validatorId, user, _amount, shares);\n', '        logger.logStakeUpdate(validatorId);\n', '\n', '        return _amount;\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        // get rewards for recipient \n', '        _withdrawAndTransferReward(to);\n', '        // convert rewards to shares\n', '        _withdrawAndTransferReward(from);\n', '        // move shares to recipient\n', '        super._transfer(from, to, value);\n', '    }\n', '}']