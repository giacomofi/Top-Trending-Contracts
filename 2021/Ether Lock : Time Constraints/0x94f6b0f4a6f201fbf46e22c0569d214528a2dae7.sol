['# @version 0.2.8\n', '"""\n', '@title Ampleforth Governance Token\n', '@author Curve Finance, modified by Ampleforth\n', '@license MIT\n', '@notice ERC20 with fixed 2% yearly inflation\n', '@dev Based on the ERC-20 token standard as defined at\n', '     https://eips.ethereum.org/EIPS/eip-20\n', '"""\n', '\n', 'from vyper.interfaces import ERC20\n', '\n', 'implements: ERC20\n', '\n', '\n', 'event Transfer:\n', '    _from: indexed(address)\n', '    _to: indexed(address)\n', '    _value: uint256\n', '\n', 'event Approval:\n', '    _owner: indexed(address)\n', '    _spender: indexed(address)\n', '    _value: uint256\n', '\n', 'event UpdateMiningParameters:\n', '    time: uint256\n', '    rate: uint256\n', '    supply: uint256\n', '\n', 'event SetMinter:\n', '    minter: address\n', '\n', 'event SetAdmin:\n', '    admin: address\n', '\n', '\n', 'name: public(String[64])\n', 'symbol: public(String[32])\n', 'decimals: public(uint256)\n', '\n', 'balanceOf: public(HashMap[address, uint256])\n', 'allowances: HashMap[address, HashMap[address, uint256]]\n', 'total_supply: uint256\n', '\n', 'minter: public(address)\n', 'admin: public(address)\n', '\n', '# General constants\n', 'YEAR: constant(uint256) = 86400 * 365\n', '\n', '# Supply parameters\n', 'INITIAL_SUPPLY: constant(uint256) = 15_000_000\n', 'RATE_ONE: constant(uint256) = 10 ** 18\n', 'INITIAL_RATE: constant(uint256) = 300_000 * RATE_ONE / YEAR # 2% inflation per year\n', 'EPOCH_TIME: constant(uint256) = YEAR\n', 'RATE_ADJUSTMENT_COEFF: constant(uint256) = (102 * RATE_ONE) / 100   # Keep rate at 2% per year\n', 'INFLATION_DELAY: constant(uint256) = YEAR\n', '\n', '# Supply variables\n', 'mining_epoch: public(int128)\n', 'start_epoch_time: public(uint256)\n', 'rate: public(uint256)\n', '\n', 'start_epoch_supply: uint256\n', '\n', '\n', '@external\n', 'def __init__(_name: String[64], _symbol: String[32], _decimals: uint256):\n', '    """\n', '    @notice Contract constructor\n', '    @param _name Token full name\n', '    @param _symbol Token symbol\n', '    @param _decimals Number of decimals for token\n', '    """\n', '    init_supply: uint256 = INITIAL_SUPPLY * 10 ** _decimals\n', '    self.name = _name\n', '    self.symbol = _symbol\n', '    self.decimals = _decimals\n', '    self.balanceOf[msg.sender] = init_supply\n', '    self.total_supply = init_supply\n', '    self.admin = msg.sender\n', '    log Transfer(ZERO_ADDRESS, msg.sender, init_supply)\n', '\n', '    self.start_epoch_time = block.timestamp + INFLATION_DELAY - EPOCH_TIME\n', '    self.mining_epoch = -1\n', '    self.rate = 0\n', '    self.start_epoch_supply = init_supply\n', '\n', '\n', '@internal\n', 'def _update_mining_parameters():\n', '    """\n', '    @dev Update mining rate and supply at the start of the epoch\n', '         Any modifying mining call must also call this\n', '    """\n', '    _rate: uint256 = self.rate\n', '    _start_epoch_supply: uint256 = self.start_epoch_supply\n', '\n', '    self.start_epoch_time += EPOCH_TIME\n', '    self.mining_epoch += 1\n', '\n', '    if _rate == 0:\n', '        _rate = INITIAL_RATE\n', '    else:\n', '        _start_epoch_supply += _rate * EPOCH_TIME\n', '        self.start_epoch_supply = _start_epoch_supply\n', '        _rate = _rate * RATE_ADJUSTMENT_COEFF / RATE_ONE\n', '\n', '    self.rate = _rate\n', '\n', '    log UpdateMiningParameters(block.timestamp, _rate, _start_epoch_supply)\n', '\n', '\n', '@external\n', 'def update_mining_parameters():\n', '    """\n', '    @notice Update mining rate and supply at the start of the epoch\n', '    @dev Callable by any address, but only once per epoch\n', '         Total supply becomes slightly larger if this function is called late\n', '    """\n', '    assert block.timestamp >= self.start_epoch_time + EPOCH_TIME  # dev: too soon!\n', '    self._update_mining_parameters()\n', '\n', '\n', '@external\n', 'def start_epoch_time_write() -> uint256:\n', '    """\n', '    @notice Get timestamp of the current mining epoch start\n', '            while simultaneously updating mining parameters\n', '    @return Timestamp of the epoch\n', '    """\n', '    _start_epoch_time: uint256 = self.start_epoch_time\n', '    if block.timestamp >= _start_epoch_time + EPOCH_TIME:\n', '        self._update_mining_parameters()\n', '        return self.start_epoch_time\n', '    else:\n', '        return _start_epoch_time\n', '\n', '\n', '@external\n', 'def future_epoch_time_write() -> uint256:\n', '    """\n', '    @notice Get timestamp of the next mining epoch start\n', '            while simultaneously updating mining parameters\n', '    @return Timestamp of the next epoch\n', '    """\n', '    _start_epoch_time: uint256 = self.start_epoch_time\n', '    if block.timestamp >= _start_epoch_time + EPOCH_TIME:\n', '        self._update_mining_parameters()\n', '        return self.start_epoch_time + EPOCH_TIME\n', '    else:\n', '        return _start_epoch_time + EPOCH_TIME\n', '\n', '\n', '@internal\n', '@view\n', 'def _available_supply() -> uint256:\n', '    return self.start_epoch_supply + (block.timestamp - self.start_epoch_time) * self.rate\n', '\n', '\n', '@external\n', '@view\n', 'def available_supply() -> uint256:\n', '    """\n', '    @notice Current number of tokens in existence (claimed or unclaimed)\n', '    """\n', '    return self._available_supply()\n', '\n', '\n', '@external\n', '@view\n', 'def mintable_in_timeframe(start: uint256, end: uint256) -> uint256:\n', '    """\n', '    @notice How much supply is mintable from start timestamp till end timestamp\n', '    @param start Start of the time interval (timestamp)\n', '    @param end End of the time interval (timestamp)\n', '    @return Tokens mintable from `start` till `end`\n', '    """\n', '    assert start <= end  # dev: start > end\n', '    to_mint: uint256 = 0\n', '    current_epoch_time: uint256 = self.start_epoch_time\n', '    current_rate: uint256 = self.rate\n', '\n', '    # Special case if end is in future (not yet minted) epoch\n', '    if end > current_epoch_time + EPOCH_TIME:\n', '        current_epoch_time += EPOCH_TIME\n', '        current_rate = current_rate * RATE_ADJUSTMENT_COEFF / RATE_ONE\n', '\n', '    assert end <= current_epoch_time + EPOCH_TIME  # dev: too far in future\n', '\n', '    for i in range(999):  # Forth will not work in 1000 years. Darn!\n', '        if end >= current_epoch_time:\n', '            current_end: uint256 = end\n', '            if current_end > current_epoch_time + EPOCH_TIME:\n', '                current_end = current_epoch_time + EPOCH_TIME\n', '\n', '            current_start: uint256 = start\n', '            if current_start >= current_epoch_time + EPOCH_TIME:\n', '                break  # We should never get here but what if...\n', '            elif current_start < current_epoch_time:\n', '                current_start = current_epoch_time\n', '\n', '            to_mint += current_rate * (current_end - current_start)\n', '\n', '            if start >= current_epoch_time:\n', '                break\n', '\n', '        current_epoch_time -= EPOCH_TIME\n', '        current_rate = current_rate * RATE_ADJUSTMENT_COEFF / RATE_ONE\n', '        assert ((current_rate >= INITIAL_RATE) or\n', '                (current_rate == 0 and self.mining_epoch == -1)) # This should never happen\n', '\n', '    return to_mint\n', '\n', '\n', '@external\n', 'def set_minter(_minter: address):\n', '    """\n', '    @notice Set the minter address\n', '    @dev Only callable once, when minter has not yet been set\n', '    @param _minter Address of the minter\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '    assert self.minter == ZERO_ADDRESS  # dev: can set the minter only once, at creation\n', '    self.minter = _minter\n', '    log SetMinter(_minter)\n', '\n', '\n', '@external\n', 'def set_admin(_admin: address):\n', '    """\n', '    @notice Set the new admin.\n', '    @dev After all is set up, admin only can change the token name\n', '    @param _admin New admin address\n', '    """\n', '    assert msg.sender == self.admin  # dev: admin only\n', '    self.admin = _admin\n', '    log SetAdmin(_admin)\n', '\n', '\n', '@external\n', '@view\n', 'def totalSupply() -> uint256:\n', '    """\n', '    @notice Total number of tokens in existence.\n', '    """\n', '    return self.total_supply\n', '\n', '\n', '@external\n', '@view\n', 'def allowance(_owner : address, _spender : address) -> uint256:\n', '    """\n', '    @notice Check the amount of tokens that an owner allowed to a spender\n', '    @param _owner The address which owns the funds\n', '    @param _spender The address which will spend the funds\n', '    @return uint256 specifying the amount of tokens still available for the spender\n', '    """\n', '    return self.allowances[_owner][_spender]\n', '\n', '\n', '@external\n', 'def transfer(_to : address, _value : uint256) -> bool:\n', '    """\n', '    @notice Transfer `_value` tokens from `msg.sender` to `_to`\n', '    @dev Vyper does not allow underflows, so the subtraction in\n', '         this function will revert on an insufficient balance\n', '    @param _to The address to transfer to\n', '    @param _value The amount to be transferred\n', '    @return bool success\n', '    """\n', '    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\n', '    self.balanceOf[msg.sender] -= _value\n', '    self.balanceOf[_to] += _value\n', '    log Transfer(msg.sender, _to, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def transferFrom(_from : address, _to : address, _value : uint256) -> bool:\n', '    """\n', '     @notice Transfer `_value` tokens from `_from` to `_to`\n', '     @param _from address The address which you want to send tokens from\n', '     @param _to address The address which you want to transfer to\n', '     @param _value uint256 the amount of tokens to be transferred\n', '     @return bool success\n', '    """\n', '    assert _to != ZERO_ADDRESS  # dev: transfers to 0x0 are not allowed\n', '    # NOTE: vyper does not allow underflows\n', '    #       so the following subtraction would revert on insufficient balance\n', '    self.balanceOf[_from] -= _value\n', '    self.balanceOf[_to] += _value\n', '    self.allowances[_from][msg.sender] -= _value\n', '    log Transfer(_from, _to, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def approve(_spender : address, _value : uint256) -> bool:\n', '    """\n', '    @notice Approve `_spender` to transfer `_value` tokens on behalf of `msg.sender`\n', '    @dev Approval may only be from zero -> nonzero or from nonzero -> zero in order\n', '        to mitigate the potential race condition described here:\n', '        https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '    @param _spender The address which will spend the funds\n', '    @param _value The amount of tokens to be spent\n', '    @return bool success\n', '    """\n', '    assert _value == 0 or self.allowances[msg.sender][_spender] == 0\n', '    self.allowances[msg.sender][_spender] = _value\n', '    log Approval(msg.sender, _spender, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def mint(_to: address, _value: uint256) -> bool:\n', '    """\n', '    @notice Mint `_value` tokens and assign them to `_to`\n', '    @dev Emits a Transfer event originating from 0x00\n', '    @param _to The account that will receive the created tokens\n', '    @param _value The amount that will be created\n', '    @return bool success\n', '    """\n', '    assert msg.sender == self.minter  # dev: minter only\n', '    assert _to != ZERO_ADDRESS  # dev: zero address\n', '\n', '    if block.timestamp >= self.start_epoch_time + EPOCH_TIME:\n', '        self._update_mining_parameters()\n', '\n', '    _total_supply: uint256 = self.total_supply + _value\n', '    assert _total_supply <= self._available_supply()  # dev: exceeds allowable mint amount\n', '    self.total_supply = _total_supply\n', '\n', '    self.balanceOf[_to] += _value\n', '    log Transfer(ZERO_ADDRESS, _to, _value)\n', '\n', '    return True\n', '\n', '\n', '@external\n', 'def burn(_value: uint256) -> bool:\n', '    """\n', '    @notice Burn `_value` tokens belonging to `msg.sender`\n', '    @dev Emits a Transfer event with a destination of 0x00\n', '    @param _value The amount that will be burned\n', '    @return bool success\n', '    """\n', '    self.balanceOf[msg.sender] -= _value\n', '    self.total_supply -= _value\n', '\n', '    log Transfer(msg.sender, ZERO_ADDRESS, _value)\n', '    return True\n', '\n', '\n', '@external\n', 'def set_name(_name: String[64], _symbol: String[32]):\n', '    """\n', '    @notice Change the token name and symbol to `_name` and `_symbol`\n', '    @dev Only callable by the admin account\n', '    @param _name New token name\n', '    @param _symbol New token symbol\n', '    """\n', '    assert msg.sender == self.admin, "Only admin is allowed to change name"\n', '    self.name = _name\n', '    self.symbol = _symbol']