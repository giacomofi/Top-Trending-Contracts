['// SPDX-License-Identifier: PRIVATE\n', 'pragma solidity >=0.7.0 < 0.8.0;\n', 'pragma abicoder v2;\n', '\n', 'import "./tmp4.sol";\n', '\n', 'struct InvestInfo {\n', '  address Addr;\n', '  uint256 ID;\n', '\n', '  uint256 restCRFI;\n', '  uint256 perTimeCRFI;\n', '  \n', '  uint256 nextTime;\n', '  uint256 duration;\n', '  uint256 totalNums;\n', '}\n', '\n', 'contract Distribution is  ReentrancyGuard {\n', '  //////////////////// for using\n', '  using SafeMath for uint256;\n', '\n', '  //////////////////// constant\n', '\n', '  ////////////////////\n', '  IERC20 CRFI;\n', '\n', '  //////////////////// invest\n', '  // invest\n', '  uint256 public NewInvestID;\n', '  mapping(uint256 => InvestInfo) Invests;\n', '  mapping(address => uint256) public InvestAddrID;\n', '\n', '\n', '  //////////////////// modifier\n', '  constructor(address crfiAddr){\n', '    CRFI = IERC20(crfiAddr);\n', '    NewInvestID = 1;\n', '  }\n', '  \n', '  //////////////////// public\n', '  function Charge(address to,\n', '                  uint256 totalCRFI,\n', '                  uint256 nextTime,\n', '                  uint256 duration,\n', '                  uint256 totalNums)\n', '    public\n', '    nonReentrant(){\n', '\n', '    uint256 uID = getUID(to);\n', '    InvestInfo storage uInfo = Invests[uID];\n', '    \n', '    withdraw(uInfo);\n', '    require(uInfo.restCRFI == 0, "have rest crfi");\n', '\n', '    require(to != address(0x0), "user must not zero addr");\n', '    require(totalCRFI > 0, "totalCRFI must > 0");\n', '    require(duration > 0, "duration must > 0");\n', '    require(totalNums > 0, "totalNums must > 0");\n', '    require(totalCRFI > totalNums, "totalCRFI must > totalNums");\n', '\n', '    CRFI.transferFrom(msg.sender, address(this), totalCRFI);\n', '\n', '    uInfo.restCRFI = totalCRFI;\n', '    uInfo.perTimeCRFI = totalCRFI / totalNums;\n', '    uInfo.nextTime = nextTime;\n', '    uInfo.duration = duration;\n', '    uInfo.totalNums = totalNums;\n', '  }\n', '\n', '  function Withdraw(address addr)\n', '    public\n', '    nonReentrant(){\n', '    if(addr == address(0x0)){\n', '      addr = msg.sender;\n', '    }\n', '    \n', '    uint256 uID = getUID(addr);\n', '    InvestInfo storage uInfo = Invests[uID];\n', '    \n', '    withdraw(uInfo);\n', '  }\n', '    \n', '\n', '  //////////////////// view\n', '  function GetInvestInfo(address addr)\n', '    public\n', '    view\n', '    returns(uint256 restCRFI,\n', '            uint256 perTimeCRFI,\n', '            uint256 nextTime,\n', '            uint256 duration,\n', '            uint256 totalNums,\n', '            uint256 avaiCRFI){\n', '    \n', '    uint256 uID = InvestAddrID[addr];\n', '    if(uID == 0){\n', '      return(restCRFI,\n', '             perTimeCRFI,\n', '             nextTime,\n', '             duration,\n', '             totalNums,\n', '             avaiCRFI);\n', '    }\n', '    \n', '    InvestInfo storage uInfo = Invests[uID];\n', '    (avaiCRFI, nextTime, totalNums) = calcNowAvaiCRFI(uInfo);\n', '\n', '    restCRFI = uInfo.restCRFI.sub(avaiCRFI);\n', '    return(restCRFI,\n', '           uInfo.perTimeCRFI,\n', '           nextTime,\n', '           uInfo.duration,\n', '           totalNums,\n', '           avaiCRFI);\n', '  }\n', '\n', '  //////////////////// internal\n', '\n', '  function withdraw(InvestInfo storage uInfo)\n', '    internal{\n', '    (uint256 avaiCRFI, uint256 nextTime, uint256 totalNums) = calcNowAvaiCRFI(uInfo);\n', '    if(avaiCRFI == 0){\n', '      return;\n', '    }\n', '\n', '    uInfo.restCRFI = uInfo.restCRFI.sub(avaiCRFI);\n', '    uInfo.nextTime = nextTime;\n', '    uInfo.totalNums = totalNums;\n', '\n', '    CRFI.transfer(uInfo.Addr, avaiCRFI);\n', '  }\n', '    \n', '  function calcNowAvaiCRFI(InvestInfo storage uInfo)\n', '    internal\n', '    view\n', '    returns(uint256 avaiCRFI, uint256 nextTime, uint256 totalNums){\n', '    if(block.timestamp < uInfo.nextTime || uInfo.restCRFI == 0 || uInfo.totalNums == 0){\n', '      return (0, uInfo.nextTime, uInfo.totalNums);\n', '    }\n', '\n', '    uint256 times = block.timestamp.sub(uInfo.nextTime) / uInfo.duration;\n', '    times++;\n', '    if(times > uInfo.totalNums){\n', '      times = uInfo.totalNums;\n', '    }\n', '\n', '    avaiCRFI = times.mul(uInfo.perTimeCRFI);\n', '    nextTime = uInfo.nextTime.add(uInfo.duration.mul(times));\n', '    \n', '    totalNums = uInfo.totalNums.sub(times);\n', '    if(totalNums == 0){\n', '      avaiCRFI = uInfo.restCRFI;\n', '    }\n', '\n', '    return(avaiCRFI, nextTime, totalNums);\n', '  }\n', '\n', '  function getUID(address addr) internal returns(uint256 uID){\n', '    uID = InvestAddrID[addr];\n', '    if(uID != 0){\n', '      return uID;\n', '    }\n', '\n', '    uID = NewInvestID;\n', '    NewInvestID++;\n', '\n', '    InvestInfo storage uInfo = Invests[uID];\n', '    uInfo.Addr = addr;\n', '    uInfo.ID = uID;\n', '        \n', '    InvestAddrID[addr] = uID;\n', '    return uID;\n', '  }\n', '\n', '}']