['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-07\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface TokenInterface is IERC20 {\n', '    function burnFromVault(uint256 amount) external returns (bool);\n', '}\n', '\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address owner) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint256);\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n', '    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint256 amount0In,\n', '        uint256 amount1In,\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function price0CumulativeLast() external view returns (uint256);\n', '    function price1CumulativeLast() external view returns (uint256);\n', '    function kLast() external view returns (uint256);\n', '    function mint(address to) external returns (uint256 liquidity);\n', '    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n', '    function swap(\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address to,\n', '        bytes calldata data\n', '    ) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountOut);\n', '\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountIn);\n', '\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external;\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable;\n', '}\n', '\n', 'contract YZYVault is Context, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    TokenInterface public _yzy;\n', '    TokenInterface public _yfi;\n', '    TokenInterface public _wbtc;\n', '    TokenInterface public _weth;\n', '\n', '    IUniswapV2Pair public _yzyETHV2Pair;\n', '    IUniswapV2Pair public _usdcETHV2Pair;\n', '\n', '    IUniswapV2Router02 private _uniswapV2Router;\n', '\n', '    address public _daoTreasury;\n', '\n', '    uint16 public _allocPointForYZYReward;\n', '    uint16 public _allocPointForSwapReward;\n', '\n', '    uint16 public _treasuryFee;\n', '    uint16 public _rewardFee;\n', '    uint16 public _lotteryFee;\n', '    uint16 public _swapRewardFee;\n', '    uint16 public _burnFee;\n', '    uint16 public _earlyUnstakeFee;\n', '\n', '    uint16 public _allocPointForYFI;\n', '    uint16 public _allocPointForWBTC;\n', '    uint16 public _allocPointForWETH;\n', '\n', '    uint256 public _firstRewardPeriod;\n', '    uint256 public _secondRewardPeriod;\n', '\n', '    uint256 public _firstRewardAmount;\n', '    uint256 public _secondRewardAmount;\n', '\n', '    uint256 public _claimPeriodForYzyReward;\n', '    uint256 public _claimPeriodForSwapReward;\n', '\n', '    uint256 public _lockPeriod;\n', '\n', '    uint256 public _minDepositETHAmount;\n', '\n', '    bool public _enabledLock;\n', '    bool public _enabledLottery;\n', '\n', '    uint256 public _startBlock;\n', '\n', '    uint256 private _lotteryAmount;\n', '    uint256 public _lotteryLimit;\n', '\n', '    uint256 public _collectedAmountForStakers;\n', '    uint256 public _collectedAmountForSwap;\n', '    uint256 public _collectedAmountForLottery;\n', '\n', '    uint256 public _lotteryPaidOut;\n', '\n', '    struct StakerInfo {\n', '        uint256 stakedAmount;\n', '        uint256 lastClimedBlockForYzyReward;\n', '        uint256 lastClimedBlockForSwapReward;\n', '        uint256 lockedTo;\n', '    }\n', '\n', '    mapping(address => StakerInfo) public _stakers;\n', '\n', '    // Info of winners for lottery.\n', '    struct WinnerInfo {\n', '        address winner;\n', '        uint256 amount;\n', '        uint256 timestamp;\n', '    }\n', '    WinnerInfo[] private winnerInfo;\n', '    \n', '    event ChangedEnabledLock(address indexed owner, bool lock);\n', '    event ChangedEnabledLottery(address indexed owner, bool lottery);\n', '    event ChangedLockPeriod(address indexed owner, uint256 period);\n', '    event ChangedMinimumETHDepositAmount(address indexed owner, uint256 value);\n', '    event ChangedRewardPeriod(address indexed owner, uint256 firstRewardPeriod, uint256 secondRewardPeriod);\n', '    event ChangedClaimPeriod(address indexed owner, uint256 claimPeriodForYzyReward, uint256 claimPeriodForSwapReward);\n', '    event ChangedYzyAddress(address indexed owner, address indexed yzy);\n', '    event ChangedYzyETHPair(address indexed owner, address indexed yzyETHPair);\n', '    event ChangedFeeInfo(address indexed owner, uint16 treasuryFee, uint16 rewardFee, uint16 lotteryFee, uint16 swapRewardFee, uint16 burnFee);\n', '    event ChangedAllocPointsForSwapReward(address indexed owner, uint16 valueForYFI, uint16 valueForWBTC, uint16 valueForWETH);\n', '    event ChangedBurnFee(address indexed owner, uint16 value);\n', '    event ChangedEarlyUnstakeFee(address indexed owner, uint16 value);\n', '    event ChangedLotteryInfo(address indexed owner, uint16 lotteryFee, uint256 lotteryLimit);\n', '\n', '    event ClaimedYzyAvailableReward(address indexed owner, uint256 amount);\n', '    event ClaimedSwapAvailableReward(address indexed owner, uint256 amount);\n', '    event ClaimedYzyReward(address indexed owner, uint256 available, uint256 pending);\n', '    event ClaimedSwapReward(address indexed owner, uint256 amount);\n', '\n', '    event Staked(address indexed account, uint256 amount);\n', '    event Unstaked(address indexed account, uint256 amount);\n', '\n', '    event SentLotteryAmount(address indexed owner, uint256 amount, bool status);\n', '    event EmergencyWithdrawToken(address indexed from, address indexed to, uint256 amount);\n', '    event SwapAndLiquifyForYZY(address indexed msgSender, uint256 totAmount, uint256 ethAmount, uint256 yzyAmount);\n', '\n', '    // Modifier\n', '\n', '    modifier onlyYzy() {\n', '        require(\n', '            address(_yzy) == _msgSender(),\n', '            "Ownable: caller is not the YZY token contract"\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        address daoTreasury,\n', '        address yfi,\n', '        address wbtc,\n', '        address weth,\n', '        address usdcETHV2Pair\n', '    ) {\n', '        _daoTreasury = daoTreasury;\n', '\n', '        _yfi = TokenInterface(yfi);\n', '        _wbtc = TokenInterface(wbtc);\n', '        _weth = TokenInterface(weth);\n', '\n', '        _usdcETHV2Pair = IUniswapV2Pair(usdcETHV2Pair);\n', '        _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '\n', '        _firstRewardPeriod = 71500; // around 11 days, could be changed by governance\n', '        _secondRewardPeriod = 429000; // around 66 days, could be changed by governance\n', '\n', '        _firstRewardAmount = 2000e18; // 2000 yzy tokens, could be changed by governance\n', '        _secondRewardAmount = 7900e18; // 7900 yzy tokens, could be changed by governance\n', '\n', '        _claimPeriodForYzyReward = 91000; // around 14 days, could be changed by governance\n', '        _claimPeriodForSwapReward = 585000; // around 90 days, could be changed by governance\n', '\n', '        _allocPointForYZYReward = 8000; // 80% of reward will go to YZY reward, could be changed by governance\n', '        _allocPointForSwapReward = 2000; // 20% of reward will go to swap(weth, wbtc, yfi) reward, could be changed by governance\n', '\n', '        // Set values divited from taxFee\n', '        _treasuryFee = 2500; // 25% of taxFee to treasuryFee, could be changed by governance\n', '        _rewardFee = 5000; // 50% of taxFee to stakers, could be changed by governance\n', '        _lotteryFee = 500; // 5% of lottery Fee, could be changed by governance\n', '        _swapRewardFee = 2000; // 20% of taxFee to swap tokens, could be changed by governance\n', '\n', '        _earlyUnstakeFee = 1000; // 10% of early unstake fee, could be changed by governance\n', '        \n', '        // set alloc points of YFI, WBTC, WETH in swap rewards, could be changed by governance\n', '        _allocPointForYFI = 3000; // 30% of fee to buy YFI token, could be changed by governance\n', '        _allocPointForWBTC = 5000; // 50% of fee to buy WBTC token, could be changed by governance\n', '        _allocPointForWETH = 2000; // 20% of fee to buy WETH token, could be changed by governance\n', '\n', '        // set the burn fee for withdraw early\n', '        _burnFee = 2000; // 20% of pending reward to burn when staker request to withdraw pending reward, could be changed by governance\n', '        \n', '        _minDepositETHAmount = 1e17; // 0.1 ether, could be changed by governance\n', '        _lockPeriod = 90 days; // could be changed by governance\n', '\n', '        _enabledLock = true; // could be changed by governance\n', '        _enabledLottery = true; // could be changed by governance\n', '\n', '        _lotteryLimit = 1200e6; // $1200(1200 usd, decimals 6), could be changed by governance\n', '        _startBlock = block.number;\n', '    }\n', '\n', '    /**\n', '     * @dev Change Minimum Deposit ETH Amount. Call by only Governance.\n', '     */\n', '    function changeMinimumDepositETHAmount(uint256 amount) external onlyOwner {\n', '        _minDepositETHAmount = amount;\n', '\n', '        emit ChangedMinimumETHDepositAmount(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Change value of reward period. Call by only Governance.\n', '     */\n', '    function changeRewardPeriod(uint256 firstRewardPeriod, uint256 secondRewardPeriod) external onlyOwner {\n', '        _firstRewardPeriod = firstRewardPeriod;\n', '        _secondRewardPeriod = secondRewardPeriod;\n', '\n', '        emit ChangedRewardPeriod(_msgSender(), firstRewardPeriod, secondRewardPeriod);\n', '    }\n', '\n', '    /**\n', '     * @dev Change value of claim period. Call by only Governance.\n', '     */\n', '    function changeClaimPeriod(uint256 claimPeriodForYzyReward, uint256 claimPeriodForSwapReward) external onlyOwner {\n', '        _claimPeriodForYzyReward = claimPeriodForYzyReward;\n', '        _claimPeriodForSwapReward = claimPeriodForSwapReward;\n', '\n', '        emit ChangedClaimPeriod(_msgSender(), claimPeriodForYzyReward, claimPeriodForSwapReward);\n', '    }\n', '\n', '    /**\n', '     * @dev Enable lock functionality. Call by only Governance.\n', '     */\n', '    function enableLock(bool isLock) external onlyOwner {\n', '        _enabledLock = isLock;\n', '\n', '        emit ChangedEnabledLock(_msgSender(), isLock);\n', '    }\n', '\n', '    /**\n', '     * @dev Enable lottery functionality. Call by only Governance.\n', '     */\n', '    function enableLottery(bool lottery) external onlyOwner {\n', '        _enabledLottery = lottery;\n', '\n', '        emit ChangedEnabledLottery(_msgSender(), lottery);\n', '    }\n', '\n', '    /**\n', '     * @dev Change maximun lock period. Call by only Governance.\n', '     */\n', '    function changeLockPeriod(uint256 period) external onlyOwner {\n', '        _lockPeriod = period;\n', '        \n', '        emit ChangedLockPeriod(_msgSender(), _lockPeriod);\n', '    }\n', '\n', '    function changeYzyAddress(address yzy) external onlyOwner {\n', '        _yzy = TokenInterface(yzy);\n', '\n', '        emit ChangedYzyAddress(_msgSender(), yzy);\n', '    }\n', '\n', '    function changeYzyETHPair(address yzyETHPair) external onlyOwner {\n', '        _yzyETHV2Pair = IUniswapV2Pair(yzyETHPair);\n', '\n', '        emit ChangedYzyETHPair(_msgSender(), yzyETHPair);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the treasury fee for this contract\n', '     * defaults at 25% of taxFee, It can be set on only by YZY governance.\n', '     * Note contract owner is meant to be a governance contract allowing YZY governance consensus\n', '     */\n', '    function changeFeeInfo(\n', '        uint16 treasuryFee,\n', '        uint16 rewardFee,\n', '        uint16 lotteryFee,\n', '        uint16 swapRewardFee,\n', '        uint16 burnFee\n', '    ) external onlyOwner {\n', '        _treasuryFee = treasuryFee;\n', '        _rewardFee = rewardFee;\n', '        _lotteryFee = lotteryFee;\n', '        _swapRewardFee = swapRewardFee;\n', '        _burnFee = burnFee;\n', '\n', '        emit ChangedFeeInfo(_msgSender(), treasuryFee, rewardFee, lotteryFee, swapRewardFee, burnFee);\n', '    }\n', '\n', '    function changeEarlyUnstakeFee(uint16 fee) external onlyOwner {\n', '        _earlyUnstakeFee = fee;\n', '\n', '        emit ChangedEarlyUnstakeFee(_msgSender(), fee);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the dev fee for this contract\n', '     * defaults at 5% of taxFee, It can be set on only by YZY governance.\n', '     * Note contract owner is meant to be a governance contract allowing YZY governance consensus\n', '     */\n', '    function changeLotteryInfo(uint16 lotteryFee, uint256 lotteryLimit) external onlyOwner {\n', '        _lotteryFee = lotteryFee;\n', '        _lotteryLimit = lotteryLimit;\n', '\n', '        emit ChangedLotteryInfo(_msgSender(), lotteryFee, lotteryLimit);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the alloc points for yfi, weth, wbtc rewards\n', '     * defaults at 50, 30, 20 of \n', '     * Note contract owner is meant to be a governance contract allowing YZY governance consensus\n', '     */\n', '    function changeAllocPointsForSwapReward(\n', '        uint16 allocPointForYFI_,\n', '        uint16 allocPointForWBTC_,\n', '        uint16 allocPointForWETH_\n', '    ) external onlyOwner {\n', '        _allocPointForYFI = allocPointForYFI_;\n', '        _allocPointForWBTC = allocPointForWBTC_;\n', '        _allocPointForWETH = allocPointForWETH_;\n', '\n', '        emit ChangedAllocPointsForSwapReward(_msgSender(), allocPointForYFI_, allocPointForWBTC_, allocPointForWETH_);\n', '    }\n', '\n', '    function addTaxFee(uint256 amount) external onlyYzy returns (bool) {\n', '        uint256 daoTreasuryReward = amount.mul(uint256(_treasuryFee)).div(10000);\n', '        _yzy.transfer(_daoTreasury, daoTreasuryReward);\n', '\n', '        uint256 stakerReward = amount.mul(uint256(_rewardFee)).div(10000);\n', '        _collectedAmountForStakers = _collectedAmountForStakers.add(stakerReward);\n', '\n', '        uint256 lotteryReward =  amount.mul(uint256(_lotteryFee)).div(10000);\n', '        _collectedAmountForLottery = _collectedAmountForLottery.add(lotteryReward);\n', '\n', '        _collectedAmountForSwap = _collectedAmountForSwap.add(amount.sub(daoTreasuryReward).sub(stakerReward).sub(lotteryReward));\n', '\n', '        return true;\n', '    }\n', '\n', '    function getTotalStakedAmount() public view returns (uint256) {\n', '        return _yzyETHV2Pair.balanceOf(address(this));\n', '    }\n', '    \n', '    function getWinners() external view returns (uint256) {\n', '        return winnerInfo.length;\n', '    }\n', '\n', '    // Get YZY reward per block\n', '    function getYzyPerBlockForYzyReward() public view returns (uint256) {\n', '        uint256 multiplier = getMultiplier(_startBlock, block.number);\n', '        \n', '        if (multiplier == 0 || getTotalStakedAmount() == 0) {\n', '            return 0;\n', '        } else if (multiplier <= _firstRewardPeriod) {\n', '            return _firstRewardAmount\n', '                    .mul(uint256(_allocPointForYZYReward))\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(_firstRewardPeriod)\n', '                    .div(10000);\n', '        } else if (multiplier > _firstRewardPeriod && multiplier <= _secondRewardPeriod) {\n', '            return _secondRewardAmount\n', '                    .mul(uint256(_allocPointForYZYReward))\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(_secondRewardPeriod)\n', '                    .div(10000);\n', '        } else {\n', '            return _collectedAmountForStakers.mul(1 ether).div(getTotalStakedAmount()).div(multiplier);\n', '        }\n', '    }\n', '\n', '    function getYzyPerBlockForSwapReward() public view returns (uint256) {\n', '        uint256 multiplier = getMultiplier(_startBlock, block.number);\n', '\n', '        if (multiplier == 0 || getTotalStakedAmount() == 0) {\n', '            return 0;\n', '        } else if (multiplier <= _firstRewardPeriod) {\n', '            return _firstRewardAmount\n', '                    .mul(uint256(_allocPointForSwapReward))\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(_firstRewardPeriod)\n', '                    .div(10000);\n', '        } else if (multiplier > _firstRewardPeriod && multiplier <= _secondRewardPeriod) {\n', '            return _secondRewardAmount\n', '                    .mul(uint256(_allocPointForSwapReward))\n', '                    .mul(1 ether)\n', '                    .div(getTotalStakedAmount())\n', '                    .div(_secondRewardPeriod)\n', '                    .div(10000);\n', '        } else {\n', '            return _collectedAmountForSwap.mul(1 ether).div(getTotalStakedAmount()).div(multiplier);\n', '        }\n', '    }\n', '\n', '    // Return reward multiplier over the given _from to _to block.\n', '    function getMultiplier(uint256 from, uint256 to) public pure returns (uint256) {\n', '        return to.sub(from);\n', '    }\n', '\n', '    function _getLastAvailableClaimedBlock(\n', '        uint256 from,\n', '        uint256 to,\n', '        uint256 period\n', '    ) internal pure returns (uint256) {\n', '        require(from <= to, "Vault: Invalid parameters for block number.");\n', '        require(period > 0, "Vault: Invalid period.");\n', '\n', '        uint256 multiplier = getMultiplier(from, to);\n', '\n', '        return from.add(multiplier.sub(multiplier.mod(period)));\n', '    }\n', '   \n', '    function swapETHForTokens(uint256 ethAmount) private {\n', '        // generate the uniswap pair path of weth -> yzy\n', '        address[] memory path = new address[](2);\n', '        path[0] = _uniswapV2Router.WETH();\n', '        path[1] = address(_yzy);\n', '\n', '        // make the swap\n', '        _uniswapV2Router.swapExactETHForTokensSupportingFeeOnTransferTokens{\n', '            value: ethAmount\n', '        }(0, path, address(this), block.timestamp);\n', '    }\n', '\n', '    function addLiquidityForEth(uint256 tokenAmount, uint256 ethAmount)\n', '        private\n', '    {\n', '        _yzy.approve(address(_uniswapV2Router), tokenAmount);\n', '\n', '        // add the liquidity\n', '        _uniswapV2Router.addLiquidityETH{value: ethAmount}(\n', '            address(_yzy),\n', '            tokenAmount,\n', '            0, // slippage is unavoidable\n', '            0, // slippage is unavoidable\n', '            address(this),\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    function swapAndLiquifyForYZY(uint256 amount) private returns (bool) {\n', '        uint256 halfForEth = amount.div(2);\n', '        uint256 otherHalfForYZY = amount.sub(halfForEth);\n', '\n', "        // capture the contract's current ETH balance.\n", '        // this is so that we can capture exactly the amount of ETH that the\n', '        // swap creates, and not make the liquidity event include any ETH that\n', '        // has been manually sent to the contract\n', '        uint256 initialBalance = _yzy.balanceOf(address(this));\n', '\n', '        // swap ETH for tokens\n', '        swapETHForTokens(otherHalfForYZY);\n', '\n', '        // how much YZY did we just swap into?\n', '        uint256 newBalance = _yzy.balanceOf(address(this)).sub(initialBalance);\n', '\n', '        // add liquidity to uniswap\n', '        addLiquidityForEth(newBalance, halfForEth);\n', '\n', '        emit SwapAndLiquifyForYZY(_msgSender(), amount, halfForEth, newBalance);\n', '\n', '        return true;\n', '    }\n', '\n', '    function swapTokensForTokens(\n', '        address fromTokenAddress,\n', '        address toTokenAddress,\n', '        uint256 tokenAmount,\n', '        address receivedAddress\n', '    ) private returns (bool) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = fromTokenAddress;\n', '        path[1] = toTokenAddress;\n', '\n', '        IERC20(fromTokenAddress).approve(\n', '            address(_uniswapV2Router),\n', '            tokenAmount\n', '        );\n', '\n', '        // make the swap\n', '        _uniswapV2Router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '            tokenAmount,\n', '            0, // accept any amount of pair token\n', '            path,\n', '            receivedAddress,\n', '            block.timestamp\n', '        );\n', '\n', '        return true;\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    function stake() external payable returns (bool) {\n', '        require(!isContract(_msgSender()), "Vault: Could not be contract.");\n', '        require(msg.value >= _minDepositETHAmount, "Vault: insufficient staking amount.");\n', '\n', '        // Check Initial Balance\n', '        uint256 initialBalance = _yzyETHV2Pair.balanceOf(address(this));\n', '\n', '        // Call swap for YZY&ETH\n', '        require(swapAndLiquifyForYZY(msg.value), "Vault: Failed to get LP tokens.");\n', '\n', '        uint256 newBalance = _yzyETHV2Pair.balanceOf(address(this)).sub(initialBalance);\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        if (staker.stakedAmount > 0) {\n', '            claimYzyReward();\n', '            claimSwapReward();\n', '        } else {\n', '            staker.lastClimedBlockForYzyReward = block.number;\n', '            staker.lastClimedBlockForSwapReward = block.number;\n', '        }\n', '\n', '        staker.stakedAmount = staker.stakedAmount.add(newBalance);\n', '        staker.lockedTo = _lockPeriod.add(block.timestamp);\n', '\n', '        emit Staked(_msgSender(), newBalance);\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    /**\n', '     * @dev Stake LP Token to get YZY-ETH LP tokens\n', '     */\n', '    function stakeLPToken(uint256 amount) external returns (bool) {\n', '        require(!isContract(_msgSender()), "Vault: Could not be contract.");\n', '\n', '        _yzyETHV2Pair.transferFrom(_msgSender(), address(this), amount);\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        if (staker.stakedAmount > 0) {\n', '            claimYzyReward();\n', '            claimSwapReward();\n', '        } else {\n', '            staker.lastClimedBlockForYzyReward = block.number;\n', '            staker.lastClimedBlockForSwapReward = block.number;\n', '        }\n', '\n', '        staker.stakedAmount = staker.stakedAmount.add(amount);\n', '        staker.lockedTo = _lockPeriod.add(block.timestamp);\n', '\n', '        emit Staked(_msgSender(), amount);\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    /**\n', '     * @dev Unstake staked YZY-ETH LP tokens\n', '     */\n', '    function unstake(uint256 amount) external returns (bool) {\n', '        require(!isContract(_msgSender()), "Vault: Could not be contract.");\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        require(\n', '            staker.stakedAmount > 0 &&\n', '            amount > 0 &&\n', '            amount <= staker.stakedAmount,\n', '            "Vault: Invalid amount to unstake."\n', '        );\n', '\n', '        claimYzyReward();\n', '\n', '        claimSwapReward();\n', '\n', '        if (_enabledLock &&\n', '            _stakers[_msgSender()].lockedTo > 0 &&\n', '            block.timestamp < _stakers[_msgSender()].lockedTo\n', '        ) {\n', '            uint256 feeAmount = amount.mul(uint256(_earlyUnstakeFee)).div(10000);\n', '            _yzyETHV2Pair.transfer(_daoTreasury, feeAmount); \n', '            _yzyETHV2Pair.transfer(_msgSender(), amount.sub(feeAmount));\n', '        } else {\n', '           _yzyETHV2Pair.transfer(_msgSender(), amount);\n', '        }\n', '\n', '        staker.stakedAmount = staker.stakedAmount.sub(amount);\n', '\n', '        emit Unstaked(_msgSender(), amount);\n', '        \n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    function getYzyReward(address account) public view returns (uint256 available, uint256 pending) {\n', '        StakerInfo memory staker = _stakers[account];\n', '        uint256 multiplier = getMultiplier(staker.lastClimedBlockForYzyReward, block.number);\n', '\n', '        if (staker.stakedAmount <= 0 || multiplier <= 0)  {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint256 yzyPerblock = getYzyPerBlockForYzyReward();\n', '        uint256 pendingBlockNum = multiplier.mod(_claimPeriodForYzyReward);\n', '\n', '        pending = yzyPerblock.mul(pendingBlockNum).mul(staker.stakedAmount).div(1 ether);\n', '        available = yzyPerblock.mul(multiplier.sub(pendingBlockNum)).mul(staker.stakedAmount).div(1 ether);\n', '    }\n', '\n', '    function getSwapReward(address account) public view returns (uint256 available, uint256 pending) {\n', '        StakerInfo memory staker = _stakers[account];\n', '        uint256 multiplier = getMultiplier(staker.lastClimedBlockForSwapReward, block.number);\n', '\n', '        if (staker.stakedAmount <= 0 || multiplier <= 0)  {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint256 yzyPerblock = getYzyPerBlockForSwapReward();\n', '        uint256 pendingBlockNum = multiplier.mod(_claimPeriodForSwapReward);\n', '\n', '        pending = yzyPerblock.mul(pendingBlockNum).mul(staker.stakedAmount).div(1 ether);\n', '        available = yzyPerblock.mul(multiplier.sub(pendingBlockNum)).mul(staker.stakedAmount).div(1 ether);\n', '    }\n', '\n', '    function claimYzyAvailableReward() public returns (bool) {\n', '\n', '        (uint256 available, ) = getYzyReward(_msgSender());\n', '\n', '        require(available > 0, "Vault: No available reward.");\n', '\n', '        require(\n', '            safeYzyTransfer(_msgSender(), available),\n', '            "Vault: Failed to transfer."\n', '        );\n', '\n', '        emit ClaimedYzyAvailableReward(_msgSender(), available);\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '        staker.lastClimedBlockForYzyReward = _getLastAvailableClaimedBlock(\n', '            staker.lastClimedBlockForYzyReward,\n', '            block.number,\n', '            _claimPeriodForYzyReward\n', '        );\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    function claimYzyReward() public returns (bool) {\n', '        (uint256 available, uint256 pending) = getYzyReward(_msgSender());\n', '\n', '        require(available > 0 || pending > 0, "Vault: No rewards");\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        if (available > 0) {\n', '            require(\n', '                safeYzyTransfer(_msgSender(), available),\n', '                "Vault: Failed to transfer."\n', '            );\n', '        }\n', '\n', '        if (pending > 0) {\n', '            uint256 burnAmount = pending.mul(_burnFee).div(10000);\n', '            _yzy.burnFromVault(burnAmount);\n', '            safeYzyTransfer(_msgSender(), pending.sub(burnAmount));\n', '            staker.lastClimedBlockForYzyReward = block.number;\n', '        } else if (available > 0) {\n', '            staker.lastClimedBlockForYzyReward = _getLastAvailableClaimedBlock(\n', '                staker.lastClimedBlockForYzyReward,\n', '                block.number,\n', '                _claimPeriodForYzyReward\n', '            );\n', '        }\n', '\n', '        emit ClaimedYzyReward(_msgSender(), available, pending);\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    function claimSwapAvailableReward() public returns (bool) {\n', '\n', '        (uint256 available, ) = getSwapReward(_msgSender());\n', '\n', '        _swapAndClaimTokens(available);\n', '\n', '        emit ClaimedSwapAvailableReward(_msgSender(), available);\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '        staker.lastClimedBlockForSwapReward = _getLastAvailableClaimedBlock(\n', '            staker.lastClimedBlockForSwapReward,\n', '            block.number,\n', '            _claimPeriodForSwapReward\n', '        );\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    function claimSwapReward() public returns (bool) {\n', '\n', '        (uint256 available, uint256 pending) = getSwapReward(_msgSender());\n', '\n', '        if (pending > 0) {\n', '            uint256 burnAmount = pending.mul(_burnFee).div(10000);\n', '            _yzy.burnFromVault(burnAmount);\n', '            pending = pending.sub(burnAmount);\n', '        }\n', '\n', '        _swapAndClaimTokens(available.add(pending));\n', '\n', '        emit ClaimedSwapReward(_msgSender(), available.add(pending));\n', '\n', '        StakerInfo storage staker = _stakers[_msgSender()];\n', '\n', '        if (pending > 0) {\n', '            staker.lastClimedBlockForSwapReward = block.number;\n', '        } else {\n', '            staker.lastClimedBlockForSwapReward = _getLastAvailableClaimedBlock(\n', '                staker.lastClimedBlockForSwapReward,\n', '                block.number,\n', '                _claimPeriodForSwapReward\n', '            );\n', '        }\n', '\n', '        return _sendLotteryAmount();\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw YZY token from vault wallet to owner when only emergency!\n', '     *\n', '     */\n', '    function emergencyWithdrawToken() external onlyOwner {\n', '        require(_msgSender() != address(0), "Vault: Invalid address");\n', '\n', '        uint256 tokenAmount = _yzy.balanceOf(address(this));\n', '        require(tokenAmount > 0, "Vault: Insufficient amount");\n', '\n', '        _yzy.transfer(_msgSender(), tokenAmount);\n', '        emit EmergencyWithdrawToken(address(this), _msgSender(), tokenAmount);\n', '    }\n', '\n', '    function _swapAndClaimTokens(uint256 rewards) internal {\n', '        require(rewards > 0, "Vault: No reward state");\n', '\n', '        uint256 wethOldBalance = IERC20(_weth).balanceOf(address(this));\n', '\n', '        // Swap YZY -> WETH And Get Weth Tokens For Reward\n', '        require(\n', '            swapTokensForTokens(\n', '                address(_yzy),\n', '                address(_weth),\n', '                rewards,\n', '                address(this)\n', '            ),\n', '            "Vault: Failed to swap from YZY to WETH."\n', '        );\n', '\n', '        // Get New Swaped ETH Amount\n', '        uint256 wethNewBalance = IERC20(_weth).balanceOf(address(this)).sub(wethOldBalance);\n', '\n', '        require(wethNewBalance > 0, "Vault: Invalid WETH amount.");\n', '\n', '        uint256 yfiTokenReward = wethNewBalance.mul(_allocPointForYFI).div(10000);\n', '        uint256 wbtcTokenReward = wethNewBalance.mul(_allocPointForWBTC).div(10000);\n', '        uint256 wethTokenReward = wethNewBalance.sub(yfiTokenReward).sub(wbtcTokenReward);\n', '\n', '        // Transfer Weth Reward Tokens From Contract To Staker\n', '        require(\n', '            IERC20(_weth).transfer(_msgSender(), wethTokenReward),\n', '            "Vault: Faild to WETH"\n', '        );\n', '\n', '        // Swap WETH -> YFI and give YFI token to User as reward\n', '        require(\n', '            swapTokensForTokens(\n', '                address(_weth),\n', '                address(_yfi),\n', '                yfiTokenReward,\n', '                _msgSender()\n', '            ),\n', '            "Vault: Failed to swap YFI."\n', '        );\n', '\n', '        // Swap YZY -> WBTC and give WBTC token to User as reward\n', '        require(\n', '            swapTokensForTokens(\n', '                address(_weth),\n', '                address(_wbtc),\n', '                wbtcTokenReward,\n', '                _msgSender()\n', '            ),\n', '            "Vault: Failed to swap WBTC."\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to send lottery rewards\n', '     */\n', '    function _sendLotteryAmount() internal returns (bool) {\n', '        if (!_enabledLottery || _lotteryAmount <= 0)\n', '            return false;\n', '        \n', '        uint256 usdcReserve = 0;\n', '        uint256 ethReserve1 = 0;\n', '        uint256 yzyReserve = 0;\n', '        uint256 ethReserve2 = 0;\n', '        address token0 = _usdcETHV2Pair.token0();\n', '\n', '        if (token0 == address(_weth)){\n', '            (ethReserve1, usdcReserve, ) = _usdcETHV2Pair.getReserves();\n', '        } else {\n', '            (usdcReserve, ethReserve1, ) = _usdcETHV2Pair.getReserves();\n', '        }\n', '\n', '        token0 = _yzyETHV2Pair.token0();\n', '\n', '        if (token0 == address(_weth)){\n', '            (ethReserve2, yzyReserve, ) = _yzyETHV2Pair.getReserves();\n', '        } else {\n', '            (yzyReserve, ethReserve2, ) = _yzyETHV2Pair.getReserves();\n', '        }\n', '\n', '        if (ethReserve1 <= 0 || yzyReserve <= 0)\n', '            return false;\n', '\n', '        uint256 yzyPrice = usdcReserve.mul(1 ether).div(ethReserve1).mul(ethReserve2).div(yzyReserve);\n', '        uint256 lotteryValue = yzyPrice.mul(_lotteryAmount).div(1 ether);\n', '\n', '        if (lotteryValue > 0 && lotteryValue >= _lotteryLimit) {\n', '            uint256 amount = _lotteryLimit.mul(1 ether).div(yzyPrice);\n', '\n', '            if (amount > _lotteryAmount)\n', '                amount = _lotteryAmount;\n', '\n', '            _yzy.transfer(_msgSender(), amount);\n', '            _lotteryAmount = _lotteryAmount.sub(amount);\n', '            _lotteryPaidOut = _lotteryPaidOut.add(amount);\n', '\n', '            emit SentLotteryAmount(_msgSender(), amount, true);\n', '\n', '            winnerInfo.push(\n', '                WinnerInfo({\n', '                    winner: _msgSender(),\n', '                    amount: amount,\n', '                    timestamp: block.timestamp\n', '                })\n', '            );\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    function safeYzyTransfer(address to, uint256 amount) internal returns (bool) {\n', '        uint256 yzyBal = _yzy.balanceOf(address(this));\n', '\n', '        if (amount > yzyBal) {\n', '            _yzy.transfer(to, yzyBal);\n', '        } else {\n', '            _yzy.transfer(to, amount);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}']