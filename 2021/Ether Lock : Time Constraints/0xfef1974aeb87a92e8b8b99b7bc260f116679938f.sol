['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-17\n', '*/\n', '\n', '// File: contracts/interfaces/ILiquidationManager.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's liquidation manager interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface ILiquidationManager  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\tfunction partialLiquidation(address payable delinquentBorrower, uint256 targetHandler, uint256 liquidateAmount, uint256 receiveHandler) external returns (uint256);\n', '\tfunction checkLiquidation(address payable userAddr) external view returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IManagerSlotSetter.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's Manager Context Setter interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IManagerSlotSetter  {\n', '  function ownershipTransfer(address payable _owner) external returns (bool);\n', '  function setOperator(address payable adminAddr, bool flag) external returns (bool);\n', '  function setOracleProxy(address oracleProxyAddr) external returns (bool);\n', '  function setRewardErc20(address erc20Addr) external returns (bool);\n', '  function setBreakerTable(address _target, bool _status) external returns (bool);\n', '  function setCircuitBreaker(bool _emergency) external returns (bool);\n', '  function handlerRegister(uint256 handlerID, address tokenHandlerAddr, uint256 flashFeeRate, uint256 discountBase) external returns (bool);\n', '  function setLiquidationManager(address liquidationManagerAddr) external returns (bool);\n', '  function setHandlerSupport(uint256 handlerID, bool support) external returns (bool);\n', '  function setPositionStorageAddr(address _positionStorageAddr) external returns (bool);\n', '  function setNFTAddr(address _nftAddr) external returns (bool);\n', '  function setDiscountBase(uint256 handlerID, uint256 feeBase) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IHandlerManager.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's Manager Interest interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IHandlerManager  {\n', '  function applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256, uint256, uint256, uint256);\n', '  function interestUpdateReward() external returns (bool);\n', '  function updateRewardParams(address payable userAddr) external returns (bool);\n', '  function rewardClaimAll(address payable userAddr) external returns (uint256);\n', '  function claimHandlerReward(uint256 handlerID, address payable userAddr) external returns (uint256);\n', '  function ownerRewardTransfer(uint256 _amount) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IManagerFlashloan.sol\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IManagerFlashloan {\n', '  function withdrawFlashloanFee(uint256 handlerID) external returns (bool);\n', '\n', '  function flashloan(\n', '    uint256 handlerID,\n', '    address receiverAddress,\n', '    uint256 amount,\n', '    bytes calldata params\n', '  ) external returns (bool);\n', '\n', '  function getFee(uint256 handlerID, uint256 amount) external view returns (uint256);\n', '\n', '  function getFeeTotal(uint256 handlerID) external view returns (uint256);\n', '\n', '  function getFeeFromArguments(uint256 handlerID, uint256 amount, uint256 bifiAmo) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/SafeMath.sol\n', 'pragma solidity ^0.6.12;\n', '\n', '// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n', '// Subject to the MIT license.\n', '\n', '/**\n', " * @title BiFi's safe-math Contract\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'library SafeMath {\n', '  uint256 internal constant unifiedPoint = 10 ** 18;\n', '\t/******************** Safe Math********************/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "a");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _sub(a, b, "s");\n', '\t}\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _mul(a, b);\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(a, b, "d");\n', '\t}\n', '\n', '\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b <= a, errorMessage);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a* b;\n', '\t\trequire((c / a) == b, "m");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b > 0, errorMessage);\n', '\t\treturn a / b;\n', '\t}\n', '\n', '\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, unifiedPoint), b, "d");\n', '\t}\n', '\n', '\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, b), unifiedPoint, "m");\n', '\t}\n', '}\n', '\n', '// File: contracts/interfaces/IManagerDataStorage.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's manager data storage interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IManagerDataStorage  {\n', '\tfunction getGlobalRewardPerBlock() external view returns (uint256);\n', '\tfunction setGlobalRewardPerBlock(uint256 _globalRewardPerBlock) external returns (bool);\n', '\n', '\tfunction getGlobalRewardDecrement() external view returns (uint256);\n', '\tfunction setGlobalRewardDecrement(uint256 _globalRewardDecrement) external returns (bool);\n', '\n', '\tfunction getGlobalRewardTotalAmount() external view returns (uint256);\n', '\tfunction setGlobalRewardTotalAmount(uint256 _globalRewardTotalAmount) external returns (bool);\n', '\n', '\tfunction getAlphaRate() external view returns (uint256);\n', '\tfunction setAlphaRate(uint256 _alphaRate) external returns (bool);\n', '\n', '\tfunction getAlphaLastUpdated() external view returns (uint256);\n', '\tfunction setAlphaLastUpdated(uint256 _alphaLastUpdated) external returns (bool);\n', '\n', '\tfunction getRewardParamUpdateRewardPerBlock() external view returns (uint256);\n', '\tfunction setRewardParamUpdateRewardPerBlock(uint256 _rewardParamUpdateRewardPerBlock) external returns (bool);\n', '\n', '\tfunction getRewardParamUpdated() external view returns (uint256);\n', '\tfunction setRewardParamUpdated(uint256 _rewardParamUpdated) external returns (bool);\n', '\n', '\tfunction getInterestUpdateRewardPerblock() external view returns (uint256);\n', '\tfunction setInterestUpdateRewardPerblock(uint256 _interestUpdateRewardPerblock) external returns (bool);\n', '\n', '\tfunction getInterestRewardUpdated() external view returns (uint256);\n', '\tfunction setInterestRewardUpdated(uint256 _interestRewardLastUpdated) external returns (bool);\n', '\n', '\tfunction setTokenHandler(uint256 handlerID, address handlerAddr) external returns (bool);\n', '\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address);\n', '\n', '\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\n', '\n', '\tfunction getTokenHandlerAddr(uint256 handlerID) external view returns (address);\n', '\tfunction setTokenHandlerAddr(uint256 handlerID, address handlerAddr) external returns (bool);\n', '\n', '\tfunction getTokenHandlerExist(uint256 handlerID) external view returns (bool);\n', '\tfunction setTokenHandlerExist(uint256 handlerID, bool exist) external returns (bool);\n', '\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\n', '\tfunction setTokenHandlerSupport(uint256 handlerID, bool support) external returns (bool);\n', '\n', '\tfunction setLiquidationManagerAddr(address _liquidationManagerAddr) external returns (bool);\n', '\tfunction getLiquidationManagerAddr() external view returns (address);\n', '\n', '\tfunction setManagerAddr(address _managerAddr) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IOracleProxy.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's oracle proxy interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IOracleProxy  {\n', '\tfunction getTokenPrice(uint256 tokenID) external view returns (uint256);\n', '\n', '\tfunction getOracleFeed(uint256 tokenID) external view returns (address, uint256);\n', '\tfunction setOracleFeed(uint256 tokenID, address feedAddr, uint256 decimals, bool needPriceConvert, uint256 priceConvertID) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n', 'pragma solidity 0.6.12;\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external ;\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external ;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/interfaces/IObserver.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's Observer interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IObserver {\n', '    function getAlphaBaseAsset() external view returns (uint256[] memory);\n', '    function setChainGlobalRewardPerblock(uint256 _idx, uint256 globalRewardPerBlocks) external returns (bool);\n', '    function updateChainMarketInfo(uint256 _idx, uint256 chainDeposit, uint256 chainBorrow) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IProxy.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's proxy interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IProxy  {\n', '\tfunction handlerProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction handlerViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '\tfunction siProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction siViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '}\n', '\n', '// File: contracts/interfaces/IMarketHandler.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's market handler interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IMarketHandler  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\tfunction setCircuitBreakWithOwner(bool _emergency) external returns (bool);\n', '\n', '\tfunction getTokenName() external view returns (string memory);\n', '\n', '\tfunction ownershipTransfer(address payable newOwner) external returns (bool);\n', '\n', '\tfunction deposit(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\tfunction withdraw(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction borrow(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction repay(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\n', '\tfunction executeFlashloan(\n', '\t\taddress receiverAddress,\n', '\t\tuint256 amount\n', '  ) external returns (bool);\n', '\n', '\tfunction depositFlashloanFee(\n', '\t\tuint256 amount\n', '\t) external returns (bool);\n', '\n', '  function convertUnifiedToUnderlying(uint256 unifiedTokenAmount) external view returns (uint256);\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) external returns (uint256);\n', '\n', '\tfunction getTokenHandlerLimit() external view returns (uint256, uint256);\n', '  function getTokenHandlerBorrowLimit() external view returns (uint256);\n', '\tfunction getTokenHandlerMarginCallLimit() external view returns (uint256);\n', '\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) external returns (bool);\n', '\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) external returns (bool);\n', '\n', '  function getTokenLiquidityAmountWithInterest(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction getUserAmountWithInterest(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserMaxBorrowAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxRepayAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction checkFirstAction() external returns (bool);\n', '\tfunction applyInterest(address payable userAddr) external returns (uint256, uint256);\n', '\n', '\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable returns (bool);\n', '\tfunction reserveWithdraw(uint256 unifiedTokenAmount) external returns (bool);\n', '\n', '\tfunction withdrawFlashloanFee(uint256 unifiedTokenAmount) external returns (bool);\n', '\n', '\tfunction getDepositTotalAmount() external view returns (uint256);\n', '\tfunction getBorrowTotalAmount() external view returns (uint256);\n', '\n', '\tfunction getSIRandBIR() external view returns (uint256, uint256);\n', '\n', '  function getERC20Addr() external view returns (address);\n', '}\n', '\n', '// File: contracts/interfaces/IServiceIncentive.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's si interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IServiceIncentive  {\n', '\tfunction setCircuitBreakWithOwner(bool emergency) external returns (bool);\n', '\tfunction setCircuitBreaker(bool emergency) external returns (bool);\n', '\n', '\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) external returns (bool);\n', '\tfunction updateRewardLane(address payable userAddr) external returns (bool);\n', '\n', '\tfunction getBetaRateBaseTotalAmount() external view returns (uint256);\n', '\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction getUserRewardInfo(address payable userAddr) external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction claimRewardAmountUser(address payable userAddr) external returns (uint256);\n', '}\n', '\n', '// File: contracts/Errors.sol\n', 'pragma solidity 0.6.12;\n', '\n', 'contract Modifier {\n', '    string internal constant ONLY_OWNER = "O";\n', '    string internal constant ONLY_MANAGER = "M";\n', '    string internal constant CIRCUIT_BREAKER = "emergency";\n', '}\n', '\n', 'contract ManagerModifier is Modifier {\n', '    string internal constant ONLY_HANDLER = "H";\n', '    string internal constant ONLY_LIQUIDATION_MANAGER = "LM";\n', '    string internal constant ONLY_BREAKER = "B";\n', '}\n', '\n', 'contract HandlerDataStorageModifier is Modifier {\n', '    string internal constant ONLY_BIFI_CONTRACT = "BF";\n', '}\n', '\n', 'contract SIDataStorageModifier is Modifier {\n', '    string internal constant ONLY_SI_HANDLER = "SI";\n', '}\n', '\n', 'contract HandlerErrors is Modifier {\n', '    string internal constant USE_VAULE = "use value";\n', '    string internal constant USE_ARG = "use arg";\n', '    string internal constant EXCEED_LIMIT = "exceed limit";\n', '    string internal constant NO_LIQUIDATION = "no liquidation";\n', '    string internal constant NO_LIQUIDATION_REWARD = "no enough reward";\n', '    string internal constant NO_EFFECTIVE_BALANCE = "not enough balance";\n', '    string internal constant TRANSFER = "err transfer";\n', '}\n', '\n', 'contract SIErrors is Modifier { }\n', '\n', 'contract InterestErrors is Modifier { }\n', '\n', 'contract LiquidationManagerErrors is Modifier {\n', '    string internal constant NO_DELINQUENT = "not delinquent";\n', '}\n', '\n', 'contract ManagerErrors is ManagerModifier {\n', '    string internal constant REWARD_TRANSFER = "RT";\n', '    string internal constant UNSUPPORTED_TOKEN = "UT";\n', '}\n', '\n', 'contract OracleProxyErrors is Modifier {\n', '    string internal constant ZERO_PRICE = "price zero";\n', '}\n', '\n', 'contract RequestProxyErrors is Modifier { }\n', '\n', 'contract ManagerDataStorageErrors is ManagerModifier {\n', '    string internal constant NULL_ADDRESS = "err addr null";\n', '}\n', '\n', '// File: contracts/marketManager/ManagerSlot.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's Slot contract\n", ' * @notice Manager Slot Definitions & Allocations\n', ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'contract ManagerSlot is ManagerErrors {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public owner;\n', '\tmapping(address => bool) operators;\n', '\tmapping(address => Breaker) internal breakerTable;\n', '\n', '\tbool public emergency = false;\n', '\n', '\tIManagerDataStorage internal dataStorageInstance;\n', '\tIOracleProxy internal oracleProxy;\n', '\n', '\t/* feat: manager reward token instance*/\n', '\tIERC20 internal rewardErc20Instance;\n', '\n', '\tIObserver public Observer;\n', '\n', '\taddress public slotSetterAddr;\n', '\taddress public handlerManagerAddr;\n', '\taddress public flashloanAddr;\n', '\n', '  // BiFi-X\n', '  address public positionStorageAddr;\n', '  address public nftAddr;\n', '\n', '\tuint256 public tokenHandlerLength;\n', '\n', '  struct FeeRateParams {\n', '    uint256 unifiedPoint;\n', '    uint256 minimum;\n', '    uint256 slope;\n', '    uint256 discountRate;\n', '  }\n', '\n', '  struct HandlerFlashloan {\n', '      uint256 flashFeeRate;\n', '      uint256 discountBase;\n', '      uint256 feeTotal;\n', '  }\n', '\n', '  mapping(uint256 => HandlerFlashloan) public handlerFlashloan;\n', '\n', '\tstruct UserAssetsInfo {\n', '\t\tuint256 depositAssetSum;\n', '\t\tuint256 borrowAssetSum;\n', '\t\tuint256 marginCallLimitSum;\n', '\t\tuint256 depositAssetBorrowLimitSum;\n', '\t\tuint256 depositAsset;\n', '\t\tuint256 borrowAsset;\n', '\t\tuint256 price;\n', '\t\tuint256 callerPrice;\n', '\t\tuint256 depositAmount;\n', '\t\tuint256 borrowAmount;\n', '\t\tuint256 borrowLimit;\n', '\t\tuint256 marginCallLimit;\n', '\t\tuint256 callerBorrowLimit;\n', '\t\tuint256 userBorrowableAsset;\n', '\t\tuint256 withdrawableAsset;\n', '\t}\n', '\n', '\tstruct Breaker {\n', '\t\tbool auth;\n', '\t\tbool tried;\n', '\t}\n', '\n', '\tstruct ContractInfo {\n', '\t\tbool support;\n', '\t\taddress addr;\n', '    address tokenAddr;\n', '\n', '    uint256 expectedBalance;\n', '    uint256 afterBalance;\n', '\n', '\t\tIProxy tokenHandler;\n', '\t\tbytes data;\n', '\n', '\t\tIMarketHandler handlerFunction;\n', '\t\tIServiceIncentive siFunction;\n', '\n', '\t\tIOracleProxy oracleProxy;\n', '\t\tIManagerDataStorage managerDataStorage;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner, ONLY_OWNER);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyHandler(uint256 handlerID) {\n', '\t\t_isHandler(handlerID);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyOperators {\n', '\t\taddress payable sender = msg.sender;\n', '\t\trequire(operators[sender] || sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isHandler(uint256 handlerID) internal view {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == dataStorageInstance.getTokenHandlerAddr(handlerID)) || (msgSender == owner), ONLY_HANDLER);\n', '\t}\n', '\n', '\tmodifier onlyLiquidationManager {\n', '\t\t_isLiquidationManager();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isLiquidationManager() internal view {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == dataStorageInstance.getLiquidationManagerAddr()) || (msgSender == owner), ONLY_LIQUIDATION_MANAGER);\n', '\t}\n', '\n', '\tmodifier circuitBreaker {\n', '\t\t_isCircuitBreak();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isCircuitBreak() internal view {\n', '\t\trequire((!emergency) || (msg.sender == owner), CIRCUIT_BREAKER);\n', '\t}\n', '\n', '\tmodifier onlyBreaker {\n', '\t\t_isBreaker();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isBreaker() internal view {\n', '\t\trequire(breakerTable[msg.sender].auth, ONLY_BREAKER);\n', '\t}\n', '}\n', '\n', '// File: contracts/marketManager/TokenManager.sol\n', '// SPDX-License-Identifier: BSD-3-Clause\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's marketManager contract\n", ' * @notice Implement business logic and manage handlers\n', ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'contract TokenManager is ManagerSlot {\n', '\n', '\t/**\n', '\t* @dev Constructor for marketManager\n', '\t* @param managerDataStorageAddr The address of the manager storage contract\n', '\t* @param oracleProxyAddr The address of oracle proxy contract (e.g., price feeds)\n', '\t* @param breaker The address of default circuit breaker\n', '\t* @param erc20Addr The address of reward token (ERC-20)\n', '\t*/\n', '\tconstructor (address managerDataStorageAddr, address oracleProxyAddr, address _slotSetterAddr, address _handlerManagerAddr, address _flashloanAddr, address breaker, address erc20Addr) public\n', '\t{\n', '\t\towner = msg.sender;\n', '\t\tdataStorageInstance = IManagerDataStorage(managerDataStorageAddr);\n', '\t\toracleProxy = IOracleProxy(oracleProxyAddr);\n', '\t\trewardErc20Instance = IERC20(erc20Addr);\n', '\n', '\t\tslotSetterAddr = _slotSetterAddr;\n', '\t\thandlerManagerAddr = _handlerManagerAddr;\n', '\t\tflashloanAddr = _flashloanAddr;\n', '\n', '\t\tbreakerTable[owner].auth = true;\n', '\t\tbreakerTable[breaker].auth = true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer ownership\n', '\t* @param _owner the address of the new owner\n', '\t* @return result the setter call in contextSetter contract\n', '\t*/\n', '\tfunction ownershipTransfer(address payable _owner) onlyOwner public returns (bool result) {\n', '    bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t.ownershipTransfer.selector,\n', '\t\t\t\t_owner\n', '\t\t\t);\n', '\n', '    (result, ) = slotSetterAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\tfunction setOperator(address payable adminAddr, bool flag) onlyOwner external returns (bool result) {\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t.setOperator.selector,\n', '\t\t\t\tadminAddr, flag\n', '\t\t\t);\n', '\n', '\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the address of OracleProxy contract\n', '\t* @param oracleProxyAddr The address of OracleProxy contract\n', '\t* @return result the setter call in contextSetter contract\n', '\t*/\n', '\tfunction setOracleProxy(address oracleProxyAddr) onlyOwner external returns (bool result) {\n', '    bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t.setOracleProxy.selector,\n', '\t\t\t\toracleProxyAddr\n', '\t\t\t);\n', '\n', '\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the address of BiFi reward token contract\n', '\t* @param erc20Addr The address of BiFi reward token contract\n', '\t* @return result the setter call in contextSetter contract\n', '\t*/\n', '\tfunction setRewardErc20(address erc20Addr) onlyOwner public returns (bool result) {\n', '    bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t.setRewardErc20.selector,\n', '\t\t\t\terc20Addr\n', '\t\t\t);\n', '\n', '\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Authorize admin user for circuitBreaker\n', '\t* @param _target The address of the circuitBreaker admin user.\n', '\t* @param _status The boolean status of circuitBreaker (on/off)\n', '\t* @return result the setter call in contextSetter contract\n', '\t*/\n', '\tfunction setBreakerTable(address _target, bool _status) onlyOwner external returns (bool result) {\n', '    bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t.setBreakerTable.selector,\n', '\t\t\t\t_target, _status\n', '\t\t\t);\n', '\n', '\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set circuitBreak to freeze/unfreeze all handlers\n', '\t* @param _emergency The boolean status of circuitBreaker (on/off)\n', '\t* @return result the setter call in contextSetter contract\n', '\t*/\n', '\tfunction setCircuitBreaker(bool _emergency) onlyBreaker external returns (bool result) {\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t.setCircuitBreaker.selector,\n', '\t\t\t\t_emergency\n', '\t\t\t);\n', '\n', '\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\tfunction setPositionStorageAddr(address _positionStorageAddr) onlyOwner external returns (bool result) {\n', '\t\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\t\tIManagerSlotSetter.setPositionStorageAddr.selector,\n', '\t\t\t\t\t_positionStorageAddr\n', '\t\t\t\t);\n', '\n', '\t\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '\t\tassert(result);\n', '\t}\n', '\n', '\tfunction setNFTAddr(address _nftAddr) onlyOwner external returns (bool result) {\n', '\t\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\t\tIManagerSlotSetter.setNFTAddr.selector,\n', '\t\t\t\t\t_nftAddr\n', '\t\t\t\t);\n', '\n', '\t\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '\t\tassert(result);\n', '\t}\n', '\n', '\tfunction setDiscountBase(uint256 handlerID, uint256 feeBase) onlyOwner external returns (bool result) {\n', '\t\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t\t.setDiscountBase.selector,\n', '\t\t\t\t\thandlerID,\n', '\t\t\tfeeBase\n', '\t\t\t\t);\n', '\n', '\t\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '\t\tassert(result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the circuitBreak status\n', '\t* @return The circuitBreak status\n', '\t*/\n', '\tfunction getCircuitBreaker() external view returns (bool)\n', '\t{\n', '\t\treturn emergency;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get information for a handler\n', '\t* @param handlerID Handler ID\n', '\t* @return (success or failure, handler address, handler name)\n', '\t*/\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address, string memory)\n', '\t{\n', '\t\tbool support;\n', '\t\taddress tokenHandlerAddr;\n', '\t\tstring memory tokenName;\n', '\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\n', '\t\t{\n', '\t\t\ttokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(handlerID);\n', '\t\t\tIProxy TokenHandler = IProxy(tokenHandlerAddr);\n', '\t\t\tbytes memory data;\n', '\t\t\t(, data) = TokenHandler.handlerViewProxy(\n', '\t\t\t\tabi.encodeWithSelector(\n', '\t\t\t\t\tIMarketHandler\n', '\t\t\t\t\t.getTokenName.selector\n', '\t\t\t\t)\n', '\t\t\t);\n', '\t\t\ttokenName = abi.decode(data, (string));\n', '\t\t\tsupport = true;\n', '\t\t}\n', '\n', '\t\treturn (support, tokenHandlerAddr, tokenName);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Register a handler\n', '\t* @param handlerID Handler ID and address\n', '\t* @param tokenHandlerAddr The handler address\n', '\t* @return result the setter call in contextSetter contract\n', '\t*/\n', '\tfunction handlerRegister(uint256 handlerID, address tokenHandlerAddr, uint256 flashFeeRate, uint256 discountBase) onlyOwner external returns (bool result) {\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t\t.handlerRegister.selector,\n', '\t\t\t\t\thandlerID, tokenHandlerAddr, flashFeeRate, discountBase\n', '\t\t\t\t);\n', '\n', '\t\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '\t\tassert(result);\n', '\t}\n', '\t/**\n', '\t* @dev Set a liquidation manager contract\n', '\t* @param liquidationManagerAddr The address of liquidiation manager\n', '\t* @return result the setter call in contextSetter contract\n', '\t*/\n', '\tfunction setLiquidationManager(address liquidationManagerAddr) onlyOwner external returns (bool result) {\n', '    bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t.setLiquidationManager.selector,\n', '\t\t\t\tliquidationManagerAddr\n', '\t\t\t);\n', '\n', '\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update the (SI) rewards for a user\n', '\t* @param userAddr The address of the user\n', '\t* @param callerID The handler ID\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction rewardUpdateOfInAction(address payable userAddr, uint256 callerID) external returns (bool)\n', '\t{\n', '\t\tContractInfo memory handlerInfo;\n', '\t\t(handlerInfo.support, handlerInfo.addr) = dataStorageInstance.getTokenHandlerInfo(callerID);\n', '\t\tif (handlerInfo.support)\n', '\t\t{\n', '\t\t\tIProxy TokenHandler;\n', '\t\t\tTokenHandler = IProxy(handlerInfo.addr);\n', '\t\t\tTokenHandler.siProxy(\n', '\t\t\t\tabi.encodeWithSelector(\n', '\t\t\t\t\tIServiceIncentive\n', '\t\t\t\t\t.updateRewardLane.selector,\n', '\t\t\t\t\tuserAddr\n', '\t\t\t\t)\n', '\t\t\t);\n', '\t\t}\n', '\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Update interest of a user for a handler (internal)\n', '\t* @param userAddr The user address\n', '\t* @param callerID The handler ID\n', '\t* @param allFlag Flag for the full calculation mode (calculting for all handlers)\n', '\t* @return (uint256, uint256, uint256, uint256, uint256, uint256)\n', '\t*/\n', '\tfunction applyInterestHandlers(address payable userAddr, uint256 callerID, bool allFlag) external returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n', '    bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIHandlerManager\n', '\t\t\t\t.applyInterestHandlers.selector,\n', '\t\t\t\tuserAddr, callerID, allFlag\n', '\t\t\t);\n', '\n', '\t\t(bool result, bytes memory returnData) = handlerManagerAddr.delegatecall(callData);\n', '    assert(result);\n', '\n', '    return abi.decode(returnData, (uint256, uint256, uint256, uint256, uint256, uint256));\n', '  }\n', '\n', '\t/**\n', '\t* @dev Reward the user (msg.sender) with the reward token after calculating interest.\n', '\t* @return result the interestUpdateReward call in ManagerInterest contract\n', '\t*/\n', '\tfunction interestUpdateReward() external returns (bool result) {\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIHandlerManager\n', '\t\t\t\t.interestUpdateReward.selector\n', '\t\t\t);\n', '\n', '\t\t(result, ) = handlerManagerAddr.delegatecall(callData);\n', '    \tassert(result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev (Update operation) update the rewards parameters.\n', '\t* @param userAddr The address of operator\n', '\t* @return result the updateRewardParams call in ManagerInterest contract\n', '\t*/\n', '\tfunction updateRewardParams(address payable userAddr) onlyOperators external returns (bool result) {\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIHandlerManager\n', '\t\t\t\t.updateRewardParams.selector,\n', '        userAddr\n', '\t\t\t);\n', '\n', '\t\t(result, ) = handlerManagerAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Claim all rewards for the user\n', '\t* @param userAddr The user address\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction rewardClaimAll(address payable userAddr) external returns (uint256)\n', '\t{\n', '    bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIHandlerManager\n', '\t\t\t\t.rewardClaimAll.selector,\n', '        userAddr\n', '\t\t\t);\n', '\n', '\t\t(bool result, bytes memory returnData) = handlerManagerAddr.delegatecall(callData);\n', '    assert(result);\n', '\n', '    return abi.decode(returnData, (uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Claim handler rewards for the user\n', '\t* @param handlerID The ID of claim reward handler\n', '\t* @param userAddr The user address\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction claimHandlerReward(uint256 handlerID, address payable userAddr) external returns (uint256) {\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIHandlerManager\n', '\t\t\t\t.claimHandlerReward.selector,\n', '        handlerID, userAddr\n', '\t\t\t);\n', '\n', '\t\t(bool result, bytes memory returnData) = handlerManagerAddr.delegatecall(callData);\n', '    assert(result);\n', '\n', '    return abi.decode(returnData, (uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Transfer reward tokens to owner (for administration)\n', '\t* @param _amount The amount of the reward token\n', '\t* @return result (TODO: validate results)\n', '\t*/\n', '\tfunction ownerRewardTransfer(uint256 _amount) onlyOwner external returns (bool result)\n', '\t{\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIHandlerManager\n', '\t\t\t\t.ownerRewardTransfer.selector,\n', '        _amount\n', '\t\t\t);\n', '\n', '\t\t(result, ) = handlerManagerAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\n', '\t/**\n', '\t* @dev Get the token price of the handler\n', '\t* @param handlerID The handler ID\n', '\t* @return The token price of the handler\n', '\t*/\n', '\tfunction getTokenHandlerPrice(uint256 handlerID) external view returns (uint256)\n', '\t{\n', '\t\treturn _getTokenHandlerPrice(handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the margin call limit of the handler (external)\n', '\t* @param handlerID The handler ID\n', '\t* @return The margin call limit\n', '\t*/\n', '\tfunction getTokenHandlerMarginCallLimit(uint256 handlerID) external view returns (uint256)\n', '\t{\n', '\t\treturn _getTokenHandlerMarginCallLimit(handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the margin call limit of the handler (internal)\n', '\t* @param handlerID The handler ID\n', '\t* @return The margin call limit\n', '\t*/\n', '\tfunction _getTokenHandlerMarginCallLimit(uint256 handlerID) internal view returns (uint256)\n', '\t{\n', '\t\tIProxy TokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\tbytes memory data;\n', '\t\t(, data) = TokenHandler.handlerViewProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIMarketHandler\n', '\t\t\t\t.getTokenHandlerMarginCallLimit.selector\n', '\t\t\t)\n', '\t\t);\n', '\t\treturn abi.decode(data, (uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the borrow limit of the handler (external)\n', '\t* @param handlerID The handler ID\n', '\t* @return The borrow limit\n', '\t*/\n', '\tfunction getTokenHandlerBorrowLimit(uint256 handlerID) external view returns (uint256)\n', '\t{\n', '\t\treturn _getTokenHandlerBorrowLimit(handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the borrow limit of the handler (internal)\n', '\t* @param handlerID The handler ID\n', '\t* @return The borrow limit\n', '\t*/\n', '\tfunction _getTokenHandlerBorrowLimit(uint256 handlerID) internal view returns (uint256)\n', '\t{\n', '\t\tIProxy TokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\n', '\t\tbytes memory data;\n', '\t\t(, data) = TokenHandler.handlerViewProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIMarketHandler\n', '\t\t\t\t.getTokenHandlerBorrowLimit.selector\n', '\t\t\t)\n', '\t\t);\n', '\t\treturn abi.decode(data, (uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the handler status of whether the handler is supported or not.\n', '\t* @param handlerID The handler ID\n', '\t* @return Whether the handler is supported or not\n', '\t*/\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool)\n', '\t{\n', '\t\treturn dataStorageInstance.getTokenHandlerSupport(handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the length of the handler list\n', '\t* @param _tokenHandlerLength The length of the handler list\n', '\t* @return true (TODO: validate results)\n', '\t*/\n', '\tfunction setTokenHandlersLength(uint256 _tokenHandlerLength) onlyOwner external returns (bool)\n', '\t{\n', '\t\ttokenHandlerLength = _tokenHandlerLength;\n', '\t\treturn true;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the length of the handler list\n', '\t* @return the length of the handler list\n', '\t*/\n', '\tfunction getTokenHandlersLength() external view returns (uint256)\n', '\t{\n', '\t\treturn tokenHandlerLength;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the handler ID at the index in the handler list\n', '\t* @param index The index of the handler list (array)\n', '\t* @return The handler ID\n', '\t*/\n', '\tfunction getTokenHandlerID(uint256 index) external view returns (uint256)\n', '\t{\n', '\t\treturn dataStorageInstance.getTokenHandlerID(index);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the amount of token that the user can borrow more\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The amount of token that user can borrow more\n', '\t*/\n', '\tfunction getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) external view returns (uint256)\n', '\t{\n', '\t\treturn _getUserExtraLiquidityAmount(userAddr, handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the deposit and borrow amount of the user with interest added\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The deposit and borrow amount of the user with interest\n', '\t*/\n', '\t/* about user market Information function*/\n', '\tfunction getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) external view returns (uint256, uint256)\n', '\t{\n', '\t\treturn _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the depositTotalCredit and borrowTotalCredit\n', '\t* @param userAddr The address of the user\n', '\t* @return depositTotalCredit The amount that users can borrow (i.e. deposit * borrowLimit)\n', '\t* @return borrowTotalCredit The sum of borrow amount for all handlers\n', '\t*/\n', '\tfunction getUserTotalIntraCreditAsset(address payable userAddr) external view returns (uint256, uint256)\n', '\t{\n', '\t\treturn _getUserTotalIntraCreditAsset(userAddr);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the borrow and margin call limits of the user for all handlers\n', '\t* @param userAddr The address of the user\n', '\t* @return userTotalBorrowLimitAsset the sum of borrow limit for all handlers\n', '\t* @return userTotalMarginCallLimitAsset the sume of margin call limit for handlers\n', '\t*/\n', '\tfunction getUserLimitIntraAsset(address payable userAddr) external view returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 userTotalBorrowLimitAsset;\n', '\t\tuint256 userTotalMarginCallLimitAsset;\n', '\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\n', '\t\t\t{\n', '\t\t\t\tuint256 depositHandlerAsset;\n', '\t\t\t\tuint256 borrowHandlerAsset;\n', '\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\n', '\t\t\t\tuint256 borrowLimit = _getTokenHandlerBorrowLimit(handlerID);\n', '\t\t\t\tuint256 marginCallLimit = _getTokenHandlerMarginCallLimit(handlerID);\n', '\t\t\t\tuint256 userBorrowLimitAsset = depositHandlerAsset.unifiedMul(borrowLimit);\n', '\t\t\t\tuint256 userMarginCallLimitAsset = depositHandlerAsset.unifiedMul(marginCallLimit);\n', '\t\t\t\tuserTotalBorrowLimitAsset = userTotalBorrowLimitAsset.add(userBorrowLimitAsset);\n', '\t\t\t\tuserTotalMarginCallLimitAsset = userTotalMarginCallLimitAsset.add(userMarginCallLimitAsset);\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\n', '\t\t}\n', '\n', '\t\treturn (userTotalBorrowLimitAsset, userTotalMarginCallLimitAsset);\n', '\t}\n', '\n', '\n', '\t/**\n', '\t* @dev Get the maximum allowed amount to borrow of the user from the given handler\n', '\t* @param userAddr The address of the user\n', '\t* @param callerID The target handler to borrow\n', '\t* @return extraCollateralAmount The maximum allowed amount to borrow from\n', '\t  the handler.\n', '\t*/\n', '\tfunction getUserCollateralizableAmount(address payable userAddr, uint256 callerID) external view returns (uint256)\n', '\t{\n', '\t\tuint256 userTotalBorrowAsset;\n', '\t\tuint256 depositAssetBorrowLimitSum;\n', '\t\tuint256 depositHandlerAsset;\n', '\t\tuint256 borrowHandlerAsset;\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\n', '\t\t\t{\n', '\n', '\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\n', '\t\t\t\tuserTotalBorrowAsset = userTotalBorrowAsset.add(borrowHandlerAsset);\n', '\t\t\t\tdepositAssetBorrowLimitSum = depositAssetBorrowLimitSum\n', '\t\t\t\t\t\t\t\t\t\t\t\t.add(\n', '\t\t\t\t\t\t\t\t\t\t\t\t\tdepositHandlerAsset\n', '\t\t\t\t\t\t\t\t\t\t\t\t\t.unifiedMul( _getTokenHandlerBorrowLimit(handlerID) )\n', '\t\t\t\t\t\t\t\t\t\t\t\t);\n', '\t\t\t}\n', '\t\t}\n', '\n', '\t\tif (depositAssetBorrowLimitSum > userTotalBorrowAsset)\n', '\t\t{\n', '\t\t\treturn depositAssetBorrowLimitSum\n', '\t\t\t\t\t.sub(userTotalBorrowAsset)\n', '\t\t\t\t\t.unifiedDiv( _getTokenHandlerBorrowLimit(callerID) )\n', '\t\t\t\t\t.unifiedDiv( _getTokenHandlerPrice(callerID) );\n', '\t\t}\n', '\t\treturn 0;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Partial liquidation for a user\n', '\t* @param delinquentBorrower The address of the liquidation target\n', '\t* @param liquidateAmount The amount to liquidate\n', '\t* @param liquidator The address of the liquidator (liquidation operator)\n', '\t* @param liquidateHandlerID The hander ID of the liquidating asset\n', '\t* @param rewardHandlerID The handler ID of the reward token for the liquidator\n', '\t* @return (uint256, uint256, uint256)\n', '\t*/\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 liquidateHandlerID, uint256 rewardHandlerID) onlyLiquidationManager external returns (uint256, uint256, uint256)\n', '\t{\n', '\t\taddress tokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(liquidateHandlerID);\n', '\t\tIProxy TokenHandler = IProxy(tokenHandlerAddr);\n', '\t\tbytes memory data;\n', '\n', '\t\tdata = abi.encodeWithSelector(\n', '\t\t\tIMarketHandler\n', '\t\t\t.partialLiquidationUser.selector,\n', '\n', '\t\t\tdelinquentBorrower,\n', '\t\t\tliquidateAmount,\n', '\t\t\tliquidator,\n', '\t\t\trewardHandlerID\n', '\t\t);\n', '\t\t(, data) = TokenHandler.handlerProxy(data);\n', '\n', '\t\treturn abi.decode(data, (uint256, uint256, uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the maximum liquidation reward by checking sufficient reward\n', '\t  amount for the liquidator.\n', '\t* @param delinquentBorrower The address of the liquidation target\n', '\t* @param liquidateHandlerID The hander ID of the liquidating asset\n', '\t* @param liquidateAmount The amount to liquidate\n', '\t* @param rewardHandlerID The handler ID of the reward token for the liquidator\n', '\t* @param rewardRatio delinquentBorrowAsset / delinquentDepositAsset\n', '\t* @return The maximum reward token amount for the liquidator\n', '\t*/\n', '\tfunction getMaxLiquidationReward(address payable delinquentBorrower, uint256 liquidateHandlerID, uint256 liquidateAmount, uint256 rewardHandlerID, uint256 rewardRatio) external view returns (uint256)\n', '\t{\n', '\t\tuint256 liquidatePrice = _getTokenHandlerPrice(liquidateHandlerID);\n', '\t\tuint256 rewardPrice = _getTokenHandlerPrice(rewardHandlerID);\n', '\t\tuint256 delinquentBorrowerRewardDeposit;\n', '\t\t(delinquentBorrowerRewardDeposit, ) = _getHandlerAmount(delinquentBorrower, rewardHandlerID);\n', '\t\tuint256 rewardAsset = delinquentBorrowerRewardDeposit.unifiedMul(rewardPrice).unifiedMul(rewardRatio);\n', '\t\tif (liquidateAmount.unifiedMul(liquidatePrice) > rewardAsset)\n', '\t\t{\n', '\t\t\treturn rewardAsset.unifiedDiv(liquidatePrice);\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn liquidateAmount;\n', '\t\t}\n', '\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Reward the liquidator\n', '\t* @param delinquentBorrower The address of the liquidation target\n', '\t* @param rewardAmount The amount of reward token\n', '\t* @param liquidator The address of the liquidator (liquidation operator)\n', '\t* @param handlerID The handler ID of the reward token for the liquidator\n', '\t* @return The amount of reward token\n', '\t*/\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 rewardAmount, address payable liquidator, uint256 handlerID) onlyLiquidationManager external returns (uint256)\n', '\t{\n', '\t\taddress tokenHandlerAddr = dataStorageInstance.getTokenHandlerAddr(handlerID);\n', '\t\tIProxy TokenHandler = IProxy(tokenHandlerAddr);\n', '\t\tbytes memory data;\n', '\t\tdata = abi.encodeWithSelector(\n', '\t\t\tIMarketHandler\n', '\t\t\t.partialLiquidationUserReward.selector,\n', '\n', '\t\t\tdelinquentBorrower,\n', '\t\t\trewardAmount,\n', '\t\t\tliquidator\n', '\t\t);\n', '\t\t(, data) = TokenHandler.handlerProxy(data);\n', '\n', '\t\treturn abi.decode(data, (uint256));\n', '\t}\n', '\n', '\t/**\n', '    * @dev Execute flashloan contract with delegatecall\n', '    * @param handlerID The ID of the token handler to borrow.\n', '    * @param receiverAddress The address of receive callback contract\n', '    * @param amount The amount of borrow through flashloan\n', '    * @param params The encode metadata of user\n', '    * @return Whether or not succeed\n', '    */\n', ' \tfunction flashloan(\n', '      uint256 handlerID,\n', '      address receiverAddress,\n', '      uint256 amount,\n', '      bytes calldata params\n', '    ) external returns (bool) {\n', '      bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerFlashloan\n', '\t\t\t\t.flashloan.selector,\n', '\t\t\t\thandlerID, receiverAddress, amount, params\n', '\t\t\t);\n', '\n', '      (bool result, bytes memory returnData) = flashloanAddr.delegatecall(callData);\n', '      assert(result);\n', '\n', '      return abi.decode(returnData, (bool));\n', '    }\n', '\n', '\t/**\n', '\t* @dev Call flashloan logic contract with delegatecall\n', '    * @param handlerID The ID of handler with accumulated flashloan fee\n', '    * @return The amount of fee accumlated to handler\n', '    */\n', ' \tfunction getFeeTotal(uint256 handlerID) external returns (uint256)\n', '\t{\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerFlashloan\n', '\t\t\t\t.getFeeTotal.selector,\n', '\t\t\t\thandlerID\n', '\t\t\t);\n', '\n', '\t\t(bool result, bytes memory returnData) = flashloanAddr.delegatecall(callData);\n', '\t\tassert(result);\n', '\n', '\t\treturn abi.decode(returnData, (uint256));\n', '    }\n', '\n', '\t/**\n', '    * @dev Withdraw accumulated flashloan fee with delegatecall\n', '    * @param handlerID The ID of handler with accumulated flashloan fee\n', '    * @return Whether or not succeed\n', '    */\n', '\tfunction withdrawFlashloanFee(\n', '      uint256 handlerID\n', '    ) external onlyOwner returns (bool) {\n', '    \tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerFlashloan\n', '\t\t\t\t.withdrawFlashloanFee.selector,\n', '\t\t\t\thandlerID\n', '\t\t\t);\n', '\n', '\t\t(bool result, bytes memory returnData) = flashloanAddr.delegatecall(callData);\n', '\t\tassert(result);\n', '\n', '\t\treturn abi.decode(returnData, (bool));\n', '    }\n', '\n', '  /**\n', '    * @dev Get flashloan fee for flashloan amount before make product(BiFi-X)\n', '    * @param handlerID The ID of handler with accumulated flashloan fee\n', '    * @param amount The amount of flashloan amount\n', '    * @param bifiAmount The amount of Bifi amount\n', '    * @return The amount of fee for flashloan amount\n', '    */\n', '  function getFeeFromArguments(\n', '      uint256 handlerID,\n', '      uint256 amount,\n', '      uint256 bifiAmount\n', '    ) external returns (uint256) {\n', '      bytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerFlashloan\n', '\t\t\t\t.getFeeFromArguments.selector,\n', '\t\t\t\thandlerID, amount, bifiAmount\n', '\t\t\t);\n', '\n', '      (bool result, bytes memory returnData) = flashloanAddr.delegatecall(callData);\n', '      assert(result);\n', '\n', '      return abi.decode(returnData, (uint256));\n', '    }\n', '\n', '\t/**\n', '\t* @dev Get the deposit and borrow amount of the user for the handler (internal)\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The deposit and borrow amount\n', '\t*/\n', '\tfunction _getHandlerAmount(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tIProxy TokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\tbytes memory data;\n', '\t\t(, data) = TokenHandler.handlerViewProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIMarketHandler\n', '\t\t\t\t.getUserAmount.selector,\n', '\t\t\t\tuserAddr\n', '\t\t\t)\n', '\t\t);\n', '\t\treturn abi.decode(data, (uint256, uint256));\n', '\t}\n', '\n', '  \t/**\n', '\t* @dev Get the deposit and borrow amount with interest of the user for the handler (internal)\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The deposit and borrow amount with interest\n', '\t*/\n', '\tfunction _getHandlerAmountWithAmount(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tIProxy TokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\tbytes memory data;\n', '\t\t(, data) = TokenHandler.handlerViewProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIMarketHandler\n', '\t\t\t\t.getUserAmountWithInterest.selector,\n', '\t\t\t\tuserAddr\n', '\t\t\t)\n', '\t\t);\n', '\t\treturn abi.decode(data, (uint256, uint256));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Set the support stauts for the handler\n', '\t* @param handlerID the handler ID\n', '\t* @param support the support status (boolean)\n', '\t* @return result the setter call in contextSetter contract\n', '\t*/\n', '\tfunction setHandlerSupport(uint256 handlerID, bool support) onlyOwner public returns (bool result) {\n', '\t\tbytes memory callData = abi.encodeWithSelector(\n', '\t\t\t\tIManagerSlotSetter\n', '\t\t\t\t.setHandlerSupport.selector,\n', '\t\t\t\thandlerID, support\n', '\t\t\t);\n', '\n', '\t\t(result, ) = slotSetterAddr.delegatecall(callData);\n', '    assert(result);\n', '\t}\n', '\n', '\t/**\n', "\t* @dev Get owner's address of the manager contract\n", '\t* @return The address of owner\n', '\t*/\n', '\tfunction getOwner() public view returns (address)\n', '\t{\n', '\t\treturn owner;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the deposit and borrow amount of the user with interest added\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The deposit and borrow amount of the user with interest\n', '\t*/\n', '\tfunction _getUserIntraHandlerAssetWithInterest(address payable userAddr, uint256 handlerID) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 price = _getTokenHandlerPrice(handlerID);\n', '\t\tIProxy TokenHandler = IProxy(dataStorageInstance.getTokenHandlerAddr(handlerID));\n', '\t\tuint256 depositAmount;\n', '\t\tuint256 borrowAmount;\n', '\n', '\t\tbytes memory data;\n', '\t\t(, data) = TokenHandler.handlerViewProxy(\n', '\t\t\tabi.encodeWithSelector(\n', '\t\t\t\tIMarketHandler.getUserAmountWithInterest.selector,\n', '\t\t\t\tuserAddr\n', '\t\t\t)\n', '\t\t);\n', '\t\t(depositAmount, borrowAmount) = abi.decode(data, (uint256, uint256));\n', '\n', '\t\tuint256 depositAsset = depositAmount.unifiedMul(price);\n', '\t\tuint256 borrowAsset = borrowAmount.unifiedMul(price);\n', '\t\treturn (depositAsset, borrowAsset);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the depositTotalCredit and borrowTotalCredit\n', '\t* @param userAddr The address of the user\n', '\t* @return depositTotalCredit The amount that users can borrow (i.e. deposit * borrowLimit)\n', '\t* @return borrowTotalCredit The sum of borrow amount for all handlers\n', '\t*/\n', '\tfunction _getUserTotalIntraCreditAsset(address payable userAddr) internal view returns (uint256, uint256)\n', '\t{\n', '\t\tuint256 depositTotalCredit;\n', '\t\tuint256 borrowTotalCredit;\n', '\t\tfor (uint256 handlerID; handlerID < tokenHandlerLength; handlerID++)\n', '\t\t{\n', '\t\t\tif (dataStorageInstance.getTokenHandlerSupport(handlerID))\n', '\t\t\t{\n', '\t\t\t\tuint256 depositHandlerAsset;\n', '\t\t\t\tuint256 borrowHandlerAsset;\n', '\t\t\t\t(depositHandlerAsset, borrowHandlerAsset) = _getUserIntraHandlerAssetWithInterest(userAddr, handlerID);\n', '\t\t\t\tuint256 borrowLimit = _getTokenHandlerBorrowLimit(handlerID);\n', '\t\t\t\tuint256 depositHandlerCredit = depositHandlerAsset.unifiedMul(borrowLimit);\n', '\t\t\t\tdepositTotalCredit = depositTotalCredit.add(depositHandlerCredit);\n', '\t\t\t\tborrowTotalCredit = borrowTotalCredit.add(borrowHandlerAsset);\n', '\t\t\t}\n', '\t\t\telse\n', '\t\t\t{\n', '\t\t\t\tcontinue;\n', '\t\t\t}\n', '\n', '\t\t}\n', '\n', '\t\treturn (depositTotalCredit, borrowTotalCredit);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the amount of token that the user can borrow more\n', '\t* @param userAddr The address of user\n', '\t* @param handlerID The handler ID\n', '\t* @return The amount of token that user can borrow more\n', '\t*/\n', '  \tfunction _getUserExtraLiquidityAmount(address payable userAddr, uint256 handlerID) internal view returns (uint256) {\n', '\t\tuint256 depositCredit;\n', '\t\tuint256 borrowCredit;\n', '\t\t(depositCredit, borrowCredit) = _getUserTotalIntraCreditAsset(userAddr);\n', '\t\tif (depositCredit == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tif (depositCredit > borrowCredit)\n', '\t\t{\n', '\t\t\treturn depositCredit.sub(borrowCredit).unifiedDiv(_getTokenHandlerPrice(handlerID));\n', '\t\t}\n', '\t\telse\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction getFeePercent(uint256 handlerID) external view returns (uint256)\n', '\t{\n', '\treturn handlerFlashloan[handlerID].flashFeeRate;\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the token price for the handler\n', '\t* @param handlerID The handler id\n', '\t* @return The token price of the handler\n', '\t*/\n', '\tfunction _getTokenHandlerPrice(uint256 handlerID) internal view returns (uint256)\n', '\t{\n', '\t\treturn (oracleProxy.getTokenPrice(handlerID));\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the address of reward token\n', '\t* @return The address of reward token\n', '\t*/\n', '\tfunction getRewardErc20() public view returns (address)\n', '\t{\n', '\t\treturn address(rewardErc20Instance);\n', '\t}\n', '\n', '\t/**\n', '\t* @dev Get the reward parameters\n', '\t* @return (uint256,uint256,uint256) rewardPerBlock, rewardDecrement, rewardTotalAmount\n', '\t*/\n', '\tfunction getGlobalRewardInfo() external view returns (uint256, uint256, uint256)\n', '\t{\n', '\t\tIManagerDataStorage _dataStorage = dataStorageInstance;\n', '\t\treturn (_dataStorage.getGlobalRewardPerBlock(), _dataStorage.getGlobalRewardDecrement(), _dataStorage.getGlobalRewardTotalAmount());\n', '\t}\n', '\n', '\tfunction setObserverAddr(address observerAddr) onlyOwner external returns (bool) {\n', '\t\tObserver = IObserver( observerAddr );\n', '\t}\n', '\n', '\t/**\n', '\t* @dev fallback function where handler can receive native coin\n', '\t*/\n', '\tfallback () external payable\n', '\t{\n', '\n', '\t}\n', '}']