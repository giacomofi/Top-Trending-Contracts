['pragma solidity ^0.7.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// "SPDX-License-Identifier: Apache License 2.0"\n', '// [[0xdE288bC0fCFe25D30Bad8401E70c3183A63F1893, 1619707311, 10000000000000000000]]\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Ownable.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./iIncentives.sol";\n', '\n', 'contract PrivateSale is Ownable,ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '    struct LockIInfo{\n', '        uint256 lockPeriod;\n', '        uint256 amount;\n', '    }\n', '    struct LockIInfoExt{\n', '        address user;\n', '        uint256 lockPeriod;\n', '        uint256 amount;\n', '    }\n', '\n', '    IERC20  public saleToken;\n', '    IIncentives public incentivesContract;\n', '    mapping(address => LockIInfo) internal _whitelist;\n', '\n', '    address lockContractAddress;\n', '    address incentivesTokenAddress;\n', '\n', '    event Distribute(uint256 amount, uint256 unlockTime, address buyer);\n', '\n', '    constructor(address _lockContract,\n', '        address _incentivesContract,\n', '        address _incentivesTokenAddress,\n', '        address _saleToken)\n', '    {\n', '        saleToken = IERC20(_saleToken);\n', '        lockContractAddress = _lockContract;\n', '        incentivesContract = IIncentives(_incentivesContract);\n', '        incentivesTokenAddress = _incentivesTokenAddress;\n', '    }\n', '\n', '    function addToWhiteList(LockIInfoExt[] calldata _newBuyers) external onlyOwner {\n', '        for (uint256 i = 0; i < _newBuyers.length; i++) {\n', '            _whitelist[_newBuyers[i].user]=LockIInfo(_newBuyers[i].lockPeriod,_newBuyers[i].amount);\n', '        }     \n', '    }\n', '    \n', '    function addToWhiteList1(        \n', '        address user,\n', '        uint256 lockPeriod,\n', '        uint256 amount) external onlyOwner {\n', '        _whitelist[user]=LockIInfo(lockPeriod, amount);\n', '    }\n', '\n', '    function saleInfo(address user)public view returns(LockIInfo memory){\n', '        return _whitelist[user];\n', '    }\n', '\n', '    function available() public view returns(uint256){\n', '        return saleToken.balanceOf(address(this));\n', '    }\n', '\n', '    function withdrawSaleToken(uint256 amount) external onlyOwner {\n', '        require(amount>0 && amount<=available(),"amount is incorrect!");\n', '        saleToken.safeTransfer(address(msg.sender), amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Buy sell token.\n', '     */\n', '    function distribute() external nonReentrant{\n', '\n', '        require(_whitelist[msg.sender].amount > 0,"Is not available for this account");\n', '\n', '        uint256 balance = saleToken.balanceOf(address(this));\n', '        uint256 distributeTokenAmount = _whitelist[msg.sender].amount;\n', '         _whitelist[msg.sender].amount=0;\n', '\n', '        require(balance >= distributeTokenAmount, "Not enough tokens in the contract");\n', '\n', '        saleToken.safeTransfer(address(incentivesContract), distributeTokenAmount);\n', '        uint256 unlock_time = _whitelist[msg.sender].lockPeriod;\n', '        incentivesContract.lockIncentives(\n', '                lockContractAddress,incentivesTokenAddress,distributeTokenAmount,unlock_time);\n', '\n', '        emit Distribute(distributeTokenAmount, unlock_time, msg.sender);\n', '    }\n', '}']