['// SPDX-License-Identifier: AGPL-3.0-or-later\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', 'import "SafeERC20.sol";\n', 'import "SafeMath.sol";\n', 'import "Math.sol";\n', 'import "Address.sol";\n', 'import "AdditionalMath.sol";\n', 'import "SignatureVerifier.sol";\n', 'import "StakingEscrow.sol";\n', 'import "NuCypherToken.sol";\n', 'import "Upgradeable.sol";\n', '\n', '\n', '/**\n', '* @title PolicyManager\n', '* @notice Contract holds policy data and locks accrued policy fees\n', '* @dev |v6.2.1|\n', '*/\n', 'contract PolicyManager is Upgradeable {\n', '    using SafeERC20 for NuCypherToken;\n', '    using SafeMath for uint256;\n', '    using AdditionalMath for uint256;\n', '    using AdditionalMath for int256;\n', '    using AdditionalMath for uint16;\n', '    using Address for address payable;\n', '\n', '    event PolicyCreated(\n', '        bytes16 indexed policyId,\n', '        address indexed sponsor,\n', '        address indexed owner,\n', '        uint256 feeRate,\n', '        uint64 startTimestamp,\n', '        uint64 endTimestamp,\n', '        uint256 numberOfNodes\n', '    );\n', '    event ArrangementRevoked(\n', '        bytes16 indexed policyId,\n', '        address indexed sender,\n', '        address indexed node,\n', '        uint256 value\n', '    );\n', '    event RefundForArrangement(\n', '        bytes16 indexed policyId,\n', '        address indexed sender,\n', '        address indexed node,\n', '        uint256 value\n', '    );\n', '    event PolicyRevoked(bytes16 indexed policyId, address indexed sender, uint256 value);\n', '    event RefundForPolicy(bytes16 indexed policyId, address indexed sender, uint256 value);\n', '    event MinFeeRateSet(address indexed node, uint256 value);\n', '    // TODO #1501\n', '    // Range range\n', '    event FeeRateRangeSet(address indexed sender, uint256 min, uint256 defaultValue, uint256 max);\n', '    event Withdrawn(address indexed node, address indexed recipient, uint256 value);\n', '\n', '    struct ArrangementInfo {\n', '        address node;\n', '        uint256 indexOfDowntimePeriods;\n', '        uint16 lastRefundedPeriod;\n', '    }\n', '\n', '    struct Policy {\n', '        bool disabled;\n', '        address payable sponsor;\n', '        address owner;\n', '\n', '        uint128 feeRate;\n', '        uint64 startTimestamp;\n', '        uint64 endTimestamp;\n', '\n', '        uint256 reservedSlot1;\n', '        uint256 reservedSlot2;\n', '        uint256 reservedSlot3;\n', '        uint256 reservedSlot4;\n', '        uint256 reservedSlot5;\n', '\n', '        ArrangementInfo[] arrangements;\n', '    }\n', '\n', '    struct NodeInfo {\n', '        uint128 fee;\n', '        uint16 previousFeePeriod;\n', '        uint256 feeRate;\n', '        uint256 minFeeRate;\n', '        mapping (uint16 => int256) stub; // former slot for feeDelta\n', '        mapping (uint16 => int256) feeDelta;\n', '    }\n', '\n', '    // TODO used only for `delegateGetNodeInfo`, probably will be removed after #1512\n', '    struct MemoryNodeInfo {\n', '        uint128 fee;\n', '        uint16 previousFeePeriod;\n', '        uint256 feeRate;\n', '        uint256 minFeeRate;\n', '    }\n', '\n', '    struct Range {\n', '        uint128 min;\n', '        uint128 defaultValue;\n', '        uint128 max;\n', '    }\n', '\n', '    bytes16 internal constant RESERVED_POLICY_ID = bytes16(0);\n', '    address internal constant RESERVED_NODE = address(0);\n', '    uint256 internal constant MAX_BALANCE = uint256(uint128(0) - 1);\n', '    // controlled overflow to get max int256\n', '    int256 public constant DEFAULT_FEE_DELTA = int256((uint256(0) - 1) >> 1);\n', '\n', '    StakingEscrow public immutable escrow;\n', '    uint32 public immutable genesisSecondsPerPeriod;\n', '    uint32 public immutable secondsPerPeriod;\n', '\n', '    mapping (bytes16 => Policy) public policies;\n', '    mapping (address => NodeInfo) public nodes;\n', '    Range public feeRateRange;\n', '    uint64 public resetTimestamp;\n', '\n', '    /**\n', '    * @notice Constructor sets address of the escrow contract\n', '    * @dev Put same address in both inputs variables except when migration is happening\n', '    * @param _escrowDispatcher Address of escrow dispatcher\n', '    * @param _escrowImplementation Address of escrow implementation\n', '    */\n', '    constructor(StakingEscrow _escrowDispatcher, StakingEscrow _escrowImplementation) {\n', '        escrow = _escrowDispatcher;\n', '        // if the input address is not the StakingEscrow then calling `secondsPerPeriod` will throw error\n', '        uint32 localSecondsPerPeriod = _escrowImplementation.secondsPerPeriod();\n', '        require(localSecondsPerPeriod > 0);\n', '        secondsPerPeriod = localSecondsPerPeriod;\n', '        uint32 localgenesisSecondsPerPeriod = _escrowImplementation.genesisSecondsPerPeriod();\n', '        require(localgenesisSecondsPerPeriod > 0);\n', '        genesisSecondsPerPeriod = localgenesisSecondsPerPeriod;\n', '        // handle case when we deployed new StakingEscrow but not yet upgraded\n', '        if (_escrowDispatcher != _escrowImplementation) {\n', '            require(_escrowDispatcher.secondsPerPeriod() == localSecondsPerPeriod ||\n', '                _escrowDispatcher.secondsPerPeriod() == localgenesisSecondsPerPeriod);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Checks that sender is the StakingEscrow contract\n', '    */\n', '    modifier onlyEscrowContract()\n', '    {\n', '        require(msg.sender == address(escrow));\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @return Number of current period\n', '    */\n', '    function getCurrentPeriod() public view returns (uint16) {\n', '        return uint16(block.timestamp / secondsPerPeriod);\n', '    }\n', '\n', '    /**\n', '    * @return Recalculate period value using new basis\n', '    */\n', '    function recalculatePeriod(uint16 _period) internal view returns (uint16) {\n', '        return uint16(uint256(_period) * genesisSecondsPerPeriod / secondsPerPeriod);\n', '    }\n', '\n', '    /**\n', '    * @notice Register a node\n', '    * @param _node Node address\n', '    * @param _period Initial period\n', '    */\n', '    function register(address _node, uint16 _period) external onlyEscrowContract {\n', '        NodeInfo storage nodeInfo = nodes[_node];\n', '        require(nodeInfo.previousFeePeriod == 0 && _period < getCurrentPeriod());\n', '        nodeInfo.previousFeePeriod = _period;\n', '    }\n', '\n', '    /**\n', '    * @notice Migrate from the old period length to the new one\n', '    * @param _node Node address\n', '    */\n', '    function migrate(address _node) external onlyEscrowContract {\n', '        NodeInfo storage nodeInfo = nodes[_node];\n', '        // with previous period length any previousFeePeriod will be greater than current period\n', '        // this is a sign of not migrated node\n', '        require(nodeInfo.previousFeePeriod >= getCurrentPeriod());\n', '        nodeInfo.previousFeePeriod = recalculatePeriod(nodeInfo.previousFeePeriod);\n', '        nodeInfo.feeRate = 0;\n', '    }\n', '\n', '    /**\n', "    * @notice Set minimum, default & maximum fee rate for all stakers and all policies ('global fee range')\n", '    */\n', '    // TODO # 1501\n', '    // function setFeeRateRange(Range calldata _range) external onlyOwner {\n', '    function setFeeRateRange(uint128 _min, uint128 _default, uint128 _max) external onlyOwner {\n', '        require(_min <= _default && _default <= _max);\n', '        feeRateRange = Range(_min, _default, _max);\n', '        emit FeeRateRangeSet(msg.sender, _min, _default, _max);\n', '    }\n', '\n', '    /**\n', '    * @notice Set the minimum acceptable fee rate (set by staker for their associated worker)\n', '    * @dev Input value must fall within `feeRateRange` (global fee range)\n', '    */\n', '    function setMinFeeRate(uint256 _minFeeRate) external {\n', '        require(_minFeeRate >= feeRateRange.min &&\n', '            _minFeeRate <= feeRateRange.max,\n', '            "The staker\'s min fee rate must fall within the global fee range");\n', '        NodeInfo storage nodeInfo = nodes[msg.sender];\n', '        if (nodeInfo.minFeeRate == _minFeeRate) {\n', '            return;\n', '        }\n', '        nodeInfo.minFeeRate = _minFeeRate;\n', '        emit MinFeeRateSet(msg.sender, _minFeeRate);\n', '    }\n', '\n', '    /**\n', '    * @notice Get the minimum acceptable fee rate (set by staker for their associated worker)\n', '    */\n', '    function getMinFeeRate(NodeInfo storage _nodeInfo) internal view returns (uint256) {\n', '        // if minFeeRate has not been set or chosen value falls outside the global fee range\n', '        // a default value is returned instead\n', '        if (_nodeInfo.minFeeRate == 0 ||\n', '            _nodeInfo.minFeeRate < feeRateRange.min ||\n', '            _nodeInfo.minFeeRate > feeRateRange.max) {\n', '            return feeRateRange.defaultValue;\n', '        } else {\n', '            return _nodeInfo.minFeeRate;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Get the minimum acceptable fee rate (set by staker for their associated worker)\n', '    */\n', '    function getMinFeeRate(address _node) public view returns (uint256) {\n', '        NodeInfo storage nodeInfo = nodes[_node];\n', '        return getMinFeeRate(nodeInfo);\n', '    }\n', '\n', '    /**\n', '    * @notice Create policy\n', '    * @dev Generate policy id before creation\n', '    * @param _policyId Policy id\n', '    * @param _policyOwner Policy owner. Zero address means sender is owner\n', '    * @param _endTimestamp End timestamp of the policy in seconds\n', '    * @param _nodes Nodes that will handle policy\n', '    */\n', '    function createPolicy(\n', '        bytes16 _policyId,\n', '        address _policyOwner,\n', '        uint64 _endTimestamp,\n', '        address[] calldata _nodes\n', '    )\n', '        external payable\n', '    {\n', '        Policy storage policy = policies[_policyId];\n', '        require(\n', '            _policyId != RESERVED_POLICY_ID &&\n', '            policy.feeRate == 0 &&\n', '            !policy.disabled &&\n', '            _endTimestamp > block.timestamp &&\n', '            msg.value > 0\n', '        );\n', '        require(address(this).balance <= MAX_BALANCE);\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        uint16 endPeriod = uint16(_endTimestamp / secondsPerPeriod) + 1;\n', '        uint256 numberOfPeriods = endPeriod - currentPeriod;\n', '\n', '        policy.sponsor = msg.sender;\n', '        policy.startTimestamp = uint64(block.timestamp);\n', '        policy.endTimestamp = _endTimestamp;\n', '        policy.feeRate = uint128(msg.value.div(_nodes.length) / numberOfPeriods);\n', '        require(policy.feeRate > 0 && policy.feeRate * numberOfPeriods * _nodes.length  == msg.value);\n', '        if (_policyOwner != msg.sender && _policyOwner != address(0)) {\n', '            policy.owner = _policyOwner;\n', '        }\n', '\n', '        for (uint256 i = 0; i < _nodes.length; i++) {\n', '            address node = _nodes[i];\n', '            require(node != RESERVED_NODE);\n', '            NodeInfo storage nodeInfo = nodes[node];\n', '            require(nodeInfo.previousFeePeriod != 0 &&\n', '                nodeInfo.previousFeePeriod < currentPeriod &&\n', '                policy.feeRate >= getMinFeeRate(nodeInfo));\n', '            // Check default value for feeDelta\n', '            if (nodeInfo.feeDelta[currentPeriod] == DEFAULT_FEE_DELTA) {\n', '                nodeInfo.feeDelta[currentPeriod] = int256(policy.feeRate);\n', '            } else {\n', '                // Overflow protection removed, because ETH total supply less than uint255/int256\n', '                nodeInfo.feeDelta[currentPeriod] += int256(policy.feeRate);\n', '            }\n', '            if (nodeInfo.feeDelta[endPeriod] == DEFAULT_FEE_DELTA) {\n', '                nodeInfo.feeDelta[endPeriod] = -int256(policy.feeRate);\n', '            } else {\n', '                nodeInfo.feeDelta[endPeriod] -= int256(policy.feeRate);\n', '            }\n', '            // Reset to default value if needed\n', '            if (nodeInfo.feeDelta[currentPeriod] == 0) {\n', '                nodeInfo.feeDelta[currentPeriod] = DEFAULT_FEE_DELTA;\n', '            }\n', '            if (nodeInfo.feeDelta[endPeriod] == 0) {\n', '                nodeInfo.feeDelta[endPeriod] = DEFAULT_FEE_DELTA;\n', '            }\n', '            policy.arrangements.push(ArrangementInfo(node, 0, 0));\n', '        }\n', '\n', '        emit PolicyCreated(\n', '            _policyId,\n', '            msg.sender,\n', '            _policyOwner == address(0) ? msg.sender : _policyOwner,\n', '            policy.feeRate,\n', '            policy.startTimestamp,\n', '            policy.endTimestamp,\n', '            _nodes.length\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @notice Get policy owner\n', '    */\n', '    function getPolicyOwner(bytes16 _policyId) public view returns (address) {\n', '        Policy storage policy = policies[_policyId];\n', '        return policy.owner == address(0) ? policy.sponsor : policy.owner;\n', '    }\n', '\n', '    /**\n', '    * @notice Call from StakingEscrow to update node info once per period.\n', '    * Set default `feeDelta` value for specified period and update node fee\n', '    * @param _node Node address\n', '    * @param _processedPeriod1 Processed period\n', '    * @param _processedPeriod2 Processed period\n', '    * @param _periodToSetDefault Period to set\n', '    */\n', '    function ping(\n', '        address _node,\n', '        uint16 _processedPeriod1,\n', '        uint16 _processedPeriod2,\n', '        uint16 _periodToSetDefault\n', '    )\n', '        external onlyEscrowContract\n', '    {\n', '        NodeInfo storage node = nodes[_node];\n', '        // protection from calling not migrated node, see migrate()\n', '        require(node.previousFeePeriod < getCurrentPeriod());\n', '        if (_processedPeriod1 != 0) {\n', '            updateFee(node, _processedPeriod1);\n', '        }\n', '        if (_processedPeriod2 != 0) {\n', '            updateFee(node, _processedPeriod2);\n', '        }\n', '        // This code increases gas cost for node in trade of decreasing cost for policy sponsor\n', '        if (_periodToSetDefault != 0 && node.feeDelta[_periodToSetDefault] == 0) {\n', '            node.feeDelta[_periodToSetDefault] = DEFAULT_FEE_DELTA;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Update node fee\n', '    * @param _info Node info structure\n', '    * @param _period Processed period\n', '    */\n', '    function updateFee(NodeInfo storage _info, uint16 _period) internal {\n', '        if (_info.previousFeePeriod == 0 || _period <= _info.previousFeePeriod) {\n', '            return;\n', '        }\n', '        for (uint16 i = _info.previousFeePeriod + 1; i <= _period; i++) {\n', '            int256 delta = _info.feeDelta[i];\n', '            if (delta == DEFAULT_FEE_DELTA) {\n', '                // gas refund\n', '                _info.feeDelta[i] = 0;\n', '                continue;\n', '            }\n', '\n', '            _info.feeRate = _info.feeRate.addSigned(delta);\n', '            // gas refund\n', '            _info.feeDelta[i] = 0;\n', '        }\n', '        _info.previousFeePeriod = _period;\n', '        _info.fee += uint128(_info.feeRate);\n', '    }\n', '\n', '    /**\n', '    * @notice Withdraw fee by node\n', '    */\n', '    function withdraw() external returns (uint256) {\n', '        return withdraw(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @notice Withdraw fee by node\n', '    * @param _recipient Recipient of the fee\n', '    */\n', '    function withdraw(address payable _recipient) public returns (uint256) {\n', '        NodeInfo storage node = nodes[msg.sender];\n', '        uint256 fee = node.fee;\n', '        require(fee != 0);\n', '        node.fee = 0;\n', '        _recipient.sendValue(fee);\n', '        emit Withdrawn(msg.sender, _recipient, fee);\n', '        return fee;\n', '    }\n', '\n', '    /**\n', '    * @notice Calculate amount of refund\n', '    * @param _policy Policy\n', '    * @param _arrangement Arrangement\n', '    */\n', '    function calculateRefundValue(Policy storage _policy, ArrangementInfo storage _arrangement)\n', '        internal view returns (uint256 refundValue, uint256 indexOfDowntimePeriods, uint16 lastRefundedPeriod)\n', '    {\n', '        uint16 policyStartPeriod = uint16(_policy.startTimestamp / secondsPerPeriod);\n', '        uint16 maxPeriod = AdditionalMath.min16(getCurrentPeriod(), uint16(_policy.endTimestamp / secondsPerPeriod));\n', '        uint16 minPeriod = AdditionalMath.max16(policyStartPeriod, _arrangement.lastRefundedPeriod);\n', '        uint16 downtimePeriods = 0;\n', '        uint256 length = escrow.getPastDowntimeLength(_arrangement.node);\n', '        uint256 initialIndexOfDowntimePeriods;\n', '        if (_arrangement.lastRefundedPeriod == 0) {\n', '            initialIndexOfDowntimePeriods = escrow.findIndexOfPastDowntime(_arrangement.node, policyStartPeriod);\n', '        } else {\n', '            initialIndexOfDowntimePeriods = _arrangement.indexOfDowntimePeriods;\n', '        }\n', '\n', '        for (indexOfDowntimePeriods = initialIndexOfDowntimePeriods;\n', '             indexOfDowntimePeriods < length;\n', '             indexOfDowntimePeriods++)\n', '        {\n', '            (uint16 startPeriod, uint16 endPeriod) =\n', '                escrow.getPastDowntime(_arrangement.node, indexOfDowntimePeriods);\n', '            if (startPeriod > maxPeriod) {\n', '                break;\n', '            } else if (endPeriod < minPeriod) {\n', '                continue;\n', '            }\n', '            downtimePeriods += AdditionalMath.min16(maxPeriod, endPeriod)\n', '                .sub16(AdditionalMath.max16(minPeriod, startPeriod)) + 1;\n', '            if (maxPeriod <= endPeriod) {\n', '                break;\n', '            }\n', '        }\n', '\n', '        uint16 lastCommittedPeriod = escrow.getLastCommittedPeriod(_arrangement.node);\n', '        if (indexOfDowntimePeriods == length && lastCommittedPeriod < maxPeriod) {\n', '            // Overflow protection removed:\n', '            // lastCommittedPeriod < maxPeriod and minPeriod <= maxPeriod + 1\n', '            downtimePeriods += maxPeriod - AdditionalMath.max16(minPeriod - 1, lastCommittedPeriod);\n', '        }\n', '\n', '        refundValue = _policy.feeRate * downtimePeriods;\n', '        lastRefundedPeriod = maxPeriod + 1;\n', '    }\n', '\n', '    /**\n', '    * @notice Revoke/refund arrangement/policy by the sponsor\n', '    * @param _policyId Policy id\n', '    * @param _node Node that will be excluded or RESERVED_NODE if full policy should be used\n', '    ( @param _forceRevoke Force revoke arrangement/policy\n', '    */\n', '    function refundInternal(bytes16 _policyId, address _node, bool _forceRevoke)\n', '        internal returns (uint256 refundValue)\n', '    {\n', '        refundValue = 0;\n', '        Policy storage policy = policies[_policyId];\n', '        require(!policy.disabled && policy.startTimestamp >= resetTimestamp);\n', '        uint16 endPeriod = uint16(policy.endTimestamp / secondsPerPeriod) + 1;\n', '        uint256 numberOfActive = policy.arrangements.length;\n', '        uint256 i = 0;\n', '        for (; i < policy.arrangements.length; i++) {\n', '            ArrangementInfo storage arrangement = policy.arrangements[i];\n', '            address node = arrangement.node;\n', '            if (node == RESERVED_NODE || _node != RESERVED_NODE && _node != node) {\n', '                numberOfActive--;\n', '                continue;\n', '            }\n', '            uint256 nodeRefundValue;\n', '            (nodeRefundValue, arrangement.indexOfDowntimePeriods, arrangement.lastRefundedPeriod) =\n', '                calculateRefundValue(policy, arrangement);\n', '            if (_forceRevoke) {\n', '                NodeInfo storage nodeInfo = nodes[node];\n', '\n', '                // Check default value for feeDelta\n', '                uint16 lastRefundedPeriod = arrangement.lastRefundedPeriod;\n', '                if (nodeInfo.feeDelta[lastRefundedPeriod] == DEFAULT_FEE_DELTA) {\n', '                    nodeInfo.feeDelta[lastRefundedPeriod] = -int256(policy.feeRate);\n', '                } else {\n', '                    nodeInfo.feeDelta[lastRefundedPeriod] -= int256(policy.feeRate);\n', '                }\n', '                if (nodeInfo.feeDelta[endPeriod] == DEFAULT_FEE_DELTA) {\n', '                    nodeInfo.feeDelta[endPeriod] = int256(policy.feeRate);\n', '                } else {\n', '                    nodeInfo.feeDelta[endPeriod] += int256(policy.feeRate);\n', '                }\n', '\n', '                // Reset to default value if needed\n', '                if (nodeInfo.feeDelta[lastRefundedPeriod] == 0) {\n', '                    nodeInfo.feeDelta[lastRefundedPeriod] = DEFAULT_FEE_DELTA;\n', '                }\n', '                if (nodeInfo.feeDelta[endPeriod] == 0) {\n', '                    nodeInfo.feeDelta[endPeriod] = DEFAULT_FEE_DELTA;\n', '                }\n', '                nodeRefundValue += uint256(endPeriod - lastRefundedPeriod) * policy.feeRate;\n', '            }\n', '            if (_forceRevoke || arrangement.lastRefundedPeriod >= endPeriod) {\n', '                arrangement.node = RESERVED_NODE;\n', '                arrangement.indexOfDowntimePeriods = 0;\n', '                arrangement.lastRefundedPeriod = 0;\n', '                numberOfActive--;\n', '                emit ArrangementRevoked(_policyId, msg.sender, node, nodeRefundValue);\n', '            } else {\n', '                emit RefundForArrangement(_policyId, msg.sender, node, nodeRefundValue);\n', '            }\n', '\n', '            refundValue += nodeRefundValue;\n', '            if (_node != RESERVED_NODE) {\n', '               break;\n', '            }\n', '        }\n', '        address payable policySponsor = policy.sponsor;\n', '        if (_node == RESERVED_NODE) {\n', '            if (numberOfActive == 0) {\n', '                policy.disabled = true;\n', '                // gas refund\n', '                policy.sponsor = address(0);\n', '                policy.owner = address(0);\n', '                policy.feeRate = 0;\n', '                policy.startTimestamp = 0;\n', '                policy.endTimestamp = 0;\n', '                emit PolicyRevoked(_policyId, msg.sender, refundValue);\n', '            } else {\n', '                emit RefundForPolicy(_policyId, msg.sender, refundValue);\n', '            }\n', '        } else {\n', '            // arrangement not found\n', '            require(i < policy.arrangements.length);\n', '        }\n', '        if (refundValue > 0) {\n', '            policySponsor.sendValue(refundValue);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Calculate amount of refund\n', '    * @param _policyId Policy id\n', '    * @param _node Node or RESERVED_NODE if all nodes should be used\n', '    */\n', '    function calculateRefundValueInternal(bytes16 _policyId, address _node)\n', '        internal view returns (uint256 refundValue)\n', '    {\n', '        refundValue = 0;\n', '        Policy storage policy = policies[_policyId];\n', '        require((policy.owner == msg.sender || policy.sponsor == msg.sender) && !policy.disabled);\n', '        uint256 i = 0;\n', '        for (; i < policy.arrangements.length; i++) {\n', '            ArrangementInfo storage arrangement = policy.arrangements[i];\n', '            if (arrangement.node == RESERVED_NODE || _node != RESERVED_NODE && _node != arrangement.node) {\n', '                continue;\n', '            }\n', '            (uint256 nodeRefundValue,,) = calculateRefundValue(policy, arrangement);\n', '            refundValue += nodeRefundValue;\n', '            if (_node != RESERVED_NODE) {\n', '               break;\n', '            }\n', '        }\n', '        if (_node != RESERVED_NODE) {\n', '            // arrangement not found\n', '            require(i < policy.arrangements.length);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Revoke policy by the sponsor\n', '    * @param _policyId Policy id\n', '    */\n', '    function revokePolicy(bytes16 _policyId) external returns (uint256 refundValue) {\n', '        require(getPolicyOwner(_policyId) == msg.sender);\n', '        return refundInternal(_policyId, RESERVED_NODE, true);\n', '    }\n', '\n', '    /**\n', '    * @notice Revoke arrangement by the sponsor\n', '    * @param _policyId Policy id\n', '    * @param _node Node that will be excluded\n', '    */\n', '    function revokeArrangement(bytes16 _policyId, address _node)\n', '        external returns (uint256 refundValue)\n', '    {\n', '        require(_node != RESERVED_NODE);\n', '        require(getPolicyOwner(_policyId) == msg.sender);\n', '        return refundInternal(_policyId, _node, true);\n', '    }\n', '\n', '    /**\n', '    * @notice Get unsigned hash for revocation\n', '    * @param _policyId Policy id\n', '    * @param _node Node that will be excluded\n', "    * @return Revocation hash, EIP191 version 0x45 ('E')\n", '    */\n', '    function getRevocationHash(bytes16 _policyId, address _node) public view returns (bytes32) {\n', '        return SignatureVerifier.hashEIP191(abi.encodePacked(_policyId, _node), byte(0x45));\n', '    }\n', '\n', '    /**\n', '    * @notice Check correctness of signature\n', '    * @param _policyId Policy id\n', '    * @param _node Node that will be excluded, zero address if whole policy will be revoked\n', '    * @param _signature Signature of owner\n', '    */\n', '    function checkOwnerSignature(bytes16 _policyId, address _node, bytes memory _signature) internal view {\n', '        bytes32 hash = getRevocationHash(_policyId, _node);\n', '        address recovered = SignatureVerifier.recover(hash, _signature);\n', '        require(getPolicyOwner(_policyId) == recovered);\n', '    }\n', '\n', '    /**\n', "    * @notice Revoke policy or arrangement using owner's signature\n", '    * @param _policyId Policy id\n', '    * @param _node Node that will be excluded, zero address if whole policy will be revoked\n', "    * @param _signature Signature of owner, EIP191 version 0x45 ('E')\n", '    */\n', '    function revoke(bytes16 _policyId, address _node, bytes calldata _signature)\n', '        external returns (uint256 refundValue)\n', '    {\n', '        checkOwnerSignature(_policyId, _node, _signature);\n', '        return refundInternal(_policyId, _node, true);\n', '    }\n', '\n', '    /**\n', '    * @notice Refund part of fee by the sponsor\n', '    * @param _policyId Policy id\n', '    */\n', '    function refund(bytes16 _policyId) external {\n', '        Policy storage policy = policies[_policyId];\n', '        require(policy.owner == msg.sender || policy.sponsor == msg.sender);\n', '        refundInternal(_policyId, RESERVED_NODE, false);\n', '    }\n', '\n', '    /**\n', "    * @notice Refund part of one node's fee by the sponsor\n", '    * @param _policyId Policy id\n', '    * @param _node Node address\n', '    */\n', '    function refund(bytes16 _policyId, address _node)\n', '        external returns (uint256 refundValue)\n', '    {\n', '        require(_node != RESERVED_NODE);\n', '        Policy storage policy = policies[_policyId];\n', '        require(policy.owner == msg.sender || policy.sponsor == msg.sender);\n', '        return refundInternal(_policyId, _node, false);\n', '    }\n', '\n', '    /**\n', '    * @notice Calculate amount of refund\n', '    * @param _policyId Policy id\n', '    */\n', '    function calculateRefundValue(bytes16 _policyId)\n', '        external view returns (uint256 refundValue)\n', '    {\n', '        return calculateRefundValueInternal(_policyId, RESERVED_NODE);\n', '    }\n', '\n', '    /**\n', '    * @notice Calculate amount of refund\n', '    * @param _policyId Policy id\n', '    * @param _node Node\n', '    */\n', '    function calculateRefundValue(bytes16 _policyId, address _node)\n', '        external view returns (uint256 refundValue)\n', '    {\n', '        require(_node != RESERVED_NODE);\n', '        return calculateRefundValueInternal(_policyId, _node);\n', '    }\n', '\n', '    /**\n', '    * @notice Get number of arrangements in the policy\n', '    * @param _policyId Policy id\n', '    */\n', '    function getArrangementsLength(bytes16 _policyId) external view returns (uint256) {\n', '        return policies[_policyId].arrangements.length;\n', '    }\n', '\n', '    /**\n', "    * @notice Get information about staker's fee rate\n", '    * @param _node Address of staker\n', '    * @param _period Period to get fee delta\n', '    */\n', '    function getNodeFeeDelta(address _node, uint16 _period)\n', '        // TODO "virtual" only for tests, probably will be removed after #1512\n', '        public view virtual returns (int256)\n', '    {\n', '        // TODO remove after upgrade #2579\n', '        if (_node == RESERVED_NODE && _period == 11) {\n', '            return 55;\n', '        }\n', '        return nodes[_node].feeDelta[_period];\n', '    }\n', '\n', '    /**\n', '    * @notice Return the information about arrangement\n', '    */\n', '    function getArrangementInfo(bytes16 _policyId, uint256 _index)\n', '    // TODO change to structure when ABIEncoderV2 is released (#1501)\n', '//        public view returns (ArrangementInfo)\n', '        external view returns (address node, uint256 indexOfDowntimePeriods, uint16 lastRefundedPeriod)\n', '    {\n', '        ArrangementInfo storage info = policies[_policyId].arrangements[_index];\n', '        node = info.node;\n', '        indexOfDowntimePeriods = info.indexOfDowntimePeriods;\n', '        lastRefundedPeriod = info.lastRefundedPeriod;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Get Policy structure by delegatecall\n', '    */\n', '    function delegateGetPolicy(address _target, bytes16 _policyId)\n', '        internal returns (Policy memory result)\n', '    {\n', '        bytes32 memoryAddress = delegateGetData(_target, this.policies.selector, 1, bytes32(_policyId), 0);\n', '        assembly {\n', '            result := memoryAddress\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Get ArrangementInfo structure by delegatecall\n', '    */\n', '    function delegateGetArrangementInfo(address _target, bytes16 _policyId, uint256 _index)\n', '        internal returns (ArrangementInfo memory result)\n', '    {\n', '        bytes32 memoryAddress = delegateGetData(\n', '            _target, this.getArrangementInfo.selector, 2, bytes32(_policyId), bytes32(_index));\n', '        assembly {\n', '            result := memoryAddress\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Get NodeInfo structure by delegatecall\n', '    */\n', '    function delegateGetNodeInfo(address _target, address _node)\n', '        internal returns (MemoryNodeInfo memory result)\n', '    {\n', '        bytes32 memoryAddress = delegateGetData(_target, this.nodes.selector, 1, bytes32(uint256(_node)), 0);\n', '        assembly {\n', '            result := memoryAddress\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Get feeRateRange structure by delegatecall\n', '    */\n', '    function delegateGetFeeRateRange(address _target) internal returns (Range memory result) {\n', '        bytes32 memoryAddress = delegateGetData(_target, this.feeRateRange.selector, 0, 0, 0);\n', '        assembly {\n', '            result := memoryAddress\n', '        }\n', '    }\n', '\n', '    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\n', '    function verifyState(address _testTarget) public override virtual {\n', '        super.verifyState(_testTarget);\n', '        require(uint64(delegateGet(_testTarget, this.resetTimestamp.selector)) == resetTimestamp);\n', '\n', '        Range memory rangeToCheck = delegateGetFeeRateRange(_testTarget);\n', '        require(feeRateRange.min == rangeToCheck.min &&\n', '            feeRateRange.defaultValue == rangeToCheck.defaultValue &&\n', '            feeRateRange.max == rangeToCheck.max);\n', '\n', '        Policy storage policy = policies[RESERVED_POLICY_ID];\n', '        Policy memory policyToCheck = delegateGetPolicy(_testTarget, RESERVED_POLICY_ID);\n', '        require(policyToCheck.sponsor == policy.sponsor &&\n', '            policyToCheck.owner == policy.owner &&\n', '            policyToCheck.feeRate == policy.feeRate &&\n', '            policyToCheck.startTimestamp == policy.startTimestamp &&\n', '            policyToCheck.endTimestamp == policy.endTimestamp &&\n', '            policyToCheck.disabled == policy.disabled);\n', '\n', '        require(delegateGet(_testTarget, this.getArrangementsLength.selector, RESERVED_POLICY_ID) ==\n', '            policy.arrangements.length);\n', '        if (policy.arrangements.length > 0) {\n', '            ArrangementInfo storage arrangement = policy.arrangements[0];\n', '            ArrangementInfo memory arrangementToCheck = delegateGetArrangementInfo(\n', '                _testTarget, RESERVED_POLICY_ID, 0);\n', '            require(arrangementToCheck.node == arrangement.node &&\n', '                arrangementToCheck.indexOfDowntimePeriods == arrangement.indexOfDowntimePeriods &&\n', '                arrangementToCheck.lastRefundedPeriod == arrangement.lastRefundedPeriod);\n', '        }\n', '\n', '        NodeInfo storage nodeInfo = nodes[RESERVED_NODE];\n', '        MemoryNodeInfo memory nodeInfoToCheck = delegateGetNodeInfo(_testTarget, RESERVED_NODE);\n', '        require(nodeInfoToCheck.fee == nodeInfo.fee &&\n', '            nodeInfoToCheck.feeRate == nodeInfo.feeRate &&\n', '            nodeInfoToCheck.previousFeePeriod == nodeInfo.previousFeePeriod &&\n', '            nodeInfoToCheck.minFeeRate == nodeInfo.minFeeRate);\n', '\n', '        require(int256(delegateGet(_testTarget, this.getNodeFeeDelta.selector,\n', '            bytes32(bytes20(RESERVED_NODE)), bytes32(uint256(11)))) == getNodeFeeDelta(RESERVED_NODE, 11));\n', '    }\n', '\n', '    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`\n', '    function finishUpgrade(address _target) public override virtual {\n', '        super.finishUpgrade(_target);\n', '\n', '        if (resetTimestamp == 0) {\n', '            resetTimestamp = uint64(block.timestamp);\n', '        }\n', '\n', '        // Create fake Policy and NodeInfo to use them in verifyState(address)\n', '        Policy storage policy = policies[RESERVED_POLICY_ID];\n', '        policy.sponsor = msg.sender;\n', '        policy.owner = address(this);\n', '        policy.startTimestamp = 1;\n', '        policy.endTimestamp = 2;\n', '        policy.feeRate = 3;\n', '        policy.disabled = true;\n', '        policy.arrangements.push(ArrangementInfo(RESERVED_NODE, 11, 22));\n', '        NodeInfo storage nodeInfo = nodes[RESERVED_NODE];\n', '        nodeInfo.fee = 100;\n', '        nodeInfo.feeRate = 33;\n', '        nodeInfo.previousFeePeriod = 44;\n', '        nodeInfo.feeDelta[11] = 55;\n', '        nodeInfo.minFeeRate = 777;\n', '    }\n', '}']