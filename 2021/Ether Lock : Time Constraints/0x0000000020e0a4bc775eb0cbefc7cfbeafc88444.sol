['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-11\n', '*/\n', '\n', 'pragma solidity >=0.7.0 <0.8.0;\n', '\n', '// In the first version, claimed block nonce / mixDigest IS NOT VERIFIED\n', '// This contract assumes that mev block template producer completely TRUSTS pool operator that received the signed work order.\n', '// This contract !DOES NOT VERIFY! that block nonce / mixDigest is valid or that it was broadcasted without delay\n', "// In the next version we're planning to introduce trustless approach to verify submited block nonce on-chain(see smartpool) and verify delay in seconds for share submission(using oracles)\n", 'contract LogOfClaimedMEVBlocks {\n', '    uint256 internal constant FLAG_BLOCK_NONCE_LIMIT = 0x10000000000000000;\n', '    mapping (address => uint) public timestampOfPossibleExit;\n', '    mapping (address => uint) public depositedEther;\n', '    \n', '    mapping (address => address) public blockSubmissionsOperator;\n', '    mapping (bytes32 => uint) public claimedBlockNonce;\n', '    mapping (bytes32 => bytes32) public claimedBlockMixDigest;\n', '    \n', '    event Deposit(address user, uint amount);\n', '    event Withdraw(address user, uint amount);\n', '    event BlockClaimed(bytes32 blockHeader, bytes32 seedHash, bytes32 target, uint blockNumber, uint blockPayment, address miningPoolAddress, address mevProducerAddress, uint blockNonce, bytes32 mixDigest);\n', '    \n', '\n', '    function setBlockClaimsOperator(address newBlockSubmissionsOperator) public {\n', '        assert(msg.data.length == 36);\n', '        blockSubmissionsOperator[msg.sender] = newBlockSubmissionsOperator;\n', '    }\n', '\n', '    fallback () payable external {\n', '        this.depositAndLock(msg.value, 24 * 60 * 60);\n', '    }\n', '    function depositAndLock(uint depositAmount, uint depositDuration) payable external {\n', '        require(depositAmount == msg.value);\n', '        // Enforcing min and max lockup durations\n', '        require(depositDuration >= 24 * 60 * 60 && depositDuration < 365 * 24 * 60 * 60);\n', '        timestampOfPossibleExit[msg.sender] = block.timestamp + depositDuration;\n', '        if (msg.value > 0) {\n', '            depositedEther[msg.sender] += msg.value;\n', '        }\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '    \n', '    \n', '    function withdrawUpTo(uint etherAmount) external {\n', '        // User previously deposited into contract\n', '        require(depositedEther[msg.sender] > 0);\n', '        // Deposit lockup period is over\n', '        require(block.timestamp > timestampOfPossibleExit[msg.sender]);\n', '        if (depositedEther[msg.sender] < etherAmount)\n', '            etherAmount = depositedEther[msg.sender];\n', '        depositedEther[msg.sender] -= etherAmount;\n', '        msg.sender.transfer(etherAmount);\n', '        emit Withdraw(msg.sender, etherAmount);\n', '    }\n', '\n', '    function submitClaim(\n', '        bytes32 blockHeader,\n', '        bytes32 seedHash,\n', '        bytes32 target,\n', '        uint blockNumber,\n', '        uint blockPayment,\n', '        address payable miningPoolAddress,\n', '        address mevProducerAddress,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s,\n', '        uint blockNonce,\n', '        bytes32 mixDigest\n', '    ) public {\n', '        require(msg.sender == blockSubmissionsOperator[miningPoolAddress] || msg.sender == miningPoolAddress);\n', '        bytes32 hash = keccak256(abi.encodePacked(blockHeader, seedHash, target, blockNumber, blockPayment, miningPoolAddress));\n', '        if (claimedBlockNonce[hash] == 0 && blockNonce < FLAG_BLOCK_NONCE_LIMIT) {\n', '            if (ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) == mevProducerAddress) {\n', '                require(depositedEther[mevProducerAddress] >= blockPayment);\n', '                claimedBlockNonce[hash] = FLAG_BLOCK_NONCE_LIMIT + blockNonce;\n', '                claimedBlockMixDigest[hash] = mixDigest;\n', '                depositedEther[mevProducerAddress] -= blockPayment;\n', '                miningPoolAddress.transfer(blockPayment);\n', '                emit BlockClaimed(blockHeader, seedHash, target, blockNumber, blockPayment, miningPoolAddress, mevProducerAddress, blockNonce, mixDigest);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function remainingDurationForWorkClaim(\n', '        bytes32 blockHeader,\n', '        bytes32 seedHash,\n', '        bytes32 target,\n', '        uint blockNumber,\n', '        uint blockPayment,\n', '        address miningPoolAddress,\n', '        address mevProducerAddress,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public view returns (uint) {\n', '        bytes32 hash = keccak256(abi.encodePacked(blockHeader, seedHash, target, blockNumber, blockPayment, miningPoolAddress));\n', '        if (claimedBlockNonce[hash] != 0) return 0;\n', '        if (ecrecover(keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash)),v,r,s) != mevProducerAddress) return 0;\n', '        if (depositedEther[mevProducerAddress] < blockPayment) return 0;\n', '        if (block.timestamp >= timestampOfPossibleExit[mevProducerAddress]) return 0;\n', '        return timestampOfPossibleExit[mevProducerAddress] - block.timestamp;\n', '    }\n', '}\n', '\n', 'contract GasOptimisedPayoutsToMiners {\n', '    function dispersePaymentForShares(uint256[] memory minerPayoutData) external payable {\n', '        for (uint256 i = 0; i < minerPayoutData.length; i++) {\n', '            uint256 singlePayout = minerPayoutData[i];\n', '            payable(singlePayout).transfer(singlePayout / (16 ** 40));\n', '        }\n', '        uint256 balance = address(this).balance;\n', '        if (balance > 0)\n', '            msg.sender.transfer(balance);\n', '    }\n', '}']