['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '//\n', '//\n', '//                    ┌─┐       ┌─┐ + +\n', '//                    ┌──┘ ┴───────┘ ┴──┐++\n', '//                    │                 │\n', '//                    │       ───       │++ + + +\n', '//                    ███████───███████ │+\n', '//                    │                 │+\n', '//                    │       ─┴─       │\n', '//                    │                 │\n', '//                    └───┐         ┌───┘\n', '//                    │         │\n', '//                    │         │   + +\n', '//                    │         │\n', '//                    │         └──────────────┐\n', '//                    │                        │\n', '//                    │                        ├─┐\n', '//                    │                        ┌─┘\n', '//                    │                        │\n', '//                    └─┐  ┐  ┌───────┬──┐  ┌──┘  + + + +\n', '//                    │ ─┤ ─┤       │ ─┤ ─┤\n', '//                    └──┴──┘       └──┴──┘  + + + +\n', '//                    神兽保佑\n', '//                    代码无BUG!\n', '\n', 'import "./SafeMath.sol";\n', 'import "./IBEP20.sol";\n', 'import "./SafeBEP20.sol";\n', 'import "./Ownable.sol";\n', '\n', 'import "./ZooToken.sol";\n', '\n', '// MasterChef is the master of Lyptus. He can make Lyptus and he is a fair guy.\n', '//\n', "// Note that it's ownable and the owner wields tremendous power. The ownership\n", '// will be transferred to a governance smart contract once LYPTUS is sufficiently\n', '// distributed and the community can show to govern itself.\n', '//\n', "// Have fun reading it. Hopefully it's bug-free. God bless.\n", 'contract Zoo is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeBEP20 for IBEP20;\n', '\n', '    // Info of each user.\n', '    struct UserInfo {\n', '        uint256 stakeAmount;         // How many LP tokens the user has provided.\n', '        uint256 balance;\n', '        uint256 pledgeTime;\n', '        bool isExist;\n', '    }\n', '\n', '    // Info of each pool.\n', '    struct PoolInfo {\n', '        IBEP20 poolToken;           // Address of LP token contract.\n', '        uint256 zooRewardRate;\n', '        uint256 totalStakeAmount;\n', '        uint256 openTime;\n', '        bool isOpen;\n', '    }\n', '\n', '    struct KeyFlag {\n', '        address key;\n', '        bool isExist;\n', '    }\n', '\n', '    // The ZOO TOKEN!\n', '    ZooToken public zoo;\n', '\n', '    // Info of each pool.\n', '    PoolInfo[] public poolInfo;\n', '\n', '    mapping (uint256 => mapping (address => UserInfo)) public userInfo;\n', '\n', '    event Stake(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event CancelStake(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '\n', '    constructor(\n', '        address _zooTokenAddress\n', '    ) public {\n', '        zoo = ZooToken(_zooTokenAddress);\n', '    }\n', '\n', '    function poolLength() external view returns (uint256) {\n', '        return poolInfo.length;\n', '    }\n', '\n', '    // Add a new lp to the pool. Can only be called by the owner.\n', '    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n', '    function addPool(address _poolAddress, uint256 _zooRewardRate, uint256 _openTime, bool _isOpen) public onlyOwner {\n', '        IBEP20 _poolToken = IBEP20(_poolAddress);\n', '        poolInfo.push(PoolInfo({\n', '        poolToken: _poolToken,\n', '        zooRewardRate: _zooRewardRate,\n', '        totalStakeAmount: 0,\n', '        openTime: _openTime,\n', '        isOpen: _isOpen\n', '        }));\n', '    }\n', '\n', '    function updatePool(uint256 _pid, uint256 _zooRewardRate, uint256 _openTime, bool _isOpen) public onlyOwner {\n', '        poolInfo[_pid].zooRewardRate = _zooRewardRate;\n', '        poolInfo[_pid].openTime = _openTime;\n', '        poolInfo[_pid].isOpen = _isOpen;\n', '    }\n', '\n', '\n', '    function addUser(uint256 _pid, uint256 _amount) private {\n', '        userInfo[_pid][msg.sender] = UserInfo(\n', '            _amount,\n', '            0,\n', '            block.timestamp,\n', '            true\n', '        );\n', '    }\n', '\n', '    function stake(uint256 _pid, uint256 _amount) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        pool.poolToken.transferFrom(address(msg.sender), address(this), _amount);\n', '\n', '        if(user.isExist == false){\n', '            addUser(_pid, _amount);\n', '        }else{\n', '            user.stakeAmount = user.stakeAmount.add(_amount);\n', '            uint256 profit = getUserProfit(_pid, false);\n', '\n', '            if (profit > 0) {\n', '                user.balance = user.balance.add(profit);\n', '            }\n', '\n', '            user.pledgeTime = block.timestamp;\n', '        }\n', '        \n', '        pool.totalStakeAmount = pool.totalStakeAmount.add(_amount);\n', '\n', '        emit Stake(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    function cancelStake(uint256 _pid) public payable {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '\n', '        if (user.isExist) {\n', '            if (user.stakeAmount > 0) {\n', '                uint256 stakeAmount = user.stakeAmount;\n', '                uint256 profitAmount = getUserProfit(_pid, true);\n', '\n', '                user.stakeAmount = 0;\n', '                user.balance = 0;\n', '                pool.totalStakeAmount = pool.totalStakeAmount.sub(stakeAmount);\n', '\n', '                pool.poolToken.safeTransfer(address(msg.sender), stakeAmount);\n', '\n', '                if (profitAmount > 0) {\n', '                    safeZooTransfer(address(msg.sender), profitAmount);\n', '                }\n', '\n', '                emit CancelStake(msg.sender, _pid, msg.value);\n', '            }\n', '        }\n', '    }\n', '\n', '    function withdraw(uint256 _pid) public {\n', '        uint256 profitAmount = getUserProfit(_pid, true);\n', '        require(profitAmount > 0,"profit must gt 0");\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        user.pledgeTime = block.timestamp;\n', '        user.balance = 0;\n', '        safeZooTransfer(address(msg.sender), profitAmount);\n', '        emit Withdraw(msg.sender, _pid, profitAmount);\n', '    }\n', '\n', '\n', '    function getUserProfit(uint256 _pid, bool _withBalance) private view returns (uint256) {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '\n', '        uint256 profit = 0;\n', '\n', '        if (user.stakeAmount > 0) {\n', '            uint256 totalStakeAmount = pool.totalStakeAmount;\n', '            if (totalStakeAmount > 0) {\n', '                uint256 time = block.timestamp;\n', '                uint256 hour = time.sub(user.pledgeTime).div(3600);\n', '\n', '                if (hour >= 1) {\n', '                    uint256 rate = user.stakeAmount.mul(1e18).div(totalStakeAmount);\n', '                    uint256 profitAmount = rate.mul(pool.zooRewardRate).mul(hour).div(1e18);\n', '                    if (profitAmount > 0) {\n', '                        profit = profit.add(profitAmount);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        if (_withBalance) {\n', '            profit = profit.add(user.balance);\n', '        }\n', '\n', '        return profit;\n', '    }\n', '\n', '    function getProfit(uint256 _pid) public view returns (uint256) {\n', '        uint256 profit = getUserProfit(_pid, true);\n', '        return profit;\n', '    }\n', '\n', '    function getPoolStake(uint256 _pid) public view returns (uint256) {\n', '        PoolInfo memory pool = poolInfo[_pid];\n', '        return pool.totalStakeAmount;\n', '    }\n', '\n', '    function getUserStake(uint256 _pid) public view returns (uint256){\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        return user.stakeAmount;\n', '    }\n', '\n', '    function safeZooTransfer(address _to, uint256 _amount) internal {\n', '        uint256 zooBalance = zoo.balanceOf(address(this));\n', '        if (_amount > zooBalance) {\n', '            zoo.transfer(_to, zooBalance);\n', '        } else {\n', '            zoo.transfer(_to, _amount);\n', '        }\n', '    }\n', '}']