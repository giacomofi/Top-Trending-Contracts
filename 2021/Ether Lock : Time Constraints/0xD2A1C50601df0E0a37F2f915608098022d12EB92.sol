['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./IATokenV1.sol";\n', 'import "./ICToken.sol";\n', 'import "./IComptroller.sol";\n', 'import "./ISushiBar.sol";\n', 'import "./ILendingPoolV1.sol";\n', 'import "./ICompoundLens.sol";\n', 'import "./IUniswapV2.sol";\n', 'import "./IBasicIssuanceModule.sol";\n', 'import "./IOneInch.sol";\n', '\n', 'import "./SafeMath.sol";\n', 'import "./ERC20.sol";\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./ReentrancyGuard.sol";\n', '\n', 'import "./BMIZapper.sol";\n', '\n', '// Basket Weaver is a way to socialize gas costs related to minting baskets tokens\n', 'contract SocialBMIZapper is ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    address public governance;\n', '    address public bmi;\n', '    address public bmiZapper;\n', '\n', '    // **** ERC20 **** //\n', '\n', '    // Token => Id\n', '    mapping(address => uint256) public curId;\n', '\n', '    // Token => User Address => Id => Amount deposited\n', '    mapping(address => mapping(address => mapping(uint256 => uint256))) public deposits;\n', '\n', '    // Token => User Address => Id => Claimed\n', '    mapping(address => mapping(address => mapping(uint256 => bool))) public claimed;\n', '\n', '    // Token => Id => Amount deposited\n', '    mapping(address => mapping(uint256 => uint256)) public totalDeposited;\n', '\n', '    // Token => Basket minted per weaveId\n', '    mapping(address => mapping(uint256 => uint256)) public minted;\n', '\n', '    // Approved users to call weave\n', '    // This is v important as invalid inputs will\n', '    // be basically a "fat finger"\n', '    mapping(address => bool) public approvedWeavers;\n', '\n', '    // **** Constructor and modifiers ****\n', '\n', '    constructor(\n', '        address _governance,\n', '        address _bmi,\n', '        address _bmiZapper\n', '    ) {\n', '        governance = _governance;\n', '        bmi = _bmi;\n', '        bmiZapper = _bmiZapper;\n', '    }\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == governance, "!governance");\n', '        _;\n', '    }\n', '\n', '    modifier onlyWeavers {\n', '        require(msg.sender == governance || approvedWeavers[msg.sender], "!weaver");\n', '        _;\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    // **** Protected functions ****\n', '\n', '    function approveWeaver(address _weaver) public onlyGov {\n', '        approvedWeavers[_weaver] = true;\n', '    }\n', '\n', '    function revokeWeaver(address _weaver) public onlyGov {\n', '        approvedWeavers[_weaver] = false;\n', '    }\n', '\n', '    function setGov(address _governance) public onlyGov {\n', '        governance = _governance;\n', '    }\n', '\n', '    // Emergency\n', '    function recoverERC20(address _token) public onlyGov {\n', '        IERC20(_token).safeTransfer(governance, IERC20(_token).balanceOf(address(this)));\n', '    }\n', '\n', '    function socialZap(\n', '        address _from,\n', '        address _fromUnderlying,\n', '        uint256 _fromUnderlyingAmount,\n', '        uint256 _minBMIRecv,\n', '        address[] memory _bmiConstituents,\n', '        uint256[] memory _bmiConstituentsWeightings,\n', '        address _aggregator,\n', '        bytes memory _aggregatorData,\n', '        uint256 deadline\n', '    ) public onlyWeavers {\n', '        require(block.timestamp <= deadline, "expired");\n', '\n', '        uint256 _fromAmount = IERC20(_from).balanceOf(address(this));\n', '\n', '        IERC20(_from).safeApprove(bmiZapper, 0);\n', '        IERC20(_from).safeApprove(bmiZapper, _fromAmount);\n', '\n', '        uint256 bmiMinted =\n', '            BMIZapper(bmiZapper).zapToBMI(\n', '                _from,\n', '                _fromAmount,\n', '                _fromUnderlying,\n', '                _fromUnderlyingAmount,\n', '                _minBMIRecv,\n', '                _bmiConstituents,\n', '                _bmiConstituentsWeightings,\n', '                _aggregator,\n', '                _aggregatorData,\n', '                true\n', '            );\n', '\n', '        minted[_from][curId[_from]] = bmiMinted;\n', '\n', '        curId[_from]++;\n', '    }\n', '\n', '    // **** Public functions ****\n', '\n', '    /// @notice Deposits ERC20 to be later converted into the Basket by some kind soul\n', '    function deposit(address _token, uint256 _amount) public nonReentrant {\n', '        IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);\n', '\n', '        deposits[_token][msg.sender][curId[_token]] = deposits[_token][msg.sender][curId[_token]].add(_amount);\n', '        totalDeposited[_token][curId[_token]] = totalDeposited[_token][curId[_token]].add(_amount);\n', '    }\n', '\n', "    /// @notice User doesn't want to wait anymore and just wants their ERC20 back\n", '    function withdraw(address _token, uint256 _amount) public nonReentrant {\n', '        // Reverts if withdrawing too many\n', '        deposits[_token][msg.sender][curId[_token]] = deposits[_token][msg.sender][curId[_token]].sub(_amount);\n', '        totalDeposited[_token][curId[_token]] = totalDeposited[_token][curId[_token]].sub(_amount);\n', '\n', '        IERC20(_token).safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    /// @notice User withdraws converted Basket token\n', '    function withdrawBMI(address _token, uint256 _id) public nonReentrant {\n', '        require(_id < curId[_token], "!weaved");\n', '        require(!claimed[_token][msg.sender][_id], "already-claimed");\n', '        uint256 userDeposited = deposits[_token][msg.sender][_id];\n', '        require(userDeposited > 0, "!deposit");\n', '\n', '        uint256 ratio = userDeposited.mul(1e18).div(totalDeposited[_token][_id]);\n', '        uint256 userBasketAmount = minted[_token][_id].mul(ratio).div(1e18);\n', '        claimed[_token][msg.sender][_id] = true;\n', '\n', '        IERC20(address(bmi)).safeTransfer(msg.sender, userBasketAmount);\n', '    }\n', '\n', '    /// @notice User withdraws converted Basket token\n', '    function withdrawBMIMany(address[] memory _tokens, uint256[] memory _ids) public {\n', '        assert(_tokens.length == _ids.length);\n', '\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            withdrawBMI(_tokens[i], _ids[i]);\n', '        }\n', '    }\n', '}']