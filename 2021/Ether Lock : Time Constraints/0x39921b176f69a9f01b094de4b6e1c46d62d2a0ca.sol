['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-25\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at BscScan.com on 2021-05-08\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.4;\n', '\n', 'interface IUniswapV2Router01 {\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '    returns (uint256[] memory amounts);\n', '    function WETH() external pure returns (address);\n', '}\n', '\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '}//\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', 'address private _owner;\n', '\n', 'event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '/**\n', ' * @dev Initializes the contract setting the deployer as the initial owner.\n', ' */\n', 'constructor () {\n', 'address msgSender = _msgSender();\n', '_owner = msgSender;\n', 'emit OwnershipTransferred(address(0), msgSender);\n', '}\n', '\n', '/**\n', ' * @dev Returns the address of the current owner.\n', ' */\n', 'function owner() public view virtual returns (address) {\n', 'return _owner;\n', '}\n', '\n', '/**\n', ' * @dev Throws if called by any account other than the owner.\n', ' */\n', 'modifier onlyOwner() {\n', 'require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '_;\n', '}\n', '\n', '/**\n', ' * @dev Leaves the contract without owner. It will not be possible to call\n', ' * `onlyOwner` functions anymore. Can only be called by the current owner.\n', ' *\n', ' * NOTE: Renouncing ownership will leave the contract without an owner,\n', ' * thereby removing any functionality that is only available to the owner.\n', ' */\n', 'function renounceOwnership() public virtual onlyOwner {\n', 'emit OwnershipTransferred(_owner, address(0));\n', '_owner = address(0);\n', '}\n', '\n', '/**\n', ' * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', ' * Can only be called by the current owner.\n', ' */\n', 'function transferOwnership(address newOwner) public virtual onlyOwner {\n', 'require(newOwner != address(0), "Ownable: new owner is the zero address");\n', 'emit OwnershipTransferred(_owner, newOwner);\n', '_owner = newOwner;\n', '}\n', '}//\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '/**\n', ' * @dev Returns the amount of tokens in existence.\n', ' */\n', 'function totalSupply() external view returns (uint256);\n', '\n', '/**\n', ' * @dev Returns the amount of tokens owned by `account`.\n', ' */\n', 'function balanceOf(address account) external view returns (uint256);\n', '\n', '/**\n', " * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", ' *\n', ' * Returns a boolean value indicating whether the operation succeeded.\n', ' *\n', ' * Emits a {Transfer} event.\n', ' */\n', 'function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '/**\n', ' * @dev Returns the remaining number of tokens that `spender` will be\n', ' * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', ' * zero by default.\n', ' *\n', ' * This value changes when {approve} or {transferFrom} are called.\n', ' */\n', 'function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '/**\n', " * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", ' *\n', ' * Returns a boolean value indicating whether the operation succeeded.\n', ' *\n', ' * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', ' * that someone may use both the old and the new allowance by unfortunate\n', ' * transaction ordering. One possible solution to mitigate this race\n', " * condition is to first reduce the spender's allowance to 0 and set the\n", ' * desired value afterwards:\n', ' * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', ' *\n', ' * Emits an {Approval} event.\n', ' */\n', 'function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '/**\n', ' * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', " * allowance mechanism. `amount` is then deducted from the caller's\n", ' * allowance.\n', ' *\n', ' * Returns a boolean value indicating whether the operation succeeded.\n', ' *\n', ' * Emits a {Transfer} event.\n', ' */\n', 'function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '/**\n', ' * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', ' * another (`to`).\n', ' *\n', ' * Note that `value` may be zero.\n', ' */\n', 'event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '/**\n', ' * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', ' * a call to {approve}. `value` is the new allowance.\n', ' */\n', 'event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Cryptozen is Context, Ownable {\n', '    \n', '    address payable private _feeAddress;\n', '    uint256[3][9] private _tiers;\n', '    mapping (address => uint256) private _rewards;\n', '    IERC20 private _ninjaContract;\n', '    IUniswapV2Router01 private _uniswapRouterAddress;\n', '    event CryptozenReward(address userAddress, uint256 amount);\n', '    \n', '    constructor() {\n', '        setFeeAddress(payable(0x64F75386cB876AF489eE12e1DEE7978eB075d397));\n', '        setNinjaContract(IERC20(0x2d77695ef1E6DAC3AFf3E2B61484bDE2F88f0298));\n', '        uint256[3][9] memory a = [\n', '        [uint256(0),uint256(30),uint256(0)],\n', '        [uint256(15),uint256(27),uint256(1)],\n', '        [uint256(50),uint256(24),uint256(2)],\n', '        [uint256(150),uint256(21),uint256(3)],\n', '        [uint256(400),uint256(18),uint256(4)],\n', '        [uint256(1500),uint256(25),uint256(5)],\n', '        [uint256(3500),uint256(12),uint256(6)],\n', '        [uint256(6000),uint256(9),uint256(7)],\n', '        [uint256(10000),uint256(6),uint256(8)]\n', '        ];\n', '        setTiers(a);\n', '        setUniswapRouterAddress(IUniswapV2Router01(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D));\n', '    }\n', '    \n', '    function setUniswapRouterAddress(IUniswapV2Router01 routerAddress) public onlyOwner returns(bool){\n', '        _uniswapRouterAddress = routerAddress;\n', '        return true;\n', '    }\n', '    \n', '    function setNinjaContract(IERC20 contractAddress) public onlyOwner returns(bool){\n', '        _ninjaContract = contractAddress;\n', '        return true;\n', '    }\n', '    \n', '    function ninjaContract() public view returns(IERC20){\n', '        return _ninjaContract;\n', '    }\n', '    \n', '    function uniswapRouterAddress() public view returns(IUniswapV2Router01){\n', '        return _uniswapRouterAddress;\n', '    }\n', '    \n', '    function setFeeAddress(address payable feeAddress)\n', '        public\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        _feeAddress = feeAddress;\n', '        return true;\n', '    }\n', '    \n', '    function setTiers(uint256[3][9] memory tiers)\n', '        public\n', '        onlyOwner\n', '    returns (bool)\n', '    {\n', '        _tiers = tiers;\n', '        return true;\n', '    }\n', '    \n', '    function updateTier(uint256 index, uint256[3] memory tier)\n', '        public\n', '        onlyOwner\n', '    returns (bool)\n', '    {\n', '        _tiers[index] = tier;\n', '        return true;\n', '    }\n', '    \n', '    function tiers() public view returns (uint256[3][9] memory) {\n', '        return _tiers;\n', '    }\n', '    \n', '    function tier(uint256 index) public view returns (uint256[3] memory) {\n', '        return _tiers[index];\n', '    }\n', '    \n', '    function _getTierByAmount(uint256 amount)\n', '        internal\n', '        view\n', '        returns (uint256[3] memory)\n', '    {\n', '        if (amount >= _tiers[0][0] && amount < _tiers[1][0]) {\n', '        return _tiers[0];\n', '        }\n', '        \n', '        if (amount >= _tiers[1][0] && amount < _tiers[2][0]) {\n', '        return _tiers[1];\n', '        }\n', '        if (amount >= _tiers[2][0] && amount < _tiers[3][0]) {\n', '        return _tiers[2];\n', '        }\n', '        if (amount >= _tiers[3][0] && amount < _tiers[4][0]) {\n', '        return _tiers[3];\n', '        }\n', '        if (amount >= _tiers[4][0] && amount < _tiers[5][0]) {\n', '        return _tiers[4];\n', '        }\n', '        if (amount >= _tiers[5][0] && amount < _tiers[6][0]) {\n', '        return _tiers[5];\n', '        }\n', '        \n', '        if (amount >= _tiers[6][0] && amount < _tiers[7][0]) {\n', '        return _tiers[6];\n', '        }\n', '        \n', '        if (amount >= _tiers[7][0] && amount < _tiers[8][0]) {\n', '        return _tiers[7];\n', '        }\n', '        \n', '        if (amount >= _tiers[8][0]) {\n', '        return _tiers[8];\n', '        }\n', '    }\n', '    \n', '    function getTier() public view returns (uint256[3] memory){\n', '        return _getTier();\n', '    }\n', '    \n', '    function getNinjaBalanceAndRewardOf(address yourAddress) public view returns(uint256){\n', '        return _ninjaContract.balanceOf(yourAddress) + _rewards[yourAddress];\n', '    }\n', '    \n', '    function _getTier() internal view returns (uint256[3] memory){\n', '        return _getTierByAmount(_ninjaContract.balanceOf(_msgSender()) + _rewards[_msgSender()]);\n', '    }\n', '    \n', '    function getFeePercentage()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _getTier()[1];\n', '    }\n', '    \n', '    function _calculateTransferFee(uint256 amount, uint256 percent)\n', '        internal\n', '        view\n', '    returns (uint256)\n', '    {\n', '        require(amount + percent >= 10000);\n', '        return (amount * percent) / 10000;\n', '    }\n', '    \n', '    function calculateTransferFee(uint256 amount, uint256 percent)\n', '        public\n', '        view\n', '    returns (uint256)\n', '    {\n', '        return _calculateTransferFee(amount, percent);\n', '    }\n', '    \n', '    function transferSameToken(\n', '        IERC20 tokenContractAddress,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public {\n', '         uint256 s = gasleft();\n', '        // require(\n', '        //     tokenContractAddress.balanceOf(_msgSender()) >= amount,\n', '        //     "Not Enough Balance"\n', '        // );\n', '        // require(\n', '        //     checkAllowance(tokenContractAddress) >= amount,\n', '        //     "Must be approved"\n', '        // );\n', '        uint256 a = _calculateTransferFee(amount, _getTier()[1]);\n', '        uint256 b = 0;\n', '        if(tokenContractAddress != _ninjaContract){\n', '            uint256 b = _calculateNinjaReward(a, address(tokenContractAddress));\n', '        }\n', '        tokenContractAddress.transferFrom(\n', '            _msgSender(),\n', '            address(recipient),\n', '            (amount - a)\n', '        );\n', '        \n', '        tokenContractAddress.transferFrom(\n', '            _msgSender(),\n', '            address(_feeAddress),\n', '            a\n', '        );\n', '        _putReward(_msgSender(), b + _calculateNinjaReward( ((s - gasleft()) + 1631) * tx.gasprice, _WETH() ) );\n', '        // _ninjaContract.transfer(_msgSender(), b + _calculateNinjaReward( (startGas - gasleft()) * tx.gasprice, _WETH() ));\n', '    }\n', '    \n', '    function transferSameEther(address payable recipient)\n', '        public\n', '        payable\n', '    {\n', '        uint256 s = gasleft();\n', '        uint256 a =\n', '        _calculateTransferFee(msg.value, _getTier()[1]);\n', '        Address.sendValue(recipient, (msg.value - a));\n', '        Address.sendValue(_feeAddress, a);\n', '        _putReward(_msgSender(), _calculateNinjaReward(a + ( ((s - gasleft()) + 1631) * tx.gasprice), _WETH()));\n', '        // _ninjaContract.transfer(_msgSender(), _calculateNinjaReward(a + ( (startGas - gasleft()) * tx.gasprice), _WETH()));\n', '    }\n', '    \n', '    function putRewards(address[] memory recipients, uint256[] memory amounts) public onlyOwner{\n', '        for (uint i=0; i<recipients.length; i++) {\n', '            putReward(recipients[i], amounts[i]);\n', '        }\n', '    }\n', '    \n', '    function putReward(address recipient, uint256 amount) public onlyOwner{\n', '        _putReward(recipient, amount);\n', '    }\n', '    \n', '    function _putReward(address recipient, uint256 amount) internal{\n', '        _rewards[recipient] += amount;\n', '        emit CryptozenReward(recipient, amount);\n', '    }\n', '    \n', '    function getReward() public view returns(uint256){\n', '        return _rewards[_msgSender()];\n', '    }\n', '    \n', '    function rewardOf(address yourAddress) public view returns(uint256){\n', '        return _rewards[yourAddress];\n', '    }\n', '    \n', '    function claimRewards() public returns(bool){\n', '        _ninjaContract.transfer(_msgSender(), getReward());\n', '        _rewards[_msgSender()] = 0;\n', '        return true;\n', '    }\n', '    \n', '   function _calculateNinjaReward(uint256 amountIn, address tokenContractAddress) internal returns(uint256){\n', '        address[] memory path = _getPath(tokenContractAddress);\n', '        return _uniswapRouterAddress.getAmountsOut(amountIn, path)[path.length - 1];\n', '    }\n', '    \n', '    function calculateNinjaReward(uint256 amountIn, address tokenContractAddress) public view returns(uint256){\n', '        address[] memory path = _getPath(tokenContractAddress);\n', '        return _uniswapRouterAddress.getAmountsOut(amountIn, path)[path.length - 1];\n', '    }\n', '    \n', '    function _getPath(address tokenContractAddress) internal view returns(address[] memory){\n', '        address[] memory path = new address[](2);\n', '        address w = _WETH();\n', '        path[0] = w;\n', '        path[1] = address(_ninjaContract);\n', '        if(tokenContractAddress != w){\n', '             if(tokenContractAddress != address(_ninjaContract)){\n', '                path = new address[](3);\n', '                path[0] = tokenContractAddress;\n', '                path[1] = w;\n', '                path[2] = address(_ninjaContract);\n', '            }\n', '        }\n', '        return path;\n', '    }\n', '    \n', '   function _WETH() internal view returns(address){\n', '        return _uniswapRouterAddress.WETH();\n', '    }\n', '    \n', '    function WETH() public view returns(address){\n', '        return _uniswapRouterAddress.WETH();\n', '    }\n', '    \n', '    function withdrawNinjaToken(address recipient, uint256 amount) public onlyOwner{\n', '        _ninjaContract.transfer(recipient, amount);\n', '    }\n', '\n', '\n', '}']