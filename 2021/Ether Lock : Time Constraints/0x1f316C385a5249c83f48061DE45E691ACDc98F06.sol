['// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.3;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./AccessControl.sol";\n', '\n', 'import "./IUniswapV2.sol";\n', 'import "./IWETH.sol";\n', 'import "./IBasket.sol";\n', '\n', 'import "./BDIMarketMaker.sol";\n', '\n', 'contract DelayedBurner is MarketMakerBurner {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    // Can only burn after 20 mins, and only has a 20 mins window to burn\n', '    // 20 min window to burn\n', '    uint256 public burnDelaySeconds = 1200;\n', '    uint256 public maxBurnDelaySeconds = 2400;\n', '\n', '    // Deployer\n', '    address public governance;\n', '\n', '    // User deposited\n', '    mapping(address => uint256) public deposits;\n', '\n', '    // When user deposited\n', '    mapping(address => uint256) public timestampWhenDeposited;\n', '\n', '    // Blacklist\n', '    mapping(address => bool) public isBlacklisted;\n', '\n', '    constructor(address _governance) {\n', '        governance = _governance;\n', '\n', '        IERC20(WETH).safeApprove(SUSHISWAP_ROUTER, uint256(-1));\n', '        IERC20(WETH).safeApprove(UNIV2_ROUTER, uint256(-1));\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    // **** Modifiers ****\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == governance, "!governance");\n', '        _;\n', '    }\n', '\n', '    modifier onlyEOA() {\n', '        require(msg.sender == tx.origin, "!eoa");\n', '        _;\n', '    }\n', '\n', '    modifier notBlacklisted() {\n', '        require(!isBlacklisted[msg.sender], "blacklisted");\n', '        _;\n', '    }\n', '\n', '    // **** Restricted functions ****\n', '\n', '    function setGov(address _governance) public onlyGov {\n', '        governance = _governance;\n', '    }\n', '\n', '    function rescueERC20(address _token) public onlyGov {\n', '        require(_token != address(BDPI), "!bdpi");\n', '        uint256 _amount = IERC20(_token).balanceOf(address(this));\n', '        IERC20(_token).safeTransfer(governance, _amount);\n', '    }\n', '\n', '    function rescueERC20s(address[] memory _tokens) public onlyGov {\n', '        for (uint256 i = 0; i < _tokens.length; i++) {\n', '            rescueERC20(_tokens[i]);\n', '        }\n', '    }\n', '\n', '    function setBurnDelaySeconds(uint256 _seconds) public onlyGov {\n', '        burnDelaySeconds = _seconds;\n', '    }\n', '\n', '    function setMaxBurnDelaySeconds(uint256 _seconds) public onlyGov {\n', '        maxBurnDelaySeconds = _seconds;\n', '    }\n', '\n', '    function setBlacklist(address _user, bool _b) public onlyGov {\n', '        isBlacklisted[_user] = _b;\n', '    }\n', '\n', '    // **** Deposit **** //\n', '\n', '    function deposit(uint256 _amount) public {\n', '        IERC20(address(BDPI)).safeTransferFrom(msg.sender, address(this), _amount);\n', '\n', '        deposits[msg.sender] = deposits[msg.sender].add(_amount);\n', '        timestampWhenDeposited[msg.sender] = block.timestamp;\n', '    }\n', '\n', '    // **** Withdraw **** //\n', '\n', '    function withdraw(uint256 _amount) public {\n', '        deposits[msg.sender] = deposits[msg.sender].sub(_amount);\n', '\n', '        IERC20(address(BDPI)).safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    // **** Burn **** //\n', '\n', '    function burn() public onlyEOA notBlacklisted returns (uint256[] memory) {\n', '        uint256 _amount = deposits[msg.sender];\n', '\n', '        require(_amount > 0, "!amount");\n', '        require(_canBurn(timestampWhenDeposited[msg.sender]), "!timestamp");\n', '\n', '        deposits[msg.sender] = 0;\n', '\n', '        (address[] memory assets, ) = IBasket(BDPI).getAssetsAndBalances();\n', '        uint256[] memory deltas = new uint256[](assets.length);\n', '\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            deltas[i] = IERC20(assets[i]).balanceOf(address(this));\n', '        }\n', '        IBasket(BDPI).burn(_amount);\n', '        for (uint256 i = 0; i < assets.length; i++) {\n', '            deltas[i] = IERC20(assets[i]).balanceOf(address(this)).sub(deltas[i]);\n', '            IERC20(assets[i]).transfer(msg.sender, deltas[i]);\n', '        }\n', '\n', '        return deltas;\n', '    }\n', '\n', '    function burnToETH(\n', '        address[] memory routers,\n', '        bytes[] memory routerCalldata,\n', '        address[] memory constituents,\n', '        address[] memory underlyings,\n', '        uint256[] memory underlyingsWeights,\n', '        uint256 _minETHAmount\n', '    ) public onlyEOA notBlacklisted returns (uint256) {\n', '        uint256 _amount = deposits[msg.sender];\n', '\n', '        require(_amount > 0, "!amount");\n', '        require(_canBurn(timestampWhenDeposited[msg.sender]), "!timestamp");\n', '\n', '        deposits[msg.sender] = 0;\n', '\n', '        // Memory\n', '        bytes memory mmParams =\n', '            abi.encode(\n', '                MMParams({\n', '                    routers: routers,\n', '                    routerCalldata: routerCalldata,\n', '                    constituents: constituents,\n', '                    underlyings: underlyings,\n', '                    underlyingsWeights: underlyingsWeights\n', '                })\n', '            );\n', '            \n', '        _burnBDIToWETH(_amount, mmParams);\n', '        uint256 totalWETH = IERC20(WETH).balanceOf(address(this));\n', '        require(totalWETH >= _minETHAmount, "!min-eth-amount");\n', '        IWETH(WETH).withdraw(totalWETH);\n', '\n', '        (bool success, ) = msg.sender.call{ value: totalWETH }("");\n', '        require(success, "!eth-transfer");\n', '\n', '        return totalWETH;\n', '    }\n', '\n', '    // **** Internals **** //\n', '\n', '    function _canBurn(uint256 _depositTime) public view returns (bool) {\n', '        return\n', '            block.timestamp >= _depositTime + burnDelaySeconds && block.timestamp <= _depositTime + maxBurnDelaySeconds;\n', '    }\n', '}']