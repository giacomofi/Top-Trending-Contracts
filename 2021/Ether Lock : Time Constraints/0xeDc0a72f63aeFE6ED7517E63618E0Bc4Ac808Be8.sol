['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-13\n', '*/\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' *\n', ' * _Since v2.5.0:_ this module is now much more gas efficient, given net gas\n', ' * metering changes introduced in the Istanbul hardfork.\n', ' */\n', 'contract ReentrancyGuard {\n', '    bool private _notEntered;\n', '\n', '    constructor () internal {\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/AddressHelper.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library AddressHelper {\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(\n', '            abi.encodeWithSelector(0xa9059cbb, to, value)\n', '        );\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', '            "TRANSFER_FAILED"\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(\n', '            abi.encodeWithSelector(0x23b872dd, from, to, value)\n', '        );\n', '        require(\n', '            success && (data.length == 0 || abi.decode(data, (bool))),\n', '            "TRANSFER_FROM_FAILED"\n', '        );\n', '    }\n', '\n', '    function safeTransferEther(address to, uint256 value) internal {\n', '        (bool success, ) = to.call.value(value)(new bytes(0));\n', '        require(success, "ETH_TRANSFER_FAILED");\n', '    }\n', '\n', '    function isContract(address token) internal view returns (bool) {\n', '        if (token == address(0x0)) {\n', '            return false;\n', '        }\n', '        uint256 size;\n', '        assembly {\n', '            size := extcodesize(token)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', '     * @dev returns the address used within the protocol to identify ETH\n', '     * @return the address assigned to ETH\n', '     */\n', '    function ethAddress() internal pure returns (address) {\n', '        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/XNum.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'library XNum {\n', '    uint256 public constant BONE = 10**18;\n', '    uint256 public constant MIN_BPOW_BASE = 1 wei;\n', '    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n', '    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n', '\n', '    function btoi(uint256 a) internal pure returns (uint256) {\n', '        return a / BONE;\n', '    }\n', '\n', '    function bfloor(uint256 a) internal pure returns (uint256) {\n', '        return btoi(a) * BONE;\n', '    }\n', '\n', '    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ERR_ADD_OVERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        (uint256 c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint256 c1 = c0 + (BONE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint256 c2 = c1 / BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint256 c0 = a * BONE;\n', '        require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint256 c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint256 c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    // DSMath.wpow\n', '    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n', '        uint256 z = n % 2 != 0 ? a : BONE;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            a = bmul(a, a);\n', '\n', '            if (n % 2 != 0) {\n', '                z = bmul(z, a);\n', '            }\n', '        }\n', '        return z;\n', '    }\n', '\n', '    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n', '    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n', '    // of approximation of b^0.w\n', '    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n', '        require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");\n', '        require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");\n', '\n', '        uint256 whole = bfloor(exp);\n', '        uint256 remain = bsub(exp, whole);\n', '\n', '        uint256 wholePow = bpowi(base, btoi(whole));\n', '\n', '        if (remain == 0) {\n', '            return wholePow;\n', '        }\n', '\n', '        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n', '        return bmul(wholePow, partialResult);\n', '    }\n', '\n', '    function bpowApprox(\n', '        uint256 base,\n', '        uint256 exp,\n', '        uint256 precision\n', '    ) internal pure returns (uint256) {\n', '        // term 0:\n', '        uint256 a = exp;\n', '        (uint256 x, bool xneg) = bsubSign(base, BONE);\n', '        uint256 term = BONE;\n', '        uint256 sum = term;\n', '        bool negative = false;\n', '\n', '        // term(k) = numer / denom\n', '        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\n', '        // each iteration, multiply previous term by (a-(k-1)) * x / k\n', '        // continue until term is less than precision\n', '        for (uint256 i = 1; term >= precision; i++) {\n', '            uint256 bigK = i * BONE;\n', '            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n', '            term = bmul(term, bmul(c, x));\n', '            term = bdiv(term, bigK);\n', '            if (term == 0) break;\n', '\n', '            if (xneg) negative = !negative;\n', '            if (cneg) negative = !negative;\n', '            if (negative) {\n', '                sum = bsub(sum, term);\n', '            } else {\n', '                sum = badd(sum, term);\n', '            }\n', '        }\n', '\n', '        return sum;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    ) external returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        external\n', '        view\n', '        returns (uint256 remaining);\n', '}\n', '\n', '// File: contracts/XHalfLife.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract XHalfLife is ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '    using AddressHelper for address;\n', '\n', '    uint256 private constant ONE = 10**18;\n', '\n', '    /**\n', '     * @notice Counter for new stream ids.\n', '     */\n', '    uint256 public nextStreamId = 1;\n', '\n', '    /**\n', '     * @notice key: stream id, value: minimum effective value(0.0001 TOKEN)\n', '     */\n', '    mapping(uint256 => uint256) public effectiveValues;\n', '\n', '    // halflife stream\n', '    struct Stream {\n', '        uint256 depositAmount; // total deposited amount, must >= 0.0001 TOKEN\n', '        uint256 remaining; // un-withdrawable balance\n', '        uint256 withdrawable; // withdrawable balance\n', '        uint256 startBlock; // when should start\n', '        uint256 kBlock; // interval K blocks\n', '        uint256 unlockRatio; // must be between [1-999], which means 0.1% to 99.9%\n', '        uint256 denom; // one readable coin represent\n', '        uint256 lastRewardBlock; // update by create(), fund() and withdraw()\n', '        address token; // ERC20 token address or 0xEe for Ether\n', '        address recipient;\n', '        address sender;\n', '        bool cancelable; // can be cancelled or not\n', '        bool isEntity;\n', '    }\n', '\n', '    /**\n', '     * @notice The stream objects identifiable by their unsigned integer ids.\n', '     */\n', '    mapping(uint256 => Stream) public streams;\n', '\n', '    /**\n', '     * @dev Throws if the provided id does not point to a valid stream.\n', '     */\n', '    modifier streamExists(uint256 streamId) {\n', '        require(streams[streamId].isEntity, "stream does not exist");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if the caller is not the sender of the recipient of the stream.\n', '     *  Throws if the recipient is the zero address, the contract itself or the caller.\n', '     *  Throws if the depositAmount is 0.\n', '     *  Throws if the start block is before `block.number`.\n', '     */\n', '    modifier createStreamPreflight(\n', '        address recipient,\n', '        uint256 depositAmount,\n', '        uint256 startBlock,\n', '        uint256 kBlock\n', '    ) {\n', '        require(recipient != address(0), "stream to the zero address");\n', '        require(recipient != address(this), "stream to the contract itself");\n', '        require(recipient != msg.sender, "stream to the caller");\n', '        require(depositAmount > 0, "deposit amount is zero");\n', '        require(startBlock >= block.number, "start block before block.number");\n', '        require(kBlock > 0, "k block is zero");\n', '        _;\n', '    }\n', '\n', '    event StreamCreated(\n', '        uint256 indexed streamId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        address token,\n', '        uint256 depositAmount,\n', '        uint256 startBlock,\n', '        uint256 kBlock,\n', '        uint256 unlockRatio,\n', '        bool cancelable\n', '    );\n', '\n', '    event WithdrawFromStream(\n', '        uint256 indexed streamId,\n', '        address indexed recipient,\n', '        uint256 amount\n', '    );\n', '\n', '    event StreamCanceled(\n', '        uint256 indexed streamId,\n', '        address indexed sender,\n', '        address indexed recipient,\n', '        uint256 senderBalance,\n', '        uint256 recipientBalance\n', '    );\n', '\n', '    event StreamFunded(uint256 indexed streamId, uint256 amount);\n', '\n', '    /**\n', '     * @notice Creates a new stream funded by `msg.sender` and paid towards `recipient`.\n', '     * @dev Throws if paused.\n', '     *  Throws if the token is not a contract address\n', '     *  Throws if the recipient is the zero address, the contract itself or the caller.\n', '     *  Throws if the depositAmount is 0.\n', '     *  Throws if the start block is before `block.number`.\n', '     *  Throws if the rate calculation has a math error.\n', '     *  Throws if the next stream id calculation has a math error.\n', '     *  Throws if the contract is not allowed to transfer enough tokens.\n', '     * @param token The ERC20 token address\n', '     * @param recipient The address towards which the money is streamed.\n', '     * @param depositAmount The amount of money to be streamed.\n', '     * @param startBlock stream start block\n', '     * @param kBlock unlock every k blocks\n', '     * @param unlockRatio unlock ratio from remaining balance,\n', '     *                    value must be between [1-1000], which means 0.1% to 1%\n', '     * @param cancelable can be cancelled or not\n', '     * @return The uint256 id of the newly created stream.\n', '     */\n', '    function createStream(\n', '        address token,\n', '        address recipient,\n', '        uint256 depositAmount,\n', '        uint256 startBlock,\n', '        uint256 kBlock,\n', '        uint256 unlockRatio,\n', '        bool cancelable\n', '    )\n', '        external\n', '        createStreamPreflight(recipient, depositAmount, startBlock, kBlock)\n', '        returns (uint256 streamId)\n', '    {\n', '        require(unlockRatio < 1000, "unlockRatio must < 1000");\n', '        require(unlockRatio > 0, "unlockRatio must > 0");\n', '\n', '        require(token.isContract(), "not contract");\n', '        token.safeTransferFrom(msg.sender, address(this), depositAmount);\n', '\n', '        streamId = nextStreamId;\n', '        {\n', '            uint256 denom = 10**uint256(IERC20(token).decimals());\n', '            require(denom >= 10**6, "token decimal too small");\n', '\n', '            // 0.0001 TOKEN\n', '            effectiveValues[streamId] = denom.div(10**4);\n', '            require(\n', '                depositAmount >= effectiveValues[streamId],\n', '                "deposit too small"\n', '            );\n', '\n', '            streams[streamId] = Stream({\n', '                token: token,\n', '                remaining: depositAmount,\n', '                withdrawable: 0,\n', '                depositAmount: depositAmount,\n', '                startBlock: startBlock,\n', '                kBlock: kBlock,\n', '                unlockRatio: unlockRatio,\n', '                denom: denom,\n', '                lastRewardBlock: startBlock,\n', '                recipient: recipient,\n', '                sender: msg.sender,\n', '                isEntity: true,\n', '                cancelable: cancelable\n', '            });\n', '        }\n', '\n', '        nextStreamId = nextStreamId.add(1);\n', '        emit StreamCreated(\n', '            streamId,\n', '            msg.sender,\n', '            recipient,\n', '            token,\n', '            depositAmount,\n', '            startBlock,\n', '            kBlock,\n', '            unlockRatio,\n', '            cancelable\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Creates a new ether stream funded by `msg.sender` and paid towards `recipient`.\n', '     * @dev Throws if paused.\n', '     *  Throws if the recipient is the zero address, the contract itself or the caller.\n', '     *  Throws if the depositAmount is 0.\n', '     *  Throws if the start block is before `block.number`.\n', '     *  Throws if the rate calculation has a math error.\n', '     *  Throws if the next stream id calculation has a math error.\n', '     *  Throws if the contract is not allowed to transfer enough tokens.\n', '     * @param recipient The address towards which the money is streamed.\n', '     * @param startBlock stream start block\n', '     * @param kBlock unlock every k blocks\n', '     * @param unlockRatio unlock ratio from remaining balance\n', '     * @param cancelable can be cancelled or not\n', '     * @return The uint256 id of the newly created stream.\n', '     */\n', '    function createEtherStream(\n', '        address recipient,\n', '        uint256 startBlock,\n', '        uint256 kBlock,\n', '        uint256 unlockRatio,\n', '        bool cancelable\n', '    )\n', '        external\n', '        payable\n', '        createStreamPreflight(recipient, msg.value, startBlock, kBlock)\n', '        returns (uint256 streamId)\n', '    {\n', '        require(unlockRatio < 1000, "unlockRatio must < 1000");\n', '        require(unlockRatio > 0, "unlockRatio must > 0");\n', '        require(msg.value >= 10**14, "deposit too small");\n', '\n', '        /* Create and store the stream object. */\n', '        streamId = nextStreamId;\n', '        streams[streamId] = Stream({\n', '            token: AddressHelper.ethAddress(),\n', '            remaining: msg.value,\n', '            withdrawable: 0,\n', '            depositAmount: msg.value,\n', '            startBlock: startBlock,\n', '            kBlock: kBlock,\n', '            unlockRatio: unlockRatio,\n', '            denom: 10**18,\n', '            lastRewardBlock: startBlock,\n', '            recipient: recipient,\n', '            sender: msg.sender,\n', '            isEntity: true,\n', '            cancelable: cancelable\n', '        });\n', '\n', '        nextStreamId = nextStreamId.add(1);\n', '        emit StreamCreated(\n', '            streamId,\n', '            msg.sender,\n', '            recipient,\n', '            AddressHelper.ethAddress(),\n', '            msg.value,\n', '            startBlock,\n', '            kBlock,\n', '            unlockRatio,\n', '            cancelable\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Check if given stream exists.\n', '     * @param streamId The id of the stream to query.\n', '     * @return bool true=exists, otherwise false.\n', '     */\n', '    function hasStream(uint256 streamId) external view returns (bool) {\n', '        return streams[streamId].isEntity;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the stream with all its properties.\n', '     * @dev Throws if the id does not point to a valid stream.\n', '     * @param streamId The id of the stream to query.\n', '     * @return sender\n', '     * @return recipient\n', '     * @return token\n', '     * @return depositAmount\n', '     * @return startBlock\n', '     * @return kBlock\n', '     * @return remaining\n', '     * @return withdrawable\n', '     * @return unlockRatio\n', '     * @return lastRewardBlock\n', '     * @return cancelable\n', '     */\n', '    function getStream(uint256 streamId)\n', '        external\n', '        view\n', '        streamExists(streamId)\n', '        returns (\n', '            address sender,\n', '            address recipient,\n', '            address token,\n', '            uint256 depositAmount,\n', '            uint256 startBlock,\n', '            uint256 kBlock,\n', '            uint256 remaining,\n', '            uint256 withdrawable,\n', '            uint256 unlockRatio,\n', '            uint256 lastRewardBlock,\n', '            bool cancelable\n', '        )\n', '    {\n', '        Stream memory stream = streams[streamId];\n', '        sender = stream.sender;\n', '        recipient = stream.recipient;\n', '        token = stream.token;\n', '        depositAmount = stream.depositAmount;\n', '        startBlock = stream.startBlock;\n', '        kBlock = stream.kBlock;\n', '        remaining = stream.remaining;\n', '        withdrawable = stream.withdrawable;\n', '        unlockRatio = stream.unlockRatio;\n', '        lastRewardBlock = stream.lastRewardBlock;\n', '        cancelable = stream.cancelable;\n', '    }\n', '\n', '    /**\n', '     * @notice funds to an existing stream(for general purpose), \n', '     the amount of fund should be simply added to un-withdrawable.\n', '     * @dev Throws if the caller is not the stream.sender\n', '     * @param streamId The id of the stream to query.\n', '     * @param amount deposit amount by stream sender\n', '     */\n', '    function singleFundStream(uint256 streamId, uint256 amount)\n', '        external\n', '        payable\n', '        nonReentrant\n', '        streamExists(streamId)\n', '        returns (bool)\n', '    {\n', '        Stream storage stream = streams[streamId];\n', '        require(\n', '            msg.sender == stream.sender,\n', '            "caller must be the sender of the stream"\n', '        );\n', '        require(amount > effectiveValues[streamId], "amount not effective");\n', '        if (stream.token == AddressHelper.ethAddress()) {\n', '            require(amount == msg.value, "bad ether fund");\n', '        } else {\n', '            stream.token.safeTransferFrom(msg.sender, address(this), amount);\n', '        }\n', '\n', '        (uint256 withdrawable, uint256 remaining) = balanceOf(streamId);\n', '\n', '        // update remaining and withdrawable balance\n', '        stream.lastRewardBlock = block.number;\n', '        stream.remaining = remaining.add(amount); // = remaining + amount\n', '        stream.withdrawable = withdrawable; // = withdrawable\n', '\n', '        //add funds to total deposit amount\n', '        stream.depositAmount = stream.depositAmount.add(amount);\n', '        emit StreamFunded(streamId, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Implemented for XDEX farming and vesting,\n', '     * the amount of fund should be splited to withdrawable and un-withdrawable according to lastRewardBlock.\n', '     * @dev Throws if the caller is not the stream.sender\n', '     * @param streamId The id of the stream to query.\n', '     * @param amount deposit amount by stream sender\n', "     * @param blockHeightDiff diff of block.number and farmPool's lastRewardBlock\n", '     */\n', '    function lazyFundStream(\n', '        uint256 streamId,\n', '        uint256 amount,\n', '        uint256 blockHeightDiff\n', '    ) external payable nonReentrant streamExists(streamId) returns (bool) {\n', '        Stream storage stream = streams[streamId];\n', '        require(\n', '            msg.sender == stream.sender,\n', '            "caller must be the sender of the stream"\n', '        );\n', '        require(amount > effectiveValues[streamId], "amount not effective");\n', '        if (stream.token == AddressHelper.ethAddress()) {\n', '            require(amount == msg.value, "bad ether fund");\n', '        } else {\n', '            stream.token.safeTransferFrom(msg.sender, address(this), amount);\n', '        }\n', '\n', '        (uint256 withdrawable, uint256 remaining) = balanceOf(streamId);\n', '\n', '        //uint256 blockHeightDiff = block.number.sub(stream.lastRewardBlock);\n', '        // If underflow m might be 0, peg true kBlock to 1, if bHD 0 then error.\n', '        // Minimum amount is 100\n', '        uint256 m = amount.mul(ONE).div(blockHeightDiff);\n', '        // peg true kBlock to 1 so n over k always greater or equal 1\n', '        uint256 noverk = blockHeightDiff.mul(ONE);\n', '        // peg true mu to mu/kBlock\n', '        uint256 mu = stream.unlockRatio.mul(ONE).div(1000).div(stream.kBlock);\n', '        // Enlarged due to mu divided by kBlock\n', '        uint256 onesubmu = ONE.sub(mu);\n', '        // uint256 s = m.mul(ONE.sub(XNum.bpow(onesubmu,noverk))).div(ONE).div(mu).mul(ONE);\n', '        uint256 s =\n', '            m.mul(ONE.sub(XNum.bpow(onesubmu, noverk))).div(mu).div(ONE);\n', '\n', '        // update remaining and withdrawable balance\n', '        stream.lastRewardBlock = block.number;\n', '        stream.remaining = remaining.add(s); // = remaining + s\n', '        stream.withdrawable = withdrawable.add(amount).sub(s); // = withdrawable + (amount - s)\n', '\n', '        // add funds to total deposit amount\n', '        stream.depositAmount = stream.depositAmount.add(amount);\n', '        emit StreamFunded(streamId, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the available funds for the given stream id and address.\n', '     * @dev Throws if the id does not point to a valid stream.\n', '     * @param streamId The id of the stream for which to query the balance.\n', '     * @return withdrawable The total funds allocated to `recipient` and `sender` as uint256.\n', '     * @return remaining The total funds allocated to `recipient` and `sender` as uint256.\n', '     */\n', '    function balanceOf(uint256 streamId)\n', '        public\n', '        view\n', '        streamExists(streamId)\n', '        returns (uint256 withdrawable, uint256 remaining)\n', '    {\n', '        Stream memory stream = streams[streamId];\n', '\n', '        if (block.number < stream.startBlock) {\n', '            return (0, stream.depositAmount);\n', '        }\n', '\n', '        uint256 lastBalance = stream.withdrawable;\n', '\n', '        uint256 n =\n', '            block.number.sub(stream.lastRewardBlock).mul(ONE).div(\n', '                stream.kBlock\n', '            );\n', '        uint256 k = stream.unlockRatio.mul(ONE).div(1000);\n', '        uint256 mu = ONE.sub(k);\n', '        uint256 r = stream.remaining.mul(XNum.bpow(mu, n)).div(ONE);\n', '        uint256 w = stream.remaining.sub(r); // withdrawable, if n is float this process will be smooth and slightly\n', '\n', '        if (lastBalance > 0) {\n', '            w = w.add(lastBalance);\n', '        }\n', '\n', '        //If `remaining` + `withdrawable` < `depositAmount`, it means there have withdraws.\n', '        require(\n', '            r.add(w) <= stream.depositAmount,\n', '            "balanceOf: remaining or withdrawable amount is bad"\n', '        );\n', '\n', '        if (w >= effectiveValues[streamId]) {\n', '            withdrawable = w;\n', '        } else {\n', '            withdrawable = 0;\n', '        }\n', '\n', '        if (r >= effectiveValues[streamId]) {\n', '            remaining = r;\n', '        } else {\n', '            remaining = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @notice Withdraws from the contract to the recipient's account.\n", '     * @dev Throws if the id does not point to a valid stream.\n', '     *  Throws if the amount exceeds the withdrawable balance.\n', '     *  Throws if the amount < the effective withdraw value.\n', '     *  Throws if the caller is not the recipient.\n', '     * @param streamId The id of the stream to withdraw tokens from.\n', '     * @param amount The amount of tokens to withdraw.\n', '     * @return bool true=success, otherwise false.\n', '     */\n', '    function withdrawFromStream(uint256 streamId, uint256 amount)\n', '        external\n', '        nonReentrant\n', '        streamExists(streamId)\n', '        returns (bool)\n', '    {\n', '        Stream storage stream = streams[streamId];\n', '\n', '        require(\n', '            msg.sender == stream.recipient,\n', '            "caller must be the recipient of the stream"\n', '        );\n', '\n', '        require(\n', '            amount >= effectiveValues[streamId],\n', '            "amount is zero or not effective"\n', '        );\n', '\n', '        (uint256 withdrawable, uint256 remaining) = balanceOf(streamId);\n', '\n', '        require(\n', '            withdrawable >= amount,\n', '            "withdraw amount exceeds the available balance"\n', '        );\n', '\n', '        if (stream.token == AddressHelper.ethAddress()) {\n', '            stream.recipient.safeTransferEther(amount);\n', '        } else {\n', '            stream.token.safeTransfer(stream.recipient, amount);\n', '        }\n', '\n', '        stream.lastRewardBlock = block.number;\n', '        stream.remaining = remaining;\n', '        stream.withdrawable = withdrawable.sub(amount);\n', '\n', '        emit WithdrawFromStream(streamId, stream.recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Cancels the stream and transfers the tokens back\n', '     * @dev Throws if the id does not point to a valid stream.\n', '     *  Throws if the caller is not the sender or the recipient of the stream.\n', '     *  Throws if there is a token transfer failure.\n', '     * @param streamId The id of the stream to cancel.\n', '     * @return bool true=success, otherwise false.\n', '     */\n', '    function cancelStream(uint256 streamId)\n', '        external\n', '        nonReentrant\n', '        streamExists(streamId)\n', '        returns (bool)\n', '    {\n', '        Stream memory stream = streams[streamId];\n', '\n', '        require(stream.cancelable, "non cancelable stream");\n', '        require(\n', '            msg.sender == streams[streamId].sender ||\n', '                msg.sender == streams[streamId].recipient,\n', '            "caller must be the sender or the recipient"\n', '        );\n', '\n', '        (uint256 withdrawable, uint256 remaining) = balanceOf(streamId);\n', '\n', '        //save gas\n', '        delete streams[streamId];\n', '        delete effectiveValues[streamId];\n', '\n', '        if (withdrawable > 0) {\n', '            if (stream.token == AddressHelper.ethAddress()) {\n', '                stream.recipient.safeTransferEther(withdrawable);\n', '            } else {\n', '                stream.token.safeTransfer(stream.recipient, withdrawable);\n', '            }\n', '        }\n', '\n', '        if (remaining > 0) {\n', '            if (stream.token == AddressHelper.ethAddress()) {\n', '                stream.sender.safeTransferEther(remaining);\n', '            } else {\n', '                stream.token.safeTransfer(stream.sender, remaining);\n', '            }\n', '        }\n', '\n', '        emit StreamCanceled(\n', '            streamId,\n', '            stream.sender,\n', '            stream.recipient,\n', '            withdrawable,\n', '            remaining\n', '        );\n', '        return true;\n', '    }\n', '\n', '    function getVersion() external pure returns (bytes32) {\n', '        return bytes32("APOLLO");\n', '    }\n', '}']