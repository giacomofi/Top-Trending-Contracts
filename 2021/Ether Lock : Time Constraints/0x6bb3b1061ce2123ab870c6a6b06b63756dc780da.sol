['pragma solidity ^0.6.6;\n', '\n', "import './Ownable.sol';\n", "import './SafeMath.sol';\n", "import './ACOAssetHelper.sol';\n", "import './IACOToken.sol';\n", '\n', '\n', 'contract ACORewards is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 indexed pid, address indexed aco, uint256 reward);\n', '    event SetLPTokenAllocPoint(uint256 indexed pid, address indexed lpToken, uint256 allocPoint);\n', '\tevent SetCurrentReward(address indexed aco, uint256 rewardRate);\n', '\tevent WithdrawStuckToken(address indexed token, address indexed destination, uint256 amount);\n', '\t\n', '\tstruct CurrentRewardData {\n', '\t\taddress aco;               // Address of the ACO to be distributed.\n', '\t\tuint256 rewardRate;        // ACOs te be reward per second.\n', '\t}\n', '\t\n', '\tstruct PoolInfo {\n', '\t\taddress lpToken;           // Address of LP token contract.\n', '\t\tuint256 allocPoint;        // How many allocation points assigned to this LP token.\n', '\t}\n', '\t\n', '    struct ACORewardData {\n', '\t\tuint256 lastUpdateTime;    // Last timestamp that ACO distribution was updated.\n', '\t\tuint256 accRewardPerShare; // Accumulated ACO per share, times 1e18.\n', '\t}\n', '\t\n', '\tstruct UserACORewardData {\n', '\t\tuint256 pendingRewardStored;        // Pending reward stored.\n', '\t\tuint256 accAcoRewardPerShareStored; // Last accumulated ACO per share, times 1e18, since last user interaction with the SC.\n', '\t}\n', '\n', '\t// Total allocation poitns. Must be the sum of all allocation points in all pools.\n', '\tuint256 public totalAllocPoint;\n', '\t \n', '\t// The current reward data. See CurrentRewardData struct.\n', '\tCurrentRewardData public currentReward;\n', '\t\n', '\t// Info of each pool.\n', '    PoolInfo[] public poolInfo;\n', '\n', '    // Array with all ACOs used to reward and that it is still not expired.\n', '\taddress[] public acos;\n', '\t\n', '\t// LP token index => ACO => ACO reward data. See ACORewardData struct.\n', '\tmapping(uint256 => mapping(address => ACORewardData)) public acosRewardDataPerLP;\n', '\n', '\t// LP token index => User => How many LP tokens the user has provided.\n', '    mapping(uint256 => mapping(address => uint256)) public balanceOf;\n', '\t\n', '\t// LP token index => User => ACO => User reward data. See UserACORewardData struct.\n', '    mapping(uint256 => mapping(address => mapping(address => UserACORewardData))) public usersAcoRewardData; \n', '    \n', '    constructor() public {\n', '        super.init();\n', '    }\n', '    \n', '    ////////////////////// VIEW FUNCTIONS //////////////////////\n', '    \n', '    function poolLength() external view returns(uint256) {\n', '        return poolInfo.length;\n', '    }\n', '    \n', '    function acosLength() external view returns(uint256) {\n', '        return acos.length;\n', '    }\n', '    \n', '    // External function to be used on the front-end to list the pending ACOs rewards for an account and a LP token. \n', '    function pendingReward(uint256 _pid, address account) external view returns (address[] memory _acos, uint256[] memory _amounts) {\n', '        PoolInfo storage info = poolInfo[_pid];\n', '\t\tuint256 share = balanceOf[_pid][account];\n', '        uint256 totalLPSupply = ACOAssetHelper._getAssetBalanceOf(info.lpToken, address(this));\n', '        \n', '        uint256 qty = 0;\n', '        for (uint256 i = 0; i < acos.length; ++i) {\n', '            uint256 pending = _getPendingReward(\n', '                _pid,\n', '\t\t\t\tinfo.allocPoint, \n', '\t            totalLPSupply,\n', '\t            account,\n', '\t            share,\n', '\t            acos[i]);\n', '                \n', '            if (pending > 0) {\n', '                ++qty;\n', '            }\n', '        }\n', '        \n', '        _acos = new address[](qty);\n', '        _amounts = new uint256[](qty);\n', '        \n', '\t\tif (qty > 0) {\n', '\t\t\tuint256 index = 0;\n', '\t\t\tfor (uint256 i = 0; i < acos.length; ++i) {\n', '\t\t\t\tuint256 pending = _getPendingReward(\n', '\t\t\t\t\t_pid,\n', '\t\t\t\t\tinfo.allocPoint,\n', '\t\t\t\t\ttotalLPSupply,\n', '\t\t\t\t\taccount,\n', '\t\t\t\t\tshare,\n', '\t\t\t\t\tacos[i]);\n', '\t\t\t\t\t\n', '\t\t\t\tif (pending > 0) {\n', '\t\t\t\t\t_acos[index] = acos[i];\n', '\t\t\t\t\t_amounts[index] = pending;\n', '\t\t\t\t\t++index;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '    }\n', '    \n', '    ////////////////////// USERS FUNCTIONS //////////////////////\n', '\n', '    function deposit(uint256 _pid, uint256 amount) external {\n', '\t\tCurrentRewardData storage _currentReward = currentReward;\n', '\t\tPoolInfo storage info = poolInfo[_pid];\n', '\t\trequire(info.allocPoint > 0 && _currentReward.rewardRate > 0, "LP token is forbidden");\n', '        require(amount > 0, "Invalid amount");\n', '\t\t\n', '\t\t_setCurrentAcoRewardAccPerShare(_pid, _currentReward);\n', '\t\t_getUserAcoReward(_pid, true); // Claim available rewards.\n', '\n', '\t\tACOAssetHelper._callTransferFromERC20(info.lpToken, msg.sender, address(this), amount);\n', '\n', '        balanceOf[_pid][msg.sender] = amount.add(balanceOf[_pid][msg.sender]);\n', '        \n', '        emit Deposit(msg.sender, _pid, amount);\n', '    }\n', '\n', '    function withdraw(uint256 _pid, uint256 amount) external {\n', '\t\tuint256 totalUserBalance = balanceOf[_pid][msg.sender];\n', '        require(amount > 0 && totalUserBalance >= amount, "Invalid amount");\n', '\n', '\t\t_setCurrentAcoRewardAccPerShare(_pid, currentReward);\n', '\t\t_getUserAcoReward(_pid, true); // Claim available rewards.\n', '\t\t\n', '        balanceOf[_pid][msg.sender] = totalUserBalance.sub(amount);\n', '        \n', '        ACOAssetHelper._callTransferERC20(poolInfo[_pid].lpToken, msg.sender, amount);\n', '        \n', '\t\temit Withdraw(msg.sender, _pid, amount);\n', '    }\n', '\n', '    function claimReward(uint256 _pid) public {\n', '\t\tPoolInfo storage info = poolInfo[_pid];\n', '        require(info.lpToken != address(0), "Invalid LP token");\n', '\t\t\n', '\t\t_setCurrentAcoRewardAccPerShare(_pid, currentReward);\n', '\t\t_getUserAcoReward(_pid, false);\n', '    }\n', '\n', '\tfunction claimRewards(uint256[] calldata _pids) external {\n', '\t\tfor (uint256 i = 0; i < _pids.length; ++i) {\n', '\t\t\tclaimReward(_pids[i]);\n', '\t\t}\n', '    }\n', '\t\n', '\t// Withdraw without caring about rewards. EMERGENCY ONLY!\n', '    function emergencyWithdraw(uint256 _pid) external {\n', '        uint256 totalUserBalance = balanceOf[_pid][msg.sender];\n', '        require(totalUserBalance > 0, "No balance");\n', '\n', '\t\t_setCurrentAcoRewardAccPerShare(_pid, currentReward);\n', '\n', '\t\tbalanceOf[_pid][msg.sender] = 0;\n', '        ACOAssetHelper._callTransferERC20(poolInfo[_pid].lpToken, msg.sender, totalUserBalance);\n', '\n', '        emit EmergencyWithdraw(msg.sender, _pid, totalUserBalance);\n', '    }\n', '    \n', '    ////////////////////// INTERNAL FUNCTIONS //////////////////////\n', '\t\n', '\t/*\n', '\t * Calculate the pending rewards and transfers them to the user.\n', '\t * The math is basically, any point in time, the amount of ACOs entitled to a user but is pending to be distributed is:\n', '     *\n', '     * pending reward = user.share * (aco.accRewardPerShare - user.AccAcoRewardPerShareStored)\n', '     *\n', '     * Whenever a user deposit or withdraws for a LP token or even a reward claim:\n', '     *  1. The current ACOs accRewardPerShare and `lastUpdateTime get updated. `_setCurrentAcoRewardAccPerShare` function.\n', '     *  2. User receives the pending reward sent to his/her address.\n', '     *  3. userAccAcoRewardPerShareStored gets updated with the current ACO accRewardPerShare.\n', '\t */\n', '\tfunction _getUserAcoReward(uint256 _pid, bool ignoreIfNoBalance) internal {\n', '\t\tuint256 share = balanceOf[_pid][msg.sender];\n', '\t\tfor (uint256 i = acos.length; i > 0; --i) {\n', '\t\t\taddress aco = acos[i - 1];\n', '\t\t\t\n', '\t\t\tif (IACOToken(aco).expiryTime() <= block.timestamp) { // ACO is expired.\n', '\t\t\t\t_removeAco(i - 1);\n', '\t\t\t} else {\n', '\t\t\t\tuint256 acoAccRewardPerShare = acosRewardDataPerLP[_pid][aco].accRewardPerShare;\n', '\t\t\t\t\n', '\t\t\t\tUserACORewardData storage userAcoRewardData = usersAcoRewardData[_pid][msg.sender][aco];\n', '\t\t\t\t\n', '\t\t\t\tuint256 pending = _earned(share, acoAccRewardPerShare, userAcoRewardData.accAcoRewardPerShareStored);\n', '\t\t\t\tpending = pending.add(userAcoRewardData.pendingRewardStored);\n', '\n', '\t\t\t\tuserAcoRewardData.pendingRewardStored = pending;\n', '\t\t\t\tuserAcoRewardData.accAcoRewardPerShareStored = acoAccRewardPerShare;\n', '\t\t\t\t\n', '\t\t\t\tif (pending > 0) {\n', '\t\t\t\t    // If for some reason the current ACO on the SC has not enough balance, the respective reward could be skipped to be paid later and this way avoids an error. (This is true on withdraw and deposit).\n', '\t\t\t\t    if (ignoreIfNoBalance) {\n', '\t\t\t\t        uint256 acoBalance = ACOAssetHelper._getAssetBalanceOf(aco, address(this));\n', '\t\t\t\t        if (acoBalance < pending) {\n', '\t\t\t\t            continue;\n', '\t\t\t\t        }\n', '\t\t\t\t    }\n', '\n', '\t\t\t\t    userAcoRewardData.pendingRewardStored = 0; // All ACO reward was paid.\n', '\t\t\t\t\tACOAssetHelper._callTransferERC20(aco, msg.sender, pending);\n', '\t\t\t\t\temit RewardPaid(msg.sender, _pid, aco, pending);\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\t\n', '\t// Update the current ACO accRewardPerShare and lastUpdateTime for the active LP token.\n', '\tfunction _setCurrentAcoRewardAccPerShare(uint256 _pid, CurrentRewardData storage _currentReward) internal {\n', '\t\tPoolInfo storage info = poolInfo[_pid];\n', '\t\tif (info.allocPoint > 0) {\n', '\t\t\tuint256 totalLPSupply = ACOAssetHelper._getAssetBalanceOf(info.lpToken, address(this));\n', '\t\t\tACORewardData storage currentAcoData = acosRewardDataPerLP[_pid][_currentReward.aco];\n', '\t\t\tcurrentAcoData.accRewardPerShare = _getAccRewardPerAco(totalLPSupply, info.allocPoint, _currentReward.aco, _currentReward.rewardRate, _currentReward.aco, currentAcoData);\n', '\t\t\tcurrentAcoData.lastUpdateTime = block.timestamp;\n', '\t\t}\n', '\t}\n', '\t\n', '\t/*\n', '\t * Get the accumulated reward per share for an ACO.\n', '\t * For the current ACO rewarding: \n', '\t * previous accRewardPerShare + [rewardRate * (now - lastUpdateTime) * lpAllocPoint / totalAllocPoint] * 1e18 / totalSupply\n', '\t * lpAllocPoint / totalAllocPoint is to get the weight for the respective LP token on the ACO reward.\n', '\t * The value is multiplied by 1e18 for no losing precision. Hereafter it will be divided by 1e18.\n', '\t */\n', '\tfunction _getAccRewardPerAco(\n', '\t\tuint256 totalSupply,\n', '\t\tuint256\tallocPoint,\t\n', '\t\taddress currentAco, \n', '\t\tuint256 currentAcoRewardRate,\n', '\t\taddress aco, \n', '\t\tACORewardData storage acoRewardData\n', '\t) internal view returns (uint256) {\n', '        if (currentAco != aco || totalSupply == 0 || allocPoint == 0 || currentAcoRewardRate == 0) {\n', '            return acoRewardData.accRewardPerShare;\n', '        } else {\n', '\t\t\tuint256 acoReward = block.timestamp.sub(acoRewardData.lastUpdateTime).mul(currentAcoRewardRate).mul(allocPoint).div(totalAllocPoint);\n', '\t\t\treturn acoReward.mul(1e18).div(totalSupply).add(acoRewardData.accRewardPerShare);\n', '\t\t}\n', '    }\n', '\t\n', '\t// user.share * (aco.accRewardPerShare - user.accAcoRewardPerShareStored) / 1e18 (the division per 1e18 is because all "per share" data is multiplied by 1e18)\n', '\tfunction _earned(\n', '\t\tuint256 accountShare, \n', '\t\tuint256 acoAccRewardPerShare,\n', '\t\tuint256 userAccAcoRewardPerShareStored\n', '\t) internal pure returns (uint256) {\n', '        return accountShare.mul(acoAccRewardPerShare.sub(userAccAcoRewardPerShareStored)).div(1e18);\n', '    }\n', '\t\n', '\t/*\n', '\t * To remove an expired ACO that expired condition already was checked.\n', '\t * Useful to save gas on next txs.\n', '\t */\n', '\tfunction _removeAco(uint256 acoIndex) internal {\n', '\t\tuint256 lastIndex = acos.length - 1;\n', '\t\tif (lastIndex != acoIndex) {\n', '\t\t\taddress last = acos[lastIndex];\n', '\t\t\tacos[acoIndex] = last;\n', '\t\t}\n', '\t\tacos.pop();\n', '\t}\n', '\t\n', '\t// Used only on the pending reward external view function.\n', '\tfunction _getPendingReward(\n', '\t    uint256 _pid, \n', '\t\tuint256 allocPoint,\n', '\t    uint256 totalLPSupply,\n', '\t    address account,\n', '\t    uint256 accountShare,\n', '\t    address aco\n', '    ) internal view returns(uint256 pending) {\n', '\t    pending = 0;\n', '\t    if (IACOToken(aco).expiryTime() > block.timestamp) {\n', '                \n', '    \t    uint256 accRewardPerShare = _getAccRewardPerAco(\n', '    \t        totalLPSupply, \n', '    \t        allocPoint, \n', '    \t        currentReward.aco, \n', '    \t        currentReward.rewardRate, \n', '    \t        aco, \n', '    \t        acosRewardDataPerLP[_pid][aco]\n', '            );\n', '            \n', '            UserACORewardData storage userAcoRewardData = usersAcoRewardData[_pid][account][aco];\n', '\t\t\tpending = _earned(accountShare, accRewardPerShare, userAcoRewardData.accAcoRewardPerShareStored);\n', '\t\t\tpending = pending.add(userAcoRewardData.pendingRewardStored);\n', '        }\n', '\t}\n', '\t\n', '\t////////////////////// PUBLIC FUNCTIONS //////////////////////\n', '\t\n', '\t\n', '\t// Update all accumulated per share value for the current ACO rewarding on all active LP tokens.\n', '\tfunction setAllLPTokensCurrentAcoRewardAccPerShare() internal {\n', '\t\tCurrentRewardData storage _currentReward = currentReward;\n', '\t\tfor (uint256 i = 0; i < poolInfo.length; ++i) {\n', '\t\t\t_setCurrentAcoRewardAccPerShare(i, _currentReward);\n', '\t\t}\n', '\t}\n', '\n', '    // Remove expired ACOs from the array. To save gas on the next txs.\n', '\tfunction setValidAcos() public {\n', '\t\tfor (uint256 i = acos.length; i > 0; --i) {\n', '            address aco = acos[i - 1];\n', '\t\t\tif (IACOToken(aco).expiryTime() <= block.timestamp) {\n', '\t\t\t\t_removeAco(i - 1);\n', '\t\t\t}\n', '        }\n', '\t}\n', '\t\n', '\t////////////////////// ADMIN FUNCTIONS //////////////////////\n', '\n', '    /*\n', '\t * Function to the admin sets new LP tokens or change the allocation points.\n', '\t * When an allocation point is set to zero the respective LP token is inactivated.\n', '\t * If the LP token is inactived there is no reward and the respective deposit is also forbidden.\n', '\t * However, withdrawals and previous rewards claims keep working.\n', '\t */\n', '\tfunction setLPTokens(address[] calldata lpTokens, uint256[] calldata allocPoints) external onlyOwner {\n', '\t\trequire(lpTokens.length == allocPoints.length, "Invalid arguments");\n', '\t\t\n', '\t\tsetAllLPTokensCurrentAcoRewardAccPerShare();\n', '\t\tsetValidAcos();\n', '\t\t\n', '\t\taddress _currentAco = currentReward.aco;\n', '\t\tfor (uint256 i = 0; i < lpTokens.length; ++i) {\n', '\t\t\trequire(allocPoints[i] <= 1e18, "Invalid alloc point"); // To avoid overflow.\n', '\n', '\t\t\tbool isNew = true;\n', '\t\t\tuint256 _pid;\n', '\t\t\tfor (uint256 j = 0; j < poolInfo.length; ++j) {\n', '\n', '\t\t\t\tPoolInfo storage info = poolInfo[j];\n', '\t\t\t\tif (info.lpToken == lpTokens[i]) {\n', '\t\t\t\t\t_pid = j;\n', '\t\t\t\t\ttotalAllocPoint = totalAllocPoint.sub(info.allocPoint).add(allocPoints[i]);\n', '\t\t\t\t\tinfo.allocPoint = allocPoints[i];\n', '\t\t\t\t\tisNew = false;\n', '\t\t\t\t\tbreak;\n', '\t\t\t\t}\n', '\t\t\t}\n', '\t\t\tif (isNew) { // It is new LP token.\n', '\t\t\t\t_pid = poolInfo.length;\n', '\t\t\t\tpoolInfo.push(PoolInfo(lpTokens[i], allocPoints[i]));\n', '\t\t\t\ttotalAllocPoint = totalAllocPoint.add(allocPoints[i]);\n', '\t\t\t}\n', '\n', '\t\t\t// Sets the current ACO timestamp as "now" for the new LP token configuration.\n', '\t\t\tacosRewardDataPerLP[_pid][_currentAco].lastUpdateTime = block.timestamp;\n', '\n', '\t\t\temit SetLPTokenAllocPoint(_pid, lpTokens[i], allocPoints[i]);\n', '\t\t}\n', '\t}\n', '\t\n', '\t/*\n', '\t * Function to the admin sets the ACO to the current reward.\n', '\t * The rewardRate is ACO per second.\n', '\t */\n', '\tfunction setCurrentReward(address aco, uint256 rewardRate) external onlyOwner {\n', '\t\trequire(rewardRate <= 1e40, "The reward rate is too big"); // To avoid overflow.\n', '\n', '\t\tsetAllLPTokensCurrentAcoRewardAccPerShare();\n', '\t\tsetValidAcos();\n', '\t\t\n', '\t\tbool isNew = true;\n', '\t\tfor (uint256 i = 0; i < acos.length; ++i) {\n', '\t\t\tif (acos[i] == aco) {\n', '\t\t\t\tisNew = false;\n', '\t\t\t\tbreak;\n', '\t\t\t}\n', '\t\t}\n', '\t\tif (isNew) {\n', '\t\t\tacos.push(aco);\n', '\t\t}\n', '\t\t\n', '\t\tCurrentRewardData storage _currentReward = currentReward;\n', '\t\t_currentReward.aco = aco;\n', '\t\t_currentReward.rewardRate = rewardRate;\n', '\t\t\n', '\t\t/*\n', '\t\t * Set the lastUpdateTime as now for all active LP tokens.\n', '\t\t * This timestamp is used to calculate the accumulated per share value.\n', '\t\t * So new current ACO timestamp is set for all LP tokens as "now".\n', '\t\t */\n', '\t\tfor (uint256 i = 0; i < poolInfo.length; ++i) {\n', '\t\t\tif (poolInfo[i].allocPoint > 0) {\n', '\t\t\t\tacosRewardDataPerLP[i][aco].lastUpdateTime = block.timestamp;\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\temit SetCurrentReward(aco, rewardRate);\n', '\t}\n', '\t\n', '\t/*\n', '\t * Function to the admin withdraws a stuck token if necessary. \n', '\t * For example, an ACO rewarded and that is not being used anymore.\n', '\t * Withdraw any LP token is FORBIDDEN.\n', '\t */\n', '    function withdrawStuckToken(address token, uint256 amount, address destination) external onlyOwner {\n', '\t\t// To guarantee the deny for withdrawing a LP token.\n', '\t\tfor (uint256 i = 0; i < poolInfo.length; ++i) {\n', '\t\t\trequire(poolInfo[i].lpToken != token, "Forbidden!");\n', '\t\t}\n', '\t\t\n', '\t\tuint256 tokenBalance = ACOAssetHelper._getAssetBalanceOf(token, address(this));\n', '\t\tif (amount > tokenBalance) {\n', '\t\t\tamount = tokenBalance;\n', '\t\t}\n', '\t\tif (amount > 0) {\n', '\t\t    ACOAssetHelper._callTransferERC20(token, destination, amount);\n', '\t\t\temit WithdrawStuckToken(token, destination, amount);\n', '\t\t}\n', '    }\n', '}']