['// SPDX-License-Identifier: AGPL-3.0-or-later\n', '\n', 'pragma solidity ^0.7.0;\n', '\n', '\n', 'import "IERC900History.sol";\n', 'import "Issuer.sol";\n', 'import "Bits.sol";\n', 'import "Snapshot.sol";\n', 'import "SafeMath.sol";\n', 'import "SafeERC20.sol";\n', '\n', '\n', '/**\n', '* @notice PolicyManager interface\n', '*/\n', 'interface PolicyManagerInterface {\n', '    function secondsPerPeriod() external view returns (uint32);\n', '    function register(address _node, uint16 _period) external;\n', '    function migrate(address _node) external;\n', '    function ping(\n', '        address _node,\n', '        uint16 _processedPeriod1,\n', '        uint16 _processedPeriod2,\n', '        uint16 _periodToSetDefault\n', '    ) external;\n', '}\n', '\n', '\n', '/**\n', '* @notice Adjudicator interface\n', '*/\n', 'interface AdjudicatorInterface {\n', '    function rewardCoefficient() external view returns (uint32);\n', '}\n', '\n', '\n', '/**\n', '* @notice WorkLock interface\n', '*/\n', 'interface WorkLockInterface {\n', '    function token() external view returns (NuCypherToken);\n', '}\n', '\n', '/**\n', '* @title StakingEscrowStub\n', '* @notice Stub is used to deploy main StakingEscrow after all other contract and make some variables immutable\n', '* @dev |v1.0.0|\n', '*/\n', 'contract StakingEscrowStub is Upgradeable {\n', '    using AdditionalMath for uint32;\n', '\n', '    NuCypherToken public immutable token;\n', '    uint32 public immutable genesisSecondsPerPeriod;\n', '    uint32 public immutable secondsPerPeriod;\n', '    uint16 public immutable minLockedPeriods;\n', '    uint256 public immutable minAllowableLockedTokens;\n', '    uint256 public immutable maxAllowableLockedTokens;\n', '\n', '    /**\n', '    * @notice Predefines some variables for use when deploying other contracts\n', '    * @param _token Token contract\n', '    * @param _genesisHoursPerPeriod Size of period in hours at genesis\n', '    * @param _hoursPerPeriod Size of period in hours\n', '    * @param _minLockedPeriods Min amount of periods during which tokens can be locked\n', '    * @param _minAllowableLockedTokens Min amount of tokens that can be locked\n', '    * @param _maxAllowableLockedTokens Max amount of tokens that can be locked\n', '    */\n', '    constructor(\n', '        NuCypherToken _token,\n', '        uint32 _genesisHoursPerPeriod,\n', '        uint32 _hoursPerPeriod,\n', '        uint16 _minLockedPeriods,\n', '        uint256 _minAllowableLockedTokens,\n', '        uint256 _maxAllowableLockedTokens\n', '    ) {\n', '        require(_token.totalSupply() > 0 &&\n', '            _hoursPerPeriod != 0 &&\n', '            _genesisHoursPerPeriod != 0 &&\n', '            _genesisHoursPerPeriod <= _hoursPerPeriod &&\n', '            _minLockedPeriods > 1 &&\n', '            _maxAllowableLockedTokens != 0);\n', '\n', '        token = _token;\n', '        secondsPerPeriod = _hoursPerPeriod.mul32(1 hours);\n', '        genesisSecondsPerPeriod = _genesisHoursPerPeriod.mul32(1 hours);\n', '        minLockedPeriods = _minLockedPeriods;\n', '        minAllowableLockedTokens = _minAllowableLockedTokens;\n', '        maxAllowableLockedTokens = _maxAllowableLockedTokens;\n', '    }\n', '\n', '    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\n', '    function verifyState(address _testTarget) public override virtual {\n', '        super.verifyState(_testTarget);\n', '\n', '        // we have to use real values even though this is a stub\n', '        require(address(delegateGet(_testTarget, this.token.selector)) == address(token));\n', '        // TODO uncomment after merging this PR #2579\n', '//        require(uint32(delegateGet(_testTarget, this.genesisSecondsPerPeriod.selector)) == genesisSecondsPerPeriod);\n', '        require(uint32(delegateGet(_testTarget, this.secondsPerPeriod.selector)) == secondsPerPeriod);\n', '        require(uint16(delegateGet(_testTarget, this.minLockedPeriods.selector)) == minLockedPeriods);\n', '        require(delegateGet(_testTarget, this.minAllowableLockedTokens.selector) == minAllowableLockedTokens);\n', '        require(delegateGet(_testTarget, this.maxAllowableLockedTokens.selector) == maxAllowableLockedTokens);\n', '    }\n', '}\n', '\n', '\n', '/**\n', '* @title StakingEscrow\n', '* @notice Contract holds and locks stakers tokens.\n', '* Each staker that locks their tokens will receive some compensation\n', '* @dev |v5.7.1|\n', '*/\n', 'contract StakingEscrow is Issuer, IERC900History {\n', '\n', '    using AdditionalMath for uint256;\n', '    using AdditionalMath for uint16;\n', '    using Bits for uint256;\n', '    using SafeMath for uint256;\n', '    using Snapshot for uint128[];\n', '    using SafeERC20 for NuCypherToken;\n', '\n', '    /**\n', '    * @notice Signals that tokens were deposited\n', '    * @param staker Staker address\n', '    * @param value Amount deposited (in NuNits)\n', '    * @param periods Number of periods tokens will be locked\n', '    */\n', '    event Deposited(address indexed staker, uint256 value, uint16 periods);\n', '\n', '    /**\n', '    * @notice Signals that tokens were stake locked\n', '    * @param staker Staker address\n', '    * @param value Amount locked (in NuNits)\n', '    * @param firstPeriod Starting lock period\n', '    * @param periods Number of periods tokens will be locked\n', '    */\n', '    event Locked(address indexed staker, uint256 value, uint16 firstPeriod, uint16 periods);\n', '\n', '    /**\n', '    * @notice Signals that a sub-stake was divided\n', '    * @param staker Staker address\n', '    * @param oldValue Old sub-stake value (in NuNits)\n', '    * @param lastPeriod Final locked period of old sub-stake\n', '    * @param newValue New sub-stake value (in NuNits)\n', '    * @param periods Number of periods to extend sub-stake\n', '    */\n', '    event Divided(\n', '        address indexed staker,\n', '        uint256 oldValue,\n', '        uint16 lastPeriod,\n', '        uint256 newValue,\n', '        uint16 periods\n', '    );\n', '\n', '    /**\n', '    * @notice Signals that two sub-stakes were merged\n', '    * @param staker Staker address\n', '    * @param value1 Value of first sub-stake (in NuNits)\n', '    * @param value2 Value of second sub-stake (in NuNits)\n', '    * @param lastPeriod Final locked period of merged sub-stake\n', '    */\n', '    event Merged(address indexed staker, uint256 value1, uint256 value2, uint16 lastPeriod);\n', '\n', '    /**\n', '    * @notice Signals that a sub-stake was prolonged\n', '    * @param staker Staker address\n', '    * @param value Value of sub-stake\n', '    * @param lastPeriod Final locked period of old sub-stake\n', '    * @param periods Number of periods sub-stake was extended\n', '    */\n', '    event Prolonged(address indexed staker, uint256 value, uint16 lastPeriod, uint16 periods);\n', '\n', '    /**\n', '    * @notice Signals that tokens were withdrawn to the staker\n', '    * @param staker Staker address\n', '    * @param value Amount withdraws (in NuNits)\n', '    */\n', '    event Withdrawn(address indexed staker, uint256 value);\n', '\n', '    /**\n', '    * @notice Signals that the worker associated with the staker made a commitment to next period\n', '    * @param staker Staker address\n', '    * @param period Period committed to\n', '    * @param value Amount of tokens staked for the committed period\n', '    */\n', '    event CommitmentMade(address indexed staker, uint16 indexed period, uint256 value);\n', '\n', '    /**\n', '    * @notice Signals that tokens were minted for previous periods\n', '    * @param staker Staker address\n', '    * @param period Previous period tokens minted for\n', '    * @param value Amount minted (in NuNits)\n', '    */\n', '    event Minted(address indexed staker, uint16 indexed period, uint256 value);\n', '\n', '    /**\n', '    * @notice Signals that the staker was slashed\n', '    * @param staker Staker address\n', '    * @param penalty Slashing penalty\n', '    * @param investigator Investigator address\n', '    * @param reward Value of reward provided to investigator (in NuNits)\n', '    */\n', '    event Slashed(address indexed staker, uint256 penalty, address indexed investigator, uint256 reward);\n', '\n', '    /**\n', '    * @notice Signals that the restake parameter was activated/deactivated\n', '    * @param staker Staker address\n', '    * @param reStake Updated parameter value\n', '    */\n', '    event ReStakeSet(address indexed staker, bool reStake);\n', '\n', '    /**\n', '    * @notice Signals that a worker was bonded to the staker\n', '    * @param staker Staker address\n', '    * @param worker Worker address\n', '    * @param startPeriod Period bonding occurred\n', '    */\n', '    event WorkerBonded(address indexed staker, address indexed worker, uint16 indexed startPeriod);\n', '\n', '    /**\n', '    * @notice Signals that the winddown parameter was activated/deactivated\n', '    * @param staker Staker address\n', '    * @param windDown Updated parameter value\n', '    */\n', '    event WindDownSet(address indexed staker, bool windDown);\n', '\n', '    /**\n', '    * @notice Signals that the snapshot parameter was activated/deactivated\n', '    * @param staker Staker address\n', '    * @param snapshotsEnabled Updated parameter value\n', '    */\n', '    event SnapshotSet(address indexed staker, bool snapshotsEnabled);\n', '\n', '    /**\n', '    * @notice Signals that the staker migrated their stake to the new period length\n', '    * @param staker Staker address\n', '    * @param period Period when migration happened\n', '    */\n', '    event Migrated(address indexed staker, uint16 indexed period);\n', '\n', '    /// internal event\n', '    event WorkMeasurementSet(address indexed staker, bool measureWork);\n', '\n', '    struct SubStakeInfo {\n', '        uint16 firstPeriod;\n', '        uint16 lastPeriod;\n', '        uint16 unlockingDuration;\n', '        uint128 lockedValue;\n', '    }\n', '\n', '    struct Downtime {\n', '        uint16 startPeriod;\n', '        uint16 endPeriod;\n', '    }\n', '\n', '    struct StakerInfo {\n', '        uint256 value;\n', '        /*\n', '        * Stores periods that are committed but not yet rewarded.\n', '        * In order to optimize storage, only two values are used instead of an array.\n', '        * commitToNextPeriod() method invokes mint() method so there can only be two committed\n', '        * periods that are not yet rewarded: the current and the next periods.\n', '        */\n', '        uint16 currentCommittedPeriod;\n', '        uint16 nextCommittedPeriod;\n', '        uint16 lastCommittedPeriod;\n', '        uint16 stub1; // former slot for lockReStakeUntilPeriod\n', '        uint256 completedWork;\n', '        uint16 workerStartPeriod; // period when worker was bonded\n', '        address worker;\n', '        uint256 flags; // uint256 to acquire whole slot and minimize operations on it\n', '\n', '        uint256 reservedSlot1;\n', '        uint256 reservedSlot2;\n', '        uint256 reservedSlot3;\n', '        uint256 reservedSlot4;\n', '        uint256 reservedSlot5;\n', '\n', '        Downtime[] pastDowntime;\n', '        SubStakeInfo[] subStakes;\n', '        uint128[] history;\n', '\n', '    }\n', '\n', '    // used only for upgrading\n', '    uint16 internal constant RESERVED_PERIOD = 0;\n', '    uint16 internal constant MAX_CHECKED_VALUES = 5;\n', '    // to prevent high gas consumption in loops for slashing\n', '    uint16 public constant MAX_SUB_STAKES = 30;\n', '    uint16 internal constant MAX_UINT16 = 65535;\n', '\n', '    // indices for flags\n', '    uint8 internal constant RE_STAKE_DISABLED_INDEX = 0;\n', '    uint8 internal constant WIND_DOWN_INDEX = 1;\n', '    uint8 internal constant MEASURE_WORK_INDEX = 2;\n', '    uint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;\n', '    uint8 internal constant MIGRATED_INDEX = 4;\n', '\n', '    uint16 public immutable minLockedPeriods;\n', '    uint16 public immutable minWorkerPeriods;\n', '    uint256 public immutable minAllowableLockedTokens;\n', '    uint256 public immutable maxAllowableLockedTokens;\n', '\n', '    PolicyManagerInterface public immutable policyManager;\n', '    AdjudicatorInterface public immutable adjudicator;\n', '    WorkLockInterface public immutable workLock;\n', '\n', '    mapping (address => StakerInfo) public stakerInfo;\n', '    address[] public stakers;\n', '    mapping (address => address) public stakerFromWorker;\n', '\n', '    mapping (uint16 => uint256) stub4; // former slot for lockedPerPeriod\n', '    uint128[] public balanceHistory;\n', '\n', '    address stub1; // former slot for PolicyManager\n', '    address stub2; // former slot for Adjudicator\n', '    address stub3; // former slot for WorkLock\n', '\n', '    mapping (uint16 => uint256) _lockedPerPeriod;\n', '    // only to make verifyState from previous version work, temporary\n', '    // TODO remove after upgrade #2579\n', '    function lockedPerPeriod(uint16 _period) public view returns (uint256) {\n', '        return _period != RESERVED_PERIOD ? _lockedPerPeriod[_period] : 111;\n', '    }\n', '\n', '    /**\n', '    * @notice Constructor sets address of token contract and coefficients for minting\n', '    * @param _token Token contract\n', '    * @param _policyManager Policy Manager contract\n', '    * @param _adjudicator Adjudicator contract\n', '    * @param _workLock WorkLock contract. Zero address if there is no WorkLock\n', '    * @param _genesisHoursPerPeriod Size of period in hours at genesis\n', '    * @param _hoursPerPeriod Size of period in hours\n', '    * @param _issuanceDecayCoefficient (d) Coefficient which modifies the rate at which the maximum issuance decays,\n', '    * only applicable to Phase 2. d = 365 * half-life / LOG2 where default half-life = 2.\n', '    * See Equation 10 in Staking Protocol & Economics paper\n', '    * @param _lockDurationCoefficient1 (k1) Numerator of the coefficient which modifies the extent\n', "    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.\n", '    * Applicable to Phase 1 and Phase 2. k1 = k2 * small_stake_multiplier where default small_stake_multiplier = 0.5.\n', '    * See Equation 8 in Staking Protocol & Economics paper.\n', '    * @param _lockDurationCoefficient2 (k2) Denominator of the coefficient which modifies the extent\n', "    * to which a stake's lock duration affects the subsidy it receives. Affects stakers differently.\n", '    * Applicable to Phase 1 and Phase 2. k2 = maximum_rewarded_periods / (1 - small_stake_multiplier)\n', '    * where default maximum_rewarded_periods = 365 and default small_stake_multiplier = 0.5.\n', '    * See Equation 8 in Staking Protocol & Economics paper.\n', "    * @param _maximumRewardedPeriods (kmax) Number of periods beyond which a stake's lock duration\n", '    * no longer increases the subsidy it receives. kmax = reward_saturation * 365 where default reward_saturation = 1.\n', '    * See Equation 8 in Staking Protocol & Economics paper.\n', '    * @param _firstPhaseTotalSupply Total supply for the first phase\n', '    * @param _firstPhaseMaxIssuance (Imax) Maximum number of new tokens minted per period during Phase 1.\n', '    * See Equation 7 in Staking Protocol & Economics paper.\n', '    * @param _minLockedPeriods Min amount of periods during which tokens can be locked\n', '    * @param _minAllowableLockedTokens Min amount of tokens that can be locked\n', '    * @param _maxAllowableLockedTokens Max amount of tokens that can be locked\n', "    * @param _minWorkerPeriods Min amount of periods while a worker can't be changed\n", '    */\n', '    constructor(\n', '        NuCypherToken _token,\n', '        PolicyManagerInterface _policyManager,\n', '        AdjudicatorInterface _adjudicator,\n', '        WorkLockInterface _workLock,\n', '        uint32 _genesisHoursPerPeriod,\n', '        uint32 _hoursPerPeriod,\n', '        uint256 _issuanceDecayCoefficient,\n', '        uint256 _lockDurationCoefficient1,\n', '        uint256 _lockDurationCoefficient2,\n', '        uint16 _maximumRewardedPeriods,\n', '        uint256 _firstPhaseTotalSupply,\n', '        uint256 _firstPhaseMaxIssuance,\n', '        uint16 _minLockedPeriods,\n', '        uint256 _minAllowableLockedTokens,\n', '        uint256 _maxAllowableLockedTokens,\n', '        uint16 _minWorkerPeriods\n', '    )\n', '        Issuer(\n', '            _token,\n', '            _genesisHoursPerPeriod,\n', '            _hoursPerPeriod,\n', '            _issuanceDecayCoefficient,\n', '            _lockDurationCoefficient1,\n', '            _lockDurationCoefficient2,\n', '            _maximumRewardedPeriods,\n', '            _firstPhaseTotalSupply,\n', '            _firstPhaseMaxIssuance\n', '        )\n', '    {\n', '        // constant `1` in the expression `_minLockedPeriods > 1` uses to simplify the `lock` method\n', '        require(_minLockedPeriods > 1 && _maxAllowableLockedTokens != 0);\n', '        minLockedPeriods = _minLockedPeriods;\n', '        minAllowableLockedTokens = _minAllowableLockedTokens;\n', '        maxAllowableLockedTokens = _maxAllowableLockedTokens;\n', '        minWorkerPeriods = _minWorkerPeriods;\n', '\n', '        require((_policyManager.secondsPerPeriod() == _hoursPerPeriod * (1 hours) ||\n', '            _policyManager.secondsPerPeriod() == _genesisHoursPerPeriod * (1 hours)) &&\n', '            _adjudicator.rewardCoefficient() != 0 &&\n', '            (address(_workLock) == address(0) || _workLock.token() == _token));\n', '        policyManager = _policyManager;\n', '        adjudicator = _adjudicator;\n', '        workLock = _workLock;\n', '    }\n', '\n', '    /**\n', '    * @dev Checks the existence of a staker in the contract\n', '    */\n', '    modifier onlyStaker()\n', '    {\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        require((info.value > 0 || info.nextCommittedPeriod != 0) &&\n', '            info.flags.bitSet(MIGRATED_INDEX));\n', '        _;\n', '    }\n', '\n', '    //------------------------Main getters------------------------\n', '    /**\n', '    * @notice Get all tokens belonging to the staker\n', '    */\n', '    function getAllTokens(address _staker) external view returns (uint256) {\n', '        return stakerInfo[_staker].value;\n', '    }\n', '\n', '    /**\n', '    * @notice Get all flags for the staker\n', '    */\n', '    function getFlags(address _staker)\n', '        external view returns (\n', '            bool windDown,\n', '            bool reStake,\n', '            bool measureWork,\n', '            bool snapshots,\n', '            bool migrated\n', '        )\n', '    {\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        windDown = info.flags.bitSet(WIND_DOWN_INDEX);\n', '        reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);\n', '        measureWork = info.flags.bitSet(MEASURE_WORK_INDEX);\n', '        snapshots = !info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX);\n', '        migrated = info.flags.bitSet(MIGRATED_INDEX);\n', '    }\n', '\n', '    /**\n', '    * @notice Get the start period. Use in the calculation of the last period of the sub stake\n', '    * @param _info Staker structure\n', '    * @param _currentPeriod Current period\n', '    */\n', '    function getStartPeriod(StakerInfo storage _info, uint16 _currentPeriod)\n', '        internal view returns (uint16)\n', '    {\n', '        // if the next period (after current) is committed\n', '        if (_info.flags.bitSet(WIND_DOWN_INDEX) && _info.nextCommittedPeriod > _currentPeriod) {\n', '            return _currentPeriod + 1;\n', '        }\n', '        return _currentPeriod;\n', '    }\n', '\n', '    /**\n', '    * @notice Get the last period of the sub stake\n', '    * @param _subStake Sub stake structure\n', '    * @param _startPeriod Pre-calculated start period\n', '    */\n', '    function getLastPeriodOfSubStake(SubStakeInfo storage _subStake, uint16 _startPeriod)\n', '        internal view returns (uint16)\n', '    {\n', '        if (_subStake.lastPeriod != 0) {\n', '            return _subStake.lastPeriod;\n', '        }\n', '        uint32 lastPeriod = uint32(_startPeriod) + _subStake.unlockingDuration;\n', '        if (lastPeriod > uint32(MAX_UINT16)) {\n', '            return MAX_UINT16;\n', '        }\n', '        return uint16(lastPeriod);\n', '    }\n', '\n', '    /**\n', '    * @notice Get the last period of the sub stake\n', '    * @param _staker Staker\n', '    * @param _index Stake index\n', '    */\n', '    function getLastPeriodOfSubStake(address _staker, uint256 _index)\n', '        public view returns (uint16)\n', '    {\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        SubStakeInfo storage subStake = info.subStakes[_index];\n', '        uint16 startPeriod = getStartPeriod(info, getCurrentPeriod());\n', '        return getLastPeriodOfSubStake(subStake, startPeriod);\n', '    }\n', '\n', '\n', '    /**\n', '    * @notice Get the value of locked tokens for a staker in a specified period\n', '    * @dev Information may be incorrect for rewarded or not committed surpassed period\n', '    * @param _info Staker structure\n', '    * @param _currentPeriod Current period\n', '    * @param _period Next period\n', '    */\n', '    function getLockedTokens(StakerInfo storage _info, uint16 _currentPeriod, uint16 _period)\n', '        internal view returns (uint256 lockedValue)\n', '    {\n', '        lockedValue = 0;\n', '        uint16 startPeriod = getStartPeriod(_info, _currentPeriod);\n', '        for (uint256 i = 0; i < _info.subStakes.length; i++) {\n', '            SubStakeInfo storage subStake = _info.subStakes[i];\n', '            if (subStake.firstPeriod <= _period &&\n', '                getLastPeriodOfSubStake(subStake, startPeriod) >= _period) {\n', '                lockedValue += subStake.lockedValue;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Get the value of locked tokens for a staker in a future period\n', "    * @dev This function is used by PreallocationEscrow so its signature can't be updated.\n", '    * @param _staker Staker\n', '    * @param _offsetPeriods Amount of periods that will be added to the current period\n', '    */\n', '    function getLockedTokens(address _staker, uint16 _offsetPeriods)\n', '        external view returns (uint256 lockedValue)\n', '    {\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        uint16 nextPeriod = currentPeriod.add16(_offsetPeriods);\n', '        return getLockedTokens(info, currentPeriod, nextPeriod);\n', '    }\n', '\n', '    /**\n', "    * @notice Get the last committed staker's period\n", '    * @param _staker Staker\n', '    */\n', '    function getLastCommittedPeriod(address _staker) public view returns (uint16) {\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        return info.nextCommittedPeriod != 0 ? info.nextCommittedPeriod : info.lastCommittedPeriod;\n', '    }\n', '\n', '    /**\n', '    * @notice Get the value of locked tokens for active stakers in (getCurrentPeriod() + _offsetPeriods) period\n', '    * as well as stakers and their locked tokens\n', '    * @param _offsetPeriods Amount of periods for locked tokens calculation\n', '    * @param _startIndex Start index for looking in stakers array\n', '    * @param _maxStakers Max stakers for looking, if set 0 then all will be used\n', '    * @return allLockedTokens Sum of locked tokens for active stakers\n', '    * @return activeStakers Array of stakers and their locked tokens. Stakers addresses stored as uint256\n', '    * @dev Note that activeStakers[0] in an array of uint256, but you want addresses. Careful when used directly!\n', '    */\n', '    function getActiveStakers(uint16 _offsetPeriods, uint256 _startIndex, uint256 _maxStakers)\n', '        external view returns (uint256 allLockedTokens, uint256[2][] memory activeStakers)\n', '    {\n', '        require(_offsetPeriods > 0);\n', '\n', '        uint256 endIndex = stakers.length;\n', '        require(_startIndex < endIndex);\n', '        if (_maxStakers != 0 && _startIndex + _maxStakers < endIndex) {\n', '            endIndex = _startIndex + _maxStakers;\n', '        }\n', '        activeStakers = new uint256[2][](endIndex - _startIndex);\n', '        allLockedTokens = 0;\n', '\n', '        uint256 resultIndex = 0;\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        uint16 nextPeriod = currentPeriod.add16(_offsetPeriods);\n', '\n', '        for (uint256 i = _startIndex; i < endIndex; i++) {\n', '            address staker = stakers[i];\n', '            StakerInfo storage info = stakerInfo[staker];\n', '            if (info.currentCommittedPeriod != currentPeriod &&\n', '                info.nextCommittedPeriod != currentPeriod) {\n', '                continue;\n', '            }\n', '            uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\n', '            if (lockedTokens != 0) {\n', '                activeStakers[resultIndex][0] = uint256(staker);\n', '                activeStakers[resultIndex++][1] = lockedTokens;\n', '                allLockedTokens += lockedTokens;\n', '            }\n', '        }\n', '        assembly {\n', '            mstore(activeStakers, resultIndex)\n', '        }\n', '    }\n', '\n', '    /**\n', "    * @notice Get worker using staker's address\n", '    */\n', '    function getWorkerFromStaker(address _staker) external view returns (address) {\n', '        return stakerInfo[_staker].worker;\n', '    }\n', '\n', '    /**\n', '    * @notice Get work that completed by the staker\n', '    */\n', '    function getCompletedWork(address _staker) external view returns (uint256) {\n', '        return stakerInfo[_staker].completedWork;\n', '    }\n', '\n', '    /**\n', '    * @notice Find index of downtime structure that includes specified period\n', '    * @dev If specified period is outside all downtime periods, the length of the array will be returned\n', '    * @param _staker Staker\n', '    * @param _period Specified period number\n', '    */\n', '    function findIndexOfPastDowntime(address _staker, uint16 _period) external view returns (uint256 index) {\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        for (index = 0; index < info.pastDowntime.length; index++) {\n', '            if (_period <= info.pastDowntime[index].endPeriod) {\n', '                return index;\n', '            }\n', '        }\n', '    }\n', '\n', '    //------------------------Main methods------------------------\n', '    /**\n', '    * @notice Start or stop measuring the work of a staker\n', '    * @param _staker Staker\n', '    * @param _measureWork Value for `measureWork` parameter\n', '    * @return Work that was previously done\n', '    */\n', '    function setWorkMeasurement(address _staker, bool _measureWork) external returns (uint256) {\n', '        require(msg.sender == address(workLock));\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        if (info.flags.bitSet(MEASURE_WORK_INDEX) == _measureWork) {\n', '            return info.completedWork;\n', '        }\n', '        info.flags = info.flags.toggleBit(MEASURE_WORK_INDEX);\n', '        emit WorkMeasurementSet(_staker, _measureWork);\n', '        return info.completedWork;\n', '    }\n', '\n', '    /**\n', '    * @notice Bond worker\n', '    * @param _worker Worker address. Must be a real address, not a contract\n', '    */\n', '    function bondWorker(address _worker) external onlyStaker {\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        // Specified worker is already bonded with this staker\n', '        require(_worker != info.worker);\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        if (info.worker != address(0)) { // If this staker had a worker ...\n', '            // Check that enough time has passed to change it\n', '            require(currentPeriod >= info.workerStartPeriod.add16(minWorkerPeriods));\n', '            // Remove the old relation "worker->staker"\n', '            stakerFromWorker[info.worker] = address(0);\n', '        }\n', '\n', '        if (_worker != address(0)) {\n', '            // Specified worker is already in use\n', '            require(stakerFromWorker[_worker] == address(0));\n', '            // Specified worker is a staker\n', '            require(stakerInfo[_worker].subStakes.length == 0 || _worker == msg.sender);\n', '            // Set new worker->staker relation\n', '            stakerFromWorker[_worker] = msg.sender;\n', '        }\n', '\n', '        // Bond new worker (or unbond if _worker == address(0))\n', '        info.worker = _worker;\n', '        info.workerStartPeriod = currentPeriod;\n', '        emit WorkerBonded(msg.sender, _worker, currentPeriod);\n', '    }\n', '\n', '    /**\n', '    * @notice Set `reStake` parameter. If true then all staking rewards will be added to locked stake\n', '    * @param _reStake Value for parameter\n', '    */\n', '    function setReStake(bool _reStake) external {\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        if (info.flags.bitSet(RE_STAKE_DISABLED_INDEX) == !_reStake) {\n', '            return;\n', '        }\n', '        info.flags = info.flags.toggleBit(RE_STAKE_DISABLED_INDEX);\n', '        emit ReStakeSet(msg.sender, _reStake);\n', '    }\n', '\n', '    /**\n', '    * @notice Deposit tokens from WorkLock contract\n', '    * @param _staker Staker address\n', '    * @param _value Amount of tokens to deposit\n', '    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled\n', '    */\n', '    function depositFromWorkLock(\n', '        address _staker,\n', '        uint256 _value,\n', '        uint16 _unlockingDuration\n', '    )\n', '        external\n', '    {\n', '        require(msg.sender == address(workLock));\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        if (!info.flags.bitSet(WIND_DOWN_INDEX) && info.subStakes.length == 0) {\n', '            info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);\n', '            emit WindDownSet(_staker, true);\n', '        }\n', '        // WorkLock still uses the genesis period length (24h)\n', '        _unlockingDuration = recalculatePeriod(_unlockingDuration);\n', '        deposit(_staker, msg.sender, MAX_SUB_STAKES, _value, _unlockingDuration);\n', '    }\n', '\n', '    /**\n', '    * @notice Set `windDown` parameter.\n', "    * If true then stake's duration will be decreasing in each period with `commitToNextPeriod()`\n", '    * @param _windDown Value for parameter\n', '    */\n', '    function setWindDown(bool _windDown) external {\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        if (info.flags.bitSet(WIND_DOWN_INDEX) == _windDown) {\n', '            return;\n', '        }\n', '        info.flags = info.flags.toggleBit(WIND_DOWN_INDEX);\n', '        emit WindDownSet(msg.sender, _windDown);\n', '\n', '        // duration adjustment if next period is committed\n', '        uint16 nextPeriod = getCurrentPeriod() + 1;\n', '        if (info.nextCommittedPeriod != nextPeriod) {\n', '           return;\n', '        }\n', '\n', '        // adjust sub-stakes duration for the new value of winding down parameter\n', '        for (uint256 index = 0; index < info.subStakes.length; index++) {\n', '            SubStakeInfo storage subStake = info.subStakes[index];\n', '            // sub-stake does not have fixed last period when winding down is disabled\n', '            if (!_windDown && subStake.lastPeriod == nextPeriod) {\n', '                subStake.lastPeriod = 0;\n', '                subStake.unlockingDuration = 1;\n', '                continue;\n', '            }\n', '            // this sub-stake is no longer affected by winding down parameter\n', '            if (subStake.lastPeriod != 0 || subStake.unlockingDuration == 0) {\n', '                continue;\n', '            }\n', '\n', '            subStake.unlockingDuration = _windDown ? subStake.unlockingDuration - 1 : subStake.unlockingDuration + 1;\n', '            if (subStake.unlockingDuration == 0) {\n', '                subStake.lastPeriod = nextPeriod;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Activate/deactivate taking snapshots of balances\n', '    * @param _enableSnapshots True to activate snapshots, False to deactivate\n', '    */\n', '    function setSnapshots(bool _enableSnapshots) external {\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        if (info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX) == !_enableSnapshots) {\n', '            return;\n', '        }\n', '\n', '        uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());\n', '        if(_enableSnapshots){\n', '            info.history.addSnapshot(info.value);\n', '            balanceHistory.addSnapshot(lastGlobalBalance + info.value);\n', '        } else {\n', '            info.history.addSnapshot(0);\n', '            balanceHistory.addSnapshot(lastGlobalBalance - info.value);\n', '        }\n', '        info.flags = info.flags.toggleBit(SNAPSHOTS_DISABLED_INDEX);\n', '\n', '        emit SnapshotSet(msg.sender, _enableSnapshots);\n', '    }\n', '\n', '    /**\n', '    * @notice Adds a new snapshot to both the staker and global balance histories,\n', "    * assuming the staker's balance was already changed\n", "    * @param _info Reference to affected staker's struct\n", '    * @param _addition Variance in balance. It can be positive or negative.\n', '    */\n', '    function addSnapshot(StakerInfo storage _info, int256 _addition) internal {\n', '        if(!_info.flags.bitSet(SNAPSHOTS_DISABLED_INDEX)){\n', '            _info.history.addSnapshot(_info.value);\n', '            uint256 lastGlobalBalance = uint256(balanceHistory.lastValue());\n', '            balanceHistory.addSnapshot(lastGlobalBalance.addSigned(_addition));\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Implementation of the receiveApproval(address,uint256,address,bytes) method\n', '    * (see NuCypherToken contract). Deposit all tokens that were approved to transfer\n', '    * @param _from Staker\n', '    * @param _value Amount of tokens to deposit\n', '    * @param _tokenContract Token contract address\n', '    * @notice (param _extraData) Amount of periods during which tokens will be unlocked when wind down is enabled\n', '    */\n', '    function receiveApproval(\n', '        address _from,\n', '        uint256 _value,\n', '        address _tokenContract,\n', '        bytes calldata /* _extraData */\n', '    )\n', '        external\n', '    {\n', '        require(_tokenContract == address(token) && msg.sender == address(token));\n', '\n', '        // Copy first 32 bytes from _extraData, according to calldata memory layout:\n', '        //\n', '        // 0x00: method signature      4 bytes\n', '        // 0x04: _from                 32 bytes after encoding\n', '        // 0x24: _value                32 bytes after encoding\n', '        // 0x44: _tokenContract        32 bytes after encoding\n', '        // 0x64: _extraData pointer    32 bytes. Value must be 0x80 (offset of _extraData wrt to 1st parameter)\n', '        // 0x84: _extraData length     32 bytes\n', '        // 0xA4: _extraData data       Length determined by previous variable\n', '        //\n', '        // See https://solidity.readthedocs.io/en/latest/abi-spec.html#examples\n', '\n', '        uint256 payloadSize;\n', '        uint256 payload;\n', '        assembly {\n', '            payloadSize := calldataload(0x84)\n', '            payload := calldataload(0xA4)\n', '        }\n', '        payload = payload >> 8*(32 - payloadSize);\n', '        deposit(_from, _from, MAX_SUB_STAKES, _value, uint16(payload));\n', '    }\n', '\n', '    /**\n', '    * @notice Deposit tokens and create new sub-stake. Use this method to become a staker\n', '    * @param _staker Staker\n', '    * @param _value Amount of tokens to deposit\n', '    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled\n', '    */\n', '    function deposit(address _staker, uint256 _value, uint16 _unlockingDuration) external {\n', '        deposit(_staker, msg.sender, MAX_SUB_STAKES, _value, _unlockingDuration);\n', '    }\n', '\n', '    /**\n', '    * @notice Deposit tokens and increase lock amount of an existing sub-stake\n', '    * @dev This is preferable way to stake tokens because will be fewer active sub-stakes in the result\n', '    * @param _index Index of the sub stake\n', '    * @param _value Amount of tokens which will be locked\n', '    */\n', '    function depositAndIncrease(uint256 _index, uint256 _value) external onlyStaker {\n', '        require(_index < MAX_SUB_STAKES);\n', '        deposit(msg.sender, msg.sender, _index, _value, 0);\n', '    }\n', '\n', '    /**\n', '    * @notice Deposit tokens\n', '    * @dev Specify either index and zero periods (for an existing sub-stake)\n', '    * or index >= MAX_SUB_STAKES and real value for periods (for a new sub-stake), not both\n', '    * @param _staker Staker\n', '    * @param _payer Owner of tokens\n', '    * @param _index Index of the sub stake\n', '    * @param _value Amount of tokens to deposit\n', '    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled\n', '    */\n', '    function deposit(address _staker, address _payer, uint256 _index, uint256 _value, uint16 _unlockingDuration) internal {\n', '        require(_value != 0);\n', '        StakerInfo storage info = stakerInfo[_staker];\n', "        // A staker can't be a worker for another staker\n", '        require(stakerFromWorker[_staker] == address(0) || stakerFromWorker[_staker] == info.worker);\n', '        // initial stake of the staker\n', '        if (info.subStakes.length == 0 && info.lastCommittedPeriod == 0) {\n', '            stakers.push(_staker);\n', '            policyManager.register(_staker, getCurrentPeriod() - 1);\n', '            info.flags = info.flags.toggleBit(MIGRATED_INDEX);\n', '        }\n', '        require(info.flags.bitSet(MIGRATED_INDEX));\n', '        token.safeTransferFrom(_payer, address(this), _value);\n', '        info.value += _value;\n', '        lock(_staker, _index, _value, _unlockingDuration);\n', '\n', '        addSnapshot(info, int256(_value));\n', '        if (_index >= MAX_SUB_STAKES) {\n', '            emit Deposited(_staker, _value, _unlockingDuration);\n', '        } else {\n', '            uint16 lastPeriod = getLastPeriodOfSubStake(_staker, _index);\n', '            emit Deposited(_staker, _value, lastPeriod - getCurrentPeriod());\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Lock some tokens as a new sub-stake\n', '    * @param _value Amount of tokens which will be locked\n', '    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled\n', '    */\n', '    function lockAndCreate(uint256 _value, uint16 _unlockingDuration) external onlyStaker {\n', '        lock(msg.sender, MAX_SUB_STAKES, _value, _unlockingDuration);\n', '    }\n', '\n', '    /**\n', '    * @notice Increase lock amount of an existing sub-stake\n', '    * @param _index Index of the sub-stake\n', '    * @param _value Amount of tokens which will be locked\n', '    */\n', '    function lockAndIncrease(uint256 _index, uint256 _value) external onlyStaker {\n', '        require(_index < MAX_SUB_STAKES);\n', '        lock(msg.sender, _index, _value, 0);\n', '    }\n', '\n', '    /**\n', '    * @notice Lock some tokens as a stake\n', '    * @dev Specify either index and zero periods (for an existing sub-stake)\n', '    * or index >= MAX_SUB_STAKES and real value for periods (for a new sub-stake), not both\n', '    * @param _staker Staker\n', '    * @param _index Index of the sub stake\n', '    * @param _value Amount of tokens which will be locked\n', '    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled\n', '    */\n', '    function lock(address _staker, uint256 _index, uint256 _value, uint16 _unlockingDuration) internal {\n', '        if (_index < MAX_SUB_STAKES) {\n', '            require(_value > 0);\n', '        } else {\n', '            require(_value >= minAllowableLockedTokens && _unlockingDuration >= minLockedPeriods);\n', '        }\n', '\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        uint16 nextPeriod = currentPeriod + 1;\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\n', '        uint256 requestedLockedTokens = _value.add(lockedTokens);\n', '        require(requestedLockedTokens <= info.value && requestedLockedTokens <= maxAllowableLockedTokens);\n', '\n', '        // next period is committed\n', '        if (info.nextCommittedPeriod == nextPeriod) {\n', '            _lockedPerPeriod[nextPeriod] += _value;\n', '            emit CommitmentMade(_staker, nextPeriod, _value);\n', '        }\n', '\n', '        // if index was provided then increase existing sub-stake\n', '        if (_index < MAX_SUB_STAKES) {\n', '            lockAndIncrease(info, currentPeriod, nextPeriod, _staker, _index, _value);\n', '        // otherwise create new\n', '        } else {\n', '            lockAndCreate(info, nextPeriod, _staker, _value, _unlockingDuration);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Lock some tokens as a new sub-stake\n', '    * @param _info Staker structure\n', '    * @param _nextPeriod Next period\n', '    * @param _staker Staker\n', '    * @param _value Amount of tokens which will be locked\n', '    * @param _unlockingDuration Amount of periods during which tokens will be unlocked when wind down is enabled\n', '    */\n', '    function lockAndCreate(\n', '        StakerInfo storage _info,\n', '        uint16 _nextPeriod,\n', '        address _staker,\n', '        uint256 _value,\n', '        uint16 _unlockingDuration\n', '    )\n', '        internal\n', '    {\n', '        uint16 duration = _unlockingDuration;\n', '        // if winding down is enabled and next period is committed\n', '        // then sub-stakes duration were decreased\n', '        if (_info.nextCommittedPeriod == _nextPeriod && _info.flags.bitSet(WIND_DOWN_INDEX)) {\n', '            duration -= 1;\n', '        }\n', '        saveSubStake(_info, _nextPeriod, 0, duration, _value);\n', '\n', '        emit Locked(_staker, _value, _nextPeriod, _unlockingDuration);\n', '    }\n', '\n', '    /**\n', '    * @notice Increase lock amount of an existing sub-stake\n', '    * @dev Probably will be created a new sub-stake but it will be active only one period\n', '    * @param _info Staker structure\n', '    * @param _currentPeriod Current period\n', '    * @param _nextPeriod Next period\n', '    * @param _staker Staker\n', '    * @param _index Index of the sub-stake\n', '    * @param _value Amount of tokens which will be locked\n', '    */\n', '    function lockAndIncrease(\n', '        StakerInfo storage _info,\n', '        uint16 _currentPeriod,\n', '        uint16 _nextPeriod,\n', '        address _staker,\n', '        uint256 _index,\n', '        uint256 _value\n', '    )\n', '        internal\n', '    {\n', '        SubStakeInfo storage subStake = _info.subStakes[_index];\n', '        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(_info, subStake, _currentPeriod);\n', '\n', '        // create temporary sub-stake for current or previous committed periods\n', '        // to leave locked amount in this period unchanged\n', '        if (_info.currentCommittedPeriod != 0 &&\n', '            _info.currentCommittedPeriod <= _currentPeriod ||\n', '            _info.nextCommittedPeriod != 0 &&\n', '            _info.nextCommittedPeriod <= _currentPeriod)\n', '        {\n', '            saveSubStake(_info, subStake.firstPeriod, _currentPeriod, 0, subStake.lockedValue);\n', '        }\n', '\n', '        subStake.lockedValue += uint128(_value);\n', '        // all new locks should start from the next period\n', '        subStake.firstPeriod = _nextPeriod;\n', '\n', '        emit Locked(_staker, _value, _nextPeriod, lastPeriod - _currentPeriod);\n', '    }\n', '\n', '    /**\n', '    * @notice Checks that last period of sub-stake is greater than the current period\n', '    * @param _info Staker structure\n', '    * @param _subStake Sub-stake structure\n', '    * @param _currentPeriod Current period\n', '    * @return startPeriod Start period. Use in the calculation of the last period of the sub stake\n', '    * @return lastPeriod Last period of the sub stake\n', '    */\n', '    function checkLastPeriodOfSubStake(\n', '        StakerInfo storage _info,\n', '        SubStakeInfo storage _subStake,\n', '        uint16 _currentPeriod\n', '    )\n', '        internal view returns (uint16 startPeriod, uint16 lastPeriod)\n', '    {\n', '        startPeriod = getStartPeriod(_info, _currentPeriod);\n', '        lastPeriod = getLastPeriodOfSubStake(_subStake, startPeriod);\n', '        // The sub stake must be active at least in the next period\n', '        require(lastPeriod > _currentPeriod);\n', '    }\n', '\n', '    /**\n', '    * @notice Save sub stake. First tries to override inactive sub stake\n', '    * @dev Inactive sub stake means that last period of sub stake has been surpassed and already rewarded\n', '    * @param _info Staker structure\n', '    * @param _firstPeriod First period of the sub stake\n', '    * @param _lastPeriod Last period of the sub stake\n', '    * @param _unlockingDuration Duration of the sub stake in periods\n', '    * @param _lockedValue Amount of locked tokens\n', '    */\n', '    function saveSubStake(\n', '        StakerInfo storage _info,\n', '        uint16 _firstPeriod,\n', '        uint16 _lastPeriod,\n', '        uint16 _unlockingDuration,\n', '        uint256 _lockedValue\n', '    )\n', '        internal\n', '    {\n', '        for (uint256 i = 0; i < _info.subStakes.length; i++) {\n', '            SubStakeInfo storage subStake = _info.subStakes[i];\n', '            if (subStake.lastPeriod != 0 &&\n', '                (_info.currentCommittedPeriod == 0 ||\n', '                subStake.lastPeriod < _info.currentCommittedPeriod) &&\n', '                (_info.nextCommittedPeriod == 0 ||\n', '                subStake.lastPeriod < _info.nextCommittedPeriod))\n', '            {\n', '                subStake.firstPeriod = _firstPeriod;\n', '                subStake.lastPeriod = _lastPeriod;\n', '                subStake.unlockingDuration = _unlockingDuration;\n', '                subStake.lockedValue = uint128(_lockedValue);\n', '                return;\n', '            }\n', '        }\n', '        require(_info.subStakes.length < MAX_SUB_STAKES);\n', '        _info.subStakes.push(SubStakeInfo(_firstPeriod, _lastPeriod, _unlockingDuration, uint128(_lockedValue)));\n', '    }\n', '\n', '    /**\n', '    * @notice Divide sub stake into two parts\n', '    * @param _index Index of the sub stake\n', '    * @param _newValue New sub stake value\n', '    * @param _additionalDuration Amount of periods for extending sub stake\n', '    */\n', '    function divideStake(uint256 _index, uint256 _newValue, uint16 _additionalDuration) external onlyStaker {\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        require(_newValue >= minAllowableLockedTokens && _additionalDuration > 0);\n', '        SubStakeInfo storage subStake = info.subStakes[_index];\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        (, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);\n', '\n', '        uint256 oldValue = subStake.lockedValue;\n', '        subStake.lockedValue = uint128(oldValue.sub(_newValue));\n', '        require(subStake.lockedValue >= minAllowableLockedTokens);\n', '        uint16 requestedPeriods = subStake.unlockingDuration.add16(_additionalDuration);\n', '        saveSubStake(info, subStake.firstPeriod, 0, requestedPeriods, _newValue);\n', '        emit Divided(msg.sender, oldValue, lastPeriod, _newValue, _additionalDuration);\n', '        emit Locked(msg.sender, _newValue, subStake.firstPeriod, requestedPeriods);\n', '    }\n', '\n', '    /**\n', '    * @notice Prolong active sub stake\n', '    * @param _index Index of the sub stake\n', '    * @param _additionalDuration Amount of periods for extending sub stake\n', '    */\n', '    function prolongStake(uint256 _index, uint16 _additionalDuration) external onlyStaker {\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        // Incorrect parameters\n', '        require(_additionalDuration > 0);\n', '        SubStakeInfo storage subStake = info.subStakes[_index];\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        (uint16 startPeriod, uint16 lastPeriod) = checkLastPeriodOfSubStake(info, subStake, currentPeriod);\n', '\n', '        subStake.unlockingDuration = subStake.unlockingDuration.add16(_additionalDuration);\n', '        // if the sub stake ends in the next committed period then reset the `lastPeriod` field\n', '        if (lastPeriod == startPeriod) {\n', '            subStake.lastPeriod = 0;\n', '        }\n', '        // The extended sub stake must not be less than the minimum value\n', '        require(uint32(lastPeriod - currentPeriod) + _additionalDuration >= minLockedPeriods);\n', '        emit Locked(msg.sender, subStake.lockedValue, lastPeriod + 1, _additionalDuration);\n', '        emit Prolonged(msg.sender, subStake.lockedValue, lastPeriod, _additionalDuration);\n', '    }\n', '\n', '    /**\n', '    * @notice Merge two sub-stakes into one if their last periods are equal\n', "    * @dev It's possible that both sub-stakes will be active after this transaction.\n", '    * But only one of them will be active until next call `commitToNextPeriod` (in the next period)\n', '    * @param _index1 Index of the first sub-stake\n', '    * @param _index2 Index of the second sub-stake\n', '    */\n', '    function mergeStake(uint256 _index1, uint256 _index2) external onlyStaker {\n', '        require(_index1 != _index2); // must be different sub-stakes\n', '\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        SubStakeInfo storage subStake1 = info.subStakes[_index1];\n', '        SubStakeInfo storage subStake2 = info.subStakes[_index2];\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '\n', '        (, uint16 lastPeriod1) = checkLastPeriodOfSubStake(info, subStake1, currentPeriod);\n', '        (, uint16 lastPeriod2) = checkLastPeriodOfSubStake(info, subStake2, currentPeriod);\n', '        // both sub-stakes must have equal last period to be mergeable\n', '        require(lastPeriod1 == lastPeriod2);\n', '        emit Merged(msg.sender, subStake1.lockedValue, subStake2.lockedValue, lastPeriod1);\n', '\n', '        if (subStake1.firstPeriod == subStake2.firstPeriod) {\n', '            subStake1.lockedValue += subStake2.lockedValue;\n', '            subStake2.lastPeriod = 1;\n', '            subStake2.unlockingDuration = 0;\n', '        } else if (subStake1.firstPeriod > subStake2.firstPeriod) {\n', '            subStake1.lockedValue += subStake2.lockedValue;\n', '            subStake2.lastPeriod = subStake1.firstPeriod - 1;\n', '            subStake2.unlockingDuration = 0;\n', '        } else {\n', '            subStake2.lockedValue += subStake1.lockedValue;\n', '            subStake1.lastPeriod = subStake2.firstPeriod - 1;\n', '            subStake1.unlockingDuration = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Remove unused sub-stake to decrease gas cost for several methods\n', '    */\n', '    function removeUnusedSubStake(uint16 _index) external onlyStaker {\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '\n', '        uint256 lastIndex = info.subStakes.length - 1;\n', '        SubStakeInfo storage subStake = info.subStakes[_index];\n', '        require(subStake.lastPeriod != 0 &&\n', '                (info.currentCommittedPeriod == 0 ||\n', '                subStake.lastPeriod < info.currentCommittedPeriod) &&\n', '                (info.nextCommittedPeriod == 0 ||\n', '                subStake.lastPeriod < info.nextCommittedPeriod));\n', '\n', '        if (_index != lastIndex) {\n', '            SubStakeInfo storage lastSubStake = info.subStakes[lastIndex];\n', '            subStake.firstPeriod = lastSubStake.firstPeriod;\n', '            subStake.lastPeriod = lastSubStake.lastPeriod;\n', '            subStake.unlockingDuration = lastSubStake.unlockingDuration;\n', '            subStake.lockedValue = lastSubStake.lockedValue;\n', '        }\n', '        info.subStakes.pop();\n', '    }\n', '\n', '    /**\n', '    * @notice Withdraw available amount of tokens to staker\n', '    * @param _value Amount of tokens to withdraw\n', '    */\n', '    function withdraw(uint256 _value) external onlyStaker {\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        uint16 nextPeriod = currentPeriod + 1;\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        // the max locked tokens in most cases will be in the current period\n', '        // but when the staker locks more then we should use the next period\n', '        uint256 lockedTokens = Math.max(getLockedTokens(info, currentPeriod, nextPeriod),\n', '            getLockedTokens(info, currentPeriod, currentPeriod));\n', '        require(_value <= info.value.sub(lockedTokens));\n', '        info.value -= _value;\n', '\n', '        addSnapshot(info, - int256(_value));\n', '        token.safeTransfer(msg.sender, _value);\n', '        emit Withdrawn(msg.sender, _value);\n', '\n', '        // unbond worker if staker withdraws last portion of NU\n', '        if (info.value == 0 &&\n', '            info.nextCommittedPeriod == 0 &&\n', '            info.worker != address(0))\n', '        {\n', '            stakerFromWorker[info.worker] = address(0);\n', '            info.worker = address(0);\n', '            emit WorkerBonded(msg.sender, address(0), currentPeriod);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Make a commitment to the next period and mint for the previous period\n', '    */\n', '    function commitToNextPeriod() external isInitialized {\n', '        address staker = stakerFromWorker[msg.sender];\n', '        StakerInfo storage info = stakerInfo[staker];\n', '        // Staker must have a stake to make a commitment\n', '        require(info.value > 0);\n', '        // Only worker with real address can make a commitment\n', '        require(msg.sender == tx.origin);\n', '\n', '        migrate(staker);\n', '\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        uint16 nextPeriod = currentPeriod + 1;\n', '        // the period has already been committed\n', '        require(info.nextCommittedPeriod != nextPeriod);\n', '\n', '        uint16 lastCommittedPeriod = getLastCommittedPeriod(staker);\n', '        (uint16 processedPeriod1, uint16 processedPeriod2) = mint(staker);\n', '\n', '        uint256 lockedTokens = getLockedTokens(info, currentPeriod, nextPeriod);\n', '        require(lockedTokens > 0);\n', '        _lockedPerPeriod[nextPeriod] += lockedTokens;\n', '\n', '        info.currentCommittedPeriod = info.nextCommittedPeriod;\n', '        info.nextCommittedPeriod = nextPeriod;\n', '\n', '        decreaseSubStakesDuration(info, nextPeriod);\n', '\n', '        // staker was inactive for several periods\n', '        if (lastCommittedPeriod < currentPeriod) {\n', '            info.pastDowntime.push(Downtime(lastCommittedPeriod + 1, currentPeriod));\n', '        }\n', '\n', '        policyManager.ping(staker, processedPeriod1, processedPeriod2, nextPeriod);\n', '        emit CommitmentMade(staker, nextPeriod, lockedTokens);\n', '    }\n', '\n', '    /**\n', '    * @notice Migrate from the old period length to the new one. Can be done only once\n', '    * @param _staker Staker\n', '    */\n', '    function migrate(address _staker) public {\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        // check that provided address is/was a staker\n', '        require(info.subStakes.length != 0 || info.lastCommittedPeriod != 0);\n', '        if (info.flags.bitSet(MIGRATED_INDEX)) {\n', '            return;\n', '        }\n', '\n', '        // reset state\n', '        info.currentCommittedPeriod = 0;\n', '        info.nextCommittedPeriod = 0;\n', '        // maintain case when no more sub-stakes and need to avoid re-registering this staker during deposit\n', '        info.lastCommittedPeriod = 1;\n', '        info.workerStartPeriod = recalculatePeriod(info.workerStartPeriod);\n', '        delete info.pastDowntime;\n', '\n', '        // recalculate all sub-stakes\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        for (uint256 i = 0; i < info.subStakes.length; i++) {\n', '            SubStakeInfo storage subStake = info.subStakes[i];\n', '            subStake.firstPeriod = recalculatePeriod(subStake.firstPeriod);\n', '            // sub-stake has fixed last period\n', '            if (subStake.lastPeriod != 0) {\n', '                subStake.lastPeriod = recalculatePeriod(subStake.lastPeriod);\n', '                if (subStake.lastPeriod == 0) {\n', '                    subStake.lastPeriod = 1;\n', '                }\n', '                subStake.unlockingDuration = 0;\n', '            // sub-stake has no fixed ending but possible that with new period length will have\n', '            } else {\n', '                uint16 oldCurrentPeriod = uint16(block.timestamp / genesisSecondsPerPeriod);\n', '                uint16 lastPeriod = recalculatePeriod(oldCurrentPeriod + subStake.unlockingDuration);\n', '                subStake.unlockingDuration = lastPeriod - currentPeriod;\n', '                if (subStake.unlockingDuration == 0) {\n', '                    subStake.lastPeriod = lastPeriod;\n', '                }\n', '            }\n', '        }\n', '\n', '        policyManager.migrate(_staker);\n', '        info.flags = info.flags.toggleBit(MIGRATED_INDEX);\n', '        emit Migrated(_staker, currentPeriod);\n', '    }\n', '\n', '    /**\n', '    * @notice Decrease sub-stakes duration if `windDown` is enabled\n', '    */\n', '    function decreaseSubStakesDuration(StakerInfo storage _info, uint16 _nextPeriod) internal {\n', '        if (!_info.flags.bitSet(WIND_DOWN_INDEX)) {\n', '            return;\n', '        }\n', '        for (uint256 index = 0; index < _info.subStakes.length; index++) {\n', '            SubStakeInfo storage subStake = _info.subStakes[index];\n', '            if (subStake.lastPeriod != 0 || subStake.unlockingDuration == 0) {\n', '                continue;\n', '            }\n', '            subStake.unlockingDuration--;\n', '            if (subStake.unlockingDuration == 0) {\n', '                subStake.lastPeriod = _nextPeriod;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment\n', '    */\n', '    function mint() external onlyStaker {\n', '        // save last committed period to the storage if both periods will be empty after minting\n', "        // because we won't be able to calculate last committed period\n", '        // see getLastCommittedPeriod(address)\n', '        StakerInfo storage info = stakerInfo[msg.sender];\n', '        uint16 previousPeriod = getCurrentPeriod() - 1;\n', '        if (info.nextCommittedPeriod <= previousPeriod && info.nextCommittedPeriod != 0) {\n', '            info.lastCommittedPeriod = info.nextCommittedPeriod;\n', '        }\n', '        (uint16 processedPeriod1, uint16 processedPeriod2) = mint(msg.sender);\n', '\n', '        if (processedPeriod1 != 0 || processedPeriod2 != 0) {\n', '            policyManager.ping(msg.sender, processedPeriod1, processedPeriod2, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Mint tokens for previous periods if staker locked their tokens and made a commitment\n', '    * @param _staker Staker\n', '    * @return processedPeriod1 Processed period: currentCommittedPeriod or zero\n', '    * @return processedPeriod2 Processed period: nextCommittedPeriod or zero\n', '    */\n', '    function mint(address _staker) internal returns (uint16 processedPeriod1, uint16 processedPeriod2) {\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        uint16 previousPeriod = currentPeriod - 1;\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '\n', '        if (info.nextCommittedPeriod == 0 ||\n', '            info.currentCommittedPeriod == 0 &&\n', '            info.nextCommittedPeriod > previousPeriod ||\n', '            info.currentCommittedPeriod > previousPeriod) {\n', '            return (0, 0);\n', '        }\n', '\n', '        uint16 startPeriod = getStartPeriod(info, currentPeriod);\n', '        uint256 reward = 0;\n', '        bool reStake = !info.flags.bitSet(RE_STAKE_DISABLED_INDEX);\n', '\n', '        if (info.currentCommittedPeriod != 0) {\n', '            reward = mint(info, info.currentCommittedPeriod, currentPeriod, startPeriod, reStake);\n', '            processedPeriod1 = info.currentCommittedPeriod;\n', '            info.currentCommittedPeriod = 0;\n', '            if (reStake) {\n', '                _lockedPerPeriod[info.nextCommittedPeriod] += reward;\n', '            }\n', '        }\n', '        if (info.nextCommittedPeriod <= previousPeriod) {\n', '            reward += mint(info, info.nextCommittedPeriod, currentPeriod, startPeriod, reStake);\n', '            processedPeriod2 = info.nextCommittedPeriod;\n', '            info.nextCommittedPeriod = 0;\n', '        }\n', '\n', '        info.value += reward;\n', '        if (info.flags.bitSet(MEASURE_WORK_INDEX)) {\n', '            info.completedWork += reward;\n', '        }\n', '\n', '        addSnapshot(info, int256(reward));\n', '        emit Minted(_staker, previousPeriod, reward);\n', '    }\n', '\n', '    /**\n', '    * @notice Calculate reward for one period\n', '    * @param _info Staker structure\n', '    * @param _mintingPeriod Period for minting calculation\n', '    * @param _currentPeriod Current period\n', '    * @param _startPeriod Pre-calculated start period\n', '    */\n', '    function mint(\n', '        StakerInfo storage _info,\n', '        uint16 _mintingPeriod,\n', '        uint16 _currentPeriod,\n', '        uint16 _startPeriod,\n', '        bool _reStake\n', '    )\n', '        internal returns (uint256 reward)\n', '    {\n', '        reward = 0;\n', '        for (uint256 i = 0; i < _info.subStakes.length; i++) {\n', '            SubStakeInfo storage subStake =  _info.subStakes[i];\n', '            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\n', '            if (subStake.firstPeriod <= _mintingPeriod && lastPeriod >= _mintingPeriod) {\n', '                uint256 subStakeReward = mint(\n', '                    _currentPeriod,\n', '                    subStake.lockedValue,\n', '                    _lockedPerPeriod[_mintingPeriod],\n', '                    lastPeriod.sub16(_mintingPeriod));\n', '                reward += subStakeReward;\n', '                if (_reStake) {\n', '                    subStake.lockedValue += uint128(subStakeReward);\n', '                }\n', '            }\n', '        }\n', '        return reward;\n', '    }\n', '\n', '    //-------------------------Slashing-------------------------\n', '    /**\n', "    * @notice Slash the staker's stake and reward the investigator\n", "    * @param _staker Staker's address\n", '    * @param _penalty Penalty\n', '    * @param _investigator Investigator\n', '    * @param _reward Reward for the investigator\n', '    */\n', '    function slashStaker(\n', '        address _staker,\n', '        uint256 _penalty,\n', '        address _investigator,\n', '        uint256 _reward\n', '    )\n', '        public isInitialized\n', '    {\n', '        require(msg.sender == address(adjudicator));\n', '        require(_penalty > 0);\n', '        StakerInfo storage info = stakerInfo[_staker];\n', '        require(info.flags.bitSet(MIGRATED_INDEX));\n', '        if (info.value <= _penalty) {\n', '            _penalty = info.value;\n', '        }\n', '        info.value -= _penalty;\n', '        if (_reward > _penalty) {\n', '            _reward = _penalty;\n', '        }\n', '\n', '        uint16 currentPeriod = getCurrentPeriod();\n', '        uint16 nextPeriod = currentPeriod + 1;\n', '        uint16 startPeriod = getStartPeriod(info, currentPeriod);\n', '\n', '        (uint256 currentLock, uint256 nextLock, uint256 currentAndNextLock, uint256 shortestSubStakeIndex) =\n', '            getLockedTokensAndShortestSubStake(info, currentPeriod, nextPeriod, startPeriod);\n', '\n', '        // Decrease the stake if amount of locked tokens in the current period more than staker has\n', '        uint256 lockedTokens = currentLock + currentAndNextLock;\n', '        if (info.value < lockedTokens) {\n', '           decreaseSubStakes(info, lockedTokens - info.value, currentPeriod, startPeriod, shortestSubStakeIndex);\n', '        }\n', '        // Decrease the stake if amount of locked tokens in the next period more than staker has\n', '        if (nextLock > 0) {\n', '            lockedTokens = nextLock + currentAndNextLock -\n', '                (currentAndNextLock > info.value ? currentAndNextLock - info.value : 0);\n', '            if (info.value < lockedTokens) {\n', '               decreaseSubStakes(info, lockedTokens - info.value, nextPeriod, startPeriod, MAX_SUB_STAKES);\n', '            }\n', '        }\n', '\n', '        emit Slashed(_staker, _penalty, _investigator, _reward);\n', '        if (_penalty > _reward) {\n', '            unMint(_penalty - _reward);\n', '        }\n', '        // TODO change to withdrawal pattern (#1499)\n', '        if (_reward > 0) {\n', '            token.safeTransfer(_investigator, _reward);\n', '        }\n', '\n', '        addSnapshot(info, - int256(_penalty));\n', '\n', '    }\n', '\n', '    /**\n', '    * @notice Get the value of locked tokens for a staker in the current and the next period\n', '    * and find the shortest sub stake\n', '    * @param _info Staker structure\n', '    * @param _currentPeriod Current period\n', '    * @param _nextPeriod Next period\n', '    * @param _startPeriod Pre-calculated start period\n', '    * @return currentLock Amount of tokens that locked in the current period and unlocked in the next period\n', '    * @return nextLock Amount of tokens that locked in the next period and not locked in the current period\n', '    * @return currentAndNextLock Amount of tokens that locked in the current period and in the next period\n', '    * @return shortestSubStakeIndex Index of the shortest sub stake\n', '    */\n', '    function getLockedTokensAndShortestSubStake(\n', '        StakerInfo storage _info,\n', '        uint16 _currentPeriod,\n', '        uint16 _nextPeriod,\n', '        uint16 _startPeriod\n', '    )\n', '        internal view returns (\n', '            uint256 currentLock,\n', '            uint256 nextLock,\n', '            uint256 currentAndNextLock,\n', '            uint256 shortestSubStakeIndex\n', '        )\n', '    {\n', '        uint16 minDuration = MAX_UINT16;\n', '        uint16 minLastPeriod = MAX_UINT16;\n', '        shortestSubStakeIndex = MAX_SUB_STAKES;\n', '        currentLock = 0;\n', '        nextLock = 0;\n', '        currentAndNextLock = 0;\n', '\n', '        for (uint256 i = 0; i < _info.subStakes.length; i++) {\n', '            SubStakeInfo storage subStake = _info.subStakes[i];\n', '            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\n', '            if (lastPeriod < subStake.firstPeriod) {\n', '                continue;\n', '            }\n', '            if (subStake.firstPeriod <= _currentPeriod &&\n', '                lastPeriod >= _nextPeriod) {\n', '                currentAndNextLock += subStake.lockedValue;\n', '            } else if (subStake.firstPeriod <= _currentPeriod &&\n', '                lastPeriod >= _currentPeriod) {\n', '                currentLock += subStake.lockedValue;\n', '            } else if (subStake.firstPeriod <= _nextPeriod &&\n', '                lastPeriod >= _nextPeriod) {\n', '                nextLock += subStake.lockedValue;\n', '            }\n', '            uint16 duration = lastPeriod - subStake.firstPeriod;\n', '            if (subStake.firstPeriod <= _currentPeriod &&\n', '                lastPeriod >= _currentPeriod &&\n', '                (lastPeriod < minLastPeriod ||\n', '                lastPeriod == minLastPeriod && duration < minDuration))\n', '            {\n', '                shortestSubStakeIndex = i;\n', '                minDuration = duration;\n', '                minLastPeriod = lastPeriod;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Decrease short sub stakes\n', '    * @param _info Staker structure\n', '    * @param _penalty Penalty rate\n', '    * @param _decreasePeriod The period when the decrease begins\n', '    * @param _startPeriod Pre-calculated start period\n', '    * @param _shortestSubStakeIndex Index of the shortest period\n', '    */\n', '    function decreaseSubStakes(\n', '        StakerInfo storage _info,\n', '        uint256 _penalty,\n', '        uint16 _decreasePeriod,\n', '        uint16 _startPeriod,\n', '        uint256 _shortestSubStakeIndex\n', '    )\n', '        internal\n', '    {\n', '        SubStakeInfo storage shortestSubStake = _info.subStakes[0];\n', '        uint16 minSubStakeLastPeriod = MAX_UINT16;\n', '        uint16 minSubStakeDuration = MAX_UINT16;\n', '        while(_penalty > 0) {\n', '            if (_shortestSubStakeIndex < MAX_SUB_STAKES) {\n', '                shortestSubStake = _info.subStakes[_shortestSubStakeIndex];\n', '                minSubStakeLastPeriod = getLastPeriodOfSubStake(shortestSubStake, _startPeriod);\n', '                minSubStakeDuration = minSubStakeLastPeriod - shortestSubStake.firstPeriod;\n', '                _shortestSubStakeIndex = MAX_SUB_STAKES;\n', '            } else {\n', '                (shortestSubStake, minSubStakeDuration, minSubStakeLastPeriod) =\n', '                    getShortestSubStake(_info, _decreasePeriod, _startPeriod);\n', '            }\n', '            if (minSubStakeDuration == MAX_UINT16) {\n', '                break;\n', '            }\n', '            uint256 appliedPenalty = _penalty;\n', '            if (_penalty < shortestSubStake.lockedValue) {\n', '                shortestSubStake.lockedValue -= uint128(_penalty);\n', '                saveOldSubStake(_info, shortestSubStake.firstPeriod, _penalty, _decreasePeriod);\n', '                _penalty = 0;\n', '            } else {\n', '                shortestSubStake.lastPeriod = _decreasePeriod - 1;\n', '                _penalty -= shortestSubStake.lockedValue;\n', '                appliedPenalty = shortestSubStake.lockedValue;\n', '            }\n', '            if (_info.currentCommittedPeriod >= _decreasePeriod &&\n', '                _info.currentCommittedPeriod <= minSubStakeLastPeriod)\n', '            {\n', '                _lockedPerPeriod[_info.currentCommittedPeriod] -= appliedPenalty;\n', '            }\n', '            if (_info.nextCommittedPeriod >= _decreasePeriod &&\n', '                _info.nextCommittedPeriod <= minSubStakeLastPeriod)\n', '            {\n', '                _lockedPerPeriod[_info.nextCommittedPeriod] -= appliedPenalty;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Get the shortest sub stake\n', '    * @param _info Staker structure\n', '    * @param _currentPeriod Current period\n', '    * @param _startPeriod Pre-calculated start period\n', '    * @return shortestSubStake The shortest sub stake\n', '    * @return minSubStakeDuration Duration of the shortest sub stake\n', '    * @return minSubStakeLastPeriod Last period of the shortest sub stake\n', '    */\n', '    function getShortestSubStake(\n', '        StakerInfo storage _info,\n', '        uint16 _currentPeriod,\n', '        uint16 _startPeriod\n', '    )\n', '        internal view returns (\n', '            SubStakeInfo storage shortestSubStake,\n', '            uint16 minSubStakeDuration,\n', '            uint16 minSubStakeLastPeriod\n', '        )\n', '    {\n', '        shortestSubStake = shortestSubStake;\n', '        minSubStakeDuration = MAX_UINT16;\n', '        minSubStakeLastPeriod = MAX_UINT16;\n', '        for (uint256 i = 0; i < _info.subStakes.length; i++) {\n', '            SubStakeInfo storage subStake = _info.subStakes[i];\n', '            uint16 lastPeriod = getLastPeriodOfSubStake(subStake, _startPeriod);\n', '            if (lastPeriod < subStake.firstPeriod) {\n', '                continue;\n', '            }\n', '            uint16 duration = lastPeriod - subStake.firstPeriod;\n', '            if (subStake.firstPeriod <= _currentPeriod &&\n', '                lastPeriod >= _currentPeriod &&\n', '                (lastPeriod < minSubStakeLastPeriod ||\n', '                lastPeriod == minSubStakeLastPeriod && duration < minSubStakeDuration))\n', '            {\n', '                shortestSubStake = subStake;\n', '                minSubStakeDuration = duration;\n', '                minSubStakeLastPeriod = lastPeriod;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Save the old sub stake values to prevent decreasing reward for the previous period\n', '    * @dev Saving happens only if the previous period is committed\n', '    * @param _info Staker structure\n', '    * @param _firstPeriod First period of the old sub stake\n', '    * @param _lockedValue Locked value of the old sub stake\n', '    * @param _currentPeriod Current period, when the old sub stake is already unlocked\n', '    */\n', '    function saveOldSubStake(\n', '        StakerInfo storage _info,\n', '        uint16 _firstPeriod,\n', '        uint256 _lockedValue,\n', '        uint16 _currentPeriod\n', '    )\n', '        internal\n', '    {\n', '        // Check that the old sub stake should be saved\n', '        bool oldCurrentCommittedPeriod = _info.currentCommittedPeriod != 0 &&\n', '            _info.currentCommittedPeriod < _currentPeriod;\n', '        bool oldnextCommittedPeriod = _info.nextCommittedPeriod != 0 &&\n', '            _info.nextCommittedPeriod < _currentPeriod;\n', '        bool crosscurrentCommittedPeriod = oldCurrentCommittedPeriod && _info.currentCommittedPeriod >= _firstPeriod;\n', '        bool crossnextCommittedPeriod = oldnextCommittedPeriod && _info.nextCommittedPeriod >= _firstPeriod;\n', '        if (!crosscurrentCommittedPeriod && !crossnextCommittedPeriod) {\n', '            return;\n', '        }\n', '        // Try to find already existent proper old sub stake\n', '        uint16 previousPeriod = _currentPeriod - 1;\n', '        for (uint256 i = 0; i < _info.subStakes.length; i++) {\n', '            SubStakeInfo storage subStake = _info.subStakes[i];\n', '            if (subStake.lastPeriod == previousPeriod &&\n', '                ((crosscurrentCommittedPeriod ==\n', '                (oldCurrentCommittedPeriod && _info.currentCommittedPeriod >= subStake.firstPeriod)) &&\n', '                (crossnextCommittedPeriod ==\n', '                (oldnextCommittedPeriod && _info.nextCommittedPeriod >= subStake.firstPeriod))))\n', '            {\n', '                subStake.lockedValue += uint128(_lockedValue);\n', '                return;\n', '            }\n', '        }\n', '        saveSubStake(_info, _firstPeriod, previousPeriod, 0, _lockedValue);\n', '    }\n', '\n', '    //-------------Additional getters for stakers info-------------\n', '    /**\n', '    * @notice Return the length of the array of stakers\n', '    */\n', '    function getStakersLength() external view returns (uint256) {\n', '        return stakers.length;\n', '    }\n', '\n', '    /**\n', '    * @notice Return the length of the array of sub stakes\n', '    */\n', '    function getSubStakesLength(address _staker) external view returns (uint256) {\n', '        return stakerInfo[_staker].subStakes.length;\n', '    }\n', '\n', '    /**\n', '    * @notice Return the information about sub stake\n', '    */\n', '    function getSubStakeInfo(address _staker, uint256 _index)\n', '    // TODO change to structure when ABIEncoderV2 is released (#1501)\n', '//        public view returns (SubStakeInfo)\n', '        // TODO "virtual" only for tests, probably will be removed after #1512\n', '        external view virtual returns (\n', '            uint16 firstPeriod,\n', '            uint16 lastPeriod,\n', '            uint16 unlockingDuration,\n', '            uint128 lockedValue\n', '        )\n', '    {\n', '        SubStakeInfo storage info = stakerInfo[_staker].subStakes[_index];\n', '        firstPeriod = info.firstPeriod;\n', '        lastPeriod = info.lastPeriod;\n', '        unlockingDuration = info.unlockingDuration;\n', '        lockedValue = info.lockedValue;\n', '    }\n', '\n', '    /**\n', '    * @notice Return the length of the array of past downtime\n', '    */\n', '    function getPastDowntimeLength(address _staker) external view returns (uint256) {\n', '        return stakerInfo[_staker].pastDowntime.length;\n', '    }\n', '\n', '    /**\n', '    * @notice Return the information about past downtime\n', '    */\n', '    function  getPastDowntime(address _staker, uint256 _index)\n', '    // TODO change to structure when ABIEncoderV2 is released (#1501)\n', '//        public view returns (Downtime)\n', '        external view returns (uint16 startPeriod, uint16 endPeriod)\n', '    {\n', '        Downtime storage downtime = stakerInfo[_staker].pastDowntime[_index];\n', '        startPeriod = downtime.startPeriod;\n', '        endPeriod = downtime.endPeriod;\n', '    }\n', '\n', '    //------------------ ERC900 connectors ----------------------\n', '\n', '    function totalStakedForAt(address _owner, uint256 _blockNumber) public view override returns (uint256){\n', '        return stakerInfo[_owner].history.getValueAt(_blockNumber);\n', '    }\n', '\n', '    function totalStakedAt(uint256 _blockNumber) public view override returns (uint256){\n', '        return balanceHistory.getValueAt(_blockNumber);\n', '    }\n', '\n', '    function supportsHistory() external pure override returns (bool){\n', '        return true;\n', '    }\n', '\n', '    //------------------------Upgradeable------------------------\n', '    /**\n', '    * @dev Get StakerInfo structure by delegatecall\n', '    */\n', '    function delegateGetStakerInfo(address _target, bytes32 _staker)\n', '        internal returns (StakerInfo memory result)\n', '    {\n', '        bytes32 memoryAddress = delegateGetData(_target, this.stakerInfo.selector, 1, _staker, 0);\n', '        assembly {\n', '            result := memoryAddress\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Get SubStakeInfo structure by delegatecall\n', '    */\n', '    function delegateGetSubStakeInfo(address _target, bytes32 _staker, uint256 _index)\n', '        internal returns (SubStakeInfo memory result)\n', '    {\n', '        bytes32 memoryAddress = delegateGetData(\n', '            _target, this.getSubStakeInfo.selector, 2, _staker, bytes32(_index));\n', '        assembly {\n', '            result := memoryAddress\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Get Downtime structure by delegatecall\n', '    */\n', '    function delegateGetPastDowntime(address _target, bytes32 _staker, uint256 _index)\n', '        internal returns (Downtime memory result)\n', '    {\n', '        bytes32 memoryAddress = delegateGetData(\n', '            _target, this.getPastDowntime.selector, 2, _staker, bytes32(_index));\n', '        assembly {\n', '            result := memoryAddress\n', '        }\n', '    }\n', '\n', '    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `verifyState`\n', '    function verifyState(address _testTarget) public override virtual {\n', '        super.verifyState(_testTarget);\n', '        require(delegateGet(_testTarget, this.lockedPerPeriod.selector,\n', '            bytes32(bytes2(RESERVED_PERIOD))) == lockedPerPeriod(RESERVED_PERIOD));\n', '        require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(0))) ==\n', '            stakerFromWorker[address(0)]);\n', '\n', '        require(delegateGet(_testTarget, this.getStakersLength.selector) == stakers.length);\n', '        if (stakers.length == 0) {\n', '            return;\n', '        }\n', '        address stakerAddress = stakers[0];\n', '        require(address(uint160(delegateGet(_testTarget, this.stakers.selector, 0))) == stakerAddress);\n', '        StakerInfo storage info = stakerInfo[stakerAddress];\n', '        bytes32 staker = bytes32(uint256(stakerAddress));\n', '        StakerInfo memory infoToCheck = delegateGetStakerInfo(_testTarget, staker);\n', '        require(infoToCheck.value == info.value &&\n', '            infoToCheck.currentCommittedPeriod == info.currentCommittedPeriod &&\n', '            infoToCheck.nextCommittedPeriod == info.nextCommittedPeriod &&\n', '            infoToCheck.flags == info.flags &&\n', '            infoToCheck.lastCommittedPeriod == info.lastCommittedPeriod &&\n', '            infoToCheck.completedWork == info.completedWork &&\n', '            infoToCheck.worker == info.worker &&\n', '            infoToCheck.workerStartPeriod == info.workerStartPeriod);\n', '\n', '        require(delegateGet(_testTarget, this.getPastDowntimeLength.selector, staker) ==\n', '            info.pastDowntime.length);\n', '        for (uint256 i = 0; i < info.pastDowntime.length && i < MAX_CHECKED_VALUES; i++) {\n', '            Downtime storage downtime = info.pastDowntime[i];\n', '            Downtime memory downtimeToCheck = delegateGetPastDowntime(_testTarget, staker, i);\n', '            require(downtimeToCheck.startPeriod == downtime.startPeriod &&\n', '                downtimeToCheck.endPeriod == downtime.endPeriod);\n', '        }\n', '\n', '        require(delegateGet(_testTarget, this.getSubStakesLength.selector, staker) == info.subStakes.length);\n', '        for (uint256 i = 0; i < info.subStakes.length && i < MAX_CHECKED_VALUES; i++) {\n', '            SubStakeInfo storage subStakeInfo = info.subStakes[i];\n', '            SubStakeInfo memory subStakeInfoToCheck = delegateGetSubStakeInfo(_testTarget, staker, i);\n', '            require(subStakeInfoToCheck.firstPeriod == subStakeInfo.firstPeriod &&\n', '                subStakeInfoToCheck.lastPeriod == subStakeInfo.lastPeriod &&\n', '                subStakeInfoToCheck.unlockingDuration == subStakeInfo.unlockingDuration &&\n', '                subStakeInfoToCheck.lockedValue == subStakeInfo.lockedValue);\n', '        }\n', '\n', "        // it's not perfect because checks not only slot value but also decoding\n", '        // at least without additional functions\n', '        require(delegateGet(_testTarget, this.totalStakedForAt.selector, staker, bytes32(block.number)) ==\n', '            totalStakedForAt(stakerAddress, block.number));\n', '        require(delegateGet(_testTarget, this.totalStakedAt.selector, bytes32(block.number)) ==\n', '            totalStakedAt(block.number));\n', '\n', '        if (info.worker != address(0)) {\n', '            require(address(delegateGet(_testTarget, this.stakerFromWorker.selector, bytes32(uint256(info.worker)))) ==\n', '                stakerFromWorker[info.worker]);\n', '        }\n', '    }\n', '\n', '    /// @dev the `onlyWhileUpgrading` modifier works through a call to the parent `finishUpgrade`\n', '    function finishUpgrade(address _target) public override virtual {\n', '        super.finishUpgrade(_target);\n', '        // Create fake period\n', '        _lockedPerPeriod[RESERVED_PERIOD] = 111;\n', '\n', '        // Create fake worker\n', '        stakerFromWorker[address(0)] = address(this);\n', '    }\n', '}']