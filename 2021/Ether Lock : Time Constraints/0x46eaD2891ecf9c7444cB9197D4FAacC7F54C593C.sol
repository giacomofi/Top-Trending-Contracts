['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '// File: contracts\\interfaces\\IAvnValidatorsManager.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IAvnValidatorsManager {\n', '  event LogValidatorDepositUpdated(uint256 validatorDeposit);\n', '  event LogValidatorChallengeWindowUpdated(uint256 challengeWindowInSeconds);\n', '  event LogQuorumUpdated(uint256[2] quorum);\n', '  event LogValidatorRegistered(bytes32 indexed t1PublicKeyLHS, bytes32 indexed t1PublicKeyRHS, bytes32 indexed t2PublicKey,\n', '      uint256 validatorId);\n', '  event LogValidatorActivated(address indexed t1Address, bytes32 indexed t2PublicKey, uint256 indexed t2TransactionId,\n', '      uint256 validatorId);\n', '  event LogValidatorDeregistered(address indexed t1Address, bytes32 indexed t2PublicKey, uint256 indexed t2TransactionId,\n', '      uint256 validatorId);\n', '  event LogValidatorSlashed(address indexed t1Address, bytes32 indexed t2PublicKey, uint256 indexed t2TransactionId,\n', '      uint256 slashedAmount);\n', '  event LogValidatorDepositClaimed(address indexed t1Address);\n', '  event LogRootPublished(bytes32 indexed rootHash, uint256 indexed t2TransactionId);\n', '\n', '  function disableValidatorFunctions(bool _isDisabled) external;\n', '  function setValidatorDeposit(uint256 validatorDeposit) external;\n', '  function setValidatorChallengeWindow(uint256 challengeWindowInSeconds) external;\n', '  function setQuorum(uint256[2] calldata quorum) external;\n', '  function initialiseAvn(address[] calldata t1Address, bytes32[] calldata t1PublicKeyLHS, bytes32[] calldata t1PublicKeyRHS,\n', '      bytes32[] calldata t2PublicKey) external;\n', '  function registerValidator(bytes calldata t1PublicKey, bytes32 t2PublicKey) external;\n', '  function activateValidator(bytes32 targetT2PublicKey, uint256 t2TransactionId, bytes calldata confirmations) external;\n', '  function deregisterValidator(bytes32 targetT2PublicKey, uint256 t2TransactionId, bytes calldata confirmations) external;\n', '  function claimValidatorDeposit(bytes32 t2PublicKey) external;\n', '  function slashValidator(bytes32 targetT2PublicKey, uint256 t2TransactionId, bytes calldata confirmations) external;\n', '  function publishRoot(bytes32 rootHash, uint256 t2TransactionId, bytes calldata confirmations) external;\n', '  function retire() external;\n', '}\n', '\n', '// File: contracts\\interfaces\\IAvnStorage.sol\n', '\n', '\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IAvnStorage {\n', '  event LogStoragePermissionUpdated(address indexed publisher, bool status);\n', '\n', '  function setStoragePermission(address publisher, bool status) external;\n', '  function storeT2TransactionId(uint256 _t2TransactionId) external;\n', '  function storeT2TransactionIdAndRoot(uint256 _t2TransactionId, bytes32 rootHash) external;\n', '  function confirmLeaf(bytes32 leafHash, bytes32[] memory merklePath) external view returns (bool);\n', '}\n', '\n', '// File: contracts\\interfaces\\IAvnFTTreasury.sol\n', '\n', '\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IAvnFTTreasury {\n', '  event LogFTTreasuryPermissionUpdated(address indexed treasurer, bool status);\n', '\n', '  function setTreasurerPermission(address treasurer, bool status) external;\n', '  function getTreasurers() external view returns(address[] memory);\n', '  function unlockERC777Tokens(address token, uint256 amount, bytes calldata data) external;\n', '  function unlockERC20Tokens(address token, uint256 amount) external;\n', '}\n', '\n', '// File: contracts\\interfaces\\IERC20.sol\n', '\n', '\n', 'pragma solidity 0.7.5;\n', '\n', '// As described in https://eips.ethereum.org/EIPS/eip-20\n', 'interface IERC20 {\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '  function name() external view returns (string memory); // optional method - see eip spec\n', '  function symbol() external view returns (string memory); // optional method - see eip spec\n', '  function decimals() external view returns (uint8); // optional method - see eip spec\n', '  function totalSupply() external view returns (uint256);\n', '  function balanceOf(address owner) external view returns (uint256);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '  function approve(address spender, uint256 value) external returns (bool);\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '}\n', '\n', '// File: contracts\\Owned.sol\n', '\n', '\n', 'pragma solidity 0.7.5;\n', '\n', 'contract Owned {\n', '\n', '  address public owner = msg.sender;\n', '\n', '  event LogOwnershipTransferred(address indexed owner, address indexed newOwner);\n', '\n', '  modifier onlyOwner {\n', '    require(msg.sender == owner, "Only owner");\n', '    _;\n', '  }\n', '\n', '  function setOwner(address _owner)\n', '    external\n', '    onlyOwner\n', '  {\n', '    require(_owner != address(0), "Owner cannot be zero address");\n', '    emit LogOwnershipTransferred(owner, _owner);\n', '    owner = _owner;\n', '  }\n', '}\n', '\n', '// File: ..\\contracts\\AvnValidatorsManager.sol\n', '\n', '\n', 'pragma solidity 0.7.5;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract AvnValidatorsManager is IAvnValidatorsManager, Owned {\n', '\n', '  uint256 constant internal SIGNATURE_LENGTH = 65;\n', '\n', '  IERC20 immutable public avt;\n', '  IAvnStorage immutable public avnStorage;\n', '  IAvnFTTreasury immutable public avnFTTreasury;\n', '\n', '  uint256 public validatorDeposit;\n', '  uint256 public validatorChallengeWindowInSeconds;\n', '  uint256[2] public quorum;\n', '\n', '  uint256 public numActiveValidators;\n', '  uint256 public validatorIdNum;\n', '  bool public validatorFunctionsDisabled;\n', '  bool public avnInitialised;\n', '\n', '  // Validator data\n', '  mapping (uint256 => address) public t1Address;\n', '  mapping (uint256 => bytes32) public t2PublicKey;\n', '  mapping (uint256 => uint256) public deposit;\n', '  mapping (uint256 => bool) public isRegistered;\n', '  mapping (uint256 => bool) public isActive;\n', '  mapping (uint256 => bool) public isDeregistered;\n', '  mapping (uint256 => uint256) public challengeEnd;\n', '  mapping (address => uint256) public idByT1Address;\n', '  mapping (bytes32 => uint256) public idByT2PublicKey;\n', '\n', '  constructor(IERC20 _avt, IAvnStorage _avnStorage, IAvnFTTreasury _avnFTTreasury, uint256 _validatorDeposit,\n', '      uint256 _validatorChallengeWindowInSeconds, uint256[2] memory _quorum)\n', '  {\n', '    avt = _avt;\n', '    avnStorage = _avnStorage;\n', '    avnFTTreasury = _avnFTTreasury;\n', '    validatorDeposit = _validatorDeposit;\n', '    validatorChallengeWindowInSeconds = _validatorChallengeWindowInSeconds;\n', '    setQuorum(_quorum);\n', '    validatorIdNum = 1;\n', '  }\n', '\n', '  modifier onlyWhenValidatorFunctionsEnabled() {\n', '    require(!validatorFunctionsDisabled && avnInitialised, "Function currently disabled");\n', '    _;\n', '  }\n', '\n', '  modifier onlyUniqueTransaction(uint256 _t2TransactionId) {\n', '    avnStorage.storeT2TransactionId(_t2TransactionId);\n', '    _;\n', '  }\n', '\n', '  function disableValidatorFunctions(bool _isDisabled)\n', '    onlyOwner\n', '    external\n', '    override\n', '  {\n', '    validatorFunctionsDisabled = _isDisabled;\n', '  }\n', '\n', '  function setValidatorDeposit(uint256 _validatorDeposit)\n', '    onlyOwner\n', '    external\n', '    override\n', '  {\n', '    validatorDeposit = _validatorDeposit;\n', '    emit LogValidatorDepositUpdated(validatorDeposit);\n', '  }\n', '\n', '  function setValidatorChallengeWindow(uint256 _validatorChallengeWindowInSeconds)\n', '    onlyOwner\n', '    external\n', '    override\n', '  {\n', '    validatorChallengeWindowInSeconds = _validatorChallengeWindowInSeconds;\n', '    emit LogValidatorChallengeWindowUpdated(_validatorChallengeWindowInSeconds);\n', '  }\n', '\n', '  function initialiseAvn(address[] calldata _t1Address, bytes32[] calldata _t1PublicKeyLHS, bytes32[] calldata _t1PublicKeyRHS,\n', '      bytes32[] calldata _t2PublicKey)\n', '    onlyOwner\n', '    external\n', '    override\n', '  {\n', '    require(!avnInitialised, "AVN already initialised");\n', '    require(_t1Address.length == _t1PublicKeyLHS.length && _t1PublicKeyLHS.length == _t1PublicKeyRHS.length\n', '        && _t1PublicKeyRHS.length == _t2PublicKey.length, "Validator keys missing");\n', '\n', '    uint256 targetId;\n', '    bytes memory t1PublicKey;\n', '\n', '    for (uint256 i; i < _t1Address.length; i++) {\n', '      t1PublicKey = abi.encodePacked(_t1PublicKeyLHS[i], _t1PublicKeyRHS[i]);\n', '      doRegisterValidator(_t1Address[i], t1PublicKey, _t2PublicKey[i]);\n', '      targetId = idByT1Address[_t1Address[i]];\n', '      isActive[targetId] = true;\n', '      numActiveValidators++;\n', '      emit LogValidatorActivated(_t1Address[i], _t2PublicKey[i], 0, targetId);\n', '    }\n', '\n', '    avnInitialised = true;\n', '  }\n', '\n', '  function registerValidator(bytes calldata _t1PublicKey, bytes32 _t2PublicKey)\n', '    onlyWhenValidatorFunctionsEnabled\n', '    external\n', '    override\n', '  {\n', '    doRegisterValidator(msg.sender, _t1PublicKey, _t2PublicKey);\n', '  }\n', '\n', '  function activateValidator(bytes32 _targetT2PublicKey, uint256 _t2TransactionId, bytes calldata _confirmations)\n', '    onlyWhenValidatorFunctionsEnabled\n', '    onlyUniqueTransaction(_t2TransactionId)\n', '    external\n', '    override\n', '  {\n', '    uint256 targetId = idByT2PublicKey[_targetT2PublicKey];\n', '    require(!isActive[targetId], "Target already active");\n', '    require(isRegistered[targetId], "Target must be registered");\n', '    verifyConfirmations(toConfirmationHash(_targetT2PublicKey, _t2TransactionId), _confirmations);\n', '    isActive[targetId] = true;\n', '    numActiveValidators++;\n', '    emit LogValidatorActivated(t1Address[targetId], _targetT2PublicKey, _t2TransactionId, targetId);\n', '  }\n', '\n', '  function deregisterValidator(bytes32 _targetT2PublicKey, uint256 _t2TransactionId, bytes calldata _confirmations)\n', '    onlyWhenValidatorFunctionsEnabled\n', '    onlyUniqueTransaction(_t2TransactionId)\n', '    external\n', '    override\n', '  {\n', '    uint256 targetId = idByT2PublicKey[_targetT2PublicKey];\n', '    require(isRegistered[targetId], "Target not currently registered");\n', '    deregisterAndDeactivateValidator(targetId);\n', '    verifyConfirmations(toConfirmationHash(_targetT2PublicKey, _t2TransactionId), _confirmations);\n', '    challengeEnd[targetId] = block.timestamp + validatorChallengeWindowInSeconds;\n', '    emit LogValidatorDeregistered(t1Address[targetId], _targetT2PublicKey, _t2TransactionId, targetId);\n', '  }\n', '\n', '  function claimValidatorDeposit(bytes32 _t2PublicKey)\n', '    onlyWhenValidatorFunctionsEnabled\n', '    external\n', '    override\n', '  {\n', '    uint256 id = idByT2PublicKey[_t2PublicKey];\n', '    uint256 lockedDeposit = deposit[id];\n', '\n', '    require(lockedDeposit != 0, "Has no deposit");\n', "    require(isDeregistered[id] == true, 'Must be deregistered first');\n", '    require(challengeEnd[id] <= block.timestamp, "Cannot withdraw yet");\n', '    deposit[id] = 0;\n', '    challengeEnd[id] = 0;\n', '    unlockAVTFromTreasuryAndTransfer(t1Address[id], lockedDeposit);\n', '    emit LogValidatorDepositClaimed(t1Address[id]);\n', '  }\n', '\n', '  function slashValidator(bytes32 _targetT2PublicKey, uint256 _t2TransactionId, bytes calldata _confirmations)\n', '    onlyWhenValidatorFunctionsEnabled\n', '    onlyUniqueTransaction(_t2TransactionId)\n', '    external\n', '    override\n', '  {\n', '    uint256 targetId = idByT2PublicKey[_targetT2PublicKey];\n', '    require(targetId != 0, "Validator does not exist");\n', '\n', '    deregisterAndDeactivateValidator(targetId);\n', '    verifyConfirmations(toConfirmationHash(_targetT2PublicKey, _t2TransactionId), _confirmations);\n', '    uint256 lockedDeposit = deposit[targetId];\n', '    deposit[targetId] = 0;\n', '    challengeEnd[targetId] = 0;\n', '    unlockAVTFromTreasuryAndTransfer(owner, lockedDeposit);\n', '    emit LogValidatorSlashed(t1Address[targetId], _targetT2PublicKey, _t2TransactionId, lockedDeposit);\n', '  }\n', '\n', '  function publishRoot(bytes32 _rootHash, uint256 _t2TransactionId, bytes calldata _confirmations)\n', '    onlyWhenValidatorFunctionsEnabled\n', '    external\n', '    override\n', '  {\n', '    avnStorage.storeT2TransactionIdAndRoot(_t2TransactionId, _rootHash);\n', '    verifyConfirmations(toConfirmationHash(_rootHash, _t2TransactionId), _confirmations);\n', '    emit LogRootPublished(_rootHash, _t2TransactionId);\n', '  }\n', '\n', '  function retire()\n', '    onlyOwner\n', '    external\n', '    override\n', '  {\n', '    selfdestruct(payable(owner));\n', '  }\n', '\n', '  function setQuorum(uint256[2] memory _quorum)\n', '    onlyOwner\n', '    public\n', '    override\n', '  {\n', '    require(_quorum[1] != 0, "Invalid: div by zero");\n', '    require(_quorum[0] <= _quorum[1], "Invalid: above 100%");\n', '    quorum = _quorum;\n', '    emit LogQuorumUpdated(quorum);\n', '  }\n', '\n', '  function doRegisterValidator(address _t1Address, bytes memory _t1PublicKey, bytes32 _t2PublicKey)\n', '    private\n', '  {\n', '    uint256 id = idByT1Address[_t1Address];\n', '    require(!isRegistered[id], "Already registered");\n', '    checkT1PublicKey(_t1Address, _t1PublicKey);\n', '\n', '    if (isDeregistered[id]) {\n', '      require(t2PublicKey[id] == _t2PublicKey, "Cannot change T2 public key");\n', '      uint256 existingDeposit = deposit[id];\n', '      deposit[id] = validatorDeposit;\n', '      isRegistered[id] = true;\n', '      isDeregistered[id] = false;\n', '      challengeEnd[id] = 0;\n', '      if (existingDeposit > validatorDeposit) {\n', '        unlockAVTFromTreasuryAndTransfer(_t1Address, existingDeposit - validatorDeposit);\n', '      } else if (existingDeposit < validatorDeposit) {\n', '        lockAVTInTreasury(_t1Address, validatorDeposit - existingDeposit);\n', '      }\n', '    } else {\n', '      require(idByT2PublicKey[_t2PublicKey] == 0, "T2 public key already associated");\n', '      lockAVTInTreasury(_t1Address, validatorDeposit);\n', '      id = validatorIdNum;\n', '      idByT1Address[_t1Address] = id;\n', '      isRegistered[id] = true;\n', '      t1Address[id] = _t1Address;\n', '      t2PublicKey[id] = _t2PublicKey;\n', '      deposit[id] = validatorDeposit;\n', '      idByT2PublicKey[_t2PublicKey] = id;\n', '      validatorIdNum++;\n', '    }\n', '\n', '    bytes memory t1PublicKey = _t1PublicKey;\n', '    bytes32 t1PublicKeyLHS;\n', '    bytes32 t1PublicKeyRHS;\n', '\n', '    assembly {\n', '      t1PublicKeyLHS := mload(add(t1PublicKey, 0x20))\n', '      t1PublicKeyRHS := mload(add(t1PublicKey, 0x40))\n', '    }\n', '\n', '    emit LogValidatorRegistered(t1PublicKeyLHS, t1PublicKeyRHS, _t2PublicKey, id);\n', '  }\n', '\n', '  function unlockAVTFromTreasuryAndTransfer(address _recipient, uint256 _amount)\n', '    private\n', '  {\n', '    avnFTTreasury.unlockERC20Tokens(address(avt), _amount);\n', '    assert(avt.transfer(_recipient, _amount));\n', '  }\n', '\n', '  function lockAVTInTreasury(address _t1Address, uint256 _amount)\n', '    private\n', '  {\n', "    require(avt.balanceOf(_t1Address) >= _amount, 'Insufficient AVT funds');\n", "    require(avt.allowance(_t1Address, address(this)) >= _amount, 'AVT amount requires approval');\n", '    assert(avt.transferFrom(_t1Address, address(this), _amount));\n', '    // locks the AVT in the treasury\n', '    assert(avt.transfer(address(avnFTTreasury), _amount));\n', '  }\n', '\n', '  function toConfirmationHash(bytes32 _data, uint256 _t2TransactionId)\n', '    private\n', '    view\n', '    returns (bytes32)\n', '  {\n', '    return keccak256(abi.encode(_data, _t2TransactionId, t2PublicKey[idByT1Address[msg.sender]]));\n', '  }\n', '\n', '  function verifyConfirmations(bytes32 _msgHash, bytes memory _confirmations)\n', '    private\n', '    view\n', '  {\n', '    require(isActive[idByT1Address[msg.sender]], "Must be an active validator");\n', '    bytes32 ethSignedPrefixMsgHash = keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", _msgHash));\n', '    uint256 numConfirmations = _confirmations.length / SIGNATURE_LENGTH;\n', '    uint256 requiredConfirmations = numActiveValidators * quorum[0] / quorum[1] + 1;\n', '    uint256 validConfirmations;\n', '    uint256 id;\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '    bool[] memory confirmed = new bool[](validatorIdNum);\n', '\n', '    for (uint256 i; i < numConfirmations; i++) {\n', '      assembly {\n', '        let offset := mul(i, SIGNATURE_LENGTH)\n', '        r := mload(add(_confirmations, add(0x20, offset)))\n', '        s := mload(add(_confirmations, add(0x40, offset)))\n', '        v := byte(0, mload(add(_confirmations, add(0x60, offset))))\n', '      }\n', '      if (v < 27) v += 27;\n', '      if (v != 27 && v != 28 || uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0)\n', '        continue;\n', '      else {\n', '        id = idByT1Address[ecrecover(ethSignedPrefixMsgHash, v, r, s)];\n', '        if (isActive[id] && !confirmed[id]) {\n', '          if (++validConfirmations == requiredConfirmations) break;\n', '          confirmed[id] = true;\n', '        }\n', '      }\n', '    }\n', '\n', '    require(validConfirmations == requiredConfirmations, "Invalid confirmations");\n', '  }\n', '\n', '  function checkT1PublicKey(address _t1Address, bytes memory _t1PublicKey)\n', '    private\n', '    pure\n', '  {\n', '    require(_t1PublicKey.length == 64, "T1 public key must be 64 bytes");\n', '    require(address(bytes20(uint160(uint256(keccak256(abi.encodePacked(_t1PublicKey)))))) == _t1Address, "Bad T1 public key");\n', '  }\n', '\n', '  function deregisterAndDeactivateValidator(uint256 _targetId)\n', '    private\n', '  {\n', '    isRegistered[_targetId] = false;\n', '    isDeregistered[_targetId] = true;\n', '    if (isActive[_targetId]) {\n', '      isActive[_targetId] = false;\n', '      numActiveValidators--;\n', '    }\n', '  }\n', '}']