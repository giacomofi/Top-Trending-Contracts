['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-01-30\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '    // SPDX-License-Identifier: No License\n', '\n', '    /**\n', '    * @title SafeMath\n', '    * @dev Math operations with safety checks that throw on error\n', '    */\n', '    library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a * b;\n', '        assert(a == 0 || c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '    }\n', '\n', '    /**\n', '    * @dev Library for managing\n', '    * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n', '    * types.\n', '    *\n', '    * Sets have the following properties:\n', '    *\n', '    * - Elements are added, removed, and checked for existence in constant time\n', '    * (O(1)).\n', '    * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n', '    *\n', '    * ```\n', '    * contract Example {\n', '    *     // Add the library methods\n', '    *     using EnumerableSet for EnumerableSet.AddressSet;\n', '    *\n', '    *     // Declare a set state variable\n', '    *     EnumerableSet.AddressSet private mySet;\n', '    * }\n', '    * ```\n', '    *\n', '    * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n', '    * (`UintSet`) are supported.\n', '    */\n', '    library EnumerableSet {\n', '        \n', '\n', '        struct Set {\n', '        \n', '            bytes32[] _values;\n', '    \n', '            mapping (bytes32 => uint256) _indexes;\n', '        }\n', '    \n', '        function _add(Set storage set, bytes32 value) private returns (bool) {\n', '            if (!_contains(set, value)) {\n', '                set._values.push(value);\n', '                \n', '                set._indexes[value] = set._values.length;\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        /**\n', '        * @dev Removes a value from a set. O(1).\n', '        *\n', '        * Returns true if the value was removed from the set, that is if it was\n', '        * present.\n', '        */\n', '        function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "            // We read and store the value's index to prevent multiple reads from the same storage slot\n", '            uint256 valueIndex = set._indexes[value];\n', '\n', '            if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '                \n', '\n', '                uint256 toDeleteIndex = valueIndex - 1;\n', '                uint256 lastIndex = set._values.length - 1;\n', '\n', '            \n', '                bytes32 lastvalue = set._values[lastIndex];\n', '\n', '                set._values[toDeleteIndex] = lastvalue;\n', '                set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '                set._values.pop();\n', '\n', '                delete set._indexes[value];\n', '\n', '                return true;\n', '            } else {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        \n', '        function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '            return set._indexes[value] != 0;\n', '        }\n', '\n', '        \n', '        function _length(Set storage set) private view returns (uint256) {\n', '            return set._values.length;\n', '        }\n', '\n', '    \n', '        function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '            require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '            return set._values[index];\n', '        }\n', '\n', '        \n', '\n', '        struct AddressSet {\n', '            Set _inner;\n', '        }\n', '    \n', '        function add(AddressSet storage set, address value) internal returns (bool) {\n', '            return _add(set._inner, bytes32(uint256(value)));\n', '        }\n', '\n', '    \n', '        function remove(AddressSet storage set, address value) internal returns (bool) {\n', '            return _remove(set._inner, bytes32(uint256(value)));\n', '        }\n', '\n', '        \n', '        function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '            return _contains(set._inner, bytes32(uint256(value)));\n', '        }\n', '\n', '    \n', '        function length(AddressSet storage set) internal view returns (uint256) {\n', '            return _length(set._inner);\n', '        }\n', '    \n', '        function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '            return address(uint256(_at(set._inner, index)));\n', '        }\n', '\n', '\n', '    \n', '        struct UintSet {\n', '            Set _inner;\n', '        }\n', '\n', '        \n', '        function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '            return _add(set._inner, bytes32(value));\n', '        }\n', '\n', '    \n', '        function remove(UintSet storage set, uint256 value) internal returns (bool) {\n', '            return _remove(set._inner, bytes32(value));\n', '        }\n', '\n', '        \n', '        function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n', '            return _contains(set._inner, bytes32(value));\n', '        }\n', '\n', '        \n', '        function length(UintSet storage set) internal view returns (uint256) {\n', '            return _length(set._inner);\n', '        }\n', '\n', '    \n', '        function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n', '            return uint256(_at(set._inner, index));\n', '        }\n', '    }\n', '    \n', '    contract Ownable {\n', '    address public owner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    \n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    \n', '    function transferOwnership(address newOwner) onlyOwner public {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '    }\n', '\n', '\n', '    interface Token {\n', '        function transferFrom(address, address, uint) external returns (bool);\n', '        function transfer(address, uint) external returns (bool);\n', '        function balanceOf(address) external view returns (uint256);\n', '    }\n', '\n', '    contract GCBVault is Ownable {\n', '        using SafeMath for uint;\n', '        using EnumerableSet for EnumerableSet.AddressSet;\n', '        \n', '         uint public  vaultClose = 1e21;\n', '         constructor(uint endTime) public {\n', '            vaultClose = endTime;\n', '        }\n', '    \n', '\n', '        // GCB token contract address\n', '        address public constant tokenAddress = 0x3539a4F4C0dFfC813B75944821e380C9209D3446;\n', '        \n', '        uint public oneVaultLimit = 6e20;\n', '        uint public fourVaultLimit = 6e20;\n', '\n', '        uint public  oneCliff = 30 days;\n', '        \n', '        uint public  fourthCliff = 120 days;\n', '\n', '        uint public  vaultTotal = 0;\n', '        \n', '        mapping(address => uint) public onemonth;\n', '        \n', '        mapping(address => uint) public onemonthCliff;\n', '        \n', '         mapping(address => uint) public claimed;\n', '        \n', '        mapping(address => uint) public fourmonth;\n', '        \n', '        mapping(address => uint) public fourmonthCliff;\n', '        \n', '        event DepositAdded(address indexed user,uint amount );\n', '            \n', '        event VaultClaimed(address indexed user, uint amount );\n', '    \n', '\n', '        \n', '        function oneDeposit(uint _amount) public  returns (bool)   {\n', '                    \n', '                    uint amount = _amount.sub(_amount.mul(350).div(1e4));\n', '                    require(oneVaultLimit >= amount , "Can\'t deposit more than limit") ;\n', '\n', '                    require(vaultClose > now , "Can\'t deposit now") ;\n', '\n', '                    Token(tokenAddress).transferFrom(msg.sender , address(this), _amount);\n', '                    \n', '                    onemonth[msg.sender] =  onemonth[msg.sender].add(amount) ;\n', '                    \n', '                    vaultTotal = vaultTotal.add(amount) ;\n', '\n', '                    onemonthCliff[msg.sender] = now + oneCliff ;\n', '                    \n', '                    oneVaultLimit = oneVaultLimit.sub(amount) ;\n', '                    \n', '                    emit DepositAdded(msg.sender,amount);\n', '                               \n', '                    return true ;\n', '\n', '            }\n', '            \n', '              function fourDeposit(uint _amount) public  returns (bool)   {\n', '\n', '                    uint amount = _amount.sub(_amount.mul(350).div(1e4));\n', '                    \n', '                    require(fourVaultLimit >= amount , "Can\'t deposit more than limit") ;\n', '\n', '\n', '                    require(vaultClose > now , "Can\'t deposit now") ;\n', '\n', '                    Token(tokenAddress).transferFrom(msg.sender , address(this), _amount);\n', '                    \n', '                    fourmonth[msg.sender] =  fourmonth[msg.sender].add(amount) ;\n', '                    \n', '                    vaultTotal = vaultTotal.add(amount) ;\n', '\n', '                    fourmonthCliff[msg.sender] = now + fourthCliff ;\n', '                   \n', '                    fourVaultLimit = fourVaultLimit.sub(amount);\n', '                     \n', '                    emit DepositAdded(msg.sender,amount);\n', '                               \n', '                    return true ;\n', '\n', '            }\n', '        \n', '       \n', '        function claim() public returns (uint)  {\n', '            \n', '            uint returnAmt = getTotalReturn(msg.sender) ;\n', '            \n', '            require(returnAmt > 0, "Cannot claim 0 or less");\n', '            \n', '            Token(tokenAddress).transfer(msg.sender, returnAmt);\n', '          \n', '            emit VaultClaimed(msg.sender,returnAmt);\n', '            \n', '            claimed[msg.sender] = claimed[msg.sender].add(returnAmt) ;\n', '            \n', '            if(onemonthCliff[msg.sender] < now ){\n', '              oneVaultLimit = oneVaultLimit.add(onemonth[msg.sender]);\n', '              vaultTotal = vaultTotal.sub(onemonth[msg.sender]) ;\n', '\n', '              onemonth[msg.sender] =  0 ;\n', '              onemonthCliff[msg.sender] =  0 ;\n', '            }\n', '\n', '            if(fourmonthCliff[msg.sender] < now){\n', '              fourVaultLimit = fourVaultLimit.add(fourmonth[msg.sender]);\n', '              vaultTotal = vaultTotal.sub(fourmonth[msg.sender]) ;\n', '\n', '            fourmonth[msg.sender] =  0 ;\n', '            fourmonthCliff[msg.sender] = 0 ;\n', '            }\n', '\n', '\n', '        }\n', '          \n', '        function getOneReturn(address _user) view public returns ( uint  ) {\n', '                        \n', '                        \n', '                        uint oneR = 0 ;\n', '                        if(onemonthCliff[_user] < now ){\n', '                              oneR = onemonth[_user].add(onemonth[_user].mul(4200).div(1e4));\n', '                        }\n', '                       \n', '                        return oneR ;\n', '        }\n', '        \n', '          function getFourReturn(address _user) view public returns ( uint  ) {\n', '                     \n', '                        uint fourR = 0 ;\n', '                        if(fourmonthCliff[_user] < now){\n', '                             fourR = fourmonth[_user].add(fourmonth[_user].mul(24500).div(1e4));\n', '                        }\n', '                       \n', '                        return fourR ;\n', '        }\n', '\n', '        function getTotalReturn(address _user) view public returns ( uint  ) {\n', '                        \n', '                        uint oneR = 0 ;\n', '                        if(onemonthCliff[_user] < now ){\n', '                              oneR = onemonth[_user].add(onemonth[_user].mul(4200).div(1e4));\n', '                        }\n', '                        \n', '                        uint fourR = 0 ;\n', '                        if(fourmonthCliff[_user] < now){\n', '                             fourR = fourmonth[_user].add(fourmonth[_user].mul(24500).div(1e4));\n', '                        }\n', '                        uint total = oneR + fourR ;\n', '                        return total ;\n', '        }\n', '        \n', '        function getClaimeReturn(address _user) view public returns ( uint  ) {\n', '                        return claimed[_user];\n', '        }\n', '          \n', '          \n', '        function updateCliff(uint one, uint four)  public onlyOwner returns ( bool  ) {\n', '                        oneCliff = one ;\n', '                        fourthCliff = four;\n', '                        return true;\n', '        }\n', '\n', '        function updateVaultClose(uint _vaultClose)  public onlyOwner returns ( bool  ) {                        \n', '                        vaultClose = _vaultClose;\n', '                        return true;\n', '        }\n', '        \n', '          \n', '         \n', '        function withdrawToken(uint amount) public onlyOwner {\n', '            require(Token(tokenAddress).transfer(msg.sender, amount), "Cannot withdraw balance!");\n', '            \n', '        }   \n', '    \n', ' \n', '        function addContractBalance(uint amount) public {\n', '            require(Token(tokenAddress).transferFrom(msg.sender, address(this), amount), "Cannot add balance!");\n', '            \n', '        }\n', ' \n', '    \n', '\n', '    }']