['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-17\n', '*/\n', '\n', '// File: contracts/SafeMath.sol\n', 'pragma solidity ^0.6.12;\n', '\n', '// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n', '// Subject to the MIT license.\n', '\n', '/**\n', " * @title BiFi's safe-math Contract\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'library SafeMath {\n', '  uint256 internal constant unifiedPoint = 10 ** 18;\n', '\t/******************** Safe Math********************/\n', '\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tuint256 c = a + b;\n', '\t\trequire(c >= a, "a");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _sub(a, b, "s");\n', '\t}\n', '\n', '\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _mul(a, b);\n', '\t}\n', '\n', '\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(a, b, "d");\n', '\t}\n', '\n', '\tfunction _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b <= a, errorMessage);\n', '\t\treturn a - b;\n', '\t}\n', '\n', '\tfunction _mul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\tif (a == 0)\n', '\t\t{\n', '\t\t\treturn 0;\n', '\t\t}\n', '\n', '\t\tuint256 c = a* b;\n', '\t\trequire((c / a) == b, "m");\n', '\t\treturn c;\n', '\t}\n', '\n', '\tfunction _div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256)\n', '\t{\n', '\t\trequire(b > 0, errorMessage);\n', '\t\treturn a / b;\n', '\t}\n', '\n', '\tfunction unifiedDiv(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, unifiedPoint), b, "d");\n', '\t}\n', '\n', '\tfunction unifiedMul(uint256 a, uint256 b) internal pure returns (uint256)\n', '\t{\n', '\t\treturn _div(_mul(a, b), unifiedPoint, "m");\n', '\t}\n', '}\n', '\n', '// File: contracts/interfaces/IManagerDataStorage.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's manager data storage interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IManagerDataStorage  {\n', '\tfunction getGlobalRewardPerBlock() external view returns (uint256);\n', '\tfunction setGlobalRewardPerBlock(uint256 _globalRewardPerBlock) external returns (bool);\n', '\n', '\tfunction getGlobalRewardDecrement() external view returns (uint256);\n', '\tfunction setGlobalRewardDecrement(uint256 _globalRewardDecrement) external returns (bool);\n', '\n', '\tfunction getGlobalRewardTotalAmount() external view returns (uint256);\n', '\tfunction setGlobalRewardTotalAmount(uint256 _globalRewardTotalAmount) external returns (bool);\n', '\n', '\tfunction getAlphaRate() external view returns (uint256);\n', '\tfunction setAlphaRate(uint256 _alphaRate) external returns (bool);\n', '\n', '\tfunction getAlphaLastUpdated() external view returns (uint256);\n', '\tfunction setAlphaLastUpdated(uint256 _alphaLastUpdated) external returns (bool);\n', '\n', '\tfunction getRewardParamUpdateRewardPerBlock() external view returns (uint256);\n', '\tfunction setRewardParamUpdateRewardPerBlock(uint256 _rewardParamUpdateRewardPerBlock) external returns (bool);\n', '\n', '\tfunction getRewardParamUpdated() external view returns (uint256);\n', '\tfunction setRewardParamUpdated(uint256 _rewardParamUpdated) external returns (bool);\n', '\n', '\tfunction getInterestUpdateRewardPerblock() external view returns (uint256);\n', '\tfunction setInterestUpdateRewardPerblock(uint256 _interestUpdateRewardPerblock) external returns (bool);\n', '\n', '\tfunction getInterestRewardUpdated() external view returns (uint256);\n', '\tfunction setInterestRewardUpdated(uint256 _interestRewardLastUpdated) external returns (bool);\n', '\n', '\tfunction setTokenHandler(uint256 handlerID, address handlerAddr) external returns (bool);\n', '\n', '\tfunction getTokenHandlerInfo(uint256 handlerID) external view returns (bool, address);\n', '\n', '\tfunction getTokenHandlerID(uint256 index) external view returns (uint256);\n', '\n', '\tfunction getTokenHandlerAddr(uint256 handlerID) external view returns (address);\n', '\tfunction setTokenHandlerAddr(uint256 handlerID, address handlerAddr) external returns (bool);\n', '\n', '\tfunction getTokenHandlerExist(uint256 handlerID) external view returns (bool);\n', '\tfunction setTokenHandlerExist(uint256 handlerID, bool exist) external returns (bool);\n', '\n', '\tfunction getTokenHandlerSupport(uint256 handlerID) external view returns (bool);\n', '\tfunction setTokenHandlerSupport(uint256 handlerID, bool support) external returns (bool);\n', '\n', '\tfunction setLiquidationManagerAddr(address _liquidationManagerAddr) external returns (bool);\n', '\tfunction getLiquidationManagerAddr() external view returns (address);\n', '\n', '\tfunction setManagerAddr(address _managerAddr) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IOracleProxy.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's oracle proxy interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IOracleProxy  {\n', '\tfunction getTokenPrice(uint256 tokenID) external view returns (uint256);\n', '\n', '\tfunction getOracleFeed(uint256 tokenID) external view returns (address, uint256);\n', '\tfunction setOracleFeed(uint256 tokenID, address feedAddr, uint256 decimals, bool needPriceConvert, uint256 priceConvertID) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '// from: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n', 'pragma solidity 0.6.12;\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external ;\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external ;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/interfaces/IObserver.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's Observer interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IObserver {\n', '    function getAlphaBaseAsset() external view returns (uint256[] memory);\n', '    function setChainGlobalRewardPerblock(uint256 _idx, uint256 globalRewardPerBlocks) external returns (bool);\n', '    function updateChainMarketInfo(uint256 _idx, uint256 chainDeposit, uint256 chainBorrow) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IProxy.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's proxy interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IProxy  {\n', '\tfunction handlerProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction handlerViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '\tfunction siProxy(bytes memory data) external returns (bool, bytes memory);\n', '\tfunction siViewProxy(bytes memory data) external view returns (bool, bytes memory);\n', '}\n', '\n', '// File: contracts/interfaces/IMarketHandler.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's market handler interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IMarketHandler  {\n', '\tfunction setCircuitBreaker(bool _emergency) external returns (bool);\n', '\tfunction setCircuitBreakWithOwner(bool _emergency) external returns (bool);\n', '\n', '\tfunction getTokenName() external view returns (string memory);\n', '\n', '\tfunction ownershipTransfer(address payable newOwner) external returns (bool);\n', '\n', '\tfunction deposit(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\tfunction withdraw(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction borrow(uint256 unifiedTokenAmount, bool allFlag) external returns (bool);\n', '\tfunction repay(uint256 unifiedTokenAmount, bool allFlag) external payable returns (bool);\n', '\n', '\tfunction executeFlashloan(\n', '\t\taddress receiverAddress,\n', '\t\tuint256 amount\n', '  ) external returns (bool);\n', '\n', '\tfunction depositFlashloanFee(\n', '\t\tuint256 amount\n', '\t) external returns (bool);\n', '\n', '  function convertUnifiedToUnderlying(uint256 unifiedTokenAmount) external view returns (uint256);\n', '\tfunction partialLiquidationUser(address payable delinquentBorrower, uint256 liquidateAmount, address payable liquidator, uint256 rewardHandlerID) external returns (uint256, uint256, uint256);\n', '\tfunction partialLiquidationUserReward(address payable delinquentBorrower, uint256 liquidationAmountWithReward, address payable liquidator) external returns (uint256);\n', '\n', '\tfunction getTokenHandlerLimit() external view returns (uint256, uint256);\n', '  function getTokenHandlerBorrowLimit() external view returns (uint256);\n', '\tfunction getTokenHandlerMarginCallLimit() external view returns (uint256);\n', '\tfunction setTokenHandlerBorrowLimit(uint256 borrowLimit) external returns (bool);\n', '\tfunction setTokenHandlerMarginCallLimit(uint256 marginCallLimit) external returns (bool);\n', '\n', '  function getTokenLiquidityAmountWithInterest(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction getUserAmountWithInterest(address payable userAddr) external view returns (uint256, uint256);\n', '\tfunction getUserAmount(address payable userAddr) external view returns (uint256, uint256);\n', '\n', '\tfunction getUserMaxBorrowAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxWithdrawAmount(address payable userAddr) external view returns (uint256);\n', '\tfunction getUserMaxRepayAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction checkFirstAction() external returns (bool);\n', '\tfunction applyInterest(address payable userAddr) external returns (uint256, uint256);\n', '\n', '\tfunction reserveDeposit(uint256 unifiedTokenAmount) external payable returns (bool);\n', '\tfunction reserveWithdraw(uint256 unifiedTokenAmount) external returns (bool);\n', '\n', '\tfunction withdrawFlashloanFee(uint256 unifiedTokenAmount) external returns (bool);\n', '\n', '\tfunction getDepositTotalAmount() external view returns (uint256);\n', '\tfunction getBorrowTotalAmount() external view returns (uint256);\n', '\n', '\tfunction getSIRandBIR() external view returns (uint256, uint256);\n', '\n', '  function getERC20Addr() external view returns (address);\n', '}\n', '\n', '// File: contracts/interfaces/IServiceIncentive.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's si interface\n", ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'interface IServiceIncentive  {\n', '\tfunction setCircuitBreakWithOwner(bool emergency) external returns (bool);\n', '\tfunction setCircuitBreaker(bool emergency) external returns (bool);\n', '\n', '\tfunction updateRewardPerBlockLogic(uint256 _rewardPerBlock) external returns (bool);\n', '\tfunction updateRewardLane(address payable userAddr) external returns (bool);\n', '\n', '\tfunction getBetaRateBaseTotalAmount() external view returns (uint256);\n', '\tfunction getBetaRateBaseUserAmount(address payable userAddr) external view returns (uint256);\n', '\n', '\tfunction getMarketRewardInfo() external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction getUserRewardInfo(address payable userAddr) external view returns (uint256, uint256, uint256);\n', '\n', '\tfunction claimRewardAmountUser(address payable userAddr) external returns (uint256);\n', '}\n', '\n', '// File: contracts/Errors.sol\n', 'pragma solidity 0.6.12;\n', '\n', 'contract Modifier {\n', '    string internal constant ONLY_OWNER = "O";\n', '    string internal constant ONLY_MANAGER = "M";\n', '    string internal constant CIRCUIT_BREAKER = "emergency";\n', '}\n', '\n', 'contract ManagerModifier is Modifier {\n', '    string internal constant ONLY_HANDLER = "H";\n', '    string internal constant ONLY_LIQUIDATION_MANAGER = "LM";\n', '    string internal constant ONLY_BREAKER = "B";\n', '}\n', '\n', 'contract HandlerDataStorageModifier is Modifier {\n', '    string internal constant ONLY_BIFI_CONTRACT = "BF";\n', '}\n', '\n', 'contract SIDataStorageModifier is Modifier {\n', '    string internal constant ONLY_SI_HANDLER = "SI";\n', '}\n', '\n', 'contract HandlerErrors is Modifier {\n', '    string internal constant USE_VAULE = "use value";\n', '    string internal constant USE_ARG = "use arg";\n', '    string internal constant EXCEED_LIMIT = "exceed limit";\n', '    string internal constant NO_LIQUIDATION = "no liquidation";\n', '    string internal constant NO_LIQUIDATION_REWARD = "no enough reward";\n', '    string internal constant NO_EFFECTIVE_BALANCE = "not enough balance";\n', '    string internal constant TRANSFER = "err transfer";\n', '}\n', '\n', 'contract SIErrors is Modifier { }\n', '\n', 'contract InterestErrors is Modifier { }\n', '\n', 'contract LiquidationManagerErrors is Modifier {\n', '    string internal constant NO_DELINQUENT = "not delinquent";\n', '}\n', '\n', 'contract ManagerErrors is ManagerModifier {\n', '    string internal constant REWARD_TRANSFER = "RT";\n', '    string internal constant UNSUPPORTED_TOKEN = "UT";\n', '}\n', '\n', 'contract OracleProxyErrors is Modifier {\n', '    string internal constant ZERO_PRICE = "price zero";\n', '}\n', '\n', 'contract RequestProxyErrors is Modifier { }\n', '\n', 'contract ManagerDataStorageErrors is ManagerModifier {\n', '    string internal constant NULL_ADDRESS = "err addr null";\n', '}\n', '\n', '// File: contracts/marketManager/ManagerSlot.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', " * @title BiFi's Slot contract\n", ' * @notice Manager Slot Definitions & Allocations\n', ' * @author BiFi(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', ' */\n', 'contract ManagerSlot is ManagerErrors {\n', '\tusing SafeMath for uint256;\n', '\n', '\taddress public owner;\n', '\tmapping(address => bool) operators;\n', '\tmapping(address => Breaker) internal breakerTable;\n', '\n', '\tbool public emergency = false;\n', '\n', '\tIManagerDataStorage internal dataStorageInstance;\n', '\tIOracleProxy internal oracleProxy;\n', '\n', '\t/* feat: manager reward token instance*/\n', '\tIERC20 internal rewardErc20Instance;\n', '\n', '\tIObserver public Observer;\n', '\n', '\taddress public slotSetterAddr;\n', '\taddress public handlerManagerAddr;\n', '\taddress public flashloanAddr;\n', '\n', '  // BiFi-X\n', '  address public positionStorageAddr;\n', '  address public nftAddr;\n', '\n', '\tuint256 public tokenHandlerLength;\n', '\n', '  struct FeeRateParams {\n', '    uint256 unifiedPoint;\n', '    uint256 minimum;\n', '    uint256 slope;\n', '    uint256 discountRate;\n', '  }\n', '\n', '  struct HandlerFlashloan {\n', '      uint256 flashFeeRate;\n', '      uint256 discountBase;\n', '      uint256 feeTotal;\n', '  }\n', '\n', '  mapping(uint256 => HandlerFlashloan) public handlerFlashloan;\n', '\n', '\tstruct UserAssetsInfo {\n', '\t\tuint256 depositAssetSum;\n', '\t\tuint256 borrowAssetSum;\n', '\t\tuint256 marginCallLimitSum;\n', '\t\tuint256 depositAssetBorrowLimitSum;\n', '\t\tuint256 depositAsset;\n', '\t\tuint256 borrowAsset;\n', '\t\tuint256 price;\n', '\t\tuint256 callerPrice;\n', '\t\tuint256 depositAmount;\n', '\t\tuint256 borrowAmount;\n', '\t\tuint256 borrowLimit;\n', '\t\tuint256 marginCallLimit;\n', '\t\tuint256 callerBorrowLimit;\n', '\t\tuint256 userBorrowableAsset;\n', '\t\tuint256 withdrawableAsset;\n', '\t}\n', '\n', '\tstruct Breaker {\n', '\t\tbool auth;\n', '\t\tbool tried;\n', '\t}\n', '\n', '\tstruct ContractInfo {\n', '\t\tbool support;\n', '\t\taddress addr;\n', '    address tokenAddr;\n', '\n', '    uint256 expectedBalance;\n', '    uint256 afterBalance;\n', '\n', '\t\tIProxy tokenHandler;\n', '\t\tbytes data;\n', '\n', '\t\tIMarketHandler handlerFunction;\n', '\t\tIServiceIncentive siFunction;\n', '\n', '\t\tIOracleProxy oracleProxy;\n', '\t\tIManagerDataStorage managerDataStorage;\n', '\t}\n', '\n', '\tmodifier onlyOwner {\n', '\t\trequire(msg.sender == owner, ONLY_OWNER);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyHandler(uint256 handlerID) {\n', '\t\t_isHandler(handlerID);\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyOperators {\n', '\t\taddress payable sender = msg.sender;\n', '\t\trequire(operators[sender] || sender == owner);\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isHandler(uint256 handlerID) internal view {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == dataStorageInstance.getTokenHandlerAddr(handlerID)) || (msgSender == owner), ONLY_HANDLER);\n', '\t}\n', '\n', '\tmodifier onlyLiquidationManager {\n', '\t\t_isLiquidationManager();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isLiquidationManager() internal view {\n', '\t\taddress msgSender = msg.sender;\n', '\t\trequire((msgSender == dataStorageInstance.getLiquidationManagerAddr()) || (msgSender == owner), ONLY_LIQUIDATION_MANAGER);\n', '\t}\n', '\n', '\tmodifier circuitBreaker {\n', '\t\t_isCircuitBreak();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isCircuitBreak() internal view {\n', '\t\trequire((!emergency) || (msg.sender == owner), CIRCUIT_BREAKER);\n', '\t}\n', '\n', '\tmodifier onlyBreaker {\n', '\t\t_isBreaker();\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction _isBreaker() internal view {\n', '\t\trequire(breakerTable[msg.sender].auth, ONLY_BREAKER);\n', '\t}\n', '}\n', '\n', '// File: contracts/interfaces/IFlashloanReceiver.sol\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IFlashloanReceiver {\n', '    function executeOperation(\n', '      address reserve,\n', '      uint256 amount,\n', '      uint256 fee,\n', '      bytes calldata params\n', '    ) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/utils/Bifi-X/IPositionStorage.sol\n', 'pragma solidity 0.6.12;\n', 'interface IPositionStorage {\n', '  function createStrategy(address strategyLogic) external returns (bool);\n', '  function setStrategy(uint256 strategyID, address strategyLogic) external returns (bool);\n', '  function getStrategy(uint256 strategyID) external view returns (address);\n', '  function newUserProduct(address user, address product) external returns (bool);\n', '  function getUserProducts(address user) external view returns (address[] memory);\n', '  function setFactory(address _factory) external returns (bool);\n', '  function getNFTID(address product) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/interfaces/utils/IERC721.sol\n', 'pragma solidity 0.6.12;\n', '\n', '/**\n', ' * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\n', ' * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n', ' */\n', 'interface IERC721\n', '{\n', '\n', '  /**\n', '   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\n', '   * assigned and queryable owner not equal to the zero address.\n', '   * @return Total supply of NFTs.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   * @return Token id.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   * @return Balance of _owner.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\n', '   * considered invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   * @return Address of _tokenId owner.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  function mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  ) external ;\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\n', '   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\n', '   * representing invalid NFTs.\n', '   * @param _owner An address where we are interested in NFTs owned by them.\n', '   * @param _index A counter less than `balanceOf(_owner)`.\n', '   * @return Token id.\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '}\n', '\n', '// File: contracts/marketManager/ManagerFlashloan.sol\n', '// SPDX-License-Identifier: BSD-3-Clause\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', '* @title BiFi-X ManagerFlashloan contract\n', '* @author BiFi-X(seinmyung25, Miller-kk, tlatkdgus1, dongchangYoo)\n', '*/\n', 'contract ManagerFlashLoan is ManagerSlot {\n', '  \tevent FlashLoan(address receiver, address asset, uint256 amount, uint256 fee);\n', '\n', '    /**\n', '    * @dev Withdraw accumulated flashloan fee\n', '    * @param handlerID The ID of handler with accumulated flashloan fee\n', '    * @return Whether or not succeed\n', '    */\n', '    function withdrawFlashloanFee(uint256 handlerID) onlyOwner external returns (bool) {\n', '      ContractInfo memory handlerInfo;\n', '      (handlerInfo.support, handlerInfo.addr) = dataStorageInstance.getTokenHandlerInfo(handlerID);\n', '\n', '      if(handlerInfo.support) {\n', '        handlerInfo.tokenHandler = IProxy(handlerInfo.addr);\n', '\n', '        (bool success, ) = handlerInfo.tokenHandler.handlerProxy(\n', '              abi.encodeWithSelector(\n', '                handlerInfo.handlerFunction\n', '                .withdrawFlashloanFee.selector,\n', '                handlerFlashloan[handlerID].feeTotal\n', '              )\n', '            );\n', '        require(success);\n', '\n', '        handlerFlashloan[handlerID].feeTotal = 0;\n', '      }\n', '\n', '      return true;\n', '    }\n', '\n', '    /**\n', '    * @dev Execute flashloan\n', '    * @param handlerID The ID of the token handler to borrow.\n', '    * @param receiverAddress The address of receive callback contract\n', '    * @param amount The amount of borrow through flashloan\n', '    * @param params The encode metadata of user\n', '    * @return Whether or not succeed\n', '    */\n', '    function flashloan(\n', '      uint256 handlerID,\n', '      address receiverAddress,\n', '      uint256 amount,\n', '      bytes calldata params\n', '    ) external returns (bool) {\n', '      return _flashloan(handlerID, receiverAddress, amount, params);\n', '    }\n', '\n', '    /**\n', '    * @dev Execute flashloan\n', '    * @param handlerID The ID of the token handler to borrow.\n', '    * @param receiverAddress The address of receive callback contract\n', '    * @param amount The amount of borrow through flashloan\n', '    * @param params The encode metadata of user\n', '    * @return Whether or not succeed\n', '    */\n', '    function _flashloan(\n', '      uint256 handlerID,\n', '      address receiverAddress,\n', '      uint256 amount,\n', '      bytes calldata params\n', '    ) internal returns (bool) {\n', '        ContractInfo memory handlerInfo;\n', '        (handlerInfo.support, handlerInfo.addr) = dataStorageInstance.getTokenHandlerInfo(handlerID);\n', '\n', '        require(handlerInfo.support);\n', '        handlerInfo.tokenHandler = IProxy(handlerInfo.addr);\n', '\n', '        // receiver to be called after the eth or token send is executed\n', '        IFlashloanReceiver receiver = IFlashloanReceiver(receiverAddress);\n', '\n', '        bool success;\n', '\n', '        // get flashloan fee\n', '        uint256 fee = _getFee(handlerID, amount);\n', '\n', '        // memory before contract balance\n', '        // for successfuly repay flashloan amount and fee\n', '        (handlerInfo.tokenAddr, handlerInfo.expectedBalance) = _getThisBalance(handlerInfo, handlerID);\n', '        handlerInfo.expectedBalance = handlerInfo.expectedBalance.add(_convertUnifiedToUnderlying(handlerInfo, amount)).add(_convertUnifiedToUnderlying(handlerInfo, fee));\n', '\n', '        // send eth or token through handler\n', '        (success, handlerInfo.data) = handlerInfo.tokenHandler.handlerProxy(\n', '          abi.encodeWithSelector(\n', '            handlerInfo.handlerFunction\n', '            .executeFlashloan.selector,\n', '            receiverAddress,\n', '            amount\n', '          )\n', '        );\n', '        // catch error in handler\n', '        require(success);\n', '\n', '        // call FlashloanReceiver executeOperation function\n', '        success = receiver.executeOperation(handlerInfo.tokenAddr, _convertUnifiedToUnderlying(handlerInfo, amount), _convertUnifiedToUnderlying(handlerInfo, fee), params);\n', '        require(success);\n', '\n', '        // get contract balance after executeOperation function\n', '        (, handlerInfo.afterBalance) = _getThisBalance(handlerInfo, handlerID);\n', '\n', '        // handlerInfo.afterBalance gte than handlerInfo.expectedBalance\n', '        // If the user has not made a successful repayment, occur revert\n', '        require(handlerInfo.expectedBalance <= handlerInfo.afterBalance);\n', '\n', '        if(handlerID == 0) { // coin case\n', '          // payback: over repay amount\n', '          if(handlerInfo.expectedBalance < handlerInfo.afterBalance){\n', '            msg.sender.transfer(handlerInfo.afterBalance.sub(handlerInfo.expectedBalance));\n', '          }\n', '          // recovery liquidity\n', '          payable(handlerInfo.addr).transfer(handlerInfo.expectedBalance);\n', '\n', '\n', '        } else { // token case\n', '          IERC20 token = IERC20(handlerInfo.tokenAddr);\n', '          // payback: over repay amount\n', '          if(handlerInfo.afterBalance > handlerInfo.expectedBalance){\n', '            token.transfer(msg.sender, handlerInfo.afterBalance.sub(handlerInfo.expectedBalance));\n', '          }\n', '          // recovery liquidity\n', '          token.transfer(handlerInfo.addr, handlerInfo.expectedBalance);\n', '        }\n', '\n', '        // fee store in manager slot\n', '        handlerFlashloan[handlerID].feeTotal = handlerFlashloan[handlerID].feeTotal.add(fee);\n', '\n', '        // fee to handler reserve\n', '        (success, handlerInfo.data) = handlerInfo.tokenHandler.handlerProxy(\n', '          abi.encodeWithSelector(\n', '            handlerInfo.handlerFunction\n', '            .depositFlashloanFee.selector,\n', '            fee\n', '          )\n', '        );\n', '\n', '        // if error in handler\n', '        require(success);\n', '\n', '        emit FlashLoan(receiverAddress, handlerInfo.addr, amount, fee);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @param handlerID The ID of handler with accumulated flashloan fee\n', '    * @return The amount of fee accumlated to handler\n', '    */\n', '    function getFeeTotal(uint256 handlerID) external view returns (uint256) {\n', '      return handlerFlashloan[handlerID].feeTotal;\n', '    }\n', '\n', '    /**\n', '    * @dev Get flashloan fee for flashloan amount\n', '    * @param handlerID The ID of handler with accumulated flashloan fee\n', '    * @return The amount of fee for flashloan amount\n', '    */\n', '    function getFee(uint256 handlerID, uint256 amount) external view returns (uint256) {\n', '      return _getFee(handlerID, amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Get flashloan fee for flashloan amount\n', '    * @param handlerID The ID of handler with accumulated flashloan fee\n', '    * @param amount The amount of flashloan amount\n', '    * @return The amount of fee for flashloan amount\n', '    */\n', '    function _getFee(uint256 handlerID, uint256 amount) internal view returns (uint256) {\n', '      FeeRateParams memory feeRateParams;\n', '\n', '      uint256 flashloanFeeRate = handlerFlashloan[handlerID].flashFeeRate;\n', '\n', '       if(positionStorageAddr == address(0)) {\n', '        return amount.unifiedMul(flashloanFeeRate);\n', '      }\n', '\n', '      // discount for BiFi-X User\n', '      IPositionStorage positionStorage = IPositionStorage(positionStorageAddr);\n', '      uint256 nftID = positionStorage.getNFTID(msg.sender);\n', '\n', '      // msg.sender is BiFi-X Product\n', '      if(nftID > 0) {\n', '        IERC721 nft = IERC721(nftAddr);\n', '\n', '        address originOwner = nft.ownerOf(nftID);\n', '        uint256 bifiBalance = rewardErc20Instance.balanceOf(originOwner);\n', '        if(bifiBalance >= handlerFlashloan[handlerID].discountBase) {\n', '          // feeRate * (0.1 + 0.9 * min(1, discountBase / bifiAmount))\n', '          feeRateParams.unifiedPoint = 10 ** 18;\n', '          feeRateParams.minimum = 10 ** 17;\n', '          feeRateParams.slope = feeRateParams.unifiedPoint - feeRateParams.minimum;\n', '\n', '          feeRateParams.discountRate = _min(feeRateParams.unifiedPoint, handlerFlashloan[handlerID].discountBase.unifiedDiv(bifiBalance));\n', '\n', '          flashloanFeeRate = flashloanFeeRate.unifiedMul(\n', '            feeRateParams.minimum.add(feeRateParams.slope.unifiedMul(feeRateParams.discountRate))\n', '          );\n', '        }\n', '      }\n', '\n', '      return amount.unifiedMul(flashloanFeeRate);\n', '    }\n', '\n', '    /**\n', '    * @dev Get flashloan fee for flashloan amount before make product(BiFi-X)\n', '    * @param handlerID The ID of handler with accumulated flashloan fee\n', '    * @param amount The amount of flashloan amount\n', '    * @param bifiBalance The amount of Bifi amount\n', '    * @return The amount of fee for flashloan amount\n', '    */\n', '    function getFeeFromArguments(uint256 handlerID, uint256 amount, uint256 bifiBalance) external view returns (uint256) {\n', '      FeeRateParams memory feeRateParams;\n', '\n', '      uint256 flashloanFeeRate = handlerFlashloan[handlerID].flashFeeRate;\n', '\n', '      if(bifiBalance >= handlerFlashloan[handlerID].discountBase) {\n', '        // feeRate * (0.1 + 0.9 * min(1, discountBase / bifiAmount))\n', '        feeRateParams.unifiedPoint = 10 ** 18;\n', '        feeRateParams.minimum = 10 ** 17;\n', '        feeRateParams.slope = feeRateParams.unifiedPoint - feeRateParams.minimum;\n', '\n', '        feeRateParams.discountRate = _min(feeRateParams.unifiedPoint, handlerFlashloan[handlerID].discountBase.unifiedDiv(bifiBalance));\n', '\n', '        flashloanFeeRate = flashloanFeeRate.unifiedMul(\n', '          feeRateParams.minimum.add(feeRateParams.slope.unifiedMul(feeRateParams.discountRate))\n', '        );\n', '      }\n', '\n', '      return amount.unifiedMul(flashloanFeeRate);\n', '    }\n', '\n', '    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a >= b) { return b; }\n', '      return a;\n', '    }\n', '\n', '    /**\n', "    * @dev Convert amount of handler's unified decimals to amount of token's underlying decimals\n", '    * @param unifiedTokenAmount The amount of unified decimals\n', '    * @return (underlyingTokenAmount)\n', '    */\n', '    function _convertUnifiedToUnderlying(ContractInfo memory handlerInfo, uint256 unifiedTokenAmount) internal view returns (uint256) {\n', '      (, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy(\n', '        abi.encodeWithSelector(\n', '          handlerInfo.handlerFunction\n', '          .convertUnifiedToUnderlying.selector,\n', '          unifiedTokenAmount\n', '        )\n', '      );\n', '\n', '      uint256 underlyingTokenDecimal = abi.decode(handlerInfo.data, (uint256));\n', '      return underlyingTokenDecimal;\n', '    }\n', '\n', '    /**\n', '    * @dev Get handler contract balance\n', "    * @param handlerInfo Handler's information about getting the balance\n", '    * @param handlerID The ID of handler get the balance\n', '    * @return tokenAddr is actual tokenAddress and contract token balance.\n', '    */\n', '    function _getThisBalance(ContractInfo memory handlerInfo, uint256 handlerID) internal view returns (address tokenAddr, uint256 balance) {\n', '      if(handlerID == 0) { // ether\n', '        balance = address(this).balance;\n', '        return (address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE), balance);\n', '      } else { // token\n', '        (, handlerInfo.data) = handlerInfo.tokenHandler.handlerViewProxy(\n', '          abi.encodeWithSelector(\n', '            handlerInfo.handlerFunction\n', '            .getERC20Addr.selector\n', '          )\n', '        );\n', '\n', '        tokenAddr = abi.decode(handlerInfo.data, (address));\n', '        balance = IERC20(tokenAddr).balanceOf(address(this));\n', '        return (tokenAddr, balance);\n', '      }\n', '    }\n', '}']