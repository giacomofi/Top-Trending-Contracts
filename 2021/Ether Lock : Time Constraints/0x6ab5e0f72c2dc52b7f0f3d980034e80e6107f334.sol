['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-07\n', '*/\n', '\n', 'pragma solidity 0.6.0;\n', '\n', 'contract INTERSMART {\n', '\n', '    address public owner = address(0);\n', '\n', '    uint128 public price = 0.10 ether;\n', '    uint128 public fee   = 0.02 ether;\n', '\n', '    uint128[] deposits = [\n', '        0.08 ether,\n', '        1.28 ether,\n', '        10.24 ether,\n', '        40.96 ether\n', '    ];\n', '\n', '    uint8 public refLimit = 8;\n', '\n', '    uint8[] public stageLimits = [7, 7, 8, 10];\n', '\n', '    struct User {\n', '        address partner;\n', '        address[] partners;\n', '        uint256 overflowIdx;\n', '        uint256 profit;\n', '        mapping (uint8 => uint256) ids;\n', '        mapping (uint8 => uint8) rounds;\n', '        mapping (uint8 => mapping (uint8 => uint8)) lastLine;\n', '    }\n', '\n', '    mapping (address => User) internal _users;\n', '\n', '    struct Stage {\n', '        uint32 _amountOfUsers;\n', '        mapping (uint256 => address) _userByid;\n', '    }\n', '\n', '    mapping (uint8 => Stage) internal _stages;\n', '\n', '    address payable internal _wallet;\n', '\n', '    uint32 internal _startDate;\n', '\n', '    event getIn(address indexed referral, address indexed partner, address indexed referrer, uint256 price);\n', '    event getOut(address indexed account, uint256 profit);\n', '    event withdrawn(address indexed account, uint256 amount);\n', '    event stageUp(address indexed account, uint256 stage);\n', '    event reinvest(address indexed account, uint256 stage);\n', '    event payOut(address indexed referrer, address indexed referral, uint256 stage, uint256 round, uint256 amount);\n', '    event qualification(address indexed referrer);\n', '\n', '    constructor(address payable walletAddr) public {\n', '        require(walletAddr != address(0));\n', "        require(!_isContract(walletAddr), 'walletAddr cannot be a smart-contract');\n", '\n', '        _wallet = walletAddr;\n', '        User storage user = _users[_wallet];\n', '\n', '        for (uint8 i = 0; i < 4; i++) {\n', '            user.rounds[i] = stageLimits[i];\n', '            _stages[i]._amountOfUsers++;\n', '            _users[_wallet].ids[i] = _stages[i]._amountOfUsers;\n', '            _stages[i]._userByid[_users[_wallet].ids[i]] = _wallet;\n', '        }\n', '\n', '        _startDate = uint32(block.timestamp);\n', '    }\n', '\n', '    fallback() external payable {\n', '        receiver();\n', '    }\n', '\n', '    receive() external payable {\n', '        receiver();\n', '    }\n', '\n', '    function receiver() internal {\n', '        if (msg.value == 0) {\n', '\n', '            withdraw();\n', '\n', '        } else if (msg.value >= price) {\n', '\n', '            if (msg.value > price) {\n', '                msg.sender.transfer(msg.value - price);\n', '            }\n', '\n', '            if (!isRegistered(msg.sender)) {\n', '                regUser(_bytesToAddress(bytes(msg.data)));\n', '            } else {\n', "                revert('User is registered already');\n", '            }\n', '\n', "        } else revert('Incorrect value');\n", '    }\n', '\n', '    function regUser(address referrerAddr) public payable {\n', "        require(!isRegistered(msg.sender), 'User is registered already');\n", "        require(isRegistered(referrerAddr), 'User must provide an active referrer address');\n", "        require(msg.value == price, 'Value must be equal to the price');\n", '\n', '        User storage user = _users[msg.sender];\n', '        address referrer = referrerAddr;\n', '\n', '        _wallet.transfer(fee);\n', '\n', '        _stages[0]._amountOfUsers++;\n', '\n', '        _users[referrer].partners.push(msg.sender);\n', '        if (getUserAmountOfPartners(referrer) == refLimit) {\n', '            emit qualification(referrer);\n', '        }\n', '\n', '        user.partner = referrer;\n', '\n', '        (uint256 newID, uint256 overflowIdx, address freeReferrer) = getFreeReferrer(referrer);\n', '        _users[referrer].overflowIdx = overflowIdx;\n', '\n', '        user.ids[0] = newID;\n', '        _stages[0]._userByid[user.ids[0]] = msg.sender;\n', '\n', '        emit getIn(msg.sender, user.partner, freeReferrer, price);\n', '\n', '        _processStructure(msg.sender, 0);\n', '\n', '    }\n', '\n', '    function withdraw() public {\n', '        uint256 amount = getUserProfit(msg.sender);\n', '\n', "        require(amount > 0, 'User has no profit yet');\n", "        require(getUserAmountOfPartners(msg.sender) >= 2, 'User did not invite 2 referrals yet');\n", '\n', '        _users[msg.sender].profit = 0;\n', '        msg.sender.transfer(amount);\n', '\n', '        emit withdrawn(msg.sender, amount);\n', '    }\n', '\n', '    function _processStructure(address account, uint8 stage) internal {\n', '\n', '        _users[account].rounds[stage]++;\n', '\n', '        emit stageUp(account, stage);\n', '\n', '        uint256 deposit = deposits[stage];\n', '        uint256 full = 64 / 2**(uint256(stage));\n', '        uint8 round = _users[account].rounds[stage];\n', '        uint256 stageUpIdx;\n', '        uint256 profit;\n', '        uint256 reinvestIdx;\n', '\n', '        if (round == 1) {\n', '            if (stage < 3) {\n', '                stageUpIdx = full / 4;\n', '                profit = deposit * (stageUpIdx - 1);\n', '            } else {\n', '                stageUpIdx = 0;\n', '                profit = deposit * 3;\n', '            }\n', '            reinvestIdx = stageUpIdx+1;\n', '        } else {\n', '            stageUpIdx = 0;\n', '            profit = deposit;\n', '            if (round < stageLimits[stage]) {\n', '                reinvestIdx = full / 4 + 1;\n', '            } else {\n', '                reinvestIdx = 0;\n', '            }\n', '        }\n', '\n', '        address rootAddr = getUserReferrer(account, stage, 4-stage);\n', '\n', '        if (rootAddr != address(0) && rootAddr != _wallet) {\n', '\n', '            _users[rootAddr].lastLine[stage][round]++;\n', '\n', '            if (_users[rootAddr].lastLine[stage][round] == stageUpIdx) {\n', '\n', '                _stages[stage+1]._amountOfUsers++;\n', '                _users[rootAddr].ids[stage+1] = _stages[stage+1]._amountOfUsers; \n', '                _stages[stage+1]._userByid[_stages[stage+1]._amountOfUsers] = rootAddr;\n', '                _processStructure(rootAddr, stage+1);\n', '\n', '            } else if (_users[rootAddr].lastLine[stage][round] == reinvestIdx) {\n', '\n', '                _processStructure(rootAddr, stage);\n', '\n', '            } else if (round == 1 && _users[rootAddr].lastLine[stage][round] == full/2) {\n', '\n', '                _users[rootAddr].profit += profit;\n', '                emit payOut(rootAddr, account, stage, round, profit);\n', '\n', '            } else if (round > 1) {\n', '\n', '                _users[rootAddr].profit += profit;\n', '                emit payOut(rootAddr, account, stage, round, profit);\n', '\n', '            }\n', '\n', '        } else {\n', '            _users[_wallet].profit += deposit;\n', '        }\n', '\n', '    }\n', '\n', '    function getFreeReferrer(address referrer) public view returns(uint256 newID, uint256 overflowIdx, address freeReferrer) {\n', '        require(isRegistered(referrer), "User is not registered yet");\n', '        if (getUserAmountOfReferrals(referrer, 0) < 2) {\n', '            return (_users[referrer].ids[0] * 2 + getUserAmountOfReferrals(referrer, 0), getUserAmountOfReferrals(referrer, 0) + 1, referrer);\n', '        }\n', '\n', '        overflowIdx = _users[referrer].overflowIdx;\n', '        uint256 startIdx = _users[referrer].ids[0] * 2;\n', '        uint256 addend = overflowIdx;\n', '        uint256 line = 1;\n', '        uint256 count;\n', '\n', '        while (true) {\n', '            if (addend > 0) {\n', '                if (addend >= 2**line) {\n', '                    addend -= 2**line;\n', '                    startIdx = startIdx * 2;\n', '                    line++;\n', '                } else {\n', '                    count += addend;\n', '                    addend = 0;\n', '                }\n', '            } else if (startIdx + count < startIdx + 2**line) {\n', '                if (_stages[0]._userByid[startIdx + count] == address(0)) {\n', '                    return (startIdx + count, overflowIdx + 1, _stages[0]._userByid[(startIdx + count) / 2]);\n', '                } else {\n', '                    overflowIdx++;\n', '                    count++;\n', '                }\n', '            } else {\n', '                startIdx = startIdx * 2;\n', '                count = 0;\n', '                line++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _bytesToAddress(bytes memory source) internal pure returns(address parsedReferrer) {\n', '        assembly {\n', '            parsedReferrer := mload(add(source,0x14))\n', '        }\n', '        return parsedReferrer;\n', '    }\n', '\n', '    function _isContract(address addr) internal view returns (bool) {\n', '        uint size;\n', '        assembly { size := extcodesize(addr) }\n', '        return size > 0;\n', '    }\n', '\n', '    function getContractBalance() public view returns(uint256) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function getAmountOfUsers(uint8 stage) public view returns(uint256) {\n', '        return _stages[stage]._amountOfUsers;\n', '    }\n', '\n', '    function getDaysSinceStart() public view returns(uint256) {\n', '        if (_startDate > 0) {\n', '            return ((block.timestamp - _startDate) / (1 days));\n', '        }\n', '    }\n', '\n', '    function isRegistered(address account) public view returns(bool) {\n', '        return (_users[account].rounds[0] > 0);\n', '    }\n', '\n', '    function getUserId(address user, uint8 stage) public view returns(uint256) {\n', '        return _users[user].ids[stage];\n', '    }\n', '\n', '    function getUserById(uint8 stage, uint256 id) public view returns(address) {\n', '        return _stages[stage]._userByid[id];\n', '    }\n', '\n', '    function getUserReferrer(address account, uint8 stage, uint256 level) public view returns(address) {\n', '        return _stages[stage]._userByid[_users[account].ids[stage] / 2**(level+1)];\n', '    }\n', '\n', '    function getUserReferrers(address account, uint8 stage) public view returns(address[] memory) {\n', '        uint256 limit = 5 - stage;\n', '        address[] memory referrers = new address[](limit);\n', '        for (uint256 i = 0; i < limit; i++) {\n', '            referrers[i] = getUserReferrer(account, stage, i);\n', '        }\n', '        return referrers;\n', '    }\n', '\n', '    function getUserPartners(address account) public view returns(address[] memory) {\n', '        return _users[account].partners;\n', '    }\n', '\n', '    function getUserAmountOfPartners(address account) public view returns(uint256) {\n', '        return _users[account].partners.length;\n', '    }\n', '\n', '    function getUserReferrals(address account, uint8 stage) public view returns(address, address) {\n', '        return (_stages[stage]._userByid[_users[account].ids[stage] * 2], _stages[stage]._userByid[_users[account].ids[stage] * 2 + 1]);\n', '    }\n', '\n', '    function getUserAmountOfReferrals(address account, uint8 stage) public view returns(uint256) {\n', '        if (_stages[stage]._userByid[_users[account].ids[stage] * 2 + 1] != address(0)) {\n', '            return 2;\n', '        } else if (_stages[stage]._userByid[_users[account].ids[stage] * 2] != address(0)) {\n', '            return 1;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function getUserProfit(address account) public view returns(uint256) {\n', '        return _users[account].profit;\n', '    }\n', '\n', '    function getUserPoints(address account, uint8 stage, uint8 round) public view returns(uint256) {\n', '        return _users[account].lastLine[stage][round];\n', '    }\n', '\n', '    function getUserRounds(address account, uint8 stage) public view returns(uint256) {\n', '        return _users[account].rounds[stage];\n', '    }\n', '\n', '    function getUserLevel(address account) public view returns(uint256) {\n', '        uint8 i;\n', '\n', '        for (i = 1; i <= 3; i++) {\n', '            if (_users[account].rounds[i] == 0) {\n', '                break;\n', '            }\n', '        }\n', '\n', '        return i-1;\n', '    }\n', '\n', '    function getUserStages(address account) public view returns(uint256[] memory) {\n', '        uint256[] memory stages = new uint256[](4);\n', '\n', '        for (uint8 i = 0; i < 4; i++) {\n', '\n', '            stages[i] = getUserRounds(account, i);\n', '\n', '        }\n', '\n', '        return stages;\n', '    }\n', '\n', '    function getStructure(address account, uint8 stage, uint256 round) public view returns(address[] memory) {\n', '        require(stage < 4, "Invalid stage value");\n', '        require(round > 0 && round <= stageLimits[stage], "Invalid round value");\n', '\n', '        uint256 limit = 64 / 2**(uint256(stage)) - 1;\n', '\n', '        address[] memory referrals = new address[](limit);\n', '\n', '        if (_users[account].rounds[stage] < round) {\n', '            return referrals;\n', '        }\n', '\n', '        uint256 id = _users[account].ids[stage];\n', '\n', '        uint256 count;\n', '        uint256 line;\n', '\n', '        while (count < limit) {\n', '            for (uint256 i = 0; i < 2**line; i++) {\n', '                uint256 idx = id * 2**line + i;\n', '                if (_users[_stages[stage]._userByid[idx]].rounds[stage] >= round) {\n', '                    referrals[count] = _stages[stage]._userByid[idx];\n', '                }\n', '                count++;\n', '            }\n', '            line++;\n', '        }\n', '\n', '        return referrals;\n', '    }\n', '\n', '    function getInfo1() external view returns(uint256[] memory) {\n', '        uint256[] memory info = new uint256[](2);\n', '\n', '        info[0] = getAmountOfUsers(0);\n', '        info[1] = getDaysSinceStart();\n', '\n', '        return info;\n', '    }\n', '\n', '    function getInfo2(address account) external view returns(uint256[] memory) {\n', '        uint256[] memory info = new uint256[](2);\n', '\n', '        info[0] = getUserAmountOfPartners(account);\n', '        info[1] = getUserProfit(account);\n', '\n', '        return info;\n', '    }\n', '\n', '    function getInfo3(address account) external view returns(address[] memory, uint256[] memory) {\n', '        address[] memory partners = getUserPartners(account);\n', '        uint256[] memory stages = new uint256[](partners.length);\n', '\n', '        for (uint256 i = 0; i < partners.length; i++) {\n', '            stages[i] = getUserLevel(partners[i]);\n', '        }\n', '\n', '        return (partners, stages);\n', '    }\n', '\n', '    function getInfo4(address account) external view returns(uint256[] memory, uint256[] memory) {\n', '        uint256[] memory reinvests = getUserStages(account);\n', '        uint256[] memory progress = new uint256[](4);\n', '\n', '        for (uint8 i = 0; i < 4; i++) {\n', '            address[] memory referrals;\n', '            if (reinvests[i] > 0) {\n', '                referrals = getStructure(account, i, 1);\n', '            }\n', '            for (uint256 l = 0; l < referrals.length; l++) {\n', '                if (referrals[l] != address(0)) {\n', '                    progress[i]++;\n', '                }\n', '            }\n', '            progress[i] = progress[i] * 10000 / (64 / 2**(uint256(i)) - 1);\n', '        }\n', '\n', '        return (reinvests, progress);\n', '    }\n', '\n', '}']