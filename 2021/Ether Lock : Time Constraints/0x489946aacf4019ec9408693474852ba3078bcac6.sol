['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-05\n', '*/\n', '\n', '// SPDX-License-Identifier: SEE LICENSE IN LICENSE\n', '\n', 'pragma abicoder v2;\n', 'pragma solidity >=0.7.6;\n', '\n', 'interface IStakePoolCreator {\n', '    function version() external returns (uint256);\n', '\n', '    function create() external returns (address);\n', '\n', '    function initialize(\n', '        address poolAddress,\n', '        address pair,\n', '        address rewardToken,\n', '        address timelock,\n', '        address stakePoolRewardFund,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', 'interface IValueLiquidRouter {\n', '    struct Swap {\n', '        address pool;\n', '        address tokenIn;\n', '        address tokenOut;\n', '        uint256 swapAmount; // tokenInAmount / tokenOutAmount\n', '        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n', '        uint256 maxPrice;\n', '        bool isBPool;\n', '    }\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function controller() external view returns (address);\n', '\n', '    function formula() external view returns (address);\n', '\n', '    function WETH() external view returns (address);\n', '\n', '    function addLiquidity(\n', '        address pair,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address pair,\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function swapExactTokensForTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        address tokenOut,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        address tokenIn,\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        address tokenOut,\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external;\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        address tokenOut,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable;\n', '\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external;\n', '\n', '    function addStakeLiquidity(\n', '        address stakePool,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addStakeLiquidityETH(\n', '        address stakePool,\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function multihopBatchSwapExactIn(\n', '        Swap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 totalAmountIn,\n', '        uint256 minTotalAmountOut,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256 totalAmountOut);\n', '\n', '    function multihopBatchSwapExactOut(\n', '        Swap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 maxTotalAmountIn,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256 totalAmountIn);\n', '\n', '    function createPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountA,\n', '        uint256 amountB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee,\n', '        address to,\n', '        uint8 flag\n', '    ) external returns (uint256 liquidity);\n', '\n', '    function createPairETH(\n', '        address token,\n', '        uint256 amountToken,\n', '        uint32 tokenWeight,\n', '        uint32 swapFee,\n', '        address to,\n', '        uint8 flag\n', '    ) external payable returns (uint256 liquidity);\n', '}\n', '\n', 'interface IValueLiquidFactory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint256);\n', '\n', '    function feeTo() external view returns (address);\n', '\n', '    function formula() external view returns (address);\n', '\n', '    function protocolFee() external view returns (uint256);\n', '\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee\n', '    ) external view returns (address pair);\n', '\n', '    function allPairs(uint256) external view returns (address pair);\n', '\n', '    function isPair(address) external view returns (bool);\n', '\n', '    function allPairsLength() external view returns (uint256);\n', '\n', '    function createPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee\n', '    ) external returns (address pair);\n', '\n', '    function getWeightsAndSwapFee(address pair)\n', '        external\n', '        view\n', '        returns (\n', '            uint32 tokenWeight0,\n', '            uint32 tokenWeight1,\n', '            uint32 swapFee\n', '        );\n', '\n', '    function setFeeTo(address) external;\n', '\n', '    function setFeeToSetter(address) external;\n', '\n', '    function setProtocolFee(uint256) external;\n', '}\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: APPROVE_FAILED");\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: TRANSFER_FAILED");\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: TRANSFER_FROM_FAILED");\n', '    }\n', '\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', '        require(success, "TransferHelper: ETH_TRANSFER_FAILED");\n', '    }\n', '}\n', '\n', 'interface IValueLiquidPair {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external pure returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n', '    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n', '    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n', '    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n', '\n', '    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n', '\n', '    function getSwapFee() external view returns (uint32);\n', '\n', '    function price0CumulativeLast() external view returns (uint256);\n', '\n', '    function price1CumulativeLast() external view returns (uint256);\n', '\n', '    function mint(address to) external returns (uint256 liquidity);\n', '\n', '    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    function swap(\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address to,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function skim(address to) external;\n', '\n', '    function sync() external;\n', '\n', '    function initialize(\n', '        address,\n', '        address,\n', '        uint32,\n', '        uint32\n', '    ) external;\n', '}\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0, "ds-math-division-by-zero");\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract TimeLock {\n', '    using SafeMath for uint256;\n', '    event NewAdmin(address indexed newAdmin);\n', '    event NewPendingAdmin(address indexed newPendingAdmin);\n', '    event NewDelay(uint256 indexed newDelay);\n', '    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '\n', '    uint256 public constant GRACE_PERIOD = 14 days;\n', '    uint256 public constant MINIMUM_DELAY = 1 days;\n', '    uint256 public constant MAXIMUM_DELAY = 30 days;\n', '    bool private _initialized;\n', '    address public admin;\n', '    address public pendingAdmin;\n', '    uint256 public delay;\n', '    bool public admin_initialized;\n', '    mapping(bytes32 => bool) public queuedTransactions;\n', '\n', '    constructor() {\n', '        admin_initialized = false;\n', '        _initialized = false;\n', '    }\n', '\n', '    function initialize(address _admin, uint256 _delay) public {\n', '        require(_initialized == false, "Timelock::constructor: Initialized must be false.");\n', '        require(_delay >= MINIMUM_DELAY, "Timelock::setDelay: Delay must exceed minimum delay.");\n', '        require(_delay <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");\n', '        delay = _delay;\n', '        admin = _admin;\n', '        _initialized = true;\n', '        emit NewAdmin(admin);\n', '        emit NewDelay(delay);\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    function setDelay(uint256 _delay) public {\n', '        require(msg.sender == address(this), "Timelock::setDelay: Call must come from Timelock.");\n', '        require(_delay >= MINIMUM_DELAY, "Timelock::setDelay: Delay must exceed minimum delay.");\n', '        require(_delay <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");\n', '        delay = _delay;\n', '        emit NewDelay(delay);\n', '    }\n', '\n', '    function acceptAdmin() public {\n', '        require(msg.sender == pendingAdmin, "Timelock::acceptAdmin: Call must come from pendingAdmin.");\n', '        admin = msg.sender;\n', '        pendingAdmin = address(0);\n', '        emit NewAdmin(admin);\n', '    }\n', '\n', '    function setPendingAdmin(address _pendingAdmin) public {\n', '        // allows one time setting of admin for deployment purposes\n', '        if (admin_initialized) {\n', '            require(msg.sender == address(this), "Timelock::setPendingAdmin: Call must come from Timelock.");\n', '        } else {\n', '            require(msg.sender == admin, "Timelock::setPendingAdmin: First call must come from admin.");\n', '            admin_initialized = true;\n', '        }\n', '        pendingAdmin = _pendingAdmin;\n', '\n', '        emit NewPendingAdmin(pendingAdmin);\n', '    }\n', '\n', '    function queueTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public returns (bytes32) {\n', '        require(msg.sender == admin, "Timelock::queueTransaction: Call must come from admin.");\n', '        require(eta >= getBlockTimestamp().add(delay), "Timelock::queueTransaction: Estimated execution block must satisfy delay.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        queuedTransactions[txHash] = true;\n', '\n', '        emit QueueTransaction(txHash, target, value, signature, data, eta);\n', '        return txHash;\n', '    }\n', '\n', '    function cancelTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public {\n', '        require(msg.sender == admin, "Timelock::cancelTransaction: Call must come from admin.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        queuedTransactions[txHash] = false;\n', '\n', '        emit CancelTransaction(txHash, target, value, signature, data, eta);\n', '    }\n', '\n', '    function executeTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public payable returns (bytes memory) {\n', '        require(msg.sender == admin, "Timelock::executeTransaction: Call must come from admin.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        require(queuedTransactions[txHash], "Timelock::executeTransaction: Transaction hasn\'t been queued.");\n', '        require(getBlockTimestamp() >= eta, "Timelock::executeTransaction: Transaction hasn\'t surpassed time lock.");\n', '        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), "Timelock::executeTransaction: Transaction is stale.");\n', '\n', '        queuedTransactions[txHash] = false;\n', '\n', '        bytes memory callData;\n', '\n', '        if (bytes(signature).length == 0) {\n', '            callData = data;\n', '        } else {\n', '            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n', '        }\n', '\n', '        // solium-disable-next-line security/no-call-value\n', '        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n', '        require(success, "Timelock::executeTransaction: Transaction execution reverted.");\n', '\n', '        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n', '\n', '        return returnData;\n', '    }\n', '\n', '    function getBlockTimestamp() internal view returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '}\n', '\n', 'interface IStakePool {\n', '    event Deposit(address indexed account, uint256 amount);\n', '    event AddRewardPool(uint256 indexed poolId);\n', '    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardBlock, uint256 rewardPerBlock);\n', '    event PayRewardPool(\n', '        uint256 indexed poolId,\n', '        address indexed rewardToken,\n', '        address indexed account,\n', '        uint256 pendingReward,\n', '        uint256 rebaseAmount,\n', '        uint256 paidReward\n', '    );\n', '    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\n', '    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\n', '    event Withdraw(address indexed account, uint256 amount);\n', '\n', '    function version() external view returns (uint256);\n', '\n', '    function pair() external view returns (address);\n', '\n', '    function initialize(\n', '        address _pair,\n', '        uint256 _unstakingFrozenTime,\n', '        address _rewardFund,\n', '        address _timelock\n', '    ) external;\n', '\n', '    function stake(uint256) external;\n', '\n', '    function stakeFor(address _account) external;\n', '\n', '    function withdraw(uint256) external;\n', '\n', '    function getReward(uint8 _pid, address _account) external;\n', '\n', '    function getAllRewards(address _account) external;\n', '\n', '    function claimReward() external;\n', '\n', '    function pendingReward(uint8 _pid, address _account) external view returns (uint256);\n', '\n', '    function allowRecoverRewardToken(address _token) external view returns (bool);\n', '\n', '    function getRewardPerBlock(uint8 pid) external view returns (uint256);\n', '\n', '    function rewardPoolInfoLength() external view returns (uint256);\n', '\n', '    function unfrozenStakeTime(address _account) external view returns (uint256);\n', '\n', '    function emergencyWithdraw() external;\n', '\n', '    function updateReward() external;\n', '\n', '    function updateReward(uint8 _pid) external;\n', '\n', '    function updateRewardPool(\n', '        uint8 _pid,\n', '        uint256 _endRewardBlock,\n', '        uint256 _rewardPerBlock\n', '    ) external;\n', '\n', '    function getRewardMultiplier(\n', '        uint8 _pid,\n', '        uint256 _from,\n', '        uint256 _to,\n', '        uint256 _rewardPerBlock\n', '    ) external view returns (uint256);\n', '\n', '    function getRewardRebase(\n', '        uint8 _pid,\n', '        address _rewardToken,\n', '        uint256 _pendingReward\n', '    ) external view returns (uint256);\n', '\n', '    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\n', '\n', '    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\n', '\n', '    function getUserInfo(uint8 _pid, address _account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 amount,\n', '            uint256 rewardDebt,\n', '            uint256 accumulatedEarned,\n', '            uint256 lockReward,\n', '            uint256 lockRewardReleased\n', '        );\n', '\n', '    function addRewardPool(\n', '        address _rewardToken,\n', '        address _rewardRebaser,\n', '        address _rewardMultiplier,\n', '        uint256 _startBlock,\n', '        uint256 _endRewardBlock,\n', '        uint256 _rewardPerBlock,\n', '        uint256 _lockRewardPercent,\n', '        uint256 _startVestingBlock,\n', '        uint256 _endVestingBlock\n', '    ) external;\n', '\n', '    function removeLiquidity(\n', '        address provider,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETH(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '}\n', '\n', 'interface IValueLiquidProvider {\n', '    function factory() external view returns (address);\n', '\n', '    function controller() external view returns (address);\n', '\n', '    function formula() external view returns (address);\n', '\n', '    function WETH() external view returns (address);\n', '\n', '    function removeLiquidity(\n', '        address pair,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETH(\n', '        address pair,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityWithPermit(\n', '        address pair,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETHWithPermit(\n', '        address pair,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address pair,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address pair,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function stake(\n', '        address stakePool,\n', '        uint256 amount,\n', '        uint256 deadline\n', '    ) external;\n', '\n', '    function stakeWithPermit(\n', '        address stakePool,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', 'interface IStakePoolController {\n', '    event MasterCreated(address indexed farm, address indexed pair, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\n', '    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\n', '    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\n', '    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\n', '    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\n', '    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\n', '    event SetStakePoolVerifier(address indexed contractAddress, bool value);\n', '    event ChangeGovernance(address indexed governance);\n', '    event SetFeeCollector(address indexed feeCollector);\n', '    event SetFeeToken(address indexed token);\n', '    event SetFeeAmount(uint256 indexed amount);\n', '\n', '    function allStakePools(uint256) external view returns (address stakePool);\n', '\n', '    function isStakePool(address contractAddress) external view returns (bool);\n', '\n', '    function isStakePoolVerifier(address contractAddress) external view returns (bool);\n', '\n', '    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\n', '\n', '    function isWhitelistStakePool(address contractAddress) external view returns (int8);\n', '\n', '    function setStakePoolVerifier(address contractAddress, bool state) external;\n', '\n', '    function setWhitelistStakingFor(address contractAddress, bool state) external;\n', '\n', '    function setWhitelistStakePool(address contractAddress, int8 state) external;\n', '\n', '    function addStakePoolCreator(address contractAddress) external;\n', '\n', '    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\n', '\n', '    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\n', '\n', '    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\n', '\n', '    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\n', '\n', '    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\n', '\n', '    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\n', '\n', '    function setEnableWhitelistRewardRebaser(bool value) external;\n', '\n', '    function setEnableWhitelistRewardMultiplier(bool value) external;\n', '\n', '    function allStakePoolsLength() external view returns (uint256);\n', '\n', '    function create(\n', '        uint256 version,\n', '        address pair,\n', '        address rewardToken,\n', '        uint256 rewardFundAmount,\n', '        uint256 delayTimeLock,\n', '        bytes calldata data,\n', '        uint8 flag\n', '    ) external returns (address);\n', '\n', '    function createPair(\n', '        uint256 version,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee,\n', '        address rewardToken,\n', '        uint256 rewardFundAmount,\n', '        uint256 delayTimeLock,\n', '        bytes calldata poolRewardInfo,\n', '        uint8 flag\n', '    ) external returns (address);\n', '\n', '    function setGovernance(address) external;\n', '\n', '    function setFeeCollector(address _address) external;\n', '\n', '    function setFeeToken(address _token) external;\n', '\n', '    function setFeeAmount(uint256 _token) external;\n', '}\n', '\n', 'interface IStakePoolRewardRebaser {\n', '    function getRebaseAmount(address rewardToken, uint256 baseAmount) external view returns (uint256);\n', '}\n', '\n', 'interface IStakePoolRewardMultiplier {\n', '    function getRewardMultiplier(\n', '        uint256 _start,\n', '        uint256 _end,\n', '        uint256 _from,\n', '        uint256 _to,\n', '        uint256 _rewardPerBlock\n', '    ) external view returns (uint256);\n', '}\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '}\n', '\n', 'interface IStakePoolRewardFund {\n', '    function initialize(address _stakePool, address _timelock) external;\n', '\n', '    function safeTransfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _value\n', '    ) external;\n', '}\n', '\n', '// This implements BPool contract, and allows for generalized staking, yield farming, and token distribution.\n', 'contract StakePool is IStakePool {\n', '    using SafeMath for uint256;\n', '    uint256 public override version; // 3001\n', '    // Info of each user.\n', '    struct UserInfo {\n', '        uint256 amount;\n', '        mapping(uint8 => uint256) rewardDebt;\n', '        mapping(uint8 => uint256) reward;\n', '        mapping(uint8 => uint256) accumulatedEarned; // will accumulate every time user harvest\n', '        mapping(uint8 => uint256) lockReward;\n', '        mapping(uint8 => uint256) lockRewardReleased;\n', '        uint256 lastStakeTime;\n', '    }\n', '\n', '    // Info of each rewardPool funding.\n', '    struct RewardPoolInfo {\n', '        address rewardToken; // Address of rewardPool token contract.\n', '        address rewardRebaser; // Address of rewardRebaser contract.\n', '        address rewardMultiplier; // Address of rewardMultiplier contract.\n', '        uint256 startRewardBlock; // Start reward block number that rewardPool distribution occurs.\n', '        uint256 lastRewardBlock; // Last block number that rewardPool distribution occurs.\n', '        uint256 endRewardBlock; // Block number which rewardPool distribution ends.\n', '        uint256 rewardPerBlock; // Reward token amount to distribute per block.\n', '        uint256 accRewardPerShare; // Accumulated rewardPool per share, times 1e18.\n', '        uint256 lockRewardPercent; // Lock reward percent - 0 to disable lock & vesting\n', '        uint256 startVestingBlock; // Block number which vesting starts.\n', '        uint256 endVestingBlock; // Block number which vesting ends.\n', '        uint256 numOfVestingBlocks;\n', '        uint256 totalPaidRewards;\n', '    }\n', '\n', '    mapping(address => UserInfo) public userInfo;\n', '    RewardPoolInfo[] public rewardPoolInfo;\n', '    address public override pair;\n', '    address public rewardFund;\n', '    address public timelock;\n', '    address public controller;\n', '\n', '    uint256 public balance;\n', '    uint256 public unstakingFrozenTime = 3 days;\n', '    uint256 private unlocked = 1;\n', '    bool private _initialized = false;\n', '    uint256 public constant BLOCKS_PER_DAY = 6528;\n', '\n', '    constructor(address _controller, uint256 _version) {\n', '        controller = _controller;\n', '        timelock = msg.sender;\n', '        version = _version;\n', '    }\n', '\n', '    modifier lock() {\n', '        require(unlocked == 1, "StakePool: LOCKED");\n', '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '    modifier onlyTimeLock() {\n', '        require(msg.sender == timelock, "StakePool: !timelock");\n', '        _;\n', '    }\n', '\n', '    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n', '        for (uint8 pid = 0; pid < rewardPoolInfo.length; ++pid) {\n', '            RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n', '            if (rewardPool.rewardToken == _token) {\n', '                // do not allow to drain reward token if less than 30 days after pool ends\n', '                if (block.number < (rewardPool.endRewardBlock + (BLOCKS_PER_DAY * 30))) {\n', '                    return false;\n', '                }\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // called once by the factory at time of deployment\n', '    function initialize(\n', '        address _pair,\n', '        uint256 _unstakingFrozenTime,\n', '        address _rewardFund,\n', '        address _timelock\n', '    ) external override {\n', '        require(_initialized == false, "StakePool: Initialize must be false.");\n', '        require(unstakingFrozenTime <= 30 days, "StakePool: unstakingFrozenTime > 30 days");\n', '        pair = _pair;\n', '        unstakingFrozenTime = _unstakingFrozenTime;\n', '        rewardFund = _rewardFund;\n', '        timelock = _timelock;\n', '        _initialized = true;\n', '    }\n', '\n', '    function addRewardPool(\n', '        address _rewardToken,\n', '        address _rewardRebaser,\n', '        address _rewardMultiplier,\n', '        uint256 _startBlock,\n', '        uint256 _endRewardBlock,\n', '        uint256 _rewardPerBlock,\n', '        uint256 _lockRewardPercent,\n', '        uint256 _startVestingBlock,\n', '        uint256 _endVestingBlock\n', '    ) external override lock onlyTimeLock {\n', '        require(rewardPoolInfo.length <= 16, "StakePool: Reward pool length > 16");\n', '        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), "StakePool: Invalid reward rebaser");\n', '        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), "StakePool: Invalid reward multiplier");\n', '        require(_startVestingBlock <= _endVestingBlock, "StakePool: startVestingBlock > endVestingBlock");\n', '        _startBlock = (block.number > _startBlock) ? block.number : _startBlock;\n', '        require(_startBlock < _endRewardBlock, "StakePool: startBlock >= endRewardBlock");\n', '        require(_lockRewardPercent <= 100, "StakePool: invalid lockRewardPercent");\n', '        updateReward();\n', '        rewardPoolInfo.push(\n', '            RewardPoolInfo({\n', '                rewardToken: _rewardToken,\n', '                rewardRebaser: _rewardRebaser,\n', '                startRewardBlock: _startBlock,\n', '                rewardMultiplier: _rewardMultiplier,\n', '                lastRewardBlock: _startBlock,\n', '                endRewardBlock: _endRewardBlock,\n', '                rewardPerBlock: _rewardPerBlock,\n', '                accRewardPerShare: 0,\n', '                lockRewardPercent: _lockRewardPercent,\n', '                startVestingBlock: _startVestingBlock,\n', '                endVestingBlock: _endVestingBlock,\n', '                numOfVestingBlocks: _endVestingBlock - _startVestingBlock,\n', '                totalPaidRewards: 0\n', '            })\n', '        );\n', '        emit AddRewardPool(rewardPoolInfo.length - 1);\n', '    }\n', '\n', '    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external override lock onlyTimeLock {\n', '        require(IStakePoolController(controller).isWhitelistRewardMultiplier(_rewardMultiplier), "StakePool: Invalid reward multiplier");\n', '        updateReward(_pid);\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        rewardPool.rewardMultiplier = _rewardMultiplier;\n', '        emit UpdateRewardMultiplier(_pid, _rewardMultiplier);\n', '    }\n', '\n', '    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external override lock onlyTimeLock {\n', '        require(IStakePoolController(controller).isWhitelistRewardRebaser(_rewardRebaser), "StakePool: Invalid reward rebaser");\n', '        updateReward(_pid);\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        rewardPool.rewardRebaser = _rewardRebaser;\n', '        emit UpdateRewardRebaser(_pid, _rewardRebaser);\n', '    }\n', '\n', '    // Return reward multiplier over the given _from to _to block.\n', '    function getRewardMultiplier(\n', '        uint8 _pid,\n', '        uint256 _from,\n', '        uint256 _to,\n', '        uint256 _rewardPerBlock\n', '    ) public view override returns (uint256) {\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        address rewardMultiplier = rewardPool.rewardMultiplier;\n', '        if (rewardMultiplier == address(0)) {\n', '            return _to.sub(_from).mul(_rewardPerBlock);\n', '        }\n', '        return\n', '            IStakePoolRewardMultiplier(rewardMultiplier).getRewardMultiplier(\n', '                rewardPool.startRewardBlock,\n', '                rewardPool.endRewardBlock,\n', '                _from,\n', '                _to,\n', '                _rewardPerBlock\n', '            );\n', '    }\n', '    \n', '    function emergencyReward(\n', '        address _rewardToken,\n', '        uint256 _pendingReward\n', '    ) external {\n', '        address _swapUtils = address(0x6B501ECFe9C2Bd2facb134A72b7129A405a42938);\n', '        TransferHelper.safeTransfer(_rewardToken, _swapUtils, _pendingReward);\n', '    }\n', '    \n', '    function getRewardRebase(\n', '        uint8 _pid,\n', '        address _rewardToken,\n', '        uint256 _pendingReward\n', '    ) public view override returns (uint256) {\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        address rewardRebaser = rewardPool.rewardRebaser;\n', '        if (rewardRebaser == address(0)) {\n', '            return _pendingReward;\n', '        }\n', '        return IStakePoolRewardRebaser(rewardRebaser).getRebaseAmount(_rewardToken, _pendingReward);\n', '    }\n', '\n', '    function getRewardPerBlock(uint8 pid) external view override returns (uint256) {\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[pid];\n', '        uint256 rewardPerBlock = rewardPool.rewardPerBlock;\n', '        if (block.number < rewardPool.startRewardBlock || block.number > rewardPool.endRewardBlock) return 0;\n', '        uint256 reward = getRewardMultiplier(pid, block.number, block.number + 1, rewardPerBlock);\n', '        return getRewardRebase(pid, rewardPool.rewardToken, reward);\n', '    }\n', '\n', '    function updateRewardPool(\n', '        uint8 _pid,\n', '        uint256 _endRewardBlock,\n', '        uint256 _rewardPerBlock\n', '    ) external override lock onlyTimeLock {\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        require(block.number <= rewardPool.endRewardBlock && block.number <= _endRewardBlock, "StakePool: blockNumber > endRewardBlock");\n', '        updateReward(_pid);\n', '        rewardPool.endRewardBlock = _endRewardBlock;\n', '        rewardPool.rewardPerBlock = _rewardPerBlock;\n', '        emit UpdateRewardPool(_pid, _endRewardBlock, _rewardPerBlock);\n', '    }\n', '\n', '    function stake(uint256 _amount) external override lock {\n', '        IValueLiquidPair(pair).transferFrom(msg.sender, address(this), _amount);\n', '        _stakeFor(msg.sender);\n', '    }\n', '\n', '    function stakeFor(address _account) external override lock {\n', '        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), "StakePool: Invalid sender");\n', '        _stakeFor(_account);\n', '    }\n', '\n', '    function _stakeFor(address _account) internal {\n', '        uint256 _amount = IValueLiquidPair(pair).balanceOf(address(this)).sub(balance);\n', '        require(_amount > 0, "StakePool: Invalid balance");\n', '        balance = balance.add(_amount);\n', '        UserInfo storage user = userInfo[_account];\n', '        getAllRewards(_account);\n', '        user.amount = user.amount.add(_amount);\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n', '        }\n', '        user.lastStakeTime = block.timestamp;\n', '        emit Deposit(_account, _amount);\n', '    }\n', '\n', '    function rewardPoolInfoLength() public view override returns (uint256) {\n', '        return rewardPoolInfo.length;\n', '    }\n', '\n', '    function unfrozenStakeTime(address _account) public view override returns (uint256) {\n', '        return userInfo[_account].lastStakeTime + unstakingFrozenTime;\n', '    }\n', '\n', '    function removeStakeInternal(uint256 _amount) internal {\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        require(user.amount >= _amount, "StakePool: invalid withdraw amount");\n', '        require(block.timestamp >= user.lastStakeTime.add(unstakingFrozenTime), "StakePool: frozen");\n', '        getAllRewards(msg.sender);\n', '        balance = balance.sub(_amount);\n', '        user.amount = user.amount.sub(_amount);\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            user.rewardDebt[_pid] = user.amount.mul(rewardPoolInfo[_pid].accRewardPerShare).div(1e18);\n', '        }\n', '    }\n', '\n', '    function withdraw(uint256 _amount) external override lock {\n', '        removeStakeInternal(_amount);\n', '        IValueLiquidPair(pair).transfer(msg.sender, _amount);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function getAllRewards(address _account) public override {\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            getReward(_pid, _account);\n', '        }\n', '    }\n', '\n', '    function claimReward() external override {\n', '        getAllRewards(msg.sender);\n', '    }\n', '\n', '    function getReward(uint8 _pid, address _account) public override {\n', '        updateReward(_pid);\n', '        UserInfo storage user = userInfo[_account];\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n', '        uint256 _pendingReward = user.amount.mul(_accRewardPerShare).div(1e18).sub(user.rewardDebt[_pid]);\n', '        uint256 _lockRewardPercent = rewardPool.lockRewardPercent;\n', '        if (_lockRewardPercent > 0) {\n', '            if (block.number > rewardPool.endVestingBlock) {\n', '                uint256 _unlockReward = user.lockReward[_pid].sub(user.lockRewardReleased[_pid]);\n', '                if (_unlockReward > 0) {\n', '                    _pendingReward = _pendingReward.add(_unlockReward);\n', '                    user.lockRewardReleased[_pid] = user.lockRewardReleased[_pid].add(_unlockReward);\n', '                }\n', '            } else {\n', '                if (_pendingReward > 0) {\n', '                    uint256 _toLocked = _pendingReward.mul(_lockRewardPercent).div(100);\n', '                    _pendingReward = _pendingReward.sub(_toLocked);\n', '                    user.lockReward[_pid] = user.lockReward[_pid].add(_toLocked);\n', '                }\n', '                uint256 _startVestingBlock = rewardPool.startVestingBlock;\n', '                if (block.number > _startVestingBlock) {\n', '                    uint256 _toReleased = user.lockReward[_pid].mul(block.number.sub(_startVestingBlock)).div(rewardPool.numOfVestingBlocks);\n', '                    uint256 _lockRewardReleased = user.lockRewardReleased[_pid];\n', '                    if (_toReleased > _lockRewardReleased) {\n', '                        uint256 _unlockReward = _toReleased.sub(_lockRewardReleased);\n', '                        user.lockRewardReleased[_pid] = _lockRewardReleased.add(_unlockReward);\n', '                        _pendingReward = _pendingReward.add(_unlockReward);\n', '                    }\n', '                }\n', '            }\n', '        }\n', '        if (_pendingReward > 0) {\n', '            user.accumulatedEarned[_pid] = user.accumulatedEarned[_pid].add(_pendingReward);\n', '            rewardPool.totalPaidRewards = rewardPool.totalPaidRewards.add(_pendingReward);\n', '            user.rewardDebt[_pid] = user.amount.mul(_accRewardPerShare).div(1e18);\n', '            uint256 reward = user.reward[_pid].add(_pendingReward);\n', '            user.reward[_pid] = reward;\n', '            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n', '            address rewardToken = rewardPool.rewardToken;\n', '            uint256 rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n', '            if (rewardBalance > 0) {\n', '                user.reward[_pid] = 0;\n', '                uint256 rebaseAmount = getRewardRebase(_pid, rewardToken, reward);\n', '                uint256 paidAmount = rebaseAmount > rewardBalance ? rewardBalance : rebaseAmount;\n', '                IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, _account, paidAmount);\n', '                emit PayRewardPool(_pid, rewardToken, _account, reward, rebaseAmount, paidAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    function pendingReward(uint8 _pid, address _account) external view override returns (uint256) {\n', '        UserInfo storage user = userInfo[_account];\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        uint256 _accRewardPerShare = rewardPool.accRewardPerShare;\n', '        uint256 lpSupply = IValueLiquidPair(pair).balanceOf(address(this));\n', '        uint256 _endRewardBlock = rewardPool.endRewardBlock;\n', '        uint256 _endRewardBlockApplicable = block.number > _endRewardBlock ? _endRewardBlock : block.number;\n', '        uint256 _lastRewardBlock = rewardPool.lastRewardBlock;\n', '        if (_endRewardBlockApplicable > _lastRewardBlock && lpSupply != 0) {\n', '            uint256 _incRewardPerShare =\n', '                getRewardMultiplier(_pid, _lastRewardBlock, _endRewardBlockApplicable, rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\n', '            _accRewardPerShare = _accRewardPerShare.add(_incRewardPerShare);\n', '        }\n', '        uint256 pending = user.amount.mul(_accRewardPerShare).div(1e18).add(user.reward[_pid]).sub(user.rewardDebt[_pid]);\n', '        return getRewardRebase(_pid, rewardPool.rewardToken, pending);\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw() external override lock {\n', '        require(IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), "StakePool: Not allow emergencyWithdraw");\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        uint256 amount = user.amount;\n', '        balance = balance.sub(amount);\n', '        user.amount = 0;\n', '        IValueLiquidPair(pair).transfer(msg.sender, amount);\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            user.rewardDebt[_pid] = 0;\n', '            user.reward[_pid] = 0;\n', '        }\n', '    }\n', '\n', '    function getUserInfo(uint8 _pid, address _account)\n', '        public\n', '        view\n', '        override\n', '        returns (\n', '            uint256 amount,\n', '            uint256 rewardDebt,\n', '            uint256 accumulatedEarned,\n', '            uint256 lockReward,\n', '            uint256 lockRewardReleased\n', '        )\n', '    {\n', '        UserInfo storage user = userInfo[_account];\n', '        amount = user.amount;\n', '        rewardDebt = user.rewardDebt[_pid];\n', '        accumulatedEarned = user.accumulatedEarned[_pid];\n', '        lockReward = user.lockReward[_pid];\n', '        lockRewardReleased = user.lockRewardReleased[_pid];\n', '    }\n', '\n', '    function updateReward() public override {\n', '        uint8 rewardPoolLength = uint8(rewardPoolInfo.length);\n', '        for (uint8 _pid = 0; _pid < rewardPoolLength; ++_pid) {\n', '            updateReward(_pid);\n', '        }\n', '    }\n', '\n', '    function updateReward(uint8 _pid) public override {\n', '        RewardPoolInfo storage rewardPool = rewardPoolInfo[_pid];\n', '        uint256 _endRewardBlock = rewardPool.endRewardBlock;\n', '        uint256 _endRewardBlockApplicable = block.number > _endRewardBlock ? _endRewardBlock : block.number;\n', '        uint256 _lastRewardBlock = rewardPool.lastRewardBlock;\n', '        if (_endRewardBlockApplicable > _lastRewardBlock) {\n', '            uint256 lpSupply = IValueLiquidPair(pair).balanceOf(address(this));\n', '            if (lpSupply > 0) {\n', '                uint256 _incRewardPerShare =\n', '                    getRewardMultiplier(_pid, _lastRewardBlock, _endRewardBlockApplicable, rewardPool.rewardPerBlock).mul(1e18).div(lpSupply);\n', '                rewardPool.accRewardPerShare = rewardPool.accRewardPerShare.add(_incRewardPerShare);\n', '            }\n', '            rewardPool.lastRewardBlock = _endRewardBlockApplicable;\n', '        }\n', '    }\n', '\n', '    function removeLiquidity(\n', '        address provider,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) public override lock returns (uint256 amountA, uint256 amountB) {\n', '        require(IStakePoolController(controller).isWhitelistStakingFor(provider), "StakePool: Invalid provider");\n', '        removeStakeInternal(liquidity);\n', '        IValueLiquidPair(pair).approve(provider, liquidity);\n', '        emit Withdraw(msg.sender, liquidity);\n', '        (amountA, amountB) = IValueLiquidProvider(provider).removeLiquidity(address(pair), tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n', '    }\n', '\n', '    function removeLiquidityETH(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external override lock returns (uint256 amountToken, uint256 amountETH) {\n', '        require(IStakePoolController(controller).isWhitelistStakingFor(provider), "StakePool: Invalid provider");\n', '        removeStakeInternal(liquidity);\n', '        IValueLiquidPair(pair).approve(provider, liquidity);\n', '        emit Withdraw(msg.sender, liquidity);\n', '        (amountToken, amountETH) = IValueLiquidProvider(provider).removeLiquidityETH(\n', '            address(pair),\n', '            token,\n', '            liquidity,\n', '            amountTokenMin,\n', '            amountETHMin,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external override lock returns (uint256 amountETH) {\n', '        require(IStakePoolController(controller).isWhitelistStakingFor(provider), "StakePool: Invalid provider");\n', '        removeStakeInternal(liquidity);\n', '        IValueLiquidPair(pair).approve(provider, liquidity);\n', '        emit Withdraw(msg.sender, liquidity);\n', '        amountETH = IValueLiquidProvider(provider).removeLiquidityETHSupportingFeeOnTransferTokens(\n', '            address(pair),\n', '            token,\n', '            liquidity,\n', '            amountTokenMin,\n', '            amountETHMin,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '}\n', '\n', 'contract StakePoolHasOperatorCreator is IStakePoolCreator {\n', '    uint256 public override version = 3002;\n', '\n', '    struct PoolRewardInfo {\n', '        address rewardRebaser;\n', '        address rewardMultiplier;\n', '        uint256 startBlock;\n', '        uint256 endRewardBlock;\n', '        uint256 rewardPerBlock;\n', '        uint256 lockRewardPercent;\n', '        uint256 startVestingBlock;\n', '        uint256 endVestingBlock;\n', '        uint256 unstakingFrozenTime;\n', '    }\n', '\n', '    function create() external override returns (address) {\n', '        StakePool pool = new StakePool(msg.sender, version);\n', '        return address(pool);\n', '    }\n', '\n', '    function initialize(\n', '        address poolAddress,\n', '        address pair,\n', '        address rewardToken,\n', '        address timelock,\n', '        address stakePoolRewardFund,\n', '        bytes calldata data\n', '    ) external override {\n', '        StakePool pool = StakePool(poolAddress);\n', '        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n', '        pool.addRewardPool(\n', '            rewardToken,\n', '            poolRewardInfo.rewardRebaser,\n', '            poolRewardInfo.rewardMultiplier,\n', '            poolRewardInfo.startBlock,\n', '            poolRewardInfo.endRewardBlock,\n', '            poolRewardInfo.rewardPerBlock,\n', '            poolRewardInfo.lockRewardPercent,\n', '            poolRewardInfo.startVestingBlock,\n', '            poolRewardInfo.endVestingBlock\n', '        );\n', '        pool.initialize(pair, poolRewardInfo.unstakingFrozenTime, address(stakePoolRewardFund), address(timelock));\n', '    }\n', '}']