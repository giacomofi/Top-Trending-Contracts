['// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "SafeMath.sol";\n', 'import "ReentrancyGuard.sol";\n', 'import "TransferHelper.sol";\n', '\n', 'contract Stake is ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    address token;\n', '    address private owner;\n', '\n', '    uint256 public stakePeriod;\n', '    uint256 public totalStake;\n', '    uint256 totalWeight;\n', '    uint256 public totalTokenReceived;\n', '    uint256 public startTime;\n', '    \n', '    mapping(address => uint256) public staked;\n', '    mapping(address => uint256) public timelock;\n', '    mapping(address => uint256) weighted;\n', '    mapping(address => uint256) accumulated;\n', '\n', '    event logStake(address indexed stakeHolder, uint256 amount);\n', '    event logWithdraw(address indexed stakeHolder, uint256 amount, uint256 reward);\n', '    event logDeposit(address indexed depositor, uint256 amount);\n', '\n', '    constructor(address _token, uint256 periodInDays, uint256 start, address _owner) public {\n', '        token = _token;\n', '        stakePeriod = periodInDays.mul(86400);\n', '        startTime = start;\n', '        owner = _owner;\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        owner = newOwner;\n', '    }\n', '    \n', '    function setStakePeriod(uint256 periodInDays) public onlyOwner {\n', '        require(periodInDays > 0, "Period greater than 0");\n', '        stakePeriod = periodInDays.mul(86400);\n', '    }\n', '    \n', '    function getStakeData() public view returns(uint256, uint256, uint256, uint256) {\n', '        return (startTime, stakePeriod, totalStake, totalTokenReceived);\n', '    }\n', '    \n', '    function getStakeHolderData(address stakeHolderAddress) public view returns(uint256, uint256, uint256, uint256, uint256) {\n', '        uint256 tokenOut = staked[msg.sender];\n', '        uint256 reward = tokenOut.mul(totalWeight.sub(weighted[msg.sender])).div(10**18).add(accumulated[msg.sender]);\n', '        return (staked[stakeHolderAddress], timelock[stakeHolderAddress], weighted[stakeHolderAddress], accumulated[stakeHolderAddress], reward);\n', '    }\n', '\n', '    function stake(uint256 amount) nonReentrant public {\n', '        require(block.timestamp >= startTime, "Stake not begin");\n', '        require(amount > 0, "Nothing to stake");\n', '\n', '        _stake(amount);\n', '        timelock[msg.sender] = block.timestamp.add(stakePeriod);\n', '\n', '        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n', '    }\n', '\n', '    function withdraw() nonReentrant public returns (uint256 amount, uint256 reward) {\n', '        require(block.timestamp >= timelock[msg.sender], "Stake is locked");\n', '\n', '        (amount, reward) = _applyReward();\n', '        emit logWithdraw(msg.sender, amount, reward);\n', '\n', '        timelock[msg.sender] = 0;\n', '\n', '        TransferHelper.safeTransfer(token, msg.sender, amount);\n', '        if (reward > 0) {\n', '            TransferHelper.safeTransfer(token, msg.sender, reward);\n', '        }\n', '    }\n', '\n', '    function claim() nonReentrant public returns (uint256 reward) {\n', '        (uint256 amount, uint256 _reward) = _applyReward();\n', '        emit logWithdraw(msg.sender, amount, _reward);\n', '        reward = _reward;\n', '\n', '        require(reward > 0, "Nothing to pay out");\n', '        TransferHelper.safeTransfer(token, msg.sender, reward);\n', '\n', '        // restake after withdrawal\n', '        _stake(amount);\n', '        timelock[msg.sender] = block.timestamp.add(stakePeriod);\n', '    }\n', '\n', '    function deposit(uint amount) nonReentrant external payable {\n', '        require(amount > 0, "Nothing to deposit");\n', '        require(totalStake > 0, "Nothing staked");\n', '        \n', '        TransferHelper.safeTransferFrom(token, msg.sender, address(this), amount);\n', '\n', '        totalTokenReceived = totalTokenReceived.add(amount);\n', '\n', '        emit logDeposit(msg.sender, amount);\n', '\n', '        _distribute(amount, totalStake);\n', '    }\n', '\n', '    function _stake(uint256 tokenIn) private {\n', '        uint256 addBack;\n', '        if (staked[msg.sender] > 0) {\n', '            (uint256 tokenOut, uint256 reward) = _applyReward();\n', '            addBack = tokenOut;\n', '            accumulated[msg.sender] = reward;\n', '            staked[msg.sender] = tokenOut;\n', '        }\n', '\n', '        staked[msg.sender] = staked[msg.sender].add(tokenIn);\n', '        weighted[msg.sender] = totalWeight;\n', '        totalStake = totalStake.add(tokenIn);\n', '\n', '        if (addBack > 0) {\n', '            totalStake = totalStake.add(addBack);\n', '        }\n', '\n', '        emit logStake(msg.sender, tokenIn);\n', '    }\n', '\n', '    function _applyReward() private returns (uint256 tokenOut, uint256 reward) {\n', '        require(staked[msg.sender] > 0, "Nothing staked");\n', '\n', '        tokenOut = staked[msg.sender];\n', '        reward = tokenOut\n', '            .mul(totalWeight.sub(weighted[msg.sender]))\n', '            .div(10**18)\n', '            .add(accumulated[msg.sender]);\n', '        totalStake = totalStake.sub(tokenOut);\n', '        accumulated[msg.sender] = 0;\n', '        staked[msg.sender] = 0;\n', '    }\n', '\n', '    function _distribute(uint256 _value, uint256 _totalStake) private {\n', '        totalWeight = totalWeight.add(_value.mul(10**18).div(_totalStake));\n', '    }\n', '}']