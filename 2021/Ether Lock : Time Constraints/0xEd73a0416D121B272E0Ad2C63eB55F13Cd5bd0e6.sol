['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', "import './IUniswapV2Pair.sol';\n", 'import "./UniswapV2OracleLibrary.sol";\n', 'import "./Context.sol";\n', 'import "./Ownable.sol";\n', 'import "./IXAUToken.sol";\n', 'import "./AggregatorV3Interface.sol";\n', '\n', '// https://docs.balancer.finance/api/api#gulp\n', 'interface BAL {\n', '    function gulp(address token) external;\n', '}\n', '\n', 'contract Rebaser is Context, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    AggregatorV3Interface public targetRateOracle1;\n', '    AggregatorV3Interface public targetRateOracle2;\n', '    uint256 public targetRateOracleScale;\n', '    \n', '    struct Transaction {\n', '        bool enabled;\n', '        address destination;\n', '        bytes data;\n', '    }\n', '\n', '    /// @notice an event emitted when a transaction fails\n', '    event TransactionFailed(address indexed destination, uint index, bytes data);\n', '\n', '    /// @notice an event emitted when deviationThreshold is changed\n', '    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\n', '\n', '    /// @notice an event emitted when maxRebaseRatio is changed\n', '    event NewMaxRebaseRatio(uint256 oldMaxRebaseRatio, uint256 newMaxRebaseRatio);\n', '\n', '    // Stable ordering is not guaranteed.\n', '    Transaction[] public transactions;\n', '\n', '    /// @notice Spreads out getting to the target price\n', '    uint256 public rebaseLag;\n', '\n', '    /// @notice Peg target\n', '    uint256 public targetRate;\n', '\n', '    // If the current exchange rate is within this fractional distance from the target, no supply\n', '    // update is performed. Fixed point number--same format as the rate.\n', '    // (ie) abs(rate - targetRate) / targetRate < deviationThreshold, then no supply change.\n', '    uint256 public deviationThreshold;\n', '\n', '    /// @notice Max scalingFactor change ratio per one rebase iteration\n', '    uint256 public maxRebaseRatio;\n', '\n', '    /// @notice More than this much time must pass between rebase operations.\n', '    uint256 public minRebaseTimeIntervalSec;\n', '\n', '    /// @notice Block timestamp of last rebase operation\n', '    uint256 public lastRebaseTimestampSec;\n', '\n', '    /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\n', '    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\n', '    uint256 public rebaseWindowOffsetSec;\n', '\n', '    /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\n', '    uint256 public rebaseWindowLengthSec;\n', '\n', '    /// @notice The number of rebase cycles since inception\n', '    uint256 public epoch;\n', '\n', '    // rebasing is not active initially. It can be activated at T+12 hours from\n', '    // deployment time\n', '    ///@notice boolean showing rebase activation status\n', '    bool public rebasingActive;\n', '\n', '    /// @notice delays rebasing activation to facilitate liquidity\n', '    uint256 public rebaseDelay; \n', '\n', '    /// @notice Time of TWAP initialization\n', '    uint256 public timeOfTWAPInit;\n', '\n', '    /// @notice XAU token address\n', '    address public xauToken;\n', '\n', '    /// @notice reserve token\n', '    address public reserveToken;\n', '\n', '    /// @notice pair for reserveToken <> xauToken\n', '    address public uniswapPair;\n', '\n', '    /// @notice list of uniswap pairs to sync\n', '    address[] public uniSyncPairs;\n', '\n', '    /// @notice list of balancer pairs to gulp\n', '    address[] public balGulpPairs;\n', '\n', '    /// @notice last TWAP update time\n', '    uint32 public blockTimestampLast;\n', '\n', '    /// @notice last TWAP cumulative price;\n', '    uint256 public priceCumulativeLast;\n', '\n', '    /// @notice Whether or not this token is first in uniswap YAM<>Reserve pair\n', '    bool public isToken0;\n', '\n', '    uint256 public constant BASE = 10**18;\n', '\n', '    constructor(\n', '        address xauToken_,\n', '        address reserveToken_,\n', '        address uniswapPair_,\n', '        address targetRateOracle1Address_,\n', '        address targetRateOracle2Address_,\n', '        uint256 targetRateOracleDecimals_,\n', '        uint256 _minRebaseTimeIntervalSec,\n', '        uint256 _rebaseWindowOffsetSec,\n', '        uint256 _rebaseWindowLengthSec,\n', '        uint256 _rebaseDelay\n', '    )\n', '        public\n', '    {\n', '          minRebaseTimeIntervalSec = _minRebaseTimeIntervalSec;\n', '          rebaseWindowOffsetSec = _rebaseWindowOffsetSec; // 8am/8pm UTC rebases\n', '\n', '          (address token0, ) = sortTokens(xauToken_, reserveToken_);\n', '\n', '          targetRateOracle1 = AggregatorV3Interface(targetRateOracle1Address_);\n', '          targetRateOracle2 = AggregatorV3Interface(targetRateOracle2Address_);\n', '          targetRateOracleScale = 10**targetRateOracleDecimals_;\n', '\n', '          // used for interacting with uniswap\n', '          if (token0 == xauToken_) {\n', '              isToken0 = true;\n', '          } else {\n', '              isToken0 = false;\n', '          }\n', '\n', '          uniswapPair = uniswapPair_;\n', '\n', '          uniSyncPairs.push(uniswapPair);\n', '\n', '          xauToken = xauToken_;\n', '\n', '          // Reserve token is not mutable. Must deploy a new rebaser to update it\n', '          reserveToken = reserveToken_;\n', '\n', '          // 1 YYCRV\n', '          targetRate = BASE;\n', '\n', '          // twice daily rebase, with targeting reaching peg in 5 days\n', '          rebaseLag = 5;\n', '\n', '          // 5%\n', '          deviationThreshold = 5 * 10**16;\n', '\n', '          // 2.0x (we can rebase up to 2.0x or down to 0.5x in one step)\n', '          maxRebaseRatio = 2 * 10**18;\n', '\n', '          // 60 minutes\n', '          rebaseWindowLengthSec = _rebaseWindowLengthSec;\n', '\n', '          // 3 days\n', '          rebaseDelay = _rebaseDelay;\n', '    }\n', '\n', '    function removeUniPair(uint256 index) public onlyOwner {\n', '        if (index >= uniSyncPairs.length) return;\n', '\n', '        uint256 totalUniPairs = uniSyncPairs.length;\n', '\n', '        for (uint256 i = index; i < totalUniPairs - 1; i++) {\n', '            uniSyncPairs[i] = uniSyncPairs[i + 1];\n', '        }\n', '        // uniSyncPairs.length--;\n', '        delete uniSyncPairs[totalUniPairs.sub(1)];\n', '    }\n', '\n', '    function removeBalPair(uint256 index) public onlyOwner {\n', '        if (index >= balGulpPairs.length) return;\n', '\n', '        uint256 totalGulpPairs = balGulpPairs.length;\n', '\n', '        for (uint256 i = index; i < totalGulpPairs - 1; i++) {\n', '            balGulpPairs[i] = balGulpPairs[i + 1];\n', '        }\n', '        // uniSyncPairs.length--;\n', '        delete balGulpPairs[totalGulpPairs.sub(1)];\n', '    }\n', '\n', '    /**\n', '    @notice Adds pairs to sync\n', '    *\n', '    */\n', '    function addUniSyncPairs(address[] memory uniSyncPairs_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        for (uint256 i = 0; i < uniSyncPairs_.length; i++) {\n', '            uniSyncPairs.push(uniSyncPairs_[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Adds pairs to sync\n', '    *\n', '    */\n', '    function addGulpSyncPairs(address[] memory balGulpPairs_)\n', '        public\n', '        onlyOwner\n', '    {\n', '        for (uint256 i = 0; i < balGulpPairs_.length; i++) {\n', '            balGulpPairs.push(balGulpPairs_[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '    @notice Uniswap synced pairs\n', '    *\n', '    */\n', '    function getUniSyncPairs()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        address[] memory pairs = uniSyncPairs;\n', '        return pairs;\n', '    }\n', '\n', '    /**\n', '    @notice Uniswap synced pairs\n', '    *\n', '    */\n', '    function getBalGulpPairs()\n', '        public\n', '        view\n', '        returns (address[] memory)\n', '    {\n', '        address[] memory pairs = balGulpPairs;\n', '        return pairs;\n', '    }\n', '\n', '    /** @notice Initializes TWAP start point, starts countdown to first rebase\n', '    *\n', '    */\n', '    function initTWAP()\n', '        public\n', '    {\n', '        require(timeOfTWAPInit == 0, "already activated");\n', '        (uint priceCumulative, uint32 blockTimestamp) =\n', '           UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair, isToken0);\n', '        require(blockTimestamp > 0, "no trades");\n', '        blockTimestampLast = blockTimestamp;\n', '        priceCumulativeLast = priceCumulative;\n', '        timeOfTWAPInit = blockTimestamp;\n', '    }\n', '\n', '    /** @notice Activates rebasing\n', '    *   @dev One way function, cannot be undone, callable by anyone\n', '    */\n', '    function activateRebasing()\n', '        public\n', '    {\n', '        require(timeOfTWAPInit > 0, "twap wasnt intitiated, call initTWAP()");\n', '        // cannot enable prior to end of rebaseDelay\n', '        require(now >= timeOfTWAPInit + rebaseDelay, "!end_delay");\n', '\n', '        rebasingActive = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\n', '     *\n', '     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\n', '     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\n', '     *      and targetRate is 1e18\n', '     */\n', '    function rebase()\n', '        public\n', '    {\n', '        // EOA only or gov\n', '        require(msg.sender == tx.origin || msg.sender == owner()); \n', '\n', '        // ensure rebasing at correct time\n', '        _inRebaseWindow(); \n', '\n', '        // This comparison also ensures there is no reentrancy.\n', '        require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) <= now);  // FIX: [<] -> [<=] to allow rebase from 0th second of each window\n', '\n', '        require(updateTargetRate(), "Target rate was not defined");\n', '\n', '        \n', '        // Snap the rebase time to the start of this window.\n', '        lastRebaseTimestampSec = now.sub( \n', '            now.mod(minRebaseTimeIntervalSec)).add(rebaseWindowOffsetSec); \n', '\n', '        epoch = epoch.add(1); \n', '\n', '        // get twap from uniswap v2;\n', '        uint256 exchangeRate = getTWAP();\n', '\n', '        // calculates % change to supply\n', '        (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate); // 999999452912662667\n', '\n', '        uint256 indexDelta = offPegPerc;\n', '\n', '        // Apply the Dampening factor.\n', '        indexDelta = indexDelta.div(rebaseLag);\n', '\n', '        // Clip indexDelta to stay within interval of [1/maxRebaseRatio - 1, maxRebaseRatio - 1] so that\n', '        // scalingFactor will get multiplied/divided up to maxRebaseRatio times.\n', '        indexDelta = obeyMaxRebaseRatio(indexDelta, positive);\n', '\n', '        IXAUToken xau = IXAUToken(xauToken);\n', '\n', '        if (positive) {\n', '            require(xau.scalingFactor().mul(BASE.add(indexDelta)).div(BASE) < xau.maxScalingFactor(), "new scaling factor will be too big");\n', '        }\n', '\n', '        // rebase, ignore returned var\n', '        xau.rebase(epoch, indexDelta, positive);\n', '\n', '        // perform actions after rebase\n', '        afterRebase(offPegPerc); \n', '    }\n', '\n', '    function afterRebase(\n', '        uint256 /* offPegPerc */\n', '    )\n', '        internal\n', '    {\n', '        // update uniswap pairs\n', '        for (uint256 i = 0; i < uniSyncPairs.length; i++) {\n', '            IUniswapV2Pair(uniSyncPairs[i]).sync();\n', '        }\n', '\n', '        // update balancer pairs\n', '        for (uint256 i = 0; i < balGulpPairs.length; i++) {\n', '            BAL(balGulpPairs[i]).gulp(xauToken);\n', '        }\n', '\n', '        // call any extra functions\n', '        for (uint i = 0; i < transactions.length; i++) {\n', '            Transaction storage t = transactions[i];\n', '            if (t.enabled) {\n', '                bool result =\n', '                    externalCall(t.destination, t.data);\n', '                if (!result) {\n', '                    emit TransactionFailed(t.destination, i, t.data);\n', '                    revert("Transaction Failed");\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates TWAP from uniswap\n', '     *\n', '     * @dev When liquidity is low, this can be manipulated by an end of block -> next block\n', '     *      attack. We delay the activation of rebases 12 hours after liquidity incentives\n', '     *      to reduce this attack vector. Additional there is very little supply\n', '     *      to be able to manipulate this during that time period of highest vuln.\n', '     */\n', '    function getTWAP()\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        (uint priceCumulative, uint32 blockTimestamp) =\n', '            UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair, isToken0);\n', '        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n', '\n', '        // no period check as is done in isRebaseWindow\n', '\n', '\n', '        // overflow is desired\n', '        uint256 priceAverage = uint256(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\n', '\n', '        priceCumulativeLast = priceCumulative;\n', '        blockTimestampLast = blockTimestamp;\n', '\n', '        // BASE is on order of 1e18, which takes 2^60 bits\n', '        // multiplication will revert if priceAverage > 2^196\n', '        // (which it can because it overflows intentially)\n', '        if (priceAverage > uint192(-1)) {\n', '           // eat loss of precision\n', '           // effectively: (x / 2**112) * 1e18\n', '           return (priceAverage >> 112) * BASE;\n', '        }\n', '        // cant overflow\n', '        // effectively: (x * 1e18 / 2**112)\n', '        return (priceAverage * BASE) >> 112;\n', '    }\n', '\n', '    /**\n', '     * @notice Calculates current TWAP from uniswap\n', '     * \n', '     * @dev Has to be called in context, where blockTimestamp > blockTimestampLast, \n', '     *      i.e. in different block after last initTWAP()/getTWAP() call.\n', '     *\n', '     */\n', '    function getCurrentTWAP()\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        (uint priceCumulative, uint32 blockTimestamp) =\n', '            UniswapV2OracleLibrary.currentCumulativePrices(uniswapPair, isToken0);\n', '        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n', '\n', '        // no period check as is done in isRebaseWindow\n', '\n', '        // overflow is desired\n', '        uint256 priceAverage = uint256(uint224((priceCumulative - priceCumulativeLast) / timeElapsed));\n', '\n', '        // BASE is on order of 1e18, which takes 2^60 bits\n', '        // multiplication will revert if priceAverage > 2^196\n', '        // (which it can because it overflows intentially)\n', '        if (priceAverage > uint192(-1)) {\n', '            // eat loss of precision\n', '            // effectively: (x / 2**112) * 1e18\n', '            return (priceAverage >> 112) * BASE;\n', '        }\n', '        // cant overflow\n', '        // effectively: (x * 1e18 / 2**112)\n', '        return (priceAverage * BASE) >> 112;\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the deviation threshold fraction. If the exchange rate given by the market\n', '     *         oracle is within this fractional distance from the targetRate, then no supply\n', '     *         modifications are made.\n', '     * @param deviationThreshold_ The new exchange rate threshold fraction.\n', '     */\n', '    function setDeviationThreshold(uint256 deviationThreshold_)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(deviationThreshold_ > 0);  // FIX: fixed YAM bug: require should validate argument, not member\n', '        uint256 oldDeviationThreshold = deviationThreshold;\n', '        deviationThreshold = deviationThreshold_;\n', '        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the deviation threshold fraction. If the exchange rate given by the market\n', '     *         oracle is within this fractional distance from the targetRate, then no supply\n', '     *         modifications are made.\n', '     * @param maxRebaseRatio_ The new exchange rate threshold fraction.\n', '     */\n', '    function setMaxRebaseRatio(uint256 maxRebaseRatio_)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(maxRebaseRatio_ > 1 * 10**18);\n', '        uint256 oldMaxRebaseRatio = maxRebaseRatio;\n', '        maxRebaseRatio = maxRebaseRatio_;\n', '        emit NewMaxRebaseRatio(oldMaxRebaseRatio, maxRebaseRatio_);\n', '    }\n', '\n', '    /**\n', '     * @param indexDelta The indexDelta to be clipped using maxRebaseRatio.\n', '     * @param positive Sign of indexDelta.\n', '     * @return unchanged indexDelta if resulting scalingFactor will stay within\n', '     *         [scalingFactor / maxRebaseRatio, scalingFactor * maxRebaseRatio] interval,\n', '     *         or maxIndexDelta derived from direction and maxRebaseRatio (saturation)\n', '     */\n', '    function obeyMaxRebaseRatio(uint256 indexDelta, bool positive)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 maxIndexDelta = (positive ? maxRebaseRatio.sub(BASE) : BASE.sub((BASE*BASE).div(maxRebaseRatio)));\n', '        return (indexDelta <= maxIndexDelta ? indexDelta : maxIndexDelta);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the rebase lag parameter.\n', '               It is used to dampen the applied supply adjustment by 1 / rebaseLag\n', '               If the rebase lag R, equals 1, the smallest value for R, then the full supply\n', '               correction is applied on each rebase cycle.\n', '               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\n', '     * @param rebaseLag_ The new rebase lag parameter.\n', '     */\n', '    function setRebaseLag(uint256 rebaseLag_)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(rebaseLag_ > 0);\n', '        rebaseLag = rebaseLag_;\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the targetRate parameter.\n', '     * @param targetRate_ The new target rate parameter.\n', '     */\n', '    function setTargetRate(uint256 targetRate_)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(targetRate_ > 0);\n', '        targetRate = targetRate_;\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the parameters which control the timing and frequency of\n', '     *         rebase operations.\n', '     *         a) the minimum time period that must elapse between rebase cycles.\n', '     *         b) the rebase window offset parameter.\n', '     *         c) the rebase window length parameter.\n', '     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\n', '     *        operations, in seconds.\n', '     * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\n', '              the rebase interval, where the rebase window begins.\n', '     * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\n', '     */\n', '    function setRebaseTimingParameters(\n', '        uint256 minRebaseTimeIntervalSec_,\n', '        uint256 rebaseWindowOffsetSec_,\n', '        uint256 rebaseWindowLengthSec_)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(minRebaseTimeIntervalSec_ > 0);\n', '        require(rebaseWindowOffsetSec_ < minRebaseTimeIntervalSec_);\n', '        require(rebaseWindowOffsetSec_ + rebaseWindowLengthSec_ <= minRebaseTimeIntervalSec_);  // FIX: [<] -> [<=] to allow window length to span whole interval if needed\n', '        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\n', '        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\n', '        rebaseWindowLengthSec = rebaseWindowLengthSec_;\n', '    }\n', '\n', '    /**\n', '     * @return If the latest block timestamp is within the rebase time window it, returns true.\n', '     *         Otherwise, returns false.\n', '     */\n', '    function inRebaseWindow() public view returns (bool) {\n', '\n', '        // rebasing is delayed until there is a liquid market\n', '        _inRebaseWindow();\n', '        return true;\n', '    }\n', '\n', '    function _inRebaseWindow() internal view {\n', '\n', '        // rebasing is delayed until there is a liquid market\n', '        require(rebasingActive, "rebasing not active");\n', '\n', '        require(now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec, "too early");\n', '        require(now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), "too late");\n', '    }\n', '\n', '    function isRebaseEffective() external view returns (bool) {\n', '        return        \n', '            rebasingActive && \n', '            now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec &&\n', '            now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)) &&\n', '            lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) <= now &&\n', '            !withinDeviationThreshold(getCurrentTWAP(), getCurrentTargetRate())\n', '            ;\n', '    }\n', '\n', '    /**\n', '     * @return Computes in % how far off market is from peg\n', '     */\n', '    function computeOffPegPerc(uint256 rate)\n', '        internal\n', '        view\n', '        returns (uint256, bool)\n', '    {\n', '        if (withinDeviationThreshold(rate, targetRate)) {\n', '            return (0, false);\n', '        }\n', '\n', '        // indexDelta =  (rate - targetRate) / targetRate\n', '        if (rate > targetRate) {\n', '            return (rate.sub(targetRate).mul(BASE).div(targetRate), true);\n', '        } else {\n', '            return (targetRate.sub(rate).mul(BASE).div(targetRate), false);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @param _currentRate The current exchange rate, an 18 decimal fixed point number.\n', '     * @param _targetRate The current target rate, an 18 decimal fixed point number.\n', '     * @return If the rate is within the deviation threshold from the target rate, returns true.\n', '     *         Otherwise, returns false.\n', '     */\n', '    function withinDeviationThreshold(uint256 _currentRate, uint256 _targetRate)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        uint256 absoluteDeviationThreshold = _targetRate.mul(deviationThreshold)\n', '            .div(10 ** 18);\n', '\n', '        return (_currentRate >= _targetRate && _currentRate.sub(_targetRate) < absoluteDeviationThreshold)\n', '            || (_currentRate < _targetRate && _targetRate.sub(_currentRate) < absoluteDeviationThreshold);\n', '    }\n', '\n', '    /* - Constructor Helpers - */\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(\n', '        address factory,\n', '        address token0,\n', '        address token1\n', '    )\n', '        internal\n', '        pure\n', '        returns (address pair)\n', '    {\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '    }\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(\n', '        address tokenA,\n', '        address tokenB\n', '    )\n', '        internal\n', '        pure\n', '        returns (address token0, address token1)\n', '    {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    /* -- Rebase helpers -- */\n', '\n', '    /**\n', '     * @notice Adds a transaction that gets called for a downstream receiver of rebases\n', '     * @param destination Address of contract destination\n', '     * @param data Transaction data payload\n', '     */\n', '    function addTransaction(address destination, bytes calldata data)\n', '        external\n', '        onlyOwner\n', '    {\n', '        transactions.push(Transaction({\n', '            enabled: true,\n', '            destination: destination,\n', '            data: data\n', '        }));\n', '    }\n', '\n', '\n', '    /**\n', '     * @param index Index of transaction to remove.\n', '     *              Transaction ordering may have changed since adding.\n', '     */\n', '    function removeTransaction(uint index)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(index < transactions.length, "index out of bounds");\n', '\n', '        if (index < transactions.length - 1) {\n', '            transactions[index] = transactions[transactions.length - 1];\n', '        }\n', '\n', '        // transactions.length--;\n', '        transactions.pop();\n', '    }\n', '\n', '    /**\n', '     * @param index Index of transaction. Transaction ordering may have changed since adding.\n', '     * @param enabled True for enabled, false for disabled.\n', '     */\n', '    function setTransactionEnabled(uint index, bool enabled)\n', '        external\n', '        onlyOwner\n', '    {\n', '        require(index < transactions.length, "index must be in range of stored tx list");\n', '        transactions[index].enabled = enabled;\n', '    }\n', '\n', '    /**\n', '     * @dev wrapper to call the encoded transactions on downstream consumers.\n', '     * @param destination Address of destination contract.\n', '     * @param data The encoded data payload.\n', '     * @return True on success\n', '     */\n', '    function externalCall(address destination, bytes memory data)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        bool result;\n', '        assembly {  // solhint-disable-line no-inline-assembly\n', '            // "Allocate" memory for output\n', '            // (0x40 is where "free memory" pointer is stored by convention)\n', '            let outputAddress := mload(0x40)\n', '\n', '            // First 32 bytes are the padded length of data, so exclude that\n', '            let dataAddress := add(data, 32)\n', '\n', '            result := call(\n', '                // 34710 is the value that solidity is currently emitting\n', '                // It includes callGas (700) + callVeryLow (3, to pay for SUB)\n', '                // + callValueTransferGas (9000) + callNewAccountGas\n', '                // (25000, in case the destination address does not exist and needs creating)\n', '                sub(gas(), 34710),\n', '\n', '\n', '                destination,\n', '                0, // transfer value in wei\n', '                dataAddress,\n', '                mload(data),  // Size of the input, in bytes. Stored in position 0 of the array.\n', '                outputAddress,\n', '                0  // Output is ignored, therefore the output size is zero\n', '            )\n', '        }\n', '        return result;\n', '    }\n', '    \n', '    // Gives governance ability to recover any ERC20 tokens mistakenly sent to this contract address.\n', '    function recoverERC20(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        external\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        return IERC20(token).transfer(to, amount);\n', '    }\n', '\n', '    function setTargetRateOracle1(AggregatorV3Interface oracleAddress_) public onlyOwner {\n', '        targetRateOracle1 = oracleAddress_;\n', '    }\n', '\n', '    function setTargetRateOracle2(AggregatorV3Interface oracleAddress_) public onlyOwner {\n', '        targetRateOracle2 = oracleAddress_;\n', '    }\n', '\n', '    function setTargetRateOracleDecimals(uint256 targetRateOracleDecimals_) public onlyOwner {\n', '        targetRateOracleScale = 10**targetRateOracleDecimals_;\n', '    }\n', '\n', '    function getTargetRateOracle1Price() public view returns (uint256) {\n', '        return getChainLinkOraclePrice(targetRateOracle1);\n', '    }\n', '\n', '    function getTargetRateOracle2Price() public view returns (uint256) {\n', '        return getChainLinkOraclePrice(targetRateOracle2);\n', '    }\n', '\n', '    function getUniswapPairAddress() public view returns (address) {\n', '        return uniswapPair;\n', '    }\n', '\n', '    function getChainLinkOraclePrice(AggregatorV3Interface chainLinkOracle) internal view returns (uint256) {\n', '        (\n', '            , // uint80 roundID, \n', '            uint price,\n', '            , // uint startedAt,\n', '            uint timeStamp,\n', '              // uint80 answeredInRound\n', '        ) = chainLinkOracle.latestRoundData();        \n', '        require(timeStamp > 0, "Round not complete");  // If the round is not complete yet, timestamp is 0\n', '        return price;\n', '    }\n', '\n', '    function getCurrentTargetRate() public view returns (uint256) {\n', '        if (address(targetRateOracle1) != address(0)) {\n', '            if (address(targetRateOracle2) != address(0)) {\n', '                // Two oracle mode (i.e.: 1: [comodity/USD], 2: [ETH/USD]; [base/quote])\n', '                return getChainLinkOraclePrice(targetRateOracle1).mul(BASE).div(getChainLinkOraclePrice(targetRateOracle2));  // [comodity/USD] / [ETH/USD] = [comodity/USD] * [USD/ETH] = [comodity/ETH])\n', '            } else {\n', '                // Single oracle mode (direct), scale is important\n', '                return getChainLinkOraclePrice(targetRateOracle1).mul(BASE).div(targetRateOracleScale);\n', '            }\n', '        } else if (address(targetRateOracle2) != address(0)) {\n', '            // Single oracle mode (inverted), scale is important\n', '            return BASE.mul(targetRateOracleScale).div(getChainLinkOraclePrice(targetRateOracle2));\n', '        } else {\n', '            // No oracle mode, fixed targetRate\n', '            return targetRate;\n', '        }\n', '    }\n', '    \n', '    function updateTargetRate() public returns (bool) {\n', '        AggregatorV3Interface _targetRateOracle1 = targetRateOracle1;  // cache storage values to save duplicit SLOAD gas\n', '        AggregatorV3Interface _targetRateOracle2 = targetRateOracle2;\n', '        if (address(_targetRateOracle1) != address(0)) {\n', '            if (address(_targetRateOracle2) != address(0)) {\n', '                // Two oracle mode (i.e.: 1: [comodity/USD], 2: [ETH/USD]; [base/quote])\n', '                targetRate = getChainLinkOraclePrice(_targetRateOracle1).mul(BASE).div(getChainLinkOraclePrice(_targetRateOracle2));  // [comodity/USD] / [ETH/USD] = [comodity/USD] * [USD/ETH] = [comodity/ETH])\n', '            } else {\n', '                // Single oracle mode (direct), scale is important\n', '                targetRate = getChainLinkOraclePrice(_targetRateOracle1).mul(BASE).div(targetRateOracleScale);\n', '            }\n', '        } else if (address(_targetRateOracle2) != address(0)) {\n', '            // Single oracle mode (inverted), scale is important\n', '            targetRate = BASE.mul(targetRateOracleScale).div(getChainLinkOraclePrice(_targetRateOracle2));\n', '        } else {\n', '            // No oracle mode, fixed targetRate\n', '        }\n', '        return true;\n', '    }\n', '\n', '}']