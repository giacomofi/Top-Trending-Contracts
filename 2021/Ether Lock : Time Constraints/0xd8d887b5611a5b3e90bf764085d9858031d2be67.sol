['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-24\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', ' /**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '  \n', '  function percent(uint value,uint numerator, uint denominator, uint precision) internal pure  returns(uint quotient) {\n', '    uint _numerator  = numerator * 10 ** (precision+1);\n', '    uint _quotient =  ((_numerator / denominator) + 5) / 10;\n', '    return (value*_quotient/1000000000000000000);\n', '  }\n', '}\n', '\n', 'contract ERC20 {\n', '  function totalSupply()public view returns (uint total_Supply);\n', '  function balanceOf(address who)public view returns (uint256);\n', '  function allowance(address owner, address spender)public view returns (uint);\n', '  function transferFrom(address from, address to, uint value)public returns (bool ok);\n', '  function approve(address spender, uint value)public returns (bool ok);\n', '  function transfer(address to, uint value);\n', '  event Transfer(address indexed from, address indexed to, uint value);\n', '  event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', '\n', 'contract UCOSTOKEN is ERC20 { \n', '    \n', '    using SafeMath for uint256;\n', '    string public constant name     \t\t= "UCOSTOKEN";                  // Name of the token\n', '    string public constant symbol   \t\t= "UCOS";                       // Symbol of token\n', '    uint8 public constant decimals  \t\t= 18;                           // Decimal of token\n', '    uint public premined           \t\t\t= 45000000 * 10 ** 18;          // 45 million in premined\n', '    uint public smartmine           \t\t= 60000000 * 10 ** 18;      \t// 60 million in Smart Mining\n', '    uint public posmine    \t\t\t\t\t= 45000000 * 10 ** 18;         \t// 45 million in POS Mining\n', '    address public owner;                                           \t\t// Owner of this contract\n', '\taddress public founder;\n', '\taddress public developer;\n', '\tuint256 internal stakePer_              = 1500000000000000000;\t\t\t//POS stake percent\n', '\tmapping(address => uint256) internal tokenBalanceLedger_;\n', '    mapping(address => uint256) internal stakeBalanceLedger_;\n', '    mapping(address => uint256) internal stakingTime_;\n', '\t\n', '\t\n', '    mapping(address => uint256) internal mintingDate;\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\t\n', '\t//Genesis Mining start\n', '\tuint256 public totalGenesisAddresses;\n', '    uint256 public currentGenesisAddresses;\n', '    uint256 public initialSupplyPerAddress;\n', '    uint256 public initialBlockCount;\n', '    uint256 private minedBlocks;\n', '    uint256 public rewardPerBlockPerAddress;\n', '    uint256 private availableAmount;\n', '    uint256 private availableBalance;\n', '    uint256 private totalMaxAvailableAmount;\n', '     mapping (address => bool) public genesisAddress;\n', '    \n', '    modifier onlyOwner() {\n', '        if (msg.sender != owner) {\n', '            revert();\n', '        }\n', '        _;\n', '    }\n', '\n', '    function UCOSTOKEN() {\n', '\t\n', '\t\tuint developerbal \t= 2250000 * 10 ** 18;  //5% from premined for developer\n', '\t\tdeveloper = 0x120f8717d16d4167DA4e8c6217Ba718cA2C299fB;\n', '\t\tfounder = 0xe860E8A7d8AC08AfBB0b03BCB5c0B822A776159C;\n', '        balances[msg.sender] = developerbal;\n', '        Transfer(0, msg.sender, developerbal);\n', '\t\tbalances[founder] = premined - developerbal;\n', '        Transfer(0, founder, premined - developerbal);\n', '        \n', '\t\t\n', '\t\t\n', '\t\t\n', '\t\trewardPerBlockPerAddress = 38051750000000000;\n', '\t\tinitialSupplyPerAddress = 400000 * 10 ** 18;\n', '\t\ttotalGenesisAddresses = 150;\n', '\t\tcurrentGenesisAddresses = 0;\n', '\t\tinitialBlockCount = block.number;\n', '    }\n', '    \n', '      \n', '    // What is the balance of a particular account?\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balances[_owner];\n', '    }\n', '    \n', '    // Token minting function\n', '\t\n', '\tfunction mint(uint256 _amountOfTokens) public{\n', '        address _customerAddress            = msg.sender;\n', '        require(_amountOfTokens >= 1000 * 10 ** 18);\n', '        require (balances[_customerAddress] >= _amountOfTokens);\n', '       \n', '        stakingTime_[_customerAddress]      = now;\n', '        stakeBalanceLedger_[_customerAddress] = SafeMath.add(stakeBalanceLedger_[_customerAddress], _amountOfTokens);\n', '        balances[_customerAddress] = SafeMath.sub(balances[_customerAddress], _amountOfTokens);\n', '\t\t\n', '\t\t\n', '    }\n', '\t\n', '\t function stakeTokensTime(address _customerAddress) public view returns(uint256){\n', '        return stakingTime_[_customerAddress];\n', '    }\n', '\t\n', '\tfunction unmint() public {\n', '       \n', '        address _customerAddress            = msg.sender;\n', '    \n', '       \n', '        uint256 _amountOfTokens             = stakeBalanceLedger_[_customerAddress];\n', '        uint256 timediff                    = SafeMath.sub(now, stakingTime_[_customerAddress]);\n', '        uint256 dayscount                   = SafeMath.div(timediff, 604800); //Weekly POS rewards\n', '        uint256 roiPercent                  = SafeMath.mul(dayscount, stakePer_);\n', '        uint256 roiTokens                   = SafeMath.percent(_amountOfTokens,roiPercent,100,18);\n', '        uint256 finalBalance                = SafeMath.add(_amountOfTokens,roiTokens/1e18);\n', '        \n', '    \n', '        balances[_customerAddress] = SafeMath.add(balances[_customerAddress], finalBalance);\n', '        stakeBalanceLedger_[_customerAddress] = 0;\n', '        stakingTime_[_customerAddress]      = 0;\n', '        \n', '    }\n', '\t\n', '\t\n', '    \n', '    \n', '    // Send _value amount of tokens from address _from to address _to\n', '    // The transferFrom method is used for a withdraw workflow, allowing contracts to send\n', '    // tokens on your behalf, for example to "deposit" to a contract address and/or to charge\n', '    // fees in sub-currencies; the command should fail unless the _from account has\n', '    // deliberately authorized the sender of the message via some mechanism; we propose\n', '    // these standardized APIs for approval:\n', '    function transferFrom( address _from, address _to, uint256 _amount ) public returns (bool success) {\n', '        require( _to != 0x0);\n', '        require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0);\n', '        balances[_from] = (balances[_from]).sub(_amount);\n', '        allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '    \n', '    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n', '    // If this function is called again it overwrites the current allowance with _value.\n', '    function approve(address _spender, uint256 _amount) public returns (bool success) {\n', '        require( _spender != 0x0);\n', '        allowed[msg.sender][_spender] = _amount;\n', '        Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '  \n', '    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n', '        require( _owner != 0x0 && _spender !=0x0);\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '    \n', '\t\n', '\t function transfer(address _to, uint256 _value)\n', '    {\n', '      if (genesisAddress[_to]) throw;\n', '\n', '      if (balances[msg.sender] < _value) throw;\n', '\n', '      if (balances[_to] + _value < balances[_to]) throw;\n', '\n', '      if (genesisAddress[msg.sender])\n', '      {\n', '    \t   minedBlocks = block.number - initialBlockCount;\n', '         if(minedBlocks % 2 != 0){\n', '           minedBlocks = minedBlocks - 1;\n', '         }\n', '    \t    if (minedBlocks < 10512000)\n', '    \t     {\n', '    \t\t       availableAmount = rewardPerBlockPerAddress*minedBlocks;\n', '    \t\t       totalMaxAvailableAmount = initialSupplyPerAddress - availableAmount;\n', '    \t\t       availableBalance = balances[msg.sender] - totalMaxAvailableAmount;\n', '    \t\t       if (_value > availableBalance) throw;\n', '    \t     }\n', '      }\n', '      balances[msg.sender] -= _value;\n', '      balances[_to] += _value;\n', '      Transfer(msg.sender, _to, _value);\n', '    }\n', '    \n', "    // Transfer the balance from owner's account to another account\n", '    function transferTokens(address _to, uint256 _amount) private returns (bool success) {\n', '        require( _to != 0x0);       \n', '        require(balances[address(this)] >= _amount && _amount > 0);\n', '        balances[address(this)] = (balances[address(this)]).sub(_amount);\n', '        balances[_to] = (balances[_to]).add(_amount);\n', '        Transfer(address(this), _to, _amount);\n', '        return true;\n', '    }\n', '\t\n', '\tfunction currentEthBlock() constant returns (uint256 blockNumber)\n', '    {\n', '    \treturn block.number;\n', '    }\n', '\n', '    function currentBlock() constant returns (uint256 blockNumber)\n', '    {\n', '      if(initialBlockCount == 0){\n', '        return 0;\n', '      }\n', '      else{\n', '      return block.number - initialBlockCount;\n', '    }\n', '    }\n', '\t\n', '\t//set Genesis\n', '\t\n', '    function setGenesisAddressArray(address[] _address) public returns (bool success)\n', '    {\n', '      if(initialBlockCount == 0) throw;\n', '      uint256 tempGenesisAddresses = currentGenesisAddresses + _address.length;\n', '      if (tempGenesisAddresses <= totalGenesisAddresses )\n', '    \t{\n', '    \t\tif (msg.sender == developer)\n', '    \t\t{\n', '          currentGenesisAddresses = currentGenesisAddresses + _address.length;\n', '    \t\t\tfor (uint i = 0; i < _address.length; i++)\n', '    \t\t\t{\n', '    \t\t\t\tbalances[_address[i]] = initialSupplyPerAddress;\n', '    \t\t\t\tgenesisAddress[_address[i]] = true;\n', '    \t\t\t}\n', '    \t\t\treturn true;\n', '    \t\t}\n', '    \t}\n', '    \treturn false;\n', '    }\n', '\t  function availableBalanceOf(address _address) constant returns (uint256 Balance)\n', '    {\n', '    \tif (genesisAddress[_address])\n', '    \t{\n', '    \t\tminedBlocks = block.number - initialBlockCount;\n', '        if(minedBlocks % 2 != 0){\n', '          minedBlocks = minedBlocks - 1;\n', '        }\n', '\n', '    \t\tif (minedBlocks >= 10512000) return balances[_address];\n', '    \t\t  availableAmount = rewardPerBlockPerAddress*minedBlocks;\n', '    \t\t  totalMaxAvailableAmount = initialSupplyPerAddress - availableAmount;\n', '          availableBalance = balances[_address] - totalMaxAvailableAmount;\n', '          return availableBalance;\n', '    \t}\n', '    \telse {\n', '    \t\treturn balances[_address];\n', '      }\n', '    }\n', '\n', '    function totalSupply() constant returns (uint256 totalSupply)\n', '    {\n', '      if (initialBlockCount != 0)\n', '      {\n', '      minedBlocks = block.number - initialBlockCount;\n', '      if(minedBlocks % 2 != 0){\n', '        minedBlocks = minedBlocks - 1;\n', '      }\n', '    \tavailableAmount = rewardPerBlockPerAddress*minedBlocks;\n', '    }\n', '    else{\n', '      availableAmount = 0;\n', '    }\n', '    \treturn availableAmount*totalGenesisAddresses+premined+posmine;\n', '    }\n', '\n', '    function maxTotalSupply() constant returns (uint256 maxSupply)\n', '    {\n', '    \treturn initialSupplyPerAddress*totalGenesisAddresses+premined+posmine;\n', '    }\n', '\t\n', '\n', '    function drain() external onlyOwner {\n', '        owner.transfer(this.balance);\n', '    }\n', '}']