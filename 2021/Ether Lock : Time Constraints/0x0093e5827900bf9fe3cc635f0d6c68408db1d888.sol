['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-04\n', '*/\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'abstract contract ERC20 {\n', '    function balanceOf(address who) public virtual view returns (uint256);\n', '    function transfer(address to, uint256 value) public virtual returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\n', '}\n', '\n', 'contract uDistributeV2 {\n', '\n', '   struct distribution{\n', '        uint tokenIndex;        //token Index\n', '        uint recipientIndex;      //recipient\n', '        uint p;                 //period\n', '        uint a;                 //amount per period\n', '        uint touchpoint;        //Withdrawal touch point, when the initial waiting period has ended, or the last withdrawal has occured\n', '        uint totalAmount;       //totalAmount Distributed\n', '    }\n', '\n', '    event Distribution(address token,address distributor,address recipient,uint256 index,uint256 amount,string description);\n', '\tevent Withdrawal(address token,address recipient,uint256 index,uint256 amount);\n', '\n', '    mapping(uint => distribution[]) public distributions;\n', '\n', '    mapping(address => uint) public recipientIndexes;\n', '    address[] public recipientList;\n', '\n', '    mapping(address => uint) public tokenIndexes;\n', '    address[] public tokenList;\n', '\n', '    constructor() {\n', '        tokenList.push(address(0));\n', '        tokenIndexes[0x92e52a1A235d9A103D970901066CE910AAceFD37] = 1;\n', '        tokenList.push(0x92e52a1A235d9A103D970901066CE910AAceFD37);\n', '        recipientList.push(address(0));\n', '    }\n', '\n', '    function distribute(address token, address recipient,uint waitTime, uint period, uint amountPerPeriod, uint amount, string memory description) public{\n', '        ERC20(token).transferFrom(msg.sender,address(this),amount);\n', '\n', '        uint touchPoint = block.timestamp + waitTime;\n', '\n', '        uint rIndex = _getRecipientIndex(recipient);\n', '\n', '        emit Distribution(token,msg.sender,recipient,numDistributions(recipient),amount,description);\n', '\n', '        distributions[rIndex].push(distribution(\n', '            getTokenIndex(token),\n', '            rIndex,\n', '            period,\n', '            amountPerPeriod,\n', '            touchPoint,\n', '            amount)\n', '        );\n', '    }\n', '\n', '    function withdraw(uint index) public {\n', '        distribution memory d = distributions[getRecipientIndex(msg.sender)][index];\n', '        require(index<numDistributions(msg.sender), "Requested distribution does not exist");\n', '        uint toWithdraw = getWithdrawable(msg.sender,index);\n', '        require(block.timestamp>=d.touchpoint, "waiting period is not over yet");\n', '        require(toWithdraw>0,"Nothing to Withdraw");\n', '\n', '        ERC20(tokenList[d.tokenIndex]).transfer(msg.sender,toWithdraw);\n', '\n', '        distributions[getRecipientIndex(msg.sender)][index].touchpoint = block.timestamp;\n', '        distributions[getRecipientIndex(msg.sender)][index].totalAmount -= toWithdraw;\n', '\n', '        emit Withdrawal(tokenList[d.tokenIndex],msg.sender,index,toWithdraw);\n', '    }\n', '\n', '    function getWithdrawable(address recipient,uint index) public view returns (uint){\n', '        distribution memory d = distributions[getRecipientIndex(recipient)][index];\n', '        uint toWithdraw;\n', '        uint elapsedPeriods;\n', '\n', '        if(block.timestamp<d.touchpoint){\n', '            return(0);\n', '        }\n', '\n', '        elapsedPeriods = (block.timestamp - d.touchpoint)/d.p;\n', '\n', '        if(elapsedPeriods<=0){\n', '            return(0);\n', '        }\n', '\n', '        toWithdraw = d.a*elapsedPeriods;\n', '\n', '        if(toWithdraw>d.totalAmount){\n', '            return(d.totalAmount);\n', '        }\n', '\n', '        return(toWithdraw);\n', '    }\n', '\n', '    function getRecipientIndex(address recipient) public view returns(uint){\n', '        return(recipientIndexes[recipient]);\n', '    }\n', '\n', '    function _getRecipientIndex(address recipient) internal returns(uint){\n', '        if (recipientIndexes[recipient]==0){\n', '            recipientIndexes[recipient]= recipientList.length;\n', '            recipientList.push(recipient);\n', '        }\n', '        return(recipientIndexes[recipient]);\n', '    }\n', '\n', '    function getTokenIndex(address token) internal returns(uint){\n', '        if (tokenIndexes[token]==0){\n', '            tokenList.push(token);\n', '            tokenIndexes[token]= tokenList.length;\n', '        }\n', '        return(tokenIndexes[token]);\n', '    }\n', '\n', '    function numDistributions(address recipient) public view returns(uint) {\n', '        return distributions[getRecipientIndex(recipient)].length;\n', '    }\n', '}']