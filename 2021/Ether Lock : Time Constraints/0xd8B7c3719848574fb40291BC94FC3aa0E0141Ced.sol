['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-22\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.4;\n', '\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a / b;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '\taddress public owner;\n', '\taddress public newOwner;\n', '\n', '\tevent OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n', '\n', '\tconstructor() {\n', '\t\towner = msg.sender;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '\n', '\tmodifier onlyOwner() {\n', '\t\trequire(msg.sender == owner, "only the owner can call this method");\n', '\t\t_;\n', '\t}\n', '\n', '\tfunction transferOwnership(address _newOwner) public onlyOwner {\n', '\t\trequire(address(0) != _newOwner, "ownership cannot be transferred to address 0");\n', '\t\tnewOwner = _newOwner;\n', '\t}\n', '\n', '\tfunction acceptOwnership() public {\n', '\t    require(newOwner != address(0), "no new owner has been set up");\n', '\t\trequire(msg.sender == newOwner, "only the new owner can accept ownership");\n', '\t\temit OwnershipTransferred(owner, msg.sender);\n', '\t\towner = msg.sender;\n', '\t\tnewOwner = address(0);\n', '\t}\n', '}\n', '\n', 'abstract contract tokenInterface {\n', '\tfunction balanceOf(address _owner) public virtual view returns (uint256 balance);\n', '\tfunction transfer(address _to, uint256 _value) public virtual returns (bool);\n', '\tfunction transferFrom(address sender, address recipient, uint256 amount) public virtual returns (bool);\n', '}\n', '\n', 'library ArrayManager {\n', '    function add(bytes32[] storage arr, mapping(bytes32 => uint256) storage indexMapping, bytes32 element) internal {\n', '        require(indexMapping[element] == 0, "The hash is already in the array.");\n', '        arr.push(element);\n', '        indexMapping[element] = arr.length;\n', '    }\n', '\n', '    function remove(bytes32[] storage arr, mapping(bytes32 => uint256) storage indexMapping, bytes32 element) internal {\n', '        require(indexMapping[element] != 0, "The address is not in the array.");\n', '        uint256 index = indexMapping[element]-1;\n', '        \n', '        bytes32 assetMoved = arr[arr.length-1];\n', '        \n', '        arr[index] = assetMoved;\n', '        indexMapping[assetMoved] = index+1;\n', '        \n', '\t\tindexMapping[element] = 0;\n', '        arr.pop();\n', '    }\n', '}\n', '\n', '\n', 'contract AtomicBridge is Ownable {\n', '    using SafeMath for uint256;\n', '    using ArrayManager for bytes32[];\n', '    \n', '    uint256 public constant aliceRecoveryTime = 48 * 60 * 60;\n', '    uint256 public constant bobRecoveryTime = 24 * 60 * 60;\n', '    \n', '    uint256 public DOSMitigationFee;\n', '    uint256 public proposalDOSMitigationFee;\n', '    uint256 public newFeeActivationTime;\n', '    \n', '    mapping (address => mapping (address => uint256)) public tknLockedOf;\n', '    \n', '    function setDOSMitigationFee(uint256 _newFee) public onlyOwner {\n', '        proposalDOSMitigationFee = _newFee;\n', '        newFeeActivationTime = block.timestamp;\n', '    }\n', '    \n', '    function activeDOSMitigationFee() public onlyOwner {\n', '        require( newFeeActivationTime != 0, "there is no new fee to be activated");\n', '        uint256 activationDate = newFeeActivationTime + aliceRecoveryTime + bobRecoveryTime;\n', '        require( block.timestamp > activationDate, "not enough time has passed not to change the rules");\n', '        DOSMitigationFee = proposalDOSMitigationFee;\n', '        proposalDOSMitigationFee = 0;\n', '        newFeeActivationTime = 0;\n', '    }\n', '    \n', '    struct deposit { \n', '        address payable from;\n', '        address payable to;\n', '        uint256 msgValue;\n', '        address tokenAddress;\n', '        uint256 tokenAmount;\n', '        bool spent;\n', '        uint256 recoveryStarted;\n', '        bool isAlice;\n', '    }\n', '    mapping (bytes32 => deposit) public depositList;\n', '    \n', '    mapping (address => bytes32[]) public recoveryList;\n', '    mapping(bytes32 => uint256) public indexOfrecoveryList;\n', '    \n', '    function readRecovery(address _user) public view returns(bytes32[] memory) {\n', '        return recoveryList[_user];\n', '    }\n', '    \n', '    function depositTkn(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bool _isAlice) internal returns (bool) {\n', '        require( depositList[_secretHash].from == address(0), "secret already used");\n', '        \n', '\n', '        tknLockedOf[msg.sender][_tokenAddress] = tknLockedOf[msg.sender][_tokenAddress].add(_tokenAmount);\n', '\n', '        \n', '        deposit memory d;\n', '        d.from = payable(msg.sender);\n', '        d.to = _to;\n', '        d.tokenAddress = _tokenAddress;\n', '        \n', '        if ( _tokenAddress != address(0) && _tokenAmount > 0 ) {\n', '            tokenInterface tkn = tokenInterface(_tokenAddress);\n', '            tkn.transferFrom(msg.sender, address(this), _tokenAmount);\n', '            d.tokenAmount = _tokenAmount;\n', '        }\n', '        \n', '        if ( msg.value > 0 ) {\n', '            d.msgValue = msg.value;\n', '        }\n', '        \n', '        d.isAlice = _isAlice;\n', '        depositList[_secretHash] = d;\n', '        \n', '        return true;\n', '    }\n', '    \n', '    event DepositStarted(bytes32 indexed secretHash, bytes msg);\n', '    function depositToken(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bool _isAlice, bytes memory _msg) internal returns (bool) {\n', '        depositTkn(_secretHash, _tokenAmount, _tokenAddress, _to, _isAlice);\n', '        emit DepositStarted(_secretHash, _msg);\n', '        return true;\n', '    }\n', '    \n', '    event DepositStarted(bytes32 indexed secretHash);\n', '    function depositWithoutMsg(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bool _isAlice) internal returns (bool) {\n', '        depositTkn(_secretHash, _tokenAmount, _tokenAddress, _to, _isAlice);\n', '        emit DepositStarted(_secretHash);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    function depositTokenAlice(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bytes memory _msg) public payable returns (bool) {\n', '        return depositToken(_secretHash, _tokenAmount, _tokenAddress, _to, true, _msg);\n', '    }\n', '    \n', '    function depositTokenBob(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to, bytes memory _msg) public payable returns (bool) {\n', '        return depositToken(_secretHash, _tokenAmount, _tokenAddress, _to, false, _msg);\n', '    }\n', '    \n', '    function depositAliceWithoutMsg(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to) public payable returns (bool) {\n', '        return depositWithoutMsg(_secretHash, _tokenAmount, _tokenAddress, _to, true);\n', '    }\n', '    \n', '    function depositBobWithoutMsg(bytes32 _secretHash, uint256 _tokenAmount, address _tokenAddress, address payable _to) public payable returns (bool) {\n', '        return depositWithoutMsg(_secretHash, _tokenAmount, _tokenAddress, _to, false);\n', '    }\n', '    \n', '    event withdrawStarted(bytes32 indexed secretHash, bytes32 secret);\n', '    function withdrawToken(bytes32 _secret) public returns (bool) {\n', '        bytes32 secretHash = keccak256(abi.encodePacked(_secret));\n', '        deposit memory d = depositList[secretHash];\n', '        \n', '        require( d.from != address(0), "the secret hash does not exist");\n', '        \n', '        require( !d.spent, "withdrawal already done" );\n', '        d.spent = true;\n', '\n', '        depositList[secretHash] = d;\n', '        \n', '        tknLockedOf[d.from][d.tokenAddress] = tknLockedOf[d.from][d.tokenAddress].sub(d.tokenAmount);\n', '\n', '        if (d.tokenAmount > 0) {\n', '            tokenInterface tkn = tokenInterface(d.tokenAddress);\n', '            tkn.transfer(d.to, d.tokenAmount);\n', '        }\n', '        \n', '        if ( d.msgValue > 0 ) {\n', '            d.to.transfer(d.msgValue);\n', '        }\n', '        \n', '        emit withdrawStarted(secretHash, _secret);\n', '        return true;\n', '    }\n', '    \n', '    event RecoveryStarted(bytes32 indexed secretHash);\n', '    function startRecovery(bytes32 _secretHash) public returns (bool) {\n', '        deposit memory d = depositList[_secretHash];\n', '        \n', '        require( d.from == msg.sender, "only the same sender can start a recovery" );\n', '        require( d.recoveryStarted == 0, "recovery is already started" );\n', '        \n', '        d.recoveryStarted = block.timestamp;\n', '        depositList[_secretHash] = d;\n', '        \n', '\t\trecoveryList[msg.sender].add(indexOfrecoveryList,_secretHash);\n', '        emit RecoveryStarted(_secretHash);\n', '        return true;\n', '    }\n', '    \n', '    function recoveryWithdraw(bytes32 _secretHash) public payable returns (bool) {\n', '        deposit memory d = depositList[_secretHash];\n', '        require( d.from == msg.sender, "only the same sender can withdraw a recovery." );\n', '        \n', '        if( d.isAlice ) {\n', '            require( block.timestamp >= d.recoveryStarted + aliceRecoveryTime, "You are not waiting long enough! You need to wait 48 hours" ); \n', '            \n', '            require( msg.value >= DOSMitigationFee, "Not enough DOSMitigationFee");\n', '            d.to.send(msg.value);\n', '        } else {\n', '            require( msg.value == 0, "only the creator of the secret has to pay the DOS Mitigation Fee");\n', '            require( block.timestamp >= d.recoveryStarted + bobRecoveryTime, "You are not waiting long enough! You need to wait 24 hours" );\n', '        }\n', '        \n', '        require( !d.spent, "deposit already spent" );\n', '        d.spent = true;\n', '        depositList[_secretHash] = d;\n', '\n', '        tknLockedOf[d.from][d.tokenAddress] = tknLockedOf[d.from][d.tokenAddress].sub(d.tokenAmount);\n', '\t\trecoveryList[msg.sender].remove(indexOfrecoveryList,_secretHash);\n', '        \n', '        if (d.tokenAmount > 0) {\n', '            tokenInterface tkn = tokenInterface(d.tokenAddress);\n', '            tkn.transfer(d.from, d.tokenAmount);\n', '        }   \n', '        \n', '        if ( d.msgValue > 0 ) {\n', '            d.from.transfer(d.msgValue);\n', '        }    \n', '        \n', '        return true;\n', '    }\n', '}']