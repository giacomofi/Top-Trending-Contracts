['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-01\n', '*/\n', '\n', '// File: contracts\\modules\\SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Halt.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract Halt is Ownable {\n', '    \n', '    bool private halted = false; \n', '    \n', '    modifier notHalted() {\n', '        require(!halted,"This contract is halted");\n', '        _;\n', '    }\n', '\n', '    modifier isHalted() {\n', '        require(halted,"This contract is not halted");\n', '        _;\n', '    }\n', '    \n', '    /// @notice function Emergency situation that requires \n', '    /// @notice contribution period to stop or not.\n', '    function setHalt(bool halt) \n', '        public \n', '        onlyOwner\n', '    {\n', '        halted = halt;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\whiteList.sol\n', '\n', 'pragma solidity >=0.5.16;\n', '/**\n', ' * SPDX-License-Identifier: GPL-3.0-or-later\n', ' * FinNexus\n', ' * Copyright (C) 2020 FinNexus Options Protocol\n', ' */\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint32.\n', '     */\n', 'library whiteListUint32 {\n', '    /**\n', '     * @dev add uint32 into white list.\n', '     * @param whiteList the storage whiteList.\n', '     * @param temp input value\n', '     */\n', '\n', '    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\n', '        if (!isEligibleUint32(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    /**\n', '     * @dev remove uint32 from whitelist.\n', '     */\n', '    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint256.\n', '     */\n', 'library whiteListUint256 {\n', '    // add whiteList\n', '    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\n', '        if (!isEligibleUint256(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible address.\n', '     */\n', 'library whiteListAddress {\n', '    // add whiteList\n', '    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\n', '        if (!isEligibleAddress(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Operator.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * each operator can be granted exclusive access to specific functions.\n', ' *\n', ' */\n', 'contract Operator is Ownable {\n', '    mapping(uint256=>address) private _operators;\n', '    /**\n', '     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyOperator(uint256 index) {\n', '        require(_operators[index] == msg.sender,"Operator: caller is not the eligible Operator");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev modify indexed operator by owner. \n', '     *\n', '     */\n', '    function setOperator(uint256 index,address addAddress)public onlyOwner{\n', '        _operators[index] = addAddress;\n', '    }\n', '    function getOperator(uint256 index)public view returns (address) {\n', '        return _operators[index];\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\AddressWhiteList.sol\n', '\n', 'pragma solidity >=0.5.16;\n', '/**\n', ' * SPDX-License-Identifier: GPL-3.0-or-later\n', ' * FinNexus\n', ' * Copyright (C) 2020 FinNexus Options Protocol\n', ' */\n', '\n', '\n', '    /**\n', '     * @dev Implementation of a whitelist filters a eligible address.\n', '     */\n', 'contract AddressWhiteList is Halt {\n', '\n', '    using whiteListAddress for address[];\n', '    // The eligible adress list\n', '    address[] internal whiteList;\n', '    /**\n', '     * @dev Implementation of add an eligible address into the whitelist.\n', '     * @param addAddress new eligible address.\n', '     */\n', '    function addWhiteList(address addAddress)public onlyOwner{\n', '        whiteList.addWhiteListAddress(addAddress);\n', '    }\n', '    /**\n', '     * @dev Implementation of revoke an invalid address from the whitelist.\n', '     * @param removeAddress revoked address.\n', '     */\n', '    function removeWhiteList(address removeAddress)public onlyOwner returns (bool){\n', '        return whiteList.removeWhiteListAddress(removeAddress);\n', '    }\n', '    /**\n', '     * @dev Implementation of getting the eligible whitelist.\n', '     */\n', '    function getWhiteList()public view returns (address[] memory){\n', '        return whiteList;\n', '    }\n', '    /**\n', '     * @dev Implementation of testing whether the input address is eligible.\n', '     * @param tmpAddress input address for testing.\n', '     */    \n', '    function isEligibleAddress(address tmpAddress) public view returns (bool){\n', '        return whiteList.isEligibleAddress(tmpAddress);\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\ReentrancyGuard.sol\n', '\n', 'pragma solidity =0.5.16;\n', 'contract ReentrancyGuard {\n', '\n', '  /**\n', '   * @dev We use a single lock for the whole contract.\n', '   */\n', '  bool private reentrancyLock = false;\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * @notice If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one nonReentrant function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and a `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    require(!reentrancyLock);\n', '    reentrancyLock = true;\n', '    _;\n', '    reentrancyLock = false;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts\\modules\\initializable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract initializable {\n', '\n', '    /**\n', '    * @dev Indicates that the contract has been initialized.\n', '    */\n', '    bool private initialized;\n', '\n', '    /**\n', '    * @dev Indicates that the contract is in the process of being initialized.\n', '    */\n', '    bool private initializing;\n', '\n', '    /**\n', '    * @dev Modifier to use in the initializer function of a contract.\n', '    */\n', '    modifier initializer() {\n', '        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '        bool wasInitializing = initializing;\n', '        initializing = true;\n', '        initialized = true;\n', '\n', '        _;\n', '\n', '        initializing = wasInitializing;\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        uint256 cs;\n', '        assembly { cs := extcodesize(address) }\n', '        return cs == 0;\n', '    }\n', '}\n', '\n', '// File: contracts\\fixedMinePool\\fixedMinePoolData.sol\n', '\n', 'pragma solidity =0.5.16;\n', '/**\n', ' * SPDX-License-Identifier: GPL-3.0-or-later\n', ' * FinNexus\n', ' * Copyright (C) 2020 FinNexus Options Protocol\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title new Finnexus Options Pool token mine pool.\n', ' * @dev A smart-contract which distribute some mine coins when you stake some FPT-A and FPT-B coins.\n', ' *      Users who both stake some FPT-A and FPT-B coins will get more bonus in mine pool.\n', ' *      Users who Lock FPT-B coins will get several times than normal miners.\n', ' */\n', 'contract fixedMinePoolData is initializable,Operator,Halt,AddressWhiteList,ReentrancyGuard {\n', '    //Special decimals for calculation\n', '    uint256 constant calDecimals = 1e18;\n', '\n', '    //The timestamp when the minepool begin.\n', '    uint256 internal _startTime;\n', '    //Single locked period duration.\n', '    uint256 internal constant _period = 30 days;\n', '    //The lock duration when user stake flexible FPT-B in this pool.\n', '    uint256 internal _flexibleExpired;\n', '\n', '    //The max locked peroid when user stake locked FPT-B coin.\n', '    uint256 constant internal _maxPeriod = 3;\n', '    //The max loop when user does nothing to this pool for long long time .\n', '    uint256 constant internal _maxLoop = 120;\n', "    //the mine distribution's ratio to FPT-A coin \n", '    uint256 constant internal _FPTARatio = 1000;\n', "    //the mine distribution's ratio to FPT-B coin \n", '    uint256 constant internal _FPTBRatio = 1000;\n', "    //the mine distribution's ratio to FPT-A and FPT-B coin repetition\n", '    uint256 constant internal _RepeatRatio = 20000;\n', '    //the accumulated weight each period has.\n', '    uint256 constant internal periodWeight = 1000;\n', '    uint256 constant internal baseWeight = 5000;\n', '\n', '    // FPT-A address\n', '    address internal _FPTA;\n', '    // FPT-B address\n', '    address internal _FPTB;\n', '\n', '    struct userInfo {\n', "        //user's FPT-A staked balance\n", '        uint256 _FPTABalance;\n', "        //user's FPT-B staked balance\n", '        uint256 _FPTBBalance;\n', '        //Period ID start at 1. if a PeriodID equals zero, it means your FPT-B is flexible staked.\n', "        //User's max locked period id;\n", '        uint256 maxPeriodID;\n', "        //User's max locked period timestamp. Flexible FPT-B is locked _flexibleExpired seconds;\n", '        uint256 lockedExpired;\n', "        //User's mine distribution.You can get base mine proportion by your distribution divided by total distribution.\n", '        uint256 distribution;\n', "        //User's settled mine coin balance.\n", '        mapping(address=>uint256) minerBalances;\n', "        //User's latest settled distribution net worth.\n", '        mapping(address=>uint256) minerOrigins;\n', "        //user's latest settlement period for each token.\n", '        mapping(address=>uint256) settlePeriod;\n', '    }\n', '    struct tokenMineInfo {\n', '        //mine distribution amount\n', '        uint256 mineAmount;\n', '        //mine distribution time interval\n', '        uint256 mineInterval;\n', '        //mine distribution first period\n', '        uint256 startPeriod;\n', '        //mine coin latest settlement time\n', '        uint256 latestSettleTime;\n', '        // total mine distribution till latest settlement time.\n', '        uint256 totalMinedCoin;\n', '        //latest distribution net worth;\n', '        uint256 minedNetWorth;\n', '        //period latest distribution net worth;\n', '        mapping(uint256=>uint256) periodMinedNetWorth;\n', '    }\n', '\n', "    //User's staking and mining info.\n", '    mapping(address=>userInfo) internal userInfoMap;\n', "    //each mine coin's mining info.\n", '    mapping(address=>tokenMineInfo) internal mineInfoMap;\n', '    //total weight distribution which is used to calculate total mined amount.\n', '    mapping(uint256=>uint256) internal weightDistributionMap;\n', '    //total Distribution\n', '    uint256 internal totalDistribution;\n', '\n', '    struct premiumDistribution {\n', '        //total premium distribution in each period\n', '        uint256 totalPremiumDistribution;\n', "        //User's premium distribution in each period\n", '        mapping(address=>uint256) userPremiumDistribution;\n', '\n', '    }\n', '    // premium mining info in each period.\n', '    mapping(uint256=>premiumDistribution) internal premiumDistributionMap;\n', "    //user's latest redeemed period index in the distributedPeriod list.\n", '    struct premiumInfo {\n', '        mapping(address=>uint256) lastPremiumIndex;\n', '        mapping(address=>uint256) premiumBalance;\n', '        //period id list which is already distributed by owner.\n', '        uint64[] distributedPeriod;\n', '        //total permium distributed by owner.\n', '        uint256 totalPremium;\n', '        //total premium distributed by owner in each period.\n', '        mapping(uint256=>uint256) periodPremium;\n', '    }\n', '    mapping(address=>premiumInfo) internal premiumMap;\n', '    address[] internal premiumCoinList;\n', '\n', '    /**\n', '     * @dev Emitted when `account` stake `amount` FPT-A coin.\n', '     */\n', '    event StakeFPTA(address indexed account,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `from` airdrop `recieptor` `amount` FPT-B coin.\n', '     */\n', '    event LockAirDrop(address indexed from,address indexed recieptor,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `account` stake `amount` FPT-B coin and locked `lockedPeriod` periods.\n', '     */\n', '    event StakeFPTB(address indexed account,uint256 amount,uint256 lockedPeriod);\n', '    /**\n', '     * @dev Emitted when `account` unstake `amount` FPT-A coin.\n', '     */\n', '    event UnstakeFPTA(address indexed account,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `account` unstake `amount` FPT-B coin.\n', '     */\n', '    event UnstakeFPTB(address indexed account,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `account` change `lockedPeriod` locked periods for FPT-B coin.\n', '     */\n', '    event ChangeLockedPeriod(address indexed account,uint256 lockedPeriod);\n', '    /**\n', '     * @dev Emitted when owner `account` distribute `amount` premium in `periodID` period.\n', '     */\n', '    event DistributePremium(address indexed account,address indexed premiumCoin,uint256 indexed periodID,uint256 amount);\n', '    /**\n', '     * @dev Emitted when `account` redeem `amount` premium.\n', '     */\n', '    event RedeemPremium(address indexed account,address indexed premiumCoin,uint256 amount);\n', '\n', '    /**\n', '     * @dev Emitted when `account` redeem `value` mineCoins.\n', '     */\n', '    event RedeemMineCoin(address indexed account, address indexed mineCoin, uint256 value);\n', '\n', '}\n', '\n', '// File: contracts\\ERC20\\IERC20.sol\n', '\n', 'pragma solidity =0.5.16;\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts\\modules\\Address.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call.value(value )(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\ERC20\\safeErc20.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\fixedMinePool\\fixedMinePool.sol\n', '\n', 'pragma solidity =0.5.16;\n', '/**\n', ' * SPDX-License-Identifier: GPL-3.0-or-later\n', ' * FinNexus\n', ' * Copyright (C) 2020 FinNexus Options Protocol\n', ' */\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title FNX period mine pool.\n', ' * @dev A smart-contract which distribute some mine coins when user stake FPT-A and FPT-B coins.\n', ' *\n', ' */\n', 'contract fixedMinePool is fixedMinePoolData {\n', '    using SafeMath for uint256;\n', '    /**\n', '     * @dev constructor.\n', "     * @param FPTA FPT-A coin's address,staking coin\n", "     * @param FPTB FPT-B coin's address,staking coin\n", '     * @param startTime the start time when this mine pool begin.\n', '     */\n', '    constructor(address FPTA,address FPTB,uint256 startTime)public{\n', '        _FPTA = FPTA;\n', '        _FPTB = FPTB;\n', '        _startTime = startTime;\n', '        initialize();\n', '    }\n', '    /**\n', '     * @dev default function for foundation input miner coins.\n', '     */\n', '    function()external payable{\n', '\n', '    }\n', '    function update()public onlyOwner{\n', '    }\n', '    /**\n', '     * @dev initial function when the proxy contract deployed.\n', '     */\n', '    function initialize() initializer public {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '        _flexibleExpired = 7 days;\n', '    }\n', '    /**\n', '     * @dev setting function.\n', "     * @param FPTA FPT-A coin's address,staking coin\n", "     * @param FPTB FPT-B coin's address,staking coin\n", '     * @param startTime the start time when this mine pool begin.\n', '     */\n', '    function setAddresses(address FPTA,address FPTB,uint256 startTime) public onlyOwner {\n', '        _FPTA = FPTA;\n', '        _FPTB = FPTB;\n', '        _startTime = startTime;\n', '    }\n', '    /**\n', "     * @dev getting function. Retrieve FPT-A coin's address\n", '     */\n', '    function getFPTAAddress()public view returns (address) {\n', '        return _FPTA;\n', '    }\n', '    /**\n', "     * @dev getting function. Retrieve FPT-B coin's address\n", '     */\n', '    function getFPTBAddress()public view returns (address) {\n', '        return _FPTB;\n', '    }\n', '    /**\n', "     * @dev getting function. Retrieve mine pool's start time.\n", '     */\n', '    function getStartTime()public view returns (uint256) {\n', '        return _startTime;\n', '    }\n', '    /**\n', '     * @dev getting current mine period ID.\n', '     */\n', '    function getCurrentPeriodID()public view returns (uint256) {\n', '        return getPeriodIndex(currentTime());\n', '    }\n', '    /**\n', "     * @dev getting user's staking FPT-A balance.\n", "     * @param account user's account\n", '     */\n', '    function getUserFPTABalance(address account)public view returns (uint256) {\n', '        return userInfoMap[account]._FPTABalance;\n', '    }\n', '    /**\n', "     * @dev getting user's staking FPT-B balance.\n", "     * @param account user's account\n", '     */\n', '    function getUserFPTBBalance(address account)public view returns (uint256) {\n', '        return userInfoMap[account]._FPTBBalance;\n', '    }\n', '    /**\n', "     * @dev getting user's maximium locked period ID.\n", "     * @param account user's account\n", '     */\n', '    function getUserMaxPeriodId(address account)public view returns (uint256) {\n', '        return userInfoMap[account].maxPeriodID;\n', '    }\n', '    /**\n', "     * @dev getting user's locked expired time. After this time user can unstake FPTB coins.\n", "     * @param account user's account\n", '     */\n', '    function getUserExpired(address account)public view returns (uint256) {\n', '        return userInfoMap[account].lockedExpired;\n', '    }\n', '    /**\n', "     * @dev getting whole pool's mine production weight ratio.\n", '     *      Real mine production equals base mine production multiply weight ratio.\n', '     */\n', '    function getMineWeightRatio()public view returns (uint256) {\n', '        if(totalDistribution > 0) {\n', '            return getweightDistribution(getPeriodIndex(currentTime()))*1000/totalDistribution;\n', '        }else{\n', '            return 1000;\n', '        }\n', '    }\n', '    /**\n', "     * @dev getting whole pool's mine shared distribution. All these distributions will share base mine production.\n", '     */\n', '    function getTotalDistribution() public view returns (uint256){\n', '        return totalDistribution;\n', '    }\n', '    /**\n', '     * @dev foundation redeem out mine coins.\n', '     * @param mineCoin mineCoin address\n', '     * @param amount redeem amount.\n', '     */\n', '    function redeemOut(address mineCoin,uint256 amount)public onlyOwner{\n', '        _redeem(msg.sender,mineCoin,amount);\n', '    }\n', '    /**\n', '     * @dev An auxiliary foundation which transter amount mine coins to recieptor.\n', "     * @param recieptor recieptor recieptor's account.\n", '     * @param mineCoin mineCoin address\n', '     * @param amount redeem amount.\n', '     */\n', '    function _redeem(address payable recieptor,address mineCoin,uint256 amount) internal{\n', '        if (mineCoin == address(0)){\n', '            recieptor.transfer(amount);\n', '        }else{\n', '            IERC20 token = IERC20(mineCoin);\n', '            uint256 preBalance = token.balanceOf(address(this));\n', '            SafeERC20.safeTransfer(token,recieptor,amount);\n', '//            token.transfer(recieptor,amount);\n', '            uint256 afterBalance = token.balanceOf(address(this));\n', '            require(preBalance - afterBalance == amount,"settlement token transfer error!");\n', '        }\n', '    }\n', '    /**\n', '     * @dev retrieve total distributed mine coins.\n', '     * @param mineCoin mineCoin address\n', '     */\n', '    function getTotalMined(address mineCoin)public view returns(uint256){\n', '        return mineInfoMap[mineCoin].totalMinedCoin.add(_getLatestMined(mineCoin));\n', '    }\n', '    /**\n', '     * @dev retrieve minecoin distributed informations.\n', '     * @param mineCoin mineCoin address\n', '     * @return distributed amount and distributed time interval.\n', '     */\n', '    function getMineInfo(address mineCoin)public view returns(uint256,uint256){\n', '        return (mineInfoMap[mineCoin].mineAmount,mineInfoMap[mineCoin].mineInterval);\n', '    }\n', '    /**\n', "     * @dev retrieve user's mine balance.\n", "     * @param account user's account\n", '     * @param mineCoin mineCoin address\n', '     */\n', '    function getMinerBalance(address account,address mineCoin)public view returns(uint256){\n', '        return userInfoMap[account].minerBalances[mineCoin].add(_getUserLatestMined(mineCoin,account));\n', '    }\n', '    /**\n', '     * @dev Set mineCoin mine info, only foundation owner can invoked.\n', '     * @param mineCoin mineCoin address\n', '     * @param _mineAmount mineCoin distributed amount\n', '     * @param _mineInterval mineCoin distributied time interval\n', '     */\n', '    function setMineCoinInfo(address mineCoin,uint256 _mineAmount,uint256 _mineInterval)public onlyOwner {\n', '        require(_mineAmount<1e30,"input mine amount is too large");\n', '        require(_mineInterval>0,"input mine Interval must larger than zero");\n', '        _mineSettlement(mineCoin);\n', '        mineInfoMap[mineCoin].mineAmount = _mineAmount;\n', '        mineInfoMap[mineCoin].mineInterval = _mineInterval;\n', '        if (mineInfoMap[mineCoin].startPeriod == 0){\n', '            mineInfoMap[mineCoin].startPeriod = getPeriodIndex(currentTime());\n', '        }\n', '        addWhiteList(mineCoin);\n', '    }\n', '\n', '    /**\n', '     * @dev user redeem mine rewards.\n', '     * @param mineCoin mine coin address\n', '     * @param amount redeem amount.\n', '     */\n', '    function redeemMinerCoin(address mineCoin,uint256 amount)public nonReentrant notHalted {\n', '        _mineSettlement(mineCoin);\n', '        _settleUserMine(mineCoin,msg.sender);\n', '        _redeemMineCoin(mineCoin,msg.sender,amount);\n', '    }\n', '    /**\n', '     * @dev subfunction for user redeem mine rewards.\n', '     * @param mineCoin mine coin address\n', "     * @param recieptor recieptor's account\n", '     * @param amount redeem amount.\n', '     */\n', '    function _redeemMineCoin(address mineCoin,address payable recieptor,uint256 amount) internal {\n', '        require (amount > 0,"input amount must more than zero!");\n', '        userInfoMap[recieptor].minerBalances[mineCoin] = \n', '            userInfoMap[recieptor].minerBalances[mineCoin].sub(amount);\n', '        _redeem(recieptor,mineCoin,amount);\n', '        emit RedeemMineCoin(recieptor,mineCoin,amount);\n', '    }\n', '\n', '    /**\n', '     * @dev settle all mine coin.\n', '     */    \n', '    function _mineSettlementAll()internal{\n', '        uint256 addrLen = whiteList.length;\n', '        for(uint256 i=0;i<addrLen;i++){\n', '            _mineSettlement(whiteList[i]);\n', '        }\n', '    }\n', '    /**\n', '     * @dev convert timestamp to period ID.\n', '     * @param _time timestamp. \n', '     */ \n', '    function getPeriodIndex(uint256 _time) public view returns (uint256) {\n', '        if (_time<_startTime){\n', '            return 0;\n', '        }\n', '        return _time.sub(_startTime).div(_period)+1;\n', '    }\n', '    /**\n', "     * @dev convert period ID to period's finish timestamp.\n", '     * @param periodID period ID. \n', '     */\n', '    function getPeriodFinishTime(uint256 periodID)public view returns (uint256) {\n', '        return periodID.mul(_period).add(_startTime);\n', '    }\n', '    function getCurrentTotalAPY(address mineCoin)public view returns (uint256) {\n', '        if (totalDistribution == 0 || mineInfoMap[mineCoin].mineInterval == 0){\n', '            return 0;\n', '        }\n', '        uint256 baseMine = mineInfoMap[mineCoin].mineAmount.mul(365 days)/mineInfoMap[mineCoin].mineInterval;\n', '        return baseMine.mul(getweightDistribution(getPeriodIndex(currentTime())))/totalDistribution;\n', '    }\n', '    /**\n', "     * @dev Calculate user's current APY.\n", "     * @param account user's account.\n", '     * @param mineCoin mine coin address\n', '     */\n', '    function getUserCurrentAPY(address account,address mineCoin)public view returns (uint256) {\n', '        if (totalDistribution == 0 || mineInfoMap[mineCoin].mineInterval == 0){\n', '            return 0;\n', '        }\n', '        uint256 baseMine = mineInfoMap[mineCoin].mineAmount.mul(365 days).mul(\n', '                userInfoMap[account].distribution)/totalDistribution/mineInfoMap[mineCoin].mineInterval;\n', '        return baseMine.mul(getPeriodWeight(getPeriodIndex(currentTime()),userInfoMap[account].maxPeriodID))/1000;\n', '    }\n', '    /**\n', '     * @dev Calculate average locked time.\n', '     */\n', '    function getAverageLockedTime()public view returns (uint256) {\n', '        if (totalDistribution == 0){\n', '            return 0;\n', '        }\n', '        uint256 i = _maxPeriod-1;\n', '        uint256 nowIndex = getPeriodIndex(currentTime());\n', '        uint256[] memory periodLocked = new uint256[](_maxPeriod);\n', '        for (;;i--){\n', '            periodLocked[i] = weightDistributionMap[nowIndex+i];\n', '            for(uint256 j=i+1;j<_maxPeriod;j++){\n', '                if (periodLocked[j]>0){\n', '                    periodLocked[i] = periodLocked[i].sub(periodLocked[j].mul(getPeriodWeight(i,j)-1000)/1000);\n', '                }\n', '            }\n', '            periodLocked[i] = periodLocked[i]*1000/(getPeriodWeight(nowIndex,nowIndex)-1000);\n', '            if (i == 0){\n', '                break;\n', '            }\n', '        }\n', '        uint256 allLockedPeriod = 0;\n', '        for(i=0;i<_maxPeriod;i++){\n', '            allLockedPeriod = allLockedPeriod.add(periodLocked[i].mul(getPeriodFinishTime(nowIndex+i).sub(currentTime())));\n', '        }\n', '        return allLockedPeriod.div(totalDistribution);\n', '    }\n', '\n', '    /**\n', '     * @dev the auxiliary function for _mineSettlementAll.\n', '     * @param mineCoin mine coin address\n', '     */    \n', '    function _mineSettlement(address mineCoin)internal{\n', '        uint256 latestTime = mineInfoMap[mineCoin].latestSettleTime;\n', '        uint256 curIndex = getPeriodIndex(latestTime);\n', '        if (curIndex == 0){\n', '            latestTime = _startTime;\n', '        }\n', '        uint256 nowIndex = getPeriodIndex(currentTime());\n', '        if (nowIndex == 0){\n', '            return;\n', '        }\n', '        for (uint256 i=0;i<_maxLoop;i++){\n', '            // If the fixed distribution is zero, we only need calculate \n', '            uint256 finishTime = getPeriodFinishTime(curIndex);\n', '            if (finishTime < currentTime()){\n', '                _mineSettlementPeriod(mineCoin,curIndex,finishTime.sub(latestTime));\n', '                latestTime = finishTime;\n', '            }else{\n', '                _mineSettlementPeriod(mineCoin,curIndex,currentTime().sub(latestTime));\n', '                latestTime = currentTime();\n', '                break;\n', '            }\n', '            curIndex++;\n', '            if (curIndex > nowIndex){\n', '                break;\n', '            }\n', '        }\n', '        mineInfoMap[mineCoin].periodMinedNetWorth[nowIndex] = mineInfoMap[mineCoin].minedNetWorth;\n', '        uint256 _mineInterval = mineInfoMap[mineCoin].mineInterval;\n', '        if (_mineInterval>0){\n', '            mineInfoMap[mineCoin].latestSettleTime = currentTime()/_mineInterval*_mineInterval;\n', '        }else{\n', '            mineInfoMap[mineCoin].latestSettleTime = currentTime();\n', '        }\n', '    }\n', '    /**\n', '     * @dev the auxiliary function for _mineSettlement. Calculate and record a period mine production. \n', '     * @param mineCoin mine coin address\n', '     * @param periodID period time\n', '     * @param mineTime covered time.\n', '     */  \n', '    function _mineSettlementPeriod(address mineCoin,uint256 periodID,uint256 mineTime)internal{\n', '        uint256 totalDistri = totalDistribution;\n', '        if (totalDistri > 0){\n', '            uint256 latestMined = _getPeriodMined(mineCoin,mineTime);\n', '            if (latestMined>0){\n', '                mineInfoMap[mineCoin].minedNetWorth = mineInfoMap[mineCoin].minedNetWorth.add(latestMined.mul(calDecimals)/totalDistri);\n', '                mineInfoMap[mineCoin].totalMinedCoin = mineInfoMap[mineCoin].totalMinedCoin.add(latestMined.mul(\n', '                    getweightDistribution(periodID))/totalDistri);\n', '            }\n', '        }\n', '        mineInfoMap[mineCoin].periodMinedNetWorth[periodID] = mineInfoMap[mineCoin].minedNetWorth;\n', '    }\n', '    /**\n', "     * @dev Calculate and record user's mine production. \n", '     * @param mineCoin mine coin address\n', "     * @param account user's account\n", '     */  \n', '    function _settleUserMine(address mineCoin,address account) internal {\n', '        uint256 nowIndex = getPeriodIndex(currentTime());\n', '        if (nowIndex == 0){\n', '            return;\n', '        }\n', '        if(userInfoMap[account].distribution>0){\n', '            uint256 userPeriod = userInfoMap[account].settlePeriod[mineCoin];\n', '            if(userPeriod == 0){\n', '                userPeriod = 1;\n', '            }\n', '            if (userPeriod < mineInfoMap[mineCoin].startPeriod){\n', '                userPeriod = mineInfoMap[mineCoin].startPeriod;\n', '            }\n', '            for (uint256 i = 0;i<_maxLoop;i++){\n', '                _settlementPeriod(mineCoin,account,userPeriod);\n', '                if (userPeriod >= nowIndex){\n', '                    break;\n', '                }\n', '                userPeriod++;\n', '            }\n', '        }\n', '        userInfoMap[account].minerOrigins[mineCoin] = _getTokenNetWorth(mineCoin,nowIndex);\n', '        userInfoMap[account].settlePeriod[mineCoin] = nowIndex;\n', '    }\n', '    /**\n', '     * @dev the auxiliary function for _settleUserMine. Calculate and record a period mine production. \n', '     * @param mineCoin mine coin address\n', "     * @param account user's account\n", '     * @param periodID period time\n', '     */ \n', '    function _settlementPeriod(address mineCoin,address account,uint256 periodID) internal {\n', '        uint256 tokenNetWorth = _getTokenNetWorth(mineCoin,periodID);\n', '        if (totalDistribution > 0){\n', '            userInfoMap[account].minerBalances[mineCoin] = userInfoMap[account].minerBalances[mineCoin].add(\n', '                _settlement(mineCoin,account,periodID,tokenNetWorth));\n', '        }\n', '        userInfoMap[account].minerOrigins[mineCoin] = tokenNetWorth;\n', '    }\n', '    /**\n', "     * @dev retrieve each period's networth. \n", '     * @param mineCoin mine coin address\n', '     * @param periodID period time\n', '     */ \n', '    function _getTokenNetWorth(address mineCoin,uint256 periodID)internal view returns(uint256){\n', '        return mineInfoMap[mineCoin].periodMinedNetWorth[periodID];\n', '    }\n', '\n', '    /**\n', '     * @dev the auxiliary function for getMinerBalance. Calculate mine amount during latest time phase.\n', '     * @param mineCoin mine coin address\n', "     * @param account user's account\n", '     */ \n', '    function _getUserLatestMined(address mineCoin,address account)internal view returns(uint256){\n', '        uint256 userDistri = userInfoMap[account].distribution;\n', '        if (userDistri == 0){\n', '            return 0;\n', '        }\n', '        uint256 userperiod = userInfoMap[account].settlePeriod[mineCoin];\n', '        if (userperiod < mineInfoMap[mineCoin].startPeriod){\n', '            userperiod = mineInfoMap[mineCoin].startPeriod;\n', '        }\n', '        uint256 origin = userInfoMap[account].minerOrigins[mineCoin];\n', '        uint256 latestMined = 0;\n', '        uint256 nowIndex = getPeriodIndex(currentTime());\n', '        uint256 userMaxPeriod = userInfoMap[account].maxPeriodID;\n', '        uint256 netWorth = _getTokenNetWorth(mineCoin,userperiod);\n', '\n', '        for (uint256 i=0;i<_maxLoop;i++){\n', '            if(userperiod > nowIndex){\n', '                break;\n', '            }\n', '            if (totalDistribution == 0){\n', '                break;\n', '            }\n', '            netWorth = getPeriodNetWorth(mineCoin,userperiod,netWorth);\n', '            latestMined = latestMined.add(userDistri.mul(netWorth.sub(origin)).mul(getPeriodWeight(userperiod,userMaxPeriod))/1000/calDecimals);\n', '            origin = netWorth;\n', '            userperiod++;\n', '        }\n', '        return latestMined;\n', '    }\n', '    /**\n', '     * @dev the auxiliary function for _getUserLatestMined. Calculate token net worth in each period.\n', '     * @param mineCoin mine coin address\n', '     * @param periodID Period ID\n', "     * @param preNetWorth The previous period's net worth.\n", '     */ \n', '    function getPeriodNetWorth(address mineCoin,uint256 periodID,uint256 preNetWorth) internal view returns(uint256) {\n', '        uint256 latestTime = mineInfoMap[mineCoin].latestSettleTime;\n', '        uint256 curPeriod = getPeriodIndex(latestTime);\n', '        if(periodID < curPeriod){\n', '            return mineInfoMap[mineCoin].periodMinedNetWorth[periodID];\n', '        }else{\n', '            if (preNetWorth<mineInfoMap[mineCoin].periodMinedNetWorth[periodID]){\n', '                preNetWorth = mineInfoMap[mineCoin].periodMinedNetWorth[periodID];\n', '            }\n', '            uint256 finishTime = getPeriodFinishTime(periodID);\n', '            if (finishTime >= currentTime()){\n', '                finishTime = currentTime();\n', '            }\n', '            if(periodID > curPeriod){\n', '                latestTime = getPeriodFinishTime(periodID-1);\n', '            }\n', '            if (totalDistribution == 0){\n', '                return preNetWorth;\n', '            }\n', '            uint256 periodMind = _getPeriodMined(mineCoin,finishTime.sub(latestTime));\n', '            return preNetWorth.add(periodMind.mul(calDecimals)/totalDistribution);\n', '        }\n', '    }\n', '    /**\n', '     * @dev the auxiliary function for getTotalMined. Calculate mine amount during latest time phase .\n', '     * @param mineCoin mine coin address\n', '     */ \n', '    function _getLatestMined(address mineCoin)internal view returns(uint256){\n', '        uint256 latestTime = mineInfoMap[mineCoin].latestSettleTime;\n', '        uint256 curIndex = getPeriodIndex(latestTime);\n', '        uint256 latestMined = 0;\n', '        for (uint256 i=0;i<_maxLoop;i++){\n', '            if (totalDistribution == 0){\n', '                break;\n', '            }\n', '            uint256 finishTime = getPeriodFinishTime(curIndex);\n', '            if (finishTime < currentTime()){\n', '                latestMined = latestMined.add(_getPeriodWeightMined(mineCoin,curIndex,finishTime.sub(latestTime)));\n', '            }else{\n', '                latestMined = latestMined.add(_getPeriodWeightMined(mineCoin,curIndex,currentTime().sub(latestTime)));\n', '                break;\n', '            }\n', '            curIndex++;\n', '            latestTime = finishTime;\n', '        }\n', '        return latestMined;\n', '    }\n', '    /**\n', '     * @dev Calculate mine amount\n', '     * @param mineCoin mine coin address\n', '     * @param mintTime mine duration.\n', '     */ \n', '    function _getPeriodMined(address mineCoin,uint256 mintTime)internal view returns(uint256){\n', '        uint256 _mineInterval = mineInfoMap[mineCoin].mineInterval;\n', '        if (totalDistribution > 0 && _mineInterval>0){\n', '            uint256 _mineAmount = mineInfoMap[mineCoin].mineAmount;\n', '            mintTime = mintTime/_mineInterval;\n', '            uint256 latestMined = _mineAmount.mul(mintTime);\n', '            return latestMined;\n', '        }\n', '        return 0;\n', '    }\n', '    /**\n', '     * @dev Calculate mine amount multiply weight ratio in each period.\n', '     * @param mineCoin mine coin address\n', '     * @param mineCoin period ID.\n', '     * @param mintTime mine duration.\n', '     */ \n', '    function _getPeriodWeightMined(address mineCoin,uint256 periodID,uint256 mintTime)internal view returns(uint256){\n', '        if (totalDistribution > 0){\n', '            return _getPeriodMined(mineCoin,mintTime).mul(getweightDistribution(periodID))/totalDistribution;\n', '        }\n', '        return 0;\n', '    }\n', '    /**\n', "     * @dev Auxiliary function, calculate user's latest mine amount.\n", '     * @param mineCoin the mine coin address\n', "     * @param account user's account\n", '     * @param tokenNetWorth the latest token net worth\n', '     */\n', '    function _settlement(address mineCoin,address account,uint256 periodID,uint256 tokenNetWorth)internal view returns (uint256) {\n', '        uint256 origin = userInfoMap[account].minerOrigins[mineCoin];\n', '        uint256 userMaxPeriod = userInfoMap[account].maxPeriodID;\n', '        require(tokenNetWorth>=origin,"error: tokenNetWorth logic error!");\n', '        return userInfoMap[account].distribution.mul(tokenNetWorth-origin).mul(getPeriodWeight(periodID,userMaxPeriod))/1000/calDecimals;\n', '    }\n', '    /**\n', '     * @dev Stake FPT-A coin and get distribution for mining.\n', '     * @param amount FPT-A amount that transfer into mine pool.\n', '     */\n', '    function stakeFPTA(uint256 amount)public minePoolStarted nonReentrant notHalted{\n', '        amount = getPayableAmount(_FPTA,amount);\n', "        require(amount > 0, 'stake amount is zero');\n", '        removeDistribution(msg.sender);\n', '        userInfoMap[msg.sender]._FPTABalance = userInfoMap[msg.sender]._FPTABalance.add(amount);\n', '        addDistribution(msg.sender);\n', '        emit StakeFPTA(msg.sender,amount);\n', '    }\n', '    /**\n', '     * @dev Air drop to user some FPT-B coin and lock one period and get distribution for mining.\n', "     * @param user air drop's recieptor.\n", '     * @param ftp_b_amount FPT-B amount that transfer into mine pool.\n', '     */\n', '    function lockAirDrop(address user,uint256 ftp_b_amount) minePoolStarted notHalted external{\n', '        if (msg.sender == getOperator(1)){\n', '            lockAirDrop_base(user,ftp_b_amount);\n', '        }else if (msg.sender == getOperator(2)){\n', '            lockAirDrop_stake(user,ftp_b_amount);\n', '        }else{\n', '            require(false ,"Operator: caller is not the eligible Operator");\n', '        }\n', '    }\n', '    function lockAirDrop_base(address user,uint256 ftp_b_amount) internal{\n', '        uint256 curPeriod = getPeriodIndex(currentTime());\n', '        uint256 maxId = userInfoMap[user].maxPeriodID;\n', '        uint256 lockedPeriod = curPeriod > maxId ? curPeriod : maxId;\n', '        ftp_b_amount = getPayableAmount(_FPTB,ftp_b_amount);\n', "        require(ftp_b_amount > 0, 'stake amount is zero');\n", '        removeDistribution(user);\n', '        userInfoMap[user]._FPTBBalance = userInfoMap[user]._FPTBBalance.add(ftp_b_amount);\n', '        userInfoMap[user].maxPeriodID = lockedPeriod;\n', '        userInfoMap[user].lockedExpired = getPeriodFinishTime(lockedPeriod);\n', '        addDistribution(user);\n', '        emit LockAirDrop(msg.sender,user,ftp_b_amount);\n', '    } \n', '    function lockAirDrop_stake(address user,uint256 lockedPeriod) internal validPeriod(lockedPeriod) {\n', '        uint256 curPeriod = getPeriodIndex(currentTime());\n', '        uint256 userMaxPeriod = curPeriod+lockedPeriod-1;\n', '\n', '        require(userMaxPeriod>=userInfoMap[user].maxPeriodID, "lockedPeriod cannot be smaller than current locked period");\n', '        if(userInfoMap[user].maxPeriodID<curPeriod && lockedPeriod == 1){\n', "            require(getPeriodFinishTime(getCurrentPeriodID()+lockedPeriod)>currentTime() + _flexibleExpired, 'locked time must greater than flexible expiration');\n", '        }\n', '        uint256 ftp_a_amount = IERC20(_FPTA).balanceOf(msg.sender);\n', '        ftp_a_amount = getPayableAmount(_FPTA,ftp_a_amount);\n', '        uint256 ftp_b_amount = IERC20(_FPTB).balanceOf(msg.sender);\n', '        ftp_b_amount = getPayableAmount(_FPTB,ftp_b_amount);\n', "        require(ftp_a_amount > 0 || ftp_b_amount > 0, 'stake amount is zero');\n", '        removeDistribution(user);\n', '        userInfoMap[user]._FPTABalance = userInfoMap[user]._FPTABalance.add(ftp_a_amount);\n', '        userInfoMap[user]._FPTBBalance = userInfoMap[user]._FPTBBalance.add(ftp_b_amount);\n', '        if (userInfoMap[user]._FPTBBalance > 0)\n', '        {\n', '            if (lockedPeriod == 0){\n', '                userInfoMap[user].maxPeriodID = 0;\n', '                if (ftp_b_amount>0){\n', '                    userInfoMap[user].lockedExpired = currentTime().add(_flexibleExpired);\n', '                }\n', '            }else{\n', '                userInfoMap[user].maxPeriodID = userMaxPeriod;\n', '                userInfoMap[user].lockedExpired = getPeriodFinishTime(userMaxPeriod);\n', '            }\n', '        }\n', '        addDistribution(user);\n', '        emit StakeFPTA(user,ftp_a_amount);\n', '        emit StakeFPTB(user,ftp_b_amount,lockedPeriod);\n', '    } \n', '    /**\n', '     * @dev Stake FPT-B coin and lock locedPreiod and get distribution for mining.\n', '     * @param amount FPT-B amount that transfer into mine pool.\n', '     * @param lockedPeriod locked preiod number.\n', '     */\n', '    function stakeFPTB(uint256 amount,uint256 lockedPeriod)public validPeriod(lockedPeriod) minePoolStarted nonReentrant notHalted{\n', '        uint256 curPeriod = getPeriodIndex(currentTime());\n', '        uint256 userMaxPeriod = curPeriod+lockedPeriod-1;\n', '        require(userMaxPeriod>=userInfoMap[msg.sender].maxPeriodID, "lockedPeriod cannot be smaller than current locked period");\n', '        if(userInfoMap[msg.sender].maxPeriodID<curPeriod && lockedPeriod == 1){\n', "            require(getPeriodFinishTime(getCurrentPeriodID()+lockedPeriod)>currentTime() + _flexibleExpired, 'locked time must greater than 15 days');\n", '        }\n', '        amount = getPayableAmount(_FPTB,amount);\n', "        require(amount > 0, 'stake amount is zero');\n", '        removeDistribution(msg.sender);\n', '        userInfoMap[msg.sender]._FPTBBalance = userInfoMap[msg.sender]._FPTBBalance.add(amount);\n', '        if (lockedPeriod == 0){\n', '            userInfoMap[msg.sender].maxPeriodID = 0;\n', '            userInfoMap[msg.sender].lockedExpired = currentTime().add(_flexibleExpired);\n', '        }else{\n', '            userInfoMap[msg.sender].maxPeriodID = userMaxPeriod;\n', '            userInfoMap[msg.sender].lockedExpired = getPeriodFinishTime(userMaxPeriod);\n', '        }\n', '        addDistribution(msg.sender);\n', '        emit StakeFPTB(msg.sender,amount,lockedPeriod);\n', '    }\n', '    /**\n', '     * @dev withdraw FPT-A coin.\n', '     * @param amount FPT-A amount that withdraw from mine pool.\n', '     */\n', '    function unstakeFPTA(uint256 amount)public nonReentrant notHalted{\n', "        require(amount > 0, 'unstake amount is zero');\n", '        require(userInfoMap[msg.sender]._FPTABalance >= amount,\n', "            'unstake amount is greater than total user stakes');\n", '        removeDistribution(msg.sender);\n', '        userInfoMap[msg.sender]._FPTABalance = userInfoMap[msg.sender]._FPTABalance - amount;\n', '        addDistribution(msg.sender);\n', '        _redeem(msg.sender,_FPTA,amount);\n', '        emit UnstakeFPTA(msg.sender,amount);\n', '    }\n', '    /**\n', '     * @dev withdraw FPT-B coin.\n', '     * @param amount FPT-B amount that withdraw from mine pool.\n', '     */\n', '    function unstakeFPTB(uint256 amount)public nonReentrant notHalted minePoolStarted periodExpired(msg.sender){\n', "        require(amount > 0, 'unstake amount is zero');\n", '        require(userInfoMap[msg.sender]._FPTBBalance >= amount,\n', "            'unstake amount is greater than total user stakes');\n", '        removeDistribution(msg.sender);\n', '        userInfoMap[msg.sender]._FPTBBalance = userInfoMap[msg.sender]._FPTBBalance - amount;\n', '        addDistribution(msg.sender);\n', '        _redeem(msg.sender,_FPTB,amount);\n', '        emit UnstakeFPTB(msg.sender,amount);\n', '    }\n', '    /**\n', '     * @dev Add FPT-B locked period.\n', '     * @param lockedPeriod FPT-B locked preiod number.\n', '     */\n', '    function changeFPTBLockedPeriod(uint256 lockedPeriod)public validPeriod(lockedPeriod) minePoolStarted notHalted{\n', '        require(userInfoMap[msg.sender]._FPTBBalance > 0, "stake FPTB balance is zero");\n', '        uint256 curPeriod = getPeriodIndex(currentTime());\n', '        require(curPeriod+lockedPeriod-1>=userInfoMap[msg.sender].maxPeriodID, "lockedPeriod cannot be smaller than current locked period");\n', '        removeDistribution(msg.sender); \n', '        if (lockedPeriod == 0){\n', '            userInfoMap[msg.sender].maxPeriodID = 0;\n', '            userInfoMap[msg.sender].lockedExpired = currentTime().add(_flexibleExpired);\n', '        }else{\n', '            userInfoMap[msg.sender].maxPeriodID = curPeriod+lockedPeriod-1;\n', '            userInfoMap[msg.sender].lockedExpired = getPeriodFinishTime(curPeriod+lockedPeriod-1);\n', '        }\n', '        addDistribution(msg.sender);\n', '        emit ChangeLockedPeriod(msg.sender,lockedPeriod);\n', '    }\n', '    /**\n', "     * @dev Auxiliary function. getting user's payment\n", "     * @param settlement user's payment coin.\n", "     * @param settlementAmount user's payment amount.\n", '     */\n', '    function getPayableAmount(address settlement,uint256 settlementAmount) internal returns (uint256) {\n', '        if (settlement == address(0)){\n', '            settlementAmount = msg.value;\n', '        }else if (settlementAmount > 0){\n', '            IERC20 oToken = IERC20(settlement);\n', '            uint256 preBalance = oToken.balanceOf(address(this));\n', '            SafeERC20.safeTransferFrom(oToken,msg.sender, address(this), settlementAmount);\n', '            //oToken.transferFrom(msg.sender, address(this), settlementAmount);\n', '            uint256 afterBalance = oToken.balanceOf(address(this));\n', '            require(afterBalance-preBalance==settlementAmount,"settlement token transfer error!");\n', '        }\n', '        return settlementAmount;\n', '    }\n', '    /**\n', "     * @dev Auxiliary function. Clear user's distribution amount.\n", "     * @param account user's account.\n", '     */\n', '    function removeDistribution(address account) internal {\n', '        uint256 addrLen = whiteList.length;\n', '        for(uint256 i=0;i<addrLen;i++){\n', '            _mineSettlement(whiteList[i]);\n', '            _settleUserMine(whiteList[i],account);\n', '        }\n', '        uint256 distri = calculateDistribution(account);\n', '        totalDistribution = totalDistribution.sub(distri);\n', '        uint256 nowId = getPeriodIndex(currentTime());\n', '        uint256 endId = userInfoMap[account].maxPeriodID;\n', '        for(;nowId<=endId;nowId++){\n', '            weightDistributionMap[nowId] = weightDistributionMap[nowId].sub(distri.mul(getPeriodWeight(nowId,endId)-1000)/1000);\n', '        }\n', '        userInfoMap[account].distribution =  0;\n', '        removePremiumDistribution(account);\n', '    }\n', '    /**\n', "     * @dev Auxiliary function. Add user's distribution amount.\n", "     * @param account user's account.\n", '     */\n', '    function addDistribution(address account) internal {\n', '        uint256 distri = calculateDistribution(account);\n', '        uint256 nowId = getPeriodIndex(currentTime());\n', '        uint256 endId = userInfoMap[account].maxPeriodID;\n', '        for(;nowId<=endId;nowId++){\n', '            weightDistributionMap[nowId] = weightDistributionMap[nowId].add(distri.mul(getPeriodWeight(nowId,endId)-1000)/1000);\n', '        }\n', '        userInfoMap[account].distribution =  distri;\n', '        totalDistribution = totalDistribution.add(distri);\n', '        addPremiumDistribution(account);\n', '    }\n', '    /**\n', "     * @dev Auxiliary function. calculate user's distribution.\n", "     * @param account user's account.\n", '     */\n', '    function calculateDistribution(address account) internal view returns (uint256){\n', '        uint256 fptAAmount = userInfoMap[account]._FPTABalance;\n', '        uint256 fptBAmount = userInfoMap[account]._FPTBBalance;\n', '        uint256 repeat = (fptAAmount>fptBAmount*10) ? fptBAmount*10 : fptAAmount;\n', '        return _FPTARatio.mul(fptAAmount).add(_FPTBRatio.mul(fptBAmount)).add(\n', '            _RepeatRatio.mul(repeat));\n', '    }\n', '    /**\n', '     * @dev Auxiliary function. get weight distribution in each period.\n', '     * @param periodID period ID.\n', '     */\n', '    function getweightDistribution(uint256 periodID)internal view returns (uint256) {\n', '        return weightDistributionMap[periodID].add(totalDistribution);\n', '    }\n', '    /**\n', "     * @dev Auxiliary function. get mine weight ratio from current period to one's maximium period.\n", '     * @param currentID current period ID.\n', "     * @param maxPeriod user's maximium period ID.\n", '     */\n', '    function getPeriodWeight(uint256 currentID,uint256 maxPeriod) public pure returns (uint256) {\n', '        if (maxPeriod == 0 || currentID > maxPeriod){\n', '            return 1000;\n', '        }\n', '        uint256 curLocked = maxPeriod-currentID;\n', '        if(curLocked == 0){\n', '            return 1600;\n', '        }else if(curLocked == 1){\n', '            return 3200;\n', '        }else{\n', '            return 5000;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev retrieve total distributed options premium.\n', '     */\n', '    function getTotalPremium(address premiumCoin)public view returns(uint256){\n', '        return premiumMap[premiumCoin].totalPremium;\n', '    }\n', '\n', '    /**\n', '     * @dev user redeem his options premium rewards.\n', '     */\n', '    function redeemPremium()public nonReentrant notHalted {\n', '        for (uint256 i=0;i<premiumCoinList.length;i++){\n', '            address premiumCoin = premiumCoinList[i];\n', '            settlePremium(msg.sender,premiumCoin);\n', '            uint256 amount = premiumMap[premiumCoin].premiumBalance[msg.sender];\n', '            if (amount > 0){\n', '                premiumMap[premiumCoin].premiumBalance[msg.sender] = 0;\n', '                _redeem(msg.sender,premiumCoin,amount);\n', '                emit RedeemPremium(msg.sender,premiumCoin,amount);\n', '            }\n', '        }\n', '    }\n', '    /**\n', '     * @dev user redeem his options premium rewards.\n', '     * @param amount redeem amount.\n', '     */\n', '    function redeemPremiumCoin(address premiumCoin,uint256 amount)public nonReentrant notHalted {\n', '        require(amount > 0,"redeem amount must be greater than zero");\n', '        settlePremium(msg.sender,premiumCoin);\n', '        premiumMap[premiumCoin].premiumBalance[msg.sender] = premiumMap[premiumCoin].premiumBalance[msg.sender].sub(amount);\n', '        _redeem(msg.sender,premiumCoin,amount);\n', '        emit RedeemPremium(msg.sender,premiumCoin,amount);\n', '    }\n', '\n', '    /**\n', "     * @dev get user's premium balance.\n", "     * @param account user's account\n", '     */ \n', '    function getUserLatestPremium(address account,address premiumCoin)public view returns(uint256){\n', '        return premiumMap[premiumCoin].premiumBalance[account].add(_getUserPremium(account,premiumCoin));\n', '    }\n', '    /**\n', '     * @dev the auxiliary function for getUserLatestPremium. Calculate latest time phase premium.\n', '     */ \n', '    function _getUserPremium(address account,address premiumCoin)internal view returns(uint256){\n', '        uint256 FPTBBalance = userInfoMap[account]._FPTBBalance;\n', '        if (FPTBBalance > 0){\n', '            uint256 lastIndex = premiumMap[premiumCoin].lastPremiumIndex[account];\n', '            uint256 nowIndex = getPeriodIndex(currentTime());\n', '            uint256 endIndex = lastIndex+_maxLoop < premiumMap[premiumCoin].distributedPeriod.length ? lastIndex+_maxLoop : premiumMap[premiumCoin].distributedPeriod.length;\n', '            uint256 LatestPremium = 0;\n', '            for (; lastIndex< endIndex;lastIndex++){\n', '                uint256 periodID = premiumMap[premiumCoin].distributedPeriod[lastIndex];\n', '                if (periodID == nowIndex || premiumDistributionMap[periodID].totalPremiumDistribution == 0 ||\n', '                    premiumDistributionMap[periodID].userPremiumDistribution[account] == 0){\n', '                    continue;\n', '                }\n', '                LatestPremium = LatestPremium.add(premiumMap[premiumCoin].periodPremium[periodID].mul(premiumDistributionMap[periodID].userPremiumDistribution[account]).div(\n', '                    premiumDistributionMap[periodID].totalPremiumDistribution));\n', '            }        \n', '            return LatestPremium;\n', '        }\n', '        return 0;\n', '    }\n', '    /**\n', '     * @dev Distribute premium from foundation.\n', '     * @param premiumCoin premium token address\n', '     * @param periodID period ID\n', '     * @param amount premium amount.\n', '     */ \n', '    function distributePremium(address premiumCoin, uint256 periodID,uint256 amount)public onlyOperator(0) {\n', '        amount = getPayableAmount(premiumCoin,amount);\n', "        require(amount > 0, 'Distribution amount is zero');\n", '        require(premiumMap[premiumCoin].periodPremium[periodID] == 0 , "This period is already distributed!");\n', '        uint256 nowIndex = getPeriodIndex(currentTime());\n', "        require(nowIndex > periodID, 'This period is not finished');\n", '        whiteListAddress.addWhiteListAddress(premiumCoinList,premiumCoin);\n', '        premiumMap[premiumCoin].periodPremium[periodID] = amount;\n', '        premiumMap[premiumCoin].totalPremium = premiumMap[premiumCoin].totalPremium.add(amount);\n', '        premiumMap[premiumCoin].distributedPeriod.push(uint64(periodID));\n', '        emit DistributePremium(msg.sender,premiumCoin,periodID,amount);\n', '    }\n', '    /**\n', "     * @dev Auxiliary function. Clear user's premium distribution amount.\n", "     * @param account user's account.\n", '     */ \n', '    function removePremiumDistribution(address account) internal {\n', '        for (uint256 i=0;i<premiumCoinList.length;i++){\n', '            settlePremium(account,premiumCoinList[i]);\n', '        }\n', '        uint256 beginTime = currentTime(); \n', '        uint256 nowId = getPeriodIndex(beginTime);\n', '        uint256 endId = userInfoMap[account].maxPeriodID;\n', '        uint256 FPTBBalance = userInfoMap[account]._FPTBBalance;\n', '        if (FPTBBalance> 0 && nowId<endId){\n', '            for(;nowId<endId;nowId++){\n', '                uint256 finishTime = getPeriodFinishTime(nowId);\n', '                uint256 periodDistribution = finishTime.sub(beginTime).mul(FPTBBalance);\n', '                premiumDistributionMap[nowId].totalPremiumDistribution = premiumDistributionMap[nowId].totalPremiumDistribution.sub(periodDistribution);\n', '                premiumDistributionMap[nowId].userPremiumDistribution[account] = premiumDistributionMap[nowId].userPremiumDistribution[account].sub(periodDistribution);\n', '                beginTime = finishTime;\n', '            }\n', '        }\n', '    }\n', '    /**\n', "     * @dev Auxiliary function. Calculate and record user's premium.\n", "     * @param account user's account.\n", '     */ \n', '    function settlePremium(address account,address premiumCoin)internal{\n', '        premiumMap[premiumCoin].premiumBalance[account] = premiumMap[premiumCoin].premiumBalance[account].add(getUserLatestPremium(account,premiumCoin));\n', '        premiumMap[premiumCoin].lastPremiumIndex[account] = premiumMap[premiumCoin].distributedPeriod.length;\n', '    }\n', '    /**\n', "     * @dev Auxiliary function. Add user's premium distribution amount.\n", "     * @param account user's account.\n", '     */ \n', '    function addPremiumDistribution(address account) internal {\n', '        uint256 beginTime = currentTime(); \n', '        uint256 nowId = getPeriodIndex(beginTime);\n', '        uint256 endId = userInfoMap[account].maxPeriodID;\n', '        uint256 FPTBBalance = userInfoMap[account]._FPTBBalance;\n', '        for(;nowId<endId;nowId++){\n', '            uint256 finishTime = getPeriodFinishTime(nowId);\n', '            uint256 periodDistribution = finishTime.sub(beginTime).mul(FPTBBalance);\n', '            premiumDistributionMap[nowId].totalPremiumDistribution = premiumDistributionMap[nowId].totalPremiumDistribution.add(periodDistribution);\n', '            premiumDistributionMap[nowId].userPremiumDistribution[account] = premiumDistributionMap[nowId].userPremiumDistribution[account].add(periodDistribution);\n', '            beginTime = finishTime;\n', '        }\n', '\n', '    }\n', '    /**\n', "     * @dev Throws if user's locked expired timestamp is less than now.\n", '     */\n', '    modifier periodExpired(address account){\n', "        require(userInfoMap[account].lockedExpired < currentTime(),'locked period is not expired');\n", '\n', '        _;\n', '    }\n', '    /**\n', '     * @dev Throws if input period number is greater than _maxPeriod.\n', '     */\n', '    modifier validPeriod(uint256 period){\n', "        require(period >= 0 && period <= _maxPeriod, 'locked period must be in valid range');\n", '        _;\n', '    }\n', '    /**\n', '     * @dev Throws if minePool is not start.\n', '     */\n', '    modifier minePoolStarted(){\n', "        require(currentTime()>=_startTime, 'mine pool is not start');\n", '        _;\n', '    }\n', '    /**\n', '     * @dev get now timestamp.\n', '     */\n', '    function currentTime() internal view returns (uint256){\n', '        return now;\n', '    }\n', '}']