['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-02\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function owner() external view returns (address);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IMasterChef {\n', '    function BONUS_MULTIPLIER() external view returns (uint256);\n', '    function bonusEndBlock() external view returns (uint256);\n', '    function devaddr() external view returns (address);\n', '    function migrator() external view returns (address);\n', '    function owner() external view returns (address);\n', '    function startBlock() external view returns (uint256);\n', '    function sushi() external view returns (address);\n', '    function sushiPerBlock() external view returns (uint256);\n', '    function totalAllocPoint() external view returns (uint256);\n', '    function poolLength() external view returns (uint256);\n', '\n', '    function poolInfo(uint256 nr)\n', '        external\n', '        view\n', '        returns (\n', '            address,\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function userInfo(uint256 nr, address who) external view returns (uint256, uint256);\n', '    function pendingSushi(uint256 nr, address who) external view returns (uint256);\n', '}\n', '\n', 'interface IPair is IERC20 {\n', '    function token0() external view returns (IERC20);\n', '    function token1() external view returns (IERC20);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112,\n', '            uint112,\n', '            uint32\n', '        );\n', '}\n', '\n', 'interface IFactory {\n', '    function allPairsLength() external view returns (uint256);\n', '    function allPairs(uint256 i) external view returns (IPair);\n', '    function getPair(IERC20 token0, IERC20 token1) external view returns (IPair);\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '}\n', '\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address public immutable owner;\n', '\n', '    constructor() internal {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', 'library BoringERC20 {\n', '    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n', '        if (data.length >= 64) {\n', '            return abi.decode(data, (string));\n', '        } else if (data.length == 32) {\n', '            uint8 i = 0;\n', '            while(i < 32 && data[i] != 0) {\n', '                i++;\n', '            }\n', '            bytes memory bytesArray = new bytes(i);\n', '            for (i = 0; i < 32 && data[i] != 0; i++) {\n', '                bytesArray[i] = data[i];\n', '            }\n', '            return string(bytesArray);\n', '        } else {\n', '            return "???";\n', '        }\n', '    } \n', '    \n', '    function symbol(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n', '        return success ? returnDataToString(data) : "???";\n', '    }\n', '\n', '    function name(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n', '        return success ? returnDataToString(data) : "???";\n', '    }\n', '\n', '    function decimals(IERC20 token) internal view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '}\n', '\n', 'library BoringPair {\n', '    function factory(IPair pair) internal view returns (IFactory) {\n', '        (bool success, bytes memory data) = address(pair).staticcall(abi.encodeWithSelector(0xc45a0155));\n', '        return success && data.length == 32 ? abi.decode(data, (IFactory)) : IFactory(0);\n', '    }\n', '}\n', '\n', 'contract BoringHelper is Ownable {\n', '    using BoringMath for uint256;\n', '    using BoringERC20 for IERC20;\n', '    using BoringERC20 for IPair;\n', '    using BoringPair for IPair;\n', '\n', '    IMasterChef public chef; // IMasterChef(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd);\n', '    address public maker; // ISushiMaker(0xE11fc0B43ab98Eb91e9836129d1ee7c3Bc95df50);\n', '    IERC20 public sushi; // ISushiToken(0x6B3595068778DD592e39A122f4f5a5cF09C90fE2);\n', '    IERC20 public WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    IERC20 public WBTC; // 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n', '    IFactory public sushiFactory; // IFactory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n', '    IFactory public uniV2Factory; // IFactory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n', '    IERC20 public bar; // 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272;\n', '\n', '    constructor(\n', '        IMasterChef chef_,\n', '        address maker_,\n', '        IERC20 sushi_,\n', '        IERC20 WETH_,\n', '        IERC20 WBTC_,\n', '        IFactory sushiFactory_,\n', '        IFactory uniV2Factory_,\n', '        IERC20 bar_\n', '    ) public {\n', '        chef = chef_;\n', '        maker = maker_;\n', '        sushi = sushi_;\n', '        WETH = WETH_;\n', '        WBTC = WBTC_;\n', '        sushiFactory = sushiFactory_;\n', '        uniV2Factory = uniV2Factory_;\n', '        bar = bar_;\n', '    }\n', '\n', '    function setContracts(\n', '        IMasterChef chef_,\n', '        address maker_,\n', '        IERC20 sushi_,\n', '        IERC20 WETH_,\n', '        IERC20 WBTC_,\n', '        IFactory sushiFactory_,\n', '        IFactory uniV2Factory_,\n', '        IERC20 bar_\n', '    ) public onlyOwner {\n', '        chef = chef_;\n', '        maker = maker_;\n', '        sushi = sushi_;\n', '        WETH = WETH_;\n', '        WBTC = WBTC_;\n', '        sushiFactory = sushiFactory_;\n', '        uniV2Factory = uniV2Factory_;\n', '        bar = bar_;\n', '    }\n', '\n', '    function getETHRate(IERC20 token) public view returns (uint256) {\n', '        if (token == WETH) {\n', '            return 1e18;\n', '        }\n', '        IPair pairUniV2 = IPair(uniV2Factory.getPair(token, WETH));\n', '        IPair pairSushi = IPair(sushiFactory.getPair(token, WETH));\n', '        if (address(pairUniV2) == address(0) && address(pairSushi) == address(0)) {\n', '            return 0;\n', '        }\n', '\n', '        uint112 reserve0;\n', '        uint112 reserve1;\n', '        IERC20 token0;\n', '        if (address(pairUniV2) != address(0)) {\n', '            (uint112 reserve0UniV2, uint112 reserve1UniV2, ) = pairUniV2.getReserves();\n', '            reserve0 += reserve0UniV2;\n', '            reserve1 += reserve1UniV2;\n', '            token0 = pairUniV2.token0();\n', '        }\n', '\n', '        if (address(pairSushi) != address(0)) {\n', '            (uint112 reserve0Sushi, uint112 reserve1Sushi, ) = pairSushi.getReserves();\n', '            reserve0 += reserve0Sushi;\n', '            reserve1 += reserve1Sushi;\n', '            if (token0 == IERC20(0)) {\n', '                token0 = pairSushi.token0();\n', '            }\n', '        }\n', '\n', '        if (token0 == WETH) {\n', '            return uint256(reserve1).mul(1e18) / reserve0;\n', '        } else {\n', '            return uint256(reserve0).mul(1e18) / reserve1;\n', '        }\n', '    }\n', '\n', '    struct Factory {\n', '        IFactory factory;\n', '        uint256 allPairsLength;\n', '    }\n', '\n', '    struct UIInfo {\n', '        uint256 ethBalance;\n', '        uint256 sushiBalance;\n', '        uint256 sushiBarBalance;\n', '        uint256 xsushiBalance;\n', '        uint256 xsushiSupply;\n', '        uint256 sushiBarAllowance;\n', '        Factory[] factories;\n', '        uint256 ethRate;\n', '        uint256 sushiRate;\n', '        uint256 btcRate;\n', '        uint256 pendingSushi;\n', '    }\n', '\n', '    function getUIInfo(\n', '        address who,\n', '        IFactory[] calldata factoryAddresses,\n', '        IERC20 currency\n', '    ) public view returns (UIInfo memory) {\n', '        UIInfo memory info;\n', '        info.ethBalance = who.balance;\n', '\n', '        info.factories = new Factory[](factoryAddresses.length);\n', '\n', '        for (uint256 i = 0; i < factoryAddresses.length; i++) {\n', '            IFactory factory = factoryAddresses[i];\n', '            info.factories[i].factory = factory;\n', '            info.factories[i].allPairsLength = factory.allPairsLength();\n', '        }\n', '\n', '        info.ethRate = getETHRate(currency);\n', '        info.sushiRate = getETHRate(sushi);\n', '        info.btcRate = getETHRate(WBTC);\n', '\n', '        info.sushiBalance = sushi.balanceOf(who);\n', '        info.sushiBarBalance = sushi.balanceOf(address(bar));\n', '        info.xsushiBalance = bar.balanceOf(who);\n', '        info.xsushiSupply = bar.totalSupply();\n', '        info.sushiBarAllowance = sushi.allowance(who, address(bar));\n', '\n', '        uint256 poolLength = chef.poolLength();\n', '        uint256 pendingSushi;\n', '        for (uint256 i = 0; i < poolLength; i++) {\n', '            pendingSushi += chef.pendingSushi(i, who);\n', '        }\n', '        info.pendingSushi = pendingSushi;\n', '\n', '        return info;\n', '    }\n', '\n', '    struct Balance {\n', '        IERC20 token;\n', '        uint256 balance;\n', '        uint256 bentoBalance;\n', '    }\n', '\n', '    struct BalanceFull {\n', '        IERC20 token;\n', '        uint256 balance;\n', '        uint256 rate;\n', '    }\n', '\n', '    struct TokenInfo {\n', '        IERC20 token;\n', '        uint256 decimals;\n', '        string name;\n', '        string symbol;\n', '    }\n', '\n', '    function getTokenInfo(address[] calldata addresses) public view returns (TokenInfo[] memory) {\n', '        TokenInfo[] memory infos = new TokenInfo[](addresses.length);\n', '\n', '        for (uint256 i = 0; i < addresses.length; i++) {\n', '            IERC20 token = IERC20(addresses[i]);\n', '            infos[i].token = token;\n', '\n', '            infos[i].name = token.name();\n', '            infos[i].symbol = token.symbol();\n', '            infos[i].decimals = token.decimals();\n', '        }\n', '\n', '        return infos;\n', '    }\n', '\n', '    function findBalances(address who, address[] calldata addresses) public view returns (Balance[] memory) {\n', '        Balance[] memory balances = new Balance[](addresses.length);\n', '\n', '        uint256 len = addresses.length;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            IERC20 token = IERC20(addresses[i]);\n', '            balances[i].token = token;\n', '            balances[i].balance = token.balanceOf(who);\n', '        }\n', '\n', '        return balances;\n', '    }\n', '\n', '    function getBalances(address who, address[] calldata addresses) public view returns (BalanceFull[] memory) {\n', '        BalanceFull[] memory balances = new BalanceFull[](addresses.length);\n', '\n', '        for (uint256 i = 0; i < addresses.length; i++) {\n', '            IERC20 token = IERC20(addresses[i]);\n', '            balances[i].token = token;\n', '            balances[i].balance = IERC20(token).balanceOf(who);\n', '            balances[i].rate = getETHRate(token);\n', '        }\n', '\n', '        return balances;\n', '    }\n', '\n', '    struct PairBase {\n', '        IPair token;\n', '        IERC20 token0;\n', '        IERC20 token1;\n', '        uint256 totalSupply;\n', '    }\n', '\n', '    function getPairs(\n', '        IFactory factory,\n', '        uint256 fromID,\n', '        uint256 toID\n', '    ) public view returns (PairBase[] memory) {\n', '        PairBase[] memory pairs = new PairBase[](toID - fromID);\n', '\n', '        for (uint256 id = fromID; id < toID; id++) {\n', '            IPair token = factory.allPairs(id);\n', '            uint256 i = id - fromID;\n', '            pairs[i].token = token;\n', '            pairs[i].token0 = token.token0();\n', '            pairs[i].token1 = token.token1();\n', '            pairs[i].totalSupply = token.totalSupply();\n', '        }\n', '        return pairs;\n', '    }\n', '\n', '    struct PairPoll {\n', '        IPair token;\n', '        uint256 reserve0;\n', '        uint256 reserve1;\n', '        uint256 totalSupply;\n', '        uint256 balance;\n', '    }\n', '\n', '    function pollPairs(address who, IPair[] calldata addresses) public view returns (PairPoll[] memory) {\n', '        PairPoll[] memory pairs = new PairPoll[](addresses.length);\n', '        for (uint256 i = 0; i < addresses.length; i++) {\n', '            IPair token = addresses[i];\n', '            pairs[i].token = token;\n', '            (uint256 reserve0, uint256 reserve1, ) = token.getReserves();\n', '            pairs[i].reserve0 = reserve0;\n', '            pairs[i].reserve1 = reserve1;\n', '            pairs[i].balance = token.balanceOf(who);\n', '            pairs[i].totalSupply = token.totalSupply();\n', '        }\n', '        return pairs;\n', '    }\n', '\n', '    struct PoolsInfo {\n', '        uint256 totalAllocPoint;\n', '        uint256 poolLength;\n', '    }\n', '\n', '    struct PoolInfo {\n', '        uint256 pid;\n', '        IPair lpToken;\n', '        uint256 allocPoint;\n', '        bool isPair;\n', '        IFactory factory;\n', '        IERC20 token0;\n', '        IERC20 token1;\n', '        string name;\n', '        string symbol;\n', '        uint8 decimals;\n', '    }\n', '\n', '    function getPools(uint256[] calldata pids) public view returns (PoolsInfo memory, PoolInfo[] memory) {\n', '        PoolsInfo memory info;\n', '        info.totalAllocPoint = chef.totalAllocPoint();\n', '        uint256 poolLength = chef.poolLength();\n', '        info.poolLength = poolLength;\n', '\n', '        PoolInfo[] memory pools = new PoolInfo[](pids.length);\n', '\n', '        for (uint256 i = 0; i < pids.length; i++) {\n', '            pools[i].pid = pids[i];\n', '            (address lpToken, uint256 allocPoint, , ) = chef.poolInfo(pids[i]);\n', '            IPair uniV2 = IPair(lpToken);\n', '            pools[i].lpToken = uniV2;\n', '            pools[i].allocPoint = allocPoint;\n', '\n', '            pools[i].name = uniV2.name();\n', '            pools[i].symbol = uniV2.symbol();\n', '            pools[i].decimals = uniV2.decimals();\n', '\n', '            pools[i].factory = uniV2.factory();\n', '            if (pools[i].factory != IFactory(0)) {\n', '                pools[i].isPair = true;\n', '                pools[i].token0 = uniV2.token0();\n', '                pools[i].token1 = uniV2.token1();\n', '            }\n', '        }\n', '        return (info, pools);\n', '    }\n', '\n', '    struct PoolFound {\n', '        uint256 pid;\n', '        uint256 balance;\n', '    }\n', '\n', '    function findPools(address who, uint256[] calldata pids) public view returns (PoolFound[] memory) {\n', '        PoolFound[] memory pools = new PoolFound[](pids.length);\n', '\n', '        for (uint256 i = 0; i < pids.length; i++) {\n', '            pools[i].pid = pids[i];\n', '            (pools[i].balance, ) = chef.userInfo(pids[i], who);\n', '        }\n', '\n', '        return pools;\n', '    }\n', '\n', '    struct UserPoolInfo {\n', '        uint256 pid;\n', '        uint256 balance; // Balance of pool tokens\n', '        uint256 totalSupply; // Token staked lp tokens\n', '        uint256 lpBalance; // Balance of lp tokens not staked\n', '        uint256 lpTotalSupply; // TotalSupply of lp tokens\n', '        uint256 lpAllowance; // LP tokens approved for masterchef\n', '        uint256 reserve0;\n', '        uint256 reserve1;\n', '        uint256 rewardDebt;\n', '        uint256 pending; // Pending SUSHI\n', '    }\n', '\n', '    function pollPools(address who, uint256[] calldata pids) public view returns (UserPoolInfo[] memory) {\n', '        UserPoolInfo[] memory pools = new UserPoolInfo[](pids.length);\n', '\n', '        for (uint256 i = 0; i < pids.length; i++) {\n', '            (uint256 amount, ) = chef.userInfo(pids[i], who);\n', '            pools[i].balance = amount;\n', '            pools[i].pending = chef.pendingSushi(pids[i], who);\n', '\n', '            (address lpToken, , , ) = chef.poolInfo(pids[i]);\n', '            pools[i].pid = pids[i];\n', '            IPair uniV2 = IPair(lpToken);\n', '            IFactory factory = uniV2.factory();\n', '            if (factory != IFactory(0)) {\n', '                pools[i].totalSupply = uniV2.balanceOf(address(chef));\n', '                pools[i].lpAllowance = uniV2.allowance(who, address(chef));\n', '                pools[i].lpBalance = uniV2.balanceOf(who);\n', '                pools[i].lpTotalSupply = uniV2.totalSupply();\n', '\n', '                (uint112 reserve0, uint112 reserve1, ) = uniV2.getReserves();\n', '                pools[i].reserve0 = reserve0;\n', '                pools[i].reserve1 = reserve1;\n', '            }\n', '        }\n', '        return pools;\n', '    }\n', '}']