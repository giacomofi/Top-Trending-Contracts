['// SPDX-License-Identifier: MIT\n', '// Based on: https://github.com/sushiswap/sushiswap/blob/d487cc774c0ac71fe2d0742976cafb3194658d62/contracts/MasterChef.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./SafeERC20.sol";\n', 'import "./EnumerableSet.sol";\n', 'import "./Ownable.sol";\n', '\n', 'interface IMigratorChef {\n', '    // Perform LP token migration from legacy UniswapV2 to MobiFiSwap.\n', '    // Take the current LP token address and return the new LP token address.\n', "    // Migrator should have full access to the caller's LP token.\n", '    // Return the new LP token address.\n', '    //\n', '    // XXX Migrator must have allowance access to UniswapV2 LP tokens.\n', '    // MobiFiSwap must mint EXACTLY the same amount of MobiFiSwap LP tokens or\n', '    // else something bad will happen. Traditional UniswapV2 does not\n', '    // do that so be careful!\n', '    function migrate(IERC20MobiFi token) external returns (IERC20MobiFi);\n', '}\n', '\n', '// MasterChef is the master of MobiFi. He can make MobiFi and he is a fair guy.\n', '//\n', "// Note that it's ownable and the owner wields tremendous power. The ownership\n", '// will be transferred to a governance smart contract once MobiFi is sufficiently\n', '// distributed and the community can show to govern itself.\n', '//\n', "// Have fun reading it. Hopefully it's bug-free. God bless.\n", 'contract MasterChef is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20MobiFi;\n', '    // Info of each user.\n', '    struct UserInfo {\n', '        uint256 amount; // How many LP tokens the user has provided.\n', '        uint256 rewardDebt; // Reward debt. See explanation below.\n', '        //\n', '        // We do some fancy math here. Basically, any point in time, the amount of MobiFis\n', '        // entitled to a user but is pending to be distributed is:\n', '        //\n', '        //   pending reward = (user.amount * pool.accMobiFiPerShare) - user.rewardDebt\n', '        //\n', "        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n", "        //   1. The pool's `accMobiFiPerShare` (and `lastRewardBlock`) gets updated.\n", '        //   2. User receives the pending reward sent to his/her address.\n', "        //   3. User's `amount` gets updated.\n", "        //   4. User's `rewardDebt` gets updated.\n", '    }\n', '    // Info of each pool.\n', '    struct PoolInfo {\n', '        IERC20MobiFi lpToken; // Address of LP token contract.\n', '        uint256 allocPoint; // How many allocation points assigned to this pool. MobiFis to distribute per block.\n', '        uint256 lastRewardBlock; // Last block number that MobiFis distribution occurs.\n', '        uint256 accMobiFiPerShare; // Accumulated MobiFis per share, times 1e12. See below.\n', '    }\n', '    // The MobiFi TOKEN!\n', '    IERC20MobiFi public MobiFi = IERC20MobiFi(MobiFi);\n', '    \n', '    address public MobiFiContract;\n', '    // Block number when bonus MobiFi period ends.\n', '    uint256 public bonusEndBlock;\n', '    // MobiFi tokens created per block.\n', '    uint256 public MobiFiPerBlock;\n', '    // Max MobiFi Supply\n', '    uint256 constant MaxSupply = 150e24;\n', '    // Bonus muliplier for early MobiFi makers.\n', '    uint256 public constant BONUS_MULTIPLIER = 1;\n', '    // The migrator contract. It has a lot of power. Can only be set through governance (owner).\n', '    IMigratorChef public migrator;\n', '    // Info of each pool.\n', '    PoolInfo[] public poolInfo;\n', '    // Info of each user that stakes LP tokens.\n', '    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n', '   \n', '    // Total Mobifi Deposited minus Total Mobifi Withdrawed;\n', '    uint256 public totalAllocPoint = 0;\n', '    // The block number when MobiFi mining starts.\n', '    uint256 public startBlock;\n', '    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n', '    event EmergencyWithdraw(\n', '        address indexed user,\n', '        uint256 indexed pid,\n', '        uint256 amount\n', '    );\n', '\n', '    constructor(\n', '        IERC20MobiFi _MobiFi,\n', '        uint256 _MobiFiPerBlock,\n', '        uint256 _startBlock,\n', '        uint256 _bonusEndBlock\n', '    ) public {\n', '        MobiFi = IERC20MobiFi(_MobiFi);\n', '        MobiFiPerBlock = _MobiFiPerBlock;\n', '        bonusEndBlock = _bonusEndBlock;\n', '        startBlock = _startBlock;\n', '    }\n', '\n', '    function poolLength() external view returns (uint256) {\n', '        return poolInfo.length;\n', '    }\n', '\n', '    // Add a new lp to the pool. Can only be called by the owner.\n', '    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n', '    function add(\n', '        uint256 _allocPoint,\n', '        IERC20MobiFi _lpToken,\n', '        bool _withUpdate\n', '    ) public onlyOwner {\n', '        if (_withUpdate) {\n', '            massUpdatePools();\n', '        }\n', '        uint256 lastRewardBlock =\n', '            block.number > startBlock ? block.number : startBlock;\n', '        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n', '        poolInfo.push(\n', '            PoolInfo({\n', '                lpToken: _lpToken,\n', '                allocPoint: _allocPoint,\n', '                lastRewardBlock: lastRewardBlock,\n', '                accMobiFiPerShare: 0\n', '            })\n', '        );\n', '    }\n', '\n', "    // Update the given pool's MobiFi allocation point. Can only be called by the owner.\n", '    function set(\n', '        uint256 _pid,\n', '        uint256 _allocPoint,\n', '        bool _withUpdate\n', '    ) public onlyOwner {\n', '        if (_withUpdate) {\n', '            massUpdatePools();\n', '        }\n', '        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n', '            _allocPoint\n', '        );\n', '        poolInfo[_pid].allocPoint = _allocPoint;\n', '    }\n', '\n', '    // Set the migrator contract. Can only be called by the owner.\n', '    function setMigrator(IMigratorChef _migrator) public onlyOwner {\n', '        migrator = _migrator;\n', '    }\n', '\n', '    // Migrate lp token to another lp contract. Can be called by anyone. We trust that migrator contract is good.\n', '    function migrate(uint256 _pid) public {\n', '        require(address(migrator) != address(0), "migrate: no migrator");\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        IERC20MobiFi lpToken = pool.lpToken;\n', '        uint256 bal = lpToken.balanceOf(address(this));\n', '        lpToken.safeApprove(address(migrator), bal);\n', '        IERC20MobiFi newLpToken = migrator.migrate(lpToken);\n', '        require(bal == newLpToken.balanceOf(address(this)), "migrate: bad");\n', '        pool.lpToken = newLpToken;\n', '    }\n', '\n', '    // Return reward multiplier over the given _from to _to block.\n', '    function getMultiplier(uint256 _from, uint256 _to)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (_to <= bonusEndBlock) {\n', '            return _to.sub(_from).mul(BONUS_MULTIPLIER);\n', '        } else if (_from >= bonusEndBlock) {\n', '            return _to.sub(_from);\n', '        } else {\n', '            return\n', '                bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\n', '                    _to.sub(bonusEndBlock)\n', '                );\n', '        }\n', '    }\n', '\n', '    // View function to see pending MobiFis on frontend.\n', '    function pendingMobiFi(uint256 _pid, address _user)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][_user];\n', '        uint256 accMobiFiPerShare = pool.accMobiFiPerShare;\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n', '            uint256 multiplier =\n', '                getMultiplier(pool.lastRewardBlock, block.number);\n', '            uint256 MobiFiReward =\n', '                multiplier.mul(MobiFiPerBlock).mul(pool.allocPoint).div(\n', '                    totalAllocPoint\n', '                );\n', '            accMobiFiPerShare = accMobiFiPerShare.add(\n', '                MobiFiReward.mul(1e12).div(lpSupply)\n', '            );\n', '        }\n', '        return\n', '            user.amount.mul(accMobiFiPerShare).div(1e12).sub(user.rewardDebt);\n', '    }\n', '\n', '    // Update reward vairables for all pools. Be careful of gas spending!\n', '    function massUpdatePools() public {\n', '        uint256 length = poolInfo.length;\n', '        for (uint256 pid = 0; pid < length; ++pid) {\n', '            updatePool(pid);\n', '        }\n', '    }\n', '\n', '    // Update reward variables of the given pool to be up-to-date.\n', '    function updatePool(uint256 _pid) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        if (block.number <= pool.lastRewardBlock) {\n', '            return;\n', '        }\n', '        uint256 lpSupply = pool.lpToken.balanceOf(address(this));\n', '        uint256 totalSupply = MobiFi.totalSupply();\n', '        if (lpSupply == 0) {\n', '            pool.lastRewardBlock = block.number;\n', '            return;\n', '        }\n', '        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n', '        uint256 MobiFiReward =\n', '            multiplier.mul(MobiFiPerBlock).mul(pool.allocPoint).div(\n', '                totalAllocPoint\n', '            );\n', '            \n', '        if(totalSupply.add(MobiFiReward) > MaxSupply) {\n', '            MobiFiReward = MaxSupply.sub(totalSupply);\n', '        }\n', '\n', '        if (MobiFiReward == 0) {\n', '            pool.lastRewardBlock = block.number;\n', '            return;\n', '        }\n', '\n', '        MobiFi.mint(address(this), MobiFiReward);\n', '        pool.accMobiFiPerShare = pool.accMobiFiPerShare.add(\n', '            MobiFiReward.mul(1e12).div(lpSupply)\n', '        );\n', '        pool.lastRewardBlock = block.number;\n', '    }\n', '\n', '    // Deposit LP tokens to MasterChef for MobiFi allocation.\n', '    function deposit(uint256 _pid, uint256 _amount) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        updatePool(_pid);\n', '        if (user.amount > 0) {\n', '            uint256 pending =\n', '                user.amount.mul(pool.accMobiFiPerShare).div(1e12).sub(\n', '                    user.rewardDebt\n', '                );\n', '            safeMobiFiTransfer(msg.sender, pending);\n', '        }\n', '        pool.lpToken.safeTransferFrom(\n', '            address(msg.sender),\n', '            address(this),\n', '            _amount\n', '        );\n', '        user.amount = user.amount.add(_amount);\n', '        user.rewardDebt = user.amount.mul(pool.accMobiFiPerShare).div(1e12);\n', '        emit Deposit(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    // Withdraw LP tokens from MasterChef.\n', '    function withdraw(uint256 _pid, uint256 _amount) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        require(user.amount >= _amount, "withdraw: not good");\n', '        updatePool(_pid);\n', '        uint256 pending =\n', '            user.amount.mul(pool.accMobiFiPerShare).div(1e12).sub(\n', '                user.rewardDebt\n', '            );\n', '        safeMobiFiTransfer(msg.sender, pending);\n', '        user.amount = user.amount.sub(_amount);\n', '        user.rewardDebt = user.amount.mul(pool.accMobiFiPerShare).div(1e12);\n', '        pool.lpToken.safeTransfer(address(msg.sender), _amount);\n', '        emit Withdraw(msg.sender, _pid, _amount);\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw(uint256 _pid) public {\n', '        PoolInfo storage pool = poolInfo[_pid];\n', '        UserInfo storage user = userInfo[_pid][msg.sender];\n', '        pool.lpToken.safeTransfer(address(msg.sender), user.amount);\n', '        emit EmergencyWithdraw(msg.sender, _pid, user.amount);\n', '        user.amount = 0;\n', '        user.rewardDebt = 0;\n', '    }\n', '\n', '    // Safe MobiFi transfer function, just in case if rounding error causes pool to not have enough MobiFis.\n', '    function safeMobiFiTransfer(address _to, uint256 _amount) internal {\n', '        uint256 MobiFiBal = MobiFi.balanceOf(address(this));\n', '        if (_amount > MobiFiBal) {\n', '            MobiFi.transfer(_to, MobiFiBal);\n', '        } else {\n', '            MobiFi.transfer(_to, _amount);\n', '        }\n', '    }\n', '\n', '}']