['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-05\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at hecoinfo.com on 2021-06-21\n', '*/\n', '\n', '// File: localhost/interface/IERC20.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'interface IERC20 {\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `amount` tokens are moved from one account (`sender`) to\n', '     * another (`recipient`).\n', '     *\n', '     * Note that `amount` may be zero.\n', '     */\n', '    event Transfer(address indexed sender, address indexed recipient, uint256 amount);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `amount` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '}\n', '// File: localhost/base/Rootable.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'contract Rootable {\n', '\n', '    address internal _ROOT_;\n', '    bool internal _INIT_;\n', '\n', '    event RootTransferred(address indexed previousRoot, address indexed newRoot);\n', '\n', '    modifier notInit() {\n', '        require(!_INIT_, "INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    function initRoot(address newRoot) internal notInit {\n', '        _INIT_ = true;\n', '        _ROOT_ = newRoot;\n', '\n', '        emit RootTransferred(address(0), newRoot);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current root.\n', '     */\n', '    function root() public view returns (address) {\n', '        return _ROOT_;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the root.\n', '     */\n', '    modifier onlyRoot() {\n', '        require(_ROOT_ == msg.sender, "YouSwap: CALLER_IS_NOT_THE_ROOT");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without root. It will not be possible to call\n', '     * `onlyRoot` functions anymore. Can only be called by the current root.\n', '     *\n', '     * NOTE: Renouncing root will leave the contract without an root,\n', '     * thereby removing any functionality that is only available to the root.\n', '     */\n', '    function renounceRoot() public onlyRoot {\n', '        emit RootTransferred(_ROOT_, address(0));\n', '        _ROOT_ = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers root of the contract to a new account (`newRoot`).\n', '     * Can only be called by the current root.\n', '     */\n', '    function transferRoot(address newRoot) public onlyRoot {\n', '        require(newRoot != address(0), "NEW_ROOT_IS_THE_ZERO_ADDRESS");\n', '        emit RootTransferred(_ROOT_, newRoot);\n', '        _ROOT_ = newRoot;\n', '    }\n', '}\n', '// File: localhost/interface/IPoolFactory.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'interface IPoolFactory {\n', '\n', '    function createPriPool(\n', '        string calldata _proName,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        address _tokenIn,\n', '        address _tokenOut,\n', '        uint256 _tokenOutSupply,\n', '        uint256 _upperLimitOfTokenIn,\n', '        uint256 _tokenOutPrice\n', '    ) external returns (address newPool);\n', '\n', '    function createPubPool(\n', '        string calldata _proName,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        address _tokenIn,\n', '        address _tokenOut,\n', '        uint256 _targetAmountOfTokenIn,\n', '        uint256 _targetAmountOfTokenOut,\n', '        uint256 _bottomLimitOfTokenIn\n', '    ) external returns (address newPool);\n', '\n', '    function addTokenInToWhiteList(address tokenIn) external;\n', '\n', '    function removeTokenInFromWhiteList(address tokenIn) external;\n', '\n', '    function tokenInWhiteList(address tokenIn) external view returns (bool);\n', '\n', '    function getPools() external view returns (address[] memory pools);\n', '\n', '    function getPoolsByCreator(address creator) external view returns (address[] memory pools);\n', '\n', '    function getPoolsByParticipant(address creator) external view returns (address[] memory pools);\n', '\n', '    function enroll(address participant, address pool) external returns (bool);\n', '\n', '    function getPoolInfo(address poolAddr) external view returns (\n', '        string memory proName,\n', '        uint256 tokenOutPrice,\n', '        string memory tokenInSymbol,\n', '        string memory tokenOutSymbol,\n', '        uint8 poolType,\n', '        uint8 state,\n', '        bool homePageShow,\n', '        string memory proLink\n', '    );\n', '}\n', '\n', '// File: localhost/interface/IPool.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'interface IPool {\n', '\n', '    struct Participation {\n', '        uint256 timeStamp;\n', '        uint256 amountOfTokenIn;\n', '        uint256 availableAmountOfTokenIn;\n', '        uint256 amountOfTokenOut;\n', '        bool claimed;\n', '    }\n', '\n', '    function getParticipation(address participant) external view returns (\n', '        uint256 timeStamp,\n', '        uint256 amountOfTokenIn,\n', '        uint256 availableAmountOfTokenIn,\n', '        uint256 amountOfTokenOut,\n', '        bool claimed\n', '    );\n', '\n', '    function proName() external view returns (string memory);\n', '\n', '    function proLink() external view returns (string memory);\n', '\n', '    function homePageShow() external view returns (bool);\n', '\n', '    function poolType() external view returns (uint8);\n', '\n', '    function startTime() external view returns (uint256);\n', '\n', '    function endTime() external view returns (uint256);\n', '\n', '    function tokenOutPrice() external view returns (uint256);\n', '\n', '    function nameOfTokenOut() external view returns (string memory);\n', '\n', '    function symbolOfTokenOut() external view returns (string memory);\n', '\n', '    function symbolOfTokenIn() external view returns (string memory);\n', '\n', '    function decimalsOfTokenOut() external view returns (uint8);\n', '\n', '    function isOver() external view returns (bool);\n', '\n', '    function canClaim(address participant) external view returns (bool);\n', '\n', '    function state() external view returns (uint8);\n', '\n', '    function setStartTime(uint256 time) external returns (bool);\n', '\n', '    function setEndTime(uint256 time) external returns (bool);\n', '\n', '    function setVault(address newVault) external returns (bool);\n', '\n', '    function activate(bool bActivated, bool bHomePageShow, string calldata prolink, uint256 feeRate) external returns (bool);\n', '\n', '    function swap(uint256 amountOfTokenIn) external returns (bool);\n', '\n', '    function claim() external returns (bool);\n', '\n', '    function withdraw() external returns (bool);\n', '\n', '    function claimTime() external view returns (uint256);\n', '\n', '    function setClaimTime(uint256 time) external returns (bool);\n', '\n', '    function getFeeRate() external view returns (uint256);\n', '\n', '    function getFeeTo() external view returns (address);\n', '\n', '    function setFeeTo(address account) external returns (bool);\n', '}\n', '// File: localhost/lib/Address.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '\n', '    function isNotZero(address account) internal pure returns (bool) {\n', '        return account != address(0);\n', '    }\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly {size := extcodesize(account)}\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success,) = recipient.call{value : amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{value : weiValue}(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '// File: localhost/base/InitializableOwnable.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'contract InitializableOwnable {\n', '    address public _OWNER_;\n', '    address public _NEW_OWNER_;\n', '    bool internal _INITIALIZED_;\n', '\n', '    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    modifier notInitialized() {\n', '        require(!_INITIALIZED_, "INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _OWNER_, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    function initOwner(address newOwner) public notInitialized {\n', '        _INITIALIZED_ = true;\n', '        _OWNER_ = newOwner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n', '        _NEW_OWNER_ = newOwner;\n', '    }\n', '\n', '    function claimOwnership() public {\n', '        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");\n', '        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n', '        _OWNER_ = _NEW_OWNER_;\n', '        _NEW_OWNER_ = address(0);\n', '    }\n', '}\n', '// File: localhost/lib/SafeMath.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = x / 2 + 1;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '// File: localhost/token/IDO/PriIPoolTemplate.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'contract PriIPoolTemplate is IPool, InitializableOwnable, Rootable {\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => uint256) private _orders;\n', '    mapping(address => Participation) private _participations;\n', '    uint256 private _startTime;\n', '    uint256 private _endTime;\n', '    uint256 private _claimTime;\n', '    uint256 private _tokenOutSupply;\n', '    uint256 private _tokenOutReserved;\n', '    uint256 private _totalAmountOfTokenIn;\n', '    uint256 private _upperLimitOfTokenIn;\n', '    bool private _isOver = false;\n', '    string private _proName;\n', '    string private _proLink;\n', '\n', '    IPoolFactory public _FACTORY_;\n', '\n', '    event PrivateOffering(address indexed participant, uint256 amountOfTokenIn, uint256 amountOfTokenOut);\n', '    event PrivateOfferingClaimed(address indexed participant, uint256 amountOfTokenOut);\n', '\n', '    uint256 private _tokenOutPrice;// TOKENOUT/TOKENIN * FACTOR\n', '    uint256 public constant _FACTOR_ = 10000;\n', '\n', '    mapping(address => uint8) private _whiteList;\n', '\n', '    IERC20  public _TOKEN_IN_;\n', '    IERC20  public _TOKEN_OUT_;\n', '\n', '    bool private _withdrawn = false;\n', '    uint8 private unlocked = 1;\n', '    modifier lock() {\n', "        require(unlocked == 1, 'LOCKED');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '    bool private _activated = false;\n', '    modifier activated() {\n', '        require(_activated, "NOT_ACTIVATED");\n', '        _;\n', '    }\n', '    modifier whenNotActivated() {\n', '        require(!_activated, "ACTIVATED");\n', '        _;\n', '    }\n', '\n', '    uint256 private _feeRate = 10;//10% as default\n', '    address private _feeTo;\n', '\n', '    address private _vault;\n', '    bool private _homePageShow;\n', '    bool public initialized;\n', '\n', '    function init(\n', '        address __factory,\n', '        address __root,\n', '        address __creator,\n', '        string calldata __proName,\n', '        uint256 __startTime,\n', '        uint256 __endTime,\n', '        address __tokenIn,\n', '        address __tokenOut,\n', '        uint256 __tokenOutSupply,\n', '        uint256 __upperLimitOfTokenIn,\n', '        uint256 __tokenOutPrice\n', '    ) external {\n', '        require(!initialized, "INITIALIZED");\n', '        initOwner(__creator);\n', '        initRoot(__root);\n', '        _feeTo = __root;\n', '        _vault = __creator;\n', '        _FACTORY_ = IPoolFactory(__factory);\n', '        _proName = __proName;\n', '        _startTime = __startTime;\n', '        _endTime = __endTime;\n', '        _TOKEN_IN_ = IERC20(__tokenIn);\n', '        _TOKEN_OUT_ = IERC20(__tokenOut);\n', '        _tokenOutSupply = __tokenOutSupply;\n', '        _upperLimitOfTokenIn = __upperLimitOfTokenIn;\n', '        _tokenOutPrice = __tokenOutPrice;\n', '        _totalAmountOfTokenIn = 0;\n', '        initialized = true;\n', '        unlocked = 1;\n', '    }\n', '\n', '    function setTokenOutPrice(uint256 newPrice) external whenNotActivated onlyOwner {\n', '        _tokenOutPrice = newPrice;\n', '    }\n', '\n', '    function inWhiteList(address account) external view returns (bool) {\n', '        return _whiteList[account] == 1;\n', '    }\n', '\n', '    function addToWhiteList(address account) external onlyOwner {\n', '        _whiteList[account] = 1;\n', '    }\n', '\n', '    function addBatchToWhiteList(address[] calldata accounts) external onlyOwner {\n', '        for (uint i = 0; i < accounts.length; i++) {\n', '            _whiteList[accounts[i]] = 1;\n', '        }\n', '    }\n', '\n', '    function removeFromWhiteList(address account) external onlyOwner {\n', '        _whiteList[account] = 0;\n', '    }\n', '\n', '    function tokenOutSupply() external view returns (uint256) {\n', '        return _tokenOutSupply;\n', '    }\n', '\n', '    function tokenOutReserved() external view returns (uint256) {\n', '        return _tokenOutReserved;\n', '    }\n', '\n', '    function totalAmountOfTokenIn() external view returns (uint256) {\n', '        return _totalAmountOfTokenIn;\n', '    }\n', '\n', '    function setTokenOutSupply(uint256 newSupply) external whenNotActivated onlyOwner {\n', '        _tokenOutSupply = newSupply;\n', '    }\n', '\n', '    function setUpperLimitOfTokenIn(uint256 newVal) external whenNotActivated onlyOwner {\n', '        _upperLimitOfTokenIn = newVal;\n', '    }\n', '\n', '    function upperLimitOfTokenIn() external view returns (uint256) {\n', '        return _upperLimitOfTokenIn;\n', '    }\n', '\n', '    //IPool\n', '    function getParticipation(address participant) external override view returns (\n', '        uint256 timeStamp,\n', '        uint256 amountOfTokenIn,\n', '        uint256 availableAmountOfTokenIn,\n', '        uint256 amountOfTokenOut,\n', '        bool claimed\n', '    ){\n', '        Participation memory p = _participations[participant];\n', '        return (p.timeStamp, p.amountOfTokenIn, p.availableAmountOfTokenIn, p.amountOfTokenOut, p.claimed);\n', '    }\n', '\n', '    function proName() external override view returns (string memory){\n', '        return _proName;\n', '    }\n', '\n', '    function proLink() external override view returns (string memory){\n', '        return _proLink;\n', '    }\n', '\n', '    function homePageShow() external override view returns (bool){\n', '        return _homePageShow;\n', '    }\n', '\n', '    function poolType() external view override returns (uint8){\n', '        return 1;\n', '    }\n', '\n', '    function startTime() external view override returns (uint256){\n', '        return _startTime;\n', '    }\n', '\n', '    function endTime() external override view returns (uint256){\n', '        return _endTime;\n', '    }\n', '\n', '    function tokenOutPrice() external override view returns (uint256){\n', '        return _tokenOutPrice;\n', '    }\n', '\n', '    function nameOfTokenOut() external override view returns (string memory) {\n', '        return _TOKEN_OUT_.name();\n', '    }\n', '\n', '    function symbolOfTokenOut() external override view returns (string memory) {\n', '        return _TOKEN_OUT_.symbol();\n', '    }\n', '\n', '    function symbolOfTokenIn() external override view returns (string memory) {\n', '        return _TOKEN_IN_.symbol();\n', '    }\n', '\n', '    function decimalsOfTokenOut() external override view returns (uint8) {\n', '        return _TOKEN_OUT_.decimals();\n', '    }\n', '\n', '    function isOver() public override view returns (bool) {\n', '        return block.timestamp > _endTime || _isOver;\n', '    }\n', '\n', '    function canClaim(address participant) public override view returns (bool){\n', '        return isOver() && _orders[participant] > 0 && block.timestamp >= _claimTime;\n', '    }\n', '\n', '    function state() external override view returns (uint8){\n', '        if (_activated) {\n', '            if (block.timestamp < _startTime) {//NOT STARTED\n', '                return 1;\n', '            }\n', '            else if (!_isOver && block.timestamp >= _startTime && block.timestamp <= _endTime) {//IN PROGRESS\n', '                return 2;\n', '            }\n', '            else {//IS OVER\n', '                return 3;\n', '            }\n', '        }\n', '        else {//NOT ACTIVATED\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function setStartTime(uint256 time) onlyOwner external override whenNotActivated returns (bool){\n', '        require(time > block.timestamp.add(300), "INVALID_START_TIME");\n', '        _startTime = time;\n', '        return true;\n', '    }\n', '\n', '    function setEndTime(uint256 time) onlyOwner external override whenNotActivated returns (bool){\n', '        require(time > block.timestamp.add(600), "INVALID_END_TIME");\n', '        _endTime = time;\n', '        return true;\n', '    }\n', '\n', '    function setVault(address newVault) onlyOwner external override whenNotActivated returns (bool){\n', "        require(Address.isNotZero(newVault), 'ZERO_ADDRESS_NOT_ALLOWED');\n", '        _vault = newVault;\n', '        return true;\n', '    }\n', '\n', '    function activate(bool bActivated, bool bHomePageShow, string calldata sProlink, uint256 feeRate) onlyRoot external override returns (bool){\n', '        require(_startTime > block.timestamp.add(300), "INVALID_START_TIME");\n', '        require(_endTime >= _startTime.add(300), "INVALID_END_TIME");\n', '        require(Address.isContract(address(_TOKEN_IN_)), "INVALID_TOKEN_IN");\n', '        require(Address.isContract(address(_TOKEN_OUT_)), "INVALID_TOKEN_OUT");\n', '        require(feeRate <= 100, "INVALID_FEE_RATE");\n', '\n', '        if (_claimTime < _endTime) {\n', '            _claimTime = _endTime;\n', '        }\n', '\n', '        _activated = bActivated;\n', '        _homePageShow = bHomePageShow;\n', '        _proLink = sProlink;\n', '        _feeRate = feeRate;\n', '\n', '        return true;\n', '    }\n', '\n', '    function swap(uint256 amountOfTokenIn) activated lock external override returns (bool)  {\n', '        require(_whiteList[msg.sender] == 1, "NOT_IN_WHITE_LIST");\n', "        require(block.timestamp >= _startTime, 'NOT_STARTED');\n", "        require(!isOver(), 'PRIVATE_OFFERING_IS_OVER');\n", "        require(_orders[msg.sender] == 0, 'ENROLLED_ALREADY');\n", "        require(amountOfTokenIn <= _upperLimitOfTokenIn, 'EXCEEDS_THE_UPPER_LIMIT');\n", '        require(amountOfTokenIn > 0, "INVALID_AMOUNT");\n', "        require(_tokenOutReserved < _tokenOutSupply, 'INSUFFICIENT_TOKEN_OUT');\n", '\n', '        uint256 tokenOutDeci = uint256(10) ** _TOKEN_OUT_.decimals();\n', '        uint256 tokenInDeci = uint256(10) ** _TOKEN_IN_.decimals();\n', '\n', '        uint256 amountOfTokenOut = amountOfTokenIn.mul(tokenOutDeci).mul(_tokenOutPrice).div(_FACTOR_).div(tokenInDeci);\n', '\n', '        if (_tokenOutReserved.add(amountOfTokenOut) >= _tokenOutSupply) {\n', '            amountOfTokenOut = _tokenOutSupply.sub(_tokenOutReserved);\n', '            amountOfTokenIn = amountOfTokenOut.mul(_FACTOR_).mul(tokenInDeci).div(tokenOutDeci).div(_tokenOutPrice);\n', '            _isOver = true;\n', '        }\n', '\n', '        _transferFrom(address(_TOKEN_IN_), msg.sender, address(this), amountOfTokenIn);\n', '        _orders[msg.sender] = amountOfTokenOut;\n', '        _tokenOutReserved = _tokenOutReserved.add(amountOfTokenOut);\n', '        _totalAmountOfTokenIn = _totalAmountOfTokenIn.add(amountOfTokenIn);\n', '        emit PrivateOffering(msg.sender, amountOfTokenIn, amountOfTokenOut);\n', '\n', '        _FACTORY_.enroll(msg.sender, address(this));\n', '        Participation storage p = _participations[msg.sender];\n', '        p.timeStamp = block.timestamp;\n', '        p.amountOfTokenIn = amountOfTokenIn;\n', '        p.availableAmountOfTokenIn = amountOfTokenIn;\n', '        p.amountOfTokenOut = amountOfTokenOut;\n', '\n', '        return true;\n', '    }\n', '\n', '    function claim() lock external override returns (bool){\n', "        require(canClaim(msg.sender), 'FORBIDDEN');\n", '\n', '        uint256 reserved = _orders[msg.sender];\n', '        _transfer(address(_TOKEN_OUT_), msg.sender, reserved);\n', '        _orders[msg.sender] = 0;\n', '        emit PrivateOfferingClaimed(msg.sender, reserved);\n', '\n', '        Participation storage p = _participations[msg.sender];\n', '        p.claimed = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw() onlyRoot external override returns (bool){\n', "        require(isOver(), 'IS_NOT_OVER');\n", "        require(!_withdrawn, 'WITHDRAWN');\n", '\n', '        uint256 fee = _totalAmountOfTokenIn.mul(_feeRate).div(100);\n', '        if (fee > 0) {\n', '            _transfer(address(_TOKEN_IN_), _feeTo, fee);\n', '        }\n', '\n', '        uint256 reserve = _totalAmountOfTokenIn.sub(fee);\n', '        if (reserve > 0) {\n', '            _transfer(address(_TOKEN_IN_), _vault, reserve);\n', '        }\n', '\n', '        _withdrawn = true;\n', '        return true;\n', '    }\n', '\n', '    function claimTime() external override view returns (uint256){\n', '        return _claimTime;\n', '    }\n', '\n', '    function setClaimTime(uint256 time) onlyRoot external override returns (bool){\n', "        require(time > _endTime, 'FORBIDDEN');\n", '        _claimTime = time;\n', '        return true;\n', '    }\n', '\n', '    function getFeeRate() external override view returns (uint256){\n', '        return _feeRate;\n', '    }\n', '\n', '    function getFeeTo() external override view returns (address){\n', '        return _feeTo;\n', '    }\n', '\n', '    function setFeeTo(address account) onlyRoot override external returns (bool){\n', '        _feeTo = account;\n', '    }\n', '\n', '    //Only can call  this function 7 days later when PRI OFFERING was over, in case of emergency\n', '    function emergencyWithdraw(address token, address recipient, uint256 amount) onlyRoot external {\n', "        require(block.timestamp > _claimTime.add(7 days), 'FORBIDDEN');\n", '\n', "        bytes4 methodId = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _transfer(address token, address recipient, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _transferFrom(address token, address sender, address recipient, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, sender, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FROM_FAILED');\n", '    }\n', '}\n', '// File: localhost/token/IDO/PubPoolTemplate.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'contract PubPoolTemplate is IPool, InitializableOwnable, Rootable {\n', '    using SafeMath for uint256;\n', '\n', '    string private _proName;\n', '    string private _proLink;\n', '    mapping(address => uint256) private _orders;\n', '    mapping(address => Participation) private _participations;\n', '    uint256 private _targetAmountOfTokenIn;\n', '    uint256 private _targetAmountOfTokenOut;\n', '    uint256 private _totalAmountOfTokenIn;\n', '    uint256 private _startTime;\n', '    uint256 private _endTime;\n', '    uint256 private _claimTime;\n', '\n', '    uint256 private _bottomLimitOfTokenIn;\n', '    IPoolFactory public _FACTORY_;\n', '\n', '    uint256 private _tokenOutPrice;\n', '    uint256 public constant FACTOR = 10000;\n', '\n', '    event PublicOffering(address indexed participant, uint256 amountOfTokenIn);\n', '    event PublicOfferingClaimed(address indexed participant, uint256 amountOfTokenOut);\n', '    event PublicOfferingRefund(address indexed participant, uint256 amountOfTokenIn);\n', '\n', '    IERC20  public _TOKEN_OUT_;\n', '    IERC20  public _TOKEN_IN_;\n', '\n', '    address private _vault;\n', '    bool private _withdrawn = false;\n', '    uint private unlocked = 1;\n', '    modifier lock() {\n', "        require(unlocked == 1, 'LOCKED');\n", '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '    bool private _activated = false;\n', '    modifier activated() {\n', '        require(_activated, "NOT_ACTIVATED");\n', '        _;\n', '    }\n', '    modifier whenNotActivated() {\n', '        require(!_activated, "ACTIVATED");\n', '        _;\n', '    }\n', '\n', '    uint256 private _feeRate = 10;//10% as default\n', '    address private _feeTo;\n', '\n', '    bool private _homePageShow;\n', '    bool public initialized;\n', '\n', '    function init(\n', '        address __factory,\n', '        address __root,\n', '        address __creator,\n', '        string calldata __proName,\n', '        uint256 __startTime,\n', '        uint256 __endTime,\n', '        address __tokenIn,\n', '        address __tokenOut,\n', '        uint256 __targetAmountOfTokenIn,\n', '        uint256 __targetAmountOfTokenOut,\n', '        uint256 __bottomLimitOfTokenIn\n', '    ) external {\n', '        require(!initialized, "INITIALIZED");\n', '        initOwner(__creator);\n', '        initRoot(__root);\n', '        _feeTo = __root;\n', '        _vault = __creator;\n', '        _FACTORY_ = IPoolFactory(__factory);\n', '        _proName = __proName;\n', '        _startTime = __startTime;\n', '        _endTime = __endTime;\n', '        _TOKEN_IN_ = IERC20(__tokenIn);\n', '        _TOKEN_OUT_ = IERC20(__tokenOut);\n', '        _targetAmountOfTokenIn = __targetAmountOfTokenIn;\n', '        _targetAmountOfTokenOut = __targetAmountOfTokenOut;\n', '        _bottomLimitOfTokenIn = __bottomLimitOfTokenIn;\n', '        updateTokenOutPrice();\n', '        initialized = true;\n', '        unlocked = 1;\n', '    }\n', '\n', '    function updateTokenOutPrice() private {\n', '        uint256 tokenOutDeci = uint256(10) ** _TOKEN_OUT_.decimals();\n', '        uint256 tokenInDeci = uint256(10) ** _TOKEN_IN_.decimals();\n', '\n', '        _tokenOutPrice = _targetAmountOfTokenOut.mul(tokenInDeci).mul(FACTOR).div(tokenOutDeci).div(_targetAmountOfTokenIn);\n', '    }\n', '\n', '    function setTargetAmountOfTokenIn(uint256 newVal) external whenNotActivated onlyOwner {\n', '        _targetAmountOfTokenIn = newVal;\n', '        updateTokenOutPrice();\n', '    }\n', '\n', '    function setTargetAmountOfTokenOut(uint256 newVal) external whenNotActivated onlyOwner {\n', '        _targetAmountOfTokenOut = newVal;\n', '        updateTokenOutPrice();\n', '    }\n', '\n', '    function setBottomLimitOfTokenIn(uint256 newVal) external whenNotActivated onlyOwner {\n', '        _bottomLimitOfTokenIn = newVal;\n', '    }\n', '\n', '    function targetAmountOfTokenIn() external view returns (uint256){\n', '        return _targetAmountOfTokenIn;\n', '    }\n', '\n', '    function targetAmountOfTokenOut() external view returns (uint256){\n', '        return _targetAmountOfTokenOut;\n', '    }\n', '\n', '    function totalAmountOfTokenIn() external view returns (uint256) {\n', '        return _totalAmountOfTokenIn;\n', '    }\n', '\n', '    function bottomLimitOfTokenIn() external view returns (uint256){\n', '        return _bottomLimitOfTokenIn;\n', '    }\n', '\n', '    //IPool\n', '    function getParticipation(address participant) external override view returns (\n', '        uint256 timeStamp,\n', '        uint256 amountOfTokenIn,\n', '        uint256 availableAmountOfTokenIn,\n', '        uint256 amountOfTokenOut,\n', '        bool claimed\n', '    ){\n', '        Participation memory p = _participations[participant];\n', '        return (p.timeStamp, p.amountOfTokenIn, p.availableAmountOfTokenIn, p.amountOfTokenOut, p.claimed);\n', '    }\n', '\n', '    function proName() external override view returns (string memory){\n', '        return _proName;\n', '    }\n', '\n', '    function proLink() external override view returns (string memory){\n', '        return _proLink;\n', '    }\n', '\n', '    function homePageShow() external override view returns (bool){\n', '        return _homePageShow;\n', '    }\n', '\n', '    function poolType() external override view returns (uint8){\n', '        return 2;\n', '    }\n', '\n', '    function startTime() external override view returns (uint256){\n', '        return _startTime;\n', '    }\n', '\n', '    function endTime() external override view returns (uint256){\n', '        return _endTime;\n', '    }\n', '\n', '    function tokenOutPrice() external override view returns (uint256){\n', '        return _tokenOutPrice;\n', '    }\n', '\n', '    function nameOfTokenOut() external override view returns (string memory) {\n', '        return _TOKEN_OUT_.name();\n', '    }\n', '\n', '    function symbolOfTokenOut() external override view returns (string memory) {\n', '        return _TOKEN_OUT_.symbol();\n', '    }\n', '\n', '    function symbolOfTokenIn() external override view returns (string memory) {\n', '        return _TOKEN_IN_.symbol();\n', '    }\n', '\n', '    function decimalsOfTokenOut() external override view returns (uint8) {\n', '        return _TOKEN_OUT_.decimals();\n', '    }\n', '\n', '    function isOver() public override view returns (bool) {\n', '        return block.timestamp > _endTime;\n', '    }\n', '\n', '    function canClaim(address participant) public override view returns (bool){\n', '        return isOver() && _orders[participant] > 0 && block.timestamp >= _claimTime;\n', '    }\n', '\n', '    function state() external override view returns (uint8){\n', '        if (_activated) {\n', '            if (block.timestamp < _startTime) {//NOT STARTED\n', '                return 1;\n', '            }\n', '            else if (block.timestamp >= _startTime && block.timestamp <= _endTime) {//IN PROGRESS\n', '                return 2;\n', '            }\n', '            else {//IS OVER\n', '                return 3;\n', '            }\n', '        }\n', '        else {//NOT ACTIVATED\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function setStartTime(uint256 time) onlyOwner external override whenNotActivated returns (bool){\n', '        require(time > block.timestamp.add(300), "INVALID_START_TIME");\n', '        _startTime = time;\n', '        return true;\n', '    }\n', '\n', '    function setEndTime(uint256 time) onlyOwner external override whenNotActivated returns (bool){\n', '        require(time > block.timestamp.add(600), "INVALID_END_TIME");\n', '        _endTime = time;\n', '        return true;\n', '    }\n', '\n', '    function setVault(address newVault) onlyOwner external override whenNotActivated returns (bool){\n', "        require(Address.isNotZero(newVault), 'ZERO_ADDRESS_NOT_ALLOWED');\n", '        _vault = newVault;\n', '\n', '        return true;\n', '    }\n', '\n', '    function activate(bool bActivated, bool bHomePageShow, string calldata sProlink, uint256 feeRate) onlyRoot external override returns (bool){\n', '        require(_startTime > block.timestamp.add(300), "INVALID_START_TIME");\n', '        require(_endTime >= _startTime.add(300), "INVALID_END_TIME");\n', '        require(Address.isContract(address(_TOKEN_IN_)), "INVALID_TOKEN_IN");\n', '        require(Address.isContract(address(_TOKEN_OUT_)), "INVALID_TOKEN_OUT");\n', '        require(feeRate <= 100, "INVALID_FEE_RATE");\n', '        if (_claimTime < _endTime) {\n', '            _claimTime = _endTime;\n', '        }\n', '\n', '        _activated = bActivated;\n', '        _homePageShow = bHomePageShow;\n', '        _proLink = sProlink;\n', '        _feeRate = feeRate;\n', '\n', '        return true;\n', '    }\n', '\n', '    function swap(uint256 amountOfTokenIn) activated lock external override returns (bool)  {\n', "        require(block.timestamp >= _startTime, 'NOT_STARTED');\n", "        require(!isOver(), 'IS_OVER');\n", "        require(amountOfTokenIn >= _bottomLimitOfTokenIn, 'AMOUNT_TOO_LOW');\n", '\n', '        _transferFrom(address(_TOKEN_IN_), msg.sender, address(this), amountOfTokenIn);\n', '        _orders[msg.sender] = _orders[msg.sender].add(amountOfTokenIn);\n', '        _totalAmountOfTokenIn = _totalAmountOfTokenIn.add(amountOfTokenIn);\n', '        emit PublicOffering(msg.sender, amountOfTokenIn);\n', '\n', '        _FACTORY_.enroll(msg.sender, address(this));\n', '        Participation storage p = _participations[msg.sender];\n', '        p.timeStamp = block.timestamp;\n', '        p.amountOfTokenIn = p.amountOfTokenIn.add(amountOfTokenIn);\n', '\n', '        return true;\n', '    }\n', '\n', '    function claim() lock external override returns (bool)  {\n', "        require(canClaim(msg.sender), 'FORBIDDEN');\n", '\n', '        uint256 tokenOutDeci = uint256(10) ** _TOKEN_OUT_.decimals();\n', '        uint256 tokenInDeci = uint256(10) ** _TOKEN_IN_.decimals();\n', '\n', '        uint256 amountOfTokenInPayed = _orders[msg.sender];\n', '\n', '        uint256 reservedTokenOut = 0;\n', '        uint256 availableAmountOfTokenIn = amountOfTokenInPayed;\n', '        if (_totalAmountOfTokenIn > _targetAmountOfTokenIn) {\n', '            availableAmountOfTokenIn = amountOfTokenInPayed.mul(_targetAmountOfTokenIn).div(_totalAmountOfTokenIn);\n', '            reservedTokenOut = availableAmountOfTokenIn.mul(tokenOutDeci).mul(_tokenOutPrice).div(tokenInDeci).div(FACTOR);\n', '            uint256 amountOfTokenInToRefund = amountOfTokenInPayed.sub(availableAmountOfTokenIn).sub(10);\n', '\n', '            if (amountOfTokenInToRefund > 0) {\n', '                _transfer(address(_TOKEN_IN_), msg.sender, amountOfTokenInToRefund);\n', '                emit PublicOfferingRefund(msg.sender, amountOfTokenInToRefund);\n', '            }\n', '        }\n', '        else {\n', '            reservedTokenOut = amountOfTokenInPayed.mul(tokenOutDeci).mul(_tokenOutPrice).div(tokenInDeci).div(FACTOR);\n', '        }\n', '\n', '        _transfer(address(_TOKEN_OUT_), msg.sender, reservedTokenOut);\n', '        _orders[msg.sender] = 0;\n', '        emit PublicOfferingClaimed(msg.sender, reservedTokenOut);\n', '\n', '        Participation storage p = _participations[msg.sender];\n', '        p.availableAmountOfTokenIn = availableAmountOfTokenIn;\n', '        p.amountOfTokenOut = reservedTokenOut;\n', '        p.claimed = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    function withdraw() onlyRoot external override returns (bool)  {\n', "        require(isOver(), 'NOT_OVER');\n", "        require(!_withdrawn, 'WITHDRAWN');\n", '\n', '        uint256 amountOfTokenInToWithdraw = _totalAmountOfTokenIn;\n', '        if (_totalAmountOfTokenIn > _targetAmountOfTokenIn) {\n', '            amountOfTokenInToWithdraw = _targetAmountOfTokenIn;\n', '        }\n', '\n', '        uint256 fee = amountOfTokenInToWithdraw.mul(_feeRate).div(100);\n', '        if (fee > 0) {\n', '            _transfer(address(_TOKEN_IN_), _feeTo, fee);\n', '        }\n', '\n', '        uint256 reserve = amountOfTokenInToWithdraw.sub(fee);\n', '        if (reserve > 0) {\n', '            _transfer(address(_TOKEN_IN_), _vault, reserve);\n', '        }\n', '\n', '        _withdrawn = true;\n', '\n', '        return true;\n', '    }\n', '\n', '    function claimTime() external override view returns (uint256){\n', '        return _claimTime;\n', '    }\n', '\n', '    function setClaimTime(uint256 time) onlyRoot external override returns (bool){\n', "        require(time > _endTime, 'FORBIDDEN');\n", '        _claimTime = time;\n', '        return true;\n', '    }\n', '\n', '    function getFeeRate() external override view returns (uint256){\n', '        return _feeRate;\n', '    }\n', '\n', '    function getFeeTo() external override view returns (address){\n', '        return _feeTo;\n', '    }\n', '\n', '    function setFeeTo(address account) onlyRoot override external returns (bool){\n', '        _feeTo = account;\n', '    }\n', '\n', '    //Only can call  this function 7 days later when PUB OFFERING was over, in case of emergency\n', '    function emergencyWithdraw(address token, address recipient, uint256 amount) onlyRoot external {\n', "        require(block.timestamp > _claimTime.add(7 days), 'FORBIDDEN');\n", '\n', "        bytes4 methodId = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _transfer(address token, address recipient, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    function _transferFrom(address token, address sender, address recipient, uint256 amount) private {\n', "        bytes4 methodId = bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(methodId, sender, recipient, amount));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TRANSFER_FROM_FAILED');\n", '    }\n', '}\n', '// File: localhost/interface/ICloneFactory.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', 'interface ICloneFactory {\n', '    function clone(address prototype) external returns (address proxy);\n', '}\n', '// File: localhost/base/Context.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '// File: localhost/base/Ownable.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', 'contract Ownable is Context{\n', '\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = _msgSender();\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "CALLER_IS_NOT_THE_OWNER");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "NEW_OWNER_IS_THE_ZERO_ADDRESS");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '// File: localhost/token/IDO/PoolFactory.sol\n', '\n', '//SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.0;\n', '\n', '\n', '\n', '\n', '\n', 'contract PoolFactory is Ownable, IPoolFactory {\n', '    address public _CLONE_FACTORY_;\n', '    address public _PRI_POOL_TEMPLATE_;\n', '    address public _PUB_POOL_TEMPLATE_;\n', '    address public _ROOT_;\n', '    mapping(address => uint8) private _tokenInWhitelist;\n', '\n', '    event NewPool(address poolAddress, uint8 poolType, address creator);\n', '\n', '    // ============ Registry ============\n', '    // creator -> pool address list\n', '    mapping(address => address[]) public _USER_REGISTRY_;\n', '\n', '    // participant -> pool address list\n', '    mapping(address => address[]) public _USER_ENROLL_;\n', '\n', '    address[] private _pools;\n', '\n', '    mapping(address => uint8) private _poolsMap;\n', '\n', '    constructor(\n', '        address cloneFactory,\n', '        address priPoolTemplate,\n', '        address pubPoolTemplate\n', '    ) public {\n', '        _CLONE_FACTORY_ = cloneFactory;\n', '        _PRI_POOL_TEMPLATE_ = priPoolTemplate;\n', '        _PUB_POOL_TEMPLATE_ = pubPoolTemplate;\n', '        _ROOT_ = 0xbF87D4a808AAdE437348B61e80704433B0bbBe7e;\n', '        _owner = 0xbF87D4a808AAdE437348B61e80704433B0bbBe7e;\n', '\n', '        // ETH\n', '        _tokenInWhitelist[0x1d32916CFA6534D261AD53E2498AB95505bd2510] = 1;//YOU\n', '        _tokenInWhitelist[0xdAC17F958D2ee523a2206206994597C13D831ec7] = 1;//USDT\n', '        _tokenInWhitelist[0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2] = 1;//WETH\n', '        _tokenInWhitelist[0x12A132927A47E8ea1535f491061bC6Cbe460C46B] = 1;//YOU/USDT LP\n', '        \n', '        //HECO\n', '        // _tokenInWhitelist[0x9364e119AD76e0346126aFcbDF5C9f0189500Cc5] = 1;//YOU\n', '        // _tokenInWhitelist[0xa71EdC38d189767582C38A3145b5873052c3e47a] = 1;//USDT\n', '        // _tokenInWhitelist[0x0298c2b32eaE4da002a15f36fdf7615BEa3DA047] = 1;//HUSD\n', '        // _tokenInWhitelist[0x5545153CCFcA01fbd7Dd11C0b23ba694D9509A6F] = 1;//WHT\n', '        // _tokenInWhitelist[0x7A24E1aA124C53E20a35Ec44AD86a16B66458087] = 1;//YOU/USDT LP\n', '\n', '        //BSC\n', '        // _tokenInWhitelist[0x181801F00df1BD997D38Dd579dBd44bf9b5a6d2D] = 1;//YOU\n', '        // _tokenInWhitelist[0x55d398326f99059fF775485246999027B3197955] = 1;//USDT\n', '        // _tokenInWhitelist[0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56] = 1;//BUSD\n', '        // _tokenInWhitelist[0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c] = 1;//WBNB\n', '        // _tokenInWhitelist[0x090DeBA6FeF9422d5f9AA944034EB37234FFba45] = 1;//YOU/USDT LP\n', '    }\n', '\n', '    function createPriPool(\n', '        string calldata _proName,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        address _tokenIn,\n', '        address _tokenOut,\n', '        uint256 _tokenOutSupply,\n', '        uint256 _upperLimitOfTokenIn,\n', '        uint256 _tokenOutPrice\n', '    ) external override returns (address newPool) {\n', '        require(tokenInWhiteList(_tokenIn), "UNSUPPORTED_TOKEN_IN");\n', '        require(_tokenIn != _tokenOut, "TOKEN_OUT_SAME_WITH_TOKEN_IN");\n', '        newPool = ICloneFactory(_CLONE_FACTORY_).clone(_PRI_POOL_TEMPLATE_);\n', '        PriIPoolTemplate(newPool).init(\n', '            address(this),\n', '            _ROOT_,\n', '            msg.sender,\n', '            _proName,\n', '            _startTime,\n', '            _endTime,\n', '            _tokenIn,\n', '            _tokenOut,\n', '            _tokenOutSupply,\n', '            _upperLimitOfTokenIn,\n', '            _tokenOutPrice\n', '        );\n', '        _USER_REGISTRY_[msg.sender].push(newPool);\n', '        _poolsMap[newPool] = 1;\n', '        _pools.push(newPool);\n', '        emit NewPool(newPool, 1, msg.sender);\n', '    }\n', '\n', '    function createPubPool(\n', '        string calldata _proName,\n', '        uint256 _startTime,\n', '        uint256 _endTime,\n', '        address _tokenIn,\n', '        address _tokenOut,\n', '        uint256 _targetAmountOfTokenIn,\n', '        uint256 _targetAmountOfTokenOut,\n', '        uint256 _bottomLimitOfTokenIn\n', '    ) external override returns (address newPool) {\n', '        require(tokenInWhiteList(_tokenIn), "UNSUPPORTED_TOKEN_IN");\n', '        require(_tokenIn != _tokenOut, "TOKEN_OUT_SAME_WITH_TOKEN_IN");\n', '        newPool = ICloneFactory(_CLONE_FACTORY_).clone(_PUB_POOL_TEMPLATE_);\n', '        PubPoolTemplate(newPool).init(\n', '            address(this),\n', '            _ROOT_,\n', '            msg.sender,\n', '            _proName,\n', '            _startTime,\n', '            _endTime,\n', '            _tokenIn,\n', '            _tokenOut,\n', '            _targetAmountOfTokenIn,\n', '            _targetAmountOfTokenOut,\n', '            _bottomLimitOfTokenIn\n', '        );\n', '        _USER_REGISTRY_[msg.sender].push(newPool);\n', '        _poolsMap[newPool] = 1;\n', '        _pools.push(newPool);\n', '        emit NewPool(newPool, 2, msg.sender);\n', '    }\n', '\n', '    modifier isPool() {\n', '        require(_poolsMap[msg.sender] == 1, "THE_CALLER_IS_NOT_A_POOL");\n', '        _;\n', '    }\n', '\n', '    function addTokenInToWhiteList(address tokenIn) external override onlyOwner {\n', '        _tokenInWhitelist[tokenIn] = 1;\n', '    }\n', '\n', '    function removeTokenInFromWhiteList(address tokenIn) external override onlyOwner {\n', '        _tokenInWhitelist[tokenIn] = 0;\n', '    }\n', '\n', '    function tokenInWhiteList(address tokenIn) public override view returns (bool) {\n', '        return _tokenInWhitelist[tokenIn] == 1;\n', '    }\n', '\n', '    function getPools() external override view returns (address[] memory pools){\n', '        return _pools;\n', '    }\n', '\n', '    function getPoolsByCreator(address creator) external override view returns (address[] memory pools){\n', '        return _USER_REGISTRY_[creator];\n', '    }\n', '\n', '    function getPoolsByParticipant(address participant) external override view returns (address[] memory pools){\n', '        return _USER_ENROLL_[participant];\n', '    }\n', '\n', '    function enroll(address participant, address pool) external override isPool returns (bool){\n', '        if (_USER_ENROLL_[participant].length > 0) {\n', '            for (uint256 i = 0; i < _USER_ENROLL_[participant].length; i++) {\n', '                if (_USER_ENROLL_[participant][i] == pool) return false;\n', '            }\n', '        }\n', '        _USER_ENROLL_[participant].push(pool);\n', '        return true;\n', '    }\n', '\n', '    function getPoolInfo(address poolAddr) external override view returns (\n', '        string memory proName,\n', '        uint256 tokenOutPrice,\n', '        string memory tokenInSymbol,\n', '        string memory tokenOutSymbol,\n', '        uint8 poolType,\n', '        uint8 state,\n', '        bool homePageShow,\n', '        string memory proLink\n', '    )\n', '    {\n', '        IPool pool = IPool(poolAddr);\n', '        return\n', '        (\n', '        pool.proName(),\n', '        pool.tokenOutPrice(),\n', '        pool.symbolOfTokenIn(),\n', '        pool.symbolOfTokenOut(),\n', '        pool.poolType(),\n', '        pool.state(),\n', '        pool.homePageShow(),\n', '        pool.proLink()\n', '        );\n', '    }\n', '}']