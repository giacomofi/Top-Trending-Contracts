['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-02\n', '*/\n', '\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '// SPDX-License-Identifier: MIT\n', 'library Strings {\n', '  struct slice {\n', '    uint _len;\n', '    uint _ptr;\n', '  }\n', '\n', '  function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n', '    if (_i == 0) {\n', '      return "0";\n', '    }\n', '    uint j = _i;\n', '    uint len;\n', '    while (j != 0) {\n', '      len++;\n', '      j /= 10;\n', '    }\n', '    bytes memory bstr = new bytes(len);\n', '    uint k = len;\n', '    while (_i != 0) {\n', '      k = k - 1;\n', '      uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n', '      bytes1 b1 = bytes1(temp);\n', '      bstr[k] = b1;\n', '      _i /= 10;\n', '    }\n', '    return string(bstr);\n', '  }\n', '\n', '  function memcpy(uint dest, uint src, uint len) private pure {\n', '    for (; len >= 32; len -= 32) {\n', '      assembly {\n', '        mstore(dest, mload(src))\n', '      }\n', '      dest += 32;\n', '      src += 32;\n', '    }\n', '    uint mask = 256 ** (32 - len) - 1;\n', '    assembly {\n', '      let srcpart := and(mload(src), not(mask))\n', '      let destpart := and(mload(dest), mask)\n', '      mstore(dest, or(destpart, srcpart))\n', '    }\n', '  }\n', '\n', '  function toSlice(string memory self) internal pure returns (slice memory) {\n', '    uint ptr;\n', '    assembly {\n', '      ptr := add(self, 0x20)\n', '    }\n', '    return slice(bytes(self).length, ptr);\n', '  }\n', '\n', '  function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n', '    string memory ret = new string(self._len + other._len);\n', '    uint retptr;\n', '    assembly {retptr := add(ret, 32)}\n', '    memcpy(retptr, self._ptr, self._len);\n', '    memcpy(retptr + self._len, other._ptr, other._len);\n', '    return ret;\n', '  }\n', '}\n', '\n', 'interface IERC20 {\n', '  function symbol() external view returns (string memory);\n', '\n', '  function name() external view returns (string memory);\n', '\n', '  function decimals() external view returns (uint256);\n', '\n', '  function balanceOf(address account) external view returns (uint256);\n', '\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '  function getTxAddress(address account) external view returns (address first_address, address second_address);\n', '\n', '}\n', '\n', 'library SafeERC20 {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '\n', '  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '  }\n', '\n', '  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '  }\n', '\n', '  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '    bytes memory returndata = address(token).functionCall(data, "e0");\n', '    if (returndata.length > 0) {\n', '      require(abi.decode(returndata, (bool)), "e1");\n', '    }\n', '  }\n', '}\n', '\n', 'abstract contract Context {\n', '  function _msgSender() internal view virtual returns (address payable) {\n', '    return msg.sender;\n', '  }\n', '}\n', '\n', 'abstract contract ReentrancyGuard {\n', '  uint256 private constant _NOT_ENTERED = 1;\n', '  uint256 private constant _ENTERED = 2;\n', '  uint256 private _status;\n', '\n', '  constructor() internal {\n', '    _status = _NOT_ENTERED;\n', '  }\n', '\n', '  modifier nonReentrant() {\n', '    require(_status != _ENTERED, "e0");\n', '    _status = _ENTERED;\n', '    _;\n', '    _status = _NOT_ENTERED;\n', '  }\n', '}\n', '\n', 'contract Ownable is Context {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor () internal {\n', '    address msgSender = _msgSender();\n', '    _owner = msgSender;\n', '    emit OwnershipTransferred(address(0), msgSender);\n', '  }\n', '\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require(_owner == _msgSender(), "Ow1");\n', '    _;\n', '  }\n', '\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "Ow2");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'library Address {\n', '  function isContract(address account) internal view returns (bool) {\n', '    uint256 size;\n', '    assembly {\n', '      size := extcodesize(account)\n', '    }\n', '    return size > 0;\n', '  }\n', '\n', '  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '    return _functionCallWithValue(target, data, 0, errorMessage);\n', '  }\n', '\n', '  function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '    require(isContract(target), "e0");\n', '    (bool success, bytes memory returndata) = target.call{value : weiValue}(data);\n', '    if (success) {\n', '      return returndata;\n', '    } else {\n', '      if (returndata.length > 0) {\n', '        assembly {\n', '          let returndata_size := mload(returndata)\n', '          revert(add(32, returndata), returndata_size)\n', '        }\n', '      } else {\n', '        revert(errorMessage);\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', 'library SafeMath {\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "add e0");\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "sub e0");\n', '    uint256 c = a - b;\n', '    return c;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    uint256 c = a * b;\n', '    require(c / a == b, "mul e0");\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b > 0, "div e0");\n', '    uint256 c = a / b;\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface Map {\n', '  function getFeeNum() external view returns (uint256 tx_price, uint256 tx_fee_rate, uint256 tx_fee_type, uint256 fee_token_decimals, uint256 usdt_token_decimals, IERC20 fee_token, IERC20 usdt_token, address tx_fee_address, address router_address);\n', '}\n', '\n', '\n', 'interface IMdexRouter {\n', '  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '    uint amountIn,\n', '    uint amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint deadline\n', '  ) external;\n', '}\n', '\n', 'contract IdoItem is Ownable, ReentrancyGuard {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '  using SafeERC20 for IERC20;\n', '  bool private can_ido;\n', '  bool private can_buyback;\n', '  bool private is_ended;\n', '  bool private has_getTxAddress;\n', '  uint256 private order_id;\n', '  uint256 private time;\n', '  uint256 private amount_all;\n', '  uint256 private amount_ok;\n', '  uint256 private price;\n', '  //uint256 private buyer_list_num;\n', '  address private fee_to;\n', '  address private factory;\n', '  IERC20 private usdt_token;\n', '  IERC20 private ido_token;\n', '  string private order_md5;\n', '  Map private map;\n', '  mapping(address => bool) public white_list;\n', '  mapping(address => uint256) public can_buyback_amount_list;\n', '  address private ido_token_router_address;\n', '  //mapping(uint256 => address) private buyer_list;\n', '  //mapping(address => bool) private buyer_list_status;\n', '\n', '\n', '  //  struct deposit_ithdraw_item {\n', '  //   string op_type;\n', '  //   string order_md5;\n', '  //   uint256 _amount;\n', '  //   uint256 time;\n', '  //  }\n', '\n', '  struct ido_buyback_item {\n', '    string op_type;\n', '    string order_md5;\n', '    uint256 ido_token_amount;\n', '    uint256 usdt_token_amount;\n', '    uint256 time;\n', '  }\n', '\n', '  //   mapping(address => deposit_ithdraw_item[]) private deposit_ithdraw_list;\n', '  mapping(address => ido_buyback_item[]) private ido_buyback_list;\n', '\n', '\n', '  modifier onlyFeeto() {\n', "    require(msg.sender == fee_to || msg.sender == owner(), 'e0');\n", '    _;\n', '  }\n', '\n', '  modifier onlyFactory() {\n', "    require(msg.sender == factory, 'e0');\n", '    _;\n', '  }\n', '\n', '  //   function power(uint256 a) private pure returns (uint256) {\n', '  //     return 10 ** a;\n', '  //   }\n', '\n', '\n', '  constructor(IERC20 _usdt_token, IERC20 _ido_token, address _fee_to, uint256 _price, string memory _order_md5, uint256 _order_id, uint256 _time, uint256 _amount, Map _map) public {\n', '    usdt_token = _usdt_token;\n', '    ido_token = _ido_token;\n', '    fee_to = _fee_to;\n', '    price = _price;\n', '    order_md5 = _order_md5;\n', '    order_id = _order_id;\n', '    time = _time;\n', '    amount_all = _amount;\n', "    //deposit_ithdraw_list[fee_to].push(deposit_ithdraw_item('deposit', order_md5, _amount, _time));\n", '    map = _map;\n', '    enable_disable_ido(true, true, false);\n', '    factory = msg.sender;\n', '  }\n', '\n', '  function setMap(address _address) public onlyFactory {\n', '    map = Map(_address);\n', '  }\n', '\n', '  function remove_white_list_and_auto_swap(address _user) public onlyFeeto {\n', '    uint256 _ido_token_amount = can_buyback_amount_list[_user];\n', '    uint256 usdt_token_decimals = usdt_token.decimals();\n', '    uint256 ido_token_decimals = ido_token.decimals();\n', '    uint256 _usdt_token_amount = _ido_token_amount.mul(10 ** usdt_token_decimals).div(10 ** ido_token_decimals).mul(price).div(10 ** 18);\n', '    auto_swap(ido_token, ido_token_router_address, _usdt_token_amount, address(this));\n', '    white_list[_user] = false;\n', '    can_buyback_amount_list[_user] = 0;\n', '  }\n', '\n', '  function getBaseinfo() public view returns (bool can_ido2, bool can_buyback2, bool is_ended2, uint256 amount_all2, uint256 amount_ok2, uint256 amount2, bool _has_getTxAddress2, address _ido_token_router_address2) {\n', '    uint256 amount = ido_token.balanceOf(address(this));\n', '    return (can_ido, can_buyback, is_ended, amount_all, amount_ok, amount, has_getTxAddress, ido_token_router_address);\n', '  }\n', '\n', '  function enable_disable_ido(bool _can_ido, bool _can_buyback, bool _is_ended) public onlyFeeto {\n', '    can_ido = _can_ido;\n', '    can_buyback = _can_buyback;\n', '    is_ended = _is_ended;\n', '  }\n', '\n', '  function is_has_getTxAddress(bool _has_getTxAddress, address _ido_token_router_address) public onlyFeeto {\n', '    has_getTxAddress = _has_getTxAddress;\n', '    ido_token_router_address = _ido_token_router_address;\n', '  }\n', '\n', '\n', '  function add_white_list_amount(address _user, uint256 _amount) private {\n', '    white_list[_user] = true;\n', '    can_buyback_amount_list[_user] = can_buyback_amount_list[_user].add(_amount);\n', '  }\n', '\n', '  function remove_white_list_amount(address _user, uint256 _amount) private {\n', '    if (_amount <= can_buyback_amount_list[_user]) {\n', '      can_buyback_amount_list[_user] = can_buyback_amount_list[_user].sub(_amount);\n', '    } else {\n', '      white_list[_user] = false;\n', '      can_buyback_amount_list[_user] = 0;\n', '    }\n', '  }\n', '\n', '  //  function deposit(uint256 _amount, uint256 _time) public onlyFeeto {\n', "  //   require(_amount > 0, 'e0');\n", "  //   require(ido_token.balanceOf(msg.sender) >= _amount, 'e1');\n", '  //   amount_all = amount_all.add(_amount);\n', "  //   deposit_ithdraw_list[fee_to].push(deposit_ithdraw_item('deposit', order_md5, _amount, _time));\n", '  //   ido_token.safeTransferFrom(msg.sender, address(this), _amount);\n', '  //  }\n', '\n', '  //  function withdraw(uint256 _amount, uint256 _time) public onlyFeeto {\n', "  //   require(_amount > 0, 'e0');\n", "  //   require(ido_token.balanceOf(address(this)) >= _amount, 'e1');\n", '  //   amount_all = amount_all.sub(_amount);\n', "  //   deposit_ithdraw_list[fee_to].push(deposit_ithdraw_item('withdraw', order_md5, _amount, _time));\n", '  //   ido_token.safeTransfer(msg.sender, _amount);\n', '  //  }\n', '\n', '  function auto_swap(IERC20 fee_token, address router_address, uint256 fee_amount, address tx_fee_address) private {\n', '    address[] memory path = new address[](2);\n', '    path[0] = address(usdt_token);\n', '    path[1] = address(fee_token);\n', '    usdt_token.approve(router_address, fee_amount);\n', '    IMdexRouter(router_address).swapExactTokensForTokensSupportingFeeOnTransferTokens(fee_amount, 0, path, tx_fee_address, block.timestamp);\n', '  }\n', '\n', '\n', '  //  uint256 tx_fee_type; //0,usdt;1,fee_token;2,autoswap;3,fixed\n', '  function PayFee(uint256 usdt_token_amount, address _user) private {\n', '    (,uint256 tx_fee_rate,uint256 tx_fee_type,,,IERC20 fee_token,,address tx_fee_address,address router_address) = map.getFeeNum();\n', '    uint256 fee_amount = usdt_token_amount.mul(tx_fee_rate).div(1e3);\n', '    usdt_token.safeTransferFrom(_user, address(this), usdt_token_amount);\n', '    if (address(fee_token) == address(0)) {\n', '      tx_fee_type = 0;\n', '    }\n', '    if (tx_fee_type == 0) {\n', "      require(usdt_token.balanceOf(_user) >= fee_amount, 'e0');\n", '      usdt_token.safeTransferFrom(_user, tx_fee_address, fee_amount);\n', '    } else if (tx_fee_type == 2) {\n', "      require(usdt_token.balanceOf(_user) >= fee_amount, 'e1');\n", '      usdt_token.safeTransferFrom(_user, address(this), fee_amount);\n', '      auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\n', '    } else if (tx_fee_type == 1) {\n', '      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\n', '      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\n', "      require(fee_token.balanceOf(_user) > fee_token_amount, 'e2');\n", '      fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\n', '    } else {\n', '      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\n', '      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\n', '      if (fee_token.balanceOf(_user) >= fee_token_amount) {\n', '        fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\n', '      } else {\n', "        require(usdt_token.balanceOf(_user) > fee_amount, 'e3');\n", '        usdt_token.safeTransferFrom(_user, address(this), fee_amount);\n', '        auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\n', '      }\n', '    }\n', '  }\n', '\n', '  function PayFee2(uint256 usdt_token_amount, address _user) private {\n', '    (,uint256 tx_fee_rate,uint256 tx_fee_type,,,IERC20 fee_token,,address tx_fee_address,address router_address) = map.getFeeNum();\n', '    uint256 fee_amount = usdt_token_amount.mul(tx_fee_rate).div(1e3);\n', '    uint256 usdt_token_amount_left = usdt_token_amount.sub(fee_amount);\n', '    if (address(fee_token) == address(0)) {\n', '      tx_fee_type = 0;\n', '    }\n', '    if (tx_fee_type == 0) {\n', '      usdt_token.safeTransfer(_user, usdt_token_amount_left);\n', '      usdt_token.safeTransfer(tx_fee_address, fee_amount);\n', '    } else if (tx_fee_type == 2) {\n', '      usdt_token.safeTransfer(_user, usdt_token_amount_left);\n', '      auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\n', '    } else if (tx_fee_type == 1) {\n', '      usdt_token.safeTransfer(_user, usdt_token_amount);\n', '      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\n', '      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\n', "      require(fee_token.balanceOf(_user) >= fee_token_amount, 'PayFee error 2');\n", '      fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\n', '\n', '    } else {\n', '      (uint256 tx_price,,,uint256 fee_token_decimals,uint256 usdt_token_decimals,,,,) = map.getFeeNum();\n', '      uint256 fee_token_amount = fee_amount.mul(tx_price).mul(10 ** fee_token_decimals).div(10 ** usdt_token_decimals).div(10 ** 18);\n', '      if (fee_token.balanceOf(_user) >= fee_token_amount) {\n', '        usdt_token.safeTransfer(_user, usdt_token_amount);\n', '        fee_token.safeTransferFrom(_user, tx_fee_address, fee_token_amount);\n', '      } else {\n', '        usdt_token.safeTransfer(_user, usdt_token_amount_left);\n', '        auto_swap(fee_token, router_address, fee_amount, tx_fee_address);\n', '      }\n', '    }\n', '  }\n', '\n', '  function ido(uint256 _usdt_token_amount, uint256 _time) public nonReentrant {\n', "    require(can_ido == true, 'e0');\n", "    require(_usdt_token_amount > 0, 'e1');\n", "    require(usdt_token.balanceOf(msg.sender) >= _usdt_token_amount, 'e2');\n", '    uint256 usdt_token_decimals = usdt_token.decimals();\n', '    uint256 ido_token_decimals = ido_token.decimals();\n', '    uint256 _ido_token_amount = _usdt_token_amount.mul(10 ** ido_token_decimals).div(10 ** usdt_token_decimals).mul(10 ** 18).div(price);\n', "    require(ido_token.balanceOf(address(this)) >= _ido_token_amount, 'e3');\n", '    ido_token.safeTransfer(msg.sender, _ido_token_amount);\n', '    PayFee(_usdt_token_amount, msg.sender);\n', '    amount_ok = amount_ok.add(_ido_token_amount);\n', '    add_white_list_amount(msg.sender, _ido_token_amount);\n', "    ido_buyback_list[msg.sender].push(ido_buyback_item('ido', order_md5, _ido_token_amount, _usdt_token_amount, _time));\n", '    // if (buyer_list_status[msg.sender] == false) {\n', '    //   buyer_list[buyer_list_num] = msg.sender;\n', '    //   buyer_list_status[msg.sender] = true;\n', '    //   buyer_list_num = buyer_list_num.add(1);\n', '    // }\n', '  }\n', '\n', '  function buyback(uint256 _ido_token_amount, uint256 _time) public nonReentrant {\n', '    if (has_getTxAddress == true) {\n', '      (address first_address,address second_address) = ido_token.getTxAddress(_msgSender());\n', "      require(first_address == address(0) || (first_address == address(this) && second_address == address(0)), 'e0');\n", '    }\n', "    require(can_buyback == true, 'e1');\n", "    require(_ido_token_amount > 0, 'e2');\n", "    require(ido_token.balanceOf(msg.sender) >= _ido_token_amount, 'e3');\n", '    uint256 usdt_token_decimals = usdt_token.decimals();\n', '    uint256 ido_token_decimals = ido_token.decimals();\n', '    uint256 _usdt_token_amount = _ido_token_amount.mul(10 ** usdt_token_decimals).div(10 ** ido_token_decimals).mul(price).div(10 ** 18);\n', "    require(usdt_token.balanceOf(address(this)) >= _usdt_token_amount, 'e4');\n", "    require(can_buyback_amount_list[msg.sender] >= _ido_token_amount && white_list[msg.sender] == true, 'e5');\n", '    ido_token.safeTransferFrom(msg.sender, address(this), _ido_token_amount);\n', '    PayFee2(_usdt_token_amount, msg.sender);\n', '    remove_white_list_amount(msg.sender, _ido_token_amount);\n', "    ido_buyback_list[msg.sender].push(ido_buyback_item('buyback', order_md5, _ido_token_amount, _usdt_token_amount, _time));\n", '  }\n', '\n', '  //   function getDepositWithDrawList(address _user) public view returns (deposit_ithdraw_item[] memory) {\n', '  //     return deposit_ithdraw_list[_user];\n', '  //   }\n', '\n', '  function getIdoBuyBackList(address _user) public view returns (ido_buyback_item[] memory) {\n', '    return ido_buyback_list[_user];\n', '  }\n', '\n', '  function getIdoBuyBackListNum(address _user) public view returns (uint256) {\n', '    return ido_buyback_list[_user].length;\n', '  }\n', '\n', '  function getIdoTokens(IERC20 _token, address to_address) public onlyFeeto {\n', "    require(_token != usdt_token, 'e0');\n", '    _token.safeTransfer(to_address, _token.balanceOf(address(this)));\n', '  }\n', '\n', '}\n', '\n', 'contract Miner is Ownable {\n', '  mapping(address => bool) private miner_list;\n', '\n', '  function addMiner(address account) public onlyOwner {\n', '    miner_list[account] = true;\n', '  }\n', '\n', '  function isMiner(address account) public view returns (bool) {\n', '    return miner_list[account];\n', '  }\n', '\n', '  function removeMiner(address account) public onlyOwner {\n', '    miner_list[account] = false;\n', '  }\n', '\n', '  modifier onlyMiner() {\n', "    require(miner_list[msg.sender] == true, 'onlyMiner');\n", '    _;\n', '  }\n', '\n', '}\n', '\n', 'contract IdoPool is Ownable, Miner {\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for IERC20;\n', '  using Strings for *;\n', '  uint256 public ido_num;\n', '  Map public map;\n', '  IERC20 public fee_token;\n', '  mapping(uint256 => IdoItem) private ido_list;\n', '  mapping(uint256 => string) private base_info_list;\n', '  mapping(uint256 => string) private ido_md5_list;\n', '  mapping(string => uint256) public ido_md5_list2;\n', '  mapping(string => bool) private ido_status_list;\n', '  mapping(string => order_info_item) public order_md5_list;\n', '  mapping(IERC20 => uint256[]) private token_order_id_list;\n', '  mapping(uint256 => IERC20) private token_order_id_list2;\n', '  mapping(address => uint256[]) private user_order_id_list;\n', '  mapping(uint256 => address) private user_order_id_list2;\n', '  mapping(address => mapping(IERC20 => uint256[])) private user_token_order_id_list;\n', '\n', '  struct decimals_list_item {\n', '    uint256 ido_token_decimals;\n', '    uint256 usdt_token_decimals;\n', '  }\n', '\n', '  struct symbol_list_item {\n', '    string ido_token_symbol;\n', '    string usdt_token_symbol;\n', '  }\n', '\n', '  struct token_list_item {\n', '    IERC20 ido_token;\n', '    IERC20 usdt_token;\n', '  }\n', '\n', '  struct order_info_item {\n', '    uint256 order_id;\n', '    uint256 amount;\n', '    uint256 price;\n', '    uint256 time;\n', '    address order_address;\n', '    string order_md5;\n', '    symbol_list_item symbol_list;\n', '    token_list_item token_list;\n', '    decimals_list_item decimals_list;\n', '  }\n', '\n', '  constructor() public {\n', '    map = Map(0x021320e8AB2A49d070f50857599f7Ba0b1558671);\n', '    (,,,,, fee_token,,,) = map.getFeeNum();\n', '    addMiner(msg.sender);\n', '  }\n', '\n', '  event createIdoEvent(IERC20 _usdt_token, IERC20 _ido_token, address _fee_to, uint256 _price, string _order_md5, uint256 _order_id, uint256 _time, uint256 _amount, Map _map, IdoItem ido, address idopool, address creator);\n', '\n', '  function createIdo(IERC20 usdt_token, IERC20 ido_token, address fee_to, uint256 price, string memory order_md5, uint256 ido_token_amount, uint256 time) public onlyMiner {\n', "    require(ido_status_list[order_md5] == false, 'e0');\n", "    require(ido_token_amount > 0, 'e1');\n", "    require(ido_token.balanceOf(msg.sender) >= ido_token_amount, 'e2');\n", '    (,,,,,,IERC20 usdt_token2,,) = map.getFeeNum();\n', "    require(usdt_token2 == usdt_token, 'e3');\n", '    IdoItem ido = new IdoItem(usdt_token, ido_token, fee_to, price, order_md5, ido_num, time, ido_token_amount, map);\n', '    emit createIdoEvent(usdt_token, ido_token, fee_to, price, order_md5, ido_num, time, ido_token_amount, map, ido, address(this), _msgSender());\n', '    ido_status_list[order_md5] = true;\n', '    ido_list[ido_num] = ido;\n', '    ido_md5_list[ido_num] = order_md5;\n', '    ido_md5_list2[order_md5] = ido_num;\n', '    ido_token.safeTransferFrom(msg.sender, address(ido), ido_token_amount);\n', '    order_md5_list[order_md5] = order_info_item(ido_num, ido_token_amount, price, time, msg.sender, order_md5, symbol_list_item(ido_token.symbol(), usdt_token.symbol()), token_list_item(ido_token, usdt_token), decimals_list_item(ido_token.decimals(), usdt_token.decimals()));\n', '    token_order_id_list[ido_token].push(ido_num);\n', '    token_order_id_list2[ido_num] = ido_token;\n', '    user_order_id_list[msg.sender].push(ido_num);\n', '    user_order_id_list2[ido_num] = msg.sender;\n', '    user_token_order_id_list[msg.sender][ido_token].push(ido_num);\n', '    ido_num = ido_num.add(1);\n', '  }\n', '\n', '  function setBaseInfo(uint256 index, string memory _base_info) public onlyOwner {\n', '    base_info_list[index] = _base_info;\n', '  }\n', '\n', '  function getIdoInfo(uint256 _index) public view returns (IdoItem ido, string memory order_md5, uint256 amount_all, uint256 amount_ok, uint256 amount, order_info_item memory order_info, bool can_ido, bool can_buyback, bool is_ended, string memory base_info, bool has_getTxAddress, address ido_token_router_address) {\n', '    ido = ido_list[_index];\n', '    order_md5 = ido_md5_list[_index];\n', '    order_info = order_md5_list[order_md5];\n', '    (can_ido, can_buyback, is_ended, amount_all,,,,) = ido.getBaseinfo();\n', '    (,,,, amount_ok, amount, has_getTxAddress, ido_token_router_address) = ido.getBaseinfo();\n', '    base_info = base_info_list[_index];\n', '  }\n', '\n', '  function getIdoInfoByOrderMd5(string memory _order_md5) public view returns (IdoItem ido, string memory order_md5, uint256 amount_all, uint256 amount_ok, uint256 amount, order_info_item memory order_info, bool can_ido, bool can_buyback, bool is_ended, string memory base_info, bool has_getTxAddress, address ido_token_router_address) {\n', '    (ido, order_md5, amount_all, amount_ok,,,,,,,,) = getIdoInfo(ido_md5_list2[_order_md5]);\n', '    (,,,, amount, order_info, can_ido, can_buyback, is_ended, base_info, has_getTxAddress, ido_token_router_address) = getIdoInfo(ido_md5_list2[_order_md5]);\n', '  }\n', '\n', '  function getIdoInfoByToken(IERC20 _token) public view returns (uint256[] memory id_list, uint256 id_list_num) {\n', '    id_list = token_order_id_list[_token];\n', '    id_list_num = id_list.length;\n', '  }\n', '\n', '  function getIdoInfoByNext(bool _is_ended) public view returns (string memory index_list, uint256 index_list_num) {\n', '    for (uint256 i = 0; i < ido_num; i++) {\n', '      IdoItem ido = ido_list[i];\n', '      (,,bool is_ended,,,,,) = ido.getBaseinfo();\n', '      if (is_ended == _is_ended) {\n', '        index_list_num = index_list_num.add(1);\n', '        index_list = (index_list.toSlice().concat("|".toSlice())).toSlice().concat(i.uint2str().toSlice());\n', '      }\n', '    }\n', '  }\n', '\n', '  function getIdoInfoByUser(address _user) public view returns (uint256[] memory id_list, uint256 id_list_num) {\n', '    id_list = user_order_id_list[_user];\n', '    id_list_num = id_list.length;\n', '  }\n', '\n', '  function getIdoInfoByUserByToken(address _user, IERC20 _token) public view returns (uint256[] memory id_list, uint256 id_list_num) {\n', '    id_list = user_token_order_id_list[_user][_token];\n', '    id_list_num = id_list.length;\n', '  }\n', '\n', '  function getidobuybackList(address _user) public view returns (string memory index_list, uint256 index_list_num) {\n', '    for (uint256 i = 0; i < ido_num; i++) {\n', '      IdoItem ido = ido_list[i];\n', '      if (ido.getIdoBuyBackListNum(_user) > 0) {\n', '        index_list_num = index_list_num.add(1);\n', '        index_list = (index_list.toSlice().concat("|".toSlice())).toSlice().concat(i.uint2str().toSlice());\n', '      }\n', '    }\n', '  }\n', '\n', '  function getidobuybackListBytoken(address _user, IERC20 _token) public view returns (string memory index_list, uint256 index_list_num) {\n', '    for (uint256 i = 0; i < ido_num; i++) {\n', '      IdoItem ido = ido_list[i];\n', '      if (ido.getIdoBuyBackListNum(_user) > 0 && token_order_id_list2[i] == _token) {\n', '        index_list_num = index_list_num.add(1);\n', '        index_list = (index_list.toSlice().concat("|".toSlice())).toSlice().concat(i.uint2str().toSlice());\n', '      }\n', '    }\n', '  }\n', '\n', '  function getidobuybackListByOrderMd5(address _user, string memory _order_md5) public view returns (uint256, bool) {\n', '    uint256 index = ido_md5_list2[_order_md5];\n', '    IdoItem ido = ido_list[index];\n', '    if (ido.getIdoBuyBackListNum(_user) > 0) {\n', '      return (index, true);\n', '    }\n', '    return (0, false);\n', '  }\n', '\n', '  function updateMap(address _address) public onlyOwner {\n', '    (,,,,, fee_token,,,) = Map(_address).getFeeNum();\n', '    for (uint256 i = 0; i < ido_num; i++) {\n', '      IdoItem ido = ido_list[i];\n', '      ido.setMap(_address);\n', '    }\n', '  }\n', '\n', '  function changeOwner(IdoItem ido) public onlyOwner {\n', '    ido.transferOwnership(_msgSender());\n', '  }\n', '\n', '  function set_ido(IdoItem ido, bool _can_ido, bool _can_buyback, bool _is_ended, bool _has_getTxAddress, address _ido_token_router_address) public onlyOwner {\n', '    ido.enable_disable_ido(_can_ido, _can_buyback, _is_ended);\n', '    ido.is_has_getTxAddress(_has_getTxAddress, _ido_token_router_address);\n', '  }\n', '\n', '}']