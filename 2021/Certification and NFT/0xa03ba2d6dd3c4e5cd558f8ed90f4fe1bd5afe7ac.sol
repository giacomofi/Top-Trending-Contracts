['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-07\n', '*/\n', '\n', '/**\n', 'Deployed by DeepSea\n', '*/\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', 'contract Initializable {\n', '    bool private initialized;\n', '    bool private initializing;\n', '    modifier initializer() {\n', '        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            initialized = true;\n', '        }\n', '        _;\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    function isConstructor() private view returns (bool) {\n', '\n', '        address self = address(this);\n', '        uint256 cs;\n', '        assembly {cs := extcodesize(self)}\n', '        return cs == 0;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', 'contract Context is Initializable {\n', '    constructor () internal {}\n', '\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Ownable is Initializable, Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function initialize(address sender) public initializer {\n', '        _owner = sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', 'contract Proxy {\n', '\n', '    function() payable external {\n', '        _fallback();\n', '    }\n', '\n', '    function _implementation() internal view returns (address);\n', '\n', '    function _delegate(address implementation) internal {\n', '        assembly {\n', '            calldatacopy(0, 0, calldatasize)\n', '            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '            returndatacopy(0, 0, returndatasize)\n', '            switch result\n', '            case 0 {revert(0, returndatasize)}\n', '            default {return (0, returndatasize)}\n', '        }\n', '    }\n', '\n', '    function _willFallback() internal {\n', '    }\n', '\n', '    function _fallback() internal {\n', '        _willFallback();\n', '        _delegate(_implementation());\n', '    }\n', '}\n', '\n', 'library OpenZeppelinUpgradesAddress {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly {size := extcodesize(account)}\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'contract BaseUpgradeabilityProxy is Proxy {\n', '    event Upgraded(address indexed implementation);\n', '\n', '    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    function _implementation() internal view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '\n', '\n', '    function _upgradeTo(address newImplementation) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '\n', '    function _setImplementation(address newImplementation) internal {\n', '        require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '        assembly {\n', '            sstore(slot, newImplementation)\n', '        }\n', '    }\n', '}\n', '\n', 'contract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '\n', '    constructor(address _logic, bytes memory _data) public payable {\n', "        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n", '        _setImplementation(_logic);\n', '        if (_data.length > 0) {\n', '            (bool success,) = _logic.delegatecall(_data);\n', '            require(success);\n', '        }\n', '    }\n', '}\n', '\n', 'contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n', '\n', '    modifier ifAdmin() {\n', '        if (msg.sender == _admin()) {\n', '            _;\n', '        } else {\n', '            _fallback();\n', '        }\n', '    }\n', '\n', '    function admin() external ifAdmin returns (address) {\n', '        return _admin();\n', '    }\n', '\n', '    function implementation() external ifAdmin returns (address) {\n', '        return _implementation();\n', '    }\n', '\n', '    function changeAdmin(address newAdmin) external ifAdmin {\n', '        require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");\n', '        emit AdminChanged(_admin(), newAdmin);\n', '        _setAdmin(newAdmin);\n', '    }\n', '\n', '    function upgradeTo(address newImplementation) external ifAdmin {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '    function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n', '        _upgradeTo(newImplementation);\n', '        (bool success,) = newImplementation.delegatecall(data);\n', '        require(success);\n', '    }\n', '\n', '    function _admin() internal view returns (address adm) {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            adm := sload(slot)\n', '        }\n', '    }\n', '\n', '    function _setAdmin(address newAdmin) internal {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        assembly {\n', '            sstore(slot, newAdmin)\n', '        }\n', '    }\n', '\n', '    function _willFallback() internal {\n', '        require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");\n', '        super._willFallback();\n', '    }\n', '}\n', '\n', 'contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '\n', '    function initialize(address _logic, bytes memory _data) public payable {\n', '        require(_implementation() == address(0));\n', "        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n", '        _setImplementation(_logic);\n', '        if (_data.length > 0) {\n', '            (bool success,) = _logic.delegatecall(_data);\n', '            require(success);\n', '        }\n', '    }\n', '}\n', '\n', 'contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n', '\n', '    function initialize(address _logic, address _admin, bytes memory _data) public payable {\n', '        require(_implementation() == address(0));\n', '        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n', "        assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n", '        _setAdmin(_admin);\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract ERC20Staked is Initializable, Context, IERC20 {\n', '\n', '    event LogClaimReward(address account, uint256 amount);\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 public minimumStakeBalance;\n', '\n', '    struct stakeHolder {\n', '        uint index;\n', '        uint256 reward;\n', '        bool status;\n', '    }\n', '\n', '    mapping(address => uint256) private _balances;\n', '\n', '    mapping(address => stakeHolder) public _stakeHolderMap;\n', '    address[] internal _stakeHolders;\n', '\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    uint256 private _totalPendingReward;\n', '\n', '    function initialize(uint256 _minimumStakeBalance) public initializer {\n', '        minimumStakeBalance = _minimumStakeBalance;\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    // staking function, remain reward is not claimed\n', '    function totalPendingReward() public view returns (uint256) {\n', '        return _totalPendingReward;\n', '    }\n', '\n', '    /**\n', '     * @notice A method to add a stakeholder.\n', '     * @param account The account to add.\n', '     */\n', '    function _addStakeholder(address account) private {\n', '        // if user exists, add _val\n', '        if (!_stakeHolderMap[account].status) {\n', '            // else its new user\n', '            _stakeHolders.push(account);\n', '            _stakeHolderMap[account].status = true;\n', '            _stakeHolderMap[account].index = _stakeHolders.length - 1;\n', '        }\n', '    }\n', '    /**\n', '     * @notice A method to remove a stakeholder.\n', '     * @param account The stakeholder to remove.\n', '     */\n', '    function _removeStakeholder(address account) private {\n', '        if (_stakeHolderMap[account].status) {\n', '            stakeHolder memory deletedHolder = _stakeHolderMap[account];\n', '            if (deletedHolder.index != _stakeHolders.length - 1) {\n', '                address lastAddress = _stakeHolders[_stakeHolders.length - 1];\n', '                _stakeHolders[deletedHolder.index] = lastAddress; // swap the last address to removed address\n', '                _stakeHolderMap[lastAddress].index = deletedHolder.index; // update index for the previous last one\n', '            }\n', '            _stakeHolderMap[account].status = false;\n', '            _stakeHolders.length--;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice A method to remove a stakeholder.\n', '     * @param account The account need to check.\n', '     */\n', '    function _checkStake(address account) private {\n', '        if (_balances[account] > minimumStakeBalance) {\n', '            _addStakeholder(account);\n', '        } else {\n', '            _removeStakeholder(account);\n', '        }\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    // staking function\n', '    function rewardOf(address account) public view returns (uint256) {\n', '        return _stakeHolderMap[account].reward;\n', '    }\n', '\n', '    // staking function\n', '    function isStaking(address account) public view returns (bool) {\n', '        return _stakeHolderMap[account].status;\n', '    }\n', '\n', '    // staking function\n', '    function getStakeIndex(address account) public view returns (uint) {\n', '        return _stakeHolderMap[account].index;\n', '    }\n', '\n', '    // staking function\n', '    function totalStakeHolders() public view returns (uint) {\n', '        return _stakeHolders.length;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    function _updateMinimumStakeBalance(uint256 _nextMinimumStakeBalance) internal {\n', '        minimumStakeBalance = _nextMinimumStakeBalance;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        _checkStake(sender);\n', '        // stake checking\n', '        _checkStake(recipient);\n', '        // stake checking\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        _checkStake(account);\n', '        // stake checking\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _checkStake(account);\n', '        // stake checking\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '    // staking function, add stake amount and split to all holders base on totalSupply\n', '    function _splitStakeReward(uint256 amount) internal {\n', '        _totalPendingReward = _totalPendingReward.add(amount);\n', '        for (uint256 s = 0; s < _stakeHolders.length; s += 1) {\n', '            address account = _stakeHolders[s];\n', '            uint256 reward = amount.mul(_balances[account]).div(_totalSupply);\n', '            _stakeHolderMap[account].reward = _stakeHolderMap[account].reward.add(reward);\n', '        }\n', '    }\n', '\n', '    function _claimStakeReward(address account) internal {\n', '        uint256 reward = _stakeHolderMap[account].reward;\n', '        _mint(account, reward);\n', '        _totalPendingReward = _totalPendingReward.sub(reward);\n', '        _stakeHolderMap[account].reward = 0;\n', '        emit LogClaimReward(account, reward);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', 'contract ERC20Detailed is Initializable, IERC20 {\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = decimals;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    uint256[50] private ______gap;\n', '}\n', '\n', 'contract Claimable is Initializable, Ownable {\n', '    address public pendingOwner;\n', '\n', '    function initialize(address _nextOwner) public initializer {\n', '        Ownable.initialize(_nextOwner);\n', '    }\n', '\n', '    modifier onlyPendingOwner() {\n', '        require(\n', '            _msgSender() == pendingOwner,\n', '            "Claimable: caller is not the pending owner"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(\n', '            newOwner != owner() && newOwner != pendingOwner,\n', '            "Claimable: invalid new owner"\n', '        );\n', '        pendingOwner = newOwner;\n', '    }\n', '\n', '    function claimOwnership() public onlyPendingOwner {\n', '        _transferOwnership(pendingOwner);\n', '        delete pendingOwner;\n', '    }\n', '}\n', '\n', 'library Address {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly {codehash := extcodehash(account)}\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '        (bool success,) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract CanReclaimTokens is Claimable {\n', '    using SafeERC20 for ERC20Staked;\n', '    mapping(address => bool) private recoverableTokensBlacklist;\n', '\n', '    function initialize(address _nextOwner) public initializer {\n', '        Claimable.initialize(_nextOwner);\n', '    }\n', '\n', '    function blacklistRecoverableToken(address _token) public onlyOwner {\n', '        recoverableTokensBlacklist[_token] = true;\n', '    }\n', '\n', '    function recoverTokens(address _token) external onlyOwner {\n', '        require(\n', '            !recoverableTokensBlacklist[_token],\n', '            "CanReclaimTokens: token is not recoverable"\n', '        );\n', '\n', '        if (_token == address(0x0)) {\n', '            msg.sender.transfer(address(this).balance);\n', '        } else {\n', '            ERC20Staked(_token).safeTransfer(\n', '                msg.sender,\n', '                ERC20Staked(_token).balanceOf(address(this))\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', 'contract ERC20WithPermit is Initializable, ERC20Staked, ERC20Detailed {\n', '    using SafeMath for uint256;\n', '    mapping(address => uint256) public nonces;\n', '    string public version;\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '    bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\n', '\n', '    function initialize(\n', '        uint256 _chainId,\n', '        string memory _version,\n', '        string memory _name,\n', '        string memory _symbol,\n', '        uint8 _decimals\n', '    ) internal initializer {\n', '        ERC20Detailed.initialize(_name, _symbol, _decimals);\n', '        version = _version;\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256(\n', '                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '                ),\n', '                keccak256(bytes(name())),\n', '                keccak256(bytes(version)),\n', '                _chainId,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    function permit(\n', '        address holder,\n', '        address spender,\n', '        uint256 nonce,\n', '        uint256 expiry,\n', '        bool allowed,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external {\n', '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                keccak256(\n', '                    abi.encode(\n', '                        PERMIT_TYPEHASH,\n', '                        holder,\n', '                        spender,\n', '                        nonce,\n', '                        expiry,\n', '                        allowed\n', '                    )\n', '                )\n', '            )\n', '        );\n', '\n', '        require(holder != address(0), "ERC20WithRate: address must not be 0x0");\n', '        require(\n', '            holder == ecrecover(digest, v, r, s),\n', '            "ERC20WithRate: invalid signature"\n', '        );\n', '        require(\n', '            expiry == 0 || now <= expiry,\n', '            "ERC20WithRate: permit has expired"\n', '        );\n', '        require(nonce == nonces[holder]++, "ERC20WithRate: invalid nonce");\n', '        uint256 amount = allowed ? uint256(- 1) : 0;\n', '        _approve(holder, spender, amount);\n', '    }\n', '}\n', '\n', '\n', 'contract TornomyERC20Staked is\n', 'Initializable,\n', 'ERC20Staked,\n', 'ERC20Detailed,\n', 'Ownable,\n', 'ERC20WithPermit,\n', 'Claimable,\n', 'CanReclaimTokens\n', '{\n', '    using SafeMath for uint256;\n', '\n', '    function initialize(\n', '        uint256 _chainId,\n', '        address _nextOwner,\n', '        string memory _version,\n', '        string memory _name,\n', '        string memory _symbol,\n', '        uint256 _minimumStakeBalance,\n', '        uint8 _decimals\n', '    ) public initializer {\n', '        ERC20Staked.initialize(_minimumStakeBalance);\n', '        ERC20Detailed.initialize(_name, _symbol, _decimals);\n', '        Ownable.initialize(_nextOwner);\n', '        ERC20WithPermit.initialize(\n', '            _chainId,\n', '            _version,\n', '            _name,\n', '            _symbol,\n', '            _decimals\n', '        );\n', '        Claimable.initialize(_nextOwner);\n', '        CanReclaimTokens.initialize(_nextOwner);\n', '    }\n', '\n', '    function mint(address _to, uint256 _amount) public onlyOwner {\n', '        _mint(_to, _amount);\n', '    }\n', '\n', '    function burn(address _from, uint256 _amount) public onlyOwner {\n', '        _burn(_from, _amount);\n', '    }\n', '\n', '    function splitStakeReward(uint256 _amount) public onlyOwner {\n', '        _splitStakeReward(_amount);\n', '    }\n', '\n', '    function updateMinimumStakeBalance(uint256 _nextMinimumStakeBalance) public onlyOwner {\n', '        _updateMinimumStakeBalance(_nextMinimumStakeBalance);\n', '    }\n', '\n', '    function claimStakeReward() public {\n', '        _claimStakeReward(msg.sender);\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        require(\n', '            recipient != address(this),\n', '            "TORNOMY ERC20: can\'t transfer to token address"\n', '        );\n', '        return super.transfer(recipient, amount);\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool)\n', '    {\n', '        require(\n', '            recipient != address(this),\n', '            "TORNOMY ERC20: can\'t transfer to stoken address"\n', '        );\n', '        return super.transferFrom(sender, recipient, amount);\n', '    }\n', '}']