['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', '/// GlobalSettlement.sol\n', '\n', '// Copyright (C) 2018 Rain <[email\xa0protected]>\n', '// Copyright (C) 2018 Lev Livnev <[email\xa0protected]>\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'abstract contract SAFEEngineLike {\n', '    function coinBalance(address) virtual public view returns (uint256);\n', '    function collateralTypes(bytes32) virtual public view returns (\n', '        uint256 debtAmount,        // [wad]\n', '        uint256 accumulatedRate,   // [ray]\n', '        uint256 safetyPrice,       // [ray]\n', '        uint256 debtCeiling,       // [rad]\n', '        uint256 debtFloor,         // [rad]\n', '        uint256 liquidationPrice   // [ray]\n', '    );\n', '    function safes(bytes32,address) virtual public view returns (\n', '        uint256 lockedCollateral, // [wad]\n', '        uint256 generatedDebt     // [wad]\n', '    );\n', '    function globalDebt() virtual public returns (uint256);\n', '    function transferInternalCoins(address src, address dst, uint256 rad) virtual external;\n', '    function approveSAFEModification(address) virtual external;\n', '    function transferCollateral(bytes32 collateralType, address src, address dst, uint256 wad) virtual external;\n', '    function confiscateSAFECollateralAndDebt(bytes32 collateralType, address safe, address collateralSource, address debtDestination, int256 deltaCollateral, int256 deltaDebt) virtual external;\n', '    function createUnbackedDebt(address debtDestination, address coinDestination, uint256 rad) virtual external;\n', '    function disableContract() virtual external;\n', '}\n', 'abstract contract LiquidationEngineLike {\n', '    function collateralTypes(bytes32) virtual public view returns (\n', '        address collateralAuctionHouse,\n', '        uint256 liquidationPenalty,     // [wad]\n', '        uint256 liquidationQuantity     // [rad]\n', '    );\n', '    function disableContract() virtual external;\n', '}\n', 'abstract contract StabilityFeeTreasuryLike {\n', '    function disableContract() virtual external;\n', '}\n', 'abstract contract AccountingEngineLike {\n', '    function disableContract() virtual external;\n', '}\n', 'abstract contract CoinSavingsAccountLike {\n', '    function disableContract() virtual external;\n', '}\n', 'abstract contract CollateralAuctionHouseLike {\n', '    function bidAmount(uint256 id) virtual public view returns (uint256);\n', '    function raisedAmount(uint256 id) virtual public view returns (uint256);\n', '    function remainingAmountToSell(uint256 id) virtual public view returns (uint256);\n', '    function forgoneCollateralReceiver(uint256 id) virtual public view returns (address);\n', '    function amountToRaise(uint256 id) virtual public view returns (uint256);\n', '    function terminateAuctionPrematurely(uint256 auctionId) virtual external;\n', '}\n', 'abstract contract OracleLike {\n', '    function read() virtual public view returns (uint256);\n', '}\n', 'abstract contract OracleRelayerLike {\n', '    function redemptionPrice() virtual public returns (uint256);\n', '    function collateralTypes(bytes32) virtual public view returns (\n', '        OracleLike orcl,\n', '        uint256 safetyCRatio,\n', '        uint256 liquidationCRatio\n', '    );\n', '    function disableContract() virtual external;\n', '}\n', '\n', '/*\n', '    This is the Global Settlement module. It is an\n', '    involved, stateful process that takes place over nine steps.\n', '    First we freeze the system and lock the prices for each collateral type.\n', '    1. `shutdownSystem()`:\n', '        - freezes user entrypoints\n', '        - starts cooldown period\n', '    2. `freezeCollateralType(collateralType)`:\n', '       - set the final price for each collateralType, reading off the price feed\n', '    We must process some system state before it is possible to calculate\n', '    the final coin / collateral price. In particular, we need to determine:\n', '      a. `collateralShortfall` (considers under-collateralised SAFEs)\n', '      b. `outstandingCoinSupply` (after including system surplus / deficit)\n', '    We determine (a) by processing all under-collateralised SAFEs with\n', '    `processSAFE`\n', '    3. `processSAFE(collateralType, safe)`:\n', '       - cancels SAFE debt\n', '       - any excess collateral remains\n', '       - backing collateral taken\n', '    We determine (b) by processing ongoing coin generating processes,\n', '    i.e. auctions. We need to ensure that auctions will not generate any\n', '    further coin income. In the two-way auction model this occurs when\n', '    all auctions are in the reverse (`decreaseSoldAmount`) phase. There are two ways\n', '    of ensuring this:\n', '    4.  i) `shutdownCooldown`: set the cooldown period to be at least as long as the\n', '           longest auction duration, which needs to be determined by the\n', '           shutdown administrator.\n', '           This takes a fairly predictable time to occur but with altered\n', '           auction dynamics due to the now varying price of the system coin.\n', '       ii) `fastTrackAuction`: cancel all ongoing auctions and seize the collateral.\n', '           This allows for faster processing at the expense of more\n', '           processing calls. This option allows coin holders to retrieve\n', '           their collateral faster.\n', '           `fastTrackAuction(collateralType, auctionId)`:\n', '            - cancel individual collateral auctions in the `increaseBidSize` (forward) phase\n', '            - retrieves collateral and returns coins to bidder\n', '            - `decreaseSoldAmount` (reverse) phase auctions can continue normally\n', '    Option (i), `shutdownCooldown`, is sufficient for processing the system\n', '    settlement but option (ii), `fastTrackAuction`, will speed it up. Both options\n', '    are available in this implementation, with `fastTrackAuction` being enabled on a\n', '    per-auction basis.\n', '    When a SAFE has been processed and has no debt remaining, the\n', '    remaining collateral can be removed.\n', '    5. `freeCollateral(collateralType)`:\n', "        - remove collateral from the caller's SAFE\n", '        - owner can call as needed\n', '    After the processing period has elapsed, we enable calculation of\n', '    the final price for each collateral type.\n', '    6. `setOutstandingCoinSupply()`:\n', '       - only callable after processing time period elapsed\n', '       - assumption that all under-collateralised SAFEs are processed\n', '       - fixes the total outstanding supply of coin\n', '       - may also require extra SAFE processing to cover system surplus\n', '    7. `calculateCashPrice(collateralType)`:\n', '        - calculate `collateralCashPrice`\n', '        - adjusts `collateralCashPrice` in the case of deficit / surplus\n', '    At this point we have computed the final price for each collateral\n', '    type and coin holders can now turn their coin into collateral. Each\n', '    unit coin can claim a fixed basket of collateral.\n', '    Coin holders must first `prepareCoinsForRedeeming` into a `coinBag`. Once prepared,\n', '    coins cannot be transferred out of the bag. More coin can be added to a bag later.\n', '    8. `prepareCoinsForRedeeming(coinAmount)`:\n', "        - put some coins into a bag in order to 'redeemCollateral'. The bigger the bag, the more collateral the user can claim.\n", '    9. `redeemCollateral(collateralType, collateralAmount)`:\n', '        - exchange some coin from your bag for tokens from a specific collateral type\n', '        - the amount of collateral available to redeem is limited by how big your bag is\n', '*/\n', '\n', 'contract GlobalSettlement {\n', '    // --- Auth ---\n', '    mapping (address => uint256) public authorizedAccounts;\n', '    function addAuthorization(address account) external isAuthorized {\n', '        authorizedAccounts[account] = 1;\n', '        emit AddAuthorization(account);\n', '    }\n', '    function removeAuthorization(address account) external isAuthorized {\n', '        authorizedAccounts[account] = 0;\n', '        emit RemoveAuthorization(account);\n', '    }\n', '    modifier isAuthorized {\n', '        require(authorizedAccounts[msg.sender] == 1, "GlobalSettlement/account-not-authorized");\n', '        _;\n', '    }\n', '\n', '    // --- Data ---\n', '    SAFEEngineLike            public safeEngine;\n', '    LiquidationEngineLike    public liquidationEngine;\n', '    AccountingEngineLike     public accountingEngine;\n', '    OracleRelayerLike        public oracleRelayer;\n', '    CoinSavingsAccountLike   public coinSavingsAccount;\n', '    StabilityFeeTreasuryLike public stabilityFeeTreasury;\n', '\n', '    uint256  public contractEnabled;\n', '    uint256  public shutdownTime;\n', '    uint256  public shutdownCooldown;\n', '    uint256  public outstandingCoinSupply;                                      // [rad]\n', '\n', '    mapping (bytes32 => uint256) public finalCoinPerCollateralPrice;            // [ray]\n', '    mapping (bytes32 => uint256) public collateralShortfall;                    // [wad]\n', '    mapping (bytes32 => uint256) public collateralTotalDebt;                    // [wad]\n', '    mapping (bytes32 => uint256) public collateralCashPrice;                    // [ray]\n', '\n', '    mapping (address => uint256)                      public coinBag;           // [wad]\n', '    mapping (bytes32 => mapping (address => uint256)) public coinsUsedToRedeem; // [wad]\n', '\n', '    // --- Events ---\n', '    event AddAuthorization(address account);\n', '    event RemoveAuthorization(address account);\n', '    event ModifyParameters(bytes32 parameter, uint256 data);\n', '    event ModifyParameters(bytes32 parameter, address data);\n', '    event ShutdownSystem();\n', '    event FreezeCollateralType(bytes32 indexed collateralType, uint256 finalCoinPerCollateralPrice);\n', '    event FastTrackAuction(bytes32 indexed collateralType, uint256 auctionId, uint256 collateralTotalDebt);\n', '    event ProcessSAFE(bytes32 indexed collateralType, address safe, uint256 collateralShortfall);\n', '    event FreeCollateral(bytes32 indexed collateralType, address sender, int256 collateralAmount);\n', '    event SetOutstandingCoinSupply(uint256 outstandingCoinSupply);\n', '    event CalculateCashPrice(bytes32 indexed collateralType, uint256 collateralCashPrice);\n', '    event PrepareCoinsForRedeeming(address indexed sender, uint256 coinBag);\n', '    event RedeemCollateral(bytes32 indexed collateralType, address indexed sender, uint256 coinsAmount, uint256 collateralAmount);\n', '\n', '    // --- Init ---\n', '    constructor() public {\n', '        authorizedAccounts[msg.sender] = 1;\n', '        contractEnabled = 1;\n', '        emit AddAuthorization(msg.sender);\n', '    }\n', '\n', '    // --- Math ---\n', '    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = x + y;\n', '        require(z >= x, "GlobalSettlement/add-overflow");\n', '    }\n', '    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "GlobalSettlement/sub-underflow");\n', '    }\n', '    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "GlobalSettlement/mul-overflow");\n', '    }\n', '    function minimum(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        return x <= y ? x : y;\n', '    }\n', '    uint256 constant WAD = 10 ** 18;\n', '    uint256 constant RAY = 10 ** 27;\n', '    function rmultiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = multiply(x, y) / RAY;\n', '    }\n', '    function rdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y > 0, "GlobalSettlement/rdiv-by-zero");\n', '        z = multiply(x, RAY) / y;\n', '    }\n', '    function wdivide(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y > 0, "GlobalSettlement/wdiv-by-zero");\n', '        z = multiply(x, WAD) / y;\n', '    }\n', '\n', '    // --- Administration ---\n', '    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n', '        require(contractEnabled == 1, "GlobalSettlement/contract-not-enabled");\n', '        if (parameter == "safeEngine") safeEngine = SAFEEngineLike(data);\n', '        else if (parameter == "liquidationEngine") liquidationEngine = LiquidationEngineLike(data);\n', '        else if (parameter == "accountingEngine") accountingEngine = AccountingEngineLike(data);\n', '        else if (parameter == "oracleRelayer") oracleRelayer = OracleRelayerLike(data);\n', '        else if (parameter == "coinSavingsAccount") coinSavingsAccount = CoinSavingsAccountLike(data);\n', '        else if (parameter == "stabilityFeeTreasury") stabilityFeeTreasury = StabilityFeeTreasuryLike(data);\n', '        else revert("GlobalSettlement/modify-unrecognized-parameter");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n', '        require(contractEnabled == 1, "GlobalSettlement/contract-not-enabled");\n', '        if (parameter == "shutdownCooldown") shutdownCooldown = data;\n', '        else revert("GlobalSettlement/modify-unrecognized-parameter");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '\n', '    // --- Settlement ---\n', '    /**\n', '     * @notice Freeze the system and start the cooldown period\n', '     */\n', '    function shutdownSystem() external isAuthorized {\n', '        require(contractEnabled == 1, "GlobalSettlement/contract-not-enabled");\n', '        contractEnabled = 0;\n', '        shutdownTime = now;\n', '        safeEngine.disableContract();\n', '        liquidationEngine.disableContract();\n', '        // treasury must be disabled before the accounting engine so that all surplus is gathered in one place\n', '        if (address(stabilityFeeTreasury) != address(0)) {\n', '          stabilityFeeTreasury.disableContract();\n', '        }\n', '        accountingEngine.disableContract();\n', '        oracleRelayer.disableContract();\n', '        if (address(coinSavingsAccount) != address(0)) {\n', '          coinSavingsAccount.disableContract();\n', '        }\n', '        emit ShutdownSystem();\n', '    }\n', '    /**\n', "     * @notice Calculate a collateral type's final price according to the latest system coin redemption price\n", '     * @param collateralType The collateral type to calculate the price for\n', '     */\n', '    function freezeCollateralType(bytes32 collateralType) external {\n', '        require(contractEnabled == 0, "GlobalSettlement/contract-still-enabled");\n', '        require(finalCoinPerCollateralPrice[collateralType] == 0, "GlobalSettlement/final-collateral-price-already-defined");\n', '        (collateralTotalDebt[collateralType],,,,,) = safeEngine.collateralTypes(collateralType);\n', '        (OracleLike orcl,,) = oracleRelayer.collateralTypes(collateralType);\n', '        // redemptionPrice is a ray, orcl returns a wad\n', '        finalCoinPerCollateralPrice[collateralType] = wdivide(oracleRelayer.redemptionPrice(), uint256(orcl.read()));\n', '        emit FreezeCollateralType(collateralType, finalCoinPerCollateralPrice[collateralType]);\n', '    }\n', '    /**\n', '     * @notice Fast track an ongoing collateral auction\n', '     * @param collateralType The collateral type associated with the auction contract\n', '     * @param auctionId The ID of the auction to be fast tracked\n', '     */\n', '    function fastTrackAuction(bytes32 collateralType, uint256 auctionId) external {\n', '        require(finalCoinPerCollateralPrice[collateralType] != 0, "GlobalSettlement/final-collateral-price-not-defined");\n', '\n', '        (address auctionHouse_,,)       = liquidationEngine.collateralTypes(collateralType);\n', '        CollateralAuctionHouseLike collateralAuctionHouse = CollateralAuctionHouseLike(auctionHouse_);\n', '        (, uint256 accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n', '\n', '        uint256 bidAmount                 = collateralAuctionHouse.bidAmount(auctionId);\n', '        uint256 raisedAmount              = collateralAuctionHouse.raisedAmount(auctionId);\n', '        uint256 collateralToSell          = collateralAuctionHouse.remainingAmountToSell(auctionId);\n', '        address forgoneCollateralReceiver = collateralAuctionHouse.forgoneCollateralReceiver(auctionId);\n', '        uint256 amountToRaise             = collateralAuctionHouse.amountToRaise(auctionId);\n', '\n', '        safeEngine.createUnbackedDebt(address(accountingEngine), address(accountingEngine), subtract(amountToRaise, raisedAmount));\n', '        safeEngine.createUnbackedDebt(address(accountingEngine), address(this), bidAmount);\n', '        safeEngine.approveSAFEModification(address(collateralAuctionHouse));\n', '        collateralAuctionHouse.terminateAuctionPrematurely(auctionId);\n', '\n', '        uint256 debt_ = subtract(amountToRaise, raisedAmount) / accumulatedRate;\n', '        collateralTotalDebt[collateralType] = addition(collateralTotalDebt[collateralType], debt_);\n', '        require(int256(collateralToSell) >= 0 && int256(debt_) >= 0, "GlobalSettlement/overflow");\n', '        safeEngine.confiscateSAFECollateralAndDebt(collateralType, forgoneCollateralReceiver, address(this), address(accountingEngine), int256(collateralToSell), int256(debt_));\n', '        emit FastTrackAuction(collateralType, auctionId, collateralTotalDebt[collateralType]);\n', '    }\n', '    /**\n', "     * @notice Cancel a SAFE's debt and leave any extra collateral in it\n", '     * @param collateralType The collateral type associated with the SAFE\n', '     * @param safe The SAFE to be processed\n', '     */\n', '    function processSAFE(bytes32 collateralType, address safe) external {\n', '        require(finalCoinPerCollateralPrice[collateralType] != 0, "GlobalSettlement/final-collateral-price-not-defined");\n', '        (, uint256 accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n', '        (uint256 safeCollateral, uint256 safeDebt) = safeEngine.safes(collateralType, safe);\n', '\n', '        uint256 amountOwed = rmultiply(rmultiply(safeDebt, accumulatedRate), finalCoinPerCollateralPrice[collateralType]);\n', '        uint256 minCollateral = minimum(safeCollateral, amountOwed);\n', '        collateralShortfall[collateralType] = addition(\n', '            collateralShortfall[collateralType],\n', '            subtract(amountOwed, minCollateral)\n', '        );\n', '\n', '        require(minCollateral <= 2**255 && safeDebt <= 2**255, "GlobalSettlement/overflow");\n', '        safeEngine.confiscateSAFECollateralAndDebt(\n', '            collateralType,\n', '            safe,\n', '            address(this),\n', '            address(accountingEngine),\n', '            -int256(minCollateral),\n', '            -int256(safeDebt)\n', '        );\n', '\n', '        emit ProcessSAFE(collateralType, safe, collateralShortfall[collateralType]);\n', '    }\n', '    /**\n', "     * @notice Remove collateral from the caller's SAFE\n", '     * @param collateralType The collateral type to free\n', '     */\n', '    function freeCollateral(bytes32 collateralType) external {\n', '        require(contractEnabled == 0, "GlobalSettlement/contract-still-enabled");\n', '        (uint256 safeCollateral, uint256 safeDebt) = safeEngine.safes(collateralType, msg.sender);\n', '        require(safeDebt == 0, "GlobalSettlement/safe-debt-not-zero");\n', '        require(safeCollateral <= 2**255, "GlobalSettlement/overflow");\n', '        safeEngine.confiscateSAFECollateralAndDebt(\n', '          collateralType,\n', '          msg.sender,\n', '          msg.sender,\n', '          address(accountingEngine),\n', '          -int256(safeCollateral),\n', '          0\n', '        );\n', '        emit FreeCollateral(collateralType, msg.sender, -int256(safeCollateral));\n', '    }\n', '    /**\n', '     * @notice Set the final outstanding supply of system coins. There must be no remaining surplus in the accounting engine\n', '     */\n', '    function setOutstandingCoinSupply() external {\n', '        require(contractEnabled == 0, "GlobalSettlement/contract-still-enabled");\n', '        require(outstandingCoinSupply == 0, "GlobalSettlement/outstanding-coin-supply-not-zero");\n', '        require(safeEngine.coinBalance(address(accountingEngine)) == 0, "GlobalSettlement/surplus-not-zero");\n', '        require(now >= addition(shutdownTime, shutdownCooldown), "GlobalSettlement/shutdown-cooldown-not-finished");\n', '        outstandingCoinSupply = safeEngine.globalDebt();\n', '        emit SetOutstandingCoinSupply(outstandingCoinSupply);\n', '    }\n', '    /**\n', "     * @notice Calculate a collateral's price taking into consideration system surplus/deficit and the finalCoinPerCollateralPrice\n", '     * @param collateralType The collateral whose cash price will be calculated\n', '     */\n', '    function calculateCashPrice(bytes32 collateralType) external {\n', '        require(outstandingCoinSupply != 0, "GlobalSettlement/outstanding-coin-supply-zero");\n', '        require(collateralCashPrice[collateralType] == 0, "GlobalSettlement/collateral-cash-price-already-defined");\n', '\n', '        (, uint256 accumulatedRate,,,,) = safeEngine.collateralTypes(collateralType);\n', '        uint256 redemptionAdjustedDebt = rmultiply(\n', '          rmultiply(collateralTotalDebt[collateralType], accumulatedRate), finalCoinPerCollateralPrice[collateralType]\n', '        );\n', '        collateralCashPrice[collateralType] = rdivide(\n', '          multiply(subtract(redemptionAdjustedDebt, collateralShortfall[collateralType]), RAY), outstandingCoinSupply\n', '        );\n', '        emit CalculateCashPrice(collateralType, collateralCashPrice[collateralType]);\n', '    }\n', '    /**\n', "     * @notice Add coins into a 'bag' so that you can use them to redeem collateral\n", '     * @param coinAmount The amount of internal system coins to add into the bag\n', '     */\n', '    function prepareCoinsForRedeeming(uint256 coinAmount) external {\n', '        require(outstandingCoinSupply != 0, "GlobalSettlement/outstanding-coin-supply-zero");\n', '        safeEngine.transferInternalCoins(msg.sender, address(accountingEngine), multiply(coinAmount, RAY));\n', '        coinBag[msg.sender] = addition(coinBag[msg.sender], coinAmount);\n', '        emit PrepareCoinsForRedeeming(msg.sender, coinBag[msg.sender]);\n', '    }\n', '    /**\n', '     * @notice Redeem a specific collateral type using an amount of internal system coins from your bag\n', '     * @param collateralType The collateral type to redeem\n', '     * @param coinsAmount The amount of internal coins to use from your bag\n', '     */\n', '    function redeemCollateral(bytes32 collateralType, uint256 coinsAmount) external {\n', '        require(collateralCashPrice[collateralType] != 0, "GlobalSettlement/collateral-cash-price-not-defined");\n', '        uint256 collateralAmount = rmultiply(coinsAmount, collateralCashPrice[collateralType]);\n', '        safeEngine.transferCollateral(\n', '          collateralType,\n', '          address(this),\n', '          msg.sender,\n', '          collateralAmount\n', '        );\n', '        coinsUsedToRedeem[collateralType][msg.sender] = addition(coinsUsedToRedeem[collateralType][msg.sender], coinsAmount);\n', '        require(coinsUsedToRedeem[collateralType][msg.sender] <= coinBag[msg.sender], "GlobalSettlement/insufficient-bag-balance");\n', '        emit RedeemCollateral(collateralType, msg.sender, coinsAmount, collateralAmount);\n', '    }\n', '}']