['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-26\n', '*/\n', '\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '  abstract contract ILendingPool {\n', '    function flashLoan( address payable _receiver, address _reserve, uint _amount, bytes calldata _params) external virtual;\n', '    function deposit(address _reserve, uint256 _amount, uint16 _referralCode) external virtual payable;\n', '\tfunction setUserUseReserveAsCollateral(address _reserve, bool _useAsCollateral) external virtual;\n', '\tfunction borrow(address _reserve, uint256 _amount, uint256 _interestRateMode, uint16 _referralCode) external virtual;\n', '\tfunction repay( address _reserve, uint256 _amount, address payable _onBehalfOf) external virtual payable;\n', '\tfunction swapBorrowRateMode(address _reserve) external virtual;\n', '    function getReserves() external virtual view returns(address[] memory);\n', '\n', '    /// @param _reserve underlying token address\n', '    function getReserveData(address _reserve)\n', '        external virtual\n', '        view\n', '        returns (\n', '            uint256 totalLiquidity,               // reserve total liquidity\n', '            uint256 availableLiquidity,           // reserve available liquidity for borrowing\n', '            uint256 totalBorrowsStable,           // total amount of outstanding borrows at Stable rate\n', '            uint256 totalBorrowsVariable,         // total amount of outstanding borrows at Variable rate\n', '            uint256 liquidityRate,                // current deposit APY of the reserve for depositors, in Ray units.\n', '            uint256 variableBorrowRate,           // current variable rate APY of the reserve pool, in Ray units.\n', '            uint256 stableBorrowRate,             // current stable rate APY of the reserve pool, in Ray units.\n', '            uint256 averageStableBorrowRate,      // current average stable borrow rate\n', '            uint256 utilizationRate,              // expressed as total borrows/total liquidity.\n', '            uint256 liquidityIndex,               // cumulative liquidity index\n', '            uint256 variableBorrowIndex,          // cumulative variable borrow index\n', '            address aTokenAddress,                // aTokens contract address for the specific _reserve\n', '            uint40 lastUpdateTimestamp            // timestamp of the last update of reserve data\n', '        );\n', '\n', '    /// @param _user users address\n', '    function getUserAccountData(address _user)\n', '        external virtual\n', '        view\n', '        returns (\n', '            uint256 totalLiquidityETH,            // user aggregated deposits across all the reserves. In Wei\n', '            uint256 totalCollateralETH,           // user aggregated collateral across all the reserves. In Wei\n', '            uint256 totalBorrowsETH,              // user aggregated outstanding borrows across all the reserves. In Wei\n', '            uint256 totalFeesETH,                 // user aggregated current outstanding fees in ETH. In Wei\n', '            uint256 availableBorrowsETH,          // user available amount to borrow in ETH\n', '            uint256 currentLiquidationThreshold,  // user current average liquidation threshold across all the collaterals deposited\n', '            uint256 ltv,                          // user average Loan-to-Value between all the collaterals\n', '            uint256 healthFactor                  // user current Health Factor\n', '    );\n', '\n', '    /// @param _reserve underlying token address\n', '    /// @param _user users address\n', '    function getUserReserveData(address _reserve, address _user)\n', '        external virtual\n', '        view\n', '        returns (\n', '            uint256 currentATokenBalance,         // user current reserve aToken balance\n', '            uint256 currentBorrowBalance,         // user current reserve outstanding borrow balance\n', '            uint256 principalBorrowBalance,       // user balance of borrowed asset\n', '            uint256 borrowRateMode,               // user borrow rate mode either Stable or Variable\n', '            uint256 borrowRate,                   // user current borrow rate APY\n', '            uint256 liquidityRate,                // user current earn rate on _reserve\n', '            uint256 originationFee,               // user outstanding loan origination fee\n', '            uint256 variableBorrowIndex,          // user variable cumulative index\n', '            uint256 lastUpdateTimestamp,          // Timestamp of the last data update\n', "            bool usageAsCollateralEnabled         // Whether the user's current reserve is enabled as a collateral\n", '    );\n', '\n', '    function getReserveConfigurationData(address _reserve)\n', '        external virtual\n', '        view\n', '        returns (\n', '            uint256 ltv,\n', '            uint256 liquidationThreshold,\n', '            uint256 liquidationBonus,\n', '            address rateStrategyAddress,\n', '            bool usageAsCollateralEnabled,\n', '            bool borrowingEnabled,\n', '            bool stableBorrowRateEnabled,\n', '            bool isActive\n', '    );\n', '\n', '    // ------------------ LendingPoolCoreData ------------------------\n', '    function getReserveATokenAddress(address _reserve) public virtual view returns (address);\n', '    function getReserveConfiguration(address _reserve)\n', '        external virtual\n', '        view\n', '        returns (uint256, uint256, uint256, bool);\n', '    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '\n', '    function getReserveCurrentLiquidityRate(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveCurrentVariableBorrowRate(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveCurrentStableBorrowRate(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveTotalLiquidity(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveAvailableLiquidity(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveTotalBorrowsVariable(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '    function getReserveTotalBorrowsStable(address _reserve)\n', '        public virtual\n', '        view\n', '        returns (uint256);\n', '\n', '    // ---------------- LendingPoolDataProvider ---------------------\n', '    function calculateUserGlobalData(address _user)\n', '        public virtual\n', '        view\n', '        returns (\n', '            uint256 totalLiquidityBalanceETH,\n', '            uint256 totalCollateralBalanceETH,\n', '            uint256 totalBorrowBalanceETH,\n', '            uint256 totalFeesETH,\n', '            uint256 currentLtv,\n', '            uint256 currentLiquidationThreshold,\n', '            uint256 healthFactor,\n', '            bool healthFactorBelowThreshold\n', '        );\n', '}  contract DefisaverLogger {\n', '    event LogEvent(\n', '        address indexed contractAddress,\n', '        address indexed caller,\n', '        string indexed logName,\n', '        bytes data\n', '    );\n', '\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function Log(address _contract, address _caller, string memory _logName, bytes memory _data)\n', '        public\n', '    {\n', '        emit LogEvent(_contract, _caller, _logName, _data);\n', '    }\n', '}  abstract contract DSGuard {\n', '    function canCall(address src_, address dst_, bytes4 sig) public view virtual returns (bool);\n', '\n', '    function permit(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n', '\n', '    function forbid(bytes32 src, bytes32 dst, bytes32 sig) public virtual;\n', '\n', '    function permit(address src, address dst, bytes32 sig) public virtual;\n', '\n', '    function forbid(address src, address dst, bytes32 sig) public virtual;\n', '}\n', '\n', '\n', 'abstract contract DSGuardFactory {\n', '    function newGuard() public virtual returns (DSGuard guard);\n', '}  abstract contract DSAuthority {\n', '    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\n', '}  contract DSAuthEvents {\n', '    event LogSetAuthority(address indexed authority);\n', '    event LogSetOwner(address indexed owner);\n', '}\n', '\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority public authority;\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_) public auth {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_) public auth {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, address(this), sig);\n', '        }\n', '    }\n', '}  contract ProxyPermission {\n', '    address public constant FACTORY_ADDRESS = 0x5a15566417e6C1c9546523066500bDDBc53F88C7;\n', '\n', '    /// @notice Called in the context of DSProxy to authorize an address\n', '    /// @param _contractAddr Address which will be authorized\n', '    function givePermission(address _contractAddr) public {\n', '        address currAuthority = address(DSAuth(address(this)).authority());\n', '        DSGuard guard = DSGuard(currAuthority);\n', '\n', '        if (currAuthority == address(0)) {\n', '            guard = DSGuardFactory(FACTORY_ADDRESS).newGuard();\n', '            DSAuth(address(this)).setAuthority(DSAuthority(address(guard)));\n', '        }\n', '\n', '        guard.permit(_contractAddr, address(this), bytes4(keccak256("execute(address,bytes)")));\n', '    }\n', '\n', '    /// @notice Called in the context of DSProxy to remove authority of an address\n', '    /// @param _contractAddr Auth address which will be removed from authority list\n', '    function removePermission(address _contractAddr) public {\n', '        address currAuthority = address(DSAuth(address(this)).authority());\n', '        \n', "        // if there is no authority, that means that contract doesn't have permission\n", '        if (currAuthority == address(0)) {\n', '            return;\n', '        }\n', '\n', '        DSGuard guard = DSGuard(currAuthority);\n', '        guard.forbid(_contractAddr, address(this), bytes4(keccak256("execute(address,bytes)")));\n', '    }\n', '\n', '    function proxyOwner() internal returns(address) {\n', '        return DSAuth(address(this)).owner();\n', '    } \n', '}  \n', '\n', 'contract DFSExchangeData {\n', '\n', '    // first is empty to keep the legacy order in place\n', '    enum ExchangeType { _, OASIS, KYBER, UNISWAP, ZEROX }\n', '\n', '    enum ActionType { SELL, BUY }\n', '\n', '    struct OffchainData {\n', '        address wrapper;\n', '        address exchangeAddr;\n', '        address allowanceTarget;\n', '        uint256 price;\n', '        uint256 protocolFee;\n', '        bytes callData;\n', '    }\n', '\n', '    struct ExchangeData {\n', '        address srcAddr;\n', '        address destAddr;\n', '        uint256 srcAmount;\n', '        uint256 destAmount;\n', '        uint256 minPrice;\n', '        uint256 dfsFeeDivider; // service fee divider\n', '        address user; // user to check special fee\n', '        address wrapper;\n', '        bytes wrapperData;\n', '        OffchainData offchainData;\n', '    }\n', '\n', '    function packExchangeData(ExchangeData memory _exData) public pure returns(bytes memory) {\n', '        return abi.encode(_exData);\n', '    }\n', '\n', '    function unpackExchangeData(bytes memory _data) public pure returns(ExchangeData memory _exData) {\n', '        _exData = abi.decode(_data, (ExchangeData));\n', '    }\n', '}  interface ERC20 {\n', '    function totalSupply() external view returns (uint256 supply);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '\n', '    function decimals() external view returns (uint256 digits);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}  library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}  library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}  library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     */\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function _callOptionalReturn(ERC20 token, bytes memory data) private {\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '} \n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Opens compound positions with a leverage\n', 'contract CompoundCreateTaker is ProxyPermission {\n', '    using SafeERC20 for ERC20;\n', '\n', '    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    ILendingPool public constant lendingPool = ILendingPool(0x398eC7346DcD622eDc5ae82352F02bE94C62d119);\n', '\n', '    // solhint-disable-next-line const-name-snakecase\n', '    DefisaverLogger public constant logger = DefisaverLogger(0x5c55B921f590a89C1Ebe84dF170E655a82b62126);\n', '\n', '    struct CreateInfo {\n', '        address cCollAddress;\n', '        address cBorrowAddress;\n', '        uint depositAmount;\n', '    }\n', '\n', '    /// @notice Main function which will take a FL and open a leverage position\n', '    /// @dev Call through DSProxy, if _exchangeData.destAddr is a token approve DSProxy\n', '    /// @param _createInfo [cCollAddress, cBorrowAddress, depositAmount]\n', '    /// @param _exchangeData Exchange data struct\n', '    function openLeveragedLoan(\n', '        CreateInfo memory _createInfo,\n', '        DFSExchangeData.ExchangeData memory _exchangeData,\n', '        address payable _compReceiver\n', '    ) public payable {\n', '        uint loanAmount = _exchangeData.srcAmount;\n', '\n', '        // Pull tokens from user\n', '        if (_exchangeData.destAddr != ETH_ADDRESS) {\n', '            ERC20(_exchangeData.destAddr).safeTransferFrom(msg.sender, address(this), _createInfo.depositAmount);\n', '        } else {\n', '            require(msg.value >= _createInfo.depositAmount, "Must send correct amount of eth");\n', '        }\n', '\n', '        // Send tokens to FL receiver\n', '        sendDeposit(_compReceiver, _exchangeData.destAddr);\n', '\n', '        bytes memory paramsData = abi.encode(_createInfo, _exchangeData, address(this));\n', '\n', '        givePermission(_compReceiver);\n', '\n', '        lendingPool.flashLoan(_compReceiver, _exchangeData.srcAddr, loanAmount, paramsData);\n', '\n', '        removePermission(_compReceiver);\n', '\n', '        logger.Log(address(this), msg.sender, "CompoundLeveragedLoan",\n', '            abi.encode(_exchangeData.srcAddr, _exchangeData.destAddr, _exchangeData.srcAmount, _exchangeData.destAmount));\n', '    }\n', '\n', '    function sendDeposit(address payable _compoundReceiver, address _token) internal {\n', '        if (_token != ETH_ADDRESS) {\n', '            ERC20(_token).safeTransfer(_compoundReceiver, ERC20(_token).balanceOf(address(this)));\n', '        }\n', '\n', '        _compoundReceiver.transfer(address(this).balance);\n', '    }\n', '}']