['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-08\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function migrator() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '    function setMigrator(address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return payable(msg.sender);\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'contract Owned is Context {\n', '    address private _owner;\n', '    address private _pendingOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier ownerOnly {\n', '        require(_owner == _msgSender(), "Owner only");\n', '        _;\n', '    }\n', '    modifier pendingOnly {\n', '        require (_pendingOwner == msg.sender, "cannot claim");\n', '        _;\n', '    }\n', '\n', '    function pendingOwner() public view returns (address) {\n', '        return _pendingOwner;\n', '    }\n', '\n', '    function renounceOwnership() public virtual ownerOnly {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public ownerOnly {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        _pendingOwner = newOwner;\n', '    }\n', '\n', '    function cancelTransfer() public ownerOnly {\n', '        require(_pendingOwner != address(0), "no pending owner");\n', '        _pendingOwner = address(0);\n', '    }\n', '\n', '    function claimOwnership() public pendingOnly {\n', '        _pendingOwner = address(0);\n', '        emit OwnershipTransferred(_owner, _msgSender());\n', '        _owner = _msgSender();\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Pool {}\n', '\n', 'library EnumerableSet {\n', '    // To implement this library for multiple types with as little code\n', '    // repetition as possible, we write it in terms of a generic Set type with\n', '    // bytes32 values.\n', '    // The Set implementation uses private functions, and user-facing\n', '    // implementations (such as AddressSet) are just wrappers around the\n', '    // underlying Set.\n', '    // This means that we can only create new EnumerableSets for types that fit\n', '    // in bytes32.\n', '\n', '    struct Set {\n', '        // Storage of set values\n', '        bytes32[] _values;\n', '\n', '        // Position of the value in the `values` array, plus 1 because index 0\n', '        // means a value is not in the set.\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', '            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '\n', '    // Bytes32Set\n', '\n', '    struct Bytes32Set {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _add(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _remove(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n', '        return _contains(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(Bytes32Set storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n', '        return _at(set._inner, index);\n', '    }\n', '\n', '    // AddressSet\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        return address(uint160(uint256(_at(set._inner, index))));\n', '    }\n', '\n', '\n', '    // UintSet\n', '\n', '    struct UintSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function length(UintSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n', '        return uint256(_at(set._inner, index));\n', '    }\n', '}\n', '\n', 'contract Storage {\n', '\n', '    struct Addresses {\n', '        address pool;\n', '        address router;\n', '        address pair;\n', '        address protocol;\n', '        address dogecity;\n', '        address prizePool;\n', '        address buyBonusPool;\n', '        address presale;\n', '        address rng;\n', '        address farm;\n', '    }\n', '\n', '    struct Balance {\n', '        uint256 tokenSupply;\n', '        uint256 networkSupply;\n', '        uint256 targetSupply;\n', '        uint256 pairSupply;\n', '        uint256 lpSupply;\n', '        uint256 fees;\n', '        uint256 burned;\n', '    }\n', '\n', '    struct Account {\n', '        bool feeless;\n', '        bool transferPair;\n', '        bool excluded;\n', '        uint256 lastDogeIt;\n', '        uint256 tTotal;\n', '        uint256 rTotal;\n', '        uint256 lastShill;\n', '        uint256 communityPoints;\n', '        uint256 lastAward;\n', '    }\n', '\n', '    struct Divisors {\n', '        uint8 buy;\n', '        uint8 sell;\n', '        // multiplied by 10000\n', '        uint8 dogecity;\n', '        uint8 bonus;\n', '        uint8 tokenLPBurn;\n', '        uint8 inflate;\n', '        uint8 buyCounter;\n', '        uint8 tx;\n', '        uint8 dogeitpayout;\n', '        uint256 dogeify;\n', '    }\n', '\n', '    struct S {\n', '        bool initialized;\n', '        bool paused;\n', '        uint8 decimals;\n', '        uint8 odds;\n', '        Addresses addresses;\n', '        Balance balances;\n', '        Divisors divisors;\n', '        uint256 random;\n', '        uint256 buyFee;\n', '        uint256 sellFee;\n', '        uint256 minBuyForBonus;\n', '        uint256 buys;\n', '        uint256 sells;\n', '        uint256 lastAttack;\n', '        uint256 attackCooldown;\n', '        mapping(address => Account) accounts;\n', '        mapping(address => mapping(address => uint256)) allowances;\n', '\n', '        address[] entries;\n', '        string symbol;\n', '        string name;\n', '        EnumerableSet.AddressSet excludedAccounts;\n', '\n', '    }\n', '\n', '}\n', '\n', 'contract State {\n', '    Storage.S state;\n', '    TState lastTState;\n', '\n', '    enum TxType { FromExcluded, ToExcluded, BothExcluded, Standard }\n', '    enum TState { Buy, Sell, Normal }\n', '}\n', '\n', 'contract Getters is State {\n', '\n', '    function canIDogeIt() public view returns(bool) {\n', '        return state.accounts[msg.sender].lastDogeIt + state.divisors.dogeify < block.timestamp;\n', '    }\n', '\n', '    function isMinBuyForBonus(uint256 amount) public view returns(bool) {\n', '        return amount > state.minBuyForBonus * (10 ** state.decimals);\n', '    }\n', '\n', '    function isFeelessTx(address sender, address recipient) public view returns(bool) {\n', '        if(sender == state.addresses.presale) {\n', '            return true;\n', '        }\n', '        return state.accounts[sender].feeless || state.accounts[recipient].feeless;\n', '    }\n', '\n', '    function getAccount(address account) public view returns(Storage.Account memory) {\n', '        return state.accounts[account];\n', '    }\n', '\n', '    function getDivisors() external view returns(Storage.Divisors memory) {\n', '        return state.divisors;\n', '    }\n', '\n', '    function getBurned() external view returns(uint256) {\n', '        return state.balances.burned;\n', '    }\n', '\n', '    function getFees() external view returns(uint256) {\n', '        return state.balances.fees;\n', '    }\n', '\n', '    function getExcluded(address account) public view returns(bool) {\n', '        return state.accounts[account].excluded;\n', '    }\n', '\n', '    function getCurrentLPBal() public view returns(uint256) {\n', '        return IERC20(state.addresses.pool).totalSupply();\n', '    }\n', '\n', '    function getLPBalanceOf(address account) external view returns(uint256) {\n', '        return IERC20(state.addresses.pool).balanceOf(account);\n', '    }\n', '\n', '    function getFeeless(address account) external view returns (bool) {\n', '        return state.accounts[account].feeless;\n', '    }\n', '\n', '    function getTState(address sender, address recipient, uint256 lpAmount) public view returns(TState t) {\n', '        if(state.accounts[sender].transferPair) {\n', '            if(state.balances.lpSupply != lpAmount) { // withdraw vs buy\n', '                t = TState.Normal;\n', '            } else {\n', '                t = TState.Buy;\n', '            }\n', '        } else if(state.accounts[recipient].transferPair) {\n', '            t = TState.Sell;\n', '        } else {\n', '            t = TState.Normal;\n', '        }\n', '        return t;\n', '    }\n', '\n', '    function getRouter() external view returns(address) {\n', '        return state.addresses.router;\n', '    }\n', '\n', '    function getPair() external view returns(address) {\n', '        return state.addresses.pair;\n', '    }\n', '\n', '    function getPool() external view returns(address) {\n', '        return state.addresses.pool;\n', '    }\n', '\n', '    function getCirculatingSupply() public view returns(uint256, uint256) {\n', '        uint256 rSupply = state.balances.networkSupply;\n', '        uint256 tSupply = state.balances.tokenSupply;\n', '        for (uint256 i = 0; i < EnumerableSet.length(state.excludedAccounts); i++) {\n', '            address account = EnumerableSet.at(state.excludedAccounts, i);\n', '            uint256 rBalance = state.accounts[account].rTotal;\n', '            uint256 tBalance = state.accounts[account].tTotal;\n', '            if (rBalance > rSupply || tBalance > tSupply) return (state.balances.networkSupply, state.balances.tokenSupply);\n', '            rSupply -= rBalance;\n', '            tSupply -= tBalance;\n', '        }\n', '        if (rSupply < state.balances.networkSupply / state.balances.tokenSupply) return (state.balances.networkSupply, state.balances.tokenSupply);\n', '        return (rSupply, tSupply);\n', '    }\n', '\n', '    function getTxType(address sender, address recipient) public view returns(TxType t) {\n', '        bool isSenderExcluded = state.accounts[sender].excluded;\n', '        bool isRecipientExcluded = state.accounts[recipient].excluded;\n', '        if (isSenderExcluded && !isRecipientExcluded) {\n', '            t = TxType.FromExcluded;\n', '        } else if (!isSenderExcluded && isRecipientExcluded) {\n', '            t = TxType.ToExcluded;\n', '        } else if (!isSenderExcluded && !isRecipientExcluded) {\n', '            t = TxType.Standard;\n', '        } else if (isSenderExcluded && isRecipientExcluded) {\n', '            t = TxType.BothExcluded;\n', '        } else {\n', '            t = TxType.Standard;\n', '        }\n', '    }\n', '\n', '    function getFee(uint256 amount, uint256 divisor) public pure returns (uint256) {\n', '        return amount / divisor;\n', '    }\n', '\n', '    function getPrizePoolAddress() public view returns(address) {\n', '        return state.addresses.prizePool;\n', '    }\n', '\n', '    function getPrizePoolAmount() public view returns(uint256) {\n', '        return state.accounts[getPrizePoolAddress()].rTotal / ratio();\n', '    }\n', '\n', '    function getBuyPoolAmount() public view returns(uint256) {\n', '        return state.accounts[getBuyBonusPoolAddress()].rTotal / ratio();\n', '    }\n', '\n', '    function getBuyBonusPoolAddress() public view returns(address) {\n', '        return state.addresses.buyBonusPool;\n', '    }\n', '\n', '    function getAmountForMinBuyTax() public view returns(uint256) {\n', '        return (state.balances.tokenSupply / 100);\n', '    }\n', '\n', '    function getBuyTax(uint256 amount) public view returns(uint256) {\n', '        uint256 _ratio = amount * 100000 / state.balances.tokenSupply;\n', '        if(_ratio < 1) { // .001%\n', '            return state.divisors.buy; // charges whatever max buy fee is at, to discourage gaming the prizepool.\n', '        } else if (_ratio >= 1000) { // 1%\n', '            return state.divisors.buy * 5; // charges 1/5th of buy fee, from default is 1%\n', '        } else if (_ratio >= 10 && _ratio < 100){\n', '            return state.divisors.buy * 2; // and so on.\n', '        } else if (_ratio >= 100 && _ratio < 500) {\n', '            return state.divisors.buy * 3;\n', '        } else if (_ratio >= 500 && _ratio < 1000) {\n', '            return state.divisors.buy * 4;\n', "        } else { // shouldn't hit this\n", '            return state.divisors.buy;\n', '        }\n', '    }\n', '\n', '    function getTimeTillNextAttack() public view returns(uint256) {\n', '        uint256 time = (state.lastAttack + state.attackCooldown);\n', '        return block.timestamp > time ? block.timestamp - time : 0;\n', '    }\n', '\n', '    function getMaxBetAmount() public view returns(uint256) {\n', '        return state.accounts[state.addresses.buyBonusPool].tTotal / state.divisors.dogeitpayout;\n', '    }\n', '\n', '    function getLastTState() public view returns(TState) {\n', '        return lastTState;\n', '    }\n', '\n', '    function getLevel(address account) public view returns(uint256 level) {\n', '        level = state.accounts[account].communityPoints % 1000;\n', '        return level == 0 ? 1 : level;\n', '    }\n', '\n', '    function getXP(address account) public view returns(uint256) {\n', '        return state.accounts[account].communityPoints;\n', '    }\n', '\n', '    function getBuyAfterSellBonus(uint256 amount) public view returns(uint256 bonus) {\n', '        uint256 total = state.accounts[state.addresses.buyBonusPool].tTotal;\n', '        if(amount >= total / 100) { // 1% of the pool\n', '            bonus = total / state.divisors.bonus;\n', '        } else if(amount >= total / 200) { // .5% of the pool\n', '            bonus = total / (state.divisors.bonus * 2);\n', '        } else if(amount >= total / 500) {\n', '            bonus = total / (state.divisors.bonus * 3);\n', '        } else if(amount >= total / 1000) {\n', '            bonus = total / (state.divisors.bonus * 4);\n', '        } else {\n', '            bonus = total / (state.divisors.bonus * 5);\n', '        }\n', '    }\n', '\n', '    function getBuyAfterBuyBonus() public view returns(uint256 bonus) {\n', '        bonus = state.accounts[state.addresses.buyBonusPool].tTotal / 500;\n', '    }\n', '\n', '    function getBuyBonus(uint256 amount) public view returns(uint256) {\n', '        uint256 bonus;\n', '        if(lastTState == TState.Sell && amount > state.minBuyForBonus) {\n', '            bonus = getBuyAfterSellBonus(amount);\n', '        } else if(lastTState == TState.Buy && amount > state.minBuyForBonus) {\n', '            bonus = getBuyAfterBuyBonus();\n', '        } else {\n', '            bonus = 0;\n', '        }\n', '        return bonus > state.accounts[state.addresses.buyBonusPool].tTotal ? 0 : bonus;\n', '    }\n', '\n', '    function ratio() public view returns(uint256) {\n', '        return state.balances.networkSupply / state.balances.tokenSupply;\n', '    }\n', '\n', '}\n', '\n', 'interface IDogira {\n', '    function setRandomSeed(uint256 amount) external;\n', '}\n', '\n', 'contract Dogira is IDogira, IERC20, Getters, Owned {\n', '\n', '    struct TxValue {\n', '        uint256 amount;\n', '        uint256 transferAmount;\n', '        uint256 fee;\n', '        uint256 buyFee;\n', '        uint256 sellFee;\n', '        uint256 buyBonus;\n', '        uint256 operationalFee;\n', '    }\n', '    event BonusAwarded(address account, uint256 amount);\n', '    event Kek(address account, uint256 amount);\n', '    event Doge(address account, uint256 amount);\n', '    event Winner(address account, uint256 amount);\n', '    event Smashed(uint256 amount);\n', '    event Atomacized(uint256 amount);\n', '    event Blazed(uint256 amount);\n', '    mapping(address => bool) admins;\n', '\n', '    event FarmAdded(address farm);\n', '    event XPAdded(address awardee, uint256 points);\n', '    event Hooray(address awardee, uint256 points);\n', '    event TransferredToFarm(uint256 amount);\n', '\n', '    uint256 timeLock;\n', '    uint256 dogeCityInitial;\n', '    uint256 public lastTeamSell;\n', '    uint256 levelCap;\n', '    bool rngSet;\n', '    bool presaleSet;\n', '\n', '    modifier onlyAdminOrOwner {\n', '        require(admins[msg.sender] || msg.sender == owner(), "invalid caller");\n', '        _;\n', '    }\n', '\n', '    constructor() {\n', '        initialize();\n', '    }\n', '\n', '    uint256 constant private TOKEN_SUPPLY = 100_000_000;\n', '\n', '    function name() public view returns(string memory) {\n', '        return state.name;\n', '    }\n', '\n', '    function decimals() public view returns(uint8) {\n', '        return state.decimals;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return state.symbol;\n', '    }\n', '\n', '    function initialize() public {\n', '        require(!state.initialized, "Contract instance has already been initialized");\n', '        state.initialized = true;\n', '        state.decimals = 18;\n', '        state.symbol = "DOGIRA";\n', '        state.name = "dogira.lol || dogira.eth.link";\n', '        state.balances.tokenSupply = TOKEN_SUPPLY * (10 ** state.decimals);\n', '        state.balances.networkSupply = (~uint256(0) - (~uint256(0) % TOKEN_SUPPLY));\n', '        state.divisors.buy = 20; // 5% max - 1% depending on buy size.\n', '        state.divisors.sell = 20; // 5%\n', '        state.divisors.bonus = 50;\n', '        state.divisors.dogecity = 100;\n', '        state.divisors.inflate = 50;\n', '        state.divisors.tokenLPBurn = 50;\n', '        state.divisors.tx = 100;\n', '        state.divisors.dogeitpayout = 100;\n', '        state.divisors.dogeify = 1 hours; // 3600 seconds\n', '        state.divisors.buyCounter = 10;\n', '        state.odds = 4; // 1 / 4\n', '        state.minBuyForBonus = 35000e18;\n', '        state.addresses.prizePool = address(new Pool());\n', '        state.addresses.buyBonusPool = address(new Pool());\n', '        state.addresses.router = address(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        state.addresses.dogecity = address(0xfEDD9544b47a6D4A1967D385575866BD6f7A2b37);\n', '        state.addresses.pair = IUniswapV2Router02(state.addresses.router).WETH();\n', '        state.addresses.pool =\n', '            IUniswapV2Factory(IUniswapV2Router02(state.addresses.router).factory()).createPair(address(this), state.addresses.pair);\n', '        state.accounts[address(0)].feeless = true;\n', '        state.accounts[msg.sender].feeless = true;\n', '        //state.accounts[state.addresses.pool].feeless = true;\n', '        state.accounts[state.addresses.pool].transferPair = true;\n', '        uint256 locked = state.balances.networkSupply / 5; // 20%\n', '        uint256 amount = state.balances.networkSupply - locked;\n', '        state.accounts[msg.sender].rTotal = amount; // 80%\n', '        dogeCityInitial = locked - (locked / 4);\n', '        state.accounts[state.addresses.dogecity].feeless = true;\n', '        state.accounts[state.addresses.dogecity].rTotal = dogeCityInitial; // 15%\n', '        state.accounts[state.addresses.buyBonusPool].rTotal = locked / 4; // 5%\n', '        state.accounts[state.addresses.buyBonusPool].tTotal = state.balances.tokenSupply / 20; // 5%\n', '        state.paused = true;\n', '        state.attackCooldown = 10 minutes;\n', '        levelCap = 10;\n', '        timeLock = block.timestamp + 3 days;\n', '\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view override returns (uint256) {\n', '        return state.allowances[owner][spender];\n', '    }\n', '\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return getExcluded(account) ? state.accounts[account].tTotal : state.accounts[account].rTotal / ratio();\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) private {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        state.allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, state.allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, state.allowances[_msgSender()][spender] - (subtractedValue));\n', '        return true;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return state.balances.tokenSupply;\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), state.allowances[sender][_msgSender()] - amount);\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal returns(bool) {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        require(amount > 0, "Transfer amount must be greater than zero");\n', '        if(sender == state.addresses.pool) { // for presales\n', '            require(state.paused == false, "Transfers are paused");\n', '        }\n', '        // removed setter for dogecity to prevent changing the address and making this branch useless.\n', '        if(sender == state.addresses.dogecity) {\n', '            require(amount <= dogeCityInitial / 20, "too much"); // 5% per day\n', '            require(lastTeamSell + 1 days < block.timestamp, "too soon");\n', '            require(recipient == state.addresses.pool, "can only sell to uniswap pool");\n', '            lastTeamSell = block.timestamp;\n', '        }\n', '        bool noFee = isFeelessTx(sender, recipient);\n', '        uint256 rate = ratio();\n', '        uint256 lpAmount = getCurrentLPBal();\n', '        (TxValue memory t, TState ts, TxType txType) = tValues(sender, recipient, amount, noFee, lpAmount);\n', '        state.balances.lpSupply = lpAmount;\n', '        handleTRV(recipient, rate, ts, t);\n', '        rTransfer(sender, recipient, rate, t, txType);\n', '        state.balances.fees += t.fee;\n', '        state.balances.networkSupply -= (t.fee * rate);\n', '        lastTState = ts;\n', '        emit Transfer(msg.sender, recipient, t.transferAmount);\n', '        return true;\n', '    }\n', '\n', '    function transferToFarm(uint256 amount) external ownerOnly {\n', '        require(timeLock < block.timestamp, "too soon");\n', '        uint256 r = amount * ratio();\n', '        state.accounts[state.addresses.dogecity].rTotal -= r;\n', '        state.accounts[state.addresses.farm].rTotal += r;\n', '        emit TransferredToFarm(amount);\n', '    }\n', '\n', '    function rTransfer(address sender, address recipient, uint256 rate, TxValue memory t, TxType txType) internal {\n', '        if (txType == TxType.ToExcluded) {\n', '            state.accounts[sender].rTotal         -= t.amount * rate;\n', '            state.accounts[recipient].tTotal      += (t.transferAmount);\n', '            state.accounts[recipient].rTotal      += t.transferAmount * rate;\n', '        } else if (txType == TxType.FromExcluded) {\n', '            state.accounts[sender].tTotal         -= t.amount;\n', '            state.accounts[sender].rTotal         -= t.amount * rate;\n', '            state.accounts[recipient].rTotal      += t.transferAmount * rate;\n', '        } else if (txType == TxType.BothExcluded) {\n', '            state.accounts[sender].tTotal         -= t.amount;\n', '            state.accounts[sender].rTotal         -= (t.amount * rate);\n', '            state.accounts[recipient].tTotal      += t.transferAmount;\n', '            state.accounts[recipient].rTotal      += (t.transferAmount * rate);\n', '        } else {\n', '            state.accounts[sender].rTotal         -= (t.amount * rate);\n', '            state.accounts[recipient].rTotal      += (t.transferAmount * rate);\n', '        }\n', '    }\n', '\n', '    // burn supply, not negative rebase\n', '    function verysmashed() external  {\n', '        require(!state.paused, "still paused");\n', '        require(state.lastAttack + state.attackCooldown < block.timestamp, "Dogira coolingdown");\n', '        uint256 rLp = state.accounts[state.addresses.pool].rTotal;\n', '        uint256 amountToDeflate = (rLp / (state.divisors.tokenLPBurn));\n', '        uint256 burned = amountToDeflate / ratio();\n', '        state.accounts[state.addresses.pool].rTotal -= amountToDeflate;\n', '        state.accounts[address(0)].rTotal += amountToDeflate;\n', '        state.accounts[address(0)].tTotal += burned;\n', '        state.balances.burned += burned;\n', '        state.lastAttack = block.timestamp;\n', '        syncPool();\n', '        emit Smashed(burned);\n', '    }\n', '\n', '    // positive rebase\n', '    function dogebreath() external {\n', '        require(!state.paused, "still paused");\n', '        require(state.lastAttack + state.attackCooldown < block.timestamp, "Dogira coolingdown");\n', '        uint256 rate = ratio();\n', '        uint256 target = state.balances.burned == 0 ? state.balances.tokenSupply : state.balances.burned;\n', '        uint256 amountToInflate = target / state.divisors.inflate;\n', '        if(state.balances.burned > amountToInflate) {\n', '            state.balances.burned -= amountToInflate;\n', '            state.accounts[address(0)].rTotal -= amountToInflate * rate;\n', '            state.accounts[address(0)].tTotal -= amountToInflate;\n', '        }\n', '        // positive rebase\n', '        state.balances.networkSupply -= amountToInflate * rate;\n', '        state.lastAttack = block.timestamp;\n', '        syncPool();\n', '        emit Atomacized(amountToInflate);\n', '    }\n', '\n', '    // disperse amount to all holders\n', '    function wow(uint256 amount) external {\n', '        address sender = msg.sender;\n', '        uint256 rate = ratio();\n', '        require(!getExcluded(sender), "Excluded addresses can\'t call this function");\n', '        require(amount * rate < state.accounts[sender].rTotal, "too much");\n', '        state.accounts[sender].rTotal -= (amount * rate);\n', '        state.balances.networkSupply -= amount * rate;\n', '        state.balances.fees += amount;\n', '    }\n', '\n', '    // award community members from the treasury\n', '    function muchSupport(address awardee, uint256 multiplier) external onlyAdminOrOwner {\n', '        uint256 n = block.timestamp;\n', '        require(!state.paused, "still paused");\n', '        require(state.accounts[awardee].lastShill + 1 days < n, "nice shill but need to wait");\n', '        require(!getExcluded(awardee), "excluded addresses can\'t be awarded");\n', '        require(multiplier <= 100 && multiplier > 0, "can\'t be more than .1% of dogecity reward");\n', '        uint256 level = getLevel(awardee);\n', '        if(level > levelCap) {\n', '            level = levelCap; // capped at 10\n', '        } else if (level <= 0) {\n', '            level = 1;\n', '        }\n', '        uint256 p = ((state.accounts[state.addresses.dogecity].rTotal / 100000) * multiplier) * level; // .001% * m of dogecity * level\n', '        state.accounts[state.addresses.dogecity].rTotal -= p;\n', '        state.accounts[awardee].rTotal += p;\n', '        state.accounts[awardee].lastShill = block.timestamp;\n', '        state.accounts[awardee].communityPoints += multiplier;\n', '        emit Hooray(awardee, p);\n', '    }\n', '\n', '\n', '    function yayCommunity(address awardee, uint256 points) external onlyAdminOrOwner {\n', '        uint256 n = block.timestamp;\n', '        require(!state.paused, "still paused");\n', '        require(state.accounts[awardee].lastAward + 1 days < n, "nice help but need to wait");\n', '        require(!getExcluded(awardee), "excluded addresses can\'t be awarded");\n', '        require(points <= 1000 && points > 0, "can\'t be more than a full level");\n', '        state.accounts[awardee].communityPoints += points;\n', '        state.accounts[awardee].lastAward = block.timestamp;\n', '        emit XPAdded(awardee, points);\n', '    }\n', '\n', '    // burn amount, for cex integration?\n', '    function suchburn(uint256 amount) external {\n', '        address sender = msg.sender;\n', '        uint256 rate = ratio();\n', '        require(!getExcluded(sender), "Excluded addresses can\'t call this function");\n', '        require(amount * rate < state.accounts[sender].rTotal, "too much");\n', '        state.accounts[sender].rTotal -= (amount * rate);\n', '        state.accounts[address(0)].rTotal += (amount * rate);\n', '        state.accounts[address(0)].tTotal += (amount);\n', '        state.balances.burned += amount;\n', '        syncPool();\n', '        emit Blazed(amount);\n', '    }\n', '\n', '    function dogeit(uint256 amount) external {\n', '        require(!state.paused, "still paused");\n', '        require(!getExcluded(msg.sender), "excluded can\'t call");\n', '        uint256 rAmount = amount * ratio();\n', '        require(state.accounts[msg.sender].lastDogeIt + state.divisors.dogeify < block.timestamp, "you need to wait to doge");\n', '        require(amount > 0, "don\'t waste your gas");\n', '        require(rAmount <= state.accounts[state.addresses.buyBonusPool].rTotal / state.divisors.dogeitpayout, "can\'t kek too much");\n', '        state.accounts[msg.sender].lastDogeIt = block.timestamp;\n', '        if((state.random + block.timestamp + block.number) % state.odds == 0) {\n', '            state.accounts[state.addresses.buyBonusPool].rTotal -= rAmount;\n', '            state.accounts[msg.sender].rTotal += rAmount;\n', '            emit Doge(msg.sender, amount);\n', '        } else {\n', '            state.accounts[msg.sender].rTotal -= rAmount;\n', '            state.accounts[state.addresses.buyBonusPool].rTotal += rAmount;\n', '            emit Kek(msg.sender, amount);\n', '        }\n', '    }\n', '\n', '    function handleTRV(address recipient, uint256 rate, TState ts, TxValue memory t) internal {\n', '        state.accounts[state.addresses.dogecity].rTotal += (t.operationalFee * rate);\n', '        if(ts == TState.Sell) {\n', '            state.accounts[state.addresses.buyBonusPool].rTotal += t.sellFee * rate;\n', '            state.accounts[state.addresses.buyBonusPool].tTotal += t.sellFee;\n', '        }\n', '        if(ts == TState.Buy) {\n', '            state.buys++;\n', '            uint256 br = t.buyFee * rate;\n', '            if(state.buys % state.divisors.buyCounter == 0) {\n', '                uint256 a = state.accounts[state.addresses.prizePool].rTotal + (br);\n', '                state.accounts[state.addresses.prizePool].rTotal = 0;\n', '                state.accounts[state.addresses.prizePool].tTotal = 0;\n', '                state.accounts[recipient].rTotal += a;\n', '                emit Winner(recipient, a);\n', '            } else {\n', '                state.accounts[state.addresses.prizePool].rTotal += br;\n', '                state.accounts[state.addresses.prizePool].tTotal += t.buyFee;\n', '            }\n', '            uint256 r = t.buyBonus * rate;\n', '            state.accounts[state.addresses.buyBonusPool].rTotal -= r;\n', '            state.accounts[state.addresses.buyBonusPool].tTotal -= t.buyBonus;\n', '            state.accounts[recipient].rTotal += r;\n', '            emit BonusAwarded(recipient, t.buyBonus);\n', '        }\n', '    }\n', '\n', '    function tValues(address sender, address recipient, uint256 amount, bool noFee, uint256 lpAmount) public view returns (TxValue memory t, TState ts, TxType txType) {\n', '        ts = getTState(sender, recipient, lpAmount);\n', '        txType = getTxType(sender, recipient);\n', '        t.amount = amount;\n', '        if(!noFee) {\n', '            t.fee = getFee(amount, state.divisors.tx);\n', '            t.operationalFee = getFee(amount, state.divisors.dogecity);\n', '            if(ts == TState.Sell) {\n', '                uint256 sellFee = getFee(amount, state.divisors.sell);\n', '                uint256 sellLevel = sellFee == 0 ? 0 : ((sellFee * getLevel(sender)) / levelCap);\n', '                t.sellFee = sellFee - sellLevel;\n', '            }\n', '            if(ts == TState.Buy) {\n', '                t.buyFee = getFee(amount, getBuyTax(amount));\n', '                uint256 bonus = getBuyBonus(amount);\n', '                uint256 levelBonus = bonus == 0 ? 0 : ((bonus * getLevel(recipient)) / levelCap);\n', '                t.buyBonus = bonus + levelBonus;\n', '            }\n', '        }\n', '        t.transferAmount = t.amount - t.fee - t.sellFee - t.buyFee - t.operationalFee;\n', '        return (t, ts, txType);\n', '    }\n', '\n', '    function include(address account) external ownerOnly {\n', '        require(state.accounts[account].excluded, "Account is already excluded");\n', '        state.accounts[account].tTotal = 0;\n', '        EnumerableSet.remove(state.excludedAccounts, account);\n', '    }\n', '\n', '    function exclude(address account) external ownerOnly {\n', '        require(!state.accounts[account].excluded, "Account is already excluded");\n', '        state.accounts[account].excluded = true;\n', '        if(state.accounts[account].rTotal > 0) {\n', '            state.accounts[account].tTotal = state.accounts[account].rTotal / ratio();\n', '        }\n', '        state.accounts[account].excluded = true;\n', '        EnumerableSet.add(state.excludedAccounts, account);\n', '    }\n', '\n', '    function syncPool() public  {\n', '        IUniswapV2Pair(state.addresses.pool).sync();\n', '    }\n', '\n', '    function enableTrading() external ownerOnly {\n', '        state.paused = false;\n', '    }\n', '\n', '    function adjustOdds(uint8 odds) external ownerOnly {\n', '        require(odds >= 2, "can\'t be more than 50/50");\n', '        state.odds = odds;\n', '    }\n', '\n', '    function setPresale(address account) external ownerOnly {\n', '        if(!presaleSet) {\n', '            state.addresses.presale = account;\n', '            state.accounts[account].feeless = true;\n', '            presaleSet = true;\n', '        }\n', '    }\n', '\n', '    function setBuyBonusDivisor(uint8 fd) external ownerOnly {\n', '        require(fd >= 20, "can\'t be more than 5%");\n', '        state.divisors.bonus = fd;\n', '    }\n', '\n', '    function setMinBuyForBuyBonus(uint256 amount) external ownerOnly {\n', '        require(amount > 10000e18, "can\'t be less than 10k tokens");\n', '        state.minBuyForBonus = amount * (10 ** state.decimals); \n', '    }\n', '\n', '    function setFeeless(address account, bool value) external ownerOnly {\n', '        state.accounts[account].feeless = value;\n', '    }\n', '\n', '    function setBuyFee(uint8 fd) external ownerOnly {\n', '        require(fd >= 20, "can\'t be more than 5%");\n', '        state.divisors.buy = fd;\n', '    }\n', '\n', '    function setSellFee(uint8 fd) external ownerOnly {\n', '        require(fd >= 10, "can\'t be more than 10%");\n', '        state.divisors.sell = fd;\n', '    }\n', '\n', '    function setFarm(address farm) external ownerOnly {\n', '        require(state.addresses.farm == address(0), "farm already set");\n', '        uint256 _codeLength;\n', '        assembly {_codeLength := extcodesize(farm)}\n', '        require(_codeLength > 0, "must be a contract");\n', '        state.addresses.farm = farm;\n', '        emit FarmAdded(farm);\n', '    }\n', '\n', '    function setRandomSeed(uint256 random) override external {\n', '        if(!rngSet){\n', '            require(msg.sender == owner(), "not valid caller"); // once chainlink is set random can\'t be called by owner\n', '        } else {\n', '            require(msg.sender == state.addresses.rng, "not valid caller"); // for chainlink VRF\n', '        }\n', '        require(state.random != random, "can\'t use the same one twice");\n', '        state.random = random;\n', '    }\n', '\n', '    function setRngAddr(address addr) external ownerOnly {\n', '        state.addresses.rng = addr;\n', '        rngSet = true;\n', '    }\n', '\n', '    function setLevelCap(uint256 l) external ownerOnly {\n', '        require(l >= 10 && l <= 100, "can\'t be lower than 10 or greater than 100");\n', '        levelCap = l;\n', '    }\n', '\n', '    function setCooldown(uint256 timeInSeconds) external ownerOnly {\n', '        require(timeInSeconds > 1 minutes, "too short a time");\n', '        state.attackCooldown = timeInSeconds;\n', '    }\n', '\n', '    function setBuyCounter(uint8 counter) external ownerOnly {\n', '        require(counter > 5, "too few people");\n', '        state.divisors.buyCounter = counter;\n', '    }\n', '\n', '    function setDogeItCooldown(uint256 time) external ownerOnly {\n', '        require(time > 5 minutes, "too quick");\n', '        state.divisors.dogeify = time;\n', '    }\n', '\n', '    function setTokenLPBurn(uint8 fd) external ownerOnly {\n', '        require(fd > 20, "can\'t be more than 5%");\n', '        state.divisors.tokenLPBurn = fd;\n', '    }\n', '\n', '    function setInflation(uint8 fd) external ownerOnly {\n', '        require(fd > 20, "can\'t be more than 5%");\n', '        state.divisors.inflate = fd;\n', '    }\n', '\n', '    function setDogeItPayoutLimit(uint8 fd) external ownerOnly {\n', '        require(fd >= 50, "can\'t be more than 2% of the buy bonus supply");\n', '        state.divisors.dogeitpayout = fd;\n', '    }\n', '\n', '    function setAdmin(address account, bool value) external ownerOnly {\n', '        admins[account] = value;\n', '    }\n', '\n', '    function setDogeCityDivisor(uint8 fd) external ownerOnly {\n', '        require(fd >= 50, "can\'t be more than 2%");\n', '        state.divisors.dogecity = fd;\n', '    }\n', '\n', '}']