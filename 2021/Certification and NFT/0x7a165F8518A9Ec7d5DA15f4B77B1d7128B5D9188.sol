['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', '// hevm: flattened sources of ./contracts/pcv/EthUniswapPCVController.sol\n', 'pragma solidity >=0.4.0 >=0.5.0 >=0.6.0 >=0.6.2 >=0.6.0 <0.7.0 >=0.6.0 <0.8.0 >=0.6.2 <0.7.0 >=0.6.2 <0.8.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '////// ./contracts/core/IPermissions.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/// @title Permissions interface\n', '/// @author Fei Protocol\n', 'interface IPermissions {\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function createRole(bytes32 role, bytes32 adminRole) external;\n', '\n', '    function grantMinter(address minter) external;\n', '\n', '    function grantBurner(address burner) external;\n', '\n', '    function grantPCVController(address pcvController) external;\n', '\n', '    function grantGovernor(address governor) external;\n', '\n', '    function grantGuardian(address guardian) external;\n', '\n', '    function revokeMinter(address minter) external;\n', '\n', '    function revokeBurner(address burner) external;\n', '\n', '    function revokePCVController(address pcvController) external;\n', '\n', '    function revokeGovernor(address governor) external;\n', '\n', '    function revokeGuardian(address guardian) external;\n', '\n', '    // ----------- Revoker only state changing api -----------\n', '\n', '    function revokeOverride(bytes32 role, address account) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function isBurner(address _address) external view returns (bool);\n', '\n', '    function isMinter(address _address) external view returns (bool);\n', '\n', '    function isGovernor(address _address) external view returns (bool);\n', '\n', '    function isGuardian(address _address) external view returns (bool);\n', '\n', '    function isPCVController(address _address) external view returns (bool);\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/token/ERC20/IERC20.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20_5 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '////// ./contracts/token/IFei.sol\n', '/* pragma solidity ^0.6.2; */\n', '\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/token/ERC20/IERC20.sol"; */\n', '\n', '/// @title FEI stablecoin interface\n', '/// @author Fei Protocol\n', 'interface IFei is IERC20_5 {\n', '    // ----------- Events -----------\n', '\n', '    event Minting(\n', '        address indexed _to,\n', '        address indexed _minter,\n', '        uint256 _amount\n', '    );\n', '\n', '    event Burning(\n', '        address indexed _to,\n', '        address indexed _burner,\n', '        uint256 _amount\n', '    );\n', '\n', '    event IncentiveContractUpdate(\n', '        address indexed _incentivized,\n', '        address indexed _incentiveContract\n', '    );\n', '\n', '    // ----------- State changing api -----------\n', '\n', '    function burn(uint256 amount) external;\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    // ----------- Burner only state changing api -----------\n', '\n', '    function burnFrom(address account, uint256 amount) external;\n', '\n', '    // ----------- Minter only state changing api -----------\n', '\n', '    function mint(address account, uint256 amount) external;\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setIncentiveContract(address account, address incentive) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function incentiveContract(address account) external view returns (address);\n', '}\n', '\n', '////// ./contracts/core/ICore.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./IPermissions.sol"; */\n', '/* import "../token/IFei.sol"; */\n', '\n', '/// @title Core Interface\n', '/// @author Fei Protocol\n', 'interface ICore is IPermissions {\n', '    // ----------- Events -----------\n', '\n', '    event FeiUpdate(address indexed _fei);\n', '    event TribeUpdate(address indexed _tribe);\n', '    event GenesisGroupUpdate(address indexed _genesisGroup);\n', '    event TribeAllocation(address indexed _to, uint256 _amount);\n', '    event GenesisPeriodComplete(uint256 _timestamp);\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function init() external;\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setFei(address token) external;\n', '\n', '    function setTribe(address token) external;\n', '\n', '    function setGenesisGroup(address _genesisGroup) external;\n', '\n', '    function allocateTribe(address to, uint256 amount) external;\n', '\n', '    // ----------- Genesis Group only state changing api -----------\n', '\n', '    function completeGenesisGroup() external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function fei() external view returns (IFei);\n', '\n', '    function tribe() external view returns (IERC20_5);\n', '\n', '    function genesisGroup() external view returns (address);\n', '\n', '    function hasGenesisGroupCompleted() external view returns (bool);\n', '}\n', '\n', '////// ./contracts/external/SafeMathCopy.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity ^0.6.0; */\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMathCopy { // To avoid namespace collision between openzeppelin safemath and uniswap safemath\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '////// ./contracts/external/Decimal.sol\n', '/*\n', '    Copyright 2019 dYdX Trading Inc.\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./SafeMathCopy.sol"; */\n', '\n', '/**\n', ' * @title Decimal\n', ' * @author dYdX\n', ' *\n', ' * Library that defines a fixed-point number with 18 decimal places.\n', ' */\n', 'library Decimal {\n', '    using SafeMathCopy for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 private constant BASE = 10**18;\n', '\n', '    // ============ Structs ============\n', '\n', '\n', '    struct D256 {\n', '        uint256 value;\n', '    }\n', '\n', '    // ============ Static Functions ============\n', '\n', '    function zero()\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: 0 });\n', '    }\n', '\n', '    function one()\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: BASE });\n', '    }\n', '\n', '    function from(\n', '        uint256 a\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: a.mul(BASE) });\n', '    }\n', '\n', '    function ratio(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(a, BASE, b) });\n', '    }\n', '\n', '    // ============ Self Functions ============\n', '\n', '    function add(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.add(b.mul(BASE)) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.mul(BASE)) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        uint256 b,\n', '        string memory reason\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.mul(BASE), reason) });\n', '    }\n', '\n', '    function mul(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.mul(b) });\n', '    }\n', '\n', '    function div(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.div(b) });\n', '    }\n', '\n', '    function pow(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        if (b == 0) {\n', '            return from(1);\n', '        }\n', '\n', '        D256 memory temp = D256({ value: self.value });\n', '        for (uint256 i = 1; i < b; i++) {\n', '            temp = mul(temp, self);\n', '        }\n', '\n', '        return temp;\n', '    }\n', '\n', '    function add(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.add(b.value) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.value) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        D256 memory b,\n', '        string memory reason\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.value, reason) });\n', '    }\n', '\n', '    function mul(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(self.value, b.value, BASE) });\n', '    }\n', '\n', '    function div(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(self.value, BASE, b.value) });\n', '    }\n', '\n', '    function equals(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return self.value == b.value;\n', '    }\n', '\n', '    function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) == 2;\n', '    }\n', '\n', '    function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) == 0;\n', '    }\n', '\n', '    function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) > 0;\n', '    }\n', '\n', '    function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) < 2;\n', '    }\n', '\n', '    function isZero(D256 memory self) internal pure returns (bool) {\n', '        return self.value == 0;\n', '    }\n', '\n', '    function asUint256(D256 memory self) internal pure returns (uint256) {\n', '        return self.value.div(BASE);\n', '    }\n', '\n', '    // ============ Core Methods ============\n', '\n', '    function getPartial(\n', '        uint256 target,\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '    private\n', '    pure\n', '    returns (uint256)\n', '    {\n', '        return target.mul(numerator).div(denominator);\n', '    }\n', '\n', '    function compareTo(\n', '        D256 memory a,\n', '        D256 memory b\n', '    )\n', '    private\n', '    pure\n', '    returns (uint256)\n', '    {\n', '        if (a.value == b.value) {\n', '            return 1;\n', '        }\n', '        return a.value > b.value ? 2 : 0;\n', '    }\n', '}\n', '////// ./contracts/external/UniswapV2Library.sol\n', ' /* pragma solidity >=0.6.0; */\n', '\n', ' /* import "./SafeMathCopy.sol"; */\n', '\n', ' library UniswapV2Library_2 {\n', '    using SafeMathCopy for uint;\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', ' }\n', '////// ./contracts/oracle/IOracle.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "../external/Decimal.sol"; */\n', '\n', '/// @title generic oracle interface for Fei Protocol\n', '/// @author Fei Protocol\n', 'interface IOracle {\n', '    // ----------- Events -----------\n', '\n', '    event Update(uint256 _peg);\n', '\n', '    // ----------- State changing API -----------\n', '\n', '    function update() external returns (bool);\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function read() external view returns (Decimal.D256 memory, bool);\n', '\n', '    function isOutdated() external view returns (bool);\n', '\n', '}\n', '\n', '////// ./contracts/pcv/IPCVDeposit.sol\n', '/* pragma solidity ^0.6.2; */\n', '\n', '/// @title a PCV Deposit interface\n', '/// @author Fei Protocol\n', 'interface IPCVDeposit {\n', '    // ----------- Events -----------\n', '    event Deposit(address indexed _from, uint256 _amount);\n', '\n', '    event Withdrawal(\n', '        address indexed _caller,\n', '        address indexed _to,\n', '        uint256 _amount\n', '    );\n', '\n', '    // ----------- State changing api -----------\n', '\n', '    function deposit(uint256 amount) external payable;\n', '\n', '    // ----------- PCV Controller only state changing api -----------\n', '\n', '    function withdraw(address to, uint256 amount) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function totalValue() external view returns (uint256);\n', '}\n', '\n', '////// ./contracts/token/IIncentive.sol\n', '/* pragma solidity ^0.6.2; */\n', '\n', '/// @title incentive contract interface\n', '/// @author Fei Protocol\n', '/// @notice Called by FEI token contract when transferring with an incentivized address\n', '/// @dev should be appointed as a Minter or Burner as needed\n', 'interface IIncentive {\n', '    // ----------- Fei only state changing api -----------\n', '\n', '    /// @notice apply incentives on transfer\n', '    /// @param sender the sender address of the FEI\n', '    /// @param receiver the receiver address of the FEI\n', '    /// @param operator the operator (msg.sender) of the transfer\n', '    /// @param amount the amount of FEI transferred\n', '    function incentivize(\n', '        address sender,\n', '        address receiver,\n', '        address operator,\n', '        uint256 amount\n', '    ) external;\n', '}\n', '\n', '////// ./contracts/token/IUniswapIncentive.sol\n', '/* pragma solidity ^0.6.2; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./IIncentive.sol"; */\n', '/* import "../external/Decimal.sol"; */\n', '\n', '/// @title UniswapIncentive interface\n', '/// @author Fei Protocol\n', 'interface IUniswapIncentive is IIncentive {\n', '    // ----------- Events -----------\n', '\n', '    event TimeWeightUpdate(uint256 _weight, bool _active);\n', '\n', '    event GrowthRateUpdate(uint256 _growthRate);\n', '\n', '    event ExemptAddressUpdate(address indexed _account, bool _isExempt);\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setExemptAddress(address account, bool isExempt) external;\n', '\n', '    function setTimeWeightGrowth(uint32 growthRate) external;\n', '\n', '    function setTimeWeight(\n', '        uint32 weight,\n', '        uint32 growth,\n', '        bool active\n', '    ) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function isIncentiveParity() external view returns (bool);\n', '\n', '    function isExemptAddress(address account) external view returns (bool);\n', '\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function TIME_WEIGHT_GRANULARITY() external view returns (uint32);\n', '\n', '    function getGrowthRate() external view returns (uint32);\n', '\n', '    function getTimeWeight() external view returns (uint32);\n', '\n', '    function isTimeWeightActive() external view returns (bool);\n', '\n', '    function getBuyIncentive(uint256 amount)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 incentive,\n', '            uint32 weight,\n', '            Decimal.D256 memory initialDeviation,\n', '            Decimal.D256 memory finalDeviation\n', '        );\n', '\n', '    function getSellPenalty(uint256 amount)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 penalty,\n', '            Decimal.D256 memory initialDeviation,\n', '            Decimal.D256 memory finalDeviation\n', '        );\n', '\n', '    function getSellPenaltyMultiplier(\n', '        Decimal.D256 calldata initialDeviation,\n', '        Decimal.D256 calldata finalDeviation\n', '    ) external view returns (Decimal.D256 memory);\n', '\n', '    function getBuyIncentiveMultiplier(\n', '        Decimal.D256 calldata initialDeviation,\n', '        Decimal.D256 calldata finalDeviation\n', '    ) external view returns (Decimal.D256 memory);\n', '}\n', '\n', '////// ./contracts/pcv/IUniswapPCVController.sol\n', '/* pragma solidity ^0.6.2; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./IPCVDeposit.sol"; */\n', '/* import "../token/IUniswapIncentive.sol"; */\n', '\n', '/// @title a Uniswap PCV Controller interface\n', '/// @author Fei Protocol\n', 'interface IUniswapPCVController {\n', '    // ----------- Events -----------\n', '\n', '    event Reweight(address indexed _caller);\n', '\n', '    event PCVDepositUpdate(address indexed _pcvDeposit);\n', '\n', '    event ReweightIncentiveUpdate(uint256 _amount);\n', '\n', '    event ReweightMinDistanceUpdate(uint256 _basisPoints);\n', '\n', '    event ReweightWithdrawBPsUpdate(uint256 _reweightWithdrawBPs);\n', '\n', '    // ----------- State changing API -----------\n', '\n', '    function reweight() external;\n', '\n', '    // ----------- Governor only state changing API -----------\n', '\n', '    function forceReweight() external;\n', '\n', '    function setPCVDeposit(address _pcvDeposit) external;\n', '\n', '    function setReweightIncentive(uint256 amount) external;\n', '\n', '    function setReweightMinDistance(uint256 basisPoints) external;\n', '\n', '    function setReweightWithdrawBPs(uint256 _reweightWithdrawBPs) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function pcvDeposit() external view returns (IPCVDeposit);\n', '\n', '    function incentiveContract() external view returns (IUniswapIncentive);\n', '\n', '    function reweightIncentiveAmount() external view returns (uint256);\n', '\n', '    function reweightEligible() external view returns (bool);\n', '\n', '    function reweightWithdrawBPs() external view returns (uint256);\n', '\n', '    function minDistanceForReweight()\n', '        external\n', '        view\n', '        returns (Decimal.D256 memory);\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\n', '/* pragma solidity >=0.5.0; */\n', '\n', 'interface IUniswapV2Pair_3 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\n', '/* pragma solidity >=0.6.2; */\n', '\n', 'interface IUniswapV2Router01_2 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\n', '/* pragma solidity >=0.6.2; */\n', '\n', "/* import './IUniswapV2Router01.sol'; */\n", '\n', 'interface IUniswapV2Router02_2 is IUniswapV2Router01_2 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', '////// ./contracts/refs/IUniRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/token/ERC20/IERC20.sol"; */\n', '/* import "../external/Decimal.sol"; */\n', '\n', '/// @title UniRef interface\n', '/// @author Fei Protocol\n', 'interface IUniRef {\n', '    // ----------- Events -----------\n', '\n', '    event PairUpdate(address indexed _pair);\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setPair(address _pair) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function router() external view returns (IUniswapV2Router02_2);\n', '\n', '    function pair() external view returns (IUniswapV2Pair_3);\n', '\n', '    function token() external view returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (uint256 feiReserves, uint256 tokenReserves);\n', '\n', '    function deviationBelowPeg(\n', '        Decimal.D256 calldata price,\n', '        Decimal.D256 calldata peg\n', '    ) external pure returns (Decimal.D256 memory);\n', '\n', '    function liquidityOwned() external view returns (uint256);\n', '}\n', '\n', '////// ./contracts/refs/ICoreRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "../core/ICore.sol"; */\n', '\n', '/// @title CoreRef interface\n', '/// @author Fei Protocol\n', 'interface ICoreRef {\n', '    // ----------- Events -----------\n', '\n', '    event CoreUpdate(address indexed _core);\n', '\n', '    // ----------- Governor only state changing api -----------\n', '\n', '    function setCore(address core) external;\n', '\n', '    function pause() external;\n', '\n', '    function unpause() external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function core() external view returns (ICore);\n', '\n', '    function fei() external view returns (IFei);\n', '\n', '    function tribe() external view returns (IERC20_5);\n', '\n', '    function feiBalance() external view returns (uint256);\n', '\n', '    function tribeBalance() external view returns (uint256);\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Address.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.2 <0.8.0; */\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address_2 {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Context.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context_2 {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Pausable.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/* import "./Context.sol"; */\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'abstract contract Pausable_2 is Context_2 {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state.\n', '     */\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view virtual returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused(), "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused(), "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', '////// ./contracts/refs/CoreRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./ICoreRef.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Pausable.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/Address.sol"; */\n', '\n', '/// @title A Reference to Core\n', '/// @author Fei Protocol\n', '/// @notice defines some modifiers and utilities around interacting with Core\n', 'abstract contract CoreRef is ICoreRef, Pausable_2 {\n', '    ICore private _core;\n', '\n', '    /// @notice CoreRef constructor\n', '    /// @param core Fei Core to reference\n', '    constructor(address core) public {\n', '        _core = ICore(core);\n', '    }\n', '\n', '    modifier ifMinterSelf() {\n', '        if (_core.isMinter(address(this))) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier ifBurnerSelf() {\n', '        if (_core.isBurner(address(this))) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(_core.isMinter(msg.sender), "CoreRef: Caller is not a minter");\n', '        _;\n', '    }\n', '\n', '    modifier onlyBurner() {\n', '        require(_core.isBurner(msg.sender), "CoreRef: Caller is not a burner");\n', '        _;\n', '    }\n', '\n', '    modifier onlyPCVController() {\n', '        require(\n', '            _core.isPCVController(msg.sender),\n', '            "CoreRef: Caller is not a PCV controller"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyGovernor() {\n', '        require(\n', '            _core.isGovernor(msg.sender),\n', '            "CoreRef: Caller is not a governor"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyGuardianOrGovernor() {\n', '        require(\n', '            _core.isGovernor(msg.sender) ||\n', '            _core.isGuardian(msg.sender),\n', '            "CoreRef: Caller is not a guardian or governor"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyFei() {\n', '        require(msg.sender == address(fei()), "CoreRef: Caller is not FEI");\n', '        _;\n', '    }\n', '\n', '    modifier onlyGenesisGroup() {\n', '        require(\n', '            msg.sender == _core.genesisGroup(),\n', '            "CoreRef: Caller is not GenesisGroup"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier postGenesis() {\n', '        require(\n', '            _core.hasGenesisGroupCompleted(),\n', '            "CoreRef: Still in Genesis Period"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier nonContract() {\n', '        require(!Address_2.isContract(msg.sender), "CoreRef: Caller is a contract");\n', '        _;\n', '    }\n', '\n', '    /// @notice set new Core reference address\n', '    /// @param core the new core address\n', '    function setCore(address core) external override onlyGovernor {\n', '        _core = ICore(core);\n', '        emit CoreUpdate(core);\n', '    }\n', '\n', '    /// @notice set pausable methods to paused\n', '    function pause() public override onlyGuardianOrGovernor {\n', '        _pause();\n', '    }\n', '\n', '    /// @notice set pausable methods to unpaused\n', '    function unpause() public override onlyGuardianOrGovernor {\n', '        _unpause();\n', '    }\n', '\n', '    /// @notice address of the Core contract referenced\n', '    /// @return ICore implementation address\n', '    function core() public view override returns (ICore) {\n', '        return _core;\n', '    }\n', '\n', '    /// @notice address of the Fei contract referenced by Core\n', '    /// @return IFei implementation address\n', '    function fei() public view override returns (IFei) {\n', '        return _core.fei();\n', '    }\n', '\n', '    /// @notice address of the Tribe contract referenced by Core\n', '    /// @return IERC20 implementation address\n', '    function tribe() public view override returns (IERC20_5) {\n', '        return _core.tribe();\n', '    }\n', '\n', '    /// @notice fei balance of contract\n', '    /// @return fei amount held\n', '    function feiBalance() public view override returns (uint256) {\n', '        return fei().balanceOf(address(this));\n', '    }\n', '\n', '    /// @notice tribe balance of contract\n', '    /// @return tribe amount held\n', '    function tribeBalance() public view override returns (uint256) {\n', '        return tribe().balanceOf(address(this));\n', '    }\n', '\n', '    function _burnFeiHeld() internal {\n', '        fei().burn(feiBalance());\n', '    }\n', '\n', '    function _mintFei(uint256 amount) internal {\n', '        fei().mint(address(this), amount);\n', '    }\n', '}\n', '\n', '////// ./contracts/refs/IOracleRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "../oracle/IOracle.sol"; */\n', '\n', '/// @title OracleRef interface\n', '/// @author Fei Protocol\n', 'interface IOracleRef {\n', '    // ----------- Events -----------\n', '\n', '    event OracleUpdate(address indexed _oracle);\n', '\n', '    // ----------- State changing API -----------\n', '\n', '    function updateOracle() external returns (bool);\n', '\n', '    // ----------- Governor only state changing API -----------\n', '\n', '    function setOracle(address _oracle) external;\n', '\n', '    // ----------- Getters -----------\n', '\n', '    function oracle() external view returns (IOracle);\n', '\n', '    function peg() external view returns (Decimal.D256 memory);\n', '\n', '    function invert(Decimal.D256 calldata price)\n', '        external\n', '        pure\n', '        returns (Decimal.D256 memory);\n', '}\n', '\n', '////// ./contracts/refs/OracleRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "./IOracleRef.sol"; */\n', '/* import "./CoreRef.sol"; */\n', '\n', '/// @title Reference to an Oracle\n', '/// @author Fei Protocol\n', '/// @notice defines some utilities around interacting with the referenced oracle\n', 'abstract contract OracleRef is IOracleRef, CoreRef {\n', '    using Decimal for Decimal.D256;\n', '\n', '    /// @notice the oracle reference by the contract\n', '    IOracle public override oracle;\n', '\n', '    /// @notice OracleRef constructor\n', '    /// @param _core Fei Core to reference\n', '    /// @param _oracle oracle to reference\n', '    constructor(address _core, address _oracle) public CoreRef(_core) {\n', '        _setOracle(_oracle);\n', '    }\n', '\n', '    /// @notice sets the referenced oracle\n', '    /// @param _oracle the new oracle to reference\n', '    function setOracle(address _oracle) external override onlyGovernor {\n', '        _setOracle(_oracle);\n', '    }\n', '\n', '    /// @notice invert a peg price\n', '    /// @param price the peg price to invert\n', '    /// @return the inverted peg as a Decimal\n', '    /// @dev the inverted peg would be X per FEI\n', '    function invert(Decimal.D256 memory price)\n', '        public\n', '        pure\n', '        override\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        return Decimal.one().div(price);\n', '    }\n', '\n', '    /// @notice updates the referenced oracle\n', '    /// @return true if the update is effective\n', '    function updateOracle() public override returns (bool) {\n', '        return oracle.update();\n', '    }\n', '\n', '    /// @notice the peg price of the referenced oracle\n', '    /// @return the peg as a Decimal\n', '    /// @dev the peg is defined as FEI per X with X being ETH, dollars, etc\n', '    function peg() public view override returns (Decimal.D256 memory) {\n', '        (Decimal.D256 memory _peg, bool valid) = oracle.read();\n', '        require(valid, "OracleRef: oracle invalid");\n', '        return _peg;\n', '    }\n', '\n', '    function _setOracle(address _oracle) internal {\n', '        oracle = IOracle(_oracle);\n', '        emit OracleUpdate(_oracle);\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/math/SignedSafeMath.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/**\n', ' * @title SignedSafeMath\n', ' * @dev Signed math operations with safety checks that revert on error.\n', ' */\n', 'library SignedSafeMath_2 {\n', '    int256 constant private _INT256_MIN = -2**255;\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(int256 a, int256 b) internal pure returns (int256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        require(!(a == -1 && b == _INT256_MIN), "SignedSafeMath: multiplication overflow");\n', '\n', '        int256 c = a * b;\n', '        require(c / a == b, "SignedSafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two signed integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(int256 a, int256 b) internal pure returns (int256) {\n', '        require(b != 0, "SignedSafeMath: division by zero");\n', '        require(!(b == -1 && a == _INT256_MIN), "SignedSafeMath: division overflow");\n', '\n', '        int256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a), "SignedSafeMath: subtraction overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two signed integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(int256 a, int256 b) internal pure returns (int256) {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a), "SignedSafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/SafeCast.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast_2 {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/lib/contracts/libraries/Babylonian.sol\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', '/* pragma solidity >=0.4.0; */\n', '\n', '// computes square roots using the babylonian method\n', '// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n', 'library Babylonian_3 {\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '        // else z = 0\n', '    }\n', '}\n', '\n', '////// ./contracts/refs/UniRef.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/math/SignedSafeMath.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/utils/SafeCast.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/lib/contracts/libraries/Babylonian.sol"; */\n', '/* import "./OracleRef.sol"; */\n', '/* import "./IUniRef.sol"; */\n', '\n', '/// @title A Reference to Uniswap\n', '/// @author Fei Protocol\n', '/// @notice defines some modifiers and utilities around interacting with Uniswap\n', '/// @dev the uniswap pair should be FEI and another asset\n', 'abstract contract UniRef is IUniRef, OracleRef {\n', '    using Decimal for Decimal.D256;\n', '    using Babylonian_3 for uint256;\n', '    using SignedSafeMath_2 for int256;\n', '    using SafeMathCopy for uint256;\n', '    using SafeCast_2 for uint256;\n', '    using SafeCast_2 for int256;\n', '\n', '    /// @notice the Uniswap router contract\n', '    IUniswapV2Router02_2 public override router;\n', '\n', '    /// @notice the referenced Uniswap pair contract\n', '    IUniswapV2Pair_3 public override pair;\n', '\n', '    /// @notice UniRef constructor\n', '    /// @param _core Fei Core to reference\n', '    /// @param _pair Uniswap pair to reference\n', '    /// @param _router Uniswap Router to reference\n', '    /// @param _oracle oracle to reference\n', '    constructor(\n', '        address _core,\n', '        address _pair,\n', '        address _router,\n', '        address _oracle\n', '    ) public OracleRef(_core, _oracle) {\n', '        _setupPair(_pair);\n', '\n', '        router = IUniswapV2Router02_2(_router);\n', '\n', '        _approveToken(address(fei()));\n', '        _approveToken(token());\n', '        _approveToken(_pair);\n', '    }\n', '\n', '    /// @notice set the new pair contract\n', '    /// @param _pair the new pair\n', '    /// @dev also approves the router for the new pair token and underlying token\n', '    function setPair(address _pair) external override onlyGovernor {\n', '        _setupPair(_pair);\n', '\n', '        _approveToken(token());\n', '        _approveToken(_pair);\n', '    }\n', '\n', '    /// @notice the address of the non-fei underlying token\n', '    function token() public view override returns (address) {\n', '        address token0 = pair.token0();\n', '        if (address(fei()) == token0) {\n', '            return pair.token1();\n', '        }\n', '        return token0;\n', '    }\n', '\n', '    /// @notice pair reserves with fei listed first\n', '    /// @dev uses the max of pair fei balance and fei reserves. Mitigates attack vectors which manipulate the pair balance\n', '    function getReserves()\n', '        public\n', '        view\n', '        override\n', '        returns (uint256 feiReserves, uint256 tokenReserves)\n', '    {\n', '        address token0 = pair.token0();\n', '        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n', '        (feiReserves, tokenReserves) = address(fei()) == token0\n', '            ? (reserve0, reserve1)\n', '            : (reserve1, reserve0);\n', '        return (feiReserves, tokenReserves);\n', '    }\n', '\n', '    /// @notice get deviation from peg as a percent given price\n', '    /// @dev will return Decimal.zero() if above peg\n', '    function deviationBelowPeg(\n', '        Decimal.D256 calldata price,\n', '        Decimal.D256 calldata peg\n', '    ) external pure override returns (Decimal.D256 memory) {\n', '        return _deviationBelowPeg(price, peg);\n', '    }\n', '\n', '    /// @notice amount of pair liquidity owned by this contract\n', '    /// @return amount of LP tokens\n', '    function liquidityOwned() public view override returns (uint256) {\n', '        return pair.balanceOf(address(this));\n', '    }\n', '\n', '    /// @notice ratio of all pair liquidity owned by this contract\n', '    function _ratioOwned() internal view returns (Decimal.D256 memory) {\n', '        uint256 balance = liquidityOwned();\n', '        uint256 total = pair.totalSupply();\n', '        return Decimal.ratio(balance, total);\n', '    }\n', '\n', '    /// @notice returns true if price is below the peg\n', '    /// @dev counterintuitively checks if peg < price because price is reported as FEI per X\n', '    function _isBelowPeg(Decimal.D256 memory peg) internal view returns (bool) {\n', '        (Decimal.D256 memory price, , ) = _getUniswapPrice();\n', '        return peg.lessThan(price);\n', '    }\n', '\n', '    /// @notice approves a token for the router\n', '    function _approveToken(address _token) internal {\n', '        uint256 maxTokens = uint256(-1);\n', '        IERC20_5(_token).approve(address(router), maxTokens);\n', '    }\n', '\n', '    function _setupPair(address _pair) internal {\n', '        pair = IUniswapV2Pair_3(_pair);\n', '        emit PairUpdate(_pair);\n', '    }\n', '\n', '    function _isPair(address account) internal view returns (bool) {\n', '        return address(pair) == account;\n', '    }\n', '\n', '    /// @notice utility for calculating absolute distance from peg based on reserves\n', '    /// @param reserveTarget pair reserves of the asset desired to trade with\n', '    /// @param reserveOther pair reserves of the non-traded asset\n', '    /// @param peg the target peg reported as Target per Other\n', '    function _getAmountToPeg(\n', '        uint256 reserveTarget,\n', '        uint256 reserveOther,\n', '        Decimal.D256 memory peg\n', '    ) internal pure returns (uint256) {\n', '        uint256 radicand = peg.mul(reserveTarget).mul(reserveOther).asUint256();\n', '        uint256 root = radicand.sqrt();\n', '        if (root > reserveTarget) {\n', '            return (root - reserveTarget).mul(1000).div(997);\n', '        }\n', '        return (reserveTarget - root).mul(1000).div(997);\n', '    }\n', '\n', '    /// @notice calculate amount of Fei needed to trade back to the peg\n', '    function _getAmountToPegFei(\n', '        uint256 feiReserves,\n', '        uint256 tokenReserves,\n', '        Decimal.D256 memory peg\n', '    ) internal pure returns (uint256) {\n', '        return _getAmountToPeg(feiReserves, tokenReserves, peg);\n', '    }\n', '\n', '    /// @notice calculate amount of the not Fei token needed to trade back to the peg\n', '    function _getAmountToPegOther(\n', '        uint256 feiReserves,\n', '        uint256 tokenReserves,\n', '        Decimal.D256 memory peg\n', '    ) internal pure returns (uint256) {\n', '        return _getAmountToPeg(tokenReserves, feiReserves, invert(peg));\n', '    }\n', '\n', '    /// @notice get uniswap price and reserves\n', '    /// @return price reported as Fei per X\n', '    /// @return reserveFei fei reserves\n', '    /// @return reserveOther non-fei reserves\n', '    function _getUniswapPrice()\n', '        internal\n', '        view\n', '        returns (\n', '            Decimal.D256 memory,\n', '            uint256 reserveFei,\n', '            uint256 reserveOther\n', '        )\n', '    {\n', '        (reserveFei, reserveOther) = getReserves();\n', '        return (\n', '            Decimal.ratio(reserveFei, reserveOther),\n', '            reserveFei,\n', '            reserveOther\n', '        );\n', '    }\n', '\n', '    /// @notice get final uniswap price after hypothetical FEI trade\n', '    /// @param amountFei a signed integer representing FEI trade. Positive=sell, negative=buy\n', '    /// @param reserveFei fei reserves\n', '    /// @param reserveOther non-fei reserves\n', '    function _getFinalPrice(\n', '        int256 amountFei,\n', '        uint256 reserveFei,\n', '        uint256 reserveOther\n', '    ) internal pure returns (Decimal.D256 memory) {\n', '        uint256 k = reserveFei.mul(reserveOther);\n', '        int256 signedReservesFei = reserveFei.toInt256();\n', "        int256 amountFeiWithFee = amountFei > 0 ? amountFei.mul(997).div(1000) : amountFei; // buys already have fee factored in on uniswap's other token side\n", '\n', '        uint256 adjustedReserveFei = signedReservesFei.add(amountFeiWithFee).toUint256();\n', '        uint256 adjustedReserveOther = k / adjustedReserveFei;\n', '        return Decimal.ratio(adjustedReserveFei, adjustedReserveOther); // alt: adjustedReserveFei^2 / k\n', '    }\n', '\n', '    /// @notice return the percent distance from peg before and after a hypothetical trade\n', '    /// @param amountIn a signed amount of FEI to be traded. Positive=sell, negative=buy\n', '    /// @return initialDeviation the percent distance from peg before trade\n', '    /// @return finalDeviation the percent distance from peg after hypothetical trade\n', '    /// @dev deviations will return Decimal.zero() if above peg\n', '    function _getPriceDeviations(int256 amountIn)\n', '        internal\n', '        view\n', '        returns (\n', '            Decimal.D256 memory initialDeviation,\n', '            Decimal.D256 memory finalDeviation,\n', '            Decimal.D256 memory _peg,\n', '            uint256 feiReserves,\n', '            uint256 tokenReserves\n', '        )\n', '    {\n', '        _peg = peg();\n', '\n', '        (Decimal.D256 memory price, uint256 reserveFei, uint256 reserveOther) =\n', '            _getUniswapPrice();\n', '        initialDeviation = _deviationBelowPeg(price, _peg);\n', '\n', '        Decimal.D256 memory finalPrice =\n', '            _getFinalPrice(amountIn, reserveFei, reserveOther);\n', '        finalDeviation = _deviationBelowPeg(finalPrice, _peg);\n', '\n', '        return (\n', '            initialDeviation,\n', '            finalDeviation,\n', '            _peg,\n', '            reserveFei,\n', '            reserveOther\n', '        );\n', '    }\n', '\n', '    /// @notice return current percent distance from peg\n', '    /// @dev will return Decimal.zero() if above peg\n', '    function _getDistanceToPeg()\n', '        internal\n', '        view\n', '        returns (Decimal.D256 memory distance)\n', '    {\n', '        (Decimal.D256 memory price, , ) = _getUniswapPrice();\n', '        return _deviationBelowPeg(price, peg());\n', '    }\n', '\n', '    /// @notice get deviation from peg as a percent given price\n', '    /// @dev will return Decimal.zero() if above peg\n', '    function _deviationBelowPeg(\n', '        Decimal.D256 memory price,\n', '        Decimal.D256 memory peg\n', '    ) internal pure returns (Decimal.D256 memory) {\n', '        // If price <= peg, then FEI is more expensive and above peg\n', '        // In this case we can just return zero for deviation\n', '        if (price.lessThanOrEqualTo(peg)) {\n', '            return Decimal.zero();\n', '        }\n', '        Decimal.D256 memory delta = price.sub(peg, "Impossible underflow");\n', '        return delta.div(peg);\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/math/Math.sol\n', '// SPDX-License-Identifier: MIT\n', '\n', '/* pragma solidity >=0.6.0 <0.8.0; */\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math_4 {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '////// /home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/v2-periphery/contracts/interfaces/IWETH.sol\n', '/* pragma solidity >=0.5.0; */\n', '\n', 'interface IWETH_2 {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '}\n', '\n', '////// ./contracts/pcv/EthUniswapPCVController.sol\n', '/* pragma solidity ^0.6.0; */\n', '/* pragma experimental ABIEncoderV2; */\n', '\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/uniswap/v2-periphery/contracts/interfaces/IWETH.sol"; */\n', '/* import "/home/brock/git_pkgs/fei-protocol-core/contracts/openzeppelin/contracts/math/Math.sol"; */\n', '/* import "./IUniswapPCVController.sol"; */\n', '/* import "../refs/UniRef.sol"; */\n', '/* import "../external/UniswapV2Library.sol"; */\n', '\n', '/// @title a IUniswapPCVController implementation for ETH\n', '/// @author Fei Protocol\n', 'contract EthUniswapPCVController is IUniswapPCVController, UniRef {\n', '    using Decimal for Decimal.D256;\n', '    using SafeMathCopy for uint256;\n', '\n', '    uint256 public override reweightWithdrawBPs = 9900;\n', '\n', '    uint256 internal constant BASIS_POINTS_GRANULARITY = 10000;\n', '\n', '    /// @notice returns the linked pcv deposit contract\n', '    IPCVDeposit public override pcvDeposit;\n', '\n', '    /// @notice gets the FEI reward incentive for reweighting\n', '    uint256 public override reweightIncentiveAmount;\n', '    Decimal.D256 internal _minDistanceForReweight;\n', '\n', '    /// @notice EthUniswapPCVController constructor\n', '    /// @param _core Fei Core for reference\n', '    /// @param _pcvDeposit PCV Deposit to reweight\n', '    /// @param _oracle oracle for reference\n', '    /// @param _incentiveAmount amount of FEI for triggering a reweight\n', '    /// @param _minDistanceForReweightBPs minimum distance from peg to reweight in basis points\n', '    /// @param _pair Uniswap pair contract to reweight\n', '    /// @param _router Uniswap Router\n', '    constructor(\n', '        address _core,\n', '        address _pcvDeposit,\n', '        address _oracle,\n', '        uint256 _incentiveAmount,\n', '        uint256 _minDistanceForReweightBPs,\n', '        address _pair,\n', '        address _router\n', '    ) public UniRef(_core, _pair, _router, _oracle) {\n', '        pcvDeposit = IPCVDeposit(_pcvDeposit);\n', '\n', '        reweightIncentiveAmount = _incentiveAmount;\n', '        _minDistanceForReweight = Decimal.ratio(\n', '            _minDistanceForReweightBPs,\n', '            BASIS_POINTS_GRANULARITY\n', '        );\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    /// @notice reweights the linked PCV Deposit to the peg price. Needs to be reweight eligible\n', '    function reweight() external override postGenesis whenNotPaused nonContract {\n', '        updateOracle();\n', '        require(\n', '            reweightEligible(),\n', '            "EthUniswapPCVController: Not at incentive parity or not at min distance"\n', '        );\n', '        _reweight();\n', '        _incentivize();\n', '    }\n', '\n', '    /// @notice reweights regardless of eligibility\n', '    function forceReweight() external override onlyGuardianOrGovernor {\n', '        _reweight();\n', '    }\n', '\n', '    /// @notice sets the target PCV Deposit address\n', '    function setPCVDeposit(address _pcvDeposit) external override onlyGovernor {\n', '        pcvDeposit = IPCVDeposit(_pcvDeposit);\n', '        emit PCVDepositUpdate(_pcvDeposit);\n', '    }\n', '\n', '    /// @notice sets the reweight incentive amount\n', '    function setReweightIncentive(uint256 amount)\n', '        external\n', '        override\n', '        onlyGovernor\n', '    {\n', '        reweightIncentiveAmount = amount;\n', '        emit ReweightIncentiveUpdate(amount);\n', '    }\n', '\n', '    /// @notice sets the reweight withdrawal BPs\n', '    function setReweightWithdrawBPs(uint256 _reweightWithdrawBPs)\n', '        external\n', '        override\n', '        onlyGovernor\n', '    {\n', '        require(_reweightWithdrawBPs <= BASIS_POINTS_GRANULARITY, "EthUniswapPCVController: withdraw percent too high");\n', '        reweightWithdrawBPs = _reweightWithdrawBPs;\n', '        emit ReweightWithdrawBPsUpdate(_reweightWithdrawBPs);\n', '    }\n', '\n', '    /// @notice sets the reweight min distance in basis points\n', '    function setReweightMinDistance(uint256 basisPoints)\n', '        external\n', '        override\n', '        onlyGovernor\n', '    {\n', '        _minDistanceForReweight = Decimal.ratio(\n', '            basisPoints,\n', '            BASIS_POINTS_GRANULARITY\n', '        );\n', '        emit ReweightMinDistanceUpdate(basisPoints);\n', '    }\n', '\n', '    /// @notice signal whether the reweight is available. Must have incentive parity and minimum distance from peg\n', '    function reweightEligible() public view override returns (bool) {\n', '        bool magnitude =\n', '            _getDistanceToPeg().greaterThan(_minDistanceForReweight);\n', '        // incentive parity is achieved after a certain time relative to distance from peg\n', '        bool time = incentiveContract().isIncentiveParity();\n', '        return magnitude && time;\n', '    }\n', '\n', '    /// @notice minimum distance as a percentage from the peg for a reweight to be eligible\n', '    function minDistanceForReweight()\n', '        external\n', '        view\n', '        override\n', '        returns (Decimal.D256 memory)\n', '    {\n', '        return _minDistanceForReweight;\n', '    }\n', '\n', '    /// @notice returns the linked Uniswap incentive contract\n', '    function incentiveContract() public view override returns(IUniswapIncentive) {\n', '        return IUniswapIncentive(fei().incentiveContract(address(pair)));\n', '    }\n', '\n', '    function _incentivize() internal ifMinterSelf {\n', '        fei().mint(msg.sender, reweightIncentiveAmount);\n', '    }\n', '\n', '    function _reweight() internal {\n', '        _withdraw();\n', '        _returnToPeg();\n', '\n', '        // resupply PCV at peg ratio\n', '        uint256 balance = address(this).balance;\n', '        pcvDeposit.deposit{value: balance}(balance);\n', '\n', '        _burnFeiHeld();\n', '\n', '        emit Reweight(msg.sender);\n', '    }\n', '\n', '    function _returnToPeg() internal {\n', '        (uint256 feiReserves, uint256 ethReserves) = getReserves();\n', '        if (feiReserves == 0 || ethReserves == 0) {\n', '            return;\n', '        }\n', '\n', '        updateOracle();\n', '\n', '        Decimal.D256 memory _peg = peg();\n', '        require(\n', '            _isBelowPeg(_peg),\n', '            "EthUniswapPCVController: already at or above peg"\n', '        );\n', '\n', '        // calculate amount ETH needed to return to peg then swap\n', '        uint256 amountEth = _getAmountToPegOther(feiReserves, ethReserves, _peg);\n', '        _swapEth(amountEth, ethReserves, feiReserves);\n', '    }\n', '\n', '    function _swapEth(\n', '        uint256 amountEth,\n', '        uint256 ethReserves,\n', '        uint256 feiReserves\n', '    ) internal {\n', '        uint256 balance = address(this).balance;\n', '        uint256 amount = Math_4.min(amountEth, balance);\n', '\n', '        uint256 amountOut =\n', '            UniswapV2Library_2.getAmountOut(amount, ethReserves, feiReserves);\n', '\n', '        IWETH_2 weth = IWETH_2(router.WETH());\n', '        weth.deposit{value: amount}();\n', '        assert(weth.transfer(address(pair), amount));\n', '\n', '        (uint256 amount0Out, uint256 amount1Out) =\n', '            pair.token0() == address(weth)\n', '                ? (uint256(0), amountOut)\n', '                : (amountOut, uint256(0));\n', '        pair.swap(amount0Out, amount1Out, address(this), new bytes(0));\n', '    }\n', '\n', '    function _withdraw() internal {\n', '        // Only withdraw a portion to prevent rounding errors on Uni LP dust\n', '        uint256 value =\n', '            pcvDeposit.totalValue().mul(reweightWithdrawBPs) /\n', '                BASIS_POINTS_GRANULARITY;\n', '        pcvDeposit.withdraw(address(this), value);\n', '    }\n', '}']