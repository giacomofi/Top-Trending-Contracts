['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-05\n', '*/\n', '\n', '// File: contracts/ReserveAuctionV3_flat.sol\n', '\n', '\n', '// File: @openzeppelin/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.6.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// File: @openzeppelin/contracts/utils/introspection/IERC165.sol\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '      * - `from` cannot be the zero address.\n', '      * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// File: interfaces/IMarket.sol\n', '\n', '\n', '/**\n', ' * @title Math\n', ' *\n', ' * Library for non-standard Math functions\n', " * NOTE: This file is a clone of the dydx protocol's Decimal.sol contract.\n", ' * It was forked from https://github.com/dydxprotocol/solo at commit\n', ' * 2d8454e02702fe5bc455b848556660629c3cad36. It has not been modified other than to use a\n', ' * newer solidity in the pragma to match the rest of the contract suite of this project.\n', ' */\n', 'library Math {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Library Functions ============\n', '\n', '    /*\n', '     * Return target * (numerator / denominator).\n', '     */\n', '    function getPartial(\n', '        uint256 target,\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256) {\n', '        return target.mul(numerator).div(denominator);\n', '    }\n', '\n', '    /*\n', '     * Return target * (numerator / denominator), but rounded up.\n', '     */\n', '    function getPartialRoundUp(\n', '        uint256 target,\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256) {\n', '        if (target == 0 || numerator == 0) {\n', '            // SafeMath will check for zero denominator\n', '            return SafeMath.div(0, denominator);\n', '        }\n', '        return target.mul(numerator).sub(1).div(denominator).add(1);\n', '    }\n', '\n', '    function to128(uint256 number) internal pure returns (uint128) {\n', '        uint128 result = uint128(number);\n', '        require(result == number, "Math: Unsafe cast to uint128");\n', '        return result;\n', '    }\n', '\n', '    function to96(uint256 number) internal pure returns (uint96) {\n', '        uint96 result = uint96(number);\n', '        require(result == number, "Math: Unsafe cast to uint96");\n', '        return result;\n', '    }\n', '\n', '    function to32(uint256 number) internal pure returns (uint32) {\n', '        uint32 result = uint32(number);\n', '        require(result == number, "Math: Unsafe cast to uint32");\n', '        return result;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a > b ? a : b;\n', '    }\n', '}\n', '\n', '/**\n', " * NOTE: This file is a clone of the dydx protocol's Decimal.sol contract. It was forked from https://github.com/dydxprotocol/solo\n", ' * at commit 2d8454e02702fe5bc455b848556660629c3cad36\n', ' *\n', ' * It has not been modified other than to use a newer solidity in the pragma to match the rest of the contract suite of this project\n', ' */\n', '/*\n', ' * @title Decimal\n', ' *\n', ' * Library that defines a fixed-point number with 18 decimal places.\n', ' */\n', 'library Decimal {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 constant BASE_POW = 18;\n', '    uint256 constant BASE = 10**BASE_POW;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct D256 {\n', '        uint256 value;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    function one() internal pure returns (D256 memory) {\n', '        return D256({value: BASE});\n', '    }\n', '\n', '    function onePlus(D256 memory d) internal pure returns (D256 memory) {\n', '        return D256({value: d.value.add(BASE)});\n', '    }\n', '\n', '    function mul(uint256 target, D256 memory d)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return Math.getPartial(target, d.value, BASE);\n', '    }\n', '\n', '    function div(uint256 target, D256 memory d)\n', '        internal\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return Math.getPartial(target, BASE, d.value);\n', '    }\n', '}\n', '\n', '/**\n', " * @title Interface for Zora Protocol's Market\n", ' */\n', 'interface IMarket {\n', '    struct Bid {\n', '        // Amount of the currency being bid\n', '        uint256 amount;\n', '        // Address to the ERC20 token being used to bid\n', '        address currency;\n', '        // Address of the bidder\n', '        address bidder;\n', '        // Address of the recipient\n', '        address recipient;\n', '        // % of the next sale to award the current owner\n', '        Decimal.D256 sellOnShare;\n', '    }\n', '\n', '    struct Ask {\n', '        // Amount of the currency being asked\n', '        uint256 amount;\n', '        // Address to the ERC20 token being asked\n', '        address currency;\n', '    }\n', '\n', '    struct BidShares {\n', '        // % of sale value that goes to the _previous_ owner of the nft\n', '        Decimal.D256 prevOwner;\n', '        // % of sale value that goes to the original creator of the nft\n', '        Decimal.D256 creator;\n', '        // % of sale value that goes to the seller (current owner) of the nft\n', '        Decimal.D256 owner;\n', '    }\n', '\n', '    event BidCreated(uint256 indexed tokenId, Bid bid);\n', '    event BidRemoved(uint256 indexed tokenId, Bid bid);\n', '    event BidFinalized(uint256 indexed tokenId, Bid bid);\n', '    event AskCreated(uint256 indexed tokenId, Ask ask);\n', '    event AskRemoved(uint256 indexed tokenId, Ask ask);\n', '    event BidShareUpdated(uint256 indexed tokenId, BidShares bidShares);\n', '\n', '    function bidForTokenBidder(uint256 tokenId, address bidder)\n', '        external\n', '        view\n', '        returns (Bid memory);\n', '\n', '    function currentAskForToken(uint256 tokenId)\n', '        external\n', '        view\n', '        returns (Ask memory);\n', '\n', '    function bidSharesForToken(uint256 tokenId)\n', '        external\n', '        view\n', '        returns (BidShares memory);\n', '\n', '    function isValidBid(uint256 tokenId, uint256 bidAmount)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    function isValidBidShares(BidShares calldata bidShares)\n', '        external\n', '        pure\n', '        returns (bool);\n', '\n', '    function splitShare(Decimal.D256 calldata sharePercentage, uint256 amount)\n', '        external\n', '        pure\n', '        returns (uint256);\n', '\n', '    function configure(address mediaContractAddress) external;\n', '\n', '    function setBidShares(uint256 tokenId, BidShares calldata bidShares)\n', '        external;\n', '\n', '    function setAsk(uint256 tokenId, Ask calldata ask) external;\n', '\n', '    function removeAsk(uint256 tokenId) external;\n', '\n', '    function setBid(\n', '        uint256 tokenId,\n', '        Bid calldata bid,\n', '        address spender\n', '    ) external;\n', '\n', '    function removeBid(uint256 tokenId, address bidder) external;\n', '\n', '    function acceptBid(uint256 tokenId, Bid calldata expectedBid) external;\n', '}\n', '\n', '// File: contracts/ReentrancyGuard.sol\n', '\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <[email\xa0protected]π.com>, Eenae <[email\xa0protected]>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '\n', '  /// @dev counter to allow mutex lock with only one SSTORE operation\n', '  uint256 private _guardCounter = 1;\n', '\n', '  /**\n', '   * @dev Prevents a contract from calling itself, directly or indirectly.\n', '   * If you mark a function `nonReentrant`, you should also\n', '   * mark it `external`. Calling one `nonReentrant` function from\n', '   * another is not supported. Instead, you can implement a\n', '   * `private` function doing the actual work, and an `external`\n', '   * wrapper marked as `nonReentrant`.\n', '   */\n', '  modifier nonReentrant() {\n', '    _guardCounter += 1;\n', '    uint256 localCounter = _guardCounter;\n', '    _;\n', '    require(localCounter == _guardCounter);\n', '  }\n', '\n', '}\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/ReserveAuctionV3.sol\n', '\n', '// OpenZeppelin library for performing math operations without overflows.\n', '\n', '// OpenZeppelin security library for preventing reentrancy attacks.\n', '\n', "// For interacting with Zora's Market contract.\n", '\n', '// For checking `supportsInterface`.\n', '\n', '// For interacting with NFT tokens.\n', '\n', '\n', 'contract IMediaModified {\n', '    mapping(uint256 => address) public tokenCreators;\n', '    address public marketContract;\n', '}\n', '\n', 'contract ReserveAuctionV3 is ReentrancyGuard {\n', "    // Use OpenZeppelin's SafeMath library to prevent overflows.\n", '    using SafeMath for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    // The minimum amount of time left in an auction after a new bid is created; 15 min.\n', '    uint16 public constant TIME_BUFFER = 900;\n', '    // The ETH needed above the current bid for a new bid to be valid; 0.001 ETH.\n', '    uint8 public constant MIN_BID_INCREMENT_PERCENT = 10;\n', '    // Interface constant for ERC721, to check values in constructor.\n', '    bytes4 private constant ERC721_INTERFACE_ID = 0x80ac58cd;\n', '    // Allows external read `getVersion()` to return a version for the auction.\n', '    uint256 private constant RESERVE_AUCTION_VERSION = 1;\n', '\n', '    // ============ Immutable Storage ============\n', '\n', '    // The address of the ERC721 contract for tokens auctioned via this contract.\n', '    address public immutable nftContract;\n', '    // The address of the WETH contract, so that ETH can be transferred via\n', '    // WETH if native ETH transfers fail.\n', '    address public immutable wethAddress;\n', '    // The address that initially is able to recover assets.\n', '    address public immutable adminRecoveryAddress;\n', '\n', '    // ============ Mutable Storage ============\n', '\n', '    /**\n', '     * To start, there will be an admin account that can recover funds\n', '     * if anything goes wrong. Later, this public flag will be irrevocably\n', '     * set to false, removing any admin privileges forever.\n', '     *\n', '     * To check if admin recovery is enabled, call the public function `adminRecoveryEnabled()`.\n', '     */\n', '    bool private _adminRecoveryEnabled;\n', '    /**\n', '     * The account `adminRecoveryAddress` can also pause the contracts\n', '     * while _adminRecoveryEnabled is enabled. This prevents people from using\n', '     * the contract if there is a known problem with it.\n', '     */\n', '    bool private _paused;\n', '\n', '    // A mapping of all of the auctions currently running.\n', '    mapping(uint256 => Auction) public auctions;\n', '\n', '    // ============ Structs ============\n', '\n', '    struct Auction {\n', '        // The value of the current highest bid.\n', '        uint256 amount;\n', '        // The amount of time that the auction should run for,\n', '        // after the first bid was made.\n', '        uint256 duration;\n', '        // The time of the first bid.\n', '        uint256 firstBidTime;\n', '        // The minimum price of the first bid.\n', '        uint256 reservePrice;\n', '        uint8 curatorFeePercent;\n', "        // The address of the auction's curator. The curator\n", "        // can cancel the auction if it hasn't had a bid yet.\n", '        address curator;\n', '        // The address of the current highest bid.\n', '        address payable bidder;\n', '        // The address that should receive funds once the NFT is sold.\n', '        address payable fundsRecipient;\n', '    }\n', '\n', '    // ============ Events ============\n', '\n', '    // All of the details of a new auction,\n', '    // with an index created for the tokenId.\n', '    event AuctionCreated(\n', '        uint256 indexed tokenId,\n', '        address nftContractAddress,\n', '        uint256 duration,\n', '        uint256 reservePrice,\n', '        uint8 curatorFeePercent,\n', '        address curator,\n', '        address fundsRecipient\n', '    );\n', '\n', '    // All of the details of a new bid,\n', '    // with an index created for the tokenId.\n', '    event AuctionBid(\n', '        uint256 indexed tokenId,\n', '        address nftContractAddress,\n', '        address sender,\n', '        uint256 value\n', '    );\n', '\n', "    // All of the details of an auction's cancelation,\n", '    // with an index created for the tokenId.\n', '    event AuctionCanceled(\n', '        uint256 indexed tokenId,\n', '        address nftContractAddress,\n', '        address curator\n', '    );\n', '\n', "    // All of the details of an auction's close,\n", '    // with an index created for the tokenId.\n', '    event AuctionEnded(\n', '        uint256 indexed tokenId,\n', '        address nftContractAddress,\n', '        address curator,\n', '        address winner,\n', '        uint256 amount,\n', '        address nftCreator,\n', '        address payable fundsRecipient\n', '    );\n', '\n', '    // When the curator recevies fees, emit the details including the amount,\n', '    // with an index created for the tokenId.\n', '    event CuratorFeePercentTransfer(\n', '        uint256 indexed tokenId,\n', '        address curator,\n', '        uint256 amount\n', '    );\n', '\n', '    // Emitted in the case that the contract is paused.\n', '    event Paused(address account);\n', '    // Emitted when the contract is unpaused.\n', '    event Unpaused(address account);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    // Reverts if the sender is not admin, or admin\n', '    // functionality has been turned off.\n', '    modifier onlyAdminRecovery() {\n', '        require(\n', '            // The sender must be the admin address, and\n', '            // adminRecovery must be set to true.\n', '            adminRecoveryAddress == msg.sender && adminRecoveryEnabled(),\n', '            "Caller does not have admin privileges"\n', '        );\n', '        _;\n', '    }\n', '\n', "    // Reverts if the sender is not the auction's curator.\n", '    modifier onlyCurator(uint256 tokenId) {\n', '        require(\n', '            auctions[tokenId].curator == msg.sender,\n', '            "Can only be called by auction curator"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // Reverts if the contract is paused.\n', '    modifier whenNotPaused() {\n', '        require(!paused(), "Contract is paused");\n', '        _;\n', '    }\n', '\n', '    // Reverts if the auction does not exist.\n', '    modifier auctionExists(uint256 tokenId) {\n', '        // The auction exists if the curator is not null.\n', '        require(!auctionCuratorIsNull(tokenId), "Auction doesn\'t exist");\n', '        _;\n', '    }\n', '\n', '    // Reverts if the auction exists.\n', '    modifier auctionNonExistant(uint256 tokenId) {\n', '        // The auction does not exist if the curator is null.\n', '        require(auctionCuratorIsNull(tokenId), "Auction already exists");\n', '        _;\n', '    }\n', '\n', '    // Reverts if the auction is expired.\n', '    modifier auctionNotExpired(uint256 tokenId) {\n', '        require(\n', "            // Auction is not expired if there's never been a bid, or if the\n", '            // current time is less than the time at which the auction ends.\n', '            auctions[tokenId].firstBidTime == 0 ||\n', '                block.timestamp < auctionEnds(tokenId),\n', '            "Auction expired"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // Reverts if the auction is not complete.\n', '    // Auction is complete if there was a bid, and the time has run out.\n', '    modifier auctionComplete(uint256 tokenId) {\n', '        require(\n', '            // Auction is complete if there has been a bid, and the current time\n', "            // is greater than the auction's end time.\n", '            auctions[tokenId].firstBidTime > 0 &&\n', '                block.timestamp >= auctionEnds(tokenId),\n', '            "Auction hasn\'t completed"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(\n', '        address nftContract_,\n', '        address wethAddress_,\n', '        address adminRecoveryAddress_\n', '    ) public {\n', '        require(\n', '            IERC165(nftContract_).supportsInterface(ERC721_INTERFACE_ID),\n', '            "Contract at nftContract_ address does not support NFT interface"\n', '        );\n', '        // Initialize immutable memory.\n', '        nftContract = nftContract_;\n', '        wethAddress = wethAddress_;\n', '        adminRecoveryAddress = adminRecoveryAddress_;\n', '        // Initialize mutable memory.\n', '        _paused = false;\n', '        _adminRecoveryEnabled = true;\n', '    }\n', '\n', '    // ============ Create Auction ============\n', '\n', '    function createAuction(\n', '        uint256 tokenId,\n', '        uint256 duration,\n', '        uint256 reservePrice,\n', '        uint8 curatorFeePercent,\n', '        address curator,\n', '        address payable fundsRecipient\n', '    ) external nonReentrant whenNotPaused auctionNonExistant(tokenId) {\n', '        // Check basic input requirements are reasonable.\n', '        require(curator != address(0));\n', '        require(fundsRecipient != address(0));\n', '        require(curatorFeePercent < 100, "Curator fee should be < 100");\n', '        // Initialize the auction details, including null values.\n', '        auctions[tokenId] = Auction({\n', '            duration: duration,\n', '            reservePrice: reservePrice,\n', '            curatorFeePercent: curatorFeePercent,\n', '            curator: curator,\n', '            fundsRecipient: fundsRecipient,\n', '            amount: 0,\n', '            firstBidTime: 0,\n', '            bidder: address(0)\n', '        });\n', '        // Transfer the NFT into this auction contract, from whoever owns it.\n', '        IERC721(nftContract).transferFrom(\n', '            IERC721(nftContract).ownerOf(tokenId),\n', '            address(this),\n', '            tokenId\n', '        );\n', '        // Emit an event describing the new auction.\n', '        emit AuctionCreated(\n', '            tokenId,\n', '            nftContract,\n', '            duration,\n', '            reservePrice,\n', '            curatorFeePercent,\n', '            curator,\n', '            fundsRecipient\n', '        );\n', '    }\n', '\n', '    // ============ Create Bid ============\n', '\n', '    function createBid(uint256 tokenId, uint256 amount)\n', '        external\n', '        payable\n', '        nonReentrant\n', '        whenNotPaused\n', '        auctionExists(tokenId)\n', '        auctionNotExpired(tokenId)\n', '    {\n', "        // Validate that the user's expected bid value matches the ETH deposit.\n", '        require(amount == msg.value, "Amount doesn\'t equal msg.value");\n', '        require(amount > 0, "Amount must be greater than 0");\n', '        // Check if the current bid amount is 0.\n', '        if (auctions[tokenId].amount == 0) {\n', '            // If so, it is the first bid.\n', '            auctions[tokenId].firstBidTime = block.timestamp;\n', '            // We only need to check if the bid matches reserve bid for the first bid,\n', '            // since future checks will need to be higher than any previous bid.\n', '            require(\n', '                amount >= auctions[tokenId].reservePrice,\n', '                "Must bid reservePrice or more"\n', '            );\n', '        } else {\n', '            // Check that the new bid is sufficiently higher than the previous bid, by\n', '            // the percentage defined as MIN_BID_INCREMENT_PERCENT.\n', '            require(\n', '                amount >=\n', '                    auctions[tokenId].amount.add(\n', '                        // Add 10% of the current bid to the current bid.\n', '                        auctions[tokenId]\n', '                            .amount\n', '                            .mul(MIN_BID_INCREMENT_PERCENT)\n', '                            .div(100)\n', '                    ),\n', '                "Must bid more than last bid by MIN_BID_INCREMENT_PERCENT amount"\n', '            );\n', '\n', '            // Refund the previous bidder.\n', '            transferETHOrWETH(\n', '                auctions[tokenId].bidder,\n', '                auctions[tokenId].amount\n', '            );\n', '        }\n', '        // Update the current auction.\n', '        auctions[tokenId].amount = amount;\n', '        auctions[tokenId].bidder = msg.sender;\n', "        // Compare the auction's end time with the current time plus the 15 minute extension,\n", "        // to see whether we're near the auctions end and should extend the auction.\n", '        if (auctionEnds(tokenId) < block.timestamp.add(TIME_BUFFER)) {\n', '            // We add onto the duration whenever time increment is required, so\n', '            // that the auctionEnds at the current time plus the buffer.\n', '            auctions[tokenId].duration += block.timestamp.add(TIME_BUFFER).sub(\n', '                auctionEnds(tokenId)\n', '            );\n', '        }\n', '        // Emit the event that a bid has been made.\n', '        emit AuctionBid(tokenId, nftContract, msg.sender, amount);\n', '    }\n', '\n', '    // ============ End Auction ============\n', '\n', '    function endAuction(uint256 tokenId)\n', '        external\n', '        nonReentrant\n', '        whenNotPaused\n', '        auctionComplete(tokenId)\n', '    {\n', '        // Store relevant auction data in memory for the life of this function.\n', '        address winner = auctions[tokenId].bidder;\n', '        uint256 amount = auctions[tokenId].amount;\n', '        address curator = auctions[tokenId].curator;\n', '        uint8 curatorFeePercent = auctions[tokenId].curatorFeePercent;\n', '        address payable fundsRecipient = auctions[tokenId].fundsRecipient;\n', '        // Remove all auction data for this token from storage.\n', '        delete auctions[tokenId];\n', "        // We don't use safeTransferFrom, to prevent reverts at this point,\n", '        // which would break the auction.\n', '        IERC721(nftContract).transferFrom(address(this), winner, tokenId);\n', "        // First handle the curator's fee.\n", '        if (curatorFeePercent > 0) {\n', '            // Determine the curator amount, which is some percent of the total.\n', '            uint256 curatorAmount = amount.mul(curatorFeePercent).div(100);\n', '            // Send it to the curator.\n', '            transferETHOrWETH(curator, curatorAmount);\n', '            // Subtract the curator amount from the total funds available\n', '            // to send to the funds recipient and original NFT creator.\n', '            amount = amount.sub(curatorAmount);\n', '            // Emit the details of the transfer as an event.\n', '            emit CuratorFeePercentTransfer(tokenId, curator, curatorAmount);\n', '        }\n', '        // Get the address of the original creator, so that we can split shares\n', '        // if appropriate.\n', '        address payable nftCreator =\n', '            payable(\n', '                address(IMediaModified(nftContract).tokenCreators(tokenId))\n', '            );\n', '        // If the creator and the recipient of the funds are the same\n', '        // (and we expect this to be common), we can just do one transaction.\n', '        if (nftCreator == fundsRecipient) {\n', '            transferETHOrWETH(nftCreator, amount);\n', '        } else {\n', '            // Otherwise, we should determine the percent that goes to the creator.\n', '            // Collect share data from Zora.\n', '            uint256 creatorAmount =\n', '                // Call the splitShare function on the market contract, which\n', '                // takes in a Decimal and an amount.\n', '                IMarket(IMediaModified(nftContract).marketContract())\n', '                    .splitShare(\n', '                    // Fetch the decimal from the BidShares data on the market.\n', '                    IMarket(IMediaModified(nftContract).marketContract())\n', '                        .bidSharesForToken(tokenId)\n', '                        .creator,\n', '                    // Specify the amount.\n', '                    amount\n', '                );\n', "            // Send the creator's share to the creator.\n", '            transferETHOrWETH(nftCreator, creatorAmount);\n', '            // Send the remainder of the amount to the funds recipient.\n', '            transferETHOrWETH(fundsRecipient, amount.sub(creatorAmount));\n', '        }\n', '        // Emit an event describing the end of the auction.\n', '        emit AuctionEnded(\n', '            tokenId,\n', '            nftContract,\n', '            curator,\n', '            winner,\n', '            amount,\n', '            nftCreator,\n', '            fundsRecipient\n', '        );\n', '    }\n', '\n', '    // ============ Cancel Auction ============\n', '\n', '    function cancelAuction(uint256 tokenId)\n', '        external\n', '        nonReentrant\n', '        auctionExists(tokenId)\n', '        onlyCurator(tokenId)\n', '    {\n', "        // Check that there hasn't already been a bid for this NFT.\n", '        require(\n', '            uint256(auctions[tokenId].firstBidTime) == 0,\n', '            "Auction already started"\n', '        );\n', '        // Pull the creator address before removing the auction.\n', '        address curator = auctions[tokenId].curator;\n', '        // Remove all data about the auction.\n', '        delete auctions[tokenId];\n', '        // Transfer the NFT back to the curator.\n', '        IERC721(nftContract).transferFrom(address(this), curator, tokenId);\n', '        // Emit an event describing that the auction has been canceled.\n', '        emit AuctionCanceled(tokenId, nftContract, curator);\n', '    }\n', '\n', '    // ============ Admin Functions ============\n', '\n', '    // Irrevocably turns off admin recovery.\n', '    function turnOffAdminRecovery() external onlyAdminRecovery {\n', '        _adminRecoveryEnabled = false;\n', '    }\n', '\n', '    function pauseContract() external onlyAdminRecovery {\n', '        _paused = true;\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    function unpauseContract() external onlyAdminRecovery {\n', '        _paused = false;\n', '        emit Unpaused(msg.sender);\n', '    }\n', '\n', '    // Allows the admin to transfer any NFT from this contract\n', '    // to the recovery address.\n', '    function recoverNFT(uint256 tokenId) external onlyAdminRecovery {\n', '        IERC721(nftContract).transferFrom(\n', '            // From the auction contract.\n', '            address(this),\n', '            // To the recovery account.\n', '            adminRecoveryAddress,\n', '            // For the specified token.\n', '            tokenId\n', '        );\n', '    }\n', '\n', '    // Allows the admin to transfer any ETH from this contract to the recovery address.\n', '    function recoverETH(uint256 amount)\n', '        external\n', '        onlyAdminRecovery\n', '        returns (bool success)\n', '    {\n', '        // Attempt an ETH transfer to the recovery account, and return true if it succeeds.\n', '        success = attemptETHTransfer(adminRecoveryAddress, amount);\n', '    }\n', '\n', '    // ============ Miscellaneous Public and External ============\n', '\n', '    // Returns true if the contract is paused.\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    // Returns true if admin recovery is enabled.\n', '    function adminRecoveryEnabled() public view returns (bool) {\n', '        return _adminRecoveryEnabled;\n', '    }\n', '\n', '    // Returns the version of the deployed contract.\n', '    function getVersion() external pure returns (uint256 version) {\n', '        version = RESERVE_AUCTION_VERSION;\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    // Will attempt to transfer ETH, but will transfer WETH instead if it fails.\n', '    function transferETHOrWETH(address to, uint256 value) private {\n', '        // Try to transfer ETH to the given recipient.\n', '        if (!attemptETHTransfer(to, value)) {\n', '            // If the transfer fails, wrap and send as WETH, so that\n', '            // the auction is not impeded and the recipient still\n', '            // can claim ETH via the WETH contract (similar to escrow).\n', '            IWETH(wethAddress).deposit{value: value}();\n', '            IWETH(wethAddress).transfer(to, value);\n', '            // At this point, the recipient can unwrap WETH.\n', '        }\n', '    }\n', '\n', '    // Sending ETH is not guaranteed complete, and the method used here will return false if\n', '    // it fails. For example, a contract can block ETH transfer, or might use\n', '    // an excessive amount of gas, thereby griefing a new bidder.\n', '    // We should limit the gas used in transfers, and handle failure cases.\n', '    function attemptETHTransfer(address to, uint256 value)\n', '        private\n', '        returns (bool)\n', '    {\n', '        // Here increase the gas limit a reasonable amount above the default, and try\n', '        // to send ETH to the recipient.\n', '        // NOTE: This might allow the recipient to attempt a limited reentrancy attack.\n', '        (bool success, ) = to.call{value: value, gas: 30000}("");\n', '        return success;\n', '    }\n', '\n', "    // Returns true if the auction's curator is set to the null address.\n", '    function auctionCuratorIsNull(uint256 tokenId) private view returns (bool) {\n', '        // The auction does not exist if the curator is the null address,\n', '        // since the NFT would not have been transferred in `createAuction`.\n', '        return auctions[tokenId].curator == address(0);\n', '    }\n', '\n', '    // Returns the timestamp at which an auction will finish.\n', '    function auctionEnds(uint256 tokenId) private view returns (uint256) {\n', "        // Derived by adding the auction's duration to the time of the first bid.\n", '        // NOTE: duration can be extended conditionally after each new bid is added.\n', '        return auctions[tokenId].firstBidTime.add(auctions[tokenId].duration);\n', '    }\n', '}\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', '// File: contracts/ABDKMath64x64.sol\n', '\n', '/*\n', ' * ABDK Math 64.64 Smart Contract Library.  Copyright © 2019 by ABDK Consulting.\n', ' * Author: Mikhail Vladimirov <[email\xa0protected]>\n', ' */\n', 'pragma solidity ^0.5.0 || ^0.6.0;\n', '\n', '/**\n', ' * Smart contract library of mathematical functions operating with signed\n', ' * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n', ' * basically a simple fraction whose numerator is signed 128-bit integer and\n', ' * denominator is 2^64.  As long as denominator is always the same, there is no\n', ' * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n', ' * represented by int128 type holding only the numerator.\n', ' */\n', 'library ABDKMath64x64 {\n', '  /**\n', '   * Minimum value signed 64.64-bit fixed point number may have. \n', '   */\n', '  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n', '\n', '  /**\n', '   * Maximum value signed 64.64-bit fixed point number may have. \n', '   */\n', '  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n', '\n', '  /**\n', '   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n', '   * number.  Revert on overflow.\n', '   *\n', '   * @param x signed 256-bit integer number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function fromInt (int256 x) internal pure returns (int128) {\n', '    require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n', '    return int128 (x << 64);\n', '  }\n', '\n', '  /**\n', '   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n', '   * rounding down.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64-bit integer number\n', '   */\n', '  function toInt (int128 x) internal pure returns (int64) {\n', '    return int64 (x >> 64);\n', '  }\n', '\n', '  /**\n', '   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n', '   * number.  Revert on overflow.\n', '   *\n', '   * @param x unsigned 256-bit integer number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function fromUInt (uint256 x) internal pure returns (int128) {\n', '    require (x <= 0x7FFFFFFFFFFFFFFF);\n', '    return int128 (x << 64);\n', '  }\n', '\n', '  /**\n', '   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n', '   * number rounding down.  Revert on underflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return unsigned 64-bit integer number\n', '   */\n', '  function toUInt (int128 x) internal pure returns (uint64) {\n', '    require (x >= 0);\n', '    return uint64 (x >> 64);\n', '  }\n', '\n', '  /**\n', '   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n', '   * number rounding down.  Revert on overflow.\n', '   *\n', '   * @param x signed 128.128-bin fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function from128x128 (int256 x) internal pure returns (int128) {\n', '    int256 result = x >> 64;\n', '    require (result >= MIN_64x64 && result <= MAX_64x64);\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n', '   * number.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 128.128 fixed point number\n', '   */\n', '  function to128x128 (int128 x) internal pure returns (int256) {\n', '    return int256 (x) << 64;\n', '  }\n', '\n', '  /**\n', '   * Calculate x + y.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @param y signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function add (int128 x, int128 y) internal pure returns (int128) {\n', '    int256 result = int256(x) + y;\n', '    require (result >= MIN_64x64 && result <= MAX_64x64);\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate x - y.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @param y signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function sub (int128 x, int128 y) internal pure returns (int128) {\n', '    int256 result = int256(x) - y;\n', '    require (result >= MIN_64x64 && result <= MAX_64x64);\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate x * y rounding down.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @param y signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function mul (int128 x, int128 y) internal pure returns (int128) {\n', '    int256 result = int256(x) * y >> 64;\n', '    require (result >= MIN_64x64 && result <= MAX_64x64);\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n', '   * number and y is signed 256-bit integer number.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64 fixed point number\n', '   * @param y signed 256-bit integer number\n', '   * @return signed 256-bit integer number\n', '   */\n', '  function muli (int128 x, int256 y) internal pure returns (int256) {\n', '    if (x == MIN_64x64) {\n', '      require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n', '        y <= 0x1000000000000000000000000000000000000000000000000);\n', '      return -y << 63;\n', '    } else {\n', '      bool negativeResult = false;\n', '      if (x < 0) {\n', '        x = -x;\n', '        negativeResult = true;\n', '      }\n', '      if (y < 0) {\n', '        y = -y; // We rely on overflow behavior here\n', '        negativeResult = !negativeResult;\n', '      }\n', '      uint256 absoluteResult = mulu (x, uint256 (y));\n', '      if (negativeResult) {\n', '        require (absoluteResult <=\n', '          0x8000000000000000000000000000000000000000000000000000000000000000);\n', '        return -int256 (absoluteResult); // We rely on overflow behavior here\n', '      } else {\n', '        require (absoluteResult <=\n', '          0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '        return int256 (absoluteResult);\n', '      }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n', '   * and y is unsigned 256-bit integer number.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64 fixed point number\n', '   * @param y unsigned 256-bit integer number\n', '   * @return unsigned 256-bit integer number\n', '   */\n', '  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n', '    if (y == 0) return 0;\n', '\n', '    require (x >= 0);\n', '\n', '    uint256 lo = (uint256 (x) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n', '    uint256 hi = uint256 (x) * (y >> 128);\n', '\n', '    require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '    hi <<= 64;\n', '\n', '    require (hi <=\n', '      0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n', '    return hi + lo;\n', '  }\n', '\n', '  /**\n', '   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n', '   * zero.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @param y signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function div (int128 x, int128 y) internal pure returns (int128) {\n', '    require (y != 0);\n', '    int256 result = (int256 (x) << 64) / y;\n', '    require (result >= MIN_64x64 && result <= MAX_64x64);\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n', '   * integer numbers.  Revert on overflow or when y is zero.\n', '   *\n', '   * @param x signed 256-bit integer number\n', '   * @param y signed 256-bit integer number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function divi (int256 x, int256 y) internal pure returns (int128) {\n', '    require (y != 0);\n', '\n', '    bool negativeResult = false;\n', '    if (x < 0) {\n', '      x = -x; // We rely on overflow behavior here\n', '      negativeResult = true;\n', '    }\n', '    if (y < 0) {\n', '      y = -y; // We rely on overflow behavior here\n', '      negativeResult = !negativeResult;\n', '    }\n', '    uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n', '    if (negativeResult) {\n', '      require (absoluteResult <= 0x80000000000000000000000000000000);\n', '      return -int128 (absoluteResult); // We rely on overflow behavior here\n', '    } else {\n', '      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '      return int128 (absoluteResult); // We rely on overflow behavior here\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n', '   * integer numbers.  Revert on overflow or when y is zero.\n', '   *\n', '   * @param x unsigned 256-bit integer number\n', '   * @param y unsigned 256-bit integer number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n', '    require (y != 0);\n', '    uint128 result = divuu (x, y);\n', '    require (result <= uint128 (MAX_64x64));\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate -x.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function neg (int128 x) internal pure returns (int128) {\n', '    require (x != MIN_64x64);\n', '    return -x;\n', '  }\n', '\n', '  /**\n', '   * Calculate |x|.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function abs (int128 x) internal pure returns (int128) {\n', '    require (x != MIN_64x64);\n', '    return x < 0 ? -x : x;\n', '  }\n', '\n', '  /**\n', '   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n', '   * zero.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function inv (int128 x) internal pure returns (int128) {\n', '    require (x != 0);\n', '    int256 result = int256 (0x100000000000000000000000000000000) / x;\n', '    require (result >= MIN_64x64 && result <= MAX_64x64);\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @param y signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function avg (int128 x, int128 y) internal pure returns (int128) {\n', '    return int128 ((int256 (x) + int256 (y)) >> 1);\n', '  }\n', '\n', '  /**\n', '   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n', '   * Revert on overflow or in case x * y is negative.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @param y signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function gavg (int128 x, int128 y) internal pure returns (int128) {\n', '    int256 m = int256 (x) * int256 (y);\n', '    require (m >= 0);\n', '    require (m <\n', '        0x4000000000000000000000000000000000000000000000000000000000000000);\n', '    return int128 (sqrtu (uint256 (m), uint256 (x) + uint256 (y) >> 1));\n', '  }\n', '\n', '  /**\n', '   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n', '   * and y is unsigned 256-bit integer number.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @param y uint256 value\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function pow (int128 x, uint256 y) internal pure returns (int128) {\n', '    uint256 absoluteResult;\n', '    bool negativeResult = false;\n', '    if (x >= 0) {\n', '      absoluteResult = powu (uint256 (x) << 63, y);\n', '    } else {\n', '      // We rely on overflow behavior here\n', '      absoluteResult = powu (uint256 (uint128 (-x)) << 63, y);\n', '      negativeResult = y & 1 > 0;\n', '    }\n', '\n', '    absoluteResult >>= 63;\n', '\n', '    if (negativeResult) {\n', '      require (absoluteResult <= 0x80000000000000000000000000000000);\n', '      return -int128 (absoluteResult); // We rely on overflow behavior here\n', '    } else {\n', '      require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '      return int128 (absoluteResult); // We rely on overflow behavior here\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function sqrt (int128 x) internal pure returns (int128) {\n', '    require (x >= 0);\n', '    return int128 (sqrtu (uint256 (x) << 64, 0x10000000000000000));\n', '  }\n', '\n', '  /**\n', '   * Calculate binary logarithm of x.  Revert if x <= 0.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function log_2 (int128 x) internal pure returns (int128) {\n', '    require (x > 0);\n', '\n', '    int256 msb = 0;\n', '    int256 xc = x;\n', '    if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n', '    if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n', '    if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n', '    if (xc >= 0x100) { xc >>= 8; msb += 8; }\n', '    if (xc >= 0x10) { xc >>= 4; msb += 4; }\n', '    if (xc >= 0x4) { xc >>= 2; msb += 2; }\n', '    if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n', '\n', '    int256 result = msb - 64 << 64;\n', '    uint256 ux = uint256 (x) << 127 - msb;\n', '    for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n', '      ux *= ux;\n', '      uint256 b = ux >> 255;\n', '      ux >>= 127 + b;\n', '      result += bit * int256 (b);\n', '    }\n', '\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate natural logarithm of x.  Revert if x <= 0.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function ln (int128 x) internal pure returns (int128) {\n', '    require (x > 0);\n', '\n', '    return int128 (\n', '        uint256 (log_2 (x)) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128);\n', '  }\n', '\n', '  /**\n', '   * Calculate binary exponent of x.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function exp_2 (int128 x) internal pure returns (int128) {\n', '    require (x < 0x400000000000000000); // Overflow\n', '\n', '    if (x < -0x400000000000000000) return 0; // Underflow\n', '\n', '    uint256 result = 0x80000000000000000000000000000000;\n', '\n', '    if (x & 0x8000000000000000 > 0)\n', '      result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n', '    if (x & 0x4000000000000000 > 0)\n', '      result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n', '    if (x & 0x2000000000000000 > 0)\n', '      result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n', '    if (x & 0x1000000000000000 > 0)\n', '      result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n', '    if (x & 0x800000000000000 > 0)\n', '      result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n', '    if (x & 0x400000000000000 > 0)\n', '      result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n', '    if (x & 0x200000000000000 > 0)\n', '      result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n', '    if (x & 0x100000000000000 > 0)\n', '      result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n', '    if (x & 0x80000000000000 > 0)\n', '      result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n', '    if (x & 0x40000000000000 > 0)\n', '      result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n', '    if (x & 0x20000000000000 > 0)\n', '      result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n', '    if (x & 0x10000000000000 > 0)\n', '      result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n', '    if (x & 0x8000000000000 > 0)\n', '      result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n', '    if (x & 0x4000000000000 > 0)\n', '      result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n', '    if (x & 0x2000000000000 > 0)\n', '      result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n', '    if (x & 0x1000000000000 > 0)\n', '      result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n', '    if (x & 0x800000000000 > 0)\n', '      result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n', '    if (x & 0x400000000000 > 0)\n', '      result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n', '    if (x & 0x200000000000 > 0)\n', '      result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n', '    if (x & 0x100000000000 > 0)\n', '      result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n', '    if (x & 0x80000000000 > 0)\n', '      result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n', '    if (x & 0x40000000000 > 0)\n', '      result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n', '    if (x & 0x20000000000 > 0)\n', '      result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n', '    if (x & 0x10000000000 > 0)\n', '      result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n', '    if (x & 0x8000000000 > 0)\n', '      result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n', '    if (x & 0x4000000000 > 0)\n', '      result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n', '    if (x & 0x2000000000 > 0)\n', '      result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n', '    if (x & 0x1000000000 > 0)\n', '      result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n', '    if (x & 0x800000000 > 0)\n', '      result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n', '    if (x & 0x400000000 > 0)\n', '      result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n', '    if (x & 0x200000000 > 0)\n', '      result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n', '    if (x & 0x100000000 > 0)\n', '      result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n', '    if (x & 0x80000000 > 0)\n', '      result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n', '    if (x & 0x40000000 > 0)\n', '      result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n', '    if (x & 0x20000000 > 0)\n', '      result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n', '    if (x & 0x10000000 > 0)\n', '      result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n', '    if (x & 0x8000000 > 0)\n', '      result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n', '    if (x & 0x4000000 > 0)\n', '      result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n', '    if (x & 0x2000000 > 0)\n', '      result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n', '    if (x & 0x1000000 > 0)\n', '      result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n', '    if (x & 0x800000 > 0)\n', '      result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n', '    if (x & 0x400000 > 0)\n', '      result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n', '    if (x & 0x200000 > 0)\n', '      result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n', '    if (x & 0x100000 > 0)\n', '      result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n', '    if (x & 0x80000 > 0)\n', '      result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n', '    if (x & 0x40000 > 0)\n', '      result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n', '    if (x & 0x20000 > 0)\n', '      result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n', '    if (x & 0x10000 > 0)\n', '      result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n', '    if (x & 0x8000 > 0)\n', '      result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n', '    if (x & 0x4000 > 0)\n', '      result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n', '    if (x & 0x2000 > 0)\n', '      result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n', '    if (x & 0x1000 > 0)\n', '      result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n', '    if (x & 0x800 > 0)\n', '      result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n', '    if (x & 0x400 > 0)\n', '      result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n', '    if (x & 0x200 > 0)\n', '      result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n', '    if (x & 0x100 > 0)\n', '      result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n', '    if (x & 0x80 > 0)\n', '      result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n', '    if (x & 0x40 > 0)\n', '      result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n', '    if (x & 0x20 > 0)\n', '      result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n', '    if (x & 0x10 > 0)\n', '      result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n', '    if (x & 0x8 > 0)\n', '      result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n', '    if (x & 0x4 > 0)\n', '      result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n', '    if (x & 0x2 > 0)\n', '      result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n', '    if (x & 0x1 > 0)\n', '      result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n', '\n', '    result >>= 63 - (x >> 64);\n', '    require (result <= uint256 (MAX_64x64));\n', '\n', '    return int128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate natural exponent of x.  Revert on overflow.\n', '   *\n', '   * @param x signed 64.64-bit fixed point number\n', '   * @return signed 64.64-bit fixed point number\n', '   */\n', '  function exp (int128 x) internal pure returns (int128) {\n', '    require (x < 0x400000000000000000); // Overflow\n', '\n', '    if (x < -0x400000000000000000) return 0; // Underflow\n', '\n', '    return exp_2 (\n', '        int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n', '  }\n', '\n', '  /**\n', '   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n', '   * integer numbers.  Revert on overflow or when y is zero.\n', '   *\n', '   * @param x unsigned 256-bit integer number\n', '   * @param y unsigned 256-bit integer number\n', '   * @return unsigned 64.64-bit fixed point number\n', '   */\n', '  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n', '    require (y != 0);\n', '\n', '    uint256 result;\n', '\n', '    if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n', '      result = (x << 64) / y;\n', '    else {\n', '      uint256 msb = 192;\n', '      uint256 xc = x >> 192;\n', '      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n', '      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n', '      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n', '      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n', '      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n', '      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n', '\n', '      result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n', '      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '\n', '      uint256 hi = result * (y >> 128);\n', '      uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '\n', '      uint256 xh = x >> 192;\n', '      uint256 xl = x << 64;\n', '\n', '      if (xl < lo) xh -= 1;\n', '      xl -= lo; // We rely on overflow behavior here\n', '      lo = hi << 128;\n', '      if (xl < lo) xh -= 1;\n', '      xl -= lo; // We rely on overflow behavior here\n', '\n', '      assert (xh == hi >> 128);\n', '\n', '      result += xl / y;\n', '    }\n', '\n', '    require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n', '    return uint128 (result);\n', '  }\n', '\n', '  /**\n', '   * Calculate x^y assuming 0^0 is 1, where x is unsigned 129.127 fixed point\n', '   * number and y is unsigned 256-bit integer number.  Revert on overflow.\n', '   *\n', '   * @param x unsigned 129.127-bit fixed point number\n', '   * @param y uint256 value\n', '   * @return unsigned 129.127-bit fixed point number\n', '   */\n', '  function powu (uint256 x, uint256 y) private pure returns (uint256) {\n', '    if (y == 0) return 0x80000000000000000000000000000000;\n', '    else if (x == 0) return 0;\n', '    else {\n', '      int256 msb = 0;\n', '      uint256 xc = x;\n', '      if (xc >= 0x100000000000000000000000000000000) { xc >>= 128; msb += 128; }\n', '      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n', '      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n', '      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n', '      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n', '      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n', '      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n', '      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n', '\n', '      int256 xe = msb - 127;\n', '      if (xe > 0) x >>= xe;\n', '      else x <<= -xe;\n', '\n', '      uint256 result = 0x80000000000000000000000000000000;\n', '      int256 re = 0;\n', '\n', '      while (y > 0) {\n', '        if (y & 1 > 0) {\n', '          result = result * x;\n', '          y -= 1;\n', '          re += xe;\n', '          if (result >=\n', '            0x8000000000000000000000000000000000000000000000000000000000000000) {\n', '            result >>= 128;\n', '            re += 1;\n', '          } else result >>= 127;\n', '          if (re < -127) return 0; // Underflow\n', '          require (re < 128); // Overflow\n', '        } else {\n', '          x = x * x;\n', '          y >>= 1;\n', '          xe <<= 1;\n', '          if (x >=\n', '            0x8000000000000000000000000000000000000000000000000000000000000000) {\n', '            x >>= 128;\n', '            xe += 1;\n', '          } else x >>= 127;\n', '          if (xe < -127) return 0; // Underflow\n', '          require (xe < 128); // Overflow\n', '        }\n', '      }\n', '\n', '      if (re > 0) result <<= re;\n', '      else if (re < 0) result >>= -re;\n', '\n', '      return result;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n', '   * number.\n', '   *\n', '   * @param x unsigned 256-bit integer number\n', '   * @return unsigned 128-bit integer number\n', '   */\n', '  function sqrtu (uint256 x, uint256 r) private pure returns (uint128) {\n', '    if (x == 0) return 0;\n', '    else {\n', '      require (r > 0);\n', '      while (true) {\n', '        uint256 rr = x / r;\n', '        if (r == rr || r + 1 == rr) return uint128 (r);\n', '        else if (r == rr + 1) return uint128 (rr);\n', '        r = r + rr + 1 >> 1;\n', '      }\n', '    }\n', '  }\n', '}\n', '// File: contracts/PartyBidRA.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.6.8;\n', '\n', '// ============ Imports ============\n', '\n', '\n', '\n', '\n', '// ============ Interface declarations ============\n', '\n', '// Wrapped Ether\n', 'interface IWETH {\n', '  function deposit() external payable;\n', '  function approve(address guy, uint wad) external returns (bool);\n', '  function balanceOf(address src) external view returns (uint256);\n', '  function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n', '  function transfer(address to, uint256 value) external returns (bool);\n', '}\n', '\n', '// IMedia (with bid acceptance extension)\n', 'interface IMediaExtended {\n', '  function acceptBid(uint256 tokenId, IMarket.Bid calldata bid) external;\n', '}\n', '\n', '// @dev: Must use wETH for all outgoing transactions, since returned capital from contract will\n', '//       always be wETH (due to hard 30,000 imposed gas limitation at ETH transfer layer).\n', 'contract PartyBid {\n', '  // Use OpenZeppelin library for SafeMath\n', '  using SafeMath for uint256;\n', '\n', '  // ============ Immutable storage ============\n', '\n', '  // Address of the Reserve Auction contract to place bid on\n', '  address public immutable ReserveAuctionV3Address;\n', '  // Address of the wETH contract\n', '  address public immutable wETHAddress;\n', '  // Address of the NFT contract\n', '  address public immutable NFTAddress;\n', '\n', '  // ============ Mutable storage ============\n', '\n', '  // ReserveAuctionV3 auctionID to bid on\n', '  uint256 public auctionID;\n', '  // Amount that DAO will bid for on ReserveAuctionV3 item\n', '  uint256 public bidAmount;\n', '  // Current amount raised to bid on ReserveAuctionV3 item\n', '  uint256 public currentRaisedAmount;\n', '  // Maximum time to wait for dao members to fill contract before enabling exit\n', '  uint256 public exitTimeout; \n', '  // Value received from accepted bid\n', '  uint256 public NFTResoldValue;\n', '  // Toggled when DAO places bid to purchase a ReserveAuctionV3 item\n', '  bool public bidPlaced;\n', '  // Toggled when DAO has resold won ReserveAuctionV3 item (to enable exit liquidity)\n', '  bool public NFTResold;\n', '  // Stakes of individual dao members\n', '  mapping (address => uint256) public daoStakes;\n', '  // List of active proposals to accept bids\n', '  BidProposal[] public BidProposals;\n', '  // List of supporters for each active bid proposal\n', '  mapping (uint256 => mapping (address => bool)) BidProposalSupporters;\n', '\n', '  // ============ Structs ============\n', '\n', '  // Individual bid proposals\n', '  struct BidProposal {\n', '    address proposer; // Proposing DAO member\n', '    address bidder; // Proposed bidder to accept bid from\n', '    uint256 amount; // Proposed bid amount\n', '    uint256 aggregateSupport; // sum(balance(voting_addresses_in_favor))\n', '  }\n', '\n', '  // ============ Modifiers ============\n', '  \n', '  // Reverts if the DAO has not won the NFT\n', '  modifier onlyIfAuctionWon() {\n', '    // Ensure that owner of NFT(auctionId) is contract address\n', '    require(IERC721(NFTAddress).ownerOf(auctionID) == address(this), "PartyBid: DAO has not won auction.");\n', '    _;\n', '  }\n', '\n', '  // ============ Events ============\n', '\n', '  // Address of a new DAO member and their entry share\n', '  event PartyJoined(address indexed member, uint256 value);\n', '  // Value of newly placed bid on ReserveAuctionV3 item\n', '  event PartyBidPlaced(uint256 auctionID, uint256 value);\n', '  // Address and exit share of DAO member, along with reason for exit\n', '  event PartyMemberExited(address indexed member, uint256 value, bool postFailure);\n', '  // Value of new proposal ID, proposer, Zora bidder, and Zora bidder bid amount\n', '  event PartyProposeNewZoraBid(uint256 indexed proposalId, address proposer, address bidder, uint256 amount);\n', '  // Value of proposal ID, and voter\n', '  event PartyProposalVote(uint256 indexed proposalId, address voter);\n', '  // Value of executed sale amount\n', '  event PartyExecuteSale(uint256 amount);\n', '\n', '  // ============ Constructor ============\n', '\n', '  constructor(\n', '    address _ReserveAuctionV3Address,\n', '    uint256 _auctionID,\n', '    uint256 _bidAmount,\n', '    uint256 _exitTimeout\n', '  ) public {\n', '    // Initialize immutable memory\n', '    ReserveAuctionV3Address = _ReserveAuctionV3Address;\n', '    wETHAddress = ReserveAuctionV3(_ReserveAuctionV3Address).wethAddress();\n', '    NFTAddress = ReserveAuctionV3(_ReserveAuctionV3Address).nftContract();\n', '\n', '    // Initialize mutable memory\n', '    auctionID = _auctionID;\n', '    bidAmount = _bidAmount;\n', '    currentRaisedAmount = 0;\n', '    exitTimeout = _exitTimeout;\n', '    bidPlaced = false;\n', '    NFTResold = false;\n', '  }\n', '\n', '  // ============ Join the DAO ============\n', '\n', '  /**\n', '   * Join the DAO by sending ETH\n', '   * Requires bidding to be enabled, forced matching of deposit value to sent eth, and there to be capacity in DAO\n', '   */\n', '  function join(uint256 _value) external payable {\n', '    // Dont allow joining once the bid has already been placed\n', '    require(bidPlaced == false, "PartyBid: Cannot join since bid has been placed.");\n', '    // Ensure matching of deposited value to ETH sent to contract\n', '    require(msg.value == _value, "PartyBid: Deposit amount does not match spent ETH.");\n', '    // Ensure sum(eth sent, current raised) <= required bid amount\n', '    require(_value.add(currentRaisedAmount) <= bidAmount, "PartyBid: DAO does not have capacity.");\n', '\n', '    currentRaisedAmount = currentRaisedAmount.add(_value); // Increment raised amount\n', '    daoStakes[msg.sender] = daoStakes[msg.sender].add(_value); // Track DAO member contribution\n', '\n', '    emit PartyJoined(msg.sender, _value); // Emit new DAO member\n', '  }\n', '\n', '  // ============ Place a bid from DAO ============\n', '\n', '  /**\n', '   * Execute bid placement, as DAO member, so long as required conditions are met\n', '   */\n', '  function placeBid() external {\n', '    // Dont allow placing a bid if already placed\n', '    require(bidPlaced == false, "PartyBid: Bid has already been placed.");\n', '    // Ensure that required bidAmount is matched with currently raised amount\n', '    require(bidAmount == currentRaisedAmount, "PartyBid: Insufficient raised capital to place bid.");\n', '    // Ensure that caller is a DAO member\n', '    require(daoStakes[msg.sender] > 0, "PartyBid: Must be DAO member to initiate placing bid.");\n', '\n', '    // Setup auction contract, place bid, toggle bidding status\n', '    ReserveAuctionV3 auction_contract = ReserveAuctionV3(ReserveAuctionV3Address);\n', '    auction_contract.createBid{value: bidAmount}(auctionID, bidAmount);\n', '    bidPlaced = true;\n', '\n', '    emit PartyBidPlaced(auctionID, bidAmount); // Emit bid placed\n', '  }\n', '\n', '  // ============ ReserveAuctionV3 NFT re-auctioning via Zora Market ============\n', '\n', '  /**\n', '   * Returns boolean status of if DAO has won NFT\n', '   */\n', '  function NFTWon() public view returns (bool) {\n', '    // Check if owner of NFT(auctionID) is contract address\n', '    return IERC721(NFTAddress).ownerOf(auctionID) == address(this);\n', '  }\n', '\n', '  /**\n', '   * Propose a new Zora bid for acceptance to the DAO\n', '   */\n', '  function DAOProposeZoraBid(address _bidder) external onlyIfAuctionWon() returns (uint256) {\n', '    // Collect Zora Bid\n', '    IMarket.Bid memory bid = IMarket(\n', '      // Collect Zora Market contract from IMedia storage\n', '      IMediaModified(NFTAddress).marketContract()\n', '    // Collect bid by bidder address\n', '    ).bidForTokenBidder(auctionID, _bidder);\n', '    \n', '    // Ensure that bid from bidder exists\n', '    require(bid.bidder == _bidder, "PartyBid: Bidder does not have an active bid on NFT.");\n', '    // Ensure that bid currency is Wrapped Ether\n', '    require(bid.currency == wETHAddress, "PartyBid: Bidder has bid in a non-wETH token.");\n', '    // Ensure that caller is a DAO member\n', '    require(daoStakes[msg.sender] > 0, "PartyBid: Must be a DAO member to propose a new Zora bid.");\n', '\n', '    // Collect proposalId from proposals array length\n', '    uint256 proposalId = BidProposals.length;\n', '\n', '    BidProposals.push(BidProposal(\n', '      msg.sender,\n', '      _bidder,\n', '      bid.amount,\n', '      // Existing aggregate support starts at power(proposer)\n', '      daoStakes[msg.sender]\n', '    ));\n', '\n', '    // Update supporters mapping\n', '    BidProposalSupporters[proposalId][msg.sender] = true;\n', '\n', '    emit PartyProposeNewZoraBid(proposalId, msg.sender, _bidder, bid.amount); // Emit new bid proposal\n', '    emit PartyProposalVote(proposalId, msg.sender); // Emit new vote for proposal (from proposal proposer themselves)\n', '\n', '    return proposalId;\n', '  }\n', '\n', '  /**\n', '   * Vote for a new Zora bid proposal if you have not already\n', '   */\n', '  function DAOVoteForZoraBidProposal(uint256 _proposalId) external onlyIfAuctionWon() {\n', '    // Ensure that caller is a DAO member\n', '    require(daoStakes[msg.sender] > 0, "PartyBid: Must be a DAO member to vote for bid proposal.");\n', '    // Ensure that caller has not already voted in favor of proposal\n', '    require(BidProposalSupporters[_proposalId][msg.sender] != true, "PartyBid: Cannot vote for a proposal twice.");\n', '\n', '    // Increment aggregate support with power(voter)\n', '    BidProposals[_proposalId].aggregateSupport = BidProposals[_proposalId].aggregateSupport.add(daoStakes[msg.sender]);\n', '\n', '    // Update supporters mapping\n', '    BidProposalSupporters[_proposalId][msg.sender] = true;\n', '\n', '    emit PartyProposalVote(_proposalId, msg.sender); // Emit new vote for proposal\n', '  }\n', '  \n', '  /**\n', '   * Execute a Zora bid proposal assuming it still exists and matches amount in storage\n', '   */\n', '  function DAOExecuteZoraBid(uint256 _proposalId) external onlyIfAuctionWon() {\n', '    // Ensure that caller is a DAO member\n', '    require(daoStakes[msg.sender] > 0, "PartyBid: Must first be a DAO member to execute bid proposal.");\n', '    // Ensure that the proposal being enacted has > 50% of supporting DAO vote\n', '    require(BidProposals[_proposalId].aggregateSupport > currentRaisedAmount.div(2), "PartyBid: Insufficient support to accept Zora bid.");\n', '\n', '    // Collect Bid from IMedia\n', '    IMarket.Bid memory bid = IMarket(IMediaModified(NFTAddress).marketContract()).bidForTokenBidder(auctionID, BidProposals[_proposalId].bidder);\n', '    \n', '    // Ensure that bid amount has not changed \n', '    require(BidProposals[_proposalId].amount == bid.amount, "PartyBid: Bid amount has changed during proposal voting.");\n', '\n', '    // Collect bidshares to calculate NFTResoldValue\n', '    IMarket.BidShares memory bidShares = IMarket(IMediaModified(NFTAddress).marketContract()).bidSharesForToken(auctionID);\n', '\n', '    // Accept bid from Imedia\n', '    IMediaExtended(NFTAddress).acceptBid(auctionID, bid);\n', '\n', '    // Update NFT price \n', '    NFTResold = true;\n', '    NFTResoldValue = ABDKMath64x64.mulu(\n', '      // Multiply the (bidShare of owner / total bidShare)\n', '      ABDKMath64x64.divu(bidShares.owner.value, 100000000000000000000),\n', '      // By the amount received through the bid\n', '      bid.amount\n', '    );\n', '\n', '    // Nullify proposal aggregate support to prevent resetting price via same proposal in future\n', '    BidProposals[_proposalId].aggregateSupport = 0;\n', '\n', '    emit PartyExecuteSale(NFTResoldValue); // Emit NFT sale price\n', '  }\n', '\n', '  // ============ Exit the DAO ============\n', '\n', '  /**\n', '   * Exit DAO if bid was won, and NFT was resold for NFTResoldValue\n', '   */\n', '  function _exitPostSale() internal {\n', '    // Require NFT to have already have been resold\n', '    require(NFTResold = true, "PartyBid: NFT has not yet been resold.");\n', '    // Failsafe: Ensure contract has non-zero funds to payout DAO members\n', '    require(IWETH(wETHAddress).balanceOf(address(this)) > 0, "PartyBid: DAO is insolvent.");\n', '    \n', '    // Send calculated share of NFTSalePrice based on DAO membership share\n', '    IWETH(wETHAddress).transferFrom(address(this), msg.sender,\n', '      // Multiply final NFT sale price\n', '      ABDKMath64x64.mulu(\n', '          // Multiply (dao_share / total)\n', '          ABDKMath64x64.divu(daoStakes[msg.sender], currentRaisedAmount),\n', '          // by final NFT sale price\n', '            NFTResoldValue)\n', '    );\n', '    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], false); // Emit exit event\n', '\n', '    // Nullify member DAO share\n', '    daoStakes[msg.sender] = 0;\n', '  }\n', '  \n', '  /**\n', '   * Exit DAO if bid was beaten\n', '   * @dev Capital returned in form of wETH due to 30,000 gas transfer limit imposed by ReserveAuctionV3\n', '   */\n', '  function _exitIfBidFailed() internal {\n', "    // Dont allow exiting via this function if bid hasn't been placed\n", '    require(bidPlaced == true, "PartyBid: Bid must be placed to exit via failure.");\n', '    // Ensure that contract wETH balance is > 0 (implying that either funds have been returned or wETH airdropped)\n', '    require(IWETH(wETHAddress).balanceOf(address(this)) > 0, "PartyBid: DAO bid has not been beaten or refunded yet.");\n', '\n', '    // Transfer wETH from contract to DAO member and emit event\n', '    IWETH(wETHAddress).transferFrom(address(this), msg.sender, daoStakes[msg.sender]);\n', '    currentRaisedAmount = currentRaisedAmount.sub(daoStakes[msg.sender]);\n', '    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], true); // Emit exit event\n', '\n', '    // Nullify member DAO share\n', '    daoStakes[msg.sender] = 0;\n', '  }\n', '\n', '  /**\n', '   * Exit DAO if deposit timeout has passed\n', '   */\n', '  function _exitIfTimeoutPassed() internal {\n', '    // Dont allow exiting via this function if bid has been placed\n', '    require(bidPlaced == false, "PartyBid: Bid must be pending to exit via timeout.");\n', '    // Ensure that current time > deposit timeout\n', '    require(block.timestamp >= exitTimeout, "PartyBid: Exit timeout not met.");\n', '\n', '    // Transfer ETH from contract to DAO member and emit event\n', '    payable(msg.sender).transfer(daoStakes[msg.sender]);\n', '    currentRaisedAmount = currentRaisedAmount.sub(daoStakes[msg.sender]);\n', '    emit PartyMemberExited(msg.sender, daoStakes[msg.sender], false); // Emit exit event\n', '\n', '    // Nullify member DAO share\n', '    daoStakes[msg.sender] = 0;\n', '  }\n', '\n', '  /**\n', '   * Public utility function to call internal exit functions based on bid state\n', '   */\n', '  function exit() external payable {\n', '    // Ensure that caller is a DAO member\n', '    require(daoStakes[msg.sender] > 0, "PartyBid: Must first be a DAO member to exit DAO.");\n', '\n', '    if (NFTResold) {\n', '      // If NFT has already been resold, allow post-sale exit\n', '      _exitPostSale();\n', '    } else {\n', '      if (bidPlaced) {\n', '        // If bid has been placed, allow exit on bid failure\n', '        _exitIfBidFailed();\n', '      } else {\n', '        // Else, allow exit when exit timeout window has passed\n', '        _exitIfTimeoutPassed();\n', '      }\n', '    }\n', '  }\n', '}']