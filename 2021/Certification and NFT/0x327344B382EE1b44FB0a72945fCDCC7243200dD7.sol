['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-14\n', '*/\n', '\n', '// File: contracts/lib/SafeMath.sol\n', '\n', '/*\n', '\n', '    Copyright 2020 DODO ZOO.\n', '    SPDX-License-Identifier: Apache-2.0\n', '\n', '*/\n', '\n', 'pragma solidity 0.6.9;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "MUL_ERROR");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "DIVIDING_ERROR");\n', '        return a / b;\n', '    }\n', '\n', '    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 quotient = div(a, b);\n', '        uint256 remainder = a - quotient * b;\n', '        if (remainder > 0) {\n', '            return quotient + 1;\n', '        } else {\n', '            return quotient;\n', '        }\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SUB_ERROR");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ADD_ERROR");\n', '        return c;\n', '    }\n', '\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = x / 2 + 1;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/DecimalMath.sol\n', '\n', '\n', '/**\n', ' * @title DecimalMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for fixed point number with 18 decimals\n', ' */\n', 'library DecimalMath {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 internal constant ONE = 10**18;\n', '    uint256 internal constant ONE2 = 10**36;\n', '\n', '    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(d) / (10**18);\n', '    }\n', '\n', '    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(d).divCeil(10**18);\n', '    }\n', '\n', '    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(10**18).div(d);\n', '    }\n', '\n', '    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(10**18).divCeil(d);\n', '    }\n', '\n', '    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\n', '        return uint256(10**36).div(target);\n', '    }\n', '\n', '    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\n', '        return uint256(10**36).divCeil(target);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Ownable.sol\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Ownership related functions\n', ' */\n', 'contract Ownable {\n', '    address public _OWNER_;\n', '    address public _NEW_OWNER_;\n', '\n', '    // ============ Events ============\n', '\n', '    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _OWNER_, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    constructor() internal {\n', '        _OWNER_ = msg.sender;\n', '        emit OwnershipTransferred(address(0), _OWNER_);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n', '        _NEW_OWNER_ = newOwner;\n', '    }\n', '\n', '    function claimOwnership() external {\n', '        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");\n', '        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n', '        _OWNER_ = _NEW_OWNER_;\n', '        _NEW_OWNER_ = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/intf/IERC20.sol\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}\n', '\n', '// File: contracts/lib/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n', '        );\n', '    }\n', '\n', '    function safeApprove(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require(\n', '            (value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/DODOVendingMachine/intf/IDVM.sol\n', '\n', '\n', 'interface IDVM {\n', '    function init(\n', '        address maintainer,\n', '        address baseTokenAddress,\n', '        address quoteTokenAddress,\n', '        uint256 lpFeeRate,\n', '        address mtFeeRateModel,\n', '        uint256 i,\n', '        uint256 k,\n', '        bool isOpenTWAP\n', '    ) external;\n', '\n', '    function _BASE_TOKEN_() external returns (address);\n', '\n', '    function _QUOTE_TOKEN_() external returns (address);\n', '\n', '    function _MT_FEE_RATE_MODEL_() external returns (address);\n', '\n', '    function getVaultReserve() external returns (uint256 baseReserve, uint256 quoteReserve);\n', '\n', '    function sellBase(address to) external returns (uint256);\n', '\n', '    function sellQuote(address to) external returns (uint256);\n', '\n', '    function buyShares(address to) external returns (uint256,uint256,uint256);\n', '\n', '}\n', '\n', '// File: contracts/lib/InitializableOwnable.sol\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Ownership related functions\n', ' */\n', 'contract InitializableOwnable {\n', '    address public _OWNER_;\n', '    address public _NEW_OWNER_;\n', '    bool internal _INITIALIZED_;\n', '\n', '    // ============ Events ============\n', '\n', '    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier notInitialized() {\n', '        require(!_INITIALIZED_, "DODO_INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _OWNER_, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    function initOwner(address newOwner) public notInitialized {\n', '        _INITIALIZED_ = true;\n', '        _OWNER_ = newOwner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n', '        _NEW_OWNER_ = newOwner;\n', '    }\n', '\n', '    function claimOwnership() public {\n', '        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");\n', '        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n', '        _OWNER_ = _NEW_OWNER_;\n', '        _NEW_OWNER_ = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/CloneFactory.sol\n', '\n', '\n', 'interface ICloneFactory {\n', '    function clone(address prototype) external returns (address proxy);\n', '}\n', '\n', '// introduction of proxy mode design: https://docs.openzeppelin.com/upgrades/2.8/\n', '// minimum implementation of transparent proxy: https://eips.ethereum.org/EIPS/eip-1167\n', '\n', 'contract CloneFactory is ICloneFactory {\n', '    function clone(address prototype) external override returns (address proxy) {\n', '        bytes20 targetBytes = bytes20(prototype);\n', '        assembly {\n', '            let clone := mload(0x40)\n', '            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(clone, 0x14), targetBytes)\n', '            mstore(\n', '                add(clone, 0x28),\n', '                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n', '            )\n', '            proxy := create(0, clone, 0x37)\n', '        }\n', '        return proxy;\n', '    }\n', '}\n', '\n', '// File: contracts/Factory/DVMFactory.sol\n', '\n', '\n', '\n', '\n', 'interface IDVMFactory {\n', '    function createDODOVendingMachine(\n', '        address baseToken,\n', '        address quoteToken,\n', '        uint256 lpFeeRate,\n', '        uint256 i,\n', '        uint256 k,\n', '        bool isOpenTWAP\n', '    ) external returns (address newVendingMachine);\n', '}\n', '\n', '\n', '/**\n', ' * @title DODO VendingMachine Factory\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Create And Register DVM Pools \n', ' */\n', 'contract DVMFactory is InitializableOwnable {\n', '    // ============ Templates ============\n', '\n', '    address public immutable _CLONE_FACTORY_;\n', '    address public immutable _DEFAULT_MAINTAINER_;\n', '    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\n', '    address public _DVM_TEMPLATE_;\n', '\n', '    // ============ Registry ============\n', '\n', '    // base -> quote -> DVM address list\n', '    mapping(address => mapping(address => address[])) public _REGISTRY_;\n', '    // creator -> DVM address list\n', '    mapping(address => address[]) public _USER_REGISTRY_;\n', '\n', '    // ============ Events ============\n', '\n', '    event NewDVM(\n', '        address baseToken,\n', '        address quoteToken,\n', '        address creator,\n', '        address dvm\n', '    );\n', '\n', '    event RemoveDVM(address dvm);\n', '\n', '    // ============ Functions ============\n', '\n', '    constructor(\n', '        address cloneFactory,\n', '        address dvmTemplate,\n', '        address defaultMaintainer,\n', '        address defaultMtFeeRateModel\n', '    ) public {\n', '        _CLONE_FACTORY_ = cloneFactory;\n', '        _DVM_TEMPLATE_ = dvmTemplate;\n', '        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n', '        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\n', '    }\n', '\n', '    function createDODOVendingMachine(\n', '        address baseToken,\n', '        address quoteToken,\n', '        uint256 lpFeeRate,\n', '        uint256 i,\n', '        uint256 k,\n', '        bool isOpenTWAP\n', '    ) external returns (address newVendingMachine) {\n', '        newVendingMachine = ICloneFactory(_CLONE_FACTORY_).clone(_DVM_TEMPLATE_);\n', '        {\n', '            IDVM(newVendingMachine).init(\n', '                _DEFAULT_MAINTAINER_,\n', '                baseToken,\n', '                quoteToken,\n', '                lpFeeRate,\n', '                _DEFAULT_MT_FEE_RATE_MODEL_,\n', '                i,\n', '                k,\n', '                isOpenTWAP\n', '            );\n', '        }\n', '        _REGISTRY_[baseToken][quoteToken].push(newVendingMachine);\n', '        _USER_REGISTRY_[tx.origin].push(newVendingMachine);\n', '        emit NewDVM(baseToken, quoteToken, tx.origin, newVendingMachine);\n', '    }\n', '\n', '    // ============ Admin Operation Functions ============\n', '\n', '    function updateDvmTemplate(address _newDVMTemplate) external onlyOwner {\n', '        _DVM_TEMPLATE_ = _newDVMTemplate;\n', '    }\n', '\n', '    function addPoolByAdmin(\n', '        address creator,\n', '        address baseToken, \n', '        address quoteToken,\n', '        address pool\n', '    ) external onlyOwner {\n', '        _REGISTRY_[baseToken][quoteToken].push(pool);\n', '        _USER_REGISTRY_[creator].push(pool);\n', '        emit NewDVM(baseToken, quoteToken, creator, pool);\n', '    }\n', '\n', '    function removePoolByAdmin(\n', '        address creator,\n', '        address baseToken, \n', '        address quoteToken,\n', '        address pool\n', '    ) external onlyOwner {\n', '        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\n', '        for (uint256 i = 0; i < registryList.length; i++) {\n', '            if (registryList[i] == pool) {\n', '                registryList[i] = registryList[registryList.length - 1];\n', '                break;\n', '            }\n', '        }\n', '        _REGISTRY_[baseToken][quoteToken] = registryList;\n', '        _REGISTRY_[baseToken][quoteToken].pop();\n', '        address[] memory userRegistryList = _USER_REGISTRY_[creator];\n', '        for (uint256 i = 0; i < userRegistryList.length; i++) {\n', '            if (userRegistryList[i] == pool) {\n', '                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\n', '                break;\n', '            }\n', '        }\n', '        _USER_REGISTRY_[creator] = userRegistryList;\n', '        _USER_REGISTRY_[creator].pop();\n', '        emit RemoveDVM(pool);\n', '    }\n', '\n', '    // ============ View Functions ============\n', '\n', '    function getDODOPool(address baseToken, address quoteToken)\n', '        external\n', '        view\n', '        returns (address[] memory machines)\n', '    {\n', '        return _REGISTRY_[baseToken][quoteToken];\n', '    }\n', '\n', '    function getDODOPoolBidirection(address token0, address token1)\n', '        external\n', '        view\n', '        returns (address[] memory baseToken0Machines, address[] memory baseToken1Machines)\n', '    {\n', '        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\n', '    }\n', '\n', '    function getDODOPoolByUser(address user)\n', '        external\n', '        view\n', '        returns (address[] memory machines)\n', '    {\n', '        return _USER_REGISTRY_[user];\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ReentrancyGuard.sol\n', '\n', '\n', '/**\n', ' * @title ReentrancyGuard\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Protect functions from Reentrancy Attack\n', ' */\n', 'contract ReentrancyGuard {\n', '    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\n', '    // zero-state of _ENTERED_ is false\n', '    bool private _ENTERED_;\n', '\n', '    modifier preventReentrant() {\n', '        require(!_ENTERED_, "REENTRANT");\n', '        _ENTERED_ = true;\n', '        _;\n', '        _ENTERED_ = false;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/PermissionManager.sol\n', '\n', '\n', '\n', 'interface IPermissionManager {\n', '    function initOwner(address) external;\n', '\n', '    function isAllowed(address) external view returns (bool);\n', '}\n', '\n', 'contract PermissionManager is InitializableOwnable {\n', '    bool public _WHITELIST_MODE_ON_;\n', '\n', '    mapping(address => bool) internal _whitelist_;\n', '    mapping(address => bool) internal _blacklist_;\n', '\n', '    function isAllowed(address account) external view returns (bool) {\n', '        if (_WHITELIST_MODE_ON_) {\n', '            return _whitelist_[account];\n', '        } else {\n', '            return !_blacklist_[account];\n', '        }\n', '    }\n', '\n', '    function openBlacklistMode() external onlyOwner {\n', '        _WHITELIST_MODE_ON_ = false;\n', '    }\n', '\n', '    function openWhitelistMode() external onlyOwner {\n', '        _WHITELIST_MODE_ON_ = true;\n', '    }\n', '\n', '    function addToWhitelist(address account) external onlyOwner {\n', '        _whitelist_[account] = true;\n', '    }\n', '\n', '    function removeFromWhitelist(address account) external onlyOwner {\n', '        _whitelist_[account] = false;\n', '    }\n', '\n', '    function addToBlacklist(address account) external onlyOwner {\n', '        _blacklist_[account] = true;\n', '    }\n', '\n', '    function removeFromBlacklist(address account) external onlyOwner {\n', '        _blacklist_[account] = false;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/FeeRateModel.sol\n', '\n', '\n', 'interface IFeeRateImpl {\n', '    function getFeeRate(address pool, address trader) external view returns (uint256);\n', '}\n', '\n', 'interface IFeeRateModel {\n', '    function getFeeRate(address trader) external view returns (uint256);\n', '}\n', '\n', 'contract FeeRateModel is InitializableOwnable {\n', '    address public feeRateImpl;\n', '\n', '    function setFeeProxy(address _feeRateImpl) public onlyOwner {\n', '        feeRateImpl = _feeRateImpl;\n', '    }\n', '    \n', '    function getFeeRate(address trader) external view returns (uint256) {\n', '        if(feeRateImpl == address(0))\n', '            return 0;\n', '        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender,trader);\n', '    }\n', '}\n', '\n', '// File: contracts/CrowdPooling/impl/CPStorage.sol\n', '\n', 'contract CPStorage is InitializableOwnable, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constant ============\n', '    \n', '    uint256 internal constant _SETTLEMENT_EXPIRE_ = 86400 * 7;\n', '    uint256 internal constant _SETTEL_FUND_ = 200 finney;\n', '    bool public _IS_OPEN_TWAP_ = false;\n', '\n', '    // ============ Timeline ============\n', '\n', '    uint256 public _PHASE_BID_STARTTIME_;\n', '    uint256 public _PHASE_BID_ENDTIME_;\n', '    uint256 public _PHASE_CALM_ENDTIME_;\n', '    uint256 public _SETTLED_TIME_;\n', '    bool public _SETTLED_;\n', '\n', '    // ============ Core Address ============\n', '\n', '    IERC20 public _BASE_TOKEN_;\n', '    IERC20 public _QUOTE_TOKEN_;\n', '\n', '    // ============ Distribution Parameters ============\n', '\n', '    uint256 public _TOTAL_BASE_;\n', '    uint256 public _POOL_QUOTE_CAP_;\n', '\n', '    // ============ Settlement ============\n', '\n', '    uint256 public _QUOTE_RESERVE_;\n', '\n', '    uint256 public _UNUSED_BASE_;\n', '    uint256 public _UNUSED_QUOTE_;\n', '\n', '    uint256 public _TOTAL_SHARES_;\n', '    mapping(address => uint256) internal _SHARES_;\n', '    mapping(address => bool) public _CLAIMED_;\n', '\n', '    address public _POOL_FACTORY_;\n', '    address public _POOL_;\n', '    uint256 public _AVG_SETTLED_PRICE_;\n', '\n', '    // ============ Advanced Control ============\n', '\n', '    address public _MAINTAINER_;\n', '    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n', '    IPermissionManager public _BIDDER_PERMISSION_;\n', '\n', '    // ============ PMM Parameters ============\n', '\n', '    uint256 public _K_;\n', '    uint256 public _I_;\n', '\n', '    // ============ LP Token Vesting ============\n', '\n', '    uint256 public _TOTAL_LP_AMOUNT_;\n', '    uint256 public _FREEZE_DURATION_;\n', '    uint256 public _VESTING_DURATION_;\n', '    uint256 public _CLIFF_RATE_;\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier phaseBid() {\n', '        require(\n', '            block.timestamp >= _PHASE_BID_STARTTIME_ && block.timestamp < _PHASE_BID_ENDTIME_,\n', '            "NOT_PHASE_BID"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier phaseCalm() {\n', '        require(\n', '            block.timestamp >= _PHASE_BID_ENDTIME_ && block.timestamp < _PHASE_CALM_ENDTIME_,\n', '            "NOT_PHASE_CALM"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier phaseBidOrCalm() {\n', '        require(\n', '            block.timestamp >= _PHASE_BID_STARTTIME_ && block.timestamp < _PHASE_CALM_ENDTIME_,\n', '            "NOT_PHASE_BID_OR_CALM"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier phaseSettlement() {\n', '        require(block.timestamp >= _PHASE_CALM_ENDTIME_, "NOT_PHASE_EXE");\n', '        _;\n', '    }\n', '\n', '    modifier phaseVesting() {\n', '        require(_SETTLED_, "NOT_VESTING");\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/DODOMath.sol\n', '\n', '\n', '/**\n', ' * @title DODOMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n', ' */\n', 'library DODOMath {\n', '    using SafeMath for uint256;\n', '\n', '    /*\n', '        Integrate dodo curve from V1 to V2\n', '        require V0>=V1>=V2>0\n', '        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n', '        let V1-V2=delta\n', '        res = i*delta*(1-k+k(V0^2/V1/V2))\n', '\n', '        i is the price of V-res trading pair\n', '\n', '        support k=1 & k=0 case\n', '\n', '        [round down]\n', '    */\n', '    function _GeneralIntegrate(\n', '        uint256 V0,\n', '        uint256 V1,\n', '        uint256 V2,\n', '        uint256 i,\n', '        uint256 k\n', '    ) internal pure returns (uint256) {\n', '        require(V0 > 0, "TARGET_IS_ZERO");\n', '        uint256 fairAmount = i.mul(V1.sub(V2)); // i*delta\n', '        if (k == 0) {\n', '            return fairAmount.div(DecimalMath.ONE);\n', '        }\n', '        uint256 V0V0V1V2 = DecimalMath.divFloor(V0.mul(V0).div(V1), V2);\n', '        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n', '        return DecimalMath.ONE.sub(k).add(penalty).mul(fairAmount).div(DecimalMath.ONE2);\n', '    }\n', '\n', '    /*\n', '        Follow the integration function above\n', '        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n', '        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n', '\n', '        i is the price of delta-V trading pair\n', '        give out target of V\n', '\n', '        support k=1 & k=0 case\n', '\n', '        [round down]\n', '    */\n', '    function _SolveQuadraticFunctionForTarget(\n', '        uint256 V1,\n', '        uint256 delta,\n', '        uint256 i,\n', '        uint256 k\n', '    ) internal pure returns (uint256) {\n', '        if (V1 == 0) {\n', '            return 0;\n', '        }\n', '        if (k == 0) {\n', '            return V1.add(DecimalMath.mulFloor(i, delta));\n', '        }\n', '        // V0 = V1*(1+(sqrt-1)/2k)\n', '        // sqrt = √(1+4kidelta/V1)\n', '        // premium = 1+(sqrt-1)/2k\n', '        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\n', '        uint256 sqrt;\n', '        uint256 ki = (4 * k).mul(i);\n', '        if (ki == 0) {\n', '            sqrt = DecimalMath.ONE;\n', '        } else if ((ki * delta) / ki == delta) {\n', '            sqrt = (ki * delta).div(V1).add(DecimalMath.ONE2).sqrt();\n', '        } else {\n', '            sqrt = ki.div(V1).mul(delta).add(DecimalMath.ONE2).sqrt();\n', '        }\n', '        uint256 premium =\n', '            DecimalMath.divFloor(sqrt.sub(DecimalMath.ONE), k * 2).add(DecimalMath.ONE);\n', '        // V0 is greater than or equal to V1 according to the solution\n', '        return DecimalMath.mulFloor(V1, premium);\n', '    }\n', '\n', '    /*\n', '        Follow the integration expression above, we have:\n', '        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n', '        Given Q1 and deltaB, solve Q2\n', '        This is a quadratic function and the standard version is\n', '        aQ2^2 + bQ2 + c = 0, where\n', '        a=1-k\n', '        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n', '        c=-kQ0^2 \n', '        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n', '        note: another root is negative, abondan\n', '\n', '        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\n', '        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\n', '        return |Q1-Q2|\n', '\n', '        as we only support sell amount as delta, the deltaB is always negative\n', '        the input ideltaB is actually -ideltaB in the equation\n', '\n', '        i is the price of delta-V trading pair\n', '\n', '        support k=1 & k=0 case\n', '\n', '        [round down]\n', '    */\n', '    function _SolveQuadraticFunctionForTrade(\n', '        uint256 V0,\n', '        uint256 V1,\n', '        uint256 delta,\n', '        uint256 i,\n', '        uint256 k\n', '    ) internal pure returns (uint256) {\n', '        require(V0 > 0, "TARGET_IS_ZERO");\n', '        if (delta == 0) {\n', '            return 0;\n', '        }\n', '\n', '        if (k == 0) {\n', '            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\n', '        }\n', '\n', '        if (k == DecimalMath.ONE) {\n', '            // if k==1\n', '            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\n', '            // temp = ideltaBQ1/Q0/Q0\n', '            // Q2 = Q1/(1+temp)\n', '            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\n', '            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\n', '            uint256 temp;\n', '            uint256 idelta = i.mul(delta);\n', '            if (idelta == 0) {\n', '                temp = 0;\n', '            } else if ((idelta * V1) / idelta == V1) {\n', '                temp = (idelta * V1).div(V0.mul(V0));\n', '            } else {\n', '                temp = delta.mul(V1).div(V0).mul(i).div(V0);\n', '            }\n', '            return V1.mul(temp).div(temp.add(DecimalMath.ONE));\n', '        }\n', '\n', '        // calculate -b value and sig\n', '        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\n', '        // part1 = (1-k)Q1 >=0\n', '        // part2 = kQ0^2/Q1-i*deltaB >=0\n', '        // bAbs = abs(part1-part2)\n', '        // if part1>part2 => b is negative => bSig is false\n', '        // if part2>part1 => b is positive => bSig is true\n', '        uint256 part2 = k.mul(V0).div(V1).mul(V0).add(i.mul(delta)); // kQ0^2/Q1-i*deltaB\n', '        uint256 bAbs = DecimalMath.ONE.sub(k).mul(V1); // (1-k)Q1\n', '\n', '        bool bSig;\n', '        if (bAbs >= part2) {\n', '            bAbs = bAbs - part2;\n', '            bSig = false;\n', '        } else {\n', '            bAbs = part2 - bAbs;\n', '            bSig = true;\n', '        }\n', '        bAbs = bAbs.div(DecimalMath.ONE);\n', '\n', '        // calculate sqrt\n', '        uint256 squareRoot =\n', '            DecimalMath.mulFloor(\n', '                DecimalMath.ONE.sub(k).mul(4),\n', '                DecimalMath.mulFloor(k, V0).mul(V0)\n', '            ); // 4(1-k)kQ0^2\n', '        squareRoot = bAbs.mul(bAbs).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n', '\n', '        // final res\n', '        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\n', '        uint256 numerator;\n', '        if (bSig) {\n', '            numerator = squareRoot.sub(bAbs);\n', '        } else {\n', '            numerator = bAbs.add(squareRoot);\n', '        }\n', '\n', '        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\n', '        if (V2 > V1) {\n', '            return 0;\n', '        } else {\n', '            return V1 - V2;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/PMMPricing.sol\n', '\n', '\n', '/**\n', ' * @title Pricing\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice DODO Pricing model\n', ' */\n', '\n', 'library PMMPricing {\n', '    using SafeMath for uint256;\n', '\n', '    enum RState {ONE, ABOVE_ONE, BELOW_ONE}\n', '\n', '    struct PMMState {\n', '        uint256 i;\n', '        uint256 K;\n', '        uint256 B;\n', '        uint256 Q;\n', '        uint256 B0;\n', '        uint256 Q0;\n', '        RState R;\n', '    }\n', '\n', '    // ============ buy & sell ============\n', '\n', '    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\n', '        internal\n', '        pure\n', '        returns (uint256 receiveQuoteAmount, RState newR)\n', '    {\n', '        if (state.R == RState.ONE) {\n', '            // case 1: R=1\n', '            // R falls below one\n', '            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n', '            newR = RState.BELOW_ONE;\n', '        } else if (state.R == RState.ABOVE_ONE) {\n', '            uint256 backToOnePayBase = state.B0.sub(state.B);\n', '            uint256 backToOneReceiveQuote = state.Q.sub(state.Q0);\n', '            // case 2: R>1\n', '            // complex case, R status depends on trading amount\n', '            if (payBaseAmount < backToOnePayBase) {\n', '                // case 2.1: R status do not change\n', '                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\n', '                newR = RState.ABOVE_ONE;\n', '                if (receiveQuoteAmount > backToOneReceiveQuote) {\n', '                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n', '                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n', '                    receiveQuoteAmount = backToOneReceiveQuote;\n', '                }\n', '            } else if (payBaseAmount == backToOnePayBase) {\n', '                // case 2.2: R status changes to ONE\n', '                receiveQuoteAmount = backToOneReceiveQuote;\n', '                newR = RState.ONE;\n', '            } else {\n', '                // case 2.3: R status changes to BELOW_ONE\n', '                receiveQuoteAmount = backToOneReceiveQuote.add(\n', '                    _ROneSellBaseToken(state, payBaseAmount.sub(backToOnePayBase))\n', '                );\n', '                newR = RState.BELOW_ONE;\n', '            }\n', '        } else {\n', '            // state.R == RState.BELOW_ONE\n', '            // case 3: R<1\n', '            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\n', '            newR = RState.BELOW_ONE;\n', '        }\n', '    }\n', '\n', '    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n', '        internal\n', '        pure\n', '        returns (uint256 receiveBaseAmount, RState newR)\n', '    {\n', '        if (state.R == RState.ONE) {\n', '            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\n', '            newR = RState.ABOVE_ONE;\n', '        } else if (state.R == RState.ABOVE_ONE) {\n', '            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\n', '            newR = RState.ABOVE_ONE;\n', '        } else {\n', '            uint256 backToOnePayQuote = state.Q0.sub(state.Q);\n', '            uint256 backToOneReceiveBase = state.B.sub(state.B0);\n', '            if (payQuoteAmount < backToOnePayQuote) {\n', '                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\n', '                newR = RState.BELOW_ONE;\n', '                if (receiveBaseAmount > backToOneReceiveBase) {\n', '                    receiveBaseAmount = backToOneReceiveBase;\n', '                }\n', '            } else if (payQuoteAmount == backToOnePayQuote) {\n', '                receiveBaseAmount = backToOneReceiveBase;\n', '                newR = RState.ONE;\n', '            } else {\n', '                receiveBaseAmount = backToOneReceiveBase.add(\n', '                    _ROneSellQuoteToken(state, payQuoteAmount.sub(backToOnePayQuote))\n', '                );\n', '                newR = RState.ABOVE_ONE;\n', '            }\n', '        }\n', '    }\n', '\n', '    // ============ R = 1 cases ============\n', '\n', '    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveQuoteToken\n', '        )\n', '    {\n', '        // in theory Q2 <= targetQuoteTokenAmount\n', '        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n', '        return\n', '            DODOMath._SolveQuadraticFunctionForTrade(\n', '                state.Q0,\n', '                state.Q0,\n', '                payBaseAmount,\n', '                state.i,\n', '                state.K\n', '            );\n', '    }\n', '\n', '    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveBaseToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._SolveQuadraticFunctionForTrade(\n', '                state.B0,\n', '                state.B0,\n', '                payQuoteAmount,\n', '                DecimalMath.reciprocalFloor(state.i),\n', '                state.K\n', '            );\n', '    }\n', '\n', '    // ============ R < 1 cases ============\n', '\n', '    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveBaseToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._GeneralIntegrate(\n', '                state.Q0,\n', '                state.Q.add(payQuoteAmount),\n', '                state.Q,\n', '                DecimalMath.reciprocalFloor(state.i),\n', '                state.K\n', '            );\n', '    }\n', '\n', '    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveQuoteToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._SolveQuadraticFunctionForTrade(\n', '                state.Q0,\n', '                state.Q,\n', '                payBaseAmount,\n', '                state.i,\n', '                state.K\n', '            );\n', '    }\n', '\n', '    // ============ R > 1 cases ============\n', '\n', '    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveQuoteToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._GeneralIntegrate(\n', '                state.B0,\n', '                state.B.add(payBaseAmount),\n', '                state.B,\n', '                state.i,\n', '                state.K\n', '            );\n', '    }\n', '\n', '    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveBaseToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._SolveQuadraticFunctionForTrade(\n', '                state.B0,\n', '                state.B,\n', '                payQuoteAmount,\n', '                DecimalMath.reciprocalFloor(state.i),\n', '                state.K\n', '            );\n', '    }\n', '\n', '    // ============ Helper functions ============\n', '\n', '    function adjustedTarget(PMMState memory state) internal pure {\n', '        if (state.R == RState.BELOW_ONE) {\n', '            state.Q0 = DODOMath._SolveQuadraticFunctionForTarget(\n', '                state.Q,\n', '                state.B.sub(state.B0),\n', '                state.i,\n', '                state.K\n', '            );\n', '        } else if (state.R == RState.ABOVE_ONE) {\n', '            state.B0 = DODOMath._SolveQuadraticFunctionForTarget(\n', '                state.B,\n', '                state.Q.sub(state.Q0),\n', '                DecimalMath.reciprocalFloor(state.i),\n', '                state.K\n', '            );\n', '        }\n', '    }\n', '\n', '    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\n', '        if (state.R == RState.BELOW_ONE) {\n', '            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\n', '            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n', '            return DecimalMath.divFloor(state.i, R);\n', '        } else {\n', '            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\n', '            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n', '            return DecimalMath.mulFloor(state.i, R);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/intf/IDODOCallee.sol\n', '\n', '\n', 'interface IDODOCallee {\n', '    function DVMSellShareCall(\n', '        address sender,\n', '        uint256 burnShareAmount,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function DVMFlashLoanCall(\n', '        address sender,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function DPPFlashLoanCall(\n', '        address sender,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function CPCancelCall(\n', '        address sender,\n', '        uint256 amount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '\tfunction CPClaimBidCall(\n', '        address sender,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// File: contracts/CrowdPooling/impl/CPFunding.sol\n', '\n', '\n', '\n', '\n', '\n', 'contract CPFunding is CPStorage {\n', '    using SafeERC20 for IERC20;\n', '    \n', '    // ============ Events ============\n', '    \n', '    event Bid(address to, uint256 amount, uint256 fee);\n', '    event Cancel(address to,uint256 amount);\n', '    event Settle();\n', '\n', '    // ============ BID & CALM PHASE ============\n', '    \n', '    modifier isBidderAllow(address bidder) {\n', '        require(_BIDDER_PERMISSION_.isAllowed(bidder), "BIDDER_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    function bid(address to) external phaseBid preventReentrant isBidderAllow(to) {\n', '        uint256 input = _getQuoteInput();\n', '        uint256 mtFee = DecimalMath.mulFloor(input, _MT_FEE_RATE_MODEL_.getFeeRate(to));\n', '        _transferQuoteOut(_MAINTAINER_, mtFee);\n', '        _mintShares(to, input.sub(mtFee));\n', '        _sync();\n', '        emit Bid(to, input, mtFee);\n', '    }\n', '\n', '    function cancel(address to, uint256 amount, bytes calldata data) external phaseBidOrCalm preventReentrant {\n', '        require(_SHARES_[msg.sender] >= amount, "SHARES_NOT_ENOUGH");\n', '        _burnShares(msg.sender, amount);\n', '        _transferQuoteOut(to, amount);\n', '        _sync();\n', '\n', '        if(data.length > 0){\n', '            IDODOCallee(to).CPCancelCall(msg.sender,amount,data);\n', '        }\n', '\n', '        emit Cancel(msg.sender,amount);\n', '    }\n', '\n', '    function _mintShares(address to, uint256 amount) internal {\n', '        _SHARES_[to] = _SHARES_[to].add(amount);\n', '        _TOTAL_SHARES_ = _TOTAL_SHARES_.add(amount);\n', '    }\n', '\n', '    function _burnShares(address from, uint256 amount) internal {\n', '        _SHARES_[from] = _SHARES_[from].sub(amount);\n', '        _TOTAL_SHARES_ = _TOTAL_SHARES_.sub(amount);\n', '    }\n', '\n', '    // ============ SETTLEMENT ============\n', '\n', '    function settle() external phaseSettlement preventReentrant {\n', '        _settle();\n', '\n', '        (uint256 poolBase, uint256 poolQuote, uint256 poolI, uint256 unUsedBase, uint256 unUsedQuote) = getSettleResult();\n', '        _UNUSED_BASE_ = unUsedBase;\n', '        _UNUSED_QUOTE_ = unUsedQuote;\n', '\n', '        address _poolBaseToken;\n', '        address _poolQuoteToken;\n', '\n', '        if (_UNUSED_BASE_ > poolBase) {\n', '            _poolBaseToken = address(_QUOTE_TOKEN_);\n', '            _poolQuoteToken = address(_BASE_TOKEN_);\n', '        } else {\n', '            _poolBaseToken = address(_BASE_TOKEN_);\n', '            _poolQuoteToken = address(_QUOTE_TOKEN_);\n', '        }\n', '\n', '        _POOL_ = IDVMFactory(_POOL_FACTORY_).createDODOVendingMachine(\n', '            _poolBaseToken,\n', '            _poolQuoteToken,\n', '            3e15, // 0.3% lp feeRate\n', '            poolI,\n', '            DecimalMath.ONE,\n', '            _IS_OPEN_TWAP_\n', '        );\n', '\n', '        uint256 avgPrice = unUsedBase == 0 ? _I_ : DecimalMath.divCeil(poolQuote, unUsedBase);\n', '        _AVG_SETTLED_PRICE_ = avgPrice;\n', '\n', '        _transferBaseOut(_POOL_, poolBase);\n', '        _transferQuoteOut(_POOL_, poolQuote);\n', '\n', '        (_TOTAL_LP_AMOUNT_, ,) = IDVM(_POOL_).buyShares(address(this));\n', '\n', '        msg.sender.transfer(_SETTEL_FUND_);\n', '\n', '        emit Settle();\n', '    }\n', '\n', '    // in case something wrong with base token contract\n', '    function emergencySettle() external phaseSettlement preventReentrant {\n', '        require(block.timestamp >= _PHASE_CALM_ENDTIME_.add(_SETTLEMENT_EXPIRE_), "NOT_EMERGENCY");\n', '        _settle();\n', '        _UNUSED_QUOTE_ = _QUOTE_TOKEN_.balanceOf(address(this));\n', '    }\n', '\n', '    function _settle() internal {\n', '        require(!_SETTLED_, "ALREADY_SETTLED");\n', '        _SETTLED_ = true;\n', '        _SETTLED_TIME_ = block.timestamp;\n', '    }\n', '\n', '    // ============ Pricing ============\n', '\n', '    function getSettleResult() public view returns (uint256 poolBase, uint256 poolQuote, uint256 poolI, uint256 unUsedBase, uint256 unUsedQuote) {\n', '        poolQuote = _QUOTE_TOKEN_.balanceOf(address(this));\n', '        if (poolQuote > _POOL_QUOTE_CAP_) {\n', '            poolQuote = _POOL_QUOTE_CAP_;\n', '        }\n', '        (uint256 soldBase,) = PMMPricing.sellQuoteToken(_getPMMState(), poolQuote);\n', '        poolBase = _TOTAL_BASE_.sub(soldBase);\n', '\n', '        unUsedQuote = _QUOTE_TOKEN_.balanceOf(address(this)).sub(poolQuote);\n', '        unUsedBase = _BASE_TOKEN_.balanceOf(address(this)).sub(poolBase);\n', '\n', '        // Try to make midPrice equal to avgPrice\n', '        // k=1, If quote and base are not balanced, one side must be cut off\n', '        // DVM truncated quote, but if more quote than base entering the pool, we need set the quote to the base\n', '\n', '        // m = avgPrice\n', '        // i = m (1-quote/(m*base))\n', '        // if quote = m*base i = 1\n', '        // if quote > m*base reverse\n', '        uint256 avgPrice = unUsedBase == 0 ? _I_ : DecimalMath.divCeil(poolQuote, unUsedBase);\n', '        uint256 baseDepth = DecimalMath.mulFloor(avgPrice, poolBase);\n', '\n', '        if (poolQuote == 0) {\n', '            // ask side only DVM\n', '            poolI = _I_;\n', '        } else if (unUsedBase== poolBase) {\n', '            // standard bonding curve\n', '            poolI = 1;\n', '        } else if (unUsedBase < poolBase) {\n', '            // poolI up round\n', '            uint256 ratio = DecimalMath.ONE.sub(DecimalMath.divFloor(poolQuote, baseDepth));\n', '            poolI = avgPrice.mul(ratio).mul(ratio).divCeil(DecimalMath.ONE2);\n', '        } else if (unUsedBase > poolBase) {\n', '            // poolI down round\n', '            uint256 ratio = DecimalMath.ONE.sub(DecimalMath.divCeil(baseDepth, poolQuote));\n', '            poolI = ratio.mul(ratio).div(avgPrice);\n', '        }\n', '    }\n', '\n', '    function _getPMMState() internal view returns (PMMPricing.PMMState memory state) {\n', '        state.i = _I_;\n', '        state.K = _K_;\n', '        state.B = _TOTAL_BASE_;\n', '        state.Q = 0;\n', '        state.B0 = state.B;\n', '        state.Q0 = 0;\n', '        state.R = PMMPricing.RState.ONE;\n', '    }\n', '\n', '    function getExpectedAvgPrice() external view returns (uint256) {\n', '        require(!_SETTLED_, "ALREADY_SETTLED");\n', '        (uint256 poolBase, uint256 poolQuote, , , ) = getSettleResult();\n', '        return DecimalMath.divCeil(poolQuote, _BASE_TOKEN_.balanceOf(address(this)).sub(poolBase));\n', '    }\n', '\n', '    // ============ Asset In ============\n', '\n', '    function _getQuoteInput() internal view returns (uint256 input) {\n', '        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(_QUOTE_RESERVE_);\n', '    }\n', '\n', '    // ============ Set States ============\n', '\n', '    function _sync() internal {\n', '        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n', '        if (quoteBalance != _QUOTE_RESERVE_) {\n', '            _QUOTE_RESERVE_ = quoteBalance;\n', '        }\n', '    }\n', '\n', '    // ============ Asset Out ============\n', '\n', '    function _transferBaseOut(address to, uint256 amount) internal {\n', '        if (amount > 0) {\n', '            _BASE_TOKEN_.safeTransfer(to, amount);\n', '        }\n', '    }\n', '\n', '    function _transferQuoteOut(address to, uint256 amount) internal {\n', '        if (amount > 0) {\n', '            _QUOTE_TOKEN_.safeTransfer(to, amount);\n', '        }\n', '    }\n', '\n', '    function getShares(address user) external view returns (uint256) {\n', '        return _SHARES_[user];\n', '    }\n', '}\n', '\n', '// File: contracts/CrowdPooling/impl/CPVesting.sol\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title CPVesting\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Lock Token and release it linearly\n', ' */\n', '\n', 'contract CPVesting is CPFunding {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // ============ Events ============\n', '    \n', '    event Claim(address user, uint256 baseAmount, uint256 quoteAmount);\n', '    event ClaimLP(uint256 amount);\n', '\n', '\n', '    // ================ Modifiers ================\n', '\n', '    modifier afterSettlement() {\n', '        require(_SETTLED_, "NOT_SETTLED");\n', '        _;\n', '    }\n', '\n', '    modifier afterFreeze() {\n', '        require(_SETTLED_ && block.timestamp >= _SETTLED_TIME_.add(_FREEZE_DURATION_), "FREEZED");\n', '        _;\n', '    }\n', '\n', '    // ============ Bidder Functions ============\n', '\n', '    function bidderClaim(address to,bytes calldata data) external afterSettlement {\n', '        require(!_CLAIMED_[msg.sender], "ALREADY_CLAIMED");\n', '        _CLAIMED_[msg.sender] = true;\n', '\n', '\t\tuint256 baseAmount = _UNUSED_BASE_.mul(_SHARES_[msg.sender]).div(_TOTAL_SHARES_);\n', '\t\tuint256 quoteAmount = _UNUSED_QUOTE_.mul(_SHARES_[msg.sender]).div(_TOTAL_SHARES_);\n', '\n', '        _transferBaseOut(to, baseAmount);\n', '        _transferQuoteOut(to, quoteAmount);\n', '\n', '\t\tif(data.length>0){\n', '\t\t\tIDODOCallee(to).CPClaimBidCall(msg.sender,baseAmount,quoteAmount,data);\n', '\t\t}\n', '\n', '        emit Claim(msg.sender, baseAmount, quoteAmount);\n', '    }\n', '\n', '    // ============ Owner Functions ============\n', '\n', '    function claimLPToken() external onlyOwner afterFreeze {\n', '        uint256 lpAmount = getClaimableLPToken();\n', '        IERC20(_POOL_).safeTransfer(_OWNER_, lpAmount);\n', '        emit ClaimLP(lpAmount);\n', '    }\n', '\n', '    function getClaimableLPToken() public view afterFreeze returns (uint256) {\n', '        uint256 remainingLPToken = DecimalMath.mulFloor(\n', '            getRemainingLPRatio(block.timestamp),\n', '            _TOTAL_LP_AMOUNT_\n', '        );\n', '        return IERC20(_POOL_).balanceOf(address(this)).sub(remainingLPToken);\n', '    }\n', '\n', '    function getRemainingLPRatio(uint256 timestamp) public view afterFreeze returns (uint256) {\n', '        uint256 timePast = timestamp.sub(_SETTLED_TIME_.add(_FREEZE_DURATION_));\n', '        if (timePast < _VESTING_DURATION_) {\n', '            uint256 remainingTime = _VESTING_DURATION_.sub(timePast);\n', '            return DecimalMath.ONE.sub(_CLIFF_RATE_).mul(remainingTime).div(_VESTING_DURATION_);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/CrowdPooling/impl/CP.sol\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title DODO CrowdPooling\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice CrowdPooling initialization\n', ' */\n', 'contract CP is CPVesting {\n', '    using SafeMath for uint256;\n', '\n', '    receive() external payable {\n', '        require(_INITIALIZED_ == false, "WE_NOT_SAVE_ETH_AFTER_INIT");\n', '    }\n', '\n', '    function init(\n', '        address[] calldata addressList,\n', '        uint256[] calldata timeLine,\n', '        uint256[] calldata valueList,\n', '        bool isOpenTWAP\n', '    ) external {\n', '        /*\n', '        Address List\n', '        0. owner\n', '        1. maintainer\n', '        2. baseToken\n', '        3. quoteToken\n', '        4. permissionManager\n', '        5. feeRateModel\n', '        6. poolFactory\n', '      */\n', '\n', '        require(addressList.length == 7, "LIST_LENGTH_WRONG");\n', '\n', '        initOwner(addressList[0]);\n', '        _MAINTAINER_ = addressList[1];\n', '        _BASE_TOKEN_ = IERC20(addressList[2]);\n', '        _QUOTE_TOKEN_ = IERC20(addressList[3]);\n', '        _BIDDER_PERMISSION_ = IPermissionManager(addressList[4]);\n', '        _MT_FEE_RATE_MODEL_ = IFeeRateModel(addressList[5]);\n', '        _POOL_FACTORY_ = addressList[6];\n', '\n', '        /*\n', '        Time Line\n', '        0. phase bid starttime\n', '        1. phase bid duration\n', '        2. phase calm duration\n', '        3. freeze duration\n', '        4. vesting duration\n', '        */\n', '\n', '        require(timeLine.length == 5, "LIST_LENGTH_WRONG");\n', '\n', '        _PHASE_BID_STARTTIME_ = timeLine[0];\n', '        _PHASE_BID_ENDTIME_ = _PHASE_BID_STARTTIME_.add(timeLine[1]);\n', '        _PHASE_CALM_ENDTIME_ = _PHASE_BID_ENDTIME_.add(timeLine[2]);\n', '\n', '        _FREEZE_DURATION_ = timeLine[3];\n', '        _VESTING_DURATION_ = timeLine[4];\n', '\n', '        require(block.timestamp <= _PHASE_BID_STARTTIME_, "TIMELINE_WRONG");\n', '\n', '        /*\n', '        Value List\n', '        0. pool quote cap\n', '        1. k\n', '        2. i\n', '        3. cliff rate\n', '        */\n', '\n', '        require(valueList.length == 4, "LIST_LENGTH_WRONG");\n', '\n', '        _POOL_QUOTE_CAP_ = valueList[0];\n', '        _K_ = valueList[1];\n', '        _I_ = valueList[2];\n', '        _CLIFF_RATE_ = valueList[3];\n', '\n', '        require(_I_ > 0 && _I_ <= 1e36, "I_VALUE_WRONG");\n', '        require(_K_ <= 1e18, "K_VALUE_WRONG");\n', '        require(_CLIFF_RATE_ <= 1e18, "CLIFF_RATE_WRONG");\n', '\n', '        _TOTAL_BASE_ = _BASE_TOKEN_.balanceOf(address(this));\n', '\n', '        _IS_OPEN_TWAP_ = isOpenTWAP;\n', '\n', '        require(address(this).balance == _SETTEL_FUND_, "SETTLE_FUND_NOT_MATCH");\n', '    }\n', '}']