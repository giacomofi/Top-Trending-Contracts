['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-02\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '/**\n', '\n', 'Buy The Floor \n', '\n', 'Demand-side NFT exchange that allows buyers to make offchain blanket bids for NFTs based on type.  \n', '\n', '*/\n', '\n', ' \n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', ' \n', ' \n', ' interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/// @title ERC-721 Non-Fungible Token Standard\n', '       /// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', '       ///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\n', '       interface ERC721 /* is ERC165 */ {\n', '           /// @dev This emits when ownership of any NFT changes by any mechanism.\n', '           ///  This event emits when NFTs are created (`from` == 0) and destroyed\n', '           ///  (`to` == 0). Exception: during contract creation, any number of NFTs\n', '           ///  may be created and assigned without emitting Transfer. At the time of\n', '           ///  any transfer, the approved address for that NFT (if any) is reset to none.\n', '           event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '\n', '           /// @dev This emits when the approved address for an NFT is changed or\n', '           ///  reaffirmed. The zero address indicates there is no approved address.\n', '           ///  When a Transfer event emits, this also indicates that the approved\n', '           ///  address for that NFT (if any) is reset to none.\n', '           event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '\n', '           /// @dev This emits when an operator is enabled or disabled for an owner.\n', '           ///  The operator can manage all NFTs of the owner.\n', '           event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '           /// @notice Count all NFTs assigned to an owner\n', '           /// @dev NFTs assigned to the zero address are considered invalid, and this\n', '           ///  function throws for queries about the zero address.\n', '           /// @param _owner An address for whom to query the balance\n', '           /// @return The number of NFTs owned by `_owner`, possibly zero\n', '           function balanceOf(address _owner) external view returns (uint256);\n', '\n', '           /// @notice Find the owner of an NFT\n', '           /// @dev NFTs assigned to zero address are considered invalid, and queries\n', '           ///  about them do throw.\n', '           /// @param _tokenId The identifier for an NFT\n', '           /// @return The address of the owner of the NFT\n', '           function ownerOf(uint256 _tokenId) external view returns (address);\n', '\n', '           /// @notice Transfers the ownership of an NFT from one address to another address\n', '           /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '           ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '           ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '           ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n', '           ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '           ///  `onERC721Received` on `_to` and throws if the return value is not\n', '           ///  `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.\n', '           /// @param _from The current owner of the NFT\n', '           /// @param _to The new owner\n', '           /// @param _tokenId The NFT to transfer\n', '           /// @param data Additional data with no specified format, sent in call to `_to`\n', '           function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\n', '\n', '           /// @notice Transfers the ownership of an NFT from one address to another address\n', '           /// @dev This works identically to the other function with an extra data parameter,\n', '           ///  except this function just sets data to ""\n', '           /// @param _from The current owner of the NFT\n', '           /// @param _to The new owner\n', '           /// @param _tokenId The NFT to transfer\n', '           function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '           /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '           ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '           ///  THEY MAY BE PERMANENTLY LOST\n', '           /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '           ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '           ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '           ///  `_tokenId` is not a valid NFT.\n', '           /// @param _from The current owner of the NFT\n', '           /// @param _to The new owner\n', '           /// @param _tokenId The NFT to transfer\n', '           function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '           /// @notice Set or reaffirm the approved address for an NFT\n', '           /// @dev The zero address indicates there is no approved address.\n', '           /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\n', '           ///  operator of the current owner.\n', '           /// @param _approved The new approved NFT controller\n', '           /// @param _tokenId The NFT to approve\n', '           function approve(address _approved, uint256 _tokenId) external payable;\n', '\n', '           /// @notice Enable or disable approval for a third party ("operator") to manage\n', "           ///  all of `msg.sender`'s assets.\n", '           /// @dev Emits the ApprovalForAll event. The contract MUST allow\n', '           ///  multiple operators per owner.\n', '           /// @param _operator Address to add to the set of authorized operators.\n', '           /// @param _approved True if the operator is approved, false to revoke approval\n', '           function setApprovalForAll(address _operator, bool _approved) external;\n', '\n', '           /// @notice Get the approved address for a single NFT\n', '           /// @dev Throws if `_tokenId` is not a valid NFT\n', '           /// @param _tokenId The NFT to find the approved address for\n', '           /// @return The approved address for this NFT, or the zero address if there is none\n', '           function getApproved(uint256 _tokenId) external view returns (address);\n', '\n', '           /// @notice Query if an address is an authorized operator for another address\n', '           /// @param _owner The address that owns the NFTs\n', '           /// @param _operator The address that acts on behalf of the owner\n', '           /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n', '           function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '       }\n', '\n', '       interface ERC165 {\n', '           /// @notice Query if a contract implements an interface\n', '           /// @param interfaceID The interface identifier, as specified in ERC-165\n', '           /// @dev Interface identification is specified in ERC-165. This function\n', '           ///  uses less than 30,000 gas.\n', '           /// @return `true` if the contract implements `interfaceID` and\n', '           ///  `interfaceID` is not 0xffffffff, `false` otherwise\n', '           function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '       }\n', '\n', '       interface ERC721TokenReceiver {\n', '           /// @notice Handle the receipt of an NFT\n', '           /// @dev The ERC721 smart contract calls this function on the\n', '           /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n', '           /// of other than the magic value MUST result in the transaction being reverted.\n', '           /// @notice The contract address is always the message sender.\n', '           /// @param _operator The address which called `safeTransferFrom` function\n', '           /// @param _from The address which previously owned the token\n', '           /// @param _tokenId The NFT identifier which is being transferred\n', '           /// @param _data Additional data with no specified format\n', '           /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '           /// unless throwing\n', '           function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n', '        }\n', '        \n', '        interface ProjectBasedNFT {\n', '            function tokenIdToProjectId(uint256 tokenId) external returns(uint256);\n', '        }\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '\n', '// Owned contract\n', '\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '\n', '    address public newOwner;\n', '\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '\n', '    constructor() public {\n', '\n', '        owner = msg.sender;\n', '\n', '    }\n', '\n', '\n', '    modifier onlyOwner {\n', '\n', '        require(msg.sender == owner);\n', '\n', '        _;\n', '\n', '    }\n', '\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '\n', '        newOwner = _newOwner;\n', '\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '\n', '        require(msg.sender == newOwner);\n', '\n', '        emit OwnershipTransferred(owner, newOwner);\n', '\n', '        owner = newOwner;\n', '\n', '        newOwner = address(0);\n', '\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract ECRecovery {\n', '\n', '  /**\n', '   * @dev Recover signer address from a message by using their signature\n', '   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n', '   * @param sig bytes signature, the signature is generated using web3.eth.sign()\n', '   */\n', '  function recover(bytes32 hash, bytes memory sig) internal  pure returns (address) {\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    //Check the signature length\n', '    if (sig.length != 65) {\n', '      return (address(0));\n', '    }\n', '\n', '    // Divide the signature in r, s and v variables\n', '    assembly {\n', '      r := mload(add(sig, 32))\n', '      s := mload(add(sig, 64))\n', '      v := byte(0, mload(add(sig, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      return (address(0));\n', '    } else {\n', '      return ecrecover(hash, v, r, s);\n', '    }\n', '  }\n', '\n', '}\n', '\n', '\n', '/*\n', 'ERC20 tokens must be approved to this contract ! \n', 'Then, the buyer will perform an offchain metatx personalsign for their bid \n', '\n', 'NFT must also be approved to this contract - setApprovalForAll\n', '*/\n', '\n', 'contract BuyTheFloorExchange is Owned, ECRecovery  {\n', '\n', '  using SafeMath for uint;\n', '\n', '    \n', '  mapping (bytes32 => uint) public burnedSignatures; \n', '    \n', '  uint256 public _fee_pct;\n', '  uint256 public _chain_id;\n', ' \n', '  constructor( uint chainId, uint fee_pct) public { \n', '    require(fee_pct >= 0 && fee_pct <100);\n', '\n', '    _fee_pct = fee_pct;\n', '    _chain_id = chainId;\n', '  }\n', '\n', '\n', '  //Do not allow ETH to enter\n', '   function() external payable {\n', '    revert();\n', '  }\n', '  \n', '  event BuyTheFloor(address indexed bidderAddress, address indexed sellerAddress, address indexed nftContractAddress, uint256 tokenId, address currencyTokenAddress, uint currencyTokenAmount);\n', '  event SignatureBurned(address indexed bidderAddress, bytes32 hash);\n', '  \n', '  struct BidPacket {\n', '    address bidderAddress;\n', '    address nftContractAddress;\n', '    address currencyTokenAddress;\n', '    uint256 currencyTokenAmount;\n', '    bool requireProjectId;\n', '    uint256 projectId;\n', '    uint256 expires;\n', '  }\n', '  \n', '  \n', '     bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\n', '          "EIP712Domain(string contractName,string version,uint256 chainId,address verifyingContract)"\n', '      );\n', '\n', '   function getBidDomainTypehash() public pure returns (bytes32) {\n', '      return EIP712DOMAIN_TYPEHASH;\n', '   }\n', '\n', '   function getEIP712DomainHash(string memory contractName, string memory version, uint256 chainId, address verifyingContract) public pure returns (bytes32) {\n', '\n', '      return keccak256(abi.encode(\n', '            EIP712DOMAIN_TYPEHASH,\n', '            keccak256(bytes(contractName)),\n', '            keccak256(bytes(version)),\n', '            chainId,\n', '            verifyingContract\n', '        ));\n', '    }\n', '\n', '\n', '  bytes32 constant BIDPACKET_TYPEHASH = keccak256(\n', '      "BidPacket(address bidderAddress,address nftContractAddress,address currencyTokenAddress,uint256 currencyTokenAmount,bool requireProjectId,uint256 projectId,uint256 expires)"\n', '  );\n', '\n', '\n', '\n', '    function getBidPacketTypehash()  public pure returns (bytes32) {\n', '      return BIDPACKET_TYPEHASH;\n', '  }\n', '  \n', '  function getBidPacketHash(address bidderAddress,address nftContractAddress,address currencyTokenAddress, uint256 currencyTokenAmount,bool requireProjectId,uint256 projectId,uint256 expires) public pure returns (bytes32) {\n', '          return keccak256(abi.encode(\n', '              BIDPACKET_TYPEHASH,\n', '              bidderAddress,\n', '              nftContractAddress,\n', '              currencyTokenAddress,\n', '              currencyTokenAmount,\n', '              requireProjectId,\n', '              projectId,\n', '              expires\n', '          ));\n', '      }\n', '\n', '  function getBidTypedDataHash(address bidderAddress,address nftContractAddress,address currencyTokenAddress, uint256 currencyTokenAmount,bool requireProjectId,uint256 projectId,uint256 expires) public view returns (bytes32) {\n', '\n', '\n', '              \n', '              bytes32 digest = keccak256(abi.encodePacked(\n', '                  "\\x19\\x01",\n', "                  getEIP712DomainHash('BuyTheFloor','2',_chain_id,address(this)),\n", '                  getBidPacketHash(bidderAddress,nftContractAddress,currencyTokenAddress,currencyTokenAmount,requireProjectId,projectId,expires)\n', '              ));\n', '              return digest;\n', '          }\n', '  \n', '\n', '  //require pre-approval from the buyer in the form of a personal sign \n', '  function sellNFT(address nftContractAddress, uint256 tokenId, address from, address to, address currencyToken, uint256 currencyAmount, bool requireProjectId,uint256 projectId, uint256 expires, bytes memory buyerSignature) public returns (bool){\n', '      \n', '      //require personalsign from buyer to be submitted by seller  \n', '      bytes32 sigHash = getBidTypedDataHash(to,nftContractAddress,currencyToken,currencyAmount,requireProjectId,projectId,expires);\n', '\n', '      address recoveredSignatureSigner = recover(sigHash,buyerSignature);\n', '\n', '\n', '      //make sure the signer is the depositor of the tokens\n', "      require(to == recoveredSignatureSigner, 'Invalid signature');\n", "      require(from == msg.sender, 'Not NFT Owner');\n", '      \n', '      \n', "      require(block.number < expires || expires == 0, 'bid expired');\n", '     \n', "      require(burnedSignatures[sigHash] == 0, 'signature already used');\n", '      burnedSignatures[sigHash] = 0x1;\n', '      \n', '      if(requireProjectId){\n', "          require(ProjectBasedNFT(nftContractAddress).tokenIdToProjectId(tokenId) == projectId , 'Incorrect Project Id');\n", '      }\n', '      \n', '      \n', '      ERC721(nftContractAddress).safeTransferFrom(from, to, tokenId);\n', '      \n', '      _transferCurrencyForSale(from,to,currencyToken,currencyAmount);\n', '      \n', '      \n', '      emit BuyTheFloor(to, from, nftContractAddress, tokenId, currencyToken, currencyAmount);\n', '      emit SignatureBurned(to, sigHash);\n', '\n', '      return true;\n', '  }\n', '  \n', '  function _transferCurrencyForSale(address from, address to, address currencyToken, uint256 currencyAmount) internal returns (bool){\n', '    uint256 feeAmount = currencyAmount.mul(_fee_pct).div(100);\n', '\n', "    require( IERC20(currencyToken).transferFrom(to, from, currencyAmount.sub(feeAmount) ), 'unable to pay' );\n", "    require( IERC20(currencyToken).transferFrom(to, owner, feeAmount ), 'unable to pay'  );\n", '    \n', '    return true;\n', '  }\n', '  \n', '   \n', '  function cancelBid(address nftContractAddress, address to, address currencyToken, uint256 currencyAmount,  bool requireProjectId, uint256 projectId, uint256 expires, bytes memory buyerSignature ) public returns (bool){\n', '      bytes32 sigHash = getBidTypedDataHash(to,nftContractAddress,currencyToken,currencyAmount,requireProjectId,projectId,expires);\n', '      address recoveredSignatureSigner = recover(sigHash,buyerSignature);\n', '      \n', "      require(to == recoveredSignatureSigner, 'Invalid signature');\n", "      require(msg.sender == recoveredSignatureSigner, 'Not bid owner');\n", "      require(burnedSignatures[sigHash]==0, 'Already burned');\n", '      \n', '      burnedSignatures[sigHash] = 0x2;\n', '      emit SignatureBurned(to, sigHash);\n', '      \n', '      return true;\n', '  }\n', '  \n', '  \n', '  \n', '}']