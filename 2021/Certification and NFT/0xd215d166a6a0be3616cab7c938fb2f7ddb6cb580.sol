['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-10\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IOwnable {\n', '  function manager() external view returns (address);\n', '\n', '  function renounceManagement() external;\n', '  \n', '  function pushManagement( address newOwner_ ) external;\n', '  \n', '  function pullManagement() external;\n', '}\n', '\n', 'contract Ownable is IOwnable {\n', '\n', '    address internal _owner;\n', '    address internal _newOwner;\n', '\n', '    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\n', '    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        _owner = msg.sender;\n', '        emit OwnershipPushed( address(0), _owner );\n', '    }\n', '\n', '    function manager() public view override returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyManager() {\n', '        require( _owner == msg.sender, "Ownable: caller is not the owner" );\n', '        _;\n', '    }\n', '\n', '    function renounceManagement() public virtual override onlyManager() {\n', '        emit OwnershipPushed( _owner, address(0) );\n', '        _owner = address(0);\n', '    }\n', '\n', '    function pushManagement( address newOwner_ ) public virtual override onlyManager() {\n', '        require( newOwner_ != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipPushed( _owner, newOwner_ );\n', '        _newOwner = newOwner_;\n', '    }\n', '    \n', '    function pullManagement() public virtual override {\n', '        require( msg.sender == _newOwner, "Ownable: must be new owner to pull");\n', '        emit OwnershipPulled( _owner, _newOwner );\n', '        _owner = _newOwner;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function sqrrt(uint256 a) internal pure returns (uint c) {\n', '        if (a > 3) {\n', '            c = a;\n', '            uint b = add( div( a, 2), 1 );\n', '            while (b < c) {\n', '                c = b;\n', '                b = div( add( div( a, b ), b), 2 );\n', '            }\n', '        } else if (a != 0) {\n', '            c = 1;\n', '        }\n', '    }\n', '}\n', '\n', 'library Address {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function addressToString(address _address) internal pure returns(string memory) {\n', '        bytes32 _bytes = bytes32(uint256(_address));\n', '        bytes memory HEX = "0123456789abcdef";\n', '        bytes memory _addr = new bytes(42);\n', '\n', "        _addr[0] = '0';\n", "        _addr[1] = 'x';\n", '\n', '        for(uint256 i = 0; i < 20; i++) {\n', '            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\n', '            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n', '        }\n', '\n', '        return string(_addr);\n', '\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract ERC20 is IERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // TODO comment actual hash value.\n', '    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( "ERC20Token" );\n', '    \n', '    mapping (address => uint256) internal _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    string internal _name;\n', '    \n', '    string internal _symbol;\n', '    \n', '    uint8 internal _decimals;\n', '\n', '    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view override returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account_, uint256 ammount_) internal virtual {\n', '        require(account_ != address(0), "ERC20: mint to the zero address");\n', '        _beforeTokenTransfer(address( this ), account_, ammount_);\n', '        _totalSupply = _totalSupply.add(ammount_);\n', '        _balances[account_] = _balances[account_].add(ammount_);\n', '        emit Transfer(address( this ), account_, ammount_);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\n', '}\n', '\n', 'interface IERC2612Permit {\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '}\n', '\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', 'abstract contract ERC20Permit is ERC20, IERC2612Permit {\n', '    using Counters for Counters.Counter;\n', '\n', '    mapping(address => Counters.Counter) private _nonces;\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '\n', '    constructor() {\n', '        uint256 chainID;\n', '        assembly {\n', '            chainID := chainid()\n', '        }\n', '\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n', '                keccak256(bytes(name())),\n', '                keccak256(bytes("1")), // Version\n', '                chainID,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public virtual override {\n', '        require(block.timestamp <= deadline, "Permit: expired deadline");\n', '\n', '        bytes32 hashStruct =\n', '            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));\n', '\n', '        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\n', '\n', '        address signer = ecrecover(_hash, v, r, s);\n', '        require(signer != address(0) && signer == owner, "ZeroSwapPermit: Invalid signature");\n', '\n', '        _nonces[owner].increment();\n', '        _approve(owner, spender, amount);\n', '    }\n', '\n', '    function nonces(address owner) public view override returns (uint256) {\n', '        return _nonces[owner].current();\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'library FullMath {\n', '    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n', '        uint256 mm = mulmod(x, y, uint256(-1));\n', '        l = x * y;\n', '        h = mm - l;\n', '        if (mm < l) h -= 1;\n', '    }\n', '\n', '    function fullDiv(\n', '        uint256 l,\n', '        uint256 h,\n', '        uint256 d\n', '    ) private pure returns (uint256) {\n', '        uint256 pow2 = d & -d;\n', '        d /= pow2;\n', '        l /= pow2;\n', '        l += h * ((-pow2) / pow2 + 1);\n', '        uint256 r = 1;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        return l * r;\n', '    }\n', '\n', '    function mulDiv(\n', '        uint256 x,\n', '        uint256 y,\n', '        uint256 d\n', '    ) internal pure returns (uint256) {\n', '        (uint256 l, uint256 h) = fullMul(x, y);\n', '        uint256 mm = mulmod(x, y, d);\n', '        if (mm > l) h -= 1;\n', '        l -= mm;\n', "        require(h < d, 'FullMath::mulDiv: overflow');\n", '        return fullDiv(l, h, d);\n', '    }\n', '}\n', '\n', 'library FixedPoint {\n', '\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    struct uq144x112 {\n', '        uint256 _x;\n', '    }\n', '\n', '    uint8 private constant RESOLUTION = 112;\n', '    uint256 private constant Q112 = 0x10000000000000000000000000000;\n', '    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n', '    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n', '\n', '    function decode(uq112x112 memory self) internal pure returns (uint112) {\n', '        return uint112(self._x >> RESOLUTION);\n', '    }\n', '\n', '    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n', '\n', '        return uint(self._x) / 5192296858534827;\n', '    }\n', '\n', '    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n', "        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n", '        if (numerator == 0) return FixedPoint.uq112x112(0);\n', '\n', '        if (numerator <= uint144(-1)) {\n', '            uint256 result = (numerator << RESOLUTION) / denominator;\n', "            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n", '            return uq112x112(uint224(result));\n', '        } else {\n', '            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n', "            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n", '            return uq112x112(uint224(result));\n', '        }\n', '    }\n', '}\n', '\n', 'interface ITreasury {\n', '    function deposit( uint _amount, address _token, uint _profit ) external returns ( bool );\n', '}\n', '\n', 'interface IBondCalculator {\n', '    function valuation( address _LP, uint _amount ) external view returns ( uint );\n', '    function markdown( address _LP ) external view returns ( uint );\n', '}\n', '\n', 'interface IStaking {\n', '    function stake( uint _amount, address _recipient ) external returns ( bool );\n', '}\n', '\n', 'contract OlympusBondDepository is Ownable {\n', '\n', '    using FixedPoint for *;\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '\n', '    event BondCreated( uint deposit, uint indexed payout, uint indexed expires, uint indexed priceInUSD );\n', '    event BondRedeemed( uint indexed payout, uint indexed remaining );\n', '    event BondPriceChanged( uint indexed priceInUSD, uint indexed internalPrice, uint indexed debtRatio );\n', '\n', '    address public immutable OHM; // Token given as payment for bond\n', '    address public immutable principle; // Token used to create bond\n', '    address public immutable treasury; // Mints OHM when receives principle\n', '    address public immutable DAO; // Receives profit share from bond\n', '\n', '    bool public immutable isLiquidityBond; // LP and Reserve bonds are treated slightly different\n', '    address public immutable bondCalculator; // Calculates value of LP tokens\n', '    address public staking;\n', '\n', '    constructor ( \n', '        address _OHM,\n', '        address _principle,\n', '        address _treasury, \n', '        address _DAO, \n', '        address _bondCalculator\n', '    ) {\n', '        require( _OHM != address(0) );\n', '        OHM = _OHM;\n', '        require( _principle != address(0) );\n', '        principle = _principle;\n', '        require( _treasury != address(0) );\n', '        treasury = _treasury;\n', '        require( _DAO != address(0) );\n', '        DAO = _DAO;\n', '        // bondCalculator should be address(0) if not LP bond\n', '        bondCalculator = _bondCalculator;\n', '        isLiquidityBond = ( _bondCalculator != address(0) );\n', '    }\n', '\n', '    /*\n', '        Bond holder information\n', '     */\n', '\n', '    struct Bond {\n', '        uint valueRemaining; // value of principle given\n', '        uint payoutRemaining; // OHM remaining to be paid\n', '        uint vestingPeriod; // Blocks left to vest\n', '        uint lastBlock; // Last interaction\n', '        uint pricePaid; // In DAI, for front end viewing\n', '    }\n', '    mapping( address => Bond ) public bondInfo; // Stores bond information for depositor\n', '\n', '    /*\n', '        New bond terms\n', '     */\n', '\n', '    struct Terms {\n', '        uint controlVariable; // scaling variable for price\n', '        uint vestingTerm; // in blocks\n', '        uint minimumPrice; // vs principle value\n', '        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\n', '        uint fee; // as % of bond payout, in hundreths. ( 500 = 5% = 0.05 for every 1 paid)\n', '    }\n', '    Terms public terms; // Stores terms for new bonds\n', '    \n', '    // Total value of outstanding bonds\n', '    uint public totalDebt; // Used for pricing\n', '    \n', '    \n', '\n', '    /**\n', '     * @notice sets initial bond terms - initialization function\n', '     * @param _controlVariable uint\n', '     * @param _minimumPrice uint\n', '    */\n', '    function initializeBondTerms( uint _controlVariable, uint _minimumPrice ) external onlyManager() {\n', '        terms.controlVariable = _controlVariable;\n', '        terms.minimumPrice = _minimumPrice;\n', '    }\n', '    \n', '    /**\n', '     * @notice sets staking contract if not yet set - initialization function\n', '     * @param _staking address\n', '     */\n', '    function initializeStaking( address _staking ) external onlyManager() {\n', '        require( staking == address(0) );\n', '        require( _staking != address(0) );\n', '        staking = _staking;\n', '    }\n', '    \n', '    \n', '\n', '    /**\n', '        @notice set parameters of new bonds\n', '        @param _vestingTerm uint\n', '        @param _maxPayout uint\n', '        @param _fee uint\n', '        @return bool\n', '     */\n', '    function setBondTerms ( \n', '        uint _vestingTerm, // Length in blocks for bond to vest\n', '        uint _maxPayout, // Maximum amount (as % of circ supply) a bond can pay out\n', '        uint _fee // Amount of profits DAO takes\n', '    ) external onlyManager() returns ( bool ) {\n', '        require( _vestingTerm >= 10000, "Vesting must be longer than 36 hours" );\n', '        require( _maxPayout <= 1000, "Payout cannot be above 1 percent" );\n', '        require( _fee <= 10000, "DAO fee cannot exceed payout" );\n', '\n', '        terms.vestingTerm = _vestingTerm;\n', '        terms.maxPayout = _maxPayout;\n', '        terms.fee = _fee;\n', '\n', '        return true;\n', '    }\n', '    \n', '    /**\n', '        Info for incremental adjustments to control variable \n', '     */\n', '\n', '    struct Adjust {\n', '        bool add;\n', '        uint rate;\n', '        uint target;\n', '    }\n', '    Adjust public adjustment;\n', '\n', '    /**\n', '        @notice set control variable adjustment\n', '        @param _addition bool\n', '        @param _increment uint\n', '        @param _target uint\n', '     */\n', '    function setAdjustment ( \n', '        bool _addition,\n', '        uint _increment, \n', '        uint _target \n', '    ) external onlyManager() {\n', '        require( _increment <= terms.controlVariable.mul( 25 ).div( 1000 ), "Increment too large" );\n', '\n', '        adjustment = Adjust({\n', '            add: _addition,\n', '            rate: _increment,\n', '            target: _target\n', '        });\n', '    }\n', '\n', '\n', '    /**\n', '        @notice deposit bond\n', '        @param _amount uint\n', '        @param _maxPrice uint\n', '        @param _depositor address\n', '        @return uint\n', '     */\n', '    function deposit( \n', '        uint _amount, \n', '        uint _maxPrice,\n', '        address _depositor\n', '    ) external returns ( uint ) {\n', '        require( _depositor != address(0), "Invalid address" );\n', '        \n', '        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\n', '        uint nativePrice = _bondPrice();\n', '\n', '        require( _maxPrice >= nativePrice, "Slippage limit: more than max price" ); // slippage protection\n', '\n', '        uint value;\n', '        if( isLiquidityBond ) { // LP is calculated at risk-free value\n', '            value = IBondCalculator( bondCalculator ).valuation( principle, _amount ); \n', '        } else { // reserve is converted to OHM decimals\n', '            value = _amount.mul( 10 ** IERC20( OHM ).decimals() ).div( 10 ** IERC20( principle ).decimals() ); \n', '        }\n', '        uint payout = payoutFor( value ); // payout to bonder is computed\n', '\n', '        require( payout >= 10000000, "Bond too small" ); // must be > 0.01 OHM ( underflow protection )\n', '        require( payout <= maxPayout(), "Bond too large"); // size protection because there is no slippage\n', '\n', '        // calculate profits\n', '        uint fee = payout.mul( terms.fee ).div( 10000 );\n', '        uint profit = value.sub( payout ).sub( fee );\n', '\n', '        /**\n', '            principle is transferred in\n', '            approved and\n', '            deposited into the treasury\n', '            returning (_amount - profit) OHM\n', '         */\n', '        IERC20( principle ).safeTransferFrom( msg.sender, address(this), _amount );\n', '        IERC20( principle ).approve( address( treasury ), _amount );\n', '        ITreasury( treasury ).deposit( _amount, principle, profit );\n', '        \n', '        // fee is transferred to dao \n', '        IERC20( OHM ).safeTransfer( DAO, fee ); \n', '        \n', '        // total debt is increased\n', '        totalDebt = totalDebt.add( value ); \n', '                \n', '        // depositor info is stored\n', '        Bond memory info = bondInfo[ _depositor ];\n', '        bondInfo[ _depositor ] = Bond({ \n', '            valueRemaining: info.valueRemaining.add( value ), // add on to previous \n', '            payoutRemaining: info.payoutRemaining.add( payout ), // amounts if they exist\n', '            vestingPeriod: terms.vestingTerm,\n', '            lastBlock: block.number,\n', '            pricePaid: priceInUSD\n', '        });\n', '\n', '        // emit indexed events \n', '        emit BondCreated( _amount, payout, block.number.add( terms.vestingTerm ), priceInUSD );\n', '        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\n', '\n', '        adjust(); // adjustment control variable\n', '        return payout; \n', '    }\n', '\n', '    /** \n', '        @notice redeem all unvested bonds\n', '        @param _stake bool\n', '        @return payout_ uint\n', '     */ \n', '    function redeem( bool _stake ) external returns ( uint ) {        \n', '        Bond memory info = bondInfo[ msg.sender ];\n', '        uint percentVested = percentVestedFor( msg.sender ); // (blocks since last interaction / vesting term remaining)\n', '\n', '        if ( percentVested >= 10000 ) { // if fully vested\n', '            delete bondInfo[msg.sender]; // delete user info\n', '            totalDebt = totalDebt.sub( info.valueRemaining ); // reduce debt\n', '            emit BondRedeemed( info.payoutRemaining, 0 ); // emit bond data\n', '            return stakeOrSend( _stake, info.payoutRemaining ); // pay user everything due\n', '\n', '        } else { // if unfinished\n', '            // calculate payout vested\n', '            uint value = info.valueRemaining.mul( percentVested ).div( 10000 );\n', '            uint payout = info.payoutRemaining.mul( percentVested ).div( 10000 );\n', '            uint blocksSinceLast = block.number.sub( info.lastBlock );\n', '\n', '            // store updated deposit info\n', '            bondInfo[ msg.sender ] = Bond({\n', '                valueRemaining: info.valueRemaining.sub( value ),\n', '                payoutRemaining: info.payoutRemaining.sub( payout ),\n', '                vestingPeriod: info.vestingPeriod.sub( blocksSinceLast ),\n', '                lastBlock: block.number,\n', '                pricePaid: info.pricePaid\n', '            });\n', '\n', '            // reduce total debt by vested amount\n', '            totalDebt = totalDebt.sub( value );\n', '\n', '            emit BondRedeemed( payout, bondInfo[ msg.sender ].payoutRemaining );\n', '            return stakeOrSend( _stake, payout );\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice allow user to stake payout automatically\n', '        @param _stake bool\n', '        @param _amount uint\n', '        @return uint\n', '     */\n', '    function stakeOrSend( bool _stake, uint _amount ) internal returns ( uint ) {\n', '        emit BondPriceChanged( bondPriceInUSD(), _bondPrice(), debtRatio() );\n', '\n', '        if ( !_stake ) { // if user does not want to stake\n', '            IERC20( OHM ).transfer( msg.sender, _amount ); // send payout\n', '        } else { // if user wants to stake\n', '            IERC20( OHM ).approve( staking, _amount );\n', '            IStaking( staking ).stake( _amount, msg.sender ); // stake payout\n', '        }\n', '        return _amount;\n', '    }\n', '\n', '    /**\n', '        @notice makes incremental adjustment to control variable\n', '     */\n', '    function adjust() internal {\n', '        if( adjustment.rate != 0 ) {\n', '            if ( adjustment.add ) {\n', '                terms.controlVariable = terms.controlVariable.add( adjustment.rate );\n', '                if ( terms.controlVariable >= adjustment.target ) {\n', '                    adjustment.rate = 0;\n', '                }\n', '            } else {\n', '                terms.controlVariable = terms.controlVariable.sub( adjustment.rate );\n', '                if ( terms.controlVariable <= adjustment.target ) {\n', '                    adjustment.rate = 0;\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice determine maximum bond size\n', '        @return uint\n', '     */\n', '    function maxPayout() public view returns ( uint ) {\n', '        return IERC20( OHM ).totalSupply().mul( terms.maxPayout ).div( 100000 );\n', '    }\n', '\n', '    /**\n', '        @notice calculate current bond premium\n', '        @return price_ uint\n', '     */\n', '    function bondPrice() public view returns ( uint price_ ) {        \n', '        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\n', '        if ( price_ < terms.minimumPrice ) {\n', '            price_ = terms.minimumPrice;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice calculate current bond price and remove floor if above\n', '        @return price_ uint\n', '     */\n', '    function _bondPrice() internal returns ( uint price_ ) {\n', '        price_ = terms.controlVariable.mul( debtRatio() ).add( 1000000000 ).div( 1e7 );\n', '        if ( price_ < terms.minimumPrice ) {\n', '            price_ = terms.minimumPrice;        \n', '        } else if ( terms.minimumPrice != 0 ) {\n', '            terms.minimumPrice = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice converts bond price to DAI value\n', '        @return price_ uint\n', '     */\n', '    function bondPriceInUSD() public view returns ( uint price_ ) {\n', '        if( isLiquidityBond ) {\n', '            price_ = bondPrice().mul( IBondCalculator( bondCalculator ).markdown( principle ) ).div( 100 );\n', '        } else {\n', '            price_ = bondPrice().mul( 10 ** IERC20( principle ).decimals() ).div( 100 );\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice calculate current ratio of payouts to OHM supply\n', '        @return debtRatio_ uint\n', '     */\n', '\n', '    function debtRatio() public view returns ( uint debtRatio_ ) {   \n', '        uint supply = IERC20( OHM ).totalSupply();\n', '        debtRatio_ = FixedPoint.fraction( \n', '            totalDebt.mul( 1e9 ), \n', '            supply\n', '        ).decode112with18().div( 1e18 );\n', '    }\n', '\n', '    /**\n', '        @notice calculate interest due for new bond\n', '        @param _value uint\n', '        @return uint\n', '     */\n', '    function payoutFor( uint _value ) public view returns ( uint ) {\n', '        return FixedPoint.fraction( _value, bondPrice() ).decode112with18().div( 1e16 );\n', '    }\n', '\n', '    /**\n', '        @notice calculate how far into vesting a depositor is\n', '        @param _depositor address\n', '        @return percentVested_ uint\n', '     */\n', '    function percentVestedFor( address _depositor ) public view returns ( uint percentVested_ ) {\n', '        Bond memory bond = bondInfo[ _depositor ];\n', '        uint blocksSinceLast = block.number.sub( bond.lastBlock );\n', '        uint vestingPeriod = bond.vestingPeriod;\n', '\n', '        if ( vestingPeriod > 0 ) {\n', '            percentVested_ = blocksSinceLast.mul( 10000 ).div( vestingPeriod );\n', '        } else {\n', '            percentVested_ = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice calculate amount of OHM available for claim by depositor\n', '        @param _depositor address\n', '        @return pendingPayout_ uint\n', '     */\n', '    function pendingPayoutFor( address _depositor ) external view returns ( uint pendingPayout_ ) {\n', '        uint percentVested = percentVestedFor( _depositor );\n', '        uint payoutRemaining = bondInfo[ _depositor ].payoutRemaining;\n', '\n', '        if ( percentVested >= 10000 ) {\n', '            pendingPayout_ = payoutRemaining;\n', '        } else {\n', '            pendingPayout_ = payoutRemaining.mul( percentVested ).div( 10000 );\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice allow anyone to send lost tokens (excluding principle or OHM) to the DAO\n', '        @return bool\n', '     */\n', '    function recoverLostToken( address _token ) external returns ( bool ) {\n', '        require( _token != OHM );\n', '        require( _token != principle );\n', '        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\n', '        return true;\n', '    }\n', '}']