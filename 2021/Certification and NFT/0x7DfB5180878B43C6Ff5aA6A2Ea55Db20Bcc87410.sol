['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-04\n', '*/\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: solidity/contracts/utility/interfaces/IOwned.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Owned contract interface\n', '*/\n', 'interface IOwned {\n', "    // this function isn't since the compiler emits automatically generated getter functions as external\n", '    function owner() external view returns (address);\n', '\n', '    function transferOwnership(address _newOwner) external;\n', '\n', '    function acceptOwnership() external;\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/IConverterAnchor.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/*\n', '    Converter Anchor interface\n', '*/\n', 'interface IConverterAnchor is IOwned {\n', '\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/IConverter.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '/*\n', '    Converter interface\n', '*/\n', 'interface IConverter is IOwned {\n', '    function converterType() external pure returns (uint16);\n', '\n', '    function anchor() external view returns (IConverterAnchor);\n', '\n', '    function isActive() external view returns (bool);\n', '\n', '    function targetAmountAndFee(\n', '        IERC20 _sourceToken,\n', '        IERC20 _targetToken,\n', '        uint256 _amount\n', '    ) external view returns (uint256, uint256);\n', '\n', '    function convert(\n', '        IERC20 _sourceToken,\n', '        IERC20 _targetToken,\n', '        uint256 _amount,\n', '        address _trader,\n', '        address payable _beneficiary\n', '    ) external payable returns (uint256);\n', '\n', '    function conversionFee() external view returns (uint32);\n', '\n', '    function maxConversionFee() external view returns (uint32);\n', '\n', '    function reserveBalance(IERC20 _reserveToken) external view returns (uint256);\n', '\n', '    receive() external payable;\n', '\n', '    function transferAnchorOwnership(address _newOwner) external;\n', '\n', '    function acceptAnchorOwnership() external;\n', '\n', '    function setConversionFee(uint32 _conversionFee) external;\n', '\n', '    function addReserve(IERC20 _token, uint32 _weight) external;\n', '\n', '    function transferReservesOnUpgrade(address _newConverter) external;\n', '\n', '    function onUpgradeComplete() external;\n', '\n', '    // deprecated, backward compatibility\n', '    function token() external view returns (IConverterAnchor);\n', '\n', '    function transferTokenOwnership(address _newOwner) external;\n', '\n', '    function acceptTokenOwnership() external;\n', '\n', '    function connectors(IERC20 _address)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint32,\n', '            bool,\n', '            bool,\n', '            bool\n', '        );\n', '\n', '    function getConnectorBalance(IERC20 _connectorToken) external view returns (uint256);\n', '\n', '    function connectorTokens(uint256 _index) external view returns (IERC20);\n', '\n', '    function connectorTokenCount() external view returns (uint16);\n', '\n', '    /**\n', '     * @dev triggered when the converter is activated\n', '     *\n', '     * @param _type        converter type\n', '     * @param _anchor      converter anchor\n', '     * @param _activated   true if the converter was activated, false if it was deactivated\n', '     */\n', '    event Activation(uint16 indexed _type, IConverterAnchor indexed _anchor, bool indexed _activated);\n', '\n', '    /**\n', '     * @dev triggered when a conversion between two tokens occurs\n', '     *\n', '     * @param _fromToken       source ERC20 token\n', '     * @param _toToken         target ERC20 token\n', '     * @param _trader          wallet that initiated the trade\n', '     * @param _amount          input amount in units of the source token\n', '     * @param _return          output amount minus conversion fee in units of the target token\n', '     * @param _conversionFee   conversion fee in units of the target token\n', '     */\n', '    event Conversion(\n', '        IERC20 indexed _fromToken,\n', '        IERC20 indexed _toToken,\n', '        address indexed _trader,\n', '        uint256 _amount,\n', '        uint256 _return,\n', '        int256 _conversionFee\n', '    );\n', '\n', '    /**\n', '     * @dev triggered when the rate between two tokens in the converter changes\n', '     * note that the event might be dispatched for rate updates between any two tokens in the converter\n', '     *\n', '     * @param  _token1 address of the first token\n', '     * @param  _token2 address of the second token\n', '     * @param  _rateN  rate of 1 unit of `_token1` in `_token2` (numerator)\n', '     * @param  _rateD  rate of 1 unit of `_token1` in `_token2` (denominator)\n', '     */\n', '    event TokenRateUpdate(IERC20 indexed _token1, IERC20 indexed _token2, uint256 _rateN, uint256 _rateD);\n', '\n', '    /**\n', '     * @dev triggered when the conversion fee is updated\n', '     *\n', '     * @param  _prevFee    previous fee percentage, represented in ppm\n', '     * @param  _newFee     new fee percentage, represented in ppm\n', '     */\n', '    event ConversionFeeUpdate(uint32 _prevFee, uint32 _newFee);\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/IConverterUpgrader.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Converter Upgrader interface\n', '*/\n', 'interface IConverterUpgrader {\n', '    function upgrade(bytes32 _version) external;\n', '\n', '    function upgrade(uint16 _version) external;\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/ITypedConverterCustomFactory.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Typed Converter Custom Factory interface\n', '*/\n', 'interface ITypedConverterCustomFactory {\n', '    function converterType() external pure returns (uint16);\n', '}\n', '\n', '// File: solidity/contracts/utility/interfaces/IContractRegistry.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/*\n', '    Contract Registry interface\n', '*/\n', 'interface IContractRegistry {\n', '    function addressOf(bytes32 _contractName) external view returns (address);\n', '}\n', '\n', '// File: solidity/contracts/converter/interfaces/IConverterFactory.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '/*\n', '    Converter Factory interface\n', '*/\n', 'interface IConverterFactory {\n', '    function createAnchor(\n', '        uint16 _type,\n', '        string memory _name,\n', '        string memory _symbol,\n', '        uint8 _decimals\n', '    ) external returns (IConverterAnchor);\n', '\n', '    function createConverter(\n', '        uint16 _type,\n', '        IConverterAnchor _anchor,\n', '        IContractRegistry _registry,\n', '        uint32 _maxConversionFee\n', '    ) external returns (IConverter);\n', '\n', '    function customFactories(uint16 _type) external view returns (ITypedConverterCustomFactory);\n', '}\n', '\n', '// File: solidity/contracts/utility/Owned.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/**\n', ' * @dev This contract provides support and utilities for contract ownership.\n', ' */\n', 'contract Owned is IOwned {\n', '    address public override owner;\n', '    address public newOwner;\n', '\n', '    /**\n', '     * @dev triggered when the owner is updated\n', '     *\n', '     * @param _prevOwner previous owner\n', '     * @param _newOwner  new owner\n', '     */\n', '    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\n', '\n', '    /**\n', '     * @dev initializes a new Owned instance\n', '     */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    // allows execution by the owner only\n', '    modifier ownerOnly {\n', '        _ownerOnly();\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _ownerOnly() internal view {\n', '        require(msg.sender == owner, "ERR_ACCESS_DENIED");\n', '    }\n', '\n', '    /**\n', '     * @dev allows transferring the contract ownership\n', '     * the new owner still needs to accept the transfer\n', '     * can only be called by the contract owner\n', '     *\n', '     * @param _newOwner    new contract owner\n', '     */\n', '    function transferOwnership(address _newOwner) public override ownerOnly {\n', '        require(_newOwner != owner, "ERR_SAME_OWNER");\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev used by a new owner to accept an ownership transfer\n', '     */\n', '    function acceptOwnership() public override {\n', '        require(msg.sender == newOwner, "ERR_ACCESS_DENIED");\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/utility/Utils.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '/**\n', ' * @dev Utilities & Common Modifiers\n', ' */\n', 'contract Utils {\n', '    uint32 internal constant PPM_RESOLUTION = 1000000;\n', '    IERC20 internal constant NATIVE_TOKEN_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '\n', '    // verifies that a value is greater than zero\n', '    modifier greaterThanZero(uint256 _value) {\n', '        _greaterThanZero(_value);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _greaterThanZero(uint256 _value) internal pure {\n', '        require(_value > 0, "ERR_ZERO_VALUE");\n', '    }\n', '\n', "    // validates an address - currently only checks that it isn't null\n", '    modifier validAddress(address _address) {\n', '        _validAddress(_address);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validAddress(address _address) internal pure {\n', '        require(_address != address(0), "ERR_INVALID_ADDRESS");\n', '    }\n', '\n', '    // ensures that the portion is valid\n', '    modifier validPortion(uint32 _portion) {\n', '        _validPortion(_portion);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validPortion(uint32 _portion) internal pure {\n', '        require(_portion > 0 && _portion <= PPM_RESOLUTION, "ERR_INVALID_PORTION");\n', '    }\n', '\n', "    // validates an external address - currently only checks that it isn't null or this\n", '    modifier validExternalAddress(address _address) {\n', '        _validExternalAddress(_address);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validExternalAddress(address _address) internal view {\n', '        require(_address != address(0) && _address != address(this), "ERR_INVALID_EXTERNAL_ADDRESS");\n', '    }\n', '\n', '    // ensures that the fee is valid\n', '    modifier validFee(uint32 fee) {\n', '        _validFee(fee);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _validFee(uint32 fee) internal pure {\n', '        require(fee <= PPM_RESOLUTION, "ERR_INVALID_FEE");\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/utility/ContractRegistryClient.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev This is the base contract for ContractRegistry clients.\n', ' */\n', 'contract ContractRegistryClient is Owned, Utils {\n', '    bytes32 internal constant CONTRACT_REGISTRY = "ContractRegistry";\n', '    bytes32 internal constant BANCOR_NETWORK = "BancorNetwork";\n', '    bytes32 internal constant BANCOR_FORMULA = "BancorFormula";\n', '    bytes32 internal constant CONVERTER_FACTORY = "ConverterFactory";\n', '    bytes32 internal constant CONVERSION_PATH_FINDER = "ConversionPathFinder";\n', '    bytes32 internal constant CONVERTER_UPGRADER = "BancorConverterUpgrader";\n', '    bytes32 internal constant CONVERTER_REGISTRY = "BancorConverterRegistry";\n', '    bytes32 internal constant CONVERTER_REGISTRY_DATA = "BancorConverterRegistryData";\n', '    bytes32 internal constant BNT_TOKEN = "BNTToken";\n', '    bytes32 internal constant BANCOR_X = "BancorX";\n', '    bytes32 internal constant BANCOR_X_UPGRADER = "BancorXUpgrader";\n', '    bytes32 internal constant LIQUIDITY_PROTECTION = "LiquidityProtection";\n', '    bytes32 internal constant NETWORK_SETTINGS = "NetworkSettings";\n', '\n', '    IContractRegistry public registry; // address of the current contract-registry\n', '    IContractRegistry public prevRegistry; // address of the previous contract-registry\n', '    bool public onlyOwnerCanUpdateRegistry; // only an owner can update the contract-registry\n', '\n', '    /**\n', '     * @dev verifies that the caller is mapped to the given contract name\n', '     *\n', '     * @param _contractName    contract name\n', '     */\n', '    modifier only(bytes32 _contractName) {\n', '        _only(_contractName);\n', '        _;\n', '    }\n', '\n', '    // error message binary size optimization\n', '    function _only(bytes32 _contractName) internal view {\n', '        require(msg.sender == addressOf(_contractName), "ERR_ACCESS_DENIED");\n', '    }\n', '\n', '    /**\n', '     * @dev initializes a new ContractRegistryClient instance\n', '     *\n', '     * @param  _registry   address of a contract-registry contract\n', '     */\n', '    constructor(IContractRegistry _registry) internal validAddress(address(_registry)) {\n', '        registry = IContractRegistry(_registry);\n', '        prevRegistry = IContractRegistry(_registry);\n', '    }\n', '\n', '    /**\n', '     * @dev updates to the new contract-registry\n', '     */\n', '    function updateRegistry() public {\n', '        // verify that this function is permitted\n', '        require(msg.sender == owner || !onlyOwnerCanUpdateRegistry, "ERR_ACCESS_DENIED");\n', '\n', '        // get the new contract-registry\n', '        IContractRegistry newRegistry = IContractRegistry(addressOf(CONTRACT_REGISTRY));\n', '\n', '        // verify that the new contract-registry is different and not zero\n', '        require(newRegistry != registry && address(newRegistry) != address(0), "ERR_INVALID_REGISTRY");\n', '\n', '        // verify that the new contract-registry is pointing to a non-zero contract-registry\n', '        require(newRegistry.addressOf(CONTRACT_REGISTRY) != address(0), "ERR_INVALID_REGISTRY");\n', '\n', '        // save a backup of the current contract-registry before replacing it\n', '        prevRegistry = registry;\n', '\n', '        // replace the current contract-registry with the new contract-registry\n', '        registry = newRegistry;\n', '    }\n', '\n', '    /**\n', '     * @dev restores the previous contract-registry\n', '     */\n', '    function restoreRegistry() public ownerOnly {\n', '        // restore the previous contract-registry\n', '        registry = prevRegistry;\n', '    }\n', '\n', '    /**\n', '     * @dev restricts the permission to update the contract-registry\n', '     *\n', '     * @param _onlyOwnerCanUpdateRegistry  indicates whether or not permission is restricted to owner only\n', '     */\n', '    function restrictRegistryUpdate(bool _onlyOwnerCanUpdateRegistry) public ownerOnly {\n', '        // change the permission to update the contract-registry\n', '        onlyOwnerCanUpdateRegistry = _onlyOwnerCanUpdateRegistry;\n', '    }\n', '\n', '    /**\n', '     * @dev returns the address associated with the given contract name\n', '     *\n', '     * @param _contractName    contract name\n', '     *\n', '     * @return contract address\n', '     */\n', '    function addressOf(bytes32 _contractName) internal view returns (address) {\n', '        return registry.addressOf(_contractName);\n', '    }\n', '}\n', '\n', '// File: solidity/contracts/converter/ConverterUpgrader.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', '\n', '\n', '\n', 'interface ILegacyConverterVersion45 is IConverter {\n', '    function withdrawTokens(\n', '        IERC20 _token,\n', '        address _to,\n', '        uint256 _amount\n', '    ) external;\n', '\n', '    function withdrawETH(address payable _to) external;\n', '}\n', '\n', '/**\n', ' * @dev This contract contract allows upgrading an older converter contract (0.4 and up)\n', ' * to the latest version.\n', " * To begin the upgrade process, simply execute the 'upgrade' function.\n", ' * At the end of the process, the ownership of the newly upgraded converter will be transferred\n', " * back to the original owner and the original owner will need to execute the 'acceptOwnership' function.\n", ' *\n', ' * The address of the new converter is available in the ConverterUpgrade event.\n', ' *\n', " * Note that for older converters that don't yet have the 'upgrade' function, ownership should first\n", " * be transferred manually to the ConverterUpgrader contract using the 'transferOwnership' function\n", " * and then the upgrader 'upgrade' function should be executed directly.\n", ' */\n', 'contract ConverterUpgrader is IConverterUpgrader, ContractRegistryClient {\n', '    /**\n', '     * @dev triggered when the contract accept a converter ownership\n', '     *\n', '     * @param _converter   converter address\n', '     * @param _owner       new owner - local upgrader address\n', '     */\n', '    event ConverterOwned(IConverter indexed _converter, address indexed _owner);\n', '\n', '    /**\n', '     * @dev triggered when the upgrading process is done\n', '     *\n', '     * @param _oldConverter    old converter address\n', '     * @param _newConverter    new converter address\n', '     */\n', '    event ConverterUpgrade(address indexed _oldConverter, address indexed _newConverter);\n', '\n', '    /**\n', '     * @dev initializes a new ConverterUpgrader instance\n', '     *\n', '     * @param _registry    address of a contract registry contract\n', '     */\n', '    constructor(IContractRegistry _registry) public ContractRegistryClient(_registry) {}\n', '\n', '    /**\n', '     * @dev upgrades an old converter to the latest version\n', "     * will throw if ownership wasn't transferred to the upgrader before calling this function.\n", '     * ownership of the new converter will be transferred back to the original owner.\n', '     * fires the ConverterUpgrade event upon success.\n', '     * can only be called by a converter\n', '     *\n', '     * @param _version old converter version\n', '     */\n', '    function upgrade(bytes32 _version) external override {\n', '        upgradeOld(IConverter(msg.sender), _version);\n', '    }\n', '\n', '    /**\n', '     * @dev upgrades an old converter to the latest version\n', "     * will throw if ownership wasn't transferred to the upgrader before calling this function.\n", '     * ownership of the new converter will be transferred back to the original owner.\n', '     * fires the ConverterUpgrade event upon success.\n', '     * can only be called by a converter\n', '     *\n', '     * @param _version old converter version\n', '     */\n', '    function upgrade(uint16 _version) external override {\n', '        upgrade(IConverter(msg.sender), _version);\n', '    }\n', '\n', '    /**\n', '     * @dev upgrades an old converter to the latest version\n', "     * will throw if ownership wasn't transferred to the upgrader before calling this function.\n", '     * ownership of the new converter will be transferred back to the original owner.\n', '     * fires the ConverterUpgrade event upon success.\n', '     *\n', '     * @param _converter old converter contract address\n', '     */\n', '    function upgradeOld(\n', '        IConverter _converter,\n', '        bytes32 /* _version */\n', '    ) public {\n', "        // the upgrader doesn't require the version for older converters\n", '        upgrade(_converter, 0);\n', '    }\n', '\n', '    /**\n', '     * @dev upgrades an old converter to the latest version\n', "     * will throw if ownership wasn't transferred to the upgrader before calling this function.\n", '     * ownership of the new converter will be transferred back to the original owner.\n', '     * fires the ConverterUpgrade event upon success.\n', '     *\n', '     * @param _converter old converter contract address\n', '     * @param _version old converter version\n', '     */\n', '    function upgrade(IConverter _converter, uint16 _version) private {\n', '        IConverter converter = IConverter(_converter);\n', '        address prevOwner = converter.owner();\n', '        acceptConverterOwnership(converter);\n', '        IConverter newConverter = createConverter(converter);\n', '        copyReserves(converter, newConverter);\n', '        copyConversionFee(converter, newConverter);\n', '        transferReserveBalances(converter, newConverter, _version);\n', '        IConverterAnchor anchor = converter.token();\n', '\n', '        if (anchor.owner() == address(converter)) {\n', '            converter.transferTokenOwnership(address(newConverter));\n', '            newConverter.acceptAnchorOwnership();\n', '        }\n', '\n', '        converter.transferOwnership(prevOwner);\n', '        newConverter.transferOwnership(prevOwner);\n', '\n', '        newConverter.onUpgradeComplete();\n', '\n', '        emit ConverterUpgrade(address(converter), address(newConverter));\n', '    }\n', '\n', '    /**\n', '     * @dev the first step when upgrading a converter is to transfer the ownership to the local contract.\n', '     * the upgrader contract then needs to accept the ownership transfer before initiating\n', '     * the upgrade process.\n', '     * fires the ConverterOwned event upon success\n', '     *\n', '     * @param _oldConverter       converter to accept ownership of\n', '     */\n', '    function acceptConverterOwnership(IConverter _oldConverter) private {\n', '        _oldConverter.acceptOwnership();\n', '        emit ConverterOwned(_oldConverter, address(this));\n', '    }\n', '\n', '    /**\n', '     * @dev creates a new converter with same basic data as the original old converter\n', '     * the newly created converter will have no reserves at this step.\n', '     *\n', '     * @param _oldConverter    old converter contract address\n', '     *\n', '     * @return the new converter  new converter contract address\n', '     */\n', '    function createConverter(IConverter _oldConverter) private returns (IConverter) {\n', '        IConverterAnchor anchor = _oldConverter.token();\n', '        uint32 maxConversionFee = _oldConverter.maxConversionFee();\n', '        uint16 reserveTokenCount = _oldConverter.connectorTokenCount();\n', '\n', '        // determine new converter type\n', '        uint16 newType = 0;\n', '        // new converter - get the type from the converter itself\n', '        if (isV28OrHigherConverter(_oldConverter)) {\n', '            newType = _oldConverter.converterType();\n', '        } else if (reserveTokenCount > 1) {\n', '            // old converter - if it has 1 reserve token, the type is a liquid token, otherwise the type liquidity pool\n', '            newType = 1;\n', '        }\n', '\n', '        if (newType == 1 && reserveTokenCount == 2) {\n', '            (, uint32 weight0, , , ) = _oldConverter.connectors(_oldConverter.connectorTokens(0));\n', '            (, uint32 weight1, , , ) = _oldConverter.connectors(_oldConverter.connectorTokens(1));\n', '            if (weight0 == PPM_RESOLUTION / 2 && weight1 == PPM_RESOLUTION / 2) {\n', '                newType = 3;\n', '            }\n', '        }\n', '\n', '        IConverterFactory converterFactory = IConverterFactory(addressOf(CONVERTER_FACTORY));\n', '        IConverter converter = converterFactory.createConverter(newType, anchor, registry, maxConversionFee);\n', '\n', '        converter.acceptOwnership();\n', '        return converter;\n', '    }\n', '\n', '    /**\n', '     * @dev copies the reserves from the old converter to the new one.\n', '     * note that this will not work for an unlimited number of reserves due to block gas limit constraints.\n', '     *\n', '     * @param _oldConverter    old converter contract address\n', '     * @param _newConverter    new converter contract address\n', '     */\n', '    function copyReserves(IConverter _oldConverter, IConverter _newConverter) private {\n', '        uint16 reserveTokenCount = _oldConverter.connectorTokenCount();\n', '\n', '        for (uint16 i = 0; i < reserveTokenCount; i++) {\n', '            IERC20 reserveAddress = _oldConverter.connectorTokens(i);\n', '            (, uint32 weight, , , ) = _oldConverter.connectors(reserveAddress);\n', '\n', '            _newConverter.addReserve(reserveAddress, weight);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev copies the conversion fee from the old converter to the new one\n', '     *\n', '     * @param _oldConverter    old converter contract address\n', '     * @param _newConverter    new converter contract address\n', '     */\n', '    function copyConversionFee(IConverter _oldConverter, IConverter _newConverter) private {\n', '        uint32 conversionFee = _oldConverter.conversionFee();\n', '        _newConverter.setConversionFee(conversionFee);\n', '    }\n', '\n', '    /**\n', '     * @dev transfers the balance of each reserve in the old converter to the new one.\n', '     * note that the function assumes that the new converter already has the exact same number of reserves\n', '     * also, this will not work for an unlimited number of reserves due to block gas limit constraints.\n', '     *\n', '     * @param _oldConverter    old converter contract address\n', '     * @param _newConverter    new converter contract address\n', '     * @param _version old converter version\n', '     */\n', '    function transferReserveBalances(\n', '        IConverter _oldConverter,\n', '        IConverter _newConverter,\n', '        uint16 _version\n', '    ) private {\n', '        if (_version <= 45) {\n', '            transferReserveBalancesVersion45(ILegacyConverterVersion45(address(_oldConverter)), _newConverter);\n', '\n', '            return;\n', '        }\n', '\n', '        _oldConverter.transferReservesOnUpgrade(address(_newConverter));\n', '    }\n', '\n', '    /**\n', '     * @dev transfers the balance of each reserve in the old converter to the new one.\n', '     * note that the function assumes that the new converter already has the exact same number of reserves\n', '     * also, this will not work for an unlimited number of reserves due to block gas limit constraints.\n', '     *\n', '     * @param _oldConverter old converter contract address\n', '     * @param _newConverter new converter contract address\n', '     */\n', '    function transferReserveBalancesVersion45(ILegacyConverterVersion45 _oldConverter, IConverter _newConverter)\n', '        private\n', '    {\n', '        uint256 reserveBalance;\n', '        uint16 reserveTokenCount = _oldConverter.connectorTokenCount();\n', '\n', '        for (uint16 i = 0; i < reserveTokenCount; i++) {\n', '            IERC20 reserveAddress = _oldConverter.connectorTokens(i);\n', '            // Ether reserve\n', '            if (reserveAddress == NATIVE_TOKEN_ADDRESS) {\n', '                if (address(_oldConverter).balance > 0) {\n', '                    _oldConverter.withdrawETH(address(_newConverter));\n', '                }\n', '            }\n', '            // ERC20 reserve token\n', '            else {\n', '                IERC20 connector = reserveAddress;\n', '                reserveBalance = connector.balanceOf(address(_oldConverter));\n', '                if (reserveBalance > 0) {\n', '                    _oldConverter.withdrawTokens(connector, address(_newConverter), reserveBalance);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    bytes4 private constant IS_V28_OR_HIGHER_FUNC_SELECTOR = bytes4(keccak256("isV28OrHigher()"));\n', '\n', '    // using a static call to identify converter version\n', "    // can't rely on the version number since the function had a different signature in older converters\n", '    function isV28OrHigherConverter(IConverter _converter) internal view returns (bool) {\n', '        bytes memory data = abi.encodeWithSelector(IS_V28_OR_HIGHER_FUNC_SELECTOR);\n', '        (bool success, bytes memory returnData) = address(_converter).staticcall{ gas: 4000 }(data);\n', '\n', '        if (success && returnData.length == 32) {\n', '            return abi.decode(returnData, (bool));\n', '        }\n', '\n', '        return false;\n', '    }\n', '}']