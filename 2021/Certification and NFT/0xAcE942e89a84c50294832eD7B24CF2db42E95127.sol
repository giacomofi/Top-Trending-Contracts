['pragma solidity ^0.5.0;\n', '\n', 'import "./ERC1155.sol";\n', '\n', '/**\n', '    @dev Mintable form of ERC1155\n', '    Shows how easy it is to mint new items.\n', '*/\n', 'contract ERC1155Mintable is ERC1155 {\n', '\n', '    bytes4 constant private INTERFACE_SIGNATURE_URI = 0x0e89341c;\n', '    \n', '    // id => creators\n', '    mapping (uint256 => address) public creators;\n', '    mapping(uint256 => string) public tokenUris;\n', '\n', '    // A nonce to ensure we have a unique id each time we mint.\n', '    uint256 public nonce;\n', '\n', '    modifier creatorOnly(uint256 _id) {\n', '        require(creators[_id] == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function supportsInterface(bytes4 _interfaceId)\n', '    public\n', '    view\n', '    returns (bool) {\n', '        if (_interfaceId == INTERFACE_SIGNATURE_URI) {\n', '            return true;\n', '        } else {\n', '            return super.supportsInterface(_interfaceId);\n', '        }\n', '    }\n', '\n', '    // Creates a new token type and assings _initialSupply to minter\n', '    function create(uint256 _initialSupply, string calldata _uri) external returns(uint256 _id) {\n', '\n', '        _id = ++nonce;\n', '        creators[_id] = msg.sender;\n', '        balances[_id][msg.sender] = _initialSupply;\n', '        tokenUris[_id] = _uri;\n', '\n', '        // Transfer event with mint semantic\n', '        emit TransferSingle(msg.sender, address(0x0), msg.sender, _id, _initialSupply);\n', '\n', '        if (bytes(_uri).length > 0)\n', '            emit URI(_uri, _id);\n', '    }\n', '\n', '    // Batch mint tokens. Assign directly to _to[].\n', '    function mint(uint256 _id, address[] calldata _to, uint256[] calldata _quantities) external creatorOnly(_id) {\n', '        require(msg.sender == creators[_id]);\n', '        for (uint256 i = 0; i < _to.length; ++i) {\n', '\n', '            address to = _to[i];\n', '            uint256 quantity = _quantities[i];\n', '\n', '            // Grant the items to the caller\n', '            balances[_id][to] = quantity.add(balances[_id][to]);\n', '\n', '            // Emit the Transfer/Mint event.\n', '            // the 0x0 source address implies a mint\n', '            // It will also provide the circulating supply info.\n', '            emit TransferSingle(msg.sender, address(0x0), to, _id, quantity);\n', '\n', '            if (to.isContract()) {\n', "                _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, to, _id, quantity, '');\n", '            }\n', '        }\n', '    }\n', '    \n', '    //mint tokens. Assign directly to _to[].\n', '    function mintSingle(uint256 _id, address _to, uint256 _quantities) external creatorOnly(_id) {\n', '        require(msg.sender == creators[_id]);\n', '        // Grant the items to the caller\n', '        balances[_id][_to] = _quantities.add(balances[_id][_to]);\n', '\n', '        // Emit the Transfer/Mint event.\n', '        // the 0x0 source address implies a mint\n', '        // It will also provide the circulating supply info.\n', '        emit TransferSingle(msg.sender, address(0x0), _to, _id, _quantities);\n', '\n', '        if (_to.isContract()) {\n', "            _doSafeTransferAcceptanceCheck(msg.sender, msg.sender, _to, _id, _quantities, '');\n", '        }\n', '    }\n', '\n', '    function setURI(string calldata _uri, uint256 _id) external creatorOnly(_id) {\n', '        require(msg.sender == creators[_id]);\n', '        tokenUris[_id] = _uri;\n', '        emit URI(_uri, _id);\n', '    }\n', '}']