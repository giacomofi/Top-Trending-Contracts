['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "./Context.sol";\n', 'import "./IERC721.sol";\n', 'import "./IERC721Metadata.sol";\n', 'import "./IERC721Enumerable.sol";\n', 'import "./IERC721Receiver.sol";\n', 'import "./AccessControl.sol";\n', 'import "./ERC165.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Address.sol";\n', 'import "./EnumerableSet.sol";\n', 'import "./EnumerableMap.sol";\n', 'import "./Strings.sol";\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'contract GovERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable, AccessControl {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '    using EnumerableSet for EnumerableSet.UintSet;\n', '    using EnumerableMap for EnumerableMap.UintToAddressMap;\n', '    using Strings for uint256;\n', '    bool public isOnline;\n', '    bool public canWithdrawalFees;\n', '    DAOInterface public DAO;\n', '    ExchangeInterface public Exchange;\n', '    uint256 public total_voting_power;\n', '    uint256 constant public MAX_VOTES = 10_000_000;\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '    bytes32 public constant GOVERANCE = keccak256("GOVERANCE");\n', '    bytes32 public constant EXCHANGE = keccak256("EXCHANGE");\n', '    // Mapping from holder address to their (enumerable) set of owned tokens\n', '    mapping (address => EnumerableSet.UintSet) private _holderTokens;\n', '\n', '    // Enumerable mapping from token ids to their owners\n', '    EnumerableMap.UintToAddressMap private _tokenOwners;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '\n', '    \n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping(address => bool)) private _operatorApprovals;\n', '\n', '    // Token name\n', '    string private _name;\n', '\n', '    // Token symbol\n', '    string private _symbol;\n', '    \n', '    struct Voting {\n', '            \n', '        uint256 id;\n', '        \n', '        bool hasVoted;\n', '\n', '    }\n', '    /// @notice Possible states that a proposal may be in\n', '    enum ProposalState {\n', '        Pending,\n', '        Active,\n', '        Canceled,\n', '        Defeated,\n', '        Succeeded,\n', '        Executed\n', '    }\n', '    // Optional mapping for token URIs\n', '    mapping(uint256 => string) private _tokenURIs;\n', '    mapping(address => uint256) public delegate_voting_power;\n', '    mapping(uint256 => uint256) public NFT_voting_power;\n', '    mapping(address => bool) public vote_in_progress;\n', '    mapping (address => Voting) private currently_voting;\n', '    // Base URI\n', '    string private _baseURI;\n', '\n', '    /*\n', "     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n", "     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n", "     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n", "     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n", '     *\n', '     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\n', '     *        0xa22cb465 ^ 0xe985e9c ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n', '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '\n', '    /*\n', "     *     bytes4(keccak256('name()')) == 0x06fdde03\n", "     *     bytes4(keccak256('symbol()')) == 0x95d89b41\n", "     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\n", '     *\n', '     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\n', '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '\n', '    /*\n', "     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\n", "     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\n", "     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\n", '     *\n', '     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\n', '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '\n', '    /**\n', '     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n', '     */\n', '     \n', '     // @notice An event emitted when voting power has been changed\n', '    event VotingPowerAdded(address indexed voter, uint256 indexed tokenId, uint256 indexed votes);\n', '    event VotingPowerRemoved(address indexed voter, uint256 indexed tokenId,uint256 indexed votes);\n', '    \n', '    \n', '    constructor (string memory name, string memory symbol, string memory baseURI_, address _exchange) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _setBaseURI(baseURI_);\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n', '        _setupRole(EXCHANGE, _exchange);\n', '        isOnline = true;\n', '        canWithdrawalFees = false;\n', '        _mint(msg.sender, 5_000_000);\n', '        \n', '    }\n', '    \n', '    modifier isGoverance() {\n', '        require(\n', '            hasRole(GOVERANCE, _msgSender()) ||  hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\n', '            "Only permitted addresses can use this function"\n', '        );\n', '        _;\n', '    }\n', '   modifier isExchange() {\n', '        require(\n', '            hasRole(EXCHANGE, _msgSender()),\n', '            "Only permitted addresses can use this function"\n', '        );\n', '        _;\n', '    }\n', ' \n', '    /**\n', '     * @dev See {IERC721-balanceOf}.\n', '     */\n', '    function balanceOf(address owner) public view override returns (uint256) {\n', '        require(owner != address(0), "ERC721: balance query for the zero address");\n', '\n', '        return _holderTokens[owner].length();\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-ownerOf}.\n', '     */\n', '    function ownerOf(uint256 tokenId) public view override returns (address) {\n', '        return _tokenOwners.get(tokenId, "ERC721: owner query for nonexistent token");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-name}.\n', '     */\n', '    function name() public view override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-symbol}.\n', '     */\n', '    function symbol() public view override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    \n', '    /**\n', '     * @dev See {IERC721Metadata-tokenURI}.\n', '     */\n', '    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n', '        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n', '\n', '        string memory _tokenURI = _tokenURIs[tokenId];\n', '\n', '        // If there is no base URI, return the token URI.\n', '        if (bytes(_baseURI).length == 0) {\n', '            return _tokenURI;\n', '        }\n', '        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n', '        if (bytes(_tokenURI).length > 0) {\n', '            return string(abi.encodePacked(_baseURI, _tokenURI));\n', '        }\n', '        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n', '        return string(abi.encodePacked(_baseURI, tokenId.toString()));\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the base URI set via {_setBaseURI}. This will be\n', "    * automatically added as a prefix in {tokenURI} to each token's URI, or\n", '    * to the token ID if no specific URI is set for that token ID.\n', '    */\n', '    function baseURI() public view returns (string memory) {\n', '        return _baseURI;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n', '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view override returns (uint256) {\n', '        return _holderTokens[owner].at(index);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\n', '        return _tokenOwners.length();\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-tokenByIndex}.\n', '     */\n', '    function tokenByIndex(uint256 index) public view override returns (uint256) {\n', '        (uint256 tokenId, ) = _tokenOwners.at(index);\n', '        return tokenId;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-approve}.\n', '     */\n', '    function approve(address to, uint256 tokenId) public virtual override {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner, "ERC721: approval to current owner");\n', '\n', '        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n', '            "ERC721: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _approve(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-getApproved}.\n', '     */\n', '    function getApproved(uint256 tokenId) public view override returns (address) {\n', '        require(_exists(tokenId), "ERC721: approved query for nonexistent token");\n', '\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-setApprovalForAll}.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) public virtual override {\n', '        require(operator != _msgSender(), "ERC721: approve to caller");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-isApprovedForAll}.\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-transferFrom}.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n', '        //solhint-disable-next-line max-line-length\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '\n', '        _transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: transfer caller is not owner nor approved");\n', '        _safeTransfer(from, to, tokenId, _data);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n', '     *\n', '     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n', '     * implement alternative mecanisms to perform token transfer, such as signature-based.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n', '        _transfer(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `tokenId` exists.\n', '     *\n', '     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n', '     *\n', '     * Tokens start existing when they are minted (`_mint`),\n', '     * and stop existing when they are burned (`_burn`).\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        return _tokenOwners.contains(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        require(_exists(tokenId), "ERC721: operator query for nonexistent token");\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Safely mints `tokenId` and transfers it to `to`.\n', '     *\n', '     * Requirements:\n', '     d*\n', '     * - `tokenId` must not exist.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeMint(address to, uint256 tokenId, uint256 voting_power) internal virtual {\n', '        _safeMint(to, tokenId, "", voting_power);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n', '     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n', '     */\n', '    function _safeMint(address to, uint256 tokenId, bytes memory _data, uint256 voting_power) internal virtual {\n', '        _mint(to, voting_power);\n', '        require(_checkOnERC721Received(address(0), to, tokenId, _data), "ERC721: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    /**\n', '     * @dev Mints `tokenId` and transfers it to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must not exist.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _mint(address to, uint256 voting_power) internal virtual {\n', '        require(isOnline, "The contract is paused, cannot proceed");\n', '        require(to != address(0), "ERC721: mint to the zero address");\n', '        uint256 tokenId = totalSupply().add(1); \n', '        require(!_exists(tokenId), "ERC721: token already minted");\n', '        if(total_voting_power.add(voting_power) >= MAX_VOTES){\n', '            return;\n', '        }\n', '        if(balanceOf(to) >= 1){\n', '            uint256 current_token = tokenOfOwnerByIndex(to, 0);\n', '            NFT_voting_power[current_token] = NFT_voting_power[current_token].add(voting_power);\n', '            delegate_voting_power[to] = delegate_voting_power[to].add(voting_power);\n', '            total_voting_power = total_voting_power.add(voting_power);\n', '            emit VotingPowerAdded(to, current_token, voting_power);\n', '            return;\n', '        }\n', '        _holderTokens[to].add(tokenId);\n', '        NFT_voting_power[tokenId] = voting_power;\n', '        delegate_voting_power[to] = delegate_voting_power[to].add(voting_power);\n', '        _tokenOwners.set(tokenId, to);\n', '        total_voting_power = total_voting_power.add(voting_power);\n', '        emit VotingPowerAdded(to, tokenId, voting_power);\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `tokenId`.\n', '     * The approval is cleared when the token is burned.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _burn(uint256 tokenId) internal virtual {\n', '        address owner = ownerOf(tokenId);\n', '\n', '        //_beforeTokenTransfer(owner, address(0), tokenId);\n', '\n', '        // Clear approvals\n', '        _approve(address(0), tokenId);\n', '\n', '        // Clear metadata (if any)\n', '        if (bytes(_tokenURIs[tokenId]).length != 0) {\n', '            delete _tokenURIs[tokenId];\n', '        }\n', '\n', '        _holderTokens[owner].remove(tokenId);\n', '        //_tokenOwners.remove(tokenId);\n', '        _tokenOwners.set(tokenId, address(0));\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` from `from` to `to`.\n', '     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n', '        require(ownerOf(tokenId) == from, "ERC721: transfer of token that is not own");\n', '        require(to != address(0), "ERC721: transfer to the zero address");\n', '        require(!isLocked(from), "NFT votes are being used and cannot be transferred");\n', '        _beforeTokenTransfer(from, to, tokenId);\n', '\n', '        // Clear approvals from the previous owner\n', '        _approve(address(0), tokenId);\n', '\n', '        _holderTokens[from].remove(tokenId);\n', '        _holderTokens[to].add(tokenId);\n', '\n', '        _tokenOwners.set(tokenId, to);\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n', '        require(_exists(tokenId), "ERC721Metadata: URI set of nonexistent token");\n', '        _tokenURIs[tokenId] = _tokenURI;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to set the base URI for all token IDs. It is\n', '     * automatically added as a prefix to the value returned in {tokenURI},\n', '     * or to the token ID if {tokenURI} is empty.\n', '     */\n', '    function _setBaseURI(string memory baseURI_) internal virtual {\n', '        _baseURI = baseURI_;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n', '     * The call is not executed if the target address is not a contract.\n', '     *\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        private returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n', '            IERC721Receiver(to).onERC721Received.selector,\n', '            _msgSender(),\n', '            from,\n', '            tokenId,\n', '            _data\n', '        ), "ERC721: transfer to non ERC721Receiver implementer");\n', '        bytes4 retval = abi.decode(returndata, (bytes4));\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    function _approve(address to, uint256 tokenId) private {\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(ownerOf(tokenId), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any token transfer. This includes minting\n', '     * and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n", '     * transferred to `to`.\n', '     * - When `from` is zero, `tokenId` will be minted for `to`.\n', "     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n", '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual {\n', '        delegate_voting_power[from] = delegate_voting_power[from].sub(NFT_voting_power[tokenId]);\n', '        delegate_voting_power[to] = delegate_voting_power[to].add(NFT_voting_power[tokenId]);\n', '        emit VotingPowerAdded(to, tokenId, NFT_voting_power[tokenId]);\n', '        emit VotingPowerRemoved(from, tokenId, NFT_voting_power[tokenId]);\n', '    }\n', '    \n', '    \n', '    /**\n', '     * \n', '     *      GOVERANCE FUNCTIONS\n', '     * \n', '     * */\n', '      function isLocked(address _account) public returns (bool){\n', '        if(vote_in_progress[_account]){\n', '            if(DAO.state(currently_voting[_account].id) != ProposalState.Active){\n', '                _unlockNFT(_account);\n', '                return false;\n', '            }else{\n', '                return true;\n', '            }\n', '        }else{\n', '            return false;\n', '        }\n', '    }\n', '        \n', '   function _lockNFT(address _voter, uint256 _proposal) isGoverance external returns (bool){\n', '      vote_in_progress[_voter] = true;\n', '      Voting memory newVote = Voting({\n', '            id: _proposal,\n', '            hasVoted: true\n', '        });\n', '      currently_voting[_voter] = newVote;\n', '      return vote_in_progress[_voter];\n', '   } \n', '\n', '    function _unlockNFT(address _voter) internal returns (bool){\n', '         vote_in_progress[_voter] = false;\n', '         return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the total votes in circulation\n', '     */\n', '    function totalVotingPower() public view  returns (uint256) {\n', '        return total_voting_power;\n', '    }\n', '\n', '\n', '    /**\n', "     * @dev Returns an account's total voting power\n", '     */\n', '    function delegateVotingPower(address _address) public view  returns (uint256) {\n', '        return delegate_voting_power[_address];\n', '    }\n', '    \n', '    /**\n', "     * @dev Returns an NFT's total voting power\n", '     */\n', '    function tokenVotingPower(uint256 _tokenId) public view  returns (uint256) {\n', '        return NFT_voting_power[_tokenId];\n', '    }\n', '       /**  Bonding curve\n', '     *\n', '     * */\n', '    function calculateCurve() public view returns (uint256) {\n', '        uint256 p = (\n', '            (total_voting_power.div(200) * 10**18).div(MAX_VOTES.sub(total_voting_power))\n', '        );\n', '        if(p > (1*10**18)){\n', '            return 1* 10**18;\n', '        }\n', '        if(p == 0){\n', '            return 1;\n', '        }\n', '        return p;\n', '    }\n', '    \n', '    function _checkWashTrader(address _account) internal view returns (bool){\n', '        return DAO.getWashTrader(_account);\n', '    }\n', '    \n', '    function _checkApprovedContract(address _contract) internal view returns (bool){\n', '        return DAO.getApprovedContracts(_contract);\n', '    }\n', '    function splitNFT(address _to, uint256 _tokenId, uint256 _split_amount)public returns (bool){\n', '        require(isOnline, "The contract is paused, cannot proceed");\n', '        require(ownerOf(_tokenId) == _msgSender(), "ERC721: transfer of token that is not own");\n', '        require(_to != address(0), "ERC721: transfer to the zero address");\n', '        require(!isLocked(_msgSender()), "NFT votes are being used and cannot be transferred");\n', '        require(delegate_voting_power[_msgSender()] >= _split_amount, "You don\'t have enough votes to split");\n', '        require(NFT_voting_power[_tokenId] >= _split_amount, "Your NFT doesn\'t have that many votes to split");\n', '        uint256 tokenId = totalSupply().add(1); \n', '        require(!_exists(tokenId), "ERC721: token already minted");\n', '        \n', '        \n', '        NFT_voting_power[tokenId] = _split_amount;    \n', '        NFT_voting_power[_tokenId] = NFT_voting_power[_tokenId].sub(_split_amount);\n', '        _tokenOwners.set(tokenId, _to);\n', '        _holderTokens[_to].add(tokenId);\n', '        delegate_voting_power[_msgSender()] = delegate_voting_power[_msgSender()].sub(_split_amount);\n', '        delegate_voting_power[_to] = delegate_voting_power[_to].add(_split_amount);\n', '        emit VotingPowerAdded(_to, tokenId, NFT_voting_power[tokenId]);\n', '        emit VotingPowerRemoved(_msgSender(), tokenId, NFT_voting_power[tokenId]);\n', '        emit Transfer(address(0), _to, tokenId);\n', '    \n', '       \n', '    }\n', '    \n', '    function buyVotes() public payable returns (bool){\n', '        require(isOnline, "The contract is paused, cannot proceed");\n', '        uint256 p = calculateCurve();\n', '        uint256 amount = msg.value.div(p);\n', '        require(amount >= 1, "Not enough for one vote");\n', '        require(total_voting_power.add(amount) <= MAX_VOTES, "Not enough votes left to be purchased");\n', '        _mint(_msgSender(), amount);\n', '        return true;\n', '        \n', '    }\n', '    \n', '    function earnVotes(uint256 _value, address _seller, address _buyer, address _contract) isExchange external returns (bool){\n', '        uint256 p = calculateCurve();\n', '        uint256 multipler = 50;\n', '        //p = p.add(p.mul(75).div(100));\n', '        if(_checkApprovedContract(_contract)){\n', '            multipler = 100;\n', '        }\n', '        uint256 votes = _value.div(p);\n', '        votes = votes.mul(multipler).div(100);\n', '        if(votes < 2){\n', '              \n', '            return false;\n', '        }\n', '         if(total_voting_power.add(votes) >= MAX_VOTES){\n', '             \n', '             return false;\n', '         }\n', '        require(_buyer != address(0x0) && _seller != address(0x0), "Cannot by the 0x0 address");\n', '        require(_contract != address(0x0), "Cannot be the 0x0 address");\n', '        require(_value >= 0, "Must have sent a value");\n', '        if(_buyer == _seller){\n', '            return false;\n', '        }\n', '        if(_checkWashTrader(_seller) || _checkWashTrader(_buyer)){\n', '              \n', '            return false;\n', '        }\n', '   \n', '        votes = votes.div(2);\n', '        _mint(_seller, votes);\n', '        _mint(_buyer, votes);\n', '        return true;\n', '    }\n', '    \n', '    function setDAOContract(address _DAO) isGoverance public returns (bool){\n', '        DAO = DAOInterface(_DAO);\n', '        _setupRole(GOVERANCE, _DAO);\n', '        return true;\n', '    }\n', '    function setExchangeContract(address _exchange) isGoverance public returns (bool){\n', '        Exchange = ExchangeInterface(_exchange);\n', '        _setupRole(EXCHANGE, _exchange);\n', '        return true;\n', '    }\n', '    function toggleOnline() isGoverance public returns (bool){\n', '        isOnline = !isOnline;\n', '        return isOnline;\n', '    }\n', '      function toggleWithdrawFees() isGoverance public returns (bool){\n', '       canWithdrawalFees = !canWithdrawalFees;\n', '       return canWithdrawalFees;\n', '    }\n', '  function withdraw (uint256 _amount) public returns (bool){\n', '      require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "Not authorized");\n', '      require(_amount <= address(this).balance, "Not enough funds to withdrawal");\n', '      msg.sender.transfer(_amount);\n', '      return true;\n', '  }\n', '  \n', '  function withdrawFeesByVoter(uint256 _tokenId) public returns (bool){\n', '      require(canWithdrawalFees, "Withdrawals have not been enabled by the DAO");\n', '      require(isOnline, "The contract is paused, cannot proceed");\n', '      require(balanceOf(msg.sender) >= 1, "You must have atleast 1 NFT to withdrawal");\n', '      require(ownerOf(_tokenId) == msg.sender, "You do not own that token");\n', '      require(delegateVotingPower(msg.sender) >= 1, "You must have atleast 1 vote in order to withdrawal");\n', '      require(tokenVotingPower(_tokenId) >= 1, "Your NFT must hold atleast 1 vote");\n', '      require(total_voting_power.sub(NFT_voting_power[_tokenId]) >= 0, "Cannot go negative for voting power");\n', '      require(address(Exchange).balance > 0, "No fees to withdrawal");\n', '      _withdrawalFees(_tokenId);\n', '      \n', '      \n', '  }\n', '  function _withdrawalFees(uint256 _tokenId) internal returns (bool){\n', '      require(tokenVotingPower(_tokenId) <= delegateVotingPower(msg.sender), "NFT has more votes than owner does");\n', '      uint256 percentageOfVotes = (tokenVotingPower(_tokenId).mul(10_000)).div(total_voting_power);\n', '      require(percentageOfVotes > 0, "Percentage of votes is less than minimum to withdrawal");\n', '      uint256 ExchangeBalance = address(Exchange).balance;\n', '      uint256 withdrawAmount = (ExchangeBalance.mul(percentageOfVotes)).div(10_000);\n', '      require(withdrawAmount > 0, "Cannot withdrawal 0");\n', '      require(withdrawAmount <= ExchangeBalance, "Cannot withdrawal more than the balance of the contract");\n', '        \n', '      delegate_voting_power[msg.sender] = delegate_voting_power[msg.sender].sub(NFT_voting_power[_tokenId]);\n', '      emit VotingPowerRemoved(msg.sender, _tokenId, NFT_voting_power[_tokenId]); \n', '      total_voting_power = total_voting_power.sub(NFT_voting_power[_tokenId]);\n', '      NFT_voting_power[_tokenId] = 0;\n', '      _burn(_tokenId);\n', '      require(Exchange.WithdrawalDAO(withdrawAmount, msg.sender), "Withdrawal failed");\n', '      return true;\n', '  }\n', '  \n', '}\n', 'interface DAOInterface {\n', '    \n', '    function state(uint256 proposalId) external view returns (GovERC721.ProposalState);\n', '    function getWashTrader(address _account) external view returns (bool);\n', '    function getApprovedContracts(address _contract) external view returns (bool);\n', '}\n', 'interface ExchangeInterface {\n', '    \n', '    function WithdrawalDAO (uint256 _amount, address payable _account) external returns (bool);\n', '}']