['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-19\n', '*/\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.6.9;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/Initializable.sol\n', '\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/GSN/Context.sol\n', '\n', '\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract ContextUpgradeSafe is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '\n', '\n', '    }\n', '\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', '// File: src/utils/PerpFiOwnableUpgrade.sol\n', '\n', '\n', '\n', '\n', '\n', '// copy from openzeppelin Ownable, only modify how the owner transfer\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract PerpFiOwnableUpgrade is ContextUpgradeSafe {\n', '    address private _owner;\n', '    address private _candidate;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    function candidate() public view returns (address) {\n', '        return _candidate;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "PerpFiOwnableUpgrade: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Set ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function setOwner(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "PerpFiOwnableUpgrade: zero address");\n', '        require(newOwner != _owner, "PerpFiOwnableUpgrade: same as original");\n', '        require(newOwner != _candidate, "PerpFiOwnableUpgrade: same as candidate");\n', '        _candidate = newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`_candidate`).\n', '     * Can only be called by the new owner.\n', '     */\n', '    function updateOwner() public {\n', '        require(_candidate != address(0), "PerpFiOwnableUpgrade: candidate is zero address");\n', '        require(_candidate == _msgSender(), "PerpFiOwnableUpgrade: not the new owner");\n', '\n', '        emit OwnershipTransferred(_owner, _candidate);\n', '        _owner = _candidate;\n', '        _candidate = address(0);\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', '// File: solidity-bytes-utils/contracts/BytesLib.sol\n', '\n', '/*\n', ' * @title Solidity Bytes Arrays Utils\n', ' * @author Gonçalo Sá <[email\xa0protected]>\n', ' *\n', ' * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n', ' *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n', ' */\n', '\n', '\n', 'library BytesLib {\n', '    function concat(\n', '        bytes memory _preBytes,\n', '        bytes memory _postBytes\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            // Get a location of some free memory and store it in tempBytes as\n', '            // Solidity does for memory variables.\n', '            tempBytes := mload(0x40)\n', '\n', '            // Store the length of the first bytes array at the beginning of\n', '            // the memory for tempBytes.\n', '            let length := mload(_preBytes)\n', '            mstore(tempBytes, length)\n', '\n', '            // Maintain a memory counter for the current write location in the\n', '            // temp bytes array by adding the 32 bytes for the array length to\n', '            // the starting location.\n', '            let mc := add(tempBytes, 0x20)\n', '            // Stop copying when the memory counter reaches the length of the\n', '            // first bytes array.\n', '            let end := add(mc, length)\n', '\n', '            for {\n', '                // Initialize a copy counter to the start of the _preBytes data,\n', '                // 32 bytes into its memory.\n', '                let cc := add(_preBytes, 0x20)\n', '            } lt(mc, end) {\n', '                // Increase both counters by 32 bytes each iteration.\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                // Write the _preBytes data into the tempBytes memory 32 bytes\n', '                // at a time.\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Add the length of _postBytes to the current length of tempBytes\n', '            // and store it as the new length in the first 32 bytes of the\n', '            // tempBytes memory.\n', '            length := mload(_postBytes)\n', '            mstore(tempBytes, add(length, mload(tempBytes)))\n', '\n', '            // Move the memory counter back from a multiple of 0x20 to the\n', '            // actual end of the _preBytes data.\n', '            mc := end\n', '            // Stop copying when the memory counter reaches the new combined\n', '            // length of the arrays.\n', '            end := add(mc, length)\n', '\n', '            for {\n', '                let cc := add(_postBytes, 0x20)\n', '            } lt(mc, end) {\n', '                mc := add(mc, 0x20)\n', '                cc := add(cc, 0x20)\n', '            } {\n', '                mstore(mc, mload(cc))\n', '            }\n', '\n', '            // Update the free-memory pointer by padding our last write location\n', '            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n', '            // next 32 byte block, then round down to the nearest multiple of\n', '            // 32. If the sum of the length of the two arrays is zero then add\n', '            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n', '            mstore(0x40, and(\n', '              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n', '              not(31) // Round down to the nearest 32 bytes.\n', '            ))\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n', '        assembly {\n', '            // Read the first 32 bytes of _preBytes storage, which is the length\n', "            // of the array. (We don't need to use the offset into the slot\n", '            // because arrays use the entire slot.)\n', '            let fslot := sload(_preBytes_slot)\n', '            // Arrays of 31 bytes or less have an even value in their slot,\n', '            // while longer arrays have an odd value. The actual length is\n', '            // the slot divided by two for odd values, and the lowest order\n', '            // byte divided by two for even values.\n', '            // If the slot is even, bitwise and the slot with 255 and divide by\n', '            // two to get the length. If the slot is odd, bitwise and the slot\n', '            // with -1 and divide by two.\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '            let newlength := add(slength, mlength)\n', '            // slength can contain both the length and contents of the array\n', "            // if length < 32 bytes so let's prepare for that\n", '            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '            switch add(lt(slength, 32), lt(newlength, 32))\n', '            case 2 {\n', '                // Since the new array still fits in the slot, we just need to\n', '                // update the contents of the slot.\n', '                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n', '                sstore(\n', '                    _preBytes_slot,\n', '                    // all the modifications to the slot are inside this\n', '                    // next block\n', '                    add(\n', '                        // we can just add to the slot contents because the\n', '                        // bytes we want to change are the LSBs\n', '                        fslot,\n', '                        add(\n', '                            mul(\n', '                                div(\n', '                                    // load the bytes from memory\n', '                                    mload(add(_postBytes, 0x20)),\n', '                                    // zero all bytes to the right\n', '                                    exp(0x100, sub(32, mlength))\n', '                                ),\n', '                                // and now shift left the number of bytes to\n', '                                // leave space for the length in the slot\n', '                                exp(0x100, sub(32, newlength))\n', '                            ),\n', '                            // increase length by the double of the memory\n', '                            // bytes length\n', '                            mul(mlength, 2)\n', '                        )\n', '                    )\n', '                )\n', '            }\n', '            case 1 {\n', '                // The stored value fits in the slot, but the combined value\n', '                // will exceed it.\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // The contents of the _postBytes array start 32 bytes into\n', '                // the structure. Our first read should obtain the `submod`\n', '                // bytes that can fit into the unused space in the last word\n', '                // of the stored array. To get this, we read 32 bytes starting\n', '                // from `submod`, so the data we read overlaps with the array\n', '                // contents by `submod` bytes. Masking the lowest-order\n', '                // `submod` bytes allows us to add that value directly to the\n', '                // stored value.\n', '\n', '                let submod := sub(32, slength)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(\n', '                    sc,\n', '                    add(\n', '                        and(\n', '                            fslot,\n', '                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n', '                        ),\n', '                        and(mload(mc), mask)\n', '                    )\n', '                )\n', '\n', '                for {\n', '                    mc := add(mc, 0x20)\n', '                    sc := add(sc, 1)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '            default {\n', '                // get the keccak hash to get the contents of the array\n', '                mstore(0x0, _preBytes_slot)\n', '                // Start copying to the last used word of the stored array.\n', '                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n', '\n', '                // save new length\n', '                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\n', '\n', '                // Copy over the first `submod` bytes of the new data as in\n', '                // case 1 above.\n', '                let slengthmod := mod(slength, 32)\n', '                let mlengthmod := mod(mlength, 32)\n', '                let submod := sub(32, slengthmod)\n', '                let mc := add(_postBytes, submod)\n', '                let end := add(_postBytes, mlength)\n', '                let mask := sub(exp(0x100, submod), 1)\n', '\n', '                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n', '\n', '                for {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } lt(mc, end) {\n', '                    sc := add(sc, 1)\n', '                    mc := add(mc, 0x20)\n', '                } {\n', '                    sstore(sc, mload(mc))\n', '                }\n', '\n', '                mask := exp(0x100, sub(mc, end))\n', '\n', '                sstore(sc, mul(div(mload(mc), mask), mask))\n', '            }\n', '        }\n', '    }\n', '\n', '    function slice(\n', '        bytes memory _bytes,\n', '        uint256 _start,\n', '        uint256 _length\n', '    )\n', '        internal\n', '        pure\n', '        returns (bytes memory)\n', '    {\n', '        require(_length + 31 >= _length, "slice_overflow");\n', '        require(_start + _length >= _start, "slice_overflow");\n', '        require(_bytes.length >= _start + _length, "slice_outOfBounds");\n', '\n', '        bytes memory tempBytes;\n', '\n', '        assembly {\n', '            switch iszero(_length)\n', '            case 0 {\n', '                // Get a location of some free memory and store it in tempBytes as\n', '                // Solidity does for memory variables.\n', '                tempBytes := mload(0x40)\n', '\n', '                // The first word of the slice result is potentially a partial\n', '                // word read from the original array. To read it, we calculate\n', '                // the length of that partial word and start copying that many\n', '                // bytes into the array. The first word we copy will start with\n', "                // data we don't care about, but the last `lengthmod` bytes will\n", '                // land at the beginning of the contents of the new array. When\n', "                // we're done copying, we overwrite the full first word with\n", '                // the actual length of the slice.\n', '                let lengthmod := and(_length, 31)\n', '\n', '                // The multiplication in the next line is necessary\n', '                // because when slicing multiples of 32 bytes (lengthmod == 0)\n', "                // the following copy loop was copying the origin's length\n", '                // and then ending prematurely not copying everything it should.\n', '                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n', '                let end := add(mc, _length)\n', '\n', '                for {\n', '                    // The multiplication in the next line has the same exact purpose\n', '                    // as the one above.\n', '                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n', '                } lt(mc, end) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    mstore(mc, mload(cc))\n', '                }\n', '\n', '                mstore(tempBytes, _length)\n', '\n', '                //update free-memory pointer\n', '                //allocating the array padded to 32 bytes like the compiler does now\n', '                mstore(0x40, and(add(mc, 31), not(31)))\n', '            }\n', "            //if we want a zero-length slice let's just return a zero-length array\n", '            default {\n', '                tempBytes := mload(0x40)\n', '\n', '                mstore(0x40, add(tempBytes, 0x20))\n', '            }\n', '        }\n', '\n', '        return tempBytes;\n', '    }\n', '\n', '    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n', '        require(_start + 20 >= _start, "toAddress_overflow");\n', '        require(_bytes.length >= _start + 20, "toAddress_outOfBounds");\n', '        address tempAddress;\n', '\n', '        assembly {\n', '            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n', '        }\n', '\n', '        return tempAddress;\n', '    }\n', '\n', '    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n', '        require(_start + 1 >= _start, "toUint8_overflow");\n', '        require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");\n', '        uint8 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x1), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n', '        require(_start + 2 >= _start, "toUint16_overflow");\n', '        require(_bytes.length >= _start + 2, "toUint16_outOfBounds");\n', '        uint16 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x2), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n', '        require(_start + 4 >= _start, "toUint32_overflow");\n', '        require(_bytes.length >= _start + 4, "toUint32_outOfBounds");\n', '        uint32 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x4), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n', '        require(_start + 8 >= _start, "toUint64_overflow");\n', '        require(_bytes.length >= _start + 8, "toUint64_outOfBounds");\n', '        uint64 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x8), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n', '        require(_start + 12 >= _start, "toUint96_overflow");\n', '        require(_bytes.length >= _start + 12, "toUint96_outOfBounds");\n', '        uint96 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0xc), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n', '        require(_start + 16 >= _start, "toUint128_overflow");\n', '        require(_bytes.length >= _start + 16, "toUint128_outOfBounds");\n', '        uint128 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x10), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n', '        require(_start + 32 >= _start, "toUint256_overflow");\n', '        require(_bytes.length >= _start + 32, "toUint256_outOfBounds");\n', '        uint256 tempUint;\n', '\n', '        assembly {\n', '            tempUint := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempUint;\n', '    }\n', '\n', '    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n', '        require(_start + 32 >= _start, "toBytes32_overflow");\n', '        require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");\n', '        bytes32 tempBytes32;\n', '\n', '        assembly {\n', '            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n', '        }\n', '\n', '        return tempBytes32;\n', '    }\n', '\n', '    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            let length := mload(_preBytes)\n', '\n', "            // if lengths don't match the arrays are not equal\n", '            switch eq(length, mload(_postBytes))\n', '            case 1 {\n', "                // cb is a circuit breaker in the for loop since there's\n", '                //  no said feature for inline assembly loops\n', "                // cb = 1 - don't breaker\n", '                // cb = 0 - break\n', '                let cb := 1\n', '\n', '                let mc := add(_preBytes, 0x20)\n', '                let end := add(mc, length)\n', '\n', '                for {\n', '                    let cc := add(_postBytes, 0x20)\n', '                // the next line is the loop condition:\n', '                // while(uint256(mc < end) + cb == 2)\n', '                } eq(add(lt(mc, end), cb), 2) {\n', '                    mc := add(mc, 0x20)\n', '                    cc := add(cc, 0x20)\n', '                } {\n', '                    // if any of these checks fails then arrays are not equal\n', '                    if iszero(eq(mload(mc), mload(cc))) {\n', '                        // unsuccess:\n', '                        success := 0\n', '                        cb := 0\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '\n', '    function equalStorage(\n', '        bytes storage _preBytes,\n', '        bytes memory _postBytes\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        bool success = true;\n', '\n', '        assembly {\n', '            // we know _preBytes_offset is 0\n', '            let fslot := sload(_preBytes_slot)\n', '            // Decode the length of the stored array like in concatStorage().\n', '            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n', '            let mlength := mload(_postBytes)\n', '\n', "            // if lengths don't match the arrays are not equal\n", '            switch eq(slength, mlength)\n', '            case 1 {\n', '                // slength can contain both the length and contents of the array\n', "                // if length < 32 bytes so let's prepare for that\n", '                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n', '                if iszero(iszero(slength)) {\n', '                    switch lt(slength, 32)\n', '                    case 1 {\n', '                        // blank the last byte which is the length\n', '                        fslot := mul(div(fslot, 0x100), 0x100)\n', '\n', '                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n', '                            // unsuccess:\n', '                            success := 0\n', '                        }\n', '                    }\n', '                    default {\n', "                        // cb is a circuit breaker in the for loop since there's\n", '                        //  no said feature for inline assembly loops\n', "                        // cb = 1 - don't breaker\n", '                        // cb = 0 - break\n', '                        let cb := 1\n', '\n', '                        // get the keccak hash to get the contents of the array\n', '                        mstore(0x0, _preBytes_slot)\n', '                        let sc := keccak256(0x0, 0x20)\n', '\n', '                        let mc := add(_postBytes, 0x20)\n', '                        let end := add(mc, mlength)\n', '\n', '                        // the next line is the loop condition:\n', '                        // while(uint256(mc < end) + cb == 2)\n', '                        for {} eq(add(lt(mc, end), cb), 2) {\n', '                            sc := add(sc, 1)\n', '                            mc := add(mc, 0x20)\n', '                        } {\n', '                            if iszero(eq(sload(sc), mload(mc))) {\n', '                                // unsuccess:\n', '                                success := 0\n', '                                cb := 0\n', '                            }\n', '                        }\n', '                    }\n', '                }\n', '            }\n', '            default {\n', '                // unsuccess:\n', '                success := 0\n', '            }\n', '        }\n', '\n', '        return success;\n', '    }\n', '}\n', '\n', '// File: src/utils/LowLevelErrorMessage.sol\n', '\n', '\n', '\n', '\n', '\n', 'abstract contract LowLevelErrorMessage {\n', '    using BytesLib for bytes;\n', '\n', '    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n', '\n', '    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n', '    uint256[50] private __gap;\n', '\n', '    function _getRevertMessage(bytes memory _res) internal pure returns (string memory) {\n', '        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n', '        if (_res.length < 68) return "Transaction reverted silently";\n', '        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n', '        return abi.decode(revertData, (string)); // All that remains is the revert string\n', '    }\n', '}\n', '\n', '// File: src/MetaTxGateway.sol\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// this is functionally identical to https://github.com/bcnmy/metatx-standard/blob/master/src/contracts/EIP712MetaTransaction.sol\n', '// except it implements openzeppelin Initializable\n', 'contract MetaTxGateway is PerpFiOwnableUpgrade, LowLevelErrorMessage {\n', '    using SafeMath for uint256;\n', '\n', '    //\n', '    // EVENTS\n', '    //\n', '    event MetaTransactionExecuted(address from, address to, address payable relayerAddress, bytes functionSignature);\n', '\n', '    //\n', '    // Struct and Enum\n', '    //\n', '    struct EIP712Domain {\n', '        string name;\n', '        string version;\n', '        uint256 chainId;\n', '        address verifyingContract;\n', '    }\n', '\n', '    /*\n', '     * Meta transaction structure.\n', '     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\n', '     * He should call the desired function directly in that case.\n', '     */\n', '    struct MetaTransaction {\n', '        uint256 nonce;\n', '        address from;\n', '        address to;\n', '        bytes functionSignature;\n', '    }\n', '\n', '    //\n', '    // Constant\n', '    //\n', '    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n', '        bytes("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)")\n', '    );\n', '\n', '    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\n', '        bytes("MetaTransaction(uint256 nonce,address from,address to,bytes functionSignature)")\n', '    );\n', '\n', '    //**********************************************************//\n', '    //    Can not change the order of below state variables     //\n', '    //**********************************************************//\n', '\n', '    bytes32 internal domainSeperatorL1;\n', '    bytes32 internal domainSeperatorL2;\n', '    mapping(address => uint256) private nonces;\n', '\n', '    // whitelist of contracts this gateway can execute\n', '    mapping(address => bool) private whitelistMap;\n', '\n', '    //**********************************************************//\n', '    //    Can not change the order of above state variables     //\n', '    //**********************************************************//\n', '\n', '    //◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤ add state variables below ◥◤◥◤◥◤◥◤◥◤◥◤◥◤◥◤//\n', '\n', '    //◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣ add state variables above ◢◣◢◣◢◣◢◣◢◣◢◣◢◣◢◣//\n', '    uint256[50] private __gap;\n', '\n', '    //\n', '    // FUNCTIONS\n', '    //\n', '    function initialize(\n', '        string memory _name,\n', '        string memory _version,\n', '        uint256 _chainIdL1\n', '    ) public initializer {\n', '        __Ownable_init();\n', '\n', '        domainSeperatorL1 = keccak256(\n', '            abi.encode(\n', '                EIP712_DOMAIN_TYPEHASH,\n', '                keccak256(bytes(_name)),\n', '                keccak256(bytes(_version)),\n', '                _chainIdL1,\n', '                address(this)\n', '            )\n', '        );\n', '\n', '        domainSeperatorL2 = keccak256(\n', '            abi.encode(\n', '                EIP712_DOMAIN_TYPEHASH,\n', '                keccak256(bytes(_name)),\n', '                keccak256(bytes(_version)),\n', '                getChainID(),\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice add an address to the whitelist. Only contracts in the whitelist can be executed by this gateway.\n', '     *         This prevents the gateway from being abused to execute arbitrary meta txs\n', '     * @dev only owner can call\n', '     * @param _addr an address\n', '     */\n', '    function addToWhitelists(address _addr) external onlyOwner {\n', '        whitelistMap[_addr] = true;\n', '    }\n', '\n', '    function removeFromWhitelists(address _addr) external onlyOwner {\n', '        delete whitelistMap[_addr];\n', '    }\n', '\n', '    function executeMetaTransaction(\n', '        address from,\n', '        address to,\n', '        bytes calldata functionSignature,\n', '        bytes32 sigR,\n', '        bytes32 sigS,\n', '        uint8 sigV\n', '    ) external returns (bytes memory) {\n', '        require(isInWhitelists(to), "!whitelisted");\n', '\n', '        MetaTransaction memory metaTx = MetaTransaction({\n', '            nonce: nonces[from],\n', '            from: from,\n', '            to: to,\n', '            functionSignature: functionSignature\n', '        });\n', '\n', '        require(\n', '            verify(from, domainSeperatorL1, metaTx, sigR, sigS, sigV) ||\n', '                verify(from, domainSeperatorL2, metaTx, sigR, sigS, sigV),\n', '            "Meta tx Signer and signature do not match"\n', '        );\n', '\n', '        nonces[from] = nonces[from].add(1);\n', '        // Append userAddress at the end to extract it from calling context\n', '        // solhint-disable avoid-low-level-calls\n', '        (bool success, bytes memory returnData) = address(to).call(abi.encodePacked(functionSignature, from));\n', '        require(success, _getRevertMessage(returnData));\n', '        emit MetaTransactionExecuted(from, to, msg.sender, functionSignature);\n', '        return returnData;\n', '    }\n', '\n', '    //\n', '    // VIEW FUNCTIONS\n', '    //\n', '\n', '    function getNonce(address user) external view returns (uint256 nonce) {\n', '        nonce = nonces[user];\n', '    }\n', '\n', '    //\n', '    // INTERNAL VIEW FUNCTIONS\n', '    //\n', '\n', '    function isInWhitelists(address _addr) public view returns (bool) {\n', '        return whitelistMap[_addr];\n', '    }\n', '\n', '    function getChainID() internal pure returns (uint256 id) {\n', '        assembly {\n', '            id := chainid()\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Accept message hash and returns hash message in EIP712 compatible form\n', '     * So that it can be used to recover signer from signature signed using EIP712 formatted data\n', '     * https://eips.ethereum.org/EIPS/eip-712\n', '     * "\\\\x19" makes the encoding deterministic\n', '     * "\\\\x01" is the version byte to make it compatible to EIP-191\n', '     */\n', '    function toTypedMessageHash(bytes32 domainSeperator, bytes32 messageHash) internal pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19\\x01", domainSeperator, messageHash));\n', '    }\n', '\n', '    function hashMetaTransaction(MetaTransaction memory metaTx) internal pure returns (bytes32) {\n', '        return\n', '            keccak256(\n', '                abi.encode(\n', '                    META_TRANSACTION_TYPEHASH,\n', '                    metaTx.nonce,\n', '                    metaTx.from,\n', '                    metaTx.to,\n', '                    keccak256(metaTx.functionSignature)\n', '                )\n', '            );\n', '    }\n', '\n', '    function verify(\n', '        address user,\n', '        bytes32 domainSeperator,\n', '        MetaTransaction memory metaTx,\n', '        bytes32 sigR,\n', '        bytes32 sigS,\n', '        uint8 sigV\n', '    ) internal pure returns (bool) {\n', '        address signer = ecrecover(toTypedMessageHash(domainSeperator, hashMetaTransaction(metaTx)), sigV, sigR, sigS);\n', '        require(signer != address(0), "invalid signature");\n', '        return signer == user;\n', '    }\n', '}']