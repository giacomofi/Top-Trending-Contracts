['"""\n', '@title Greenwood Store\n', '@notice Loan and asset storage contract for the Greenwood Protocol\n', '@author Greenwood Labs\n', '"""\n', '\n', '# define the interfaces used by the contract\n', 'interface REGISTRY:\n', '    def getAddress(_contract: String[20], _version: String[11], ) -> address: nonpayable\n', '    def governance() -> address: nonpayable\n', '\n', '# define the events used by the contract\n', 'event SetRegistry:\n', '    previousRegistry: address\n', '    newRegistry: address\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', '# define the structs used by the contract\n', 'struct AssetContext:\n', '    aToken: address\n', '    aaveV2PriceFeed: address\n', '    aaveV2LendingPool: address\n', '    cToken: address\n', '    compoundPriceFeed: address\n', '    comptroller: address\n', '    decimals: uint256\n', '    underlying: address\n', '\n', 'struct Loan:\n', '    collateralAsset: address\n', '    borrowAsset: address\n', '    outstanding: uint256\n', '    collateralizationRatio: uint256\n', '    collateralLocked: uint256\n', '    borrower: address\n', '    lastBorrowIndex: uint256\n', '    repaymentTime: uint256\n', '\n', '    \n', '# define the storage variables used by the contract\n', 'assetContexts: public(HashMap[String[10], AssetContext])\n', 'assetTickers: public(HashMap[String[10], address])\n', 'registry: public(address)\n', 'loans: public(HashMap[bytes32, Loan])\n', 'loanNumbers: public(HashMap[address, uint256])\n', 'loanProtocols: public(HashMap[bytes32, String[10]])\n', '\n', '@external\n', 'def __init__(_registry: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _registry The address of the Greenwood Registry\n', '    """\n', '\n', '    # set the address of the Escrow\n', '    self.registry = _registry\n', '\n', '@internal\n', 'def isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\n', '    """\n', '    @notice Method for role-based security\n', '    @param _caller The address that called the permissioned method\n', '    @param _role The requested authorization level\n', '    @param _version The version of Greenwood to use\n', '    @return True if the caller is authorized, False otherwise\n', '    """\n', '\n', '    # check if the requested role is "aaveV2Escrow"\n', '    if keccak256(_role) == keccak256("aaveV2Escrow"):\n', '\n', '        # get the address of the AaveV2Escrow from the Registry\n', '        aaveV2Escrow: address = REGISTRY(self.registry).getAddress("aaveV2Escrow", _version)\n', '\n', '        # return the equality comparison\n', '        return aaveV2Escrow == _caller\n', '    \n', '    # check if the requested role is "compoundEscrow"\n', '    elif keccak256(_role) == keccak256("compoundEscrow"):\n', '\n', '        # get the address of the CompoundEscrow from the Registry\n', '        compoundEscrow: address = REGISTRY(self.registry).getAddress("compoundEscrow", _version)\n', '\n', '        # return the equality comparison\n', '        return compoundEscrow == _caller\n', '\n', '    # check if the requested role is "governance"\n', '    elif keccak256(_role) == keccak256("governance"):\n', '\n', '        # get the address of the Governance from the Registry\n', '        governance: address = REGISTRY(self.registry).governance()\n', '\n', '        # return the equality comparison\n', '        return governance == _caller\n', '\n', '    # catch extraneous role arguments\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled role argument"\n', '\n', '@external\n', 'def setAssetContext(_ticker: String[10], _a_token: address, _aave_v2_price_feed: address, _aave_v2_lending_pool: address, _c_token: address, _compound_price_feed: address, _comptroller: address, _decimals: uint256, _underlying: address, _version: String[11]):\n', '    """\n', '    @notice Writes contextual information about an asset ticker to storage\n', '    @param _ticker The ticker string of that asset that the context applies to\n', '    @param _a_token The address of the Aave V2 aToken contract for the underlying asset\n', '    @param _aave_V2_price_feed The address of the Aave V2 price feed contract\n', '    @param _aave_v2_lending_pool The address of the Aave V2 LendingPool contract\n', '    @param _c_token The address of the Compound cToken contract for the underlying asset\n', '    @param _compound_price_feed The address of the Compound price feed contract\n', '    @param _comptroller The address of the Compound Comptroller contract\n', '    @param _decimals The decimals of the underlying asset\n', '    @param _underlying The address of the underlying asset\n', '    @param _version The version of the Greenwood Protocol to use\n', '    @dev Only the Governance can call this method\n', '    """\n', '   \n', '    # require that the method caller is the governance\n', '    assert self.isAuthorized(msg.sender, "governance", _version) == True, "Only Governance can call this method"\n', '\n', '    # check if the aToken address is the zero address\n', '    if _a_token != ZERO_ADDRESS:\n', '\n', '        # write the aToken address to storage\n', '        self.assetContexts[_ticker].aToken = _a_token\n', '\n', '    # check if the Aave V2 price feed address is the zero address\n', '    if _aave_v2_price_feed != ZERO_ADDRESS:\n', '\n', '        # write the Aave V2 price feed address to stroage\n', '        self.assetContexts[_ticker].aaveV2PriceFeed = _aave_v2_price_feed\n', '\n', '    # check if the Aave V2 LendingPool address is the zero address\n', '    if _aave_v2_lending_pool != ZERO_ADDRESS:\n', '\n', '        # write the Aave V2 LendingPool address to storage\n', '        self.assetContexts[_ticker].aaveV2LendingPool = _aave_v2_lending_pool\n', '\n', '    # check if the cToken address is the zero address\n', '    if _c_token != ZERO_ADDRESS:\n', '\n', '        # write the cToken address to storage\n', '        self.assetContexts[_ticker].cToken = _c_token\n', '\n', '    # check if the Compound price feed address is the zero address\n', '    if _compound_price_feed != ZERO_ADDRESS:\n', '\n', '        # write the Compound price feed address to storage\n', '        self.assetContexts[_ticker].compoundPriceFeed = _compound_price_feed\n', '\n', '    # check if the Comptroller address is the zero address\n', '    if _comptroller != ZERO_ADDRESS:\n', '\n', '        # write the Comptroller address to storage\n', '        self.assetContexts[_ticker].comptroller = _comptroller\n', '\n', '    # check if the asset decimals are zero\n', '    if _decimals != 0:\n', '\n', '        # write the asset decimals to stroage\n', '        self.assetContexts[_ticker].decimals = _decimals\n', '\n', '    # check if the underlying address is the zero address\n', '    if _underlying != ZERO_ADDRESS:\n', '\n', '        # write the underlying address to storage\n', '        self.assetContexts[_ticker].underlying = _underlying\n', '    \n', '@external\n', '@view\n', 'def getAssetContext(_ticker: String[10]) -> AssetContext:\n', '    """\n', '    @notice Gets contextual information about a given asset ticker from storage\n', '    @param _ticker The ticker string of that asset that the context applies to\n', '    @return AssetContext struct\n', '    """\n', '\n', '    # read the contextual data out of storage and return it\n', '    return AssetContext({\n', '        aToken: self.assetContexts[_ticker].aToken,\n', '        aaveV2PriceFeed: self.assetContexts[_ticker].aaveV2PriceFeed,\n', '        aaveV2LendingPool: self.assetContexts[_ticker].aaveV2LendingPool,\n', '        cToken: self.assetContexts[_ticker].cToken,\n', '        compoundPriceFeed: self.assetContexts[_ticker].compoundPriceFeed,\n', '        comptroller: self.assetContexts[_ticker].comptroller,\n', '        decimals: self.assetContexts[_ticker].decimals,\n', '        underlying: self.assetContexts[_ticker].underlying\n', '    })\n', '\n', '@external\n', 'def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]):\n', '    """\n', '    @notice Writes information about a loan to storage\n', '    @param _borrower The address of the borrower\n', '    @param _borrow_asset The address of the asset that is being borrowed\n', '    @param _collateral_asset The address of the asset that is being used as collateral\n', '    @param _collateralization_ratio The collateralization ratio for the loan\n', "    @param _collateral_locked The amount of collateral locked for the loan scaled by the collateral asset's decimals\n", '    @param _index The borrow index at origination\n', "    @param _principal The principal of the loan scaled by the borrow asset's decimals\n", '    @param _protocol The name of the underlying lending protocol for the loan\n', '    @param _version The version of the Greenwood Protocol to use\n', '    @dev Only the AaveV2Escrow, the CompoundEscrow or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by an Escrow or the Governance\n', '    assert self.isAuthorized(msg.sender, "aaveV2Escrow", _version) == True or self.isAuthorized(msg.sender, "compoundEscrow", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Escrow or Governance can call this method"\n', '\n', "    # create a unique lookup key by concatenating the borrower's address with their current loan number and hashing\n", '    loanKey: bytes32 = keccak256(concat(convert(_borrower, bytes32), convert(self.loanNumbers[_borrower], bytes32)))\n', '\n', '    # write the collateral asset to storage\n', '    self.loans[loanKey].collateralAsset = _collateral_asset\n', '\n', '    # write the borrow asset to storage\n', '    self.loans[loanKey].borrowAsset = _borrow_asset\n', '\n', '    # write the principal to storage as the outstanding loan balance\n', '    self.loans[loanKey].outstanding = _principal\n', '\n', '    # write the collateralization ratio to storage\n', '    self.loans[loanKey].collateralizationRatio = _collateralization_ratio\n', '\n', '    # write the collateral locked to storage\n', '    self.loans[loanKey].collateralLocked = _collateral_locked\n', '\n', "    # write the borrower's address to storage\n", '    self.loans[loanKey].borrower = _borrower\n', '\n', '    # write the borrow index to storage\n', '    self.loans[loanKey].lastBorrowIndex = _index\n', '\n', '    # write loan protocol to storage\n', '    self.loanProtocols[loanKey] = _protocol\n', '\n', "    # increment the borrower's loan number\n", '    self.loanNumbers[_borrower] += 1\n', '\n', '@external\n', 'def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]):\n', '    """\n', '    @notice Updates information about a loan in storage\n', "    @param _collateral_locked The amount of collateral locked for the loan scaled by the collateral asset's decimals\n", '    @param _index The borrow index at the time the method is called\n', '    @param _loan_key The uinque identifier for the loan\n', "    @param _outstanding The outstanding balance of the loan scaled by the borrow asset's decimals\n", '    @param _version The version of the Greenwood Protocol to use\n', '    @dev Only the AaveV2Escrow, the CompoundEscrow or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by an escrow or the governance\n', '    assert self.isAuthorized(msg.sender, "aaveV2Escrow", _version) == True or self.isAuthorized(msg.sender, "compoundEscrow", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Escrow or Governance can call this method"\n', '\n', '    # require that the loan key corresponds to an existing loan\n', '    assert self.loans[_loan_key].borrower != ZERO_ADDRESS, "No corresponding loan to update"\n', '\n', '    # update the outstanding balance of the loan\n', '    self.loans[_loan_key].outstanding = _outstanding\n', '\n', '    # update the collateral locked for the loan\n', '    self.loans[_loan_key].collateralLocked = _collateral_locked\n', '\n', '    # set the lastBorrowIndex of the loan if the _borrow_index argument is not 0\n', '    if _index != 0:\n', '        self.loans[_loan_key].lastBorrowIndex = _index\n', '\n', '    # set the repayment time of the loan if the _outstanding argument is 0\n', '    if _outstanding == 0:\n', '        self.loans[_loan_key].repaymentTime = block.timestamp\n', '\n', '@external\n', '@view\n', 'def getLoan(_loan_key: bytes32) -> Loan:\n', '    """\n', '    @notice Gets loan data from storage\n', '    @param _loan_key The uinque identifier for the loan\n', '    @return Loan struct\n', '    """\n', '\n', '    # read the loan data out of storage and return it\n', '    return Loan({\n', '        collateralAsset: self.loans[_loan_key].collateralAsset,\n', '        borrowAsset: self.loans[_loan_key].borrowAsset,\n', '        outstanding: self.loans[_loan_key].outstanding,\n', '        collateralizationRatio: self.loans[_loan_key].collateralizationRatio,\n', '        collateralLocked: self.loans[_loan_key].collateralLocked,\n', '        borrower: self.loans[_loan_key].borrower,\n', '        lastBorrowIndex: self.loans[_loan_key].lastBorrowIndex,\n', '        repaymentTime: self.loans[_loan_key].repaymentTime\n', '    })\n', '\n', '@external\n', '@view\n', 'def getLoanProtocol(_loan_key: bytes32) -> String[10]:\n', '    """\n', '    @notice Gets the name of the lending protocol of loan from storage\n', '    @param _loan_key The uinque identifier for the loan\n', '    @return String with a maximum length of 10\n', '    """\n', '\n', '    # read the loan protocol data out of storage and return it\n', '    return self.loanProtocols[_loan_key]\n', '\n', '@external\n', 'def setRegistry(_new_registry: address):\n', '    """\n', '    @notice Updates the address of the Registry\n', '    @param _new_registry The address of the new Greenwood Registry\n', '    @dev Only the Governance can call this method\n', '    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isAuthorized(msg.sender, "governance", "") == True, "Only Governance can call this method"\n', '\n', '    # get the previous Registry\n', '    previousRegistry: address = self.registry\n', '\n', '    # update the address of the Registry\n', '    self.registry = _new_registry\n', '\n', '    # emit a SetRegistry event\n', '    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)']