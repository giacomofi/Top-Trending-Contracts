['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-20\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '/**\n', ' * @title Artifex Smart Contract\n', ' * @author GigLabs, Brian Burns <[email\xa0protected]>\n', ' */\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(\n', '            address(this).balance >= amount,\n', '            "Address: insufficient balance"\n', '        );\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{value: amount}("");\n', '        require(\n', '            success,\n', '            "Address: unable to send value, recipient may have reverted"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data)\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value\n', '    ) internal returns (bytes memory) {\n', '        return\n', '            functionCallWithValue(\n', '                target,\n', '                data,\n', '                value,\n', '                "Address: low-level call with value failed"\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(\n', '        address target,\n', '        bytes memory data,\n', '        uint256 value,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(\n', '            address(this).balance >= value,\n', '            "Address: insufficient balance for call"\n', '        );\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) =\n', '            target.call{value: value}(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data)\n', '        internal\n', '        view\n', '        returns (bytes memory)\n', '    {\n', '        return\n', '            functionStaticCall(\n', '                target,\n', '                data,\n', '                "Address: low-level static call failed"\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data)\n', '        internal\n', '        returns (bytes memory)\n', '    {\n', '        return\n', '            functionDelegateCall(\n', '                target,\n', '                data,\n', '                "Address: low-level delegate call failed"\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(\n', '        address target,\n', '        bytes memory data,\n', '        string memory errorMessage\n', '    ) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(\n', '        bool success,\n', '        bytes memory returndata,\n', '        string memory errorMessage\n', '    ) private pure returns (bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev String operations.\n', ' */\n', 'library Strings {\n', '    bytes16 private constant alphabet = "0123456789abcdef";\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n', '     */\n', '    function toString(uint256 value) internal pure returns (string memory) {\n', "        // Inspired by OraclizeAPI's implementation - MIT licence\n", '        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n', '\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        while (value != 0) {\n', '            digits -= 1;\n', '            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n', '            value /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n', '     */\n', '    function toHexString(uint256 value) internal pure returns (string memory) {\n', '        if (value == 0) {\n', '            return "0x00";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 length = 0;\n', '        while (temp != 0) {\n', '            length++;\n', '            temp >>= 8;\n', '        }\n', '        return toHexString(value, length);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n', '     */\n', '    function toHexString(uint256 value, uint256 length)\n', '        internal\n', '        pure\n', '        returns (string memory)\n', '    {\n', '        bytes memory buffer = new bytes(2 * length + 2);\n', '        buffer[0] = "0";\n', '        buffer[1] = "x";\n', '        for (uint256 i = 2 * length + 1; i > 1; --i) {\n', '            buffer[i] = alphabet[value & 0xf];\n', '            value >>= 4;\n', '        }\n', '        require(value == 0, "Strings: hex length insufficient");\n', '        return string(buffer);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '    mapping(address => uint8) private _otherOperators;\n', '\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the operator state for an address. State\n', '     * of 1 means active operator of the contract. State of 0 means\n', '     * not an operator of the contract.\n', '     */\n', '    function otherOperator(address operatorAddress)\n', '        public\n', '        view\n', '        virtual\n', '        returns (uint8)\n', '    {\n', '        return _otherOperators[operatorAddress];\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than an operator.\n', '     */\n', '    modifier anyOperator() {\n', '        require(\n', '            owner() == _msgSender() || _otherOperators[msg.sender] == 1,\n', '            "Ownable: caller is not an operator"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(\n', '            newOwner != address(0),\n', '            "Ownable: new owner is the zero address"\n', '        );\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the state of other operators for performaing certain\n', '     * contract functions. Can only be called by the current owner.\n', '     */\n', '    function setOtherOperator(address _newOperator, uint8 _state)\n', '        public\n', '        virtual\n', '        onlyOwner\n', '    {\n', '        require(_newOperator != address(0));\n', '        _otherOperators[_newOperator] = _state;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(\n', '        address operator,\n', '        address from,\n', '        uint256 tokenId,\n', '        bytes calldata data\n', '    ) external returns (bytes4);\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(\n', '        address indexed from,\n', '        address indexed to,\n', '        uint256 indexed tokenId\n', '    );\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed approved,\n', '        uint256 indexed tokenId\n', '    );\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(\n', '        address indexed owner,\n', '        address indexed operator,\n', '        bool approved\n', '    );\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId)\n', '        external\n', '        view\n', '        returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator)\n', '        external\n', '        view\n', '        returns (bool);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n', ' * for the additional interface id that will be supported. For example:\n', ' *\n', ' * ```solidity\n', ' * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', ' *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n', ' * }\n', ' * ```\n', ' *\n', ' * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Metadata is IERC721 {\n', '    /**\n', '     * @dev Returns the token collection name.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the token collection symbol.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' */\n', 'interface IERC721Enumerable is IERC721 {\n', '    /**\n', '     * @dev Returns the total amount of tokens stored by the contract.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n', "     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n", '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index)\n', '        external\n', '        view\n', '        returns (uint256 tokenId);\n', '\n', '    /**\n', '     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n', '     * Use along with {totalSupply} to enumerate all tokens.\n', '     */\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n', ' * the Metadata extension, but not including the Enumerable extension, which is available separately as\n', ' * {ERC721Enumerable}.\n', ' */\n', 'contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n', '    using Address for address;\n', '    using Strings for uint256;\n', '\n', '    // Token name\n', '    string private _name;\n', '\n', '    // Token symbol\n', '    string private _symbol;\n', '\n', '    // Mapping from token ID to owner address\n', '    mapping(uint256 => address) private _owners;\n', '\n', '    // Mapping owner address to token count\n', '    mapping(address => uint256) private _balances;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping(uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping(address => mapping(address => bool)) private _operatorApprovals;\n', '\n', '    /**\n', '     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n', '     */\n', '    constructor(string memory name_, string memory symbol_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId)\n', '        public\n', '        view\n', '        virtual\n', '        override(ERC165, IERC165)\n', '        returns (bool)\n', '    {\n', '        return\n', '            interfaceId == type(IERC721).interfaceId ||\n', '            interfaceId == type(IERC721Metadata).interfaceId ||\n', '            super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-balanceOf}.\n', '     */\n', '    function balanceOf(address owner)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        require(\n', '            owner != address(0),\n', '            "ERC721: balance query for the zero address"\n', '        );\n', '        return _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-ownerOf}.\n', '     */\n', '    function ownerOf(uint256 tokenId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (address)\n', '    {\n', '        address owner = _owners[tokenId];\n', '        require(\n', '            owner != address(0),\n', '            "ERC721: owner query for nonexistent token"\n', '        );\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-name}.\n', '     */\n', '    function name() public view virtual override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-symbol}.\n', '     */\n', '    function symbol() public view virtual override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-tokenURI}.\n', '     */\n', '    function tokenURI(uint256 tokenId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (string memory)\n', '    {\n', '        require(\n', '            _exists(tokenId),\n', '            "ERC721Metadata: URI query for nonexistent token"\n', '        );\n', '\n', '        string memory baseURI = _baseURI();\n', '        return\n', '            bytes(baseURI).length > 0\n', '                ? string(abi.encodePacked(baseURI, tokenId.toString()))\n', '                : "";\n', '    }\n', '\n', '    /**\n', '     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n', '     * in child contracts.\n', '     */\n', '    function _baseURI() internal view virtual returns (string memory) {\n', '        return "";\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-approve}.\n', '     */\n', '    function approve(address to, uint256 tokenId) public virtual override {\n', '        address owner = ERC721.ownerOf(tokenId);\n', '        require(to != owner, "ERC721: approval to current owner");\n', '\n', '        require(\n', '            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n', '            "ERC721: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _approve(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-getApproved}.\n', '     */\n', '    function getApproved(uint256 tokenId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (address)\n', '    {\n', '        require(\n', '            _exists(tokenId),\n', '            "ERC721: approved query for nonexistent token"\n', '        );\n', '\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-setApprovalForAll}.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved)\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        require(operator != _msgSender(), "ERC721: approve to caller");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-isApprovedForAll}.\n', '     */\n', '    function isApprovedForAll(address owner, address operator)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-transferFrom}.\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) public virtual override {\n', '        //solhint-disable-next-line max-line-length\n', '        require(\n', '            _isApprovedOrOwner(_msgSender(), tokenId),\n', '            "ERC721: transfer caller is not owner nor approved"\n', '        );\n', '\n', '        _transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) public virtual override {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId,\n', '        bytes memory _data\n', '    ) public virtual override {\n', '        require(\n', '            _isApprovedOrOwner(_msgSender(), tokenId),\n', '            "ERC721: transfer caller is not owner nor approved"\n', '        );\n', '        _safeTransfer(from, to, tokenId, _data);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n', '     *\n', '     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n', '     * implement alternative mechanisms to perform token transfer, such as signature-based.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeTransfer(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId,\n', '        bytes memory _data\n', '    ) internal virtual {\n', '        _transfer(from, to, tokenId);\n', '        require(\n', '            _checkOnERC721Received(from, to, tokenId, _data),\n', '            "ERC721: transfer to non ERC721Receiver implementer"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `tokenId` exists.\n', '     *\n', '     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n', '     *\n', '     * Tokens start existing when they are minted (`_mint`),\n', '     * and stop existing when they are burned (`_burn`).\n', '     */\n', '    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n', '        return _owners[tokenId] != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId)\n', '        internal\n', '        view\n', '        virtual\n', '        returns (bool)\n', '    {\n', '        require(\n', '            _exists(tokenId),\n', '            "ERC721: operator query for nonexistent token"\n', '        );\n', '        address owner = ERC721.ownerOf(tokenId);\n', '        return (spender == owner ||\n', '            getApproved(tokenId) == spender ||\n', '            isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Safely mints `tokenId` and transfers it to `to`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must not exist.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeMint(address to, uint256 tokenId) internal virtual {\n', '        _safeMint(to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n', '     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n', '     */\n', '    function _safeMint(\n', '        address to,\n', '        uint256 tokenId,\n', '        bytes memory _data\n', '    ) internal virtual {\n', '        _mint(to, tokenId);\n', '        require(\n', '            _checkOnERC721Received(address(0), to, tokenId, _data),\n', '            "ERC721: transfer to non ERC721Receiver implementer"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Mints `tokenId` and transfers it to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must not exist.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal virtual {\n', '        require(to != address(0), "ERC721: mint to the zero address");\n', '        require(!_exists(tokenId), "ERC721: token already minted");\n', '\n', '        _beforeTokenTransfer(address(0), to, tokenId);\n', '\n', '        _balances[to] += 1;\n', '        _owners[tokenId] = to;\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `tokenId`.\n', '     * The approval is cleared when the token is burned.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _burn(uint256 tokenId) internal virtual {\n', '        address owner = ERC721.ownerOf(tokenId);\n', '\n', '        _beforeTokenTransfer(owner, address(0), tokenId);\n', '\n', '        // Clear approvals\n', '        _approve(address(0), tokenId);\n', '\n', '        _balances[owner] -= 1;\n', '        delete _owners[tokenId];\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` from `from` to `to`.\n', '     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) internal virtual {\n', '        require(\n', '            ERC721.ownerOf(tokenId) == from,\n', '            "ERC721: transfer of token that is not own"\n', '        );\n', '        require(to != address(0), "ERC721: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(from, to, tokenId);\n', '\n', '        // Clear approvals from the previous owner\n', '        _approve(address(0), tokenId);\n', '\n', '        _balances[from] -= 1;\n', '        _balances[to] += 1;\n', '        _owners[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve `to` to operate on `tokenId`\n', '     *\n', '     * Emits a {Approval} event.\n', '     */\n', '    function _approve(address to, uint256 tokenId) internal virtual {\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n', '     * The call is not executed if the target address is not a contract.\n', '     *\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId,\n', '        bytes memory _data\n', '    ) private returns (bool) {\n', '        if (to.isContract()) {\n', '            try\n', '                IERC721Receiver(to).onERC721Received(\n', '                    _msgSender(),\n', '                    from,\n', '                    tokenId,\n', '                    _data\n', '                )\n', '            returns (bytes4 retval) {\n', '                return retval == IERC721Receiver(to).onERC721Received.selector;\n', '            } catch (bytes memory reason) {\n', '                if (reason.length == 0) {\n', '                    revert(\n', '                        "ERC721: transfer to non ERC721Receiver implementer"\n', '                    );\n', '                } else {\n', '                    // solhint-disable-next-line no-inline-assembly\n', '                    assembly {\n', '                        revert(add(32, reason), mload(reason))\n', '                    }\n', '                }\n', '            }\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any token transfer. This includes minting\n', '     * and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n", '     * transferred to `to`.\n', '     * - When `from` is zero, `tokenId` will be minted for `to`.\n', "     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n", '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) internal virtual {}\n', '}\n', '\n', '/**\n', ' * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n', ' * enumerability of all the token ids in the contract as well as all token ids owned by each\n', ' * account.\n', ' */\n', 'abstract contract ERC721Enumerable is\n', '    Context,\n', '    ERC165,\n', '    ERC721,\n', '    IERC721Enumerable\n', '{\n', '    // Mapping from owner to list of owned token IDs\n', '    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n', '\n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '\n', '    // Array with all token ids, used for enumeration\n', '    uint256[] private _allTokens;\n', '\n', '    // Mapping from token id to position in the allTokens array\n', '    mapping(uint256 => uint256) private _allTokensIndex;\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId)\n', '        public\n', '        view\n', '        virtual\n', '        override(IERC165, ERC165, ERC721)\n', '        returns (bool)\n', '    {\n', '        return\n', '            interfaceId == type(IERC721Enumerable).interfaceId ||\n', '            super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n', '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        require(\n', '            index < ERC721.balanceOf(owner),\n', '            "ERC721Enumerable: owner index out of bounds"\n', '        );\n', '        return _ownedTokens[owner][index];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _allTokens.length;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-tokenByIndex}.\n', '     */\n', '    function tokenByIndex(uint256 index)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        require(\n', '            index < ERC721Enumerable.totalSupply(),\n', '            "ERC721Enumerable: global index out of bounds"\n', '        );\n', '        return _allTokens[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any token transfer. This includes minting\n', '     * and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n", '     * transferred to `to`.\n', '     * - When `from` is zero, `tokenId` will be minted for `to`.\n', "     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n", '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) internal virtual override {\n', '        super._beforeTokenTransfer(from, to, tokenId);\n', '\n', '        if (from == address(0)) {\n', '            _addTokenToAllTokensEnumeration(tokenId);\n', '        } else if (from != to) {\n', '            _removeTokenFromOwnerEnumeration(from, tokenId);\n', '        }\n', '        if (to == address(0)) {\n', '            _removeTokenFromAllTokensEnumeration(tokenId);\n', '        } else if (to != from) {\n', '            _addTokenToOwnerEnumeration(to, tokenId);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n", '     * @param to address representing the new owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '     */\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        uint256 length = ERC721.balanceOf(to);\n', '        _ownedTokens[to][length] = tokenId;\n', '        _ownedTokensIndex[tokenId] = length;\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's token tracking data structures.\n", '     * @param tokenId uint256 ID of the token to be added to the tokens list\n', '     */\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n", '     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n', '     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n', '     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '     */\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n', '        private\n', '    {\n', "        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n", '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '\n', '        // This also deletes the contents at the last position of the array\n', '        delete _ownedTokensIndex[tokenId];\n', '        delete _ownedTokens[from][lastTokenIndex];\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's token tracking data structures.\n", '     * This has O(1) time complexity, but alters the order of the _allTokens array.\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list\n', '     */\n', '    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n', '        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n', '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _allTokens.length - 1;\n', '        uint256 tokenIndex = _allTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n', '        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n', "        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n", '        uint256 lastTokenId = _allTokens[lastTokenIndex];\n', '\n', '        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '\n', '        // This also deletes the contents at the last position of the array\n', '        delete _allTokensIndex[tokenId];\n', '        _allTokens.pop();\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev The Artifex main contract.\n', ' *\n', ' * Each Artifex token implements full on-chain metadata\n', ' * in standard JSON format for anyone to retreive using the\n', ' * getMetadata() function in this contract. A mirrored copy of the\n', ' * metadata JSON is also stored on IPFS.\n', ' *\n', ' * Each NFT 2D image is stored on both IPFS and Arweave\n', ' * Each NFT 3D model is stored on both IPFS and Arweave\n', ' *\n', ' * The metadata on-chain in this contract (and mirrored on IPFS)\n', ' * return the hashes / locations of all NFT images and 3D model files\n', ' * stored on IPFS and Arweave.\n', ' *\n', ' * The metadata on-chain in this contract (and mirrored on IPFS)\n', ' * also return SHA256 hashes of the NFT images and 3D model files\n', ' * for verifying authenticity of the NFTs.\n', ' *\n', ' * Metadata is retreivable using the tokenURI() call as specified\n', " * in the ERC721-Metadata standard. tokenURI can't point to on-chain\n", ' * locations directly - it points to an off-chain URI for\n', ' * returning metadata.\n', ' */\n', 'contract Artifex is Ownable, ERC721Enumerable {\n', '    // NOTE: `SafeMath` is no longer needed starting with Solidity 0.8.\n', '    // The compiler now has built in overflow checking.\n', '    //\n', '    // using SafeMath for uint256;\n', '    using Address for address;\n', '    using Strings for uint256;\n', '\n', '    // Core series metadata\n', '    struct ArtistNFTSeriesInfo {\n', '        uint256 totalEditions;\n', '        string creatorName;\n', '        string artistName;\n', '        string artTitle;\n', '        string description;\n', '        string sha256ImageHash;\n', '        string ipfsImageHash;\n', '        string arweaveImageHash;\n', '        string imageFileType;\n', '    }\n', '\n', '    // Extended series metadata\n', '    struct ArtistNFTSeries3DModelInfo {\n', '        string sha256ModelHash;\n', '        string ipfs3DModelHash;\n', '        string arweave3DModelHash;\n', '        string modelFileType;\n', '    }\n', '\n', '    // Series ID => Core series metadata for NFT Type 1 (2D art piece)\n', '    mapping(uint256 => ArtistNFTSeriesInfo) private artist2DSeriesInfo;\n', '\n', '    // Series ID => Core series metadata for NFT Type 2 (3D art piece,\n', '    // in 2D format)\n', '    mapping(uint256 => ArtistNFTSeriesInfo) private artist3DSeriesInfo;\n', '\n', '    // Series ID => Extended series metadata for NFT Type 2 (3D model\n', '    // files for 3D art piece)\n', '    mapping(uint256 => ArtistNFTSeries3DModelInfo)\n', '        private artistSeries3DModelInfo;\n', '\n', '    // Series ID => series locked state\n', '    mapping(uint256 => bool) private artistSeriesLocked;\n', '\n', "    // Token ID => token's IPFS Metadata hash\n", '    mapping(uint256 => string) private tokenIdToIPFSMetadataHash;\n', '\n', '    // Base token URI used as a prefix for all tokens to build\n', '    // a full token URI string\n', '    string private _baseTokenURI;\n', '\n', '    // Base external token URI used as a prefix for all tokens\n', '    // to build a full external token URI string\n', '    string private _externalBaseTokenURI;\n', '\n', '    // Multipliers for token Id calculations\n', '    uint256 constant SERIES_MULTIPLIER = 100000000;\n', '    uint256 constant NFT_TYPE_MULTIPLIER = 10000;\n', '\n', '    /**\n', '     * @notice Event emitted when the takenBaseUri is set after\n', '     * contract deployment\n', '     * @param tokenBaseUri the base URI for tokenURI calls\n', '     */\n', '    event TokenBaseUriSet(string tokenBaseUri);\n', '\n', '    /**\n', '     * @notice Event emitted when the externalBaseUri is set after\n', '     * contract deployment.\n', '     * @param externalBaseUri the new external base URI\n', '     */\n', '    event ExternalBaseUriSet(string externalBaseUri);\n', '\n', '    /**\n', '     * @notice Event emitted when a series is locked/sealed\n', '     * @param seriesId the ID of the newly locked/sealed series\n', '     */\n', '    event SeriesLocked(uint256 seriesId);\n', '\n', '    /**\n', '     * @dev Constructor\n', '     * @param name the token name\n', '     * @param symbol the token symbol\n', '     * @param base_uri the base URI for location of off-chain metadata\n', '     * @param external_base_uri the base URI for viewing token on website\n', '     */\n', '    constructor(\n', '        string memory name,\n', '        string memory symbol,\n', '        string memory base_uri,\n', '        string memory external_base_uri\n', '    ) ERC721(name, symbol) {\n', '        _baseTokenURI = base_uri;\n', '        _externalBaseTokenURI = external_base_uri;\n', '    }\n', '\n', '    /**\n', '     * @notice Add core metadata for the 2D piece in an artist series.\n', '     * NOTE: For Artifex, there will only be 100 artist series IDs (1-100).\n', '     * Each series will have a 1 of 1 2D art piece (nftType 1) and a run\n', '     * of 100 3D art pieces (nftType 2). Series ID 0 will be a gift\n', '     * series and is not included in the 1-100 artist series IDs.\n', '     * @param seriesId the ID of the series (0-100)\n', '     * @param seriesInfo structure with series metadata\n', '     */\n', '    function addArtistSeries2dNftType(\n', '        uint256 seriesId,\n', '        ArtistNFTSeriesInfo calldata seriesInfo\n', '    ) external anyOperator {\n', '        // Series ID must be 0-100\n', '        require(seriesId <= 100);\n', '\n', '        // Once a series metadata is locked, it cannot be updated. The\n', '        // information will live as permanent metadata in the contract.\n', '        require(artistSeriesLocked[seriesId] == false, "Series is locked");\n', '\n', '        artist2DSeriesInfo[seriesId] = seriesInfo;\n', '    }\n', '\n', '    /**\n', '     * @notice Add core metadata for the 3D pieces in an artist series.\n', '     * NOTE: For Artifex, there will only be 100 artist series IDs (1-100).\n', '     * Each series will have a 1 of 1 2D art piece (nftType 1) and a run\n', '     * of 100 3D art pieces (nftType 2). Series ID 0 will be a gift\n', '     * series and is not included in the 1-100 artist series IDs.\n', '     * @param seriesId the ID of the series (0-100)\n', '     * @param seriesInfo structure with series metadata\n', '     * @param series3DModelInfo structure with series 3D model metadata\n', '     */\n', '    function addArtistSeries3dNftType(\n', '        uint256 seriesId,\n', '        ArtistNFTSeriesInfo calldata seriesInfo,\n', '        ArtistNFTSeries3DModelInfo calldata series3DModelInfo\n', '    ) external anyOperator {\n', '        // Series ID must be 0-100\n', '        require(seriesId <= 100);\n', '\n', '        // Once a series metadata is locked, it cannot be updated. The\n', '        // information will live as permanent metadata in the contract and\n', '        // on IFPS\n', '        require(artistSeriesLocked[seriesId] == false, "Series is locked");\n', '\n', '        artist3DSeriesInfo[seriesId] = seriesInfo;\n', '        artistSeries3DModelInfo[seriesId] = series3DModelInfo;\n', '    }\n', '\n', '    /**\n', '     * @dev Update the IPFS hash for a given token.\n', '     * Series metadata must NOT be locked yet (must still be within\n', '     * the series metadata update window)\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to set its URI\n', '     * @param ipfsHash string IPFS link to assign\n', '     */\n', '    function updateTokenIPFSMetadataHash(\n', '        uint256 tokenId,\n', '        string calldata ipfsHash\n', '    ) external anyOperator {\n', '        require(\n', '            artistSeriesLocked[getSeriesId(tokenId)] == false,\n', '            "Series is locked"\n', '        );\n', '        _setTokenIPFSMetadataHash(tokenId, ipfsHash);\n', '    }\n', '\n', '    /**\n', '     * @notice This function permanently locks metadata updates for all NFTs\n', '     * in a Series. For practical reasons, a short period of time is given\n', '     * for updates following a series mint. For example, maybe an artist\n', '     * notices incorrect info in the description of their art after it is\n', '     * minted. In most projects, metadata updates would be possible by changning\n', '     * the metadata on the web server hosting the metadata. However, for\n', '     * Artifex once metadata is locked, no updates to the metadata will be\n', '     * possible - the information is permanent and immutable.\n', '     *\n', '     * The metadata will be permanent on-chain here in the contract, retrievable\n', '     * as a JSON string via the getMetadata() call. A mirror of the metadata will\n', '     * also live permanently on IPFS at the location stored in the\n', '     * tokenIdToIPFSMetadataHash mapping in this contract.\n', '     *\n', '     * @param seriesId the ID of the series (0-100)\n', '     */\n', '    function lockSeries(uint256 seriesId) external anyOperator {\n', '        // Series ID must be 0-100\n', '        require(seriesId <= 100);\n', '\n', '        // Series must not have been previously locked\n', '        require(artistSeriesLocked[seriesId] == false, "Series is locked");\n', '\n', '        // Lock the series. Once a series information is set, it can no\n', '        // longer be updated. The information will live as permanent\n', '        // metadata in the contract.\n', '        artistSeriesLocked[seriesId] = true;\n', '\n', '        // Emit the event\n', '        emit SeriesLocked(seriesId);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets a new base token URI for accessing off-chain metadata\n', '     * location. If this is changed, an event gets emitted.\n', '     * @param newBaseTokenURI the new base token URI\n', '     */\n', '    function setBaseURI(string calldata newBaseTokenURI) external anyOperator {\n', '        _baseTokenURI = newBaseTokenURI;\n', '\n', '        // Emit the event\n', '        emit TokenBaseUriSet(newBaseTokenURI);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets a new base external URI for accessing the nft on a web site.\n', '     * If this is changed, an event gets emitted\n', '     * @param newExternalBaseTokenURI the new base external token URI\n', '     */\n', '    function setExternalBaseURI(string calldata newExternalBaseTokenURI)\n', '        external\n', '        anyOperator\n', '    {\n', '        _externalBaseTokenURI = newExternalBaseTokenURI;\n', '\n', '        // Emit the event\n', '        emit ExternalBaseUriSet(newExternalBaseTokenURI);\n', '    }\n', '\n', '    /**\n', '     * @dev Batch transfer of Artifex NFTs from one address to another\n', '     * @param _to The address of the recipient\n', '     * @param _tokenIds List of token IDs to transfer\n', '     */\n', '    function batchTransfer(address _to, uint256[] calldata _tokenIds) public {\n', '        require(_tokenIds.length > 0);\n', '\n', '        for (uint256 i = 0; i < _tokenIds.length; i++) {\n', '            safeTransferFrom(msg.sender, _to, _tokenIds[i], "");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Given a series ID, return the locked state\n', '     * @param seriesId the series ID\n', '     * @return true if series is locked, otherwise returns false\n', '     */\n', '    function isSeriesLocked(uint256 seriesId) external view returns (bool) {\n', '        return artistSeriesLocked[seriesId];\n', '    }\n', '\n', '    /**\n', '     * @notice return the base URI used for accessing off-chain metadata\n', '     * @return base URI for location of the off-chain metadata\n', '     */\n', '    function baseURI() external view returns (string memory) {\n', '        return _baseURI();\n', '    }\n', '\n', '    /**\n', '     * @notice return the base external URI used for accessing nft on a web site.\n', '     * @return base external URI\n', '     */\n', '    function externalBaseURI() external view returns (string memory) {\n', '        return _externalBaseTokenURI;\n', '    }\n', '\n', '    /**\n', '     * @notice Given a token ID, return whether or not it exists\n', '     * @param tokenId the token ID\n', '     * @return a bool which is true of the token exists\n', '     */\n', '    function exists(uint256 tokenId) external view returns (bool) {\n', '        return _exists(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @notice Given a token ID, return all on-chain metadata for the\n', '     * token as JSON string\n', '     *\n', '     * For each NFT, the following on-chain metadata is returned:\n', '     *    - Name: The title of the art piece (includes creator of the art piece)\n', '     *    - Descriptiom: Details about the art piece (includes the artist represented)\n', '     *    - Image URI: The off-chain URI location of the image\n', '     *    - External URI: Website to view the NFT\n', '     *    - SHA256 Image Hash: The actual image hash stored on-chain for anyone\n', '     *      to validate authenticity of their art piece\n', '     *    - IPFS Image Hash: IFPS storage hash of the image\n', '     *    - Arweave Image Hash: Arweave storage hash of the image\n', '     *    - Image File Type: File extension of the image, since file stores such\n', '     *      as IPFS may not return the image file type\n', '     *\n', '     *    IF 3D MODEL INFO AVAILABLE, THEN INCLUDE THIS IN METADATA\n', '     *    - SHA256 3D Model Hash: The actual 3D Model hash stored\n', '     *      on-chain for anyone to validate authenticity of their\n', '     *       3D model asset\n', '     *    - IPFS 3D Model Hash: IFPS storage hash of the 3D model\n', '     *    - Arweave Image Hash: Arweave storage hash of the 3D model\n', '     *    - 3D Model File Type: File extension of the 3D model\n', '     *\n', '     *    ATTRIBUTES INCLUDED:\n', '     *    - Creator name: The creator of the art piece\n', '     *    - Artist name: The artist represented / honored by the creator\n', '     *    - Edition Number: The edition number of the NFT\n', '     *    - Total Editions: Total editions that can ever exist in the series\n', '     *\n', '     * @param tokenId the token ID\n', '     * @return metadata a JSON string of the metadata\n', '     */\n', '    function getMetadata(uint256 tokenId)\n', '        external\n', '        view\n', '        returns (string memory metadata)\n', '    {\n', '        require(_exists(tokenId), "Token does not exist");\n', '\n', '        uint256 seriesId = getSeriesId(tokenId);\n', '        uint256 nftType = getNftType(tokenId);\n', '        uint256 editionNum = getNftNum(tokenId);\n', '\n', '        string memory creatorName;\n', '        ArtistNFTSeriesInfo memory seriesInfo;\n', '        ArtistNFTSeries3DModelInfo memory series3DModelInfo;\n', '        if (nftType == 1) {\n', '            seriesInfo = artist2DSeriesInfo[seriesId];\n', '            creatorName = seriesInfo.artistName;\n', '        } else if (nftType == 2) {\n', '            seriesInfo = artist3DSeriesInfo[seriesId];\n', '            creatorName = seriesInfo.creatorName;\n', '            series3DModelInfo = artistSeries3DModelInfo[seriesId];\n', '        }\n', '\n', '        // Name\n', '        metadata = string(\n', '            abi.encodePacked(\'{\\n  "name": "\', seriesInfo.artistName)\n', '        );\n', '        metadata = string(abi.encodePacked(metadata, " Artifex #"));\n', '        metadata = string(abi.encodePacked(metadata, editionNum.toString()));\n', '        metadata = string(abi.encodePacked(metadata, " of "));\n', '        metadata = string(\n', '            abi.encodePacked(metadata, seriesInfo.totalEditions.toString())\n', '        );\n', '        metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '        // Description: Generation\n', '        metadata = string(abi.encodePacked(metadata, \'  "description": "\'));\n', '        metadata = string(abi.encodePacked(metadata, seriesInfo.description));\n', '        metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '        // Image URI\n', '        metadata = string(abi.encodePacked(metadata, \'  "image": "\'));\n', '        metadata = string(abi.encodePacked(metadata, _baseTokenURI));\n', '        metadata = string(abi.encodePacked(metadata, seriesInfo.ipfsImageHash));\n', '        metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '        // External URI\n', '        metadata = string(abi.encodePacked(metadata, \'  "external_url": "\'));\n', '        metadata = string(abi.encodePacked(metadata, externalURI(tokenId)));\n', '        metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '        // SHA256 Image Hash\n', '        metadata = string(\n', '            abi.encodePacked(metadata, \'  "sha256_image_hash": "\')\n', '        );\n', '        metadata = string(\n', '            abi.encodePacked(metadata, seriesInfo.sha256ImageHash)\n', '        );\n', '        metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '        // IPFS Image Hash\n', '        metadata = string(abi.encodePacked(metadata, \'  "ipfs_image_hash": "\'));\n', '        metadata = string(abi.encodePacked(metadata, seriesInfo.ipfsImageHash));\n', '        metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '        // Arweave Image Hash\n', '        metadata = string(\n', '            abi.encodePacked(metadata, \'  "arweave_image_hash": "\')\n', '        );\n', '        metadata = string(\n', '            abi.encodePacked(metadata, seriesInfo.arweaveImageHash)\n', '        );\n', '        metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '        // Image file type\n', '        metadata = string(abi.encodePacked(metadata, \'  "image_file_type": "\'));\n', '        metadata = string(abi.encodePacked(metadata, seriesInfo.imageFileType));\n', '        metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '        // Optional 3D Model metadata\n', '        if (nftType == 2) {\n', '            // SHA256 3D Model Hash\n', '            metadata = string(\n', '                abi.encodePacked(metadata, \'  "sha256_3d_model_hash": "\')\n', '            );\n', '            metadata = string(\n', '                abi.encodePacked(metadata, series3DModelInfo.sha256ModelHash)\n', '            );\n', '            metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '            // IPFS 3D Model Hash\n', '            metadata = string(\n', '                abi.encodePacked(metadata, \'  "ipfs_3d_model_hash": "\')\n', '            );\n', '            metadata = string(\n', '                abi.encodePacked(metadata, series3DModelInfo.ipfs3DModelHash)\n', '            );\n', '            metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '            // Arweave 3D Model Hash\n', '            metadata = string(\n', '                abi.encodePacked(metadata, \'  "arweave_3d_model_hash": "\')\n', '            );\n', '            metadata = string(\n', '                abi.encodePacked(metadata, series3DModelInfo.arweave3DModelHash)\n', '            );\n', '            metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '\n', '            // 3D model file type\n', '            metadata = string(\n', '                abi.encodePacked(metadata, \'  "model_file_type": "\')\n', '            );\n', '            metadata = string(\n', '                abi.encodePacked(metadata, series3DModelInfo.modelFileType)\n', '            );\n', '            metadata = string(abi.encodePacked(metadata, \'",\\n\'));\n', '        }\n', '\n', '        // Atributes section\n', '\n', '        // Artist Name\n', '        metadata = string(\n', '            abi.encodePacked(\n', '                metadata,\n', '                \'  "attributes": [\\n     {"trait_type": "Artist", "value": "\'\n', '            )\n', '        );\n', '        metadata = string(abi.encodePacked(metadata, seriesInfo.artistName));\n', '        metadata = string(abi.encodePacked(metadata, \'"},\\n\'));\n', '\n', '        // Creator Name\n', '        metadata = string(\n', '            abi.encodePacked(\n', '                metadata,\n', '                \'     {"trait_type": "Creator", "value": "\'\n', '            )\n', '        );\n', '        metadata = string(abi.encodePacked(metadata, creatorName));\n', '        metadata = string(abi.encodePacked(metadata, \'"},\\n\'));\n', '\n', '        // Edition Number\n', '        metadata = string(\n', '            abi.encodePacked(\n', '                metadata,\n', '                \'     {"trait_type": "Edition", "value": \'\n', '            )\n', '        );\n', '        metadata = string(abi.encodePacked(metadata, editionNum.toString()));\n', '        metadata = string(abi.encodePacked(metadata, ","));\n', '\n', '        // Total Editions\n', '        metadata = string(abi.encodePacked(metadata, \' "max_value": \'));\n', '        metadata = string(\n', '            abi.encodePacked(metadata, seriesInfo.totalEditions.toString())\n', '        );\n', '        metadata = string(abi.encodePacked(metadata, ","));\n', '        metadata = string(\n', '            abi.encodePacked(metadata, \' "display_type": "number"}\\n ]\')\n', '        );\n', '\n', '        // Finish JSON object\n', '        metadata = string(abi.encodePacked(metadata, "\\n}"));\n', '    }\n', '\n', '    /**\n', '     * @notice Mints an Artifex NFT\n', '     * @param to address of the recipient\n', '     * @param seriesId series to mint\n', '     * @param nftType the type of nft - 1 for 2D piece, 2 for 3D piece\n', '     * @param nftNum the edition number of the nft\n', "     * @param ipfsHash the ipfsHash of a copy of the token's Metadata on ipfs\n", '     */\n', '    function mintArtifexNft(\n', '        address to,\n', '        uint256 seriesId,\n', '        uint256 nftType,\n', '        uint256 nftNum,\n', '        string memory ipfsHash\n', '    ) public anyOperator {\n', '        // Ensure the series is not locked yet. No more minting can\n', '        // happen once the series is locked\n', '        require(artistSeriesLocked[seriesId] == false, "Series is locked");\n', '        // Series 0 is a gift series. Only enforce edition limits\n', '        // for artist Series > 0.\n', '        if (seriesId > 0) {\n', '            if (nftType == 1) {\n', '                require(nftNum == 1, "Edition must be 1");\n', '            } else if (nftType == 2) {\n', '                require(nftNum <= 100, "Edition must be <= 100");\n', '            }\n', '        }\n', '        uint256 tokenId = encodeTokenId(seriesId, nftType, nftNum);\n', '        _safeMint(to, tokenId);\n', '        _setTokenIPFSMetadataHash(tokenId, ipfsHash);\n', '    }\n', '\n', '    /**\n', '     * @notice Mints multiple Artifex NFTs for same series and nftType\n', '     * @param to address of the recipient\n', '     * @param seriesId series to mint\n', '     * @param nftType the type of nft - 1 for 2D piece, 2 for 3D piece\n', '     * @param nftStartingNum the starting edition number of the nft\n', '     * @param numTokens the number of tokens to mint in the edition,\n', '     * starting from nftStartingNum edition number\n', "     * @param ipfsHashes an array of ipfsHashes of each token's Metadata on ipfs\n", '     */\n', '    function batchMintArtifexNft(\n', '        address to,\n', '        uint256 seriesId,\n', '        uint256 nftType,\n', '        uint256 nftStartingNum,\n', '        uint256 numTokens,\n', '        string[] memory ipfsHashes\n', '    ) public anyOperator {\n', '        require(\n', '            numTokens == ipfsHashes.length,\n', '            "numTokens and num ipfsHashes must match"\n', '        );\n', '        for (uint256 i = 0; i < numTokens; i++) {\n', '            mintArtifexNft(\n', '                to,\n', '                seriesId,\n', '                nftType,\n', '                nftStartingNum + i,\n', '                ipfsHashes[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Given a token ID, return the series ID of the token\n', '     * @param tokenId the token ID\n', '     * @return the series ID of the token\n', '     */\n', '    function getSeriesId(uint256 tokenId) public pure returns (uint256) {\n', '        return (uint256(tokenId / SERIES_MULTIPLIER));\n', '    }\n', '\n', '    /**\n', '     * @notice Given a token ID, return the nft type of the token\n', '     * @param tokenId the token ID\n', '     * @return the nft type of the token\n', '     */\n', '    function getNftType(uint256 tokenId) public pure returns (uint256) {\n', '        uint256 seriesId = getSeriesId(tokenId);\n', '        return\n', '            uint256(\n', '                (tokenId - (SERIES_MULTIPLIER * seriesId)) / NFT_TYPE_MULTIPLIER\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @notice Given a token ID, return the nft edition number of the token\n', '     * @param tokenId the token ID\n', '     * @return the nft edition number of the token\n', '     */\n', '    function getNftNum(uint256 tokenId) public pure returns (uint256) {\n', '        uint256 seriesId = getSeriesId(tokenId);\n', '        uint256 nftType = getNftType(tokenId);\n', '        return\n', '            uint256(\n', '                tokenId -\n', '                    (SERIES_MULTIPLIER * seriesId) -\n', '                    (nftType * NFT_TYPE_MULTIPLIER)\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @notice Generate a tokenId given the series ID, nft type,\n', '     * and nft edition number\n', '     * @param seriesId series to mint\n', '     * @param nftType the type of nft - 1 for 2D piece, 2 for 3D piece\n', '     * @param nftNum the edition number of the nft\n', '     * @return the token ID\n', '     */\n', '    function encodeTokenId(\n', '        uint256 seriesId,\n', '        uint256 nftType,\n', '        uint256 nftNum\n', '    ) public pure returns (uint256) {\n', '        return ((seriesId * SERIES_MULTIPLIER) +\n', '            (nftType * NFT_TYPE_MULTIPLIER) +\n', '            nftNum);\n', '    }\n', '\n', '    /**\n', '     * @notice Given a token ID, return the name of the artist name\n', '     * for the token\n', '     * @param tokenId the token ID\n', '     * @return artistName the name of the artist\n', '     */\n', '    function getArtistNameByTokenId(uint256 tokenId)\n', '        public\n', '        view\n', '        returns (string memory artistName)\n', '    {\n', '        require(_exists(tokenId), "Token does not exist");\n', '        if (getNftType(tokenId) == 1) {\n', '            artistName = artist2DSeriesInfo[getSeriesId(tokenId)].artistName;\n', '        } else if (getNftType(tokenId) == 2) {\n', '            artistName = artist3DSeriesInfo[getSeriesId(tokenId)].artistName;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Given a series ID and nft type, return information about the series\n', '     * @param seriesId series to mint\n', '     * @param nftType the type of nft - 1 for 2D piece, 2 for 3D piece\n', '     * @return seriesInfo structure with series information\n', '     */\n', '    function getSeriesInfo(uint256 seriesId, uint256 nftType)\n', '        public\n', '        view\n', '        returns (\n', '            ArtistNFTSeriesInfo memory seriesInfo,\n', '            ArtistNFTSeries3DModelInfo memory series3dModelInfo\n', '        )\n', '    {\n', '        if (nftType == 1) {\n', '            seriesInfo = artist2DSeriesInfo[seriesId];\n', '        } else if (nftType == 2) {\n', '            seriesInfo = artist3DSeriesInfo[seriesId];\n', '            series3dModelInfo = artistSeries3DModelInfo[seriesId];\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Given a token ID, return information about the series\n', '     * @param tokenId the token ID\n', '     * @return seriesInfo structure with series information\n', '     */\n', '    function getSeriesInfoByTokenId(uint256 tokenId)\n', '        public\n', '        view\n', '        returns (\n', '            ArtistNFTSeriesInfo memory seriesInfo,\n', '            ArtistNFTSeries3DModelInfo memory series3dModelInfo\n', '        )\n', '    {\n', '        require(_exists(tokenId), "Token does not exist");\n', '        (seriesInfo, series3dModelInfo) = getSeriesInfo(\n', '            getSeriesId(tokenId),\n', '            getNftType(tokenId)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an URI for a given token ID.\n', '     * See {IERC721Metadata-tokenURI}.\n', '     * @param tokenId uint256 ID of the token to query\n', '     * @return URI for location of the off-chain metadata\n', '     */\n', '    function tokenURI(uint256 tokenId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (string memory)\n', '    {\n', '        require(\n', '            _exists(tokenId),\n', '            "ERC721Metadata: URI query for nonexistent token"\n', '        );\n', '\n', '        return\n', '            bytes(_baseTokenURI).length > 0\n', '                ? string(\n', '                    abi.encodePacked(\n', '                        _baseTokenURI,\n', '                        tokenIdToIPFSMetadataHash[tokenId]\n', '                    )\n', '                )\n', '                : "";\n', '    }\n', '\n', '    /**\n', "     * @dev Returns the actual CID hash pointing to the token's metadata on IPFS.\n", '     * @param tokenId token ID of the token to query\n', '     * @return the ipfs hash of the metadata\n', '     */\n', '    function tokenIPFSMetadataHash(uint256 tokenId)\n', '        public\n', '        view\n', '        returns (string memory)\n', '    {\n', '        return tokenIdToIPFSMetadataHash[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @notice Given a token ID, return the external URI for viewing the nft on a\n', '     * web site.\n', '     * @param tokenId the token ID\n', '     * @return external URI\n', '     */\n', '    function externalURI(uint256 tokenId) public view returns (string memory) {\n', '        return\n', '            string(abi.encodePacked(_externalBaseTokenURI, tokenId.toString()));\n', '    }\n', '\n', '    /**\n', '     * @notice return the base URI used for accessing off-chain metadata\n', '     * @return base URI for location of the off-chain metadata\n', '     */\n', '    function _baseURI() internal view virtual override returns (string memory) {\n', '        return _baseTokenURI;\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to set the token IPFS hash for a given token.\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to set its URI\n', '     * @param ipfs_hash string IPFS link to assign\n', '     */\n', '    function _setTokenIPFSMetadataHash(uint256 tokenId, string memory ipfs_hash)\n', '        private\n', '    {\n', '        require(\n', '            _exists(tokenId),\n', '            "ERC721Metadata: URI set of nonexistent token"\n', '        );\n', '        tokenIdToIPFSMetadataHash[tokenId] = ipfs_hash;\n', '    }\n', '}']