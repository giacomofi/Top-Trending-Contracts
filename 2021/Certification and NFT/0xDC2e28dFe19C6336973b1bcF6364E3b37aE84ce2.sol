['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-10\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'contract Swap {\n', '    address private constant CONST_BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\n', '    \n', '    address public OWNER;\n', '    address public NEW_TOKEN_ADDRESS;\n', '    address[] public OLD_TOKEN_ADDRESS;\n', '    uint256[] public CONVERSION_RATE_PER_MILLE;\n', '    \n', '    event TokenSwapped (address requestor, address inputToken, uint256 inputQuantity, uint256 outputQuantity);\n', '    \n', '    constructor (address owner, address newTokenAddress, address[] memory oldTokenAddress, uint256[] memory conversionRatePerMille) public {\n', '        OWNER = owner;\n', '        NEW_TOKEN_ADDRESS = newTokenAddress;\n', '        OLD_TOKEN_ADDRESS = oldTokenAddress;\n', '        CONVERSION_RATE_PER_MILLE = conversionRatePerMille;\n', '    }\n', '\n', '    function checkResult (uint256 oldTokenIndex, uint256 inputQuantity) public view returns (uint256) {\n', '        uint256 conversionRate = CONVERSION_RATE_PER_MILLE[oldTokenIndex];\n', '        return (conversionRate * inputQuantity) / 1000;\n', '    }\n', '\n', '    function doSwap (uint256 oldTokenIndex, uint256 inputQuantity) public {\n', '        require(inputQuantity > 0, "Invalid input quantity");\n', '        require(oldTokenIndex < OLD_TOKEN_ADDRESS.length, "Out of index");\n', '        \n', '        IERC20 oldTokenObj = IERC20(OLD_TOKEN_ADDRESS[oldTokenIndex]);\n', '        IERC20 newTokenObj = IERC20(NEW_TOKEN_ADDRESS);\n', '        \n', '        uint256 outputQuantity = checkResult(oldTokenIndex, inputQuantity);\n', '        require(newTokenObj.balanceOf(address(this)) >= outputQuantity, "New token isnt ready");\n', '\n', '        uint256 balanceBefore = oldTokenObj.balanceOf(CONST_BURN_ADDRESS);\n', '        oldTokenObj.transferFrom(msg.sender, CONST_BURN_ADDRESS, inputQuantity);\n', '        uint256 balanceAfter = oldTokenObj.balanceOf(CONST_BURN_ADDRESS);\n', '        require(balanceBefore + inputQuantity == balanceAfter, "Old token isnt arrived");\n', '        \n', '        newTokenObj.transfer(msg.sender, outputQuantity);\n', '        emit TokenSwapped (msg.sender, OLD_TOKEN_ADDRESS[oldTokenIndex], inputQuantity, outputQuantity);\n', '    }\n', '    \n', '    function drawToken (address token, uint256 quantity, address to) public {\n', '        require (msg.sender == OWNER, "Only Owner can do");\n', '        \n', '        IERC20 tokenObj = IERC20(token);\n', '        require (tokenObj.balanceOf(address(this)) >= quantity, "Balance insufficient");\n', '        \n', '        tokenObj.transfer(to, quantity);\n', '    }\n', '}']