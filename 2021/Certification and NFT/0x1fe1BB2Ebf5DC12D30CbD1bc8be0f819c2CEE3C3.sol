['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.9;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "SafeMath.sol";\n', 'import "Ownable.sol";\n', 'import "Initializable.sol";\n', 'import "IIdeaToken.sol";\n', 'import "IIdeaTokenFactory.sol";\n', 'import "IInterestManager.sol";\n', 'import "IIdeaTokenExchange.sol";\n', '\n', '/**\n', ' * @title IdeaTokenExchange\n', ' * @author Alexander Schlindwein\n', ' *\n', ' * Exchanges Dai <-> IdeaTokens using a bonding curve. Sits behind a proxy\n', ' */\n', 'contract IdeaTokenExchange is IIdeaTokenExchange, Initializable, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // Stored for every IdeaToken and market.\n', '    // Keeps track of the amount of invested dai in this token, and the amount of investment tokens (e.g. cDai).\n', '    struct ExchangeInfo {\n', '        // The amount of Dai collected by trading\n', '        uint dai;\n', '        // The amount of "investment tokens", e.g. cDai\n', '        uint invested; \n', '    }\n', '\n', '    uint constant FEE_SCALE = 10000;\n', '\n', '    // The address authorized to set token and platform owners.\n', '    // It is only allowed to change these when the current owner is not set (zero address).\n', '    // Using such an address allows an external program to make authorization calls without having to go through the timelock.\n', '    address _authorizer;\n', '\n', '    // The amount of "investment tokens" for the collected trading fee, e.g. cDai \n', '    uint _tradingFeeInvested; \n', '    // The address which receives the trading fee when withdrawTradingFee is called\n', '    address _tradingFeeRecipient;\n', '\n', '    // marketID => owner. The owner of a platform.\n', '    // This address is allowed to withdraw platform fee.\n', '    // When allInterestToPlatform=true then this address can also withdraw the platform interest\n', '    mapping(uint => address) _platformOwner;\n', '\n', '    // marketID => amount. The amount of "investment tokens" for the collected platform fee, e.g. cDai\n', '    mapping(uint => uint) _platformFeeInvested;\n', '    \n', '\n', '    // marketID => ExchangeInfo. Stores ExchangeInfo structs for platforms\n', '    mapping(uint => ExchangeInfo) _platformsExchangeInfo;\n', '\n', '    // IdeaToken address => owner. The owner of an IdeaToken.\n', '    // This address is allowed to withdraw the interest for an IdeaToken\n', '    mapping(address => address) _tokenOwner;\n', '    // IdeaToken address => ExchangeInfo. Stores ExchangeInfo structs for IdeaTokens\n', '    mapping(address => ExchangeInfo) _tokensExchangeInfo;\n', '\n', '    // IdeaTokenFactory contract\n', '    IIdeaTokenFactory _ideaTokenFactory;\n', '    // InterestManager contract\n', '    IInterestManager _interestManager;\n', '    // Dai contract\n', '    IERC20 _dai;\n', '\n', '    // IdeaToken address => bool. Whether or not to disable all fee collection for a specific IdeaToken.\n', '    mapping(address => bool) _tokenFeeKillswitch;\n', '\n', '    event NewTokenOwner(address ideaToken, address owner);\n', '    event NewPlatformOwner(uint marketID, address owner);\n', '\n', '    event InvestedState(uint marketID, address ideaToken, uint dai, uint daiInvested, uint tradingFeeInvested, uint platformFeeInvested, uint volume);\n', '    \n', '    event PlatformInterestRedeemed(uint marketID, uint investmentToken, uint daiRedeemed);\n', '    event TokenInterestRedeemed(address ideaToken, uint investmentToken, uint daiRedeemed);\n', '    event TradingFeeRedeemed(uint daiRedeemed);\n', '    event PlatformFeeRedeemed(uint marketID, uint daiRedeemed);\n', '    \n', '    /**\n', '     * Initializes the contract\n', '     *\n', '     * @param owner The owner of the contract\n', '     * @param tradingFeeRecipient The address of the recipient of the trading fee\n', '     * @param interestManager The address of the InterestManager\n', '     * @param dai The address of Dai\n', '     */\n', '    function initialize(address owner,\n', '                        address authorizer,\n', '                        address tradingFeeRecipient,\n', '                        address interestManager,\n', '                        address dai) external initializer {\n', '        require(authorizer != address(0) &&\n', '                tradingFeeRecipient != address(0) &&\n', '                interestManager != address(0) &&\n', '                dai != address(0),\n', '                "invalid-params");\n', '\n', '        setOwnerInternal(owner); // Checks owner to be non-zero\n', '        _authorizer = authorizer;\n', '        _tradingFeeRecipient = tradingFeeRecipient;\n', '        _interestManager = IInterestManager(interestManager);\n', '        _dai = IERC20(dai);\n', '    }\n', '\n', '    /**\n', '     * Burns IdeaTokens in exchange for Dai\n', '     *\n', '     * @param ideaToken The IdeaToken to sell\n', '     * @param amount The amount of IdeaTokens to sell\n', '     * @param minPrice The minimum allowed price in Dai for selling `amount` IdeaTokens\n', '     * @param recipient The recipient of the redeemed Dai\n', '     */\n', '    function sellTokens(address ideaToken, uint amount, uint minPrice, address recipient) external override {\n', '\n', '        MarketDetails memory marketDetails = _ideaTokenFactory.getMarketDetailsByTokenAddress(ideaToken);\n', '        require(marketDetails.exists, "token-not-exist");\n', '        uint marketID = marketDetails.id;\n', '\n', '        CostAndPriceAmounts memory amounts = getPricesForSellingTokens(marketDetails, IERC20(ideaToken).totalSupply(), amount, _tokenFeeKillswitch[ideaToken]);\n', '\n', '        require(amounts.total >= minPrice, "below-min-price");\n', '        require(IIdeaToken(ideaToken).balanceOf(msg.sender) >= amount, "insufficient-tokens");\n', '        \n', '        IIdeaToken(ideaToken).burn(msg.sender, amount);\n', '\n', '        _interestManager.accrueInterest();\n', '\n', '        ExchangeInfo storage exchangeInfo;\n', '        if(marketDetails.allInterestToPlatform) {\n', '            exchangeInfo = _platformsExchangeInfo[marketID];\n', '        } else {\n', '            exchangeInfo = _tokensExchangeInfo[ideaToken];\n', '        }\n', '\n', '        uint tradingFeeInvested;\n', '        uint platformFeeInvested;\n', '        uint invested;\n', '        uint dai;\n', '        {\n', '        uint totalRedeemed = _interestManager.redeem(address(this), amounts.total);\n', '        uint tradingFeeRedeemed = _interestManager.underlyingToInvestmentToken(amounts.tradingFee);\n', '        uint platformFeeRedeemed = _interestManager.underlyingToInvestmentToken(amounts.platformFee);\n', '\n', '        invested = exchangeInfo.invested.sub(totalRedeemed.add(tradingFeeRedeemed).add(platformFeeRedeemed));\n', '        exchangeInfo.invested = invested;\n', '        tradingFeeInvested = _tradingFeeInvested.add(tradingFeeRedeemed);\n', '        _tradingFeeInvested = tradingFeeInvested;\n', '        platformFeeInvested = _platformFeeInvested[marketID].add(platformFeeRedeemed);\n', '        _platformFeeInvested[marketID] = platformFeeInvested;\n', '        dai = exchangeInfo.dai.sub(amounts.raw);\n', '        exchangeInfo.dai = dai;\n', '        }\n', '\n', '        emit InvestedState(marketID, ideaToken, dai, invested, tradingFeeInvested, platformFeeInvested, amounts.raw);\n', '        require(_dai.transfer(recipient, amounts.total), "dai-transfer");\n', '    }\n', '\n', '\n', '    /**\n', '     * Returns the price for selling IdeaTokens\n', '     *\n', '     * @param ideaToken The IdeaToken to sell\n', '     * @param amount The amount of IdeaTokens to sell\n', '     *\n', '     * @return The price in Dai for selling `amount` IdeaTokens\n', '     */\n', '    function getPriceForSellingTokens(address ideaToken, uint amount) external view override returns (uint) {\n', '        MarketDetails memory marketDetails = _ideaTokenFactory.getMarketDetailsByTokenAddress(ideaToken);\n', '        return getPricesForSellingTokens(marketDetails, IERC20(ideaToken).totalSupply(), amount, _tokenFeeKillswitch[ideaToken]).total;\n', '    }\n', '\n', '    /**\n', '     * Calculates each price related to selling tokens\n', '     *\n', '     * @param marketDetails The market details\n', '     * @param supply The existing supply of the IdeaToken\n', '     * @param amount The amount of IdeaTokens to sell\n', '     *\n', '     * @return total cost, raw cost and trading fee\n', '     */\n', '    function getPricesForSellingTokens(MarketDetails memory marketDetails, uint supply, uint amount, bool feesDisabled) public pure override returns (CostAndPriceAmounts memory) {\n', '        \n', '        uint rawPrice = getRawPriceForSellingTokens(marketDetails.baseCost,\n', '                                                    marketDetails.priceRise,\n', '                                                    marketDetails.hatchTokens,\n', '                                                    supply,\n', '                                                    amount);\n', '\n', '        uint tradingFee = 0;\n', '        uint platformFee = 0;\n', '\n', '        if(!feesDisabled) {\n', '            tradingFee = rawPrice.mul(marketDetails.tradingFeeRate).div(FEE_SCALE);\n', '            platformFee = rawPrice.mul(marketDetails.platformFeeRate).div(FEE_SCALE);\n', '        }   \n', '        \n', '        uint totalPrice = rawPrice.sub(tradingFee).sub(platformFee);\n', '\n', '        return CostAndPriceAmounts({\n', '            total: totalPrice,\n', '            raw: rawPrice,\n', '            tradingFee: tradingFee,\n', '            platformFee: platformFee\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Returns the price for selling tokens without any fees applied\n', '     *\n', '     * @param baseCost The baseCost of the token\n', '     * @param priceRise The priceRise of the token\n', '     * @param hatchTokens The amount of hatch tokens\n', '     * @param supply The current total supply of the token\n', '     * @param amount The amount of IdeaTokens to sell\n', '     *\n', '     * @return The price selling `amount` IdeaTokens without any fees applied\n', '     */\n', '    function getRawPriceForSellingTokens(uint baseCost, uint priceRise, uint hatchTokens, uint supply, uint amount) internal pure returns (uint) {\n', '\n', '        uint hatchPrice = 0;\n', '        uint updatedAmount = amount;\n', '        uint updatedSupply;\n', '\n', '        if(supply.sub(amount) < hatchTokens) {\n', '\n', '            if(supply <= hatchTokens) {\n', '                return baseCost.mul(amount).div(10**18);\n', '            }\n', '\n', '            // No SafeMath required because supply - amount < hatchTokens\n', '            uint tokensInHatch = hatchTokens - (supply - amount);\n', '            hatchPrice = baseCost.mul(tokensInHatch).div(10**18);\n', '            updatedAmount = amount.sub(tokensInHatch);\n', '            // No SafeMath required because supply >= hatchTokens\n', '            updatedSupply = supply - hatchTokens;\n', '        } else {\n', '            // No SafeMath required because supply >= hatchTokens\n', '            updatedSupply = supply - hatchTokens;\n', '        }\n', '\n', '        uint priceAtSupply = baseCost.add(priceRise.mul(updatedSupply).div(10**18));\n', '        uint priceAtSupplyMinusAmount = baseCost.add(priceRise.mul(updatedSupply.sub(updatedAmount)).div(10**18));\n', '        uint average = priceAtSupply.add(priceAtSupplyMinusAmount).div(2);\n', '    \n', '        return hatchPrice.add(average.mul(updatedAmount).div(10**18));\n', '    }\n', '\n', '    /**\n', '     * Mints IdeaTokens in exchange for Dai\n', '     *\n', '     * @param ideaToken The IdeaToken to buy\n', '     * @param amount The amount of IdeaTokens to buy\n', '     * @param fallbackAmount The fallback amount to buy in case the price changed\n', '     * @param cost The maximum allowed cost in Dai\n', '     * @param recipient The recipient of the bought IdeaTokens\n', '     */\n', '    function buyTokens(address ideaToken, uint amount, uint fallbackAmount, uint cost, address recipient) external override {\n', '        MarketDetails memory marketDetails = _ideaTokenFactory.getMarketDetailsByTokenAddress(ideaToken);\n', '        require(marketDetails.exists, "token-not-exist");\n', '        uint marketID = marketDetails.id;\n', '\n', '        uint supply = IERC20(ideaToken).totalSupply();\n', '        bool feesDisabled = _tokenFeeKillswitch[ideaToken];\n', '        uint actualAmount = amount;\n', '\n', '        CostAndPriceAmounts memory amounts = getCostsForBuyingTokens(marketDetails, supply, actualAmount, feesDisabled);\n', '\n', '        if(amounts.total > cost) {\n', '            actualAmount = fallbackAmount;\n', '            amounts = getCostsForBuyingTokens(marketDetails, supply, actualAmount, feesDisabled);\n', '    \n', '            require(amounts.total <= cost, "slippage");\n', '        }\n', '\n', '        \n', '        require(_dai.allowance(msg.sender, address(this)) >= amounts.total, "insufficient-allowance");\n', '        require(_dai.transferFrom(msg.sender, address(_interestManager), amounts.total), "dai-transfer");\n', '        \n', '        _interestManager.accrueInterest();\n', '        _interestManager.invest(amounts.total);\n', '\n', '\n', '        ExchangeInfo storage exchangeInfo;\n', '        if(marketDetails.allInterestToPlatform) {\n', '            exchangeInfo = _platformsExchangeInfo[marketID];\n', '        } else {\n', '            exchangeInfo = _tokensExchangeInfo[ideaToken];\n', '        }\n', '\n', '        exchangeInfo.invested = exchangeInfo.invested.add(_interestManager.underlyingToInvestmentToken(amounts.raw));\n', '        uint tradingFeeInvested = _tradingFeeInvested.add(_interestManager.underlyingToInvestmentToken(amounts.tradingFee));\n', '        _tradingFeeInvested = tradingFeeInvested;\n', '        uint platformFeeInvested = _platformFeeInvested[marketID].add(_interestManager.underlyingToInvestmentToken(amounts.platformFee));\n', '        _platformFeeInvested[marketID] = platformFeeInvested;\n', '        exchangeInfo.dai = exchangeInfo.dai.add(amounts.raw);\n', '    \n', '        emit InvestedState(marketID, ideaToken, exchangeInfo.dai, exchangeInfo.invested, tradingFeeInvested, platformFeeInvested, amounts.total);\n', '        IIdeaToken(ideaToken).mint(recipient, actualAmount);\n', '    }\n', '\n', '    /**\n', '     * Returns the cost for buying IdeaTokens\n', '     *\n', '     * @param ideaToken The IdeaToken to buy\n', '     * @param amount The amount of IdeaTokens to buy\n', '     *\n', '     * @return The cost in Dai for buying `amount` IdeaTokens\n', '     */\n', '    function getCostForBuyingTokens(address ideaToken, uint amount) external view override returns (uint) {\n', '        MarketDetails memory marketDetails = _ideaTokenFactory.getMarketDetailsByTokenAddress(ideaToken);\n', '\n', '        return getCostsForBuyingTokens(marketDetails, IERC20(ideaToken).totalSupply(), amount, _tokenFeeKillswitch[ideaToken]).total;\n', '    }\n', '\n', '    /**\n', '     * Calculates each cost related to buying tokens\n', '     *\n', '     * @param marketDetails The market details\n', '     * @param supply The existing supply of the IdeaToken\n', '     * @param amount The amount of IdeaTokens to buy\n', '     *\n', '     * @return total cost, raw cost, trading fee, platform fee\n', '     */\n', '    function getCostsForBuyingTokens(MarketDetails memory marketDetails, uint supply, uint amount, bool feesDisabled) public pure override returns (CostAndPriceAmounts memory) {\n', '        uint rawCost = getRawCostForBuyingTokens(marketDetails.baseCost,\n', '                                                 marketDetails.priceRise,\n', '                                                 marketDetails.hatchTokens,\n', '                                                 supply,\n', '                                                 amount);\n', '\n', '        uint tradingFee = 0;\n', '        uint platformFee = 0;\n', '\n', '        if(!feesDisabled) {\n', '            tradingFee = rawCost.mul(marketDetails.tradingFeeRate).div(FEE_SCALE);\n', '            platformFee = rawCost.mul(marketDetails.platformFeeRate).div(FEE_SCALE);\n', '        }\n', '        \n', '        uint totalCost = rawCost.add(tradingFee).add(platformFee);\n', '\n', '        return CostAndPriceAmounts({\n', '            total: totalCost,\n', '            raw: rawCost,\n', '            tradingFee: tradingFee,\n', '            platformFee: platformFee\n', '        });\n', '    }\n', '\n', '    /**\n', '     * Returns the cost for buying tokens without any fees applied\n', '     *\n', '     * @param baseCost The baseCost of the token\n', '     * @param priceRise The priceRise of the token\n', '     * @param hatchTokens The amount of hatch tokens\n', '     * @param supply The current total supply of the token\n', '     * @param amount The amount of IdeaTokens to buy\n', '     *\n', '     * @return The cost buying `amount` IdeaTokens without any fees applied\n', '     */\n', '    function getRawCostForBuyingTokens(uint baseCost, uint priceRise, uint hatchTokens, uint supply, uint amount) internal pure returns (uint) {\n', '\n', '        uint hatchCost = 0;\n', '        uint updatedAmount = amount;\n', '        uint updatedSupply;\n', '\n', '        if(supply < hatchTokens) {\n', '            // No SafeMath required because supply < hatchTokens\n', '            uint remainingHatchTokens = hatchTokens - supply;\n', '\n', '            if(amount <= remainingHatchTokens) {\n', '                return baseCost.mul(amount).div(10**18);\n', '            }\n', '\n', '            hatchCost = baseCost.mul(remainingHatchTokens).div(10**18);\n', '            updatedSupply = 0;\n', '            // No SafeMath required because remainingHatchTokens < amount\n', '            updatedAmount = amount - remainingHatchTokens;\n', '        } else {\n', '            // No SafeMath required because supply >= hatchTokens\n', '            updatedSupply = supply - hatchTokens;\n', '        }\n', '\n', '        uint priceAtSupply = baseCost.add(priceRise.mul(updatedSupply).div(10**18));\n', '        uint priceAtSupplyPlusAmount = baseCost.add(priceRise.mul(updatedSupply.add(updatedAmount)).div(10**18));\n', '        uint average = priceAtSupply.add(priceAtSupplyPlusAmount).div(2);\n', '\n', '        return hatchCost.add(average.mul(updatedAmount).div(10**18));\n', '    }\n', '\n', '    /**\n', '     * Withdraws available interest for a publisher\n', '     *\n', '     * @param token The token from which the generated interest is to be withdrawn\n', '     */\n', '    function withdrawTokenInterest(address token) external override {\n', '        require(_tokenOwner[token] == msg.sender, "not-authorized");\n', '        _interestManager.accrueInterest();\n', '\n', '        uint interestPayable = getInterestPayable(token);\n', '        if(interestPayable == 0) {\n', '            return;\n', '        }\n', '\n', '        ExchangeInfo storage exchangeInfo = _tokensExchangeInfo[token];\n', '        exchangeInfo.invested = exchangeInfo.invested.sub(_interestManager.redeem(msg.sender, interestPayable));\n', '\n', '        emit TokenInterestRedeemed(token, exchangeInfo.invested, interestPayable);\n', '    }\n', '\n', '    /**\n', '     * Returns the interest available to be paid out for a token\n', '     *\n', '     * @param token The token from which the generated interest is to be withdrawn\n', '     *\n', '     * @return The interest available to be paid out\n', '     */\n', '    function getInterestPayable(address token) public view override returns (uint) {\n', '        ExchangeInfo storage exchangeInfo = _tokensExchangeInfo[token];\n', '        return _interestManager.investmentTokenToUnderlying(exchangeInfo.invested).sub(exchangeInfo.dai);\n', '    }\n', '\n', '    /**\n', '     * Sets an address as owner of a token, allowing the address to withdraw interest\n', '     *\n', '     * @param token The token for which to authorize an address\n', '     * @param owner The address to be set as owner\n', '     */\n', '    function setTokenOwner(address token, address owner) external override {\n', '        address sender = msg.sender;\n', '        address current = _tokenOwner[token];\n', '\n', '        require((current == address(0) && (sender == _owner || sender == _authorizer)) ||\n', '                (current != address(0) && (sender == _owner || sender == current)),\n', '                "not-authorized");\n', '\n', '        _tokenOwner[token] = owner;\n', '\n', '        emit NewTokenOwner(token, owner);\n', '    }\n', '\n', '    /**\n', '     * Withdraws available interest for a platform\n', '     *\n', '     * @param marketID The market id from which the generated interest is to be withdrawn\n', '     */\n', '    function withdrawPlatformInterest(uint marketID) external override {\n', '        address sender = msg.sender;\n', '\n', '        require(_platformOwner[marketID] == sender, "not-authorized");\n', '        _interestManager.accrueInterest();\n', '\n', '        uint platformInterestPayable = getPlatformInterestPayable(marketID);\n', '        if(platformInterestPayable == 0) {\n', '            return;\n', '        }\n', '\n', '        ExchangeInfo storage exchangeInfo = _platformsExchangeInfo[marketID];\n', '        exchangeInfo.invested = exchangeInfo.invested.sub(_interestManager.redeem(sender, platformInterestPayable));\n', '\n', '        emit PlatformInterestRedeemed(marketID, exchangeInfo.invested, platformInterestPayable);\n', '    }\n', '\n', '    /**\n', '     * Returns the interest available to be paid out for a platform\n', '     *\n', '     * @param marketID The market id from which the generated interest is to be withdrawn\n', '     *\n', '     * @return The interest available to be paid out\n', '     */\n', '    function getPlatformInterestPayable(uint marketID) public view override returns (uint) {\n', '        ExchangeInfo storage exchangeInfo = _platformsExchangeInfo[marketID];\n', '        return _interestManager.investmentTokenToUnderlying(exchangeInfo.invested).sub(exchangeInfo.dai);\n', '    }\n', '\n', '    /**\n', '     * Withdraws available platform fee\n', '     *\n', '     * @param marketID The market from which the generated platform fee is to be withdrawn\n', '     */\n', '    function withdrawPlatformFee(uint marketID) external override {\n', '        address sender = msg.sender;\n', '    \n', '        require(_platformOwner[marketID] == sender, "not-authorized");\n', '        _interestManager.accrueInterest();\n', '\n', '        uint platformFeePayable = getPlatformFeePayable(marketID);\n', '        if(platformFeePayable == 0) {\n', '            return;\n', '        }\n', '\n', '        _platformFeeInvested[marketID] = 0;\n', '        _interestManager.redeem(sender, platformFeePayable);\n', '\n', '        emit PlatformFeeRedeemed(marketID, platformFeePayable);\n', '    }\n', '\n', '    /**\n', '     * Returns the platform fee available to be paid out\n', '     *\n', '     * @param marketID The market from which the generated interest is to be withdrawn\n', '     *\n', '     * @return The platform fee available to be paid out\n', '     */\n', '    function getPlatformFeePayable(uint marketID) public view override returns (uint) {\n', '        return _interestManager.investmentTokenToUnderlying(_platformFeeInvested[marketID]);\n', '    }\n', '\n', '    /**\n', '     * Authorizes an address as owner of a platform/market, which is allowed to withdraw platform fee and platform interest\n', '     *\n', '     * @param marketID The market for which to authorize an address\n', '     * @param owner The address to be authorized\n', '     */\n', '    function setPlatformOwner(uint marketID, address owner) external override {\n', '        address sender = msg.sender;\n', '        address current = _platformOwner[marketID];\n', '\n', '        require((current == address(0) && (sender == _owner || sender == _authorizer)) ||\n', '                (current != address(0) && (sender == _owner || sender == current)),\n', '                "not-authorized");\n', '        \n', '        _platformOwner[marketID] = owner;\n', '\n', '        emit NewPlatformOwner(marketID, owner);\n', '    }\n', '\n', '    /**\n', '     * Withdraws available trading fee\n', '     */\n', '    function withdrawTradingFee() external override {\n', '\n', '        uint invested = _tradingFeeInvested;\n', '        if(invested == 0) {\n', '            return;\n', '        }\n', '\n', '        _interestManager.accrueInterest();\n', '\n', '        _tradingFeeInvested = 0;\n', '        uint redeem = _interestManager.investmentTokenToUnderlying(invested);\n', '        _interestManager.redeem(_tradingFeeRecipient, redeem);\n', '\n', '        emit TradingFeeRedeemed(redeem);\n', '    }\n', '\n', '    /**\n', '     * Returns the trading fee available to be paid out\n', '     *\n', '     * @return The trading fee available to be paid out\n', '     */\n', '    function getTradingFeePayable() public view override returns (uint) {\n', '        return _interestManager.investmentTokenToUnderlying(_tradingFeeInvested);\n', '    }\n', '\n', '    /**\n', '     * Sets the authorizer address\n', '     *\n', '     * @param authorizer The new authorizer address\n', '     */\n', '    function setAuthorizer(address authorizer) external override onlyOwner {\n', '        require(authorizer != address(0), "invalid-params");\n', '        _authorizer = authorizer;\n', '    }\n', '\n', '    /**\n', '     * Returns whether or not fees are disabled for a specific IdeaToken\n', '     *\n', '     * @param ideaToken The IdeaToken\n', '     *\n', '     * @return Whether or not fees are disabled for a specific IdeaToken\n', '     */\n', '    function isTokenFeeDisabled(address ideaToken) external view override returns (bool) {\n', '        return _tokenFeeKillswitch[ideaToken];\n', '    }\n', '\n', '    /**\n', '     * Sets the fee killswitch for an IdeaToken\n', '     *\n', '     * @param ideaToken The IdeaToken\n', '     * @param set Whether or not to enable the killswitch\n', '     */\n', '    function setTokenFeeKillswitch(address ideaToken, bool set) external override onlyOwner {\n', '        _tokenFeeKillswitch[ideaToken] = set;\n', '    }\n', '\n', '    /**\n', '     * Sets the IdeaTokenFactory address. Only required once for deployment\n', '     *\n', '     * @param factory The address of the IdeaTokenFactory \n', '     */\n', '    function setIdeaTokenFactoryAddress(address factory) external onlyOwner {\n', '        require(address(_ideaTokenFactory) == address(0));\n', '        _ideaTokenFactory = IIdeaTokenFactory(factory);\n', '    }\n', '}']