['pragma solidity ^0.5.0;\n', '\n', 'import "./ENS.sol";\n', '\n', 'contract NameResolver {\n', '    function setName(bytes32 node, string memory name) public;\n', '}\n', '\n', 'contract ReverseRegistrar {\n', "    // namehash('addr.reverse')\n", '    bytes32 public constant ADDR_REVERSE_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n', '\n', '    ENS public ens;\n', '    NameResolver public defaultResolver;\n', '\n', '    /**\n', '     * @dev Constructor\n', '     * @param ensAddr The address of the ENS registry.\n', '     * @param resolverAddr The address of the default reverse resolver.\n', '     */\n', '    constructor(ENS ensAddr, NameResolver resolverAddr) public {\n', '        ens = ensAddr;\n', '        defaultResolver = resolverAddr;\n', '\n', '        // Assign ownership of the reverse record to our deployer\n', '        ReverseRegistrar oldRegistrar = ReverseRegistrar(ens.owner(ADDR_REVERSE_NODE));\n', '        if (address(oldRegistrar) != address(0x0)) {\n', '            oldRegistrar.claim(msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the reverse ENS record associated with the\n', '     *      calling account.\n', '     * @param owner The address to set as the owner of the reverse record in ENS.\n', '     * @return The ENS node hash of the reverse record.\n', '     */\n', '    function claim(address owner) public returns (bytes32) {\n', '        return claimWithResolver(owner, address(0x0));\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the reverse ENS record associated with the\n', '     *      calling account.\n', '     * @param owner The address to set as the owner of the reverse record in ENS.\n', '     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n', '     * @return The ENS node hash of the reverse record.\n', '     */\n', '    function claimWithResolver(address owner, address resolver) public returns (bytes32) {\n', '        bytes32 label = sha3HexAddress(msg.sender);\n', '        bytes32 node = keccak256(abi.encodePacked(ADDR_REVERSE_NODE, label));\n', '        address currentOwner = ens.owner(node);\n', '\n', '        // Update the resolver if required\n', '        if (resolver != address(0x0) && resolver != ens.resolver(node)) {\n', "            // Transfer the name to us first if it's not already\n", '            if (currentOwner != address(this)) {\n', '                ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, address(this));\n', '                currentOwner = address(this);\n', '            }\n', '            ens.setResolver(node, resolver);\n', '        }\n', '\n', '        // Update the owner if required\n', '        if (currentOwner != owner) {\n', '            ens.setSubnodeOwner(ADDR_REVERSE_NODE, label, owner);\n', '        }\n', '\n', '        return node;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the `name()` record for the reverse ENS record associated with\n', '     * the calling account. First updates the resolver to the default reverse\n', '     * resolver if necessary.\n', '     * @param name The name to set for this address.\n', '     * @return The ENS node hash of the reverse record.\n', '     */\n', '    function setName(string memory name) public returns (bytes32) {\n', '        bytes32 node = claimWithResolver(address(this), address(defaultResolver));\n', '        defaultResolver.setName(node, name);\n', '        return node;\n', '    }\n', '\n', '    /**\n', "     * @dev Returns the node hash for a given account's reverse records.\n", '     * @param addr The address to hash\n', '     * @return The ENS node hash.\n', '     */\n', '    function node(address addr) public pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr)));\n', '    }\n', '\n', '    /**\n', '     * @dev An optimised function to compute the sha3 of the lower-case\n', '     *      hexadecimal representation of an Ethereum address.\n', '     * @param addr The address to hash\n', '     * @return The SHA3 hash of the lower-case hexadecimal encoding of the\n', '     *         input address.\n', '     */\n', '    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n', '        addr;\n', '        ret; // Stop warning us about unused variables\n', '        assembly {\n', '            let lookup := 0x3031323334353637383961626364656600000000000000000000000000000000\n', '\n', '            for { let i := 40 } gt(i, 0) { } {\n', '                i := sub(i, 1)\n', '                mstore8(i, byte(and(addr, 0xf), lookup))\n', '                addr := div(addr, 0x10)\n', '                i := sub(i, 1)\n', '                mstore8(i, byte(and(addr, 0xf), lookup))\n', '                addr := div(addr, 0x10)\n', '            }\n', '\n', '            ret := keccak256(0, 40)\n', '        }\n', '    }\n', '}']