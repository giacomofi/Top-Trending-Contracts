['// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./Timer.sol";\n', '\n', '/**\n', ' * @title Base class that provides time overrides, but only if being run in test mode.\n', ' */\n', 'abstract contract Testable {\n', '    // If the contract is being run on the test network, then `timerAddress` will be the 0x0 address.\n', '    // Note: this variable should be set on construction and never modified.\n', '    address public timerAddress;\n', '\n', '    /**\n', '     * @notice Constructs the Testable contract. Called by child contracts.\n', '     * @param _timerAddress Contract that stores the current time in a testing environment.\n', '     * Must be set to 0x0 for production environments that use live time.\n', '     */\n', '    constructor(address _timerAddress) {\n', '        timerAddress = _timerAddress;\n', '    }\n', '\n', '    /**\n', '     * @notice Reverts if not running in test mode.\n', '     */\n', '    modifier onlyIfTest {\n', '        require(timerAddress != address(0x0));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the current time.\n', '     * @dev Will revert if not running in test mode.\n', '     * @param time timestamp to set current Testable time to.\n', '     */\n', '    function setCurrentTime(uint256 time) external onlyIfTest {\n', '        Timer(timerAddress).setCurrentTime(time);\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n', '     * Otherwise, it will return the block timestamp.\n', '     * @return uint for the current Testable timestamp.\n', '     */\n', '    function getCurrentTime() public view returns (uint256) {\n', '        if (timerAddress != address(0x0)) {\n', '            return Timer(timerAddress).getCurrentTime();\n', '        } else {\n', '            return block.timestamp; // solhint-disable-line not-rely-on-time\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title Universal store of current contract time for testing environments.\n', ' */\n', 'contract Timer {\n', '    uint256 private currentTime;\n', '\n', '    constructor() {\n', '        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the current time.\n', '     * @dev Will revert if not running in test mode.\n', '     * @param time timestamp to set `currentTime` to.\n', '     */\n', '    function setCurrentTime(uint256 time) external {\n', '        currentTime = time;\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\n', '     * Otherwise, it will return the block timestamp.\n', '     * @return uint256 for the current Testable timestamp.\n', '     */\n', '    function getCurrentTime() public view returns (uint256) {\n', '        return currentTime;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title Stores common interface names used throughout the DVM by registration in the Finder.\n', ' */\n', 'library OracleInterfaces {\n', '    bytes32 public constant Oracle = "Oracle";\n', '    bytes32 public constant IdentifierWhitelist = "IdentifierWhitelist";\n', '    bytes32 public constant Store = "Store";\n', '    bytes32 public constant FinancialContractsAdmin = "FinancialContractsAdmin";\n', '    bytes32 public constant Registry = "Registry";\n', '    bytes32 public constant CollateralWhitelist = "CollateralWhitelist";\n', '    bytes32 public constant OptimisticOracle = "OptimisticOracle";\n', '    bytes32 public constant Bridge = "Bridge";\n', '    bytes32 public constant GenericHandler = "GenericHandler";\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title Provides addresses of the live contracts implementing certain interfaces.\n', ' * @dev Examples are the Oracle or Store interfaces.\n', ' */\n', 'interface FinderInterface {\n', '    /**\n', '     * @notice Updates the address of the contract that implements `interfaceName`.\n', '     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\n', '     * @param implementationAddress address of the deployed contract that implements the interface.\n', '     */\n', '    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\n', '\n', '    /**\n', '     * @notice Gets the address of the contract that implements the given `interfaceName`.\n', '     * @param interfaceName queried interface.\n', '     * @return implementationAddress address of the deployed contract that implements the interface.\n', '     */\n', '    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title Interface for whitelists of supported identifiers that the oracle can provide prices for.\n', ' */\n', 'interface IdentifierWhitelistInterface {\n', '    /**\n', '     * @notice Adds the provided identifier as a supported identifier.\n', '     * @dev Price requests using this identifier will succeed after this call.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     */\n', '    function addSupportedIdentifier(bytes32 identifier) external;\n', '\n', '    /**\n', '     * @notice Removes the identifier from the whitelist.\n', '     * @dev Price requests using this identifier will no longer succeed after this call.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     */\n', '    function removeSupportedIdentifier(bytes32 identifier) external;\n', '\n', '    /**\n', '     * @notice Checks whether an identifier is on the whitelist.\n', '     * @param identifier bytes32 encoding of the string identifier. Eg: BTC/USD.\n', '     * @return bool if the identifier is supported (or not).\n', '     */\n', '    function isIdentifierSupported(bytes32 identifier) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title Financial contract facing Oracle interface.\n', ' * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\n', ' */\n', 'abstract contract OracleAncillaryInterface {\n', '    /**\n', "     * @notice Enqueues a request (if a request isn't already present) for the given `identifier`, `time` pair.\n", '     * @dev Time must be in the past and the identifier must be supported.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n', '     * @param time unix timestamp for the price request.\n', '     */\n', '\n', '    function requestPrice(\n', '        bytes32 identifier,\n', '        uint256 time,\n', '        bytes memory ancillaryData\n', '    ) public virtual;\n', '\n', '    /**\n', '     * @notice Whether the price for `identifier` and `time` is available.\n', '     * @dev Time must be in the past and the identifier must be supported.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param time unix timestamp for the price request.\n', '     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n', '     * @return bool if the DVM has resolved to a price for the given identifier and timestamp.\n', '     */\n', '    function hasPrice(\n', '        bytes32 identifier,\n', '        uint256 time,\n', '        bytes memory ancillaryData\n', '    ) public view virtual returns (bool);\n', '\n', '    /**\n', '     * @notice Gets the price for `identifier` and `time` if it has already been requested and resolved.\n', '     * @dev If the price is not available, the method reverts.\n', '     * @param identifier uniquely identifies the price requested. eg BTC/USD (encoded as bytes32) could be requested.\n', '     * @param time unix timestamp for the price request.\n', '     * @param ancillaryData arbitrary data appended to a price request to give the voters more info from the caller.\n', '     * @return int256 representing the resolved price for the given identifier and timestamp.\n', '     */\n', '\n', '    function getPrice(\n', '        bytes32 identifier,\n', '        uint256 time,\n', '        bytes memory ancillaryData\n', '    ) public view virtual returns (int256);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-only\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "../../common/implementation/Testable.sol";\n', 'import "../interfaces/OracleAncillaryInterface.sol";\n', 'import "../interfaces/IdentifierWhitelistInterface.sol";\n', 'import "../interfaces/FinderInterface.sol";\n', 'import "../implementation/Constants.sol";\n', '\n', '// A mock oracle used for testing.\n', 'contract MockOracleAncillary is OracleAncillaryInterface, Testable {\n', '    // Represents an available price. Have to keep a separate bool to allow for price=0.\n', '    struct Price {\n', '        bool isAvailable;\n', '        int256 price;\n', '        // Time the verified price became available.\n', '        uint256 verifiedTime;\n', '    }\n', '\n', '    // The two structs below are used in an array and mapping to keep track of prices that have been requested but are\n', '    // not yet available.\n', '    struct QueryIndex {\n', '        bool isValid;\n', '        uint256 index;\n', '    }\n', '\n', '    // Represents a (identifier, time) point that has been queried.\n', '    struct QueryPoint {\n', '        bytes32 identifier;\n', '        uint256 time;\n', '        bytes ancillaryData;\n', '    }\n', '\n', '    // Reference to the Finder.\n', '    FinderInterface private finder;\n', '\n', '    // Conceptually we want a (time, identifier) -> price map.\n', '    mapping(bytes32 => mapping(uint256 => mapping(bytes => Price))) private verifiedPrices;\n', '\n', '    // The mapping and array allow retrieving all the elements in a mapping and finding/deleting elements.\n', '    // Can we generalize this data structure?\n', '    mapping(bytes32 => mapping(uint256 => mapping(bytes => QueryIndex))) private queryIndices;\n', '    QueryPoint[] private requestedPrices;\n', '\n', '    event PriceRequestAdded(address indexed requester, bytes32 indexed identifier, uint256 time, bytes ancillaryData);\n', '    event PushedPrice(\n', '        address indexed pusher,\n', '        bytes32 indexed identifier,\n', '        uint256 time,\n', '        bytes ancillaryData,\n', '        int256 price\n', '    );\n', '\n', '    constructor(address _finderAddress, address _timerAddress) Testable(_timerAddress) {\n', '        finder = FinderInterface(_finderAddress);\n', '    }\n', '\n', "    // Enqueues a request (if a request isn't already present) for the given (identifier, time) pair.\n", '\n', '    function requestPrice(\n', '        bytes32 identifier,\n', '        uint256 time,\n', '        bytes memory ancillaryData\n', '    ) public override {\n', '        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n', '        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n', '        if (!lookup.isAvailable && !queryIndices[identifier][time][ancillaryData].isValid) {\n', '            // New query, enqueue it for review.\n', '            queryIndices[identifier][time][ancillaryData] = QueryIndex(true, requestedPrices.length);\n', '            requestedPrices.push(QueryPoint(identifier, time, ancillaryData));\n', '            emit PriceRequestAdded(msg.sender, identifier, time, ancillaryData);\n', '        }\n', '    }\n', '\n', '    // Pushes the verified price for a requested query.\n', '    function pushPrice(\n', '        bytes32 identifier,\n', '        uint256 time,\n', '        bytes memory ancillaryData,\n', '        int256 price\n', '    ) external {\n', '        verifiedPrices[identifier][time][ancillaryData] = Price(true, price, getCurrentTime());\n', '\n', '        QueryIndex storage queryIndex = queryIndices[identifier][time][ancillaryData];\n', '        require(queryIndex.isValid, "Can\'t push prices that haven\'t been requested");\n', '        // Delete from the array. Instead of shifting the queries over, replace the contents of `indexToReplace` with\n', '        // the contents of the last index (unless it is the last index).\n', '        uint256 indexToReplace = queryIndex.index;\n', '        delete queryIndices[identifier][time][ancillaryData];\n', '        uint256 lastIndex = requestedPrices.length - 1;\n', '        if (lastIndex != indexToReplace) {\n', '            QueryPoint storage queryToCopy = requestedPrices[lastIndex];\n', '            queryIndices[queryToCopy.identifier][queryToCopy.time][queryToCopy.ancillaryData].index = indexToReplace;\n', '            requestedPrices[indexToReplace] = queryToCopy;\n', '        }\n', '\n', '        emit PushedPrice(msg.sender, identifier, time, ancillaryData, price);\n', '    }\n', '\n', '    // Checks whether a price has been resolved.\n', '    function hasPrice(\n', '        bytes32 identifier,\n', '        uint256 time,\n', '        bytes memory ancillaryData\n', '    ) public view override returns (bool) {\n', '        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n', '        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n', '        return lookup.isAvailable;\n', '    }\n', '\n', '    // Gets a price that has already been resolved.\n', '    function getPrice(\n', '        bytes32 identifier,\n', '        uint256 time,\n', '        bytes memory ancillaryData\n', '    ) public view override returns (int256) {\n', '        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n', '        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n', '        require(lookup.isAvailable);\n', '        return lookup.price;\n', '    }\n', '\n', '    // Gets the queries that still need verified prices.\n', '    function getPendingQueries() external view returns (QueryPoint[] memory) {\n', '        return requestedPrices;\n', '    }\n', '\n', '    function _getIdentifierWhitelist() private view returns (IdentifierWhitelistInterface supportedIdentifiers) {\n', '        return IdentifierWhitelistInterface(finder.getImplementationAddress(OracleInterfaces.IdentifierWhitelist));\n', '    }\n', '}\n', '\n', '{\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "metadata": {\n', '    "bytecodeHash": "ipfs",\n', '    "useLiteralContent": true\n', '  },\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 199\n', '  },\n', '  "remappings": [],\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']