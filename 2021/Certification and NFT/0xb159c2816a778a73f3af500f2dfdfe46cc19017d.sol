['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-06\n', '*/\n', '\n', 'pragma solidity 0.5.10;\n', '\n', '/**\n', ' * MINA PROTOCOL - Smart-Contract\n', ' * \n', ' * \n', " * The world's lightest blockchain, powered by participants.\n", ' * \n', ' * By design, the entire Mina blockchain is and will always be about 22kb - the size of a couple of tweets. \n', ' * So anyone with a smartphone will be able to sync and verify the network in seconds.\n', ' * \n', ' * About the Tech: https://minaprotocol.com/tech\n', ' * Knowledge Base: https://minaprotocol.com/get-started#knowledge-base\n', ' * \n', ' * Technical Whitepaper: https://minaprotocol.com/static/pdf/technicalWhitepaper.pdf\n', ' * Economics Whitepaper: https://minaprotocol.com/static/pdf/economicsWhitepaper.pdf\n', ' * \n', ' * Mina Protocol-media\n', ' * Official Website: https://minaprotocol.com\n', ' * Github: https://github.com/MinaProtocol/mina\n', ' * Twitter: https://twitter.com/minaprotocol\n', ' * Telegram: https://t.me/minaprotocol\n', ' * Forums: https://forums.minaprotocol.com/t/mina-protocol-chinese-resources/200\n', ' * Discord: https://discord.com/invite/RDQc43H\n', ' * Facebook: https://www.facebook.com/Mina-Protocol-108885454193665\n', ' * Reddit: https://www.reddit.com/r/MinaProtocol\n', ' * Wiki: https://minawiki.com/Main_Page\n', ' */\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error.\n', ' */\n', 'library SafeMath {\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor(address initialOwner) internal {\n', '        require(initialOwner != address(0));\n', '        _owner = initialOwner;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "New owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://eips.ethereum.org/EIPS/eip-20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function balanceOf(address who) external view returns (uint256);\n', '}\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' */\n', 'contract ReentrancyGuard {\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () internal {\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '}\n', '\n', '/**\n', ' * @title BonusMina interface\n', ' */\n', ' interface BonusMina {\n', '     function sendBonus(address account, uint256 amount) external;\n', '     function RS_changeInterval(uint256 newInterval) external;\n', '     function RS_newTicket() external;\n', '     function RS_addReferrer(address referrer) external;\n', '     function RS_ticketsOf(address player) external view returns(uint256);\n', '     function RS_referrerOf(address player) external view returns(address);\n', '     function RS_interval() external view returns(uint256);\n', ' }\n', '\n', '/**\n', ' * @title Invest contract.\n', ' */\n', 'contract MinaProtocol is ReentrancyGuard, Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    // The token being sold\n', '    IERC20 private _token;\n', '\n', '    // BonusMina contract\n', '    BonusMina private _MPBS;\n', '\n', '    // Address where funds are collected\n', '    address payable private _wallet;\n', '\n', '    // Amount of wei raised\n', '    uint256 private _weiRaised;\n', '\n', '    // Amount of reserved tokens\n', '    uint256 private _reserve;\n', '\n', '    // How many token units a buyer gets per 1 ether\n', '    uint256 private _rate = 2e15;\n', '\n', '    // Minimum amount of wei to invest\n', '    uint256 private _minimum = 0.5 ether;\n', '\n', '    // Token amount set as share\n', '    uint256 private _share = 1000000000000000;\n', '\n', '    // Ref Bonus per share\n', '    uint256 private _bonusPerShare = 50000000000000;\n', '\n', '    // Delay period (UNIX time)\n', '    uint256 private _delay;\n', '\n', '    // User data\n', '    mapping (address => User) users;\n', '    struct User {\n', '        Deposit[] deposits;\n', '        uint256 checkpoint;\n', '        uint256 reserved;\n', '    }\n', '    struct Deposit {\n', '        uint256 amount;\n', '        uint256 endtime;\n', '        uint256 delay;\n', '    }\n', '\n', '    // Pause of recieving new deposits\n', '    bool public paused;\n', '\n', '    modifier notPaused() {\n', '        require(!paused);\n', '        _;\n', '    }\n', '\n', '    // Requiring of being referrer (more than 100 tickets)\n', '    bool public refRequired;\n', '\n', '    // Enable of referral programm\n', '    enum ReferrerSystem {OFF, ON}\n', '    ReferrerSystem public RS = ReferrerSystem.OFF;\n', '\n', '    // Sending bonus to referral\n', '    bool public referralMode;\n', '\n', '    // Events\n', '    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 delay);\n', '    event Withdrawn(address indexed account, uint256 amount);\n', '\n', '    /**\n', '     * @param rate Number of token units a buyer gets per wei\n', '     * @param wallet Address where collected funds will be forwarded to\n', '     * @param token Address of the token being sold\n', '     */\n', '    constructor(uint256 rate, address payable wallet, IERC20 token, address initialOwner, address MPBSAddr) public Ownable(initialOwner) {\n', '        require(rate != 0, "Rate is 0");\n', '        require(wallet != address(0), "Wallet is the zero address");\n', '        require(address(token) != address(0), "Token is the zero address");\n', '        require(MPBSAddr != address(0), "MPBSAddr is the zero address");\n', '\n', '        _rate = rate;\n', '        _wallet = wallet;\n', '        _token = token;\n', '        _MPBS = BonusMina(MPBSAddr);\n', '    }\n', '\n', '    /**\n', '     * @dev fallback function\n', '     */\n', '    function() external payable {\n', '        if (msg.value > 0) {\n', '            buyTokens(msg.sender);\n', '        } else {\n', '            withdraw();\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev token purchase\n', '     * This function has a non-reentrancy guard\n', '     * @param beneficiary Recipient of the token purchase\n', '     */\n', '    function buyTokens(address beneficiary) public notPaused nonReentrant payable {\n', '        require(beneficiary != address(0), "Beneficiary is the zero address");\n', '        require(msg.value >= _minimum, "Wei amount is less than minimum");\n', '        if (refRequired) {\n', '            require(_MPBS.RS_ticketsOf(msg.sender) >= _MPBS.RS_interval());\n', '        }\n', '\n', '        uint256 weiAmount = msg.value;\n', '\n', '        uint256 tokens = getTokenAmount(weiAmount);\n', '        require(tokens <=  availableTokens(), "Not enough available tokens");\n', '\n', '        _weiRaised = _weiRaised.add(weiAmount);\n', '\n', '        _wallet.transfer(weiAmount);\n', '\n', '        if (_delay == 0) {\n', '            _token.transfer(beneficiary, tokens);\n', '        } else {\n', '            createDeposit(beneficiary, tokens);\n', '        }\n', '\n', '        if (_MPBS.RS_referrerOf(beneficiary) != address(0)) {\n', '            if (RS == ReferrerSystem.ON) {\n', '                _MPBS.sendBonus(_MPBS.RS_referrerOf(beneficiary), tokens.div(_share).mul(_bonusPerShare));\n', '                if (referralMode) {\n', '                    _MPBS.sendBonus(beneficiary, tokens.div(_share).mul(_bonusPerShare));\n', '                }\n', '            }\n', '        } else if (msg.data.length == 20) {\n', '            addReferrer();\n', '        }\n', '\n', '        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens, _delay);\n', '    }\n', '\n', '    /**\n', '     * @dev internal invest function\n', '     * @param account address of users\n', '     * @param amount amount of tokens to deposit\n', '     */\n', '    function createDeposit(address account, uint256 amount) internal {\n', '        if (getDividends(account) > 0) {\n', '            users[account].reserved += getDividends(account);\n', '        }\n', '        users[account].checkpoint = block.timestamp;\n', '        users[account].deposits.push(Deposit(amount, block.timestamp.add(_delay), _delay));\n', '\n', '        _reserve = _reserve.add(amount);\n', '    }\n', '\n', '    /**\n', '     * @dev withdraw available dividens\n', '     */\n', '    function withdraw() public {\n', '        uint256 payout = getDividends(msg.sender);\n', '        if (users[msg.sender].reserved > 0) {\n', '            users[msg.sender].reserved = 0;\n', '        }\n', '\n', '        require(payout > 0);\n', '\n', '        users[msg.sender].checkpoint = block.timestamp;\n', '        _token.transfer(msg.sender, payout);\n', '\n', '        _reserve = _reserve.sub(payout);\n', '        emit Withdrawn(msg.sender, payout);\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev internal addReferrer function\n', '     */\n', '    function addReferrer() internal {\n', '        address referrer = bytesToAddress(bytes(msg.data));\n', '        if (referrer != msg.sender) {\n', '            uint256 interval = _MPBS.RS_interval();\n', '            _MPBS.RS_changeInterval(0);\n', '            _MPBS.RS_addReferrer(referrer);\n', '            _MPBS.RS_changeInterval(interval);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev internal function to convert bytes type to address\n', '     */\n', '    function bytesToAddress(bytes memory source) internal pure returns(address parsedReferrer) {\n', '        assembly {\n', '            parsedReferrer := mload(add(source,0x14))\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate amount of tokens to recieve for a given amount of wei\n', '     * @param weiAmount Value in wei to be converted into tokens\n', '     * @return Number of tokens that can be purchased with the specified _weiAmount\n', '     */\n', '    function getTokenAmount(uint256 weiAmount) public view returns(uint256) {\n', '        return weiAmount.mul(_rate).div(1e18);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate amount of tokens to recieve for a given account at current time\n', '     * @param account Address of user\n', '     * @return Number of tokens that can be withdrawn\n', '     */\n', '    function getDividends(address account) public view returns(uint256) {\n', '        uint256 payout = users[account].reserved;\n', '        for (uint256 i = 0; i < users[account].deposits.length; i++) {\n', '            if (block.timestamp < users[account].deposits[i].endtime) {\n', '                payout += (users[account].deposits[i].amount).mul(block.timestamp.sub(users[account].checkpoint)).div(users[account].deposits[i].delay);\n', '            } else if (users[account].checkpoint < users[account].deposits[i].endtime) {\n', '                payout += (users[account].deposits[i].amount).mul(users[account].deposits[i].endtime.sub(users[account].checkpoint)).div(users[account].deposits[i].delay);\n', '            }\n', '        }\n', '        return payout;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to change the rate.\n', '     * Available only to the owner.\n', '     * @param newRate new value.\n', '     */\n', '    function setRate(uint256 newRate) external onlyOwner {\n', '        require(newRate != 0, "New rate is 0");\n', '\n', '        _rate = newRate;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to change the share value\n', '     * Available only to the owner.\n', '     * @param newShare new value.\n', '     */\n', '    function setShare(uint256 newShare) external onlyOwner {\n', '        require(newShare != 0, "New share value is 0");\n', '\n', '        _share = newShare;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to change the bonusPerShare value\n', '     * Available only to the owner.\n', '     * @param newBonus new value.\n', '     */\n', '    function setBonus(uint256 newBonus) external onlyOwner {\n', '        require(newBonus != 0, "New bonus value is 0");\n', '\n', '        _bonusPerShare = newBonus;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to change the address to receive ether.\n', '     * Available only to the owner.\n', '     * @param newWallet new address.\n', '     */\n', '    function setWallet(address payable newWallet) external onlyOwner {\n', '        require(newWallet != address(0), "New wallet is the zero address");\n', '\n', '        _wallet = newWallet;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to change the delay period of recieving tokens.\n', '     * Available only to the owner.\n', '     * @param newDelay new value (UNIX time).\n', '     */\n', '    function setDelayPeriod(uint256 newDelay) external onlyOwner {\n', '\n', '        _delay = newDelay;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to change the minimum amount (wei).\n', '     * Available only to the owner.\n', '     * @param newMinimum new minimum value (wei).\n', '     */\n', '    function setMinimum(uint256 newMinimum) external onlyOwner {\n', '        require(newMinimum != 0, "New parameter value is 0");\n', '\n', '        _minimum = newMinimum;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to pause recieving of deposits.\n', '     * Available only to the owner.\n', '     */\n', '    function pause() external onlyOwner {\n', '        require(!paused);\n', '\n', '        paused = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to unpause recieving of deposits.\n', '     * Available only to the owner.\n', '     */\n', '    function unpause() external onlyOwner {\n', '        require(paused);\n', '\n', '        paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to switch if referrer is required.\n', '     * Available only to the owner.\n', '     */\n', '    function switchRefSys() external onlyOwner {\n', '\n', '        if (RS == ReferrerSystem.ON) {\n', '            RS = ReferrerSystem.OFF;\n', '        } else {\n', '            RS = ReferrerSystem.ON;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function to switch the requiring of being referrer\n', '     * Available only to the owner.\n', '     */\n', '    function switchRequiringOfRef() external onlyOwner {\n', '\n', '        if (refRequired == true) {\n', '            refRequired = false;\n', '        } else {\n', '            refRequired = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function to switch if referral gets bonus\n', '     * Available only to the owner.\n', '     */\n', '    function switchReferralMode() external onlyOwner {\n', '\n', '        if (referralMode == true) {\n', '            referralMode = false;\n', '        } else {\n', '            referralMode = true;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Allows to withdraw needed ERC20 token from this contract (promo or bounties for example).\n', '    * Available only to the owner.\n', '    * @param ERC20Token Address of ERC20 token.\n', '    * @param recipient Account to receive tokens.\n', '    */\n', '    function withdrawERC20(address ERC20Token, address recipient) external onlyOwner {\n', '\n', '        uint256 amount = IERC20(ERC20Token).balanceOf(address(this));\n', '        IERC20(ERC20Token).transfer(recipient, amount);\n', '\n', '    }\n', '\n', '    /**\n', '     * @return the token being sold.\n', '     */\n', '    function token() public view returns (IERC20) {\n', '        return _token;\n', '    }\n', '\n', '    /**\n', '     * @return address of BonusMina.\n', '     */\n', '    function MPBS() public view returns (BonusMina) {\n', '        return _MPBS;\n', '    }\n', '\n', '    /**\n', '     * @return the address where funds are collected.\n', '     */\n', '    function wallet() public view returns (address payable) {\n', '        return _wallet;\n', '    }\n', '\n', '    /**\n', '     * @return the number of token units a buyer gets per wei.\n', '     */\n', '    function rate() public view returns (uint256) {\n', '        return _rate;\n', '    }\n', '\n', '    /**\n', '     * @return the number of token set as share.\n', '     */\n', '    function share() public view returns (uint256) {\n', '        return _share;\n', '    }\n', '\n', '    /**\n', '     * @return the number of token units a referrer gets per share.\n', '     */\n', '    function bonusPerShare() public view returns (uint256) {\n', '        return _bonusPerShare;\n', '    }\n', '\n', '    /**\n', '     * @return minimum amount of wei to invest.\n', '     */\n', '    function minimum() public view returns (uint256) {\n', '        return _minimum;\n', '    }\n', '\n', '    /**\n', '     * @return the amount of wei raised.\n', '     */\n', '    function weiRaised() public view returns (uint256) {\n', '        return _weiRaised;\n', '    }\n', '\n', '    /**\n', '     * @return the amount of reserved tokens.\n', '     */\n', '    function availableTokens() public view returns (uint256) {\n', '        if (_token.balanceOf(address(this)) > _reserve) {\n', '            return _token.balanceOf(address(this)).sub(_reserve);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @return the amount of reserved tokens.\n', '     */\n', '    function reserved() public view returns (uint256) {\n', '        return _reserve;\n', '    }\n', '\n', '    /**\n', '     * @return delay time (UNIX time).\n', '     */\n', '    function delay() public view returns (uint256) {\n', '        return _delay;\n', '    }\n', '\n', '}']