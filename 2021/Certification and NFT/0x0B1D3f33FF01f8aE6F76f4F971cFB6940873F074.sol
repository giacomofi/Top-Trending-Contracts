['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-25\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.3;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '}\n', '\n', '/// @title Contains 512-bit math functions\n', '/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n', '/// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits\n', 'library FullMath {\n', '    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n', '    /// @param a The multiplicand\n', '    /// @param b The multiplier\n', '    /// @param denominator The divisor\n', '    /// @return result The 256-bit result\n', '    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n', '    function mulDiv(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        // 512-bit multiply [prod1 prod0] = a * b\n', '        // Compute the product mod 2**256 and mod 2**256 - 1\n', '        // then use the Chinese Remainder Theorem to reconstruct\n', '        // the 512 bit result. The result is stored in two 256\n', '        // variables such that product = prod1 * 2**256 + prod0\n', '        uint256 prod0; // Least significant 256 bits of the product\n', '        uint256 prod1; // Most significant 256 bits of the product\n', '        assembly {\n', '            let mm := mulmod(a, b, not(0))\n', '            prod0 := mul(a, b)\n', '            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n', '        }\n', '\n', '        // Handle non-overflow cases, 256 by 256 division\n', '        if (prod1 == 0) {\n', '            require(denominator > 0);\n', '            assembly {\n', '                result := div(prod0, denominator)\n', '            }\n', '            return result;\n', '        }\n', '\n', '        // Make sure the result is less than 2**256.\n', '        // Also prevents denominator == 0\n', '        require(denominator > prod1);\n', '\n', '        ///////////////////////////////////////////////\n', '        // 512 by 256 division.\n', '        ///////////////////////////////////////////////\n', '\n', '        // Make division exact by subtracting the remainder from [prod1 prod0]\n', '        // Compute remainder using mulmod\n', '        uint256 remainder;\n', '        assembly {\n', '            remainder := mulmod(a, b, denominator)\n', '        }\n', '        // Subtract 256 bit number from 512 bit number\n', '        assembly {\n', '            prod1 := sub(prod1, gt(remainder, prod0))\n', '            prod0 := sub(prod0, remainder)\n', '        }\n', '\n', '        // Factor powers of two out of denominator\n', '        // Compute largest power of two divisor of denominator.\n', '        // Always >= 1.\n', '        uint256 twos = denominator & (~denominator + 1);\n', '        // Divide denominator by power of two\n', '        assembly {\n', '            denominator := div(denominator, twos)\n', '        }\n', '\n', '        // Divide [prod1 prod0] by the factors of two\n', '        assembly {\n', '            prod0 := div(prod0, twos)\n', '        }\n', '        // Shift in bits from prod1 into prod0. For this we need\n', '        // to flip `twos` such that it is 2**256 / twos.\n', '        // If twos is zero, then it becomes one\n', '        assembly {\n', '            twos := add(div(sub(0, twos), twos), 1)\n', '        }\n', '        prod0 |= prod1 * twos;\n', '\n', '        // Invert denominator mod 2**256\n', '        // Now that denominator is an odd number, it has an inverse\n', '        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n', '        // Compute the inverse by starting with a seed that is correct\n', '        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n', '        uint256 inv = (3 * denominator) ^ 2;\n', '        // Now use Newton-Raphson iteration to improve the precision.\n', "        // Thanks to Hensel's lifting lemma, this also works in modular\n", '        // arithmetic, doubling the correct bits in each step.\n', '        inv *= 2 - denominator * inv; // inverse mod 2**8\n', '        inv *= 2 - denominator * inv; // inverse mod 2**16\n', '        inv *= 2 - denominator * inv; // inverse mod 2**32\n', '        inv *= 2 - denominator * inv; // inverse mod 2**64\n', '        inv *= 2 - denominator * inv; // inverse mod 2**128\n', '        inv *= 2 - denominator * inv; // inverse mod 2**256\n', '\n', '        // Because the division is now exact we can divide by multiplying\n', '        // with the modular inverse of denominator. This will give us the\n', '        // correct result modulo 2**256. Since the precoditions guarantee\n', '        // that the outcome is less than 2**256, this is the final result.\n', "        // We don't need to compute the high bits of the result and prod1\n", '        // is no longer required.\n', '        result = prod0 * inv;\n', '        return result;\n', '    }\n', '\n', '    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n', '    /// @param a The multiplicand\n', '    /// @param b The multiplier\n', '    /// @param denominator The divisor\n', '    /// @return result The 256-bit result\n', '    function mulDivRoundingUp(\n', '        uint256 a,\n', '        uint256 b,\n', '        uint256 denominator\n', '    ) internal pure returns (uint256 result) {\n', '        result = mulDiv(a, b, denominator);\n', '        if (mulmod(a, b, denominator) > 0) {\n', '            require(result < type(uint256).max);\n', '            result++;\n', '        }\n', '    }\n', '}\n', '\n', 'interface IMinterReceiver {\n', '    function sharesMinted(\n', '        uint40 stakeId,\n', '        address supplier,\n', '        uint72 stakedHearts,\n', '        uint72 stakeShares\n', '    ) external;\n', '\n', '    function earningsMinted(uint40 stakeId, uint72 heartsEarned) external;\n', '}\n', '\n', 'contract ShareMarket is IMinterReceiver {\n', '    IERC20 public hexContract;\n', '    address public minterContract;\n', '\n', '    struct ShareOrder {\n', '        uint40 stakeId;\n', '        uint72 sharesPurchased;\n', '        address shareReceiver;\n', '    }\n', '    struct ShareListing {\n', '        uint72 heartsStaked;\n', '        uint72 sharesTotal;\n', '        uint72 sharesAvailable;\n', '        uint72 heartsEarned;\n', '        uint72 supplierHeartsOwed;\n', '        address supplier;\n', '        mapping(address => uint72) shareOwners;\n', '    }\n', '    mapping(uint40 => ShareListing) public shareListings;\n', '\n', '    event AddListing(\n', '        uint40 indexed stakeId,\n', '        address indexed supplier,\n', '        uint72 shares\n', '    );\n', '    event SharesUpdate(\n', '        uint40 indexed stakeId,\n', '        address indexed updater,\n', '        uint72 sharesAvailable\n', '    );\n', '    event AddEarnings(uint40 indexed stakeId, uint72 heartsEarned);\n', '    event BuyShares(\n', '        uint40 indexed stakeId,\n', '        address indexed owner,\n', '        uint72 sharesPurchased\n', '    );\n', '    event ClaimEarnings(\n', '        uint40 indexed stakeId,\n', '        address indexed claimer,\n', '        uint256 heartsClaimed\n', '    );\n', '    event SupplierWithdraw(\n', '        uint40 indexed stakeId,\n', '        address indexed supplier,\n', '        uint72 heartsWithdrawn\n', '    );\n', '\n', '    uint256 private unlocked = 1;\n', '    modifier lock() {\n', '        require(unlocked == 1, "LOCKED");\n', '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    constructor(IERC20 _hex, address _minter) {\n', '        hexContract = _hex;\n', '        minterContract = _minter;\n', '    }\n', '\n', '    function sharesOwned(uint40 stakeId, address owner)\n', '        public\n', '        view\n', '        returns (uint72 shares)\n', '    {\n', '        return shareListings[stakeId].shareOwners[owner];\n', '    }\n', '\n', '    function sharesMinted(\n', '        uint40 stakeId,\n', '        address supplier,\n', '        uint72 stakedHearts,\n', '        uint72 stakeShares\n', '    ) external override {\n', '        require(msg.sender == minterContract, "CALLER_NOT_MINTER");\n', '\n', '        ShareListing storage listing = shareListings[stakeId];\n', '        listing.heartsStaked = stakedHearts;\n', '        listing.sharesTotal = stakeShares;\n', '        listing.sharesAvailable = stakeShares;\n', '        listing.supplier = supplier;\n', '\n', '        emit AddListing(stakeId, supplier, stakeShares);\n', '    }\n', '\n', '    function earningsMinted(uint40 stakeId, uint72 heartsEarned)\n', '        external\n', '        override\n', '    {\n', '        require(msg.sender == minterContract, "CALLER_NOT_MINTER");\n', '\n', '        shareListings[stakeId].heartsEarned = heartsEarned;\n', '\n', '        emit AddEarnings(stakeId, heartsEarned);\n', '    }\n', '\n', '    function _buyShares(\n', '        uint40 stakeId,\n', '        address shareReceiver,\n', '        uint72 sharesPurchased\n', '    ) private returns (uint72 heartsOwed) {\n', '        require(sharesPurchased != 0, "INSUFFICIENT_SHARES_PURCHASED");\n', '\n', '        ShareListing storage listing = shareListings[stakeId];\n', '\n', '        require(\n', '            sharesPurchased <= listing.sharesAvailable,\n', '            "INSUFFICIENT_SHARES_AVAILABLE"\n', '        );\n', '\n', '        heartsOwed = uint72(\n', '            FullMath.mulDivRoundingUp(\n', '                sharesPurchased,\n', '                listing.heartsStaked,\n', '                listing.sharesTotal\n', '            )\n', '        );\n', '        require(heartsOwed > 0, "INSUFFICIENT_HEARTS_INPUT");\n', '\n', '        listing.sharesAvailable -= sharesPurchased;\n', '        emit SharesUpdate(stakeId, msg.sender, listing.sharesAvailable);\n', '\n', '        listing.shareOwners[shareReceiver] += sharesPurchased;\n', '        listing.supplierHeartsOwed += heartsOwed;\n', '        emit BuyShares(stakeId, shareReceiver, sharesPurchased);\n', '\n', '        return heartsOwed;\n', '    }\n', '\n', '    function multiBuyShares(ShareOrder[] memory orders) external lock {\n', '        uint256 orderCount = orders.length;\n', '        require(orderCount <= 30, "EXCEEDED_ORDER_LIMIT");\n', '\n', '        uint256 totalHeartsOwed;\n', '        for (uint256 i = 0; i < orderCount; i++) {\n', '            ShareOrder memory order = orders[i];\n', '            totalHeartsOwed += _buyShares(\n', '                order.stakeId,\n', '                order.shareReceiver,\n', '                order.sharesPurchased\n', '            );\n', '        }\n', '\n', '        hexContract.transferFrom(msg.sender, address(this), totalHeartsOwed);\n', '    }\n', '\n', '    function buyShares(\n', '        uint40 stakeId,\n', '        address shareReceiver,\n', '        uint72 sharesPurchased\n', '    ) external lock {\n', '        uint72 heartsOwed = _buyShares(stakeId, shareReceiver, sharesPurchased);\n', '        hexContract.transferFrom(msg.sender, address(this), heartsOwed);\n', '    }\n', '\n', '    function claimEarnings(uint40 stakeId) external lock {\n', '        ShareListing storage listing = shareListings[stakeId];\n', '        require(listing.heartsEarned != 0, "SHARES_NOT_MATURE");\n', '\n', '        uint72 ownedShares = listing.shareOwners[msg.sender];\n', '\n', '        if (msg.sender == listing.supplier) {\n', '            ownedShares += listing.sharesAvailable;\n', '            listing.sharesAvailable = 0;\n', '            emit SharesUpdate(stakeId, msg.sender, 0);\n', '        }\n', '\n', '        uint256 heartsOwed =\n', '            FullMath.mulDiv(\n', '                listing.heartsEarned,\n', '                ownedShares,\n', '                listing.sharesTotal\n', '            );\n', '        require(heartsOwed != 0, "NO_HEARTS_CLAIMABLE");\n', '\n', '        listing.shareOwners[msg.sender] = 0;\n', '        hexContract.transfer(msg.sender, heartsOwed);\n', '\n', '        emit ClaimEarnings(stakeId, msg.sender, heartsOwed);\n', '    }\n', '\n', '    function supplierWithdraw(uint40 stakeId) external lock {\n', '        ShareListing storage listing = shareListings[stakeId];\n', '        require(msg.sender == listing.supplier, "SENDER_NOT_SUPPLIER");\n', '\n', '        uint72 heartsOwed = listing.supplierHeartsOwed;\n', '        require(heartsOwed != 0, "NO_HEARTS_OWED");\n', '\n', '        listing.supplierHeartsOwed = 0;\n', '        hexContract.transfer(msg.sender, heartsOwed);\n', '\n', '        emit SupplierWithdraw(stakeId, msg.sender, heartsOwed);\n', '    }\n', '}']