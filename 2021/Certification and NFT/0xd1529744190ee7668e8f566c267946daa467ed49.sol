['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-26\n', '*/\n', '\n', '// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\n', '\n', 'pragma solidity ^0.6.6;\n', '\n', 'interface IArmorMaster {\n', '    function registerModule(bytes32 _key, address _module) external;\n', '    function getModule(bytes32 _key) external view returns(address);\n', '    function keep() external;\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' * \n', ' * @dev Completely default OpenZeppelin.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '    address private _pendingOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function initializeOwnable() internal {\n', '        require(_owner == address(0), "already initialized");\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "msg.sender is not owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _pendingOwner = newOwner;\n', '    }\n', '\n', '    function receiveOwnership() public {\n', '        require(msg.sender == _pendingOwner, "only pending owner can call this function");\n', '        _transferOwnership(_pendingOwner);\n', '        _pendingOwner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', 'library Bytes32 {\n', '    function toString(bytes32 x) internal pure returns (string memory) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint256 j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (uint256 j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\n', '**/\n', 'contract ArmorModule {\n', '    IArmorMaster internal _master;\n', '\n', '    using Bytes32 for bytes32;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == Ownable(address(_master)).owner(), "only owner can call this function");\n', '        _;\n', '    }\n', '\n', '    modifier doKeep() {\n', '        _master.keep();\n', '        _;\n', '    }\n', '\n', '    modifier onlyModule(bytes32 _module) {\n', '        string memory message = string(abi.encodePacked("only module ", _module.toString()," can call this function"));\n', '        require(msg.sender == getModule(_module), message);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Used when multiple can call.\n', '    **/\n', '    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\n', '        string memory message = string(abi.encodePacked("only module ", _moduleOne.toString()," or ", _moduleTwo.toString()," can call this function"));\n', '        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\n', '        _;\n', '    }\n', '\n', '    function initializeModule(address _armorMaster) internal {\n', '        require(address(_master) == address(0), "already initialized");\n', '        require(_armorMaster != address(0), "master cannot be zero address");\n', '        _master = IArmorMaster(_armorMaster);\n', '    }\n', '\n', '    function changeMaster(address _newMaster) external onlyOwner {\n', '        _master = IArmorMaster(_newMaster);\n', '    }\n', '\n', '    function getModule(bytes32 _key) internal view returns(address) {\n', '        return _master.getModule(_key);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' * \n', ' * @dev Default OpenZeppelin\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev These functions deal with verification of Merkle trees (hash trees),\n', ' */\n', 'library MerkleProof {\n', '  function calculateRoot(bytes32[] memory leaves) internal pure returns(bytes32) {\n', '    require(leaves.length > 0, "Cannot compute zero length");\n', '    bytes32[] memory elements = leaves;\n', '    bytes32[] memory nextLayer = new bytes32[]((elements.length+1)/2) ;\n', '    while(elements.length > 1) {\n', '      for(uint256 i = 0; i<elements.length;i+=2){\n', '        bytes32 left;\n', '        bytes32 right;\n', '        if(i == elements.length - 1){\n', '          left = elements[i];\n', '          right = elements[i];\n', '        }\n', '        else if(elements[i] <= elements[i+1]){\n', '          left = elements[i];\n', '          right = elements[i+1];\n', '        }\n', '        else {\n', '          left = elements[i+1];\n', '          right = elements[i];\n', '        }\n', '        bytes32 elem = keccak256(abi.encodePacked(left,right));\n', '        nextLayer[i/2] = elem;\n', '      }\n', '      elements = nextLayer;\n', '      nextLayer = new bytes32[]((elements.length+1)/2);\n', '    }\n', '    return elements[0];\n', '\n', '  }\n', '  /**\n', '   * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n', '   * defined by `root`. For this, a `proof` must be provided, containing\n', '   * sibling hashes on the branch from the leaf to the root of the tree. Each\n', '   * pair of leaves and each pair of pre-images are assumed to be sorted.\n', '   */\n', '  function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n', '    bytes32 computedHash = leaf;\n', '\n', '    for (uint256 i = 0; i < proof.length; i++) {\n', '      bytes32 proofElement = proof[i];\n', '\n', '      if (computedHash <= proofElement) {\n', '        // Hash(current computed hash + current element of the proof)\n', '        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n', '      } else {\n', '        // Hash(current element of the proof + current computed hash)\n', '        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n', '      }\n', '    }\n', '\n', '    // Check if the computed hash (root) is equal to the provided root\n', '    return computedHash == root;\n', '  }\n', '}\n', '\n', 'interface IStakeManager {\n', '    function totalStakedAmount(address protocol) external view returns(uint256);\n', '    function protocolAddress(uint64 id) external view returns(address);\n', '    function protocolId(address protocol) external view returns(uint64);\n', '    function initialize(address _armorMaster) external;\n', '    function allowedCover(address _newProtocol, uint256 _newTotalCover) external view returns (bool);\n', '    function subtractTotal(uint256 _nftId, address _protocol, uint256 _subtractAmount) external;\n', '}\n', '\n', 'interface IBalanceManager {\n', '  event Deposit(address indexed user, uint256 amount);\n', '  event Withdraw(address indexed user, uint256 amount);\n', '  event Loss(address indexed user, uint256 amount);\n', '  event PriceChange(address indexed user, uint256 price);\n', '  event AffiliatePaid(address indexed affiliate, address indexed referral, uint256 amount, uint256 timestamp);\n', '  event ReferralAdded(address indexed affiliate, address indexed referral, uint256 timestamp);\n', '  function expireBalance(address _user) external;\n', '  function deposit(address _referrer) external payable;\n', '  function withdraw(uint256 _amount) external;\n', '  function initialize(address _armormaster, address _devWallet) external;\n', '  function balanceOf(address _user) external view returns (uint256);\n', '  function perSecondPrice(address _user) external view returns(uint256);\n', '  function changePrice(address user, uint64 _newPricePerSec) external;\n', '}\n', '\n', 'interface IPlanManager {\n', '  // Mapping = protocol => cover amount\n', '  struct Plan {\n', '      uint64 startTime;\n', '      uint64 endTime;\n', '      uint128 length;\n', '  }\n', '  \n', '  struct ProtocolPlan {\n', '      uint64 protocolId;\n', '      uint192 amount;\n', '  }\n', '    \n', '  // Event to notify frontend of plan update.\n', '  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\n', '  function userCoverageLimit(address _user, address _protocol) external view returns(uint256);\n', '  function markup() external view returns(uint256);\n', '  function nftCoverPrice(address _protocol) external view returns(uint256);\n', '  function initialize(address _armorManager) external;\n', '  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\n', '  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\n', '  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\n', '  function coverageLeft(address _protocol) external view returns(uint256);\n', '  function getCurrentPlan(address _user) external view returns(uint256 idx, uint128 start, uint128 end);\n', '  function updateExpireTime(address _user, uint256 _expiry) external;\n', '  function planRedeemed(address _user, uint256 _planIndex, address _protocol) external;\n', '  function totalUsedCover(address _scAddress) external view returns (uint256);\n', '}\n', '\n', 'interface IClaimManager {\n', '    function initialize(address _armorMaster) external;\n', '    function transferNft(address _to, uint256 _nftId) external;\n', '    function exchangeWithdrawal(uint256 _amount) external;\n', '}\n', '\n', 'contract PlanManager is ArmorModule, IPlanManager {\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    uint256 constant private DENOMINATOR = 1000;\n', '    \n', '    // List of plans that a user has purchased so there is a historical record.\n', '    mapping (address => Plan[]) public plans;\n', '\n', '    // keccak256("ARMORFI.PLAN", address(user), uint256(planIdx), uint256(protocolIdx)) => ProtocolPlan\n', '    mapping (bytes32 => ProtocolPlan) public protocolPlan;\n', '    \n', '    // StakeManager calls this when a new NFT is added to update what the price for that protocol is.\n', '    // Cover price in ETH (1e18) of price per second per ETH covered.\n', '    mapping (address => uint256) public override nftCoverPrice;\n', '    \n', "    // Mapping to doKeep track of how much coverage we've sold for each protocol.\n", '    // smart contract address => total borrowed cover\n', '    mapping (address => uint256) public override totalUsedCover;\n', '    \n', '    // Protocol => amount of coverage bought by shields (then shields plus) for that protocol.\n', '    // Keep track of these to only allow a % of staked NFTs to be bought by each.\n', '    mapping (address => uint256) public arShieldCover;\n', '    mapping (address => uint256) public arShieldPlusCover;\n', '    mapping (address => uint256) public coreCover;\n', '    \n', '    // Percent allocated to each part of the system. 350 == 35%.\n', '    uint256 public arShieldPercent;\n', '    uint256 public arShieldPlusPercent;\n', '    uint256 public corePercent;\n', '    \n', "    // Mapping of the address of shields => 1 if they're arShield and 2 if they're arShieldPlus.\n", '    mapping (address => uint256) public arShields;\n', '    \n', "    // The amount of markup for Armor's service vs. the original cover cost. 200 == 200%.\n", '    uint256 public override markup;\n', '\n', '    modifier checkExpiry(address _user) {\n', '        IBalanceManager balanceManager = IBalanceManager(getModule("BALANCE"));\n', '        if(balanceManager.balanceOf(_user) == 0 ){\n', '            balanceManager.expireBalance(_user);\n', '        }\n', '        _;\n', '    }\n', '    \n', '    function initialize(\n', '        address _armorMaster\n', '    ) external override {\n', '        initializeModule(_armorMaster);\n', '        markup = 150;\n', '        arShieldPercent = 350;\n', '        arShieldPlusPercent = 350;\n', '        corePercent = 300;\n', '    }\n', '    \n', '    function getCurrentPlan(address _user) external view override returns(uint256 idx, uint128 start, uint128 end){\n', '        if(plans[_user].length == 0){\n', '            return(0,0,0);\n', '        }\n', '        Plan memory plan = plans[_user][plans[_user].length-1];\n', '        \n', '        //return 0 if there is no active plan\n', '        if(plan.endTime < now){\n', '            return(0,0,0);\n', '        } else {\n', '            idx = plans[_user].length - 1;\n', '            start = plan.startTime;\n', '            end = plan.endTime;\n', '        }\n', '    }\n', '\n', '    function getProtocolPlan(address _user, uint256 _idx, address _protocol) external view returns(uint256 idx, uint64 protocolId, uint192 amount) {\n', '        IStakeManager stakeManager = IStakeManager(getModule("STAKE"));\n', '        uint256 length = plans[_user][_idx].length;\n', '        for(uint256 i = 0; i<length; i++){\n', '            ProtocolPlan memory protocol = protocolPlan[_hashKey(_user, _idx, i)];\n', '            address addr = stakeManager.protocolAddress(protocol.protocolId);\n', '            if(addr == _protocol){\n', '                return (i, protocol.protocolId, protocol.amount);\n', '            }\n', '        }\n', '        return(0,0,0);\n', '    }\n', '\n', '    function userCoverageLimit(address _user, address _protocol) external view override returns(uint256){\n', '        IStakeManager stakeManager = IStakeManager(getModule("STAKE"));\n', '        uint64 protocolId = stakeManager.protocolId(_protocol);\n', '       \n', '        uint256 idx = plans[_user].length - 1;\n', '        uint256 currentCover = 0;\n', '        if(idx != uint256(-1)){ \n', '            Plan memory plan = plans[_user][idx];\n', '            uint256 length = uint256( plan.length );\n', '\n', '            for (uint256 i = 0; i < length; i++) {\n', '                ProtocolPlan memory protocol = protocolPlan[ _hashKey(_user, idx, i) ];\n', '                if (protocol.protocolId == protocolId) currentCover = uint256( protocol.amount );\n', '            }\n', '        }\n', '\n', '        uint256 extraCover = coverageLeft(_protocol);\n', '\n', "        // Add current coverage because coverageLeft on planManager does not include what we're currently using.\n", '        return extraCover.add(currentCover);\n', '    }\n', '\n', '    /*\n', '     * @dev User can update their plan for cover amount on any protocol.\n', '     * @param _protocols Addresses of the protocols that we want coverage for.\n', '     * @param _coverAmounts The amount of coverage desired in WEI.\n', "     * @notice Let's simplify this somehow--even just splitting into different functions.\n", '    **/\n', '    function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts)\n', '      external\n', '      override\n', '      checkExpiry(msg.sender)\n', '      // doKeep\n', '    {\n', '        require(_protocols.length == _coverAmounts.length, "protocol and coverAmount length mismatch");\n', '        require(_protocols.length <= 30, "You may not protect more than 30 protocols at once.");\n', '        IBalanceManager balanceManager = IBalanceManager(getModule("BALANCE"));\n', '        \n', '        // Need to get price of the protocol here\n', '        if(plans[msg.sender].length > 0){\n', '          Plan storage lastPlan = plans[msg.sender][plans[msg.sender].length - 1];\n', '\n', '          // this should happen only when plan is not expired yet\n', '          if(lastPlan.endTime > now) {\n', '              // First go through and subtract all old cover amounts.\n', '              _removeLatestTotals(msg.sender);\n', '              lastPlan.endTime = uint64(now);\n', '          }\n', '        }\n', '\n', '        _addNewTotals(_protocols, _coverAmounts);\n', '        uint256 newPricePerSec;\n', '        uint256 _markup = markup;\n', '        \n', '        // Loop through protocols, find price per second, add to rate, add coverage amount to mapping.\n', '        for (uint256 i = 0; i < _protocols.length; i++) {\n', '            require(nftCoverPrice[_protocols[i]] != 0, "Protocol price is zero");\n', '            \n', '            // nftCoverPrice is Wei per second per full Ether, so a cover amont in Wei. This is divided after this loop.\n', '            uint256 pricePerSec = nftCoverPrice[ _protocols[i] ].mul(_coverAmounts[i]);\n', '            newPricePerSec = newPricePerSec.add(pricePerSec);\n', '        }\n', '        \n', '        //newPricePerSec = newPricePerSec * _markup / 1e18 for decimals / 100 to make up for markup (200 == 200%);\n', '        newPricePerSec = newPricePerSec.mul(_markup).div(1e18).div(100);\n', '        \n', '        // this means user is canceling all plans\n', '        if(newPricePerSec == 0){\n', '            Plan memory newPlan;\n', '            newPlan = Plan(uint64(now), uint64(-1), uint128(0));\n', '            plans[msg.sender].push(newPlan);\n', '            balanceManager.changePrice(msg.sender, 0);\n', '            emit PlanUpdate(msg.sender, _protocols, _coverAmounts, uint64(-1));\n', '            return;\n', '        }\n', '\n', '        uint256 endTime = balanceManager.balanceOf(msg.sender).div(newPricePerSec).add(block.timestamp);\n', '        \n', "        // Let's make sure a user can pay for this for at least a week. Weird manipulation of utilization farming could happen otherwise.\n", '        require(endTime >= block.timestamp.add(7 days), "Balance must be enough for 7 days of coverage.");\n', '        \n', '        //add plan\n', '        Plan memory newPlan;\n', '        newPlan = Plan(uint64(now), uint64(endTime), uint128(_protocols.length));\n', '        plans[msg.sender].push(newPlan);\n', '        \n', '        //add protocol plan\n', '        for(uint256 i = 0;i<_protocols.length; i++){\n', '            bytes32 key = _hashKey(msg.sender, plans[msg.sender].length - 1, i);\n', '            uint64 protocolId = IStakeManager(getModule("STAKE")).protocolId(_protocols[i]);\n', '            protocolPlan[key] = ProtocolPlan(protocolId, uint192(_coverAmounts[i]));\n', '        }\n', '        \n', '        // update balance price per second here\n', '        uint64 castPricePerSec = uint64(newPricePerSec);\n', '        require(uint256(castPricePerSec) == newPricePerSec);\n', '        IBalanceManager(getModule("BALANCE")).changePrice(msg.sender, castPricePerSec);\n', '\n', '        emit PlanUpdate(msg.sender, _protocols, _coverAmounts, endTime);\n', '    }\n', '\n', '    /**\n', '     * @dev Update the contract-wide totals for each protocol that has changed.\n', '     * @param _user User whose plan is updating these totals.\n', '    **/\n', '    function _removeLatestTotals(address _user) internal {\n', '        Plan storage plan = plans[_user][plans[_user].length - 1];\n', '\n', '        uint256 idx = plans[_user].length - 1;\n', '\n', '        for (uint256 i = 0; i < plan.length; i++) {\n', '            bytes32 key = _hashKey(_user, idx, i);\n', '            ProtocolPlan memory protocol = protocolPlan[key];\n', '            address protocolAddress = IStakeManager(getModule("STAKE")).protocolAddress(protocol.protocolId);\n', '            totalUsedCover[protocolAddress] = totalUsedCover[protocolAddress].sub(uint256(protocol.amount));\n', '            \n', '            uint256 shield = arShields[_user];\n', '            if (shield == 1) {\n', '                arShieldCover[protocolAddress] = arShieldCover[protocolAddress].sub(protocol.amount);\n', '            } else if (shield == 2) {\n', '                arShieldPlusCover[protocolAddress] = arShieldPlusCover[protocolAddress].sub(protocol.amount);\n', '            } else {\n', '                coreCover[protocolAddress] = coreCover[protocolAddress].sub(protocol.amount);\n', '            }   \n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Add new totals for new protocol/cover amounts.\n', '     * @param _newProtocols Protocols that are being borrowed for.\n', '     * @param _newCoverAmounts Cover amounts (in Wei) that are being borrowed.\n', '    **/\n', '    function _addNewTotals(address[] memory _newProtocols, uint256[] memory _newCoverAmounts) internal {\n', '        for (uint256 i = 0; i < _newProtocols.length; i++) {\n', '            \n', '            (uint256 shield, uint256 allowed) = _checkBuyerAllowed(_newProtocols[i]);\n', '            require(allowed >= _newCoverAmounts[i], "Exceeds allowed cover amount.");\n', '            \n', '            totalUsedCover[_newProtocols[i]] = totalUsedCover[_newProtocols[i]].add(_newCoverAmounts[i]);\n', '            \n', '            if (shield == 1) {\n', '                arShieldCover[_newProtocols[i]] = arShieldCover[_newProtocols[i]].add(_newCoverAmounts[i]);\n', '            } else if (shield == 2) {\n', '                arShieldPlusCover[_newProtocols[i]] = arShieldPlusCover[_newProtocols[i]].add(_newCoverAmounts[i]);\n', '            } else {\n', '                coreCover[_newProtocols[i]] = coreCover[_newProtocols[i]].add(_newCoverAmounts[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Determine the amount of coverage left for a specific protocol.\n', "     * @param _protocol The address of the protocol we're determining coverage left for.\n", '    **/\n', '    function coverageLeft(address _protocol)\n', '      public\n', '      override\n', '      view\n', '    returns (uint256) {\n', '        (/* uint256 shield */, uint256 allowed) = _checkBuyerAllowed(_protocol);\n', '        return allowed;\n', '    }\n', '    \n', '    /**\n', '     * @dev Check whether the buyer is allowed to purchase this amount of cover.\n', '     *      Used because core can only buy 30%, and 35% for shields.\n', '     * @param _protocol The protocol cover is being purchased for.\n', '    **/\n', '    function _checkBuyerAllowed(address _protocol)\n', '      internal\n', '      view\n', '    returns (uint256, uint256)\n', '    {\n', '        uint256 totalAllowed = IStakeManager(getModule("STAKE")).totalStakedAmount(_protocol);\n', '        uint256 shield = arShields[msg.sender];\n', '            \n', '        if (shield == 1) {\n', '            uint256 currentCover = arShieldCover[_protocol];\n', '            uint256 allowed = totalAllowed * arShieldPercent / DENOMINATOR;\n', '            return (shield, allowed > currentCover ? allowed - currentCover : 0);\n', '        } else if (shield == 2) {\n', '            uint256 currentCover = arShieldPlusCover[_protocol];\n', '            uint256 allowed = totalAllowed * arShieldPlusPercent / DENOMINATOR;\n', '            return (shield, allowed > currentCover ? allowed - currentCover : 0);\n', '        } else {\n', '            uint256 currentCover = coreCover[_protocol];\n', '            uint256 allowed = totalAllowed * corePercent / DENOMINATOR;\n', '            return (shield, allowed > currentCover ? allowed - currentCover : 0);        \n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev Used by ClaimManager to check how much coverage the user had at the time of a hack.\n', '     * @param _user The user to check coverage for.\n', '     * @param _protocol The address of the protocol that was hacked. (Address used according to arNFT).\n', '     * @param _hackTime The timestamp of when a hack happened.\n', '     * @return index index of plan for hackTime\n', '     * @return check whether amount is allowed\n', '    **/\n', '    function checkCoverage(address _user, address _protocol, uint256 _hackTime, uint256 _amount)\n', '      external\n', '      view\n', '      override\n', '      returns(uint256 index, bool check)\n', '    {\n', "        // This may be more gas efficient if we don't grab this first but instead grab each plan from storage individually?\n", '        Plan[] storage planArray = plans[_user];\n', '        \n', '        // In normal operation, this for loop should never get too big.\n', '        // If it does (from malicious action), the user will be the only one to suffer.\n', '        for (int256 i = int256(planArray.length - 1); i >= 0; i--) {\n', '            Plan storage plan = planArray[uint256(i)];\n', '            // Only one plan will be active at the time of a hack--return cover amount from then.\n', '            if (_hackTime >= plan.startTime && _hackTime < plan.endTime) {\n', '                for(uint256 j = 0; j< plan.length; j++){\n', '                    bytes32 key = _hashKey(_user, uint256(i), j);\n', '                    if(IStakeManager(getModule("STAKE")).protocolAddress(protocolPlan[key].protocolId) == _protocol){\n', '                        return (uint256(i), _amount <= uint256(protocolPlan[key].amount));\n', '                    }\n', '                }\n', '                return (uint256(i), false);\n', '            }\n', '        }\n', '        return (uint256(-1), false);\n', '    }\n', '\n', '    /**\n', '     * @dev ClaimManager redeems the plan if it has been claimed. Sets claim amount to 0 so it cannot be claimed again.\n', '     * @param _user User that is redeeming this plan.\n', "     * @param _planIndex The index in the user's Plan array that we're checking.\n", '     * @param _protocol Address of the protocol that a claim is being redeemed for.\n', '    **/\n', '    function planRedeemed(address _user, uint256 _planIndex, address _protocol) \n', '      external \n', '      override \n', '      onlyModule("CLAIM")\n', '    {\n', '        Plan storage plan = plans[_user][_planIndex];\n', '        require(plan.endTime <= now, "Cannot redeem active plan, update plan to redeem properly.");\n', '\n', '        for (uint256 i = 0; i < plan.length; i++) {\n', '            bytes32 key = _hashKey(_user,_planIndex,i);\n', '            \n', '            ProtocolPlan memory protocol = protocolPlan[key];\n', '            address protocolAddress = IStakeManager(getModule("STAKE")).protocolAddress(protocol.protocolId);\n', '            \n', '            if (protocolAddress == _protocol) protocolPlan[key].amount = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Armor has the ability to change the price that a user is paying for their insurance.\n', '     * @param _protocol The protocol whose arNFT price is being updated.\n', '     * @param _newPrice the new price PER SECOND that the user will be paying.\n', '    **/\n', '    function changePrice(address _protocol, uint256 _newPrice)\n', '      external\n', '      override\n', '      onlyModule("STAKE")\n', '    {\n', '        nftCoverPrice[_protocol] = _newPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev BalanceManager calls to update expire time of a plan when a deposit/withdrawal happens.\n', '     * @param _user Address whose balance was updated.\n', '     * @param _expiry New time plans expire.\n', '    **/\n', '    function updateExpireTime(address _user, uint256 _expiry)\n', '      external\n', '      override\n', '      onlyModule("BALANCE")\n', '    {\n', '        if (plans[_user].length == 0) return;\n', '        Plan storage plan = plans[_user][plans[_user].length-1];\n', '        if (plan.endTime > block.timestamp && _expiry <= block.timestamp) _removeLatestTotals(_user);\n', '        plan.endTime = uint64(_expiry);\n', '    }\n', '    \n', '    /**\n', '     * @dev Hash for protocol info identifier.\n', '     * @param _user Address of the user.\n', "     * @param _planIndex Index of the plan in the user's plan array.\n", '     * @param _protoIndex Index of the protocol in the plan.\n', '     * @return Hash for identifier for protocolPlan mapping.\n', '    **/\n', '    function _hashKey(address _user, uint256 _planIndex, uint256 _protoIndex)\n', '      internal\n', '      pure\n', '    returns (bytes32)\n', '    {\n', '        return keccak256(abi.encodePacked("ARMORFI.PLAN.", _user, _planIndex, _protoIndex));\n', '    }\n', '    \n', '    /**\n', '     * @dev Owner (DAO) can adjust the markup buyers pay for coverage.\n', '     * @param _newMarkup The new markup that will be used. 100 == 100% (no markup).\n', '    **/\n', '    function adjustMarkup(uint256 _newMarkup)\n', '      external\n', '      onlyOwner\n', '    {\n', '        require(_newMarkup >= 100, "Markup must be at least 0 (100%).");\n', '        markup = _newMarkup;\n', '    }\n', '    \n', '    /**\n', '     * @dev Owner (DAO) can adjust the percent of coverage allowed for each product.\n', '     * @param _newCorePercent New percent of coverage for general arCore users.\n', '     * @param _newArShieldPercent New percent of coverage for arShields.\n', '     * @param _newArShieldPlusPercent New percent of coverage for arShield Plus.\n', '    **/\n', '    function adjustPercents(uint256 _newCorePercent, uint256 _newArShieldPercent, uint256 _newArShieldPlusPercent)\n', '      external\n', '      onlyOwner\n', '    {\n', '        require(_newCorePercent + _newArShieldPercent + _newArShieldPlusPercent == 1000, "Total allocation cannot be more than 100%.");\n', '        corePercent = _newCorePercent;\n', '        arShieldPercent = _newArShieldPercent;\n', '        arShieldPlusPercent = _newArShieldPlusPercent;\n', '    }\n', '    \n', '    /**\n', '     * @dev Owner (DAO) can adjust shields on the contract.\n', "     * @param _shieldAddress Array of addresses we're adjusting.\n", '     * @param _shieldType Type of shield: 1 for arShield, 2 for arShield Plus.\n', '    **/\n', '    function adjustShields(address[] calldata _shieldAddress, uint256[] calldata _shieldType)\n', '      external\n', '      onlyOwner\n', '    {\n', '        require(_shieldAddress.length == _shieldType.length, "Submitted arrays are not of equal length.");\n', '        for (uint256 i = 0; i < _shieldAddress.length; i++) {\n', '            arShields[_shieldAddress[i]] = _shieldType[i];\n', '        }\n', '    }\n', '\n', '    function forceAdjustTotalUsedCover(address[] calldata _protocols, uint256[] calldata _usedCovers) external onlyOwner {\n', '        for(uint256 i = 0; i<_protocols.length; i++){\n', '            totalUsedCover[_protocols[i]] = _usedCovers[i];\n', '        }\n', '    }\n', '}']