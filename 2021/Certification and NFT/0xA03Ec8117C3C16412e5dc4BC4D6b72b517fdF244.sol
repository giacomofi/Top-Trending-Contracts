['// SPDX-License-Identifier: UNLICENSED\n', '// ALL RIGHTS RESERVED\n', '\n', '// Forked from Uniswap Ethereum mainnet for Sushiswap on Ethereum Mainnet\n', '\n', '/**\n', '    This contract creates the lock on behalf of each presale. This contract will be whitelisted to bypass the flat rate \n', '    ETH fee. Please do not use the below locking code in your own contracts as the lock will fail without the ETH fee\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./Ownable.sol";\n', 'import "./TransferHelper.sol";\n', 'import "./IERC20.sol";\n', '\n', 'interface IPresaleFactory {\n', '    function registerPresale (address _presaleAddress) external;\n', '    function presaleIsRegistered(address _presaleAddress) external view returns (bool);\n', '}\n', '\n', 'interface IUniswapV2Locker {\n', '    function lockLPToken (address _lpToken, uint256 _amount, uint256 _unlock_date, address payable _referral, bool _fee_in_eth, address payable _withdrawer) external payable;\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'contract PresaleLockForwarder is Ownable {\n', '    \n', '    IPresaleFactory public PRESALE_FACTORY;\n', '    IUniswapV2Locker public UNICRYPT_LOCKER;\n', '    IUniswapV2Factory public UNI_FACTORY;\n', '    \n', '    constructor() public {\n', '        PRESALE_FACTORY = IPresaleFactory(0xcEE32dA23A4Ea61F6217B19d84fe63E077AF5990);\n', '        UNICRYPT_LOCKER = IUniswapV2Locker(0xED9180976c2a4742C7A57354FD39d8BEc6cbd8AB);\n', '        UNI_FACTORY = IUniswapV2Factory(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n', '    }\n', '\n', '    /**\n', '        Send in _token0 as the PRESALE token, _token1 as the BASE token (usually WETH) for the check to work. As anyone can create a pair,\n', '        and send WETH to it while a presale is running, but no one should have access to the presale token. If they do and they send it to \n', '        the pair, scewing the initial liquidity, this function will return true\n', '    */\n', '    function uniswapPairIsInitialised (address _token0, address _token1) public view returns (bool) {\n', '        address pairAddress = UNI_FACTORY.getPair(_token0, _token1);\n', '        if (pairAddress == address(0)) {\n', '            return false;\n', '        }\n', '        uint256 balance = IERC20(_token0).balanceOf(pairAddress);\n', '        if (balance > 0) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    \n', '    function lockLiquidity (IERC20 _baseToken, IERC20 _saleToken, uint256 _baseAmount, uint256 _saleAmount, uint256 _unlock_date, address payable _withdrawer) external {\n', "        require(PRESALE_FACTORY.presaleIsRegistered(msg.sender), 'PRESALE NOT REGISTERED');\n", '        address pair = UNI_FACTORY.getPair(address(_baseToken), address(_saleToken));\n', '        if (pair == address(0)) {\n', '            UNI_FACTORY.createPair(address(_baseToken), address(_saleToken));\n', '            pair = UNI_FACTORY.getPair(address(_baseToken), address(_saleToken));\n', '        }\n', '        \n', '        TransferHelper.safeTransferFrom(address(_baseToken), msg.sender, address(pair), _baseAmount);\n', '        TransferHelper.safeTransferFrom(address(_saleToken), msg.sender, address(pair), _saleAmount);\n', '        IUniswapV2Pair(pair).mint(address(this));\n', '        uint256 totalLPTokensMinted = IUniswapV2Pair(pair).balanceOf(address(this));\n', '        require(totalLPTokensMinted != 0 , "LP creation failed");\n', '    \n', '        TransferHelper.safeApprove(pair, address(UNICRYPT_LOCKER), totalLPTokensMinted);\n', '        uint256 unlock_date = _unlock_date > 9999999999 ? 9999999999 : _unlock_date;\n', '        UNICRYPT_LOCKER.lockLPToken(pair, totalLPTokensMinted, unlock_date, address(0), true, _withdrawer);\n', '    }\n', '    \n', '}']