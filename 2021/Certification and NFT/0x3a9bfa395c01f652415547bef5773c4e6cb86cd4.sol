['// SPDX-License-Identifier: agpl-3.0\n', '// PreachersUniSwapLkup v1.0.10\n', 'pragma solidity ^0.8.6;\n', '\n', 'import { IERC20, IUniswapV2Router02, IUniswapV2Factory,\n', '    IUniswapV2Pair, IWETH } from "Interfaces.sol";\n', '\n', '// https://uniswap.org/docs/v2/smart-contracts/router02/\n', '// Same address on Mainnet and Kovan\n', 'address constant UNISWAP_ROUTER_ADDRESS = address( 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D );\n', 'address constant kUniswapV2Factory = address( 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f );\n', '\n', 'address constant kETH = address( 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE );\n', 'address constant ETH = address( 0 );    // preferred by UniSwap\n', '\n', '// address constant kWETH = address( 0xd0A1E359811322d97991E03f863a0C30C2cF029C ); // Kovan\n', 'address constant kWETH = address( 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 ); // Mainnet\n', '\n', '\n', 'contract PreachersUniSwapLkup {\n', '\n', '    IUniswapV2Factory constant uniswapV2Factory = IUniswapV2Factory( kUniswapV2Factory ); // same for all networks\n', '\n', '\n', '    function GetTriPair( address _tokenBorrow, address _tokenPay ) public {\n', '        \n', '        address borrowPairAddress = GetUniPairAddress( address( _tokenBorrow ), kWETH );\n', '        address payPairAddress = GetUniPairAddress( address( _tokenPay ), kWETH );\n', '        \n', '        emit PairAddr( borrowPairAddress, payPairAddress );\n', '\n', '        return;\n', '    }\n', '    \n', '    function CreateTriPair( address _tokenBorrow, address _tokenPay )\n', '        public {\n', '            \n', '        // Does _tokenBorrow => kWETH pair exist?\n', '        address TokenBorrow = address( _tokenBorrow );\n', '        address TokenPay = address( _tokenPay );\n', '        \n', '        address borrowPairAddress = uniswapV2Factory.getPair( TokenBorrow, kWETH );\n', '        if ( borrowPairAddress == address( 0 ) ){\n', '            borrowPairAddress = uniswapV2Factory.createPair( TokenBorrow, kWETH );\n', '        }\n', '        \n', '        address payPairAddress = uniswapV2Factory.getPair( TokenPay, kWETH );\n', '        if ( payPairAddress == address( 0 ) ){\n', '            payPairAddress = uniswapV2Factory.createPair( TokenPay, kWETH );\n', '        }\n', '        \n', '        emit PairAddr( borrowPairAddress, payPairAddress );\n', '        return;\n', '        \n', '    }\n', '    \n', '    function GetUniPairAddress( address token0, address token1 ) public pure returns( address _pair ){\n', '        \n', '        address PairAddress = address( uint160( uint( keccak256( abi.encodePacked(\n', "            hex'ff',\n", '            kUniswapV2Factory,\n', '            keccak256( abi.encodePacked( address( token0 ), address( token1 ) ) ),\n', "            hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f'\n", '            ) ) ) ) );\n', '        return PairAddress;\n', '    }\n', '    \n', '    function GetTriPairSupply( address _tokenBorrow, address _tokenPay ) public {\n', '        \n', '        address TokenBorrow = address( _tokenBorrow );\n', '        address TokenPay = address( _tokenPay );\n', '        \n', '        uint256 Supply1 = 0;\n', '        uint256 Supply2 = 0;\n', '\n', '        address borrowPairAddress = GetUniPairAddress( TokenBorrow, kWETH );\n', '        if ( borrowPairAddress != address( 0 )){\n', '            IUniswapV2Pair Pair1 = IUniswapV2Pair( borrowPairAddress );\n', '\n', '            Supply1 = Pair1.totalSupply();\n', '        } else {\n', '            Supply1 = 99;\n', '        }\n', '        \n', '        address payPairAddress = GetUniPairAddress( TokenPay, kWETH );\n', '        if ( payPairAddress != address( 0 )){\n', '            IUniswapV2Pair Pair2 = IUniswapV2Pair( payPairAddress );\n', '\n', '            Supply2 = Pair2.totalSupply();\n', '        } else {\n', '            Supply2 = 99;\n', '        }\n', '        emit Pair( Supply1, Supply2 );\n', '        return;\n', '    }\n', '    \n', '    function GetTriPairBalance( address _tokenBorrow, address _tokenPay ) public\n', '        returns ( uint256 _Balance1, uint256 _Balance2 ){\n', '        \n', '        address TokenBorrow = address( _tokenBorrow );\n', '        address TokenPay = address( _tokenPay );\n', '\n', '        uint256 Balance1 = 0;\n', '        uint256 Balance2 = 0;\n', '        \n', '        address borrowPairAddress = GetUniPairAddress( TokenBorrow, kWETH );\n', '        if ( borrowPairAddress != address( 0 )){\n', '            Balance1 = IERC20( TokenBorrow ).balanceOf( borrowPairAddress );\n', '        } else {\n', '            Balance1 = 99;\n', '        }\n', '        \n', '        address payPairAddress = GetUniPairAddress( TokenPay, kWETH );\n', '        if ( payPairAddress != address( 0 )){\n', '            Balance2 = IERC20( TokenPay ).balanceOf( payPairAddress );\n', '        } else {\n', '            Balance2 = 99;\n', '        }\n', '        emit Pair( Balance1, Balance2 );\n', '        return ( Balance1, Balance2 );\n', '    \n', '    }\n', '    event Pair( uint256 amount1, uint256 _amount2 );\n', '    event PairAddr( address Pair1, address Pair2 );\n', '}']