['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-19\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.2;\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '}\n', '\n', 'interface IKeep3rV1 {\n', '    function keepers(address keeper) external returns (bool);\n', '    function KPRH() external view returns (IKeep3rV1Helper);\n', '    function receipt(address credit, address keeper, uint amount) external;\n', '}\n', '\n', 'interface IKeep3rV1Helper {\n', '    function getQuoteLimit(uint gasUsed) external view returns (uint);\n', '}\n', '\n', '// sliding oracle that uses observations collected to provide moving price averages in the past\n', 'contract Keep3rV2Oracle {\n', '\n', '    constructor(address _pair) {\n', '        _factory = msg.sender;\n', '        pair = _pair;\n', '        (,,uint32 timestamp) = IUniswapV2Pair(_pair).getReserves();\n', '        uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(_pair).price0CumulativeLast() * e10 / Q112);\n', '        uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(_pair).price1CumulativeLast() * e10 / Q112);\n', '        observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n', '    }\n', '\n', '    struct Observation {\n', '        uint32 timestamp;\n', '        uint112 price0Cumulative;\n', '        uint112 price1Cumulative;\n', '    }\n', '\n', '    modifier factory() {\n', '        require(msg.sender == _factory, "!F");\n', '        _;\n', '    }\n', '\n', '    Observation[65535] public observations;\n', '    uint16 public length;\n', '\n', '    address immutable _factory;\n', '    address immutable public pair;\n', '    // this is redundant with granularity and windowSize, but stored for gas savings & informational purposes.\n', '    uint constant periodSize = 1800;\n', '    uint Q112 = 2**112;\n', '    uint e10 = 10**18;\n', '\n', '    // Pre-cache slots for cheaper oracle writes\n', '    function cache(uint size) external {\n', '        uint _length = length+size;\n', '        for (uint i = length; i < _length; i++) observations[i].timestamp = 1;\n', '    }\n', '\n', '    // update the current feed for free\n', '    function update() external factory returns (bool) {\n', '        return _update();\n', '    }\n', '\n', '    function updateable() external view returns (bool) {\n', '        Observation memory _point = observations[length-1];\n', '        (,, uint timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        uint timeElapsed = timestamp - _point.timestamp;\n', '        return timeElapsed > periodSize;\n', '    }\n', '\n', '    function _update() internal returns (bool) {\n', '        Observation memory _point = observations[length-1];\n', '        (,, uint32 timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        uint32 timeElapsed = timestamp - _point.timestamp;\n', '        if (timeElapsed > periodSize) {\n', '            uint112 _price0CumulativeLast = uint112(IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112);\n', '            uint112 _price1CumulativeLast = uint112(IUniswapV2Pair(pair).price1CumulativeLast() * e10 / Q112);\n', '            observations[length++] = Observation(timestamp, _price0CumulativeLast, _price1CumulativeLast);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function _computeAmountOut(uint start, uint end, uint elapsed, uint amountIn) internal view returns (uint amountOut) {\n', '        amountOut = amountIn * (end - start) / e10 / elapsed;\n', '    }\n', '\n', '    function current(address tokenIn, uint amountIn, address tokenOut) external view returns (uint amountOut, uint lastUpdatedAgo) {\n', '        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '\n', '        Observation memory _observation = observations[length-1];\n', '        uint price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast() * e10 / Q112;\n', '        uint price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast() * e10 / Q112;\n', '        (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\n', '\n', '        // Handle edge cases where we have no updates, will revert on first reading set\n', '        if (timestamp == _observation.timestamp) {\n', '            _observation = observations[length-2];\n', '        }\n', '\n', '        uint timeElapsed = timestamp - _observation.timestamp;\n', '        timeElapsed = timeElapsed == 0 ? 1 : timeElapsed;\n', '        if (token0 == tokenIn) {\n', '            amountOut = _computeAmountOut(_observation.price0Cumulative, price0Cumulative, timeElapsed, amountIn);\n', '        } else {\n', '            amountOut = _computeAmountOut(_observation.price1Cumulative, price1Cumulative, timeElapsed, amountIn);\n', '        }\n', '        lastUpdatedAgo = timeElapsed;\n', '    }\n', '\n', '    function quote(address tokenIn, uint amountIn, address tokenOut, uint points) external view returns (uint amountOut, uint lastUpdatedAgo) {\n', '        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '\n', '        uint priceAverageCumulative = 0;\n', '        uint _length = length-1;\n', '        uint i = _length - points;\n', '        Observation memory currentObservation;\n', '        Observation memory nextObservation;\n', '\n', '        uint nextIndex = 0;\n', '        if (token0 == tokenIn) {\n', '            for (; i < _length; i++) {\n', '                nextIndex = i+1;\n', '                currentObservation = observations[i];\n', '                nextObservation = observations[nextIndex];\n', '                priceAverageCumulative += _computeAmountOut(\n', '                    currentObservation.price0Cumulative,\n', '                    nextObservation.price0Cumulative,\n', '                    nextObservation.timestamp - currentObservation.timestamp, amountIn);\n', '            }\n', '        } else {\n', '            for (; i < _length; i++) {\n', '                nextIndex = i+1;\n', '                currentObservation = observations[i];\n', '                nextObservation = observations[nextIndex];\n', '                priceAverageCumulative += _computeAmountOut(\n', '                    currentObservation.price1Cumulative,\n', '                    nextObservation.price1Cumulative,\n', '                    nextObservation.timestamp - currentObservation.timestamp, amountIn);\n', '            }\n', '        }\n', '        amountOut = priceAverageCumulative / points;\n', '\n', '        (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\n', '        lastUpdatedAgo = timestamp - nextObservation.timestamp;\n', '    }\n', '\n', '    function sample(address tokenIn, uint amountIn, address tokenOut, uint points, uint window) external view returns (uint[] memory prices, uint lastUpdatedAgo) {\n', '        (address token0,) = tokenIn < tokenOut ? (tokenIn, tokenOut) : (tokenOut, tokenIn);\n', '        prices = new uint[](points);\n', '\n', '        if (token0 == tokenIn) {\n', '            {\n', '                uint _length = length-1;\n', '                uint i = _length - (points * window);\n', '                uint _index = 0;\n', '                Observation memory nextObservation;\n', '                for (; i < _length; i+=window) {\n', '                    Observation memory currentObservation;\n', '                    currentObservation = observations[i];\n', '                    nextObservation = observations[i + window];\n', '                    prices[_index] = _computeAmountOut(\n', '                        currentObservation.price0Cumulative,\n', '                        nextObservation.price0Cumulative,\n', '                        nextObservation.timestamp - currentObservation.timestamp, amountIn);\n', '                    _index = _index + 1;\n', '                }\n', '\n', '                (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\n', '                lastUpdatedAgo = timestamp - nextObservation.timestamp;\n', '            }\n', '        } else {\n', '            {\n', '                uint _length = length-1;\n', '                uint i = _length - (points * window);\n', '                uint _index = 0;\n', '                Observation memory nextObservation;\n', '                for (; i < _length; i+=window) {\n', '                    Observation memory currentObservation;\n', '                    currentObservation = observations[i];\n', '                    nextObservation = observations[i + window];\n', '                    prices[_index] = _computeAmountOut(\n', '                        currentObservation.price1Cumulative,\n', '                        nextObservation.price1Cumulative,\n', '                        nextObservation.timestamp - currentObservation.timestamp, amountIn);\n', '                    _index = _index + 1;\n', '                }\n', '\n', '                (,,uint timestamp) = IUniswapV2Pair(pair).getReserves();\n', '                lastUpdatedAgo = timestamp - nextObservation.timestamp;\n', '            }\n', '        }\n', '    }\n', '}']