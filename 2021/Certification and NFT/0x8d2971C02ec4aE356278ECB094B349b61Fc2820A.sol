['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-21\n', '*/\n', '\n', 'pragma solidity 0.8.0;\n', '\n', 'contract FDCBridgeEth {\n', '    \n', '    address private owner;\n', '    \n', '    struct admin {\n', '        bool isAdmin;\n', '        uint limit;\n', '        uint approvedLimit;\n', '    }\n', '    \n', '    mapping (address => admin) private admins;\n', '    \n', '    mapping (address => uint) private balances;\n', '    \n', '    address private FDCContract = 0x311C6769461e1d2173481F8d789AF00B39DF6d75;\n', '    \n', '    uint private transferFeeMinimum = 15700000000000000;\n', '    \n', '    uint private feeModifier = 0;//100 = 1%\n', '    \n', '    string private version = "v1";\n', '    \n', '    event TransferBridge(\n', '        address from,\n', '        address to,\n', '        uint amount\n', '    );\n', '    \n', '    event Balance(\n', '        address Address,\n', '        uint amount,\n', '        bool isBalanceAdd\n', '    );\n', '    \n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '    \n', '    function burn(uint amount, address adminAddress) external payable {\n', "        require(admins[adminAddress].isAdmin == true, 'only admin');\n", '        require(msg.value >= transferFeeMinimum, "Transfer Fee needs to be higher than minimum");\n', '        \n', '        TransferHelper.safeTransferFrom(\n', '          FDCContract, msg.sender, address(this), amount\n', '        );\n', '        \n', '        TransferHelper.safeTransferETH(\n', '          adminAddress, msg.value\n', '        );\n', '        \n', '        uint transferRate = amount / 10;\n', '        require(transferRate > 0, "Transfer Rate needs to be higher than the minimum");\n', '        require(amount > transferRate, "Amount sent needs to be higher than the Transfer Rate");\n', '        uint sendValue = amount - transferRate;\n', '        \n', '        if (feeModifier > 0) {\n', '            uint fee = amount / feeModifier;\n', '            require(fee > 0, "Fee needs to be higher than the minimum");\n', '            TransferHelper.safeTransfer(\n', '              FDCContract, adminAddress, fee\n', '            );\n', '            sendValue -= fee;\n', '        }\n', '        \n', "        require((admins[adminAddress].limit >= sendValue), 'not enough admin limit');\n", '        admins[adminAddress].limit -= sendValue;\n', '        admins[adminAddress].approvedLimit += sendValue;\n', '        \n', '        balanceAdd(msg.sender, sendValue);\n', '        \n', '        emit TransferBridge(\n', '          msg.sender,\n', '          adminAddress,\n', '          sendValue\n', '        );\n', '    }\n', '    \n', '    function mint(uint amount, address to) external {\n', "        require(admins[msg.sender].isAdmin == true, 'only admin');\n", '        \n', '        TransferHelper.safeTransfer(\n', '          FDCContract, to, amount\n', '        );\n', '        \n', '        emit TransferBridge(\n', '          msg.sender,\n', '          to,\n', '          amount\n', '        );\n', '    }\n', '    \n', '    function balanceOf(address Address) external view returns (uint) {\n', '        return balances[Address];\n', '    }\n', '    \n', '    function balanceAdd(address Address, uint value) internal {\n', '        require(Address != address(0));\n', '        balances[Address] = balances[Address] + value;\n', '        emit Balance(\n', '          Address,\n', '          value,\n', '          true\n', '        );\n', '    }\n', '    \n', '    function balanceSubtract(address Address, uint value) internal {\n', '        require(Address != address(0));\n', "        require(balances[Address] - value >= 0, 'Not enough balance to subtract');\n", '        balances[Address] = balances[Address] - value;\n', '        emit Balance(\n', '          Address,\n', '          value,\n', '          false\n', '        );\n', '    }\n', '    \n', '    function adminSubtractBalance(address Address, uint value) external {\n', "        require(admins[msg.sender].isAdmin == true, 'only admin');\n", '        admins[msg.sender].approvedLimit -= value;\n', '        balanceSubtract(Address, value);\n', '        emit TransferBridge(\n', '          msg.sender,\n', '          Address,\n', '          value\n', '        );\n', '    }\n', '    \n', '    function updateAdmin(address adminAddress, bool state, uint limit) external {\n', "        require(msg.sender == owner, 'only owner');\n", '        admins[adminAddress].isAdmin = state;\n', '        admins[adminAddress].limit = limit;\n', '    }\n', '    \n', '    function getAdmin(address Address) external view returns(bool,uint,uint) {\n', '        return (admins[Address].isAdmin,admins[Address].limit,admins[Address].approvedLimit);\n', '    }\n', '    \n', '    function getOwner() external view returns(address) {\n', '        return owner;\n', '    }\n', '    \n', '    function setTransferFeeMinimum(uint amount) external {\n', "        require(msg.sender == owner, 'only owner');\n", '        transferFeeMinimum = amount;\n', '    }\n', '    \n', '    function getTransferFeeMinimum() external view returns(uint) {\n', '        return transferFeeMinimum;\n', '    }\n', '    \n', '    function setFeeModifier(uint amount) external {\n', "        require(msg.sender == owner, 'only owner');\n", '        feeModifier = amount;\n', '    }\n', '    \n', '    function getFeeModifier() external view returns(uint) {\n', '        return feeModifier;\n', '    }\n', '    \n', '    function getVersion() external view returns(string memory) {\n', '        return version;\n', '    }\n', '}\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}']