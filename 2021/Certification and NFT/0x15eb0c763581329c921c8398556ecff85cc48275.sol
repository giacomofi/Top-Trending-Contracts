['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-31\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.7.4;\n', '\n', 'interface IFlashToken {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '\n', '    function mint(address to, uint256 value) external returns (bool);\n', '\n', '    function burn(uint256 value) external returns (bool);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', 'interface IFlashReceiver {\n', '    function receiveFlash(\n', '        bytes32 id,\n', '        uint256 amountIn,\n', '        uint256 expireAfter,\n', '        uint256 mintedAmount,\n', '        address staker,\n', '        bytes calldata data\n', '    ) external returns (uint256);\n', '}\n', '\n', 'interface IFlashProtocol {\n', '    enum LockedFunctions { SET_MATCH_RATIO, SET_MATCH_RECEIVER }\n', '\n', '    function TIMELOCK() external view returns (uint256);\n', '\n', '    function FLASH_TOKEN() external view returns (address);\n', '\n', '    function matchRatio() external view returns (uint256);\n', '\n', '    function matchReceiver() external view returns (address);\n', '\n', '    function stakes(bytes32 _id)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 amountIn,\n', '            uint256 expiry,\n', '            uint256 expireAfter,\n', '            uint256 mintedAmount,\n', '            address staker,\n', '            address receiver\n', '        );\n', '\n', '    function stake(\n', '        uint256 _amountIn,\n', '        uint256 _days,\n', '        address _receiver,\n', '        bytes calldata _data\n', '    )\n', '        external\n', '        returns (\n', '            uint256 mintedAmount,\n', '            uint256 matchedAmount,\n', '            bytes32 id\n', '        );\n', '\n', '    function lockFunction(LockedFunctions _lockedFunction) external;\n', '\n', '    function unlockFunction(LockedFunctions _lockedFunction) external;\n', '\n', '    function timelock(LockedFunctions _lockedFunction) external view returns (uint256);\n', '\n', '    function balances(address _staker) external view returns (uint256);\n', '\n', '    function unstake(bytes32 _id) external returns (uint256 withdrawAmount);\n', '\n', '    function unstakeEarly(bytes32 _id) external returns (uint256 withdrawAmount);\n', '\n', '    function getFPY(uint256 _amountIn) external view returns (uint256);\n', '\n', '    function setMatchReceiver(address _newMatchReceiver) external;\n', '\n', '    function setMatchRatio(uint256 _newMatchRatio) external;\n', '\n', '    function getMatchedAmount(uint256 mintedAmount) external view returns (uint256);\n', '\n', '    function getMintAmount(uint256 _amountIn, uint256 _expiry) external view returns (uint256);\n', '\n', '    function getPercentageStaked(uint256 _amountIn) external view returns (uint256 percentage);\n', '\n', '    function calculateMaxStakePeriod(uint256 _amountIn) external view returns (uint256);\n', '\n', '    function stakeWithPermit(\n', '        address _receiver,\n', '        uint256 _amountIn,\n', '        uint256 _expiry,\n', '        uint256 _deadline,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        bytes calldata _data\n', '    )\n', '        external\n', '        returns (\n', '            uint256 mintedAmount,\n', '            uint256 matchedAmount,\n', '            bytes32 id\n', '        );\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "MATH:: ADD_OVERFLOW");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "MATH:: SUB_UNDERFLOW");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "MATH:: MUL_OVERFLOW");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "MATH:: DIVISION_BY_ZERO");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            size := extcodesize(account)\n', '        }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '\n', 'contract FlashProtocol is IFlashProtocol {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    struct Stake {\n', '        uint256 amountIn;\n', '        uint256 expiry;\n', '        uint256 expireAfter;\n', '        uint256 mintedAmount;\n', '        address staker;\n', '        address receiver;\n', '    }\n', '\n', '    uint256 public constant override TIMELOCK = 3 days;\n', '    address public constant override FLASH_TOKEN = 0x20398aD62bb2D930646d45a6D4292baa0b860C1f;\n', '\n', '    uint256 internal constant PRECISION = 1e18;\n', '    uint256 internal constant MAX_FPY_FOR_1_YEAR = 5e17;\n', '    uint256 internal constant SECONDS_IN_1_YEAR = 365 * 86400;\n', '\n', '    uint256 public override matchRatio;\n', '    address public override matchReceiver;\n', '\n', '    mapping(bytes32 => Stake) public override stakes;\n', '    mapping(LockedFunctions => uint256) public override timelock;\n', '    mapping(address => uint256) public override balances;\n', '\n', '    event Staked(\n', '        bytes32 _id,\n', '        uint256 _amountIn,\n', '        uint256 _expiry,\n', '        uint256 _expireAfter,\n', '        uint256 _mintedAmount,\n', '        address indexed _staker,\n', '        address indexed _receiver\n', '    );\n', '\n', '    event Unstaked(bytes32 _id, uint256 _amountIn, address indexed _staker);\n', '\n', '    modifier onlyMatchReceiver {\n', '        require(msg.sender == matchReceiver, "FlashProtocol:: NOT_MATCH_RECEIVER");\n', '        _;\n', '    }\n', '\n', '    modifier notLocked(LockedFunctions _lockedFunction) {\n', '        require(\n', '            timelock[_lockedFunction] != 0 && timelock[_lockedFunction] <= block.timestamp,\n', '            "FlashProtocol:: FUNCTION_TIMELOCKED"\n', '        );\n', '        _;\n', '    }\n', '\n', '    constructor(address _initialMatchReceiver, uint256 _initialMatchRatio) {\n', '        _setMatchRatio(_initialMatchRatio);\n', '        _setMatchReceiver(_initialMatchReceiver);\n', '    }\n', '\n', '    function lockFunction(LockedFunctions _lockedFunction) external override onlyMatchReceiver {\n', '        timelock[_lockedFunction] = type(uint256).max;\n', '    }\n', '\n', '    function unlockFunction(LockedFunctions _lockedFunction) external override onlyMatchReceiver {\n', '        timelock[_lockedFunction] = block.timestamp + TIMELOCK;\n', '    }\n', '\n', '    function setMatchReceiver(address _newMatchReceiver)\n', '        external\n', '        override\n', '        onlyMatchReceiver\n', '        notLocked(LockedFunctions.SET_MATCH_RECEIVER)\n', '    {\n', '        _setMatchReceiver(_newMatchReceiver);\n', '        timelock[LockedFunctions.SET_MATCH_RECEIVER] = 0;\n', '    }\n', '\n', '    function _setMatchReceiver(address _newMatchReceiver) internal {\n', '        matchReceiver = _newMatchReceiver;\n', '    }\n', '\n', '    function setMatchRatio(uint256 _newMatchRatio)\n', '        external\n', '        override\n', '        onlyMatchReceiver\n', '        notLocked(LockedFunctions.SET_MATCH_RATIO)\n', '    {\n', '        _setMatchRatio(_newMatchRatio);\n', '        timelock[LockedFunctions.SET_MATCH_RATIO] = 0;\n', '    }\n', '\n', '    function _setMatchRatio(uint256 _newMatchRatio) internal {\n', '        require(_newMatchRatio >= 0 && _newMatchRatio <= 2000, "FlashProtocol:: INVALID_MATCH_RATIO");\n', '        // can be 0 and cannot be above 20%\n', '        require(_newMatchRatio <= 2000, "FlashProtocol:: INVALID_MATCH_RATIO");\n', '        matchRatio = _newMatchRatio;\n', '    }\n', '\n', '    function stake(\n', '        uint256 _amountIn,\n', '        uint256 _expiry,\n', '        address _receiver,\n', '        bytes calldata _data\n', '    )\n', '        external\n', '        override\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            bytes32\n', '        )\n', '    {\n', '        return _stake(_amountIn, _expiry, _receiver, _data);\n', '    }\n', '\n', '    function stakeWithPermit(\n', '        address _receiver,\n', '        uint256 _amountIn,\n', '        uint256 _expiry,\n', '        uint256 _deadline,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s,\n', '        bytes calldata _data\n', '    )\n', '        external\n', '        override\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            bytes32\n', '        )\n', '    {\n', '        IFlashToken(FLASH_TOKEN).permit(msg.sender, address(this), type(uint256).max, _deadline, _v, _r, _s);\n', '        return _stake(_amountIn, _expiry, _receiver, _data);\n', '    }\n', '\n', '    function _stake(\n', '        uint256 _amountIn,\n', '        uint256 _expiry,\n', '        address _receiver,\n', '        bytes calldata _data\n', '    )\n', '        internal\n', '        returns (\n', '            uint256 mintedAmount,\n', '            uint256 matchedAmount,\n', '            bytes32 id\n', '        )\n', '    {\n', '        require(_amountIn > 0, "FlashProtocol:: INVALID_AMOUNT");\n', '        require(_receiver != address(this), "FlashProtocol:: INVALID_ADDRESS");\n', '        require(_expiry <= calculateMaxStakePeriod(_amountIn), "FlashProtocol:: MAX_STAKE_PERIOD_EXCEEDS");\n', '\n', '        address staker = msg.sender;\n', '\n', '        uint256 expiration = block.timestamp.add(_expiry);\n', '        balances[staker] = balances[staker].add(_amountIn);\n', '\n', '        id = keccak256(abi.encodePacked(_amountIn, _expiry, _receiver, staker, block.timestamp));\n', '\n', '        require(stakes[id].staker == address(0), "FlashProtocol:: STAKE_EXISTS");\n', '\n', '        mintedAmount = getMintAmount(_amountIn, _expiry);\n', '        matchedAmount = getMatchedAmount(mintedAmount);\n', '\n', '        IFlashToken(FLASH_TOKEN).transferFrom(staker, address(this), _amountIn);\n', '\n', '        IFlashToken(FLASH_TOKEN).mint(_receiver, mintedAmount);\n', '        IFlashToken(FLASH_TOKEN).mint(matchReceiver, matchedAmount);\n', '\n', '        stakes[id] = Stake(_amountIn, _expiry, expiration, mintedAmount, staker, _receiver);\n', '\n', '        if (_receiver.isContract()) {\n', '            IFlashReceiver(_receiver).receiveFlash(id, _amountIn, expiration, mintedAmount, staker, _data);\n', '        }\n', '\n', '        emit Staked(id, _amountIn, _expiry, expiration, mintedAmount, staker, _receiver);\n', '    }\n', '\n', '    function unstake(bytes32 _id) external override returns (uint256 withdrawAmount) {\n', '        Stake memory s = stakes[_id];\n', '        require(block.timestamp >= s.expireAfter, "FlashProtol:: STAKE_NOT_EXPIRED");\n', '        balances[s.staker] = balances[s.staker].sub(s.amountIn);\n', '        withdrawAmount = s.amountIn;\n', '        delete stakes[_id];\n', '        IFlashToken(FLASH_TOKEN).transfer(s.staker, withdrawAmount);\n', '        emit Unstaked(_id, s.amountIn, s.staker);\n', '    }\n', '\n', '    function unstakeEarly(bytes32 _id) external override returns (uint256 withdrawAmount) {\n', '        Stake memory s = stakes[_id];\n', '        address staker = msg.sender;\n', '        require(s.staker == staker, "FlashProtocol:: INVALID_STAKER");\n', '        uint256 remainingTime = (s.expireAfter.sub(block.timestamp));\n', '        require(s.expiry > remainingTime, "Flash Protocol:: INVALID_UNSTAKE_TIME");\n', '        uint256 burnAmount = _calculateBurn(s.amountIn, remainingTime, s.expiry);\n', '        assert(burnAmount <= s.amountIn);\n', '        balances[staker] = balances[staker].sub(s.amountIn);\n', '        withdrawAmount = s.amountIn.sub(burnAmount);\n', '        delete stakes[_id];\n', '        IFlashToken(FLASH_TOKEN).burn(burnAmount);\n', '        IFlashToken(FLASH_TOKEN).transfer(staker, withdrawAmount);\n', '        emit Unstaked(_id, withdrawAmount, staker);\n', '    }\n', '\n', '    function getMatchedAmount(uint256 _mintedAmount) public view override returns (uint256) {\n', '        return _mintedAmount.mul(matchRatio).div(10000);\n', '    }\n', '\n', '    function getMintAmount(uint256 _amountIn, uint256 _expiry) public view override returns (uint256) {\n', '        return _amountIn.mul(_expiry).mul(getFPY(_amountIn)).div(PRECISION * SECONDS_IN_1_YEAR);\n', '    }\n', '\n', '    function getFPY(uint256 _amountIn) public view override returns (uint256) {\n', '        return (PRECISION.sub(getPercentageStaked(_amountIn))).div(2);\n', '    }\n', '\n', '    function getPercentageStaked(uint256 _amountIn) public view override returns (uint256) {\n', '        uint256 locked = IFlashToken(FLASH_TOKEN).balanceOf(address(this)).add(_amountIn);\n', '        return locked.mul(PRECISION).div(IFlashToken(FLASH_TOKEN).totalSupply());\n', '    }\n', '\n', '    function calculateMaxStakePeriod(uint256 _amountIn) public view override returns (uint256) {\n', '        return MAX_FPY_FOR_1_YEAR.mul(SECONDS_IN_1_YEAR).div(getFPY(_amountIn));\n', '    }\n', '\n', '    function _calculateBurn(\n', '        uint256 _amount,\n', '        uint256 _remainingTime,\n', '        uint256 _totalTime\n', '    ) private pure returns (uint256) {\n', '        return _amount.mul(_remainingTime).div(_totalTime);\n', '    }\n', '}']