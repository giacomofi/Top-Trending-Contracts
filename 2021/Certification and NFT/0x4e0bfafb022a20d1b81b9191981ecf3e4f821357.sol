['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./IERC20.sol";\n', '\n', 'interface IStaking {\n', '    function getEpochId(uint timestamp) external view returns (uint); // get epoch id\n', '    function getEpochUserBalance(address user, address token, uint128 epoch) external view returns(uint);\n', '    function getEpochPoolSize(address token, uint128 epoch) external view returns (uint);\n', '    function epoch1Start() external view returns (uint);\n', '    function epochDuration() external view returns (uint);\n', '    function hasReferrer(address addr) external view returns(bool);\n', '    function referrals(address addr) external view returns(address);\n', '    function firstReferrerRewardPercentage() external view returns(uint256);\n', '    function secondReferrerRewardPercentage() external view returns(uint256);\n', '}\n', '\n', 'interface TokenInterface is IERC20 {\n', '    function mintSupply(address _investorAddress, uint256 _amount) external;\n', '}\n', '\n', 'contract YieldFarm {\n', '    // lib\n', '    using SafeMath for uint;\n', '    using SafeMath for uint128;\n', '    using SafeMath for uint256;\n', '    \n', '    // constants\n', '    uint public constant NR_OF_EPOCHS = 24;\n', '\n', '    // addreses\n', '    address public _usdc;\n', '    address public _usdt;\n', '    address public _dai;\n', '    // contracts\n', '    TokenInterface private _swapp;\n', '    IStaking private _staking;\n', '    \n', '    address public _owner;\n', '\n', "    // fixed size array holdings total number of epochs + 1 (epoch 0 doesn't count)\n", '    uint[] private epochs = new uint[](NR_OF_EPOCHS + 1);\n', '    // pre-computed variable for optimization. total amount of swapp tokens to be distributed on each epoch\n', '    // uint private _totalAmountPerEpoch;\n', '\n', '    // id of last init epoch, for optimization purposes moved from struct to a single id.\n', '    uint128 public lastInitializedEpoch;\n', '\n', '    // state of user harvest epoch\n', '    mapping(address => uint128) private lastEpochIdHarvested;\n', '    uint public epochDuration; // init from staking contract\n', '    uint public epochStart; // init from staking contract\n', '    mapping(uint128 => uint256) public epochAmounts;\n', '\n', '    // events\n', '    event MassHarvest(address indexed user, uint256 epochsHarvested, uint256 totalValue);\n', '    event Harvest(address indexed user, uint128 indexed epochId, uint256 amount);\n', '    event ReferrerRewardCollected(address indexed staker, address indexed referrer, uint256 rewardAmount);\n', '    event Referrer2RewardCollected(address indexed staker, address indexed referrer, address indexed referrer2, uint256 rewardAmount);\n', '\n', '    // constructor\n', '    constructor() {\n', '        _swapp = TokenInterface(0x8CB924583681cbFE487A62140a994A49F833c244);\n', '        _staking = IStaking(0x245a551ee0F55005e510B239c917fA34b41B3461);\n', '\n', '        _usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '        _usdt = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '        _dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '\n', '        epochStart = _staking.epoch1Start();\n', '        epochDuration = _staking.epochDuration();\n', '        \n', '        _owner = msg.sender;\n', '        \n', '        for (uint128 i = 1; i <= 24; i++) {\n', '            // i = epochId\n', '            epochAmounts[i] = 5000000;\n', '        }\n', '    }\n', '    \n', '    function setEpochAmount(uint128 epochId, uint256 amount) external {\n', '        require(msg.sender == _owner, "Only owner can update epoch amount");\n', '        require(epochId > 0 && epochId <= NR_OF_EPOCHS, "Minimum epoch number is 1 and Maximum number of epochs is 24");\n', '        require(epochId > _getEpochId(), "Only future epoch can be updated");\n', '        epochAmounts[epochId] = amount;\n', '    }\n', '    \n', '    function getTotalAmountPerEpoch() public view returns (uint) {\n', '        uint128 currentEpoch = _getEpochId();\n', '        if (currentEpoch > NR_OF_EPOCHS) {\n', '            currentEpoch = 25;\n', '        }\n', '\n', '        return epochAmounts[currentEpoch-1].mul(10**18);\n', '    }\n', '    \n', '    function getCurrentEpochAmount() public view returns (uint) {\n', '        uint128 currentEpoch = _getEpochId();\n', '        if (currentEpoch <= 0 || currentEpoch > NR_OF_EPOCHS) {\n', '            return 0;\n', '        }\n', '\n', '        return epochAmounts[currentEpoch];\n', '    }\n', '\n', '    function getTotalDistributedAmount() external view returns(uint256) {\n', '        uint256 totalDistributed;\n', '        for (uint128 i = 1; i <= NR_OF_EPOCHS; i++) {\n', '            totalDistributed += epochAmounts[i];\n', '        }\n', '        return totalDistributed;\n', '    }\n', '\n', '    // public methods\n', '    // public method to harvest all the unharvested epochs until current epoch - 1\n', '    function massHarvest() external returns (uint){\n', '        uint totalDistributedValue;\n', '        uint epochId = _getEpochId().sub(1); // fails in epoch 0\n', '        // force max number of epochs\n', '        if (epochId > NR_OF_EPOCHS) {\n', '            epochId = NR_OF_EPOCHS;\n', '        }\n', '\n', '        for (uint128 i = lastEpochIdHarvested[msg.sender] + 1; i <= epochId; i++) {\n', '            // i = epochId\n', '            // compute distributed Value and do one single transfer at the end\n', '            totalDistributedValue += _harvest(i);\n', '        }\n', '\n', '        emit MassHarvest(msg.sender, epochId.sub(lastEpochIdHarvested[msg.sender]), totalDistributedValue);\n', '\n', '        if (totalDistributedValue > 0) {\n', '            _swapp.mintSupply(msg.sender, totalDistributedValue);\n', '            //Referrer reward\n', '            distributeReferrerReward(totalDistributedValue);\n', '        }\n', '\n', '        return totalDistributedValue;\n', '    }\n', '\n', '    function harvest (uint128 epochId) external returns (uint){\n', '        // checks for requested epoch\n', '        require (_getEpochId() > epochId, "This epoch is in the future");\n', '        require(epochId <= NR_OF_EPOCHS, "Maximum number of epochs is 24");\n', '        require (lastEpochIdHarvested[msg.sender].add(1) == epochId, "Harvest in order");\n', '        uint userReward = _harvest(epochId);\n', '        if (userReward > 0) {\n', '            _swapp.mintSupply(msg.sender, userReward);\n', '            //Referrer reward\n', '            distributeReferrerReward(userReward);\n', '        }\n', '        emit Harvest(msg.sender, epochId, userReward);\n', '        return userReward;\n', '    }\n', '    \n', '    function distributeReferrerReward(uint256 stakerReward) internal {\n', '        if (_staking.hasReferrer(msg.sender)) {\n', '            address referrer = _staking.referrals(msg.sender);\n', '            uint256 ref1Reward = stakerReward.mul(_staking.firstReferrerRewardPercentage()).div(10000);\n', '            _swapp.mintSupply(referrer, ref1Reward);\n', '            emit ReferrerRewardCollected(msg.sender, referrer, ref1Reward);\n', '            \n', '            // second step referrer\n', '            if (_staking.hasReferrer(referrer)) {\n', '                address referrer2 = _staking.referrals(referrer);\n', '                uint256 ref2Reward = stakerReward.mul(_staking.secondReferrerRewardPercentage()).div(10000);\n', '                _swapp.mintSupply(referrer2, ref2Reward);\n', '                emit Referrer2RewardCollected(msg.sender, referrer, referrer2, ref2Reward);\n', '            }\n', '        }\n', '    }\n', '\n', '    // views\n', '    // calls to the staking smart contract to retrieve the epoch total pool size\n', '    function getPoolSize(uint128 epochId) external view returns (uint) {\n', '        return _getPoolSize(epochId);\n', '    }\n', '\n', '    function getCurrentEpoch() external view returns (uint) {\n', '        return _getEpochId();\n', '    }\n', '\n', '    // calls to the staking smart contract to retrieve user balance for an epoch\n', '    function getEpochStake(address userAddress, uint128 epochId) external view returns (uint) {\n', '        return _getUserBalancePerEpoch(userAddress, epochId);\n', '    }\n', '\n', '    function userLastEpochIdHarvested() external view returns (uint){\n', '        return lastEpochIdHarvested[msg.sender];\n', '    }\n', '\n', '    // internal methods\n', '\n', '    function _initEpoch(uint128 epochId) internal {\n', '        require(lastInitializedEpoch.add(1) == epochId, "Epoch can be init only in order");\n', '        lastInitializedEpoch = epochId;\n', '        // call the staking smart contract to init the epoch\n', '        epochs[epochId] = _getPoolSize(epochId);\n', '    }\n', '\n', '    function _harvest (uint128 epochId) internal returns (uint) {\n', "        // try to initialize an epoch. if it can't it fails\n", '        // if it fails either user either a Swapp account will init not init epochs\n', '        if (lastInitializedEpoch < epochId) {\n', '            _initEpoch(epochId);\n', '        }\n', '        // Set user last harvested epoch\n', '        lastEpochIdHarvested[msg.sender] = epochId;\n', '        // compute and return user total reward. For optimization reasons the transfer have been moved to an upper layer (i.e. massHarvest needs to do a single transfer)\n', '\n', '        // exit if there is no stake on the epoch\n', '        if (epochs[epochId] == 0) {\n', '            return 0;\n', '        }\n', '\n', '        return getTotalAmountPerEpoch()\n', '        .mul(_getUserBalancePerEpoch(msg.sender, epochId))\n', '        .div(epochs[epochId]);\n', '    }\n', '\n', '    function _getPoolSize(uint128 epochId) internal view returns (uint) {\n', '        // retrieve stable coins total staked in epoch\n', '        uint valueUsdc = _staking.getEpochPoolSize(_usdc, epochId).mul(10 ** 12); // for usdc which has 6 decimals add a 10**12 to get to a common ground\n', '        uint valueUsdt = _staking.getEpochPoolSize(_usdt, epochId).mul(10 ** 12); // for usdt which has 6 decimals add a 10**12 to get to a common ground\n', '        uint valueDai = _staking.getEpochPoolSize(_dai, epochId);\n', '        return valueUsdc.add(valueUsdt).add(valueDai);\n', '    }\n', '\n', '    function _getUserBalancePerEpoch(address userAddress, uint128 epochId) internal view returns (uint){\n', '        // retrieve stable coins total staked per user in epoch\n', '        uint valueUsdc = _staking.getEpochUserBalance(userAddress, _usdc, epochId).mul(10 ** 12); // for usdc which has 6 decimals add a 10**12 to get to a common ground\n', '        uint valueUsdt = _staking.getEpochUserBalance(userAddress, _usdt, epochId).mul(10 ** 12); // for usdt which has 6 decimals add a 10**12 to get to a common ground\n', '        uint valueDai = _staking.getEpochUserBalance(userAddress, _dai, epochId);\n', '        return valueUsdc.add(valueUsdt).add(valueDai);\n', '    }\n', '\n', '    // compute epoch id from blocktimestamp and epochstart date\n', '    function _getEpochId() internal view returns (uint128 epochId) {\n', '        if (block.timestamp < epochStart) {\n', '            return 0;\n', '        }\n', '        epochId = uint128(block.timestamp.sub(epochStart).div(epochDuration).add(1));\n', '    }\n', '}']