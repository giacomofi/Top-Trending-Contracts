['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-27\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', '* @title IERC165\n', '* @dev https://eips.ethereum.org/EIPS/eip-165\n', '* @dev source : openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '*/\n', 'interface IERC165 {\n', '    /**\n', '    * @notice Query if a contract implements an interface\n', '    * @param interfaceId The interface identifier, as specified in ERC-165\n', '    * @dev Interface identification is specified in ERC-165. This function\n', '    * uses less than 30,000 gas.\n', '    */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', '* @title SafeMath\n', '* @dev Unsigned math operations with safety checks that revert on error\n', '* @dev source : openzeppelin-solidity/contracts/math/SafeMath.sol\n', '*/\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "error");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "cannot divide by 0 or negative");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "result cannot be lower than 0");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "both numbers have to be positive");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "cannot divide by 0");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', '* @title Counters\n', '* @author Matt Condon (@shrugs)\n', '* @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n', '* of elements in a mapping, issuing ERC721 ids, or counting request ids\n', '*\n', '* Include with `using Counters for Counters.Counter;`\n', '* Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n', '* overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n', '* directly accessed.\n', '* @dev source : openzeppelin-solidity/contracts/drafts/Counters.sol\n', '*/\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n', "        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n", '        // this feature: see https://github.com/ethereum/solidity/issues/4637\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', 'contract Storage {\n', '    using Counters for Counters.Counter;\n', '\n', '    // Token name\n', '    string internal _name;\n', '    // Token symbol\n', '    string internal _symbol;\n', '    // Token base uri\n', '    string internal _baseTokenURI;\n', '\n', '    // ERC165 supported interfaces\n', '    bytes4 internal constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\n', '    bytes4 internal constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '    bytes4 internal constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '    bytes4 internal constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '    \n', '    // OpenSea proxy registry\n', '    address public proxyRegistryAddress;\n', '\n', '    // token id tracker\n', '    uint256 internal _currentTokenId = 0;\n', '    \n', '    // Array with all token ids, used for enumeration\n', '    uint256[] internal _allTokens;\n', '\n', "    // mapping of interface id to whether or not it's supported    \n", '    mapping(bytes4 => bool) internal _supportedInterfaces;\n', '\n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) internal _tokenOwner;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) internal _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned token\n', '    mapping (address => Counters.Counter) internal _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) internal _operatorApprovals;\n', '\n', '    // Optional mapping for token URIs\n', '    mapping(uint256 => string) internal _tokenURIs;\n', '\n', '    // Mapping from owner to list of owned token IDs\n', '    mapping(address => uint256[]) internal _ownedTokens;\n', '\n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) internal _ownedTokensIndex;\n', '\n', '    // Mapping from token id to position in the allTokens array\n', '    mapping(uint256 => uint256) internal _allTokensIndex;\n', '\n', '    \n', '}\n', '\n', '/**\n', '* @title ERC165\n', '* @author Matt Condon (@shrugs)\n', '* @dev Implements ERC165 using a lookup table.\n', '* @dev source : openzeppelin-solidity/contracts/introspection/ERC165.sol\n', '*/\n', 'contract ERC165 is IERC165, Storage {\n', '\n', '    /**\n', '    * @dev implement supportsInterface(bytes4) using a lookup table\n', '    */\n', '    function supportsInterface(bytes4 interfaceId) external override view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '    * @dev internal method for registering an interface\n', '    */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff, "bad interface");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '/**\n', '* @title ERC721 Non-Fungible Token Standard basic interface\n', '* @dev see https://eips.ethereum.org/EIPS/eip-721\n', '* @dev source : openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '*/\n', 'interface IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) external;\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    function safeTransferFromWithData(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '/**\n', '* @title ERC721 token receiver interface\n', '* @dev Interface for any contract that wants to support safeTransfers\n', '* from ERC721 asset contracts.\n', '* @dev source : openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\n', '*/\n', 'interface IERC721Receiver {\n', '    /**\n', '    * @notice Handle the receipt of an NFT\n', '    * @dev The ERC721 smart contract calls this function on the recipient\n', '    * after a `safeTransfer`. This function MUST return the function selector,\n', '    * otherwise the caller will revert the transaction. The selector to be\n', '    * returned can be obtained as `this.onERC721Received.selector`. This\n', '    * function MAY throw to revert and reject the transfer.\n', '    * Note: the ERC721 contract address is always the message sender.\n', '    * @param operator The address which called `safeTransferFrom` function\n', '    * @param from The address which previously owned the token\n', '    * @param tokenId The NFT identifier which is being transferred\n', '    * @param data Additional data with no specified format\n', '    * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n', '    external returns (bytes4);\n', '}\n', '\n', '/**\n', '* Utility library of inline functions on addresses\n', '* @dev source : openzeppelin-solidity/contracts/utils/Address.sol\n', '*/\n', 'library Address {\n', '    /**\n', '    * Returns whether the target address is a contract\n', '    * @dev This function will return false if invoked during the constructor of a contract,\n', '    * as the code is not actually created until after the constructor finishes.\n', '    * @param account address of the account to check\n', '    * @return whether the target address is a contract\n', '    */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '/**\n', '* @title ERC721 Non-Fungible Token Standard basic implementation\n', '* @dev see https://eips.ethereum.org/EIPS/eip-721\n', '* @dev source : openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\n', '*/\n', 'contract ERC721 is ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    /**\n', '    * @dev Gets the balance of the specified address\n', '    * @param owner address to query the balance of\n', '    * @return uint256 representing the amount owned by the passed address\n', '    */\n', '    function balanceOf(address owner) public override view returns (uint256) {\n', '        require(owner != address(0), "owner cannot be address 0");\n', '        return _ownedTokensCount[owner].current();\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the owner of the specified token ID\n', '    * @param tokenId uint256 ID of the token to query the owner of\n', '    * @return address currently marked as the owner of the given token ID\n', '    */\n', '    function ownerOf(uint256 tokenId) public override view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0), "owner cannot be address 0");\n', '        return owner;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Approves another address to transfer the given token ID\n', '    * The zero address indicates there is no approved address.\n', '    * There can only be one approved address per token at a given time.\n', '    * Can only be called by the token owner or an approved operator.\n', '    * @param to address to be approved for the given token ID\n', '    * @param tokenId uint256 ID of the token to be approved\n', '    */\n', '    function approve(address to, uint256 tokenId) public override {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner, "cannot approve yourself");\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), "permission denied");\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the approved address for a token ID, or zero if no address set\n', '    * Reverts if the token ID does not exist.\n', '    * @param tokenId uint256 ID of the token to query the approval of\n', '    * @return address currently approved for the given token ID\n', '    */\n', '    function getApproved(uint256 tokenId) public override view returns (address) {\n', '        require(_exists(tokenId), "tokenID doesn\'t exist");\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '    * @dev Sets or unsets the approval of a given operator\n', '    * An operator is allowed to transfer all tokens of the sender on their behalf\n', '    * @param to operator address to set the approval\n', '    * @param approved representing the status of the approval to be set\n', '    */\n', '    function setApprovalForAll(address to, bool approved) public override {\n', '        require(to != msg.sender, "cannot approve yourself");\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '    * @dev Tells whether an operator is approved by a given owner\n', '    * @param owner owner address which you want to query the approval of\n', '    * @param operator operator address which you want to query the approval of\n', '    * @return bool whether the given operator is approved by the given owner\n', '    */\n', '    function isApprovedForAll(address owner, address operator) public override virtual view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers the ownership of a given token ID to another address\n', '    * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '    * Requires the msg.sender to be the owner, approved, or operator\n', '    * @param from current owner of the token\n', '    * @param to address to receive the ownership of the given token ID\n', '    * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function transferFrom(address from, address to, uint256 tokenId) public override {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId), "spender is not approved");\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Safely transfers the ownership of a given token ID to another address\n', '    * If the target address is a contract, it must implement `onERC721Received`,\n', '    * which is called upon a safe transfer, and return the magic value\n', '    * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '    * the transfer is reverted.\n', '    * Requires the msg.sender to be the owner, approved, or operator\n', '    * @param from current owner of the token\n', '    * @param to address to receive the ownership of the given token ID\n', '    * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\n', '        safeTransferFromWithData(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '    * @dev Safely transfers the ownership of a given token ID to another address\n', '    * If the target address is a contract, it must implement `onERC721Received`,\n', '    * which is called upon a safe transfer, and return the magic value\n', '    * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '    * the transfer is reverted.\n', '    * Requires the msg.sender to be the owner, approved, or operator\n', '    * @param from current owner of the token\n', '    * @param to address to receive the ownership of the given token ID\n', '    * @param tokenId uint256 ID of the token to be transferred\n', '    * @param _data bytes data to send along with a safe transfer check\n', '    */\n', '    function safeTransferFromWithData(address from, address to, uint256 tokenId, bytes memory _data) public override {\n', '        transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "data check is not ok");\n', '    }\n', '\n', '    /**\n', '    * @dev Returns whether the specified token exists\n', '    * @param tokenId uint256 ID of the token to query the existence of\n', '    * @return bool whether the token exists\n', '    */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Returns whether the given spender can transfer a given token ID\n', '    * @param spender address of the spender to query\n', '    * @param tokenId uint256 ID of the token to be transferred\n', '    * @return bool whether the msg.sender is approved for the given token ID,\n', '    * is an operator of the owner, or is the owner of the token\n', '    */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to mint a new token\n', '    * Reverts if the given token ID already exists\n', '    * @param to The address that will own the minted token\n', '    * @param tokenId uint256 ID of the token to be minted\n', '    */\n', '    function _mint(address to, uint256 tokenId) internal virtual {\n', '        require(to != address(0), "cannot mint to address 0");\n', '        require(!_exists(tokenId), "token already exists");\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to].increment();\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to burn a specific token\n', '    * Reverts if the token does not exist\n', '    * Deprecated, use _burn(uint256) instead.\n', '    * @param owner owner of the token to burn\n', '    * @param tokenId uint256 ID of the token being burned\n', '    */\n', '    function _burn(address owner, uint256 tokenId) internal virtual {\n', '        require(ownerOf(tokenId) == owner, "address is not owner of tokenID");\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[owner].decrement();\n', '        _tokenOwner[tokenId] = address(0);\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to burn a specific token\n', '    * Reverts if the token does not exist\n', '    * @param tokenId uint256 ID of the token being burned\n', '    */\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to transfer ownership of a given token ID to another address.\n', '    * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '    * @param from current owner of the token\n', '    * @param to address to receive the ownership of the given token ID\n', '    * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal virtual {\n', '        require(ownerOf(tokenId) == from, "sender is not owner of the token");\n', '        require(to != address(0), "cannot send to 0 address");\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from].decrement();\n', '        _ownedTokensCount[to].increment();\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to invoke `onERC721Received` on a target address\n', '    * The call is not executed if the target address is not a contract\n', '    * @param from address representing the previous owner of the given token ID\n', '    * @param to target address that will receive the tokens\n', '    * @param tokenId uint256 ID of the token to be transferred\n', '    * @param _data bytes optional data to send along with the call\n', '    * @return bool whether the call correctly returned the expected magic value\n', '    */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '    internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to clear current approval of a given token ID\n', '    * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', '* @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', '* @dev See https://eips.ethereum.org/EIPS/eip-721\n', '* @dev source : openzeppelin-solidity/contracts/token/ERC721/IERC721Full.sol\n', '*/\n', 'interface IERC721Full is IERC721 {\n', '    function totalSupply() external view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n', '    function tokenByIndex(uint256 index) external view returns (uint256);\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '}\n', '\n', '\n', '/**\n', '* @title Full ERC721 Token\n', '* This implementation includes all the required and some optional functionality of the ERC721 standard\n', '* Moreover, it includes approve all functionality using operator terminology\n', '* @dev see https://eips.ethereum.org/EIPS/eip-721\n', '* @dev source : openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\n', '*/\n', 'contract ERC721Full is ERC721, IERC721Full {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    */\n', '    function init (string memory name, string memory symbol) internal {\n', '        _name = name;\n', '        _symbol = symbol;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the token name\n', '    * @return string representing the token name\n', '    */\n', '    function name() external override view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the token symbol\n', '    * @return string representing the token symbol\n', '    */\n', '    function symbol() external override view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the token ID at a given index of the tokens list of the requested owner\n', '    * @param owner address owning the tokens list to be accessed\n', '    * @param index uint256 representing the index to be accessed of the requested tokens list\n', '    * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '    */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public override view returns (uint256) {\n', '        require(index < balanceOf(owner), "index is too high");\n', '        return _ownedTokens[owner][index];\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the total amount of tokens stored by the contract\n', '    * @return uint256 representing the total amount of tokens\n', '    */\n', '    function totalSupply() public override view returns (uint256) {\n', '        return _allTokens.length;\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the token ID at a given index of all the tokens in this contract\n', '    * Reverts if the index is greater or equal to the total number of tokens\n', '    * @param index uint256 representing the index to be accessed of the tokens list\n', '    * @return uint256 token ID at the given index of the tokens list\n', '    */\n', '    function tokenByIndex(uint256 index) public override view returns (uint256) {\n', '        require(index < totalSupply(), "index is too high");\n', '        return _allTokens[index];\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to transfer ownership of a given token ID to another address.\n', '    * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '    * @param from current owner of the token\n', '    * @param to address to receive the ownership of the given token ID\n', '    * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal override {\n', '        super._transferFrom(from, to, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(from, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to mint a new token\n', '    * Reverts if the given token ID already exists\n', '    * @param to address the beneficiary that will own the minted token\n', '    * @param tokenId uint256 ID of the token to be minted\n', '    */\n', '    function _mint(address to, uint256 tokenId) internal override {\n', '        super._mint(to, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '\n', '        _addTokenToAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to burn a specific token\n', '    * Reverts if the token does not exist\n', '    * Deprecated, use _burn(uint256) instead\n', '    * @param owner owner of the token to burn\n', '    * @param tokenId uint256 ID of the token being burned\n', '    */\n', '    function _burn(address owner, uint256 tokenId) internal override {\n', '        super._burn(owner, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(owner, tokenId);\n', '        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n', '        _ownedTokensIndex[tokenId] = 0;\n', '\n', '        _removeTokenFromAllTokensEnumeration(tokenId);\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev Gets the list of token IDs of the requested owner\n', '    * @param owner address owning the tokens\n', '    * @return uint256[] List of token IDs owned by the requested address\n', '    */\n', '    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n', '        return _ownedTokens[owner];\n', '    }\n', '\n', '    /**\n', "    * @dev Private function to add a token to this extension's ownership-tracking data structures.\n", '    * @param to address representing the new owner of the given token ID\n', '    * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '    */\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n', '        _ownedTokens[to].push(tokenId);\n', '    }\n', '\n', '    /**\n', "    * @dev Private function to add a token to this extension's token tracking data structures.\n", '    * @param tokenId uint256 ID of the token to be added to the tokens list\n', '    */\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '\n', '    /**\n', "    * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n", '    * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n', '    * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n', '    * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n', '    * @param from address representing the previous owner of the given token ID\n', '    * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '    */\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', '        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; \n', '            _ownedTokensIndex[lastTokenId] = tokenIndex; \n', '        }\n', '\n', '        _ownedTokens[from].pop();\n', '    }\n', '\n', '    /**\n', "    * @dev Private function to remove a token from this extension's token tracking data structures.\n", '    * This has O(1) time complexity, but alters the order of the _allTokens array.\n', '    * @param tokenId uint256 ID of the token to be removed from the tokens list\n', '    */\n', '    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n', '        uint256 lastTokenIndex = _allTokens.length.sub(1);\n', '        uint256 tokenIndex = _allTokensIndex[tokenId];\n', '\n', '        uint256 lastTokenId = _allTokens[lastTokenIndex];\n', '\n', '        _allTokens[tokenIndex] = lastTokenId; \n', '        _allTokensIndex[lastTokenId] = tokenIndex; \n', '\n', '        _allTokens.pop();\n', '        _allTokensIndex[tokenId] = 0;\n', '    }\n', '\n', '    /**\n', '     * @dev\n', '     * @notice Non-Standard method to retrieve all NFTs that specific owner owns\n', '     * @return uint[] containing all NFTs that owner owns\n', '     */\n', '    function tokensOf(address owner) public view returns (uint[] memory) {\n', '        return _tokensOfOwner(owner);\n', '    }\n', '}\n', '\n', '\n', '/**\n', '* @title Ownable\n', '* @dev The Ownable contract has an owner address, and provides basic authorization control\n', '* functions, this simplifies the implementation of "user permissions".\n', '* @dev source : openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '*/\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '    * @return the address of the owner.\n', '    */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '    * @dev Throws if called by any account other than the owner.\n', '    */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "sender is not owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @return true if `msg.sender` is the owner of the contract.\n', '    */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to relinquish control of the contract.\n', '    * It will not be possible to call the functions with the `onlyOwner`\n', '    * modifier anymore.\n', '    * @notice Renouncing ownership will leave the contract without an owner,\n', '    * thereby removing any functionality that is only available to the owner.\n', '    */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '    * @dev Transfers control of the contract to a newOwner.\n', '    * @param newOwner The address to transfer ownership to.\n', '    */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "new owner cannot be address 0");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Administrable\n', ' * @dev Handle allowances for NFTs administration :\n', ' *      - minting\n', ' *      - burning\n', ' *      - access to admin web interfaces\n', ' * @dev ADMINS STORAGE \n', ' * @dev rights are integer(int16) defined as follow :\n', ' *       1 : address can only mint tokens \n', ' *       2 : address can mint AND burn tokens\n', '*/\n', 'contract Administrable is Ownable {\n', '    \n', '    mapping(address => int16) private admins;\n', '\n', '    event AdminRightsGranted(address indexed newAdmin, int16 adminRights);\n', '    event AdminRightsRevoked(address indexed noAdmin);\n', '\n', '    /**\n', '    * @dev know if an address has admin rights and its type of rights\n', '    * @param _admin the address to find admin rights of\n', '    * @return int16 the admin right for _admin :\n', '    *       1 : address can only mint tokens \n', '    *       2 : address can mint AND burn tokens \n', '    */\n', '    function adminRightsOf(address _admin) public view returns(int16) {\n', '        if (_admin == owner()) return 2;\n', '        else return admins[_admin];\n', '    }\n', '\n', '    /**\n', '    * @dev verifiy if an address can mint new tokens\n', '    * @param _admin : the address to verify minting rights of\n', '    * @return a boolean, truthy when _admin has rights to mint new tokens\n', '    */\n', '    function isMinter(address _admin) public view returns (bool) {\n', '        if (_admin == owner()) return true;\n', '        else return(\n', '            admins[_admin] > 0\n', '        );\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev verifiy if an address has rights to mint and burn new tokens\n', '    * @param _admin : the address to verify minter-burner rights of\n', '    * @return a boolean, truthy when _admin has rights to mint and burn new tokens\n', '    */\n', '    function isMinterBurner(address _admin) public view returns (bool) {\n', '        if (_admin == owner()) return true;\n', '        else return(\n', '            admins[_admin] == 2\n', '        );\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev canMint external \n', '    * @return bool : truthy if msg.sender has admin rights to mint new tokens\n', '    */\n', '    function canMint() public view returns(bool) {\n', '        return(\n', '            isMinter(msg.sender)\n', '        );\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev canBurn external\n', '    * @return bool : truthy if msg.sender has admin rights to mint new tokens and burn existing tokens\n', '    */\n', '    function canMintBurn() public view returns(bool) {\n', '        return(\n', '            isMinterBurner(msg.sender)\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev onlyMinter internal\n', '    */\n', '    modifier onlyMinter() {\n', '        require(\n', '            canMint(),\n', '            "denied : no admin minting rights"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev onlyBurner internal\n', '    */\n', '    modifier onlyMinterBurner() {\n', '        require(\n', '            canMintBurn(),\n', '            "denied : no admin burning rights"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier validAddress(address _admin) {\n', '        require(_admin != address(0), "invalid admin address");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev owner can grant admin access to allow any address to mint new tokens\n', '    * @dev Restricted to CONTRACT OWNER ONLY\n', '    * @param _admin : address to grant admin minter rights to\n', '    */\n', '    function grantMinterRights(address _admin) external onlyOwner validAddress(_admin) {\n', '        admins[_admin] = 1;\n', '        emit AdminRightsGranted(_admin, 1);\n', '    }\n', '\n', '    /**\n', '    * @dev owner can grant admin access to allow any address to mint new tokens and to burn existing tokens\n', '    * @dev Restricted to CONTRACT OWNER ONLY\n', '    * @param _admin : address to grant admin minter and burner rights to\n', '    */\n', '    function grantMinterBurnerRights(address _admin) external onlyOwner validAddress(_admin) {\n', '        admins[_admin] = 2;\n', '        emit AdminRightsGranted(_admin, 2);\n', '    }\n', '\n', '    /**\n', '    * @dev owner can revoke admin right of any admin address\n', '    * @dev Restricted to CONTRACT OWNER ONLY\n', '    * @param _admin : address to revoke admin access to\n', '    */\n', '    function revokeAdminRights(address _admin) external onlyOwner validAddress(_admin) {\n', '        admins[_admin] = 0;\n', '        emit AdminRightsRevoked(_admin);\n', '    }\n', '\n', '}\n', '\n', 'library Strings {\n', '    // via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal pure returns (string memory) {\n', '        bytes memory _ba = bytes(_a);\n', '        bytes memory _bb = bytes(_b);\n', '        bytes memory _bc = bytes(_c);\n', '        bytes memory _bd = bytes(_d);\n', '        bytes memory _be = bytes(_e);\n', '        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '        bytes memory babcde = bytes(abcde);\n', '        uint k = 0;\n', '        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '        for (uint i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '        for (uint i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '        for (uint i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '        for (uint i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '        return string(babcde);\n', '    }\n', '\n', '    function strConcat(string memory _a, string memory _b, string memory _c, string memory _d) internal pure returns (string memory) {\n', '        return strConcat(_a, _b, _c, _d, "");\n', '    }\n', '\n', '    function strConcat(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\n', '        return strConcat(_a, _b, _c, "", "");\n', '    }\n', '\n', '    function strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\n', '        return strConcat(_a, _b, "", "", "");\n', '    }\n', '\n', '    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n', '        if (_i == 0) {\n', '            return "0";\n', '        }\n', '        uint j = _i;\n', '        uint len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len - 1;\n', '        while (_i != 0) {\n', '            bstr[k--] = byte(uint8(48 + _i % 10));\n', '            _i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '\n', '    function fromAddress(address addr) internal pure returns(string memory) {\n', '        bytes20 addrBytes = bytes20(addr);\n', '        bytes16 hexAlphabet = "0123456789abcdef";\n', '        bytes memory result = new bytes(42);\n', '        result[0] = "0";\n', '        result[1] = "x";\n', '        for (uint i = 0; i < 20; i++) {\n', '            result[i * 2 + 2] = hexAlphabet[uint8(addrBytes[i] >> 4)];\n', '            result[i * 2 + 3] = hexAlphabet[uint8(addrBytes[i] & 0x0f)];\n', '        }\n', '        return string(result);\n', '    }\n', '}\n', '\n', '/**\n', '* @title OwnableDelegateProxy\n', '* @dev OpenSea compliant feature\n', '*/\n', 'contract OwnableDelegateProxy { }\n', '\n', '/**\n', '* @title ProxyRegistry\n', '* @dev OpenSea compliant feature\n', '*/\n', 'contract ProxyRegistry {\n', '    mapping(address => OwnableDelegateProxy) public proxies;\n', '}\n', '\n', '\n', '/**\n', '* @title TradeableERC721Token\n', '* ERC721 contract that whitelists a trading address, and has minting functionalities.\n', "* @notice an external 'burn' function restricted to owner as been added\n", '*/\n', 'contract TradeableERC721Token is ERC721Full, Administrable {\n', '    using Strings for string;\n', '    using SafeMath for uint256;\n', '\n', '    function init(string memory _name, string memory _symbol, address _proxyRegistryAddress) internal {\n', '        ERC721Full.init(_name, _symbol);\n', '        proxyRegistryAddress = _proxyRegistryAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev Mints a token to an address.\n', '    * @param _to address of the future owner of the token\n', '    */\n', '    function mintTo(address _to) public onlyMinter {\n', '        require(_to != address(0), "cannot mint to address 0");\n', '        uint256 newTokenId = _getNextTokenId();\n', '        _mint(_to, newTokenId);\n', '        _incrementTokenId();\n', '    }\n', '\n', '    /**\n', '     * @dev Mint several tokens to an address.\n', '     * @param _total total number of NFT to mint (reverts if <= 0)\n', '     * @param _to default owner of the new created NFT (reverts if a zero address)\n', '     */\n', '    function batchMintTo(uint _total, address _to) public onlyMinter {\n', '        require(_total > 0, "mint minimum 1 token");\n', '        for (uint i = 0; i < _total; i++) mintTo(_to);\n', '    }\n', '\n', '    /**\n', '    * @dev External Burn NFT method\n', '    */\n', '    function burn(uint _tokenId) public onlyMinterBurner {\n', '        super._burn(_tokenId);\n', '    }\n', '\n', '    /**\n', '        * @dev calculates the next token ID based on value of _currentTokenId\n', '        * @return uint256 for the next token ID\n', '        */\n', '    function _getNextTokenId() private view returns (uint256) {\n', '        return _currentTokenId.add(1);\n', '    }\n', '\n', '    /**\n', '        * @dev increments the value of _currentTokenId\n', '        */\n', '    function _incrementTokenId() private  {\n', '        _currentTokenId++;\n', '    }\n', '\n', '    /**\n', "    * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-less listings.\n", '    */\n', '    function isApprovedForAll(\n', '        address owner,\n', '        address operator\n', '    )\n', '    public override\n', '    view\n', '    returns (bool)\n', '    {\n', '        // Whitelist OpenSea proxy contract for easy trading.\n', '        ProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n', '        if (address(proxyRegistry.proxies(owner)) == operator) {\n', '            return true;\n', '        }\n', '\n', '        return super.isApprovedForAll(owner, operator);\n', '    }\n', '}\n', '\n', '/**\n', '* @title IpfsHashs\n', '* @dev Provide methods to store and retrieve tokens IPFS CIDs\n', '*/\n', 'contract IpfsHashs is Administrable {\n', '\n', '    mapping (uint => mapping(string => string)) internal ipfsHashs;\n', '\n', '    function setIpfsHash(uint tokenId, string memory docType, string memory _hash) public onlyMinter {\n', '        require(tokenId > 0, "denied : token zero cant be used");\n', '        ipfsHashs[tokenId][docType] = _hash;\n', '    }\n', '\n', '    function removeIpfsHash(uint tokenId, string memory docType) public onlyMinterBurner {\n', '        ipfsHashs[tokenId][docType] = "";\n', '    }\n', '\n', '    function getIpfsHash(uint tokenId, string memory docType) public view returns (string memory) {\n', '        return ipfsHashs[tokenId][docType];\n', '    }\n', '\n', '}\n', '\n', '/**\n', '* @title Proxiable\n', '* @dev Etherland - EIP-1822 Proxiable contract implementation\n', '* @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1822.md\n', '*/\n', 'contract Proxiable {\n', '    // Code position in storage is keccak256("PROXIABLE") = "0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7"\n', '\n', '    function updateCodeAddress(address newAddress) internal {\n', '        require(\n', '            bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),\n', '            "Not compatible"\n', '        );\n', '        assembly { // solium-disable-line\n', '            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, newAddress)\n', '        }\n', '    }\n', '    function proxiableUUID() public pure returns (bytes32) {\n', '        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Etherland NFT Assets\n', ' * @author Mathieu Lecoq\n', ' * september 3rd 2020 \n', ' *\n', ' * @dev Property\n', ' * all rights are reserved to EtherLand ltd\n', ' *\n', ' * @dev deployed with compiler version 0.6.2\n', '*/\n', 'contract Etherland is TradeableERC721Token, IpfsHashs, Proxiable {\n', '    /**\n', '    * @dev initialized state MUST remain set to false on Implementation Contract \n', '    */\n', '    bool public initialized = false;\n', '\n', '    /**\n', '    * @dev event emitting when the `_baseTokenUri` is updated by owner\n', '    */\n', '    event BaseTokenUriUpdated(string newUri);\n', '\n', '    /**\n', '    * @dev Logic code implementation contact constructor\n', '    * @dev MUST be called by deployer only if contract has not been initialized before\n', '    */\n', '    function init(\n', '        string memory _name,\n', '        string memory _symbol,\n', '        address _proxyRegistryAddress,\n', '        string memory baseURI,\n', '        address _owner\n', '    ) public {\n', '        if (initialized != true) {\n', '            initialized = true;\n', '\n', '            TradeableERC721Token.init(_name, _symbol, _proxyRegistryAddress);\n', '\n', '            _baseTokenURI = baseURI;\n', '\n', '            // register the supported interfaces to conform to ERC721 via ERC165\n', '            _registerInterface(_INTERFACE_ID_ERC165);\n', '            _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '            _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '            _registerInterface(_INTERFACE_ID_ERC721);\n', '\n', '            _transferOwnership(_owner);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Retrieve all NFTs base token uri \n', '    */\n', '    function baseTokenURI() public view returns (string memory) {\n', '        return _baseTokenURI;\n', '    }\n', '\n', '    /**\n', '    * @dev Set the base token uri for all NFTs\n', '    */\n', '    function setBaseTokenURI(string memory uri) public onlyOwner {\n', '        _baseTokenURI = uri;\n', '        emit BaseTokenUriUpdated(uri);\n', '    }\n', '\n', '    /**\n', '    * @dev Retrieve the uri of a specific token \n', '    * @param _tokenId the id of the token to retrieve the uri of\n', '    * @return computed uri string pointing to a specific _tokenId\n', '    */\n', '    function tokenURI(uint256 _tokenId) external view returns (string memory) {\n', '        return Strings.strConcat(\n', '            baseTokenURI(),\n', '            Strings.uint2str(_tokenId)\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev EIP-1822 feature\n', '    * @dev Realize an update of the Etherland logic code \n', '    * @dev calls the proxy contract to update stored logic code contract address at keccak256("PROXIABLE")\n', '    */\n', '    function updateCode(address newCode) public onlyOwner {\n', '        updateCodeAddress(newCode);\n', '    }\n', '\n', '    /**\n', '    * @dev Mint a new token with document hash corresponding to an IPFS CID\n', '    * @param _to address of the future owner of the token\n', '    * @param docType string representing the type of document that is stored to IPFS (can be "pdf" or any other token related document)\n', '    * @param _hash string representing the hash of a document with type equals to `docType`\n', '    */\n', '    function mintWithIpfsHash(address _to, string memory docType, string memory _hash) public onlyMinter {\n', '        mintTo(_to);\n', '        setIpfsHash(_currentTokenId, docType, _hash);\n', '    }\n', '\n', '}']