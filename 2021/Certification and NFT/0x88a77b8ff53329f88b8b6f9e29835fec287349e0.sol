['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', '/// GebProxyActions.sol\n', '\n', '// Copyright (C) 2018-2020 Maker Ecosystem Growth Holdings, INC.\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'interface DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) external view returns (bool);\n', '}\n', '\n', 'abstract contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        virtual\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        virtual\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "ds-auth-unauthorized");\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) virtual internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, address(this), sig);\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract CollateralLike {\n', '    function approve(address, uint) virtual public;\n', '    function transfer(address, uint) virtual public;\n', '    function transferFrom(address, address, uint) virtual public;\n', '    function deposit() virtual public payable;\n', '    function withdraw(uint) virtual public;\n', '}\n', '\n', 'abstract contract ManagerLike {\n', '    function safeCan(address, uint, address) virtual public view returns (uint);\n', '    function collateralTypes(uint) virtual public view returns (bytes32);\n', '    function ownsSAFE(uint) virtual public view returns (address);\n', '    function safes(uint) virtual public view returns (address);\n', '    function safeEngine() virtual public view returns (address);\n', '    function openSAFE(bytes32, address) virtual public returns (uint);\n', '    function transferSAFEOwnership(uint, address) virtual public;\n', '    function allowSAFE(uint, address, uint) virtual public;\n', '    function allowHandler(address, uint) virtual public;\n', '    function modifySAFECollateralization(uint, int, int) virtual public;\n', '    function transferCollateral(uint, address, uint) virtual public;\n', '    function transferInternalCoins(uint, address, uint) virtual public;\n', '    function quitSystem(uint, address) virtual public;\n', '    function enterSystem(address, uint) virtual public;\n', '    function moveSAFE(uint, uint) virtual public;\n', '    function protectSAFE(uint, address, address) virtual public;\n', '}\n', '\n', 'abstract contract SAFEEngineLike {\n', '    function canModifySAFE(address, address) virtual public view returns (uint);\n', '    function collateralTypes(bytes32) virtual public view returns (uint, uint, uint, uint, uint);\n', '    function coinBalance(address) virtual public view returns (uint);\n', '    function safes(bytes32, address) virtual public view returns (uint, uint);\n', '    function modifySAFECollateralization(bytes32, address, address, address, int, int) virtual public;\n', '    function approveSAFEModification(address) virtual public;\n', '    function transferInternalCoins(address, address, uint) virtual public;\n', '}\n', '\n', 'abstract contract CollateralJoinLike {\n', '    function decimals() virtual public returns (uint);\n', '    function collateral() virtual public returns (CollateralLike);\n', '    function join(address, uint) virtual public payable;\n', '    function exit(address, uint) virtual public;\n', '}\n', '\n', 'abstract contract GNTJoinLike {\n', '    function bags(address) virtual public view returns (address);\n', '    function make(address) virtual public returns (address);\n', '}\n', '\n', 'abstract contract DSTokenLike {\n', '    function balanceOf(address) virtual public view returns (uint);\n', '    function approve(address, uint) virtual public;\n', '    function transfer(address, uint) virtual public returns (bool);\n', '    function transferFrom(address, address, uint) virtual public returns (bool);\n', '}\n', '\n', 'abstract contract WethLike {\n', '    function balanceOf(address) virtual public view returns (uint);\n', '    function approve(address, uint) virtual public;\n', '    function transfer(address, uint) virtual public;\n', '    function transferFrom(address, address, uint) virtual public;\n', '    function deposit() virtual public payable;\n', '    function withdraw(uint) virtual public;\n', '}\n', '\n', 'abstract contract CoinJoinLike {\n', '    function safeEngine() virtual public returns (SAFEEngineLike);\n', '    function systemCoin() virtual public returns (DSTokenLike);\n', '    function join(address, uint) virtual public payable;\n', '    function exit(address, uint) virtual public;\n', '}\n', '\n', 'abstract contract ApproveSAFEModificationLike {\n', '    function approveSAFEModification(address) virtual public;\n', '    function denySAFEModification(address) virtual public;\n', '}\n', '\n', 'abstract contract GlobalSettlementLike {\n', '    function collateralCashPrice(bytes32) virtual public view returns (uint);\n', '    function redeemCollateral(bytes32, uint) virtual public;\n', '    function freeCollateral(bytes32) virtual public;\n', '    function prepareCoinsForRedeeming(uint) virtual public;\n', '    function processSAFE(bytes32, address) virtual public;\n', '}\n', '\n', 'abstract contract TaxCollectorLike {\n', '    function taxSingle(bytes32) virtual public returns (uint);\n', '}\n', '\n', 'abstract contract CoinSavingsAccountLike {\n', '    function savings(address) virtual public view returns (uint);\n', '    function updateAccumulatedRate() virtual public returns (uint);\n', '    function deposit(uint) virtual public;\n', '    function withdraw(uint) virtual public;\n', '}\n', '\n', 'abstract contract ProxyRegistryLike {\n', '    function proxies(address) virtual public view returns (address);\n', '    function build(address) virtual public returns (address);\n', '}\n', '\n', 'abstract contract ProxyLike {\n', '    function owner() virtual public view returns (address);\n', '}\n', '\n', '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n', '// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n', '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n', '\n', 'contract Common {\n', '    uint256 constant RAY = 10 ** 27;\n', '\n', '    // Internal functions\n', '    function multiply(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "mul-overflow");\n', '    }\n', '\n', '    function _coinJoin_join(address apt, address safeHandler, uint wad) internal {\n', '        // Approves adapter to take the COIN amount\n', '        CoinJoinLike(apt).systemCoin().approve(apt, wad);\n', '        // Joins COIN into the safeEngine\n', '        CoinJoinLike(apt).join(safeHandler, wad);\n', '    }\n', '\n', '    // Public functions\n', '    function coinJoin_join(address apt, address safeHandler, uint wad) public {\n', "        // Gets COIN from the user's wallet\n", '        CoinJoinLike(apt).systemCoin().transferFrom(msg.sender, address(this), wad);\n', '\n', '        _coinJoin_join(apt, safeHandler, wad);\n', '    }\n', '}\n', '\n', 'contract BasicActions is Common {\n', '    // Internal functions\n', '\n', '    /// @notice Safe subtraction\n', '    /// @dev Reverts on overflows\n', '    function subtract(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "sub-overflow");\n', '    }\n', '\n', '    /// @notice Safe conversion uint -> int\n', '    /// @dev Reverts on overflows\n', '    function toInt(uint x) internal pure returns (int y) {\n', '        y = int(x);\n', '        require(y >= 0, "int-overflow");\n', '    }\n', '\n', '    /// @notice Converts a wad (18 decimal places) to rad (45 decimal places)\n', '    function toRad(uint wad) internal pure returns (uint rad) {\n', '        rad = multiply(wad, 10 ** 27);\n', '    }\n', '\n', '    function convertTo18(address collateralJoin, uint256 amt) internal returns (uint256 wad) {\n', '        // For those collaterals that have other than 18 decimals precision we need to do the conversion before passing to modifySAFECollateralization function\n', '        // Adapters will automatically handle the difference of precision\n', '        uint decimals = CollateralJoinLike(collateralJoin).decimals();\n', '        wad = amt;\n', '        if (decimals < 18) {\n', '          wad = multiply(\n', '              amt,\n', '              10 ** (18 - decimals)\n', '          );\n', '        } else if (decimals > 18) {\n', '          wad = amt / 10 ** (decimals - 18);\n', '        }\n', '    }\n', '\n', '    /// @notice Gets delta debt generated (Total Safe debt minus available safeHandler COIN balance)\n', '    /// @param safeEngine address\n', '    /// @param taxCollector address\n', '    /// @param safeHandler address\n', '    /// @param collateralType bytes32\n', '    /// @return deltaDebt\n', '    function _getGeneratedDeltaDebt(\n', '        address safeEngine,\n', '        address taxCollector,\n', '        address safeHandler,\n', '        bytes32 collateralType,\n', '        uint wad\n', '    ) internal returns (int deltaDebt) {\n', '        // Updates stability fee rate\n', '        uint rate = TaxCollectorLike(taxCollector).taxSingle(collateralType);\n', '        require(rate > 0, "invalid-collateral-type");\n', '\n', '        // Gets COIN balance of the handler in the safeEngine\n', '        uint coin = SAFEEngineLike(safeEngine).coinBalance(safeHandler);\n', '\n', '        // If there was already enough COIN in the safeEngine balance, just exits it without adding more debt\n', '        if (coin < multiply(wad, RAY)) {\n', '            // Calculates the needed deltaDebt so together with the existing coins in the safeEngine is enough to exit wad amount of COIN tokens\n', '            deltaDebt = toInt(subtract(multiply(wad, RAY), coin) / rate);\n', '            // This is neeeded due lack of precision. It might need to sum an extra deltaDebt wei (for the given COIN wad amount)\n', '            deltaDebt = multiply(uint(deltaDebt), rate) < multiply(wad, RAY) ? deltaDebt + 1 : deltaDebt;\n', '        }\n', '    }\n', '\n', '    /// @notice Gets repaid delta debt generated (rate adjusted debt)\n', '    /// @param safeEngine address\n', '    /// @param coin uint amount\n', '    /// @param safe uint - safeId\n', '    /// @param collateralType bytes32\n', '        /// @return deltaDebt\n', '    function _getRepaidDeltaDebt(\n', '        address safeEngine,\n', '        uint coin,\n', '        address safe,\n', '        bytes32 collateralType\n', '    ) internal view returns (int deltaDebt) {\n', '        // Gets actual rate from the safeEngine\n', '        (, uint rate,,,) = SAFEEngineLike(safeEngine).collateralTypes(collateralType);\n', '        require(rate > 0, "invalid-collateral-type");\n', '\n', '        // Gets actual generatedDebt value of the safe\n', '        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safe);\n', '\n', '        // Uses the whole coin balance in the safeEngine to reduce the debt\n', '        deltaDebt = toInt(coin / rate);\n', '        // Checks the calculated deltaDebt is not higher than safe.generatedDebt (total debt), otherwise uses its value\n', '        deltaDebt = uint(deltaDebt) <= generatedDebt ? - deltaDebt : - toInt(generatedDebt);\n', '    }\n', '\n', "    /// @notice Gets repaid debt (rate adjusted rate minus COIN balance available in usr's address)\n", '    /// @param safeEngine address\n', '    /// @param usr address\n', '    /// @param safe uint\n', '    /// @param collateralType address\n', '    /// @return wad\n', '    function _getRepaidAlDebt(\n', '        address safeEngine,\n', '        address usr,\n', '        address safe,\n', '        bytes32 collateralType\n', '    ) internal view returns (uint wad) {\n', '        // Gets actual rate from the safeEngine\n', '        (, uint rate,,,) = SAFEEngineLike(safeEngine).collateralTypes(collateralType);\n', '        // Gets actual generatedDebt value of the safe\n', '        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safe);\n', '        // Gets actual coin amount in the safe\n', '        uint coin = SAFEEngineLike(safeEngine).coinBalance(usr);\n', '\n', '        uint rad = subtract(multiply(generatedDebt, rate), coin);\n', '        wad = rad / RAY;\n', '\n', '        // If the rad precision has some dust, it will need to request for 1 extra wad wei\n', '        wad = multiply(wad, RAY) < rad ? wad + 1 : wad;\n', '    }\n', '\n', '    /// @notice Generates Debt (and sends coin balance to address to)\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param coinJoin address\n', '    /// @param safe uint\n', '    /// @param wad uint - amount of debt to be generated\n', '    /// @param to address - receiver of the balance of generated COIN\n', '    function _generateDebt(address manager, address taxCollector, address coinJoin, uint safe, uint wad, address to) internal {\n', '        address safeHandler = ManagerLike(manager).safes(safe);\n', '        address safeEngine = ManagerLike(manager).safeEngine();\n', '        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n', '        // Generates debt in the SAFE\n', '        modifySAFECollateralization(manager, safe, 0, _getGeneratedDeltaDebt(safeEngine, taxCollector, safeHandler, collateralType, wad));\n', "        // Moves the COIN amount (balance in the safeEngine in rad) to proxy's address\n", '        transferInternalCoins(manager, safe, address(this), toRad(wad));\n', "        // Allows adapter to access to proxy's COIN balance in the safeEngine\n", '        if (SAFEEngineLike(safeEngine).canModifySAFE(address(this), address(coinJoin)) == 0) {\n', '            SAFEEngineLike(safeEngine).approveSAFEModification(coinJoin);\n', '        }\n', '        // Exits COIN to this contract\n', '        CoinJoinLike(coinJoin).exit(to, wad);\n', '    }\n', '\n', '    /// @notice Generates Debt (and sends coin balance to address to)\n', '    /// @param manager address\n', '    /// @param ethJoin address\n', '    /// @param safe uint\n', '    /// @param value uint - amount of ETH to be locked in the Safe.\n', '    /// @dev Proxy needs to have enough balance (> value), public functions should handle this.\n', '    function _lockETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint safe,\n', '        uint value\n', '    ) internal {\n', '        // Receives ETH amount, converts it to WETH and joins it into the safeEngine\n', '        ethJoin_join(ethJoin, address(this), value);\n', '        // Locks WETH amount into the SAFE\n', '        SAFEEngineLike(ManagerLike(manager).safeEngine()).modifySAFECollateralization(\n', '            ManagerLike(manager).collateralTypes(safe),\n', '            ManagerLike(manager).safes(safe),\n', '            address(this),\n', '            address(this),\n', '            toInt(value),\n', '            0\n', '        );\n', '    }\n', '\n', '    /// @notice Repays debt\n', '    /// @param manager address\n', '    /// @param coinJoin address\n', '    /// @param safe uint\n', '    /// @param wad uint - amount of debt to be repayed\n', '    function _repayDebt(\n', '        address manager,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint wad,\n', '        bool transferFromCaller\n', '    ) internal {\n', '        address safeEngine = ManagerLike(manager).safeEngine();\n', '        address safeHandler = ManagerLike(manager).safes(safe);\n', '        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n', '\n', '        address own = ManagerLike(manager).ownsSAFE(safe);\n', '        if (own == address(this) || ManagerLike(manager).safeCan(own, safe, address(this)) == 1) {\n', '            // Joins COIN amount into the safeEngine\n', '            if (transferFromCaller) coinJoin_join(coinJoin, safeHandler, wad);\n', '            else _coinJoin_join(coinJoin, safeHandler, wad);\n', '            // // Paybacks debt to the SAFE\n', '            modifySAFECollateralization(manager, safe, 0, _getRepaidDeltaDebt(safeEngine, SAFEEngineLike(safeEngine).coinBalance(safeHandler), safeHandler, collateralType));\n', '        } else {\n', '             // Joins COIN amount into the safeEngine\n', '            if (transferFromCaller) coinJoin_join(coinJoin, address(this), wad);\n', '            else _coinJoin_join(coinJoin, address(this), wad);\n', '            // Paybacks debt to the SAFE\n', '            SAFEEngineLike(safeEngine).modifySAFECollateralization(\n', '                collateralType,\n', '                safeHandler,\n', '                address(this),\n', '                address(this),\n', '                0,\n', '                _getRepaidDeltaDebt(safeEngine, wad * RAY, safeHandler, collateralType)\n', '            );\n', '        }\n', '    }\n', '\n', '    /// @notice Repays debt and frees collateral ETH\n', '    /// @param manager address\n', '    /// @param ethJoin address\n', '    /// @param coinJoin address\n', '    /// @param safe uint\n', '    /// @param collateralWad uint - amount of ETH to free\n', '    /// @param deltaWad uint - amount of debt to be repayed\n', '    /// @param transferFromCaller True if transferring coin from caller, false if balance in the proxy\n', '    function _repayDebtAndFreeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint collateralWad,\n', '        uint deltaWad,\n', '        bool transferFromCaller\n', '    ) internal {\n', '        address safeHandler = ManagerLike(manager).safes(safe);\n', '        // Joins COIN amount into the safeEngine\n', '        if (transferFromCaller) coinJoin_join(coinJoin, safeHandler, deltaWad);\n', '        else _coinJoin_join(coinJoin, safeHandler, deltaWad);\n', '        // Paybacks debt to the SAFE and unlocks WETH amount from it\n', '        modifySAFECollateralization(\n', '            manager,\n', '            safe,\n', '            -toInt(collateralWad),\n', '            _getRepaidDeltaDebt(ManagerLike(manager).safeEngine(), SAFEEngineLike(ManagerLike(manager).safeEngine()).coinBalance(safeHandler), safeHandler, ManagerLike(manager).collateralTypes(safe))\n', '        );\n', "        // Moves the amount from the SAFE handler to proxy's address\n", '        transferCollateral(manager, safe, address(this), collateralWad);\n', '        // Exits WETH amount to proxy address as a token\n', '        CollateralJoinLike(ethJoin).exit(address(this), collateralWad);\n', '        // Converts WETH to ETH\n', '        CollateralJoinLike(ethJoin).collateral().withdraw(collateralWad);\n', '    }\n', '\n', '    // Public functions\n', '\n', '    /// @notice ERC20 transfer\n', '    /// @param collateral address - address of ERC20 collateral\n', '    /// @param dst address - Transfer destination\n', '    /// @param amt address - Amount to transfer\n', '    function transfer(address collateral, address dst, uint amt) external {\n', '        CollateralLike(collateral).transfer(dst, amt);\n', '    }\n', '\n', '    /// @notice Joins the system with the full msg.value\n', '    /// @param apt address - Address of the adapter\n', '    /// @param safe uint - Safe Id\n', '    function ethJoin_join(address apt, address safe) external payable {\n', '        ethJoin_join(apt, safe, msg.value);\n', '    }\n', '\n', '    /// @notice Joins the system with the a specified value\n', '    /// @param apt address - Address of the adapter\n', '    /// @param safe uint - Safe Id\n', '    /// @param value uint - Value to join\n', '    function ethJoin_join(address apt, address safe, uint value) public payable {\n', '        // Wraps ETH in WETH\n', '        CollateralJoinLike(apt).collateral().deposit{value: value}();\n', '        // Approves adapter to take the WETH amount\n', '        CollateralJoinLike(apt).collateral().approve(address(apt), value);\n', '        // Joins WETH collateral into the safeEngine\n', '        CollateralJoinLike(apt).join(safe, value);\n', '    }\n', '\n', '    /// @notice Approves an address to modify the Safe\n', '    /// @param safeEngine address\n', '    /// @param usr address - Address allowed to modify Safe\n', '    function approveSAFEModification(\n', '        address safeEngine,\n', '        address usr\n', '    ) external {\n', '        ApproveSAFEModificationLike(safeEngine).approveSAFEModification(usr);\n', '    }\n', '\n', '    /// @notice Denies an address to modify the Safe\n', '    /// @param safeEngine address\n', '    /// @param usr address - Address disallowed to modify Safe\n', '    function denySAFEModification(\n', '        address safeEngine,\n', '        address usr\n', '    ) external {\n', '        ApproveSAFEModificationLike(safeEngine).denySAFEModification(usr);\n', '    }\n', '\n', '    /// @notice Opens a brand new Safe\n', '    /// @param manager address - Safe Manager\n', '    /// @param collateralType bytes32 - collateral type\n', '    /// @param usr address - Owner of the safe\n', '    function openSAFE(\n', '        address manager,\n', '        bytes32 collateralType,\n', '        address usr\n', '    ) public returns (uint safe) {\n', '        safe = ManagerLike(manager).openSAFE(collateralType, usr);\n', '    }\n', '\n', '    /// @notice Transfer the ownership of a proxy owned Safe\n', '    /// @param manager address - Safe Manager\n', '    /// @param safe uint - Safe Id\n', '    /// @param usr address - Owner of the safe\n', '    function transferSAFEOwnership(\n', '        address manager,\n', '        uint safe,\n', '        address usr\n', '    ) public {\n', '        ManagerLike(manager).transferSAFEOwnership(safe, usr);\n', '    }\n', '\n', '    /// @notice Transfer the ownership to a new proxy owned by a different address\n', '    /// @param proxyRegistry address - Safe Manager\n', '    /// @param manager address - Safe Manager\n', '    /// @param safe uint - Safe Id\n', '    /// @param dst address - Owner of the new proxy\n', '    function transferSAFEOwnershipToProxy(\n', '        address proxyRegistry,\n', '        address manager,\n', '        uint safe,\n', '        address dst\n', '    ) external {\n', '        // Gets actual proxy address\n', '        address proxy = ProxyRegistryLike(proxyRegistry).proxies(dst);\n', '        // Checks if the proxy address already existed and dst address is still the owner\n', '        if (proxy == address(0) || ProxyLike(proxy).owner() != dst) {\n', '            uint csize;\n', '            assembly {\n', '                csize := extcodesize(dst)\n', '            }\n', '            // We want to avoid creating a proxy for a contract address that might not be able to handle proxies, then losing the SAFE\n', '            require(csize == 0, "dst-is-a-contract");\n', '            // Creates the proxy for the dst address\n', '            proxy = ProxyRegistryLike(proxyRegistry).build(dst);\n', '        }\n', '        // Transfers SAFE to the dst proxy\n', '        transferSAFEOwnership(manager, safe, proxy);\n', '    }\n', '\n', '    /// @notice Allow/disallow a usr address to manage the safe\n', '    /// @param manager address - Safe Manager\n', '    /// @param safe uint - Safe Id\n', '    /// @param usr address - usr address\n', '    /// uint ok - 1 for allowed\n', '    function allowSAFE(\n', '        address manager,\n', '        uint safe,\n', '        address usr,\n', '        uint ok\n', '    ) external {\n', '        ManagerLike(manager).allowSAFE(safe, usr, ok);\n', '    }\n', '\n', '    /// @notice Allow/disallow a usr address to quit to the sender handler\n', '    /// @param manager address - Safe Manager\n', '    /// @param usr address - usr address\n', '    /// uint ok - 1 for allowed\n', '    function allowHandler(\n', '        address manager,\n', '        address usr,\n', '        uint ok\n', '    ) external {\n', '        ManagerLike(manager).allowHandler(usr, ok);\n', '    }\n', '\n', '    /// @notice Transfer wad amount of safe collateral from the safe address to a dst address.\n', '    /// @param manager address - Safe Manager\n', '    /// @param safe uint - Safe Id\n', '    /// @param dst address - destination address\n', '    /// uint wad - amount\n', '    function transferCollateral(\n', '        address manager,\n', '        uint safe,\n', '        address dst,\n', '        uint wad\n', '    ) public {\n', '        ManagerLike(manager).transferCollateral(safe, dst, wad);\n', '    }\n', '\n', '    /// @notice Transfer rad amount of COIN from the safe address to a dst address.\n', '    /// @param manager address - Safe Manager\n', '    /// @param safe uint - Safe Id\n', '    /// @param dst address - destination address\n', '    /// uint rad - amount\n', '    function transferInternalCoins(\n', '        address manager,\n', '        uint safe,\n', '        address dst,\n', '        uint rad\n', '    ) public {\n', '        ManagerLike(manager).transferInternalCoins(safe, dst, rad);\n', '    }\n', '\n', '\n', "    /// @notice Modify a SAFE's collateralization ratio while keeping the generated COIN or collateral freed in the SAFE handler address.\n", '    /// @param manager address - Safe Manager\n', '    /// @param safe uint - Safe Id\n', '    /// @param deltaCollateral - int\n', '    /// @param deltaDebt - int\n', '    function modifySAFECollateralization(\n', '        address manager,\n', '        uint safe,\n', '        int deltaCollateral,\n', '        int deltaDebt\n', '    ) public {\n', '        ManagerLike(manager).modifySAFECollateralization(safe, deltaCollateral, deltaDebt);\n', '    }\n', '\n', '    /// @notice Quit the system, migrating the safe (lockedCollateral, generatedDebt) to a different dst handler\n', '    /// @param manager address - Safe Manager\n', '    /// @param safe uint - Safe Id\n', '    /// @param dst - destination handler\n', '    function quitSystem(\n', '        address manager,\n', '        uint safe,\n', '        address dst\n', '    ) external {\n', '        ManagerLike(manager).quitSystem(safe, dst);\n', '    }\n', '\n', '    /// @notice Import a position from src handler to the handler owned by safe\n', '    /// @param manager address - Safe Manager\n', '    /// @param src - source handler\n', '    /// @param safe uint - Safe Id\n', '    function enterSystem(\n', '        address manager,\n', '        address src,\n', '        uint safe\n', '    ) external {\n', '        ManagerLike(manager).enterSystem(src, safe);\n', '    }\n', '\n', '    /// @notice Move a position from safeSrc handler to the safeDst handler\n', '    /// @param manager address - Safe Manager\n', '    /// @param safeSrc uint - Source Safe Id\n', '    /// @param safeDst uint - Destination Safe Id\n', '    function moveSAFE(\n', '        address manager,\n', '        uint safeSrc,\n', '        uint safeDst\n', '    ) external {\n', '        ManagerLike(manager).moveSAFE(safeSrc, safeDst);\n', '    }\n', '\n', '    /// @notice Lock ETH (msg.value) as collateral in safe\n', '    /// @param manager address - Safe Manager\n', '    /// @param ethJoin address\n', '    /// @param safe uint - Safe Id\n', '    function lockETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint safe\n', '    ) public payable {\n', '        _lockETH(manager, ethJoin, safe, msg.value);\n', '    }\n', '\n', '    /// @notice Free ETH (wad) from safe and sends it to msg.sender\n', '    /// @param manager address - Safe Manager\n', '    /// @param ethJoin address\n', '    /// @param safe uint - Safe Id\n', '    /// @param wad uint - Amount\n', '    function freeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint safe,\n', '        uint wad\n', '    ) public {\n', '        // Unlocks WETH amount from the SAFE\n', '        modifySAFECollateralization(manager, safe, -toInt(wad), 0);\n', "        // Moves the amount from the SAFE handler to proxy's address\n", '        transferCollateral(manager, safe, address(this), wad);\n', '        // Exits WETH amount to proxy address as a token\n', '        CollateralJoinLike(ethJoin).exit(address(this), wad);\n', '        // Converts WETH to ETH\n', '        CollateralJoinLike(ethJoin).collateral().withdraw(wad);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(wad);\n', '    }\n', '\n', '\n', '    /// @notice Exits ETH (wad) from balance available in the handler\n', '    /// @param manager address - Safe Manager\n', '    /// @param ethJoin address\n', '    /// @param safe uint - Safe Id\n', '    /// @param wad uint - Amount\n', '    function exitETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint safe,\n', '        uint wad\n', '    ) external {\n', "        // Moves the amount from the SAFE handler to proxy's address\n", '        transferCollateral(manager, safe, address(this), wad);\n', '        // Exits WETH amount to proxy address as a token\n', '        CollateralJoinLike(ethJoin).exit(address(this), wad);\n', '        // Converts WETH to ETH\n', '        CollateralJoinLike(ethJoin).collateral().withdraw(wad);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(wad);\n', '    }\n', '\n', '    /// @notice Generates debt and sends COIN amount to msg.sender\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param coinJoin address\n', '    /// @param safe uint - Safe Id\n', '    /// @param wad uint - Amount\n', '    function generateDebt(\n', '        address manager,\n', '        address taxCollector,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint wad\n', '    ) public {\n', '        _generateDebt(manager, taxCollector, coinJoin, safe, wad, msg.sender);\n', '    }\n', '\n', '    /// @notice Repays debt\n', '    /// @param manager address\n', '    /// @param coinJoin address\n', '    /// @param safe uint - Safe Id\n', '    /// @param wad uint - Amount\n', '    function repayDebt(\n', '        address manager,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint wad\n', '    ) public {\n', '        _repayDebt(manager, coinJoin, safe, wad, true);\n', '    }\n', '\n', '    /// @notice Locks Eth, generates debt and sends COIN amount (deltaWad) to msg.sender\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param ethJoin address\n', '    /// @param coinJoin address\n', '    /// @param safe uint - Safe Id\n', '    /// @param deltaWad uint - Amount\n', '    function lockETHAndGenerateDebt(\n', '        address manager,\n', '        address taxCollector,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint deltaWad\n', '    ) public payable {\n', '        _lockETH(manager, ethJoin, safe, msg.value);\n', '        _generateDebt(manager, taxCollector, coinJoin, safe, deltaWad, msg.sender);\n', '    }\n', '\n', '    /// @notice Opens Safe, locks Eth, generates debt and sends COIN amount (deltaWad) to msg.sender\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param ethJoin address\n', '    /// @param coinJoin address\n', '    /// @param deltaWad uint - Amount\n', '    function openLockETHAndGenerateDebt(\n', '        address manager,\n', '        address taxCollector,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        bytes32 collateralType,\n', '        uint deltaWad\n', '    ) external payable returns (uint safe) {\n', '        safe = openSAFE(manager, collateralType, address(this));\n', '        lockETHAndGenerateDebt(manager, taxCollector, ethJoin, coinJoin, safe, deltaWad);\n', '    }\n', '\n', '    /// @notice Repays debt and frees ETH (sends it to msg.sender)\n', '    /// @param manager address\n', '    /// @param ethJoin address\n', '    /// @param coinJoin address\n', '    /// @param safe uint - Safe Id\n', '    /// @param collateralWad uint - Amount of collateral to free\n', '    /// @param deltaWad uint - Amount of debt to repay\n', '    function repayDebtAndFreeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint collateralWad,\n', '        uint deltaWad\n', '    ) external {\n', '        _repayDebtAndFreeETH(manager, ethJoin, coinJoin, safe, collateralWad, deltaWad, true);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(collateralWad);\n', '    }    \n', '}\n', '\n', 'contract GebProxyActions is BasicActions {\n', '\n', '    function tokenCollateralJoin_join(address apt, address safe, uint amt, bool transferFrom) public {\n', '        // Only executes for tokens that have approval/transferFrom implementation\n', '        if (transferFrom) {\n', "            // Gets token from the user's wallet\n", '            CollateralJoinLike(apt).collateral().transferFrom(msg.sender, address(this), amt);\n', '            // Approves adapter to take the token amount\n', '            CollateralJoinLike(apt).collateral().approve(apt, amt);\n', '        }\n', '        // Joins token collateral into the safeEngine\n', '        CollateralJoinLike(apt).join(safe, amt);\n', '    }\n', '\n', '    function protectSAFE(\n', '        address manager,\n', '        uint safe,\n', '        address liquidationEngine,\n', '        address saviour\n', '    ) public {\n', '        ManagerLike(manager).protectSAFE(safe, liquidationEngine, saviour);\n', '    }\n', '\n', '    function makeCollateralBag(\n', '        address collateralJoin\n', '    ) public returns (address bag) {\n', '        bag = GNTJoinLike(collateralJoin).make(address(this));\n', '    }\n', '\n', '    function safeLockETH(\n', '        address manager,\n', '        address ethJoin,\n', '        uint safe,\n', '        address owner\n', '    ) public payable {\n', '        require(ManagerLike(manager).ownsSAFE(safe) == owner, "owner-missmatch");\n', '        lockETH(manager, ethJoin, safe);\n', '    }\n', '\n', '    function lockTokenCollateral(\n', '        address manager,\n', '        address collateralJoin,\n', '        uint safe,\n', '        uint amt,\n', '        bool transferFrom\n', '    ) public {\n', "        // Takes token amount from user's wallet and joins into the safeEngine\n", '        tokenCollateralJoin_join(collateralJoin, address(this), amt, transferFrom);\n', '        // Locks token amount into the SAFE\n', '        SAFEEngineLike(ManagerLike(manager).safeEngine()).modifySAFECollateralization(\n', '            ManagerLike(manager).collateralTypes(safe),\n', '            ManagerLike(manager).safes(safe),\n', '            address(this),\n', '            address(this),\n', '            toInt(convertTo18(collateralJoin, amt)),\n', '            0\n', '        );\n', '    }\n', '\n', '    function safeLockTokenCollateral(\n', '        address manager,\n', '        address collateralJoin,\n', '        uint safe,\n', '        uint amt,\n', '        bool transferFrom,\n', '        address owner\n', '    ) public {\n', '        require(ManagerLike(manager).ownsSAFE(safe) == owner, "owner-missmatch");\n', '        lockTokenCollateral(manager, collateralJoin, safe, amt, transferFrom);\n', '    }\n', '\n', '    function freeTokenCollateral(\n', '        address manager,\n', '        address collateralJoin,\n', '        uint safe,\n', '        uint amt\n', '    ) public {\n', '        uint wad = convertTo18(collateralJoin, amt);\n', '        // Unlocks token amount from the SAFE\n', '        modifySAFECollateralization(manager, safe, -toInt(wad), 0);\n', "        // Moves the amount from the SAFE handler to proxy's address\n", '        transferCollateral(manager, safe, address(this), wad);\n', "        // Exits token amount to the user's wallet as a token\n", '        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n', '    }\n', '\n', '    function exitTokenCollateral(\n', '        address manager,\n', '        address collateralJoin,\n', '        uint safe,\n', '        uint amt\n', '    ) public {\n', "        // Moves the amount from the SAFE handler to proxy's address\n", '        transferCollateral(manager, safe, address(this), convertTo18(collateralJoin, amt));\n', '\n', "        // Exits token amount to the user's wallet as a token\n", '        CollateralJoinLike(collateralJoin).exit(msg.sender, amt);\n', '    }\n', '\n', '    function generateDebtAndProtectSAFE(\n', '        address manager,\n', '        address taxCollector,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint wad,\n', '        address liquidationEngine,\n', '        address saviour\n', '    ) external {\n', '        generateDebt(manager, taxCollector, coinJoin, safe, wad);\n', '        protectSAFE(manager, safe, liquidationEngine, saviour);\n', '    }\n', '\n', '    function safeRepayDebt(\n', '        address manager,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint wad,\n', '        address owner\n', '    ) public {\n', '        require(ManagerLike(manager).ownsSAFE(safe) == owner, "owner-missmatch");\n', '        repayDebt(manager, coinJoin, safe, wad);\n', '    }\n', '\n', '    function repayAllDebt(\n', '        address manager,\n', '        address coinJoin,\n', '        uint safe\n', '    ) public {\n', '        address safeEngine = ManagerLike(manager).safeEngine();\n', '        address safeHandler = ManagerLike(manager).safes(safe);\n', '        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n', '        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safeHandler);\n', '\n', '        address own = ManagerLike(manager).ownsSAFE(safe);\n', '        if (own == address(this) || ManagerLike(manager).safeCan(own, safe, address(this)) == 1) {\n', '            // Joins COIN amount into the safeEngine\n', '            coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n', '            // Paybacks debt to the SAFE\n', '            modifySAFECollateralization(manager, safe, 0, -int(generatedDebt));\n', '        } else {\n', '            // Joins COIN amount into the safeEngine\n', '            coinJoin_join(coinJoin, address(this), _getRepaidAlDebt(safeEngine, address(this), safeHandler, collateralType));\n', '            // Paybacks debt to the SAFE\n', '            SAFEEngineLike(safeEngine).modifySAFECollateralization(\n', '                collateralType,\n', '                safeHandler,\n', '                address(this),\n', '                address(this),\n', '                0,\n', '                -int(generatedDebt)\n', '            );\n', '        }\n', '    }\n', '\n', '    function safeRepayAllDebt(\n', '        address manager,\n', '        address coinJoin,\n', '        uint safe,\n', '        address owner\n', '    ) public {\n', '        require(ManagerLike(manager).ownsSAFE(safe) == owner, "owner-missmatch");\n', '        repayAllDebt(manager, coinJoin, safe);\n', '    }\n', '\n', '    function openLockETHGenerateDebtAndProtectSAFE(\n', '        address manager,\n', '        address taxCollector,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        bytes32 collateralType,\n', '        uint deltaWad,\n', '        address liquidationEngine,\n', '        address saviour\n', '    ) public payable returns (uint safe) {\n', '        safe = openSAFE(manager, collateralType, address(this));\n', '        lockETHAndGenerateDebt(manager, taxCollector, ethJoin, coinJoin, safe, deltaWad);\n', '        protectSAFE(manager, safe, liquidationEngine, saviour);\n', '    }\n', '\n', '    function lockTokenCollateralAndGenerateDebt(\n', '        address manager,\n', '        address taxCollector,\n', '        address collateralJoin,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint collateralAmount,\n', '        uint deltaWad,\n', '        bool transferFrom\n', '    ) public {\n', '        address safeHandler = ManagerLike(manager).safes(safe);\n', '        address safeEngine = ManagerLike(manager).safeEngine();\n', '        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n', "        // Takes token amount from user's wallet and joins into the safeEngine\n", '        tokenCollateralJoin_join(collateralJoin, safeHandler, collateralAmount, transferFrom);\n', '        // Locks token amount into the SAFE and generates debt\n', '        modifySAFECollateralization(manager, safe, toInt(convertTo18(collateralJoin, collateralAmount)), _getGeneratedDeltaDebt(safeEngine, taxCollector, safeHandler, collateralType, deltaWad));\n', "        // Moves the COIN amount (balance in the safeEngine in rad) to proxy's address\n", '        transferInternalCoins(manager, safe, address(this), toRad(deltaWad));\n', "        // Allows adapter to access to proxy's COIN balance in the safeEngine\n", '        if (SAFEEngineLike(safeEngine).canModifySAFE(address(this), address(coinJoin)) == 0) {\n', '            SAFEEngineLike(safeEngine).approveSAFEModification(coinJoin);\n', '        }\n', "        // Exits COIN to the user's wallet as a token\n", '        CoinJoinLike(coinJoin).exit(msg.sender, deltaWad);\n', '    }\n', '\n', '    function lockTokenCollateralGenerateDebtAndProtectSAFE(\n', '        address manager,\n', '        address taxCollector,\n', '        address collateralJoin,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint collateralAmount,\n', '        uint deltaWad,\n', '        bool transferFrom,\n', '        address liquidationEngine,\n', '        address saviour\n', '    ) public {\n', '        lockTokenCollateralAndGenerateDebt(\n', '          manager,\n', '          taxCollector,\n', '          collateralJoin,\n', '          coinJoin,\n', '          safe,\n', '          collateralAmount,\n', '          deltaWad,\n', '          transferFrom\n', '        );\n', '        protectSAFE(manager, safe, liquidationEngine, saviour);\n', '    }\n', '\n', '    function openLockTokenCollateralAndGenerateDebt(\n', '        address manager,\n', '        address taxCollector,\n', '        address collateralJoin,\n', '        address coinJoin,\n', '        bytes32 collateralType,\n', '        uint collateralAmount,\n', '        uint deltaWad,\n', '        bool transferFrom\n', '    ) public returns (uint safe) {\n', '        safe = openSAFE(manager, collateralType, address(this));\n', '        lockTokenCollateralAndGenerateDebt(manager, taxCollector, collateralJoin, coinJoin, safe, collateralAmount, deltaWad, transferFrom);\n', '    }\n', '\n', '    function openLockTokenCollateralGenerateDebtAndProtectSAFE(\n', '        address manager,\n', '        address taxCollector,\n', '        address collateralJoin,\n', '        address coinJoin,\n', '        bytes32 collateralType,\n', '        uint collateralAmount,\n', '        uint deltaWad,\n', '        bool transferFrom,\n', '        address liquidationEngine,\n', '        address saviour\n', '    ) public returns (uint safe) {\n', '        safe = openSAFE(manager, collateralType, address(this));\n', '        lockTokenCollateralAndGenerateDebt(manager, taxCollector, collateralJoin, coinJoin, safe, collateralAmount, deltaWad, transferFrom);\n', '        protectSAFE(manager, safe, liquidationEngine, saviour);\n', '    }\n', '\n', '    function openLockGNTAndGenerateDebt(\n', '        address manager,\n', '        address taxCollector,\n', '        address gntJoin,\n', '        address coinJoin,\n', '        bytes32 collateralType,\n', '        uint collateralAmount,\n', '        uint deltaWad\n', '    ) public returns (address bag, uint safe) {\n', "        // Creates bag (if doesn't exist) to hold GNT\n", '        bag = GNTJoinLike(gntJoin).bags(address(this));\n', '        if (bag == address(0)) {\n', '            bag = makeCollateralBag(gntJoin);\n', '        }\n', '        // Transfer funds to the funds which previously were sent to the proxy\n', '        CollateralLike(CollateralJoinLike(gntJoin).collateral()).transfer(bag, collateralAmount);\n', '        safe = openLockTokenCollateralAndGenerateDebt(manager, taxCollector, gntJoin, coinJoin, collateralType, collateralAmount, deltaWad, false);\n', '    }\n', '\n', '    function openLockGNTGenerateDebtAndProtectSAFE(\n', '        address manager,\n', '        address taxCollector,\n', '        address gntJoin,\n', '        address coinJoin,\n', '        bytes32 collateralType,\n', '        uint collateralAmount,\n', '        uint deltaWad,\n', '        address liquidationEngine,\n', '        address saviour\n', '    ) public returns (address bag, uint safe) {\n', '        (bag, safe) = openLockGNTAndGenerateDebt(\n', '          manager,\n', '          taxCollector,\n', '          gntJoin,\n', '          coinJoin,\n', '          collateralType,\n', '          collateralAmount,\n', '          deltaWad\n', '        );\n', '        protectSAFE(manager, safe, liquidationEngine, saviour);\n', '    }\n', '\n', '    function repayAllDebtAndFreeETH(\n', '        address manager,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint collateralWad\n', '    ) public {\n', '        address safeEngine = ManagerLike(manager).safeEngine();\n', '        address safeHandler = ManagerLike(manager).safes(safe);\n', '        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n', '        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safeHandler);\n', '\n', '        // Joins COIN amount into the safeEngine\n', '        coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n', '        // Paybacks debt to the SAFE and unlocks WETH amount from it\n', '        modifySAFECollateralization(\n', '            manager,\n', '            safe,\n', '            -toInt(collateralWad),\n', '            -int(generatedDebt)\n', '        );\n', "        // Moves the amount from the SAFE handler to proxy's address\n", '        transferCollateral(manager, safe, address(this), collateralWad);\n', '        // Exits WETH amount to proxy address as a token\n', '        CollateralJoinLike(ethJoin).exit(address(this), collateralWad);\n', '        // Converts WETH to ETH\n', '        CollateralJoinLike(ethJoin).collateral().withdraw(collateralWad);\n', "        // Sends ETH back to the user's wallet\n", '        msg.sender.transfer(collateralWad);\n', '    }\n', '\n', '    function repayDebtAndFreeTokenCollateral(\n', '        address manager,\n', '        address collateralJoin,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint collateralAmount,\n', '        uint deltaWad\n', '    ) external {\n', '        address safeHandler = ManagerLike(manager).safes(safe);\n', '        // Joins COIN amount into the safeEngine\n', '        coinJoin_join(coinJoin, safeHandler, deltaWad);\n', '        uint collateralWad = convertTo18(collateralJoin, collateralAmount);\n', '        // Paybacks debt to the SAFE and unlocks token amount from it\n', '        modifySAFECollateralization(\n', '            manager,\n', '            safe,\n', '            -toInt(collateralWad),\n', '            _getRepaidDeltaDebt(ManagerLike(manager).safeEngine(), SAFEEngineLike(ManagerLike(manager).safeEngine()).coinBalance(safeHandler), safeHandler, ManagerLike(manager).collateralTypes(safe))\n', '        );\n', "        // Moves the amount from the SAFE handler to proxy's address\n", '        transferCollateral(manager, safe, address(this), collateralWad);\n', "        // Exits token amount to the user's wallet as a token\n", '        CollateralJoinLike(collateralJoin).exit(msg.sender, collateralAmount);\n', '    }\n', '\n', '    function repayAllDebtAndFreeTokenCollateral(\n', '        address manager,\n', '        address collateralJoin,\n', '        address coinJoin,\n', '        uint safe,\n', '        uint collateralAmount\n', '    ) public {\n', '        address safeEngine = ManagerLike(manager).safeEngine();\n', '        address safeHandler = ManagerLike(manager).safes(safe);\n', '        bytes32 collateralType = ManagerLike(manager).collateralTypes(safe);\n', '        (, uint generatedDebt) = SAFEEngineLike(safeEngine).safes(collateralType, safeHandler);\n', '\n', '        // Joins COIN amount into the safeEngine\n', '        coinJoin_join(coinJoin, safeHandler, _getRepaidAlDebt(safeEngine, safeHandler, safeHandler, collateralType));\n', '        uint collateralWad = convertTo18(collateralJoin, collateralAmount);\n', '        // Paybacks debt to the SAFE and unlocks token amount from it\n', '        modifySAFECollateralization(\n', '            manager,\n', '            safe,\n', '            -toInt(collateralWad),\n', '            -int(generatedDebt)\n', '        );\n', "        // Moves the amount from the SAFE handler to proxy's address\n", '        transferCollateral(manager, safe, address(this), collateralWad);\n', "        // Exits token amount to the user's wallet as a token\n", '        CollateralJoinLike(collateralJoin).exit(msg.sender, collateralAmount);\n', '    }\n', '}\n', '\n', 'abstract contract GebIncentivesLike {\n', '    function stakingToken() virtual public returns (address);\n', '    function rewardsToken() virtual public returns (address);\n', '    function stake(uint256) virtual public;\n', '    function withdraw(uint256) virtual public;\n', '    function exit() virtual public;\n', '    function balanceOf(address) virtual public view returns (uint256);\n', '    function getReward() virtual public;\n', '}\n', '\n', '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n', '// WARNING: These functions meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n', '// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n', '\n', '/// @title Incentives proxy actions\n', '/// @notice This contract is supposed to be used alongside a DSProxy contract.\n', '/// @dev These functions are meant to be used as a a library for a DSProxy. Some are unsafe if you call them directly.\n', 'contract GebProxyIncentivesActions is BasicActions {\n', '    // Internal functions\n', '\n', '    /// @notice Provides liquidity on uniswap.\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap Router V2\n', '    /// @param tokenWad uint - amount of tokens to provide liquidity with\n', '    /// @param ethWad uint - amount of ETH to provide liquidity with\n', '    /// @param to address - receiver of the balance of generated LP Tokens\n', '    /// @param minTokenAmounts uint - Minimum amounts of both ETH and the token (user selected acceptable slippage)\n', '    /// @dev Uniswap will return unused tokens (it provides liquidity with the best current ratio)\n', '    /// @dev Public funcitons should account for change sent from Uniswap\n', '    function _provideLiquidityUniswap(address coinJoin, address uniswapRouter, uint tokenWad, uint ethWad, address to, uint[2] memory minTokenAmounts) internal {\n', '        CoinJoinLike(coinJoin).systemCoin().approve(uniswapRouter, tokenWad);\n', '        IUniswapV2Router02(uniswapRouter).addLiquidityETH{value: ethWad}(\n', '            address(CoinJoinLike(coinJoin).systemCoin()),\n', '            tokenWad,\n', '            minTokenAmounts[0],\n', '            minTokenAmounts[1],\n', '            to,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    /// @notice Stakes in Incentives Pool (geb-incentives)\n', '    /// @param incentives address - Liquidity mining pool\n', '    function _stakeInMine(address incentives) internal {\n', '        DSTokenLike lpToken = DSTokenLike(GebIncentivesLike(incentives).stakingToken());\n', '        lpToken.approve(incentives, uint(0 - 1));\n', '        GebIncentivesLike(incentives).stake(lpToken.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Removes liquidity from Uniswap\n', '    /// @param uniswapRouter address - Uniswap Router V2\n', '    /// @param systemCoin address - Address of COIN\n', '    /// @param value uint - amount of LP Tokens to remove liquidity with\n', '    /// @param to address - receiver of the balances of generated ETH / COIN\n', '    /// @param minTokenAmounts uint - Minimum amounts of both ETH and the token (user selected acceptable slippage)\n', '    function _removeLiquidityUniswap(address uniswapRouter, address systemCoin, uint value, address to, uint[2] memory minTokenAmounts) internal returns (uint amountA, uint amountB) {\n', '        DSTokenLike(getWethPair(uniswapRouter, systemCoin)).approve(uniswapRouter, value);\n', '        return IUniswapV2Router02(uniswapRouter).removeLiquidityETH(\n', '            systemCoin,\n', '            value,\n', '            minTokenAmounts[0],\n', '            minTokenAmounts[1],\n', '            to,\n', '            block.timestamp\n', '        );\n', '    }\n', '\n', '    /// @notice Opens Safe, locks Eth, generates debt and sends COIN amount (deltaWad) and provides it as liquidity to Uniswap\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param ethJoin address\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param collateralType bytes32 - The ETH type used to generate debt\n', '    /// @param deltaWad uint - Amount of debt to generate\n', '    /// @param liquidityWad uint - Amount of ETH to be provided as liquidity (the remainder of msg.value will be used to collateralize the Safe)\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function openLockETHGenerateDebtProvideLiquidityUniswap(\n', '        address manager,\n', '        address taxCollector,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        address uniswapRouter,\n', '        bytes32 collateralType,\n', '        uint deltaWad,\n', '        uint liquidityWad,\n', '        uint[2] calldata minTokenAmounts\n', '    ) external payable returns (uint safe) {\n', '        safe = openSAFE(manager, collateralType, address(this));\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '\n', '        _lockETH(manager, ethJoin, safe, subtract(msg.value, liquidityWad));\n', '\n', '        _generateDebt(manager, taxCollector, coinJoin, safe, deltaWad, address(this));\n', '\n', '        _provideLiquidityUniswap(coinJoin, uniswapRouter, deltaWad, liquidityWad, msg.sender, minTokenAmounts);\n', '\n', '        // sending back any leftover tokens/eth, necessary to manage change from providing liquidity\n', '        msg.sender.call{value: address(this).balance}("");\n', '        systemCoin.transfer(msg.sender, systemCoin.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Locks Eth, generates debt and sends COIN amount (deltaWad) and provides it as liquidity to Uniswap\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param ethJoin address\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param safe uint - Safe Id\n', '    /// @param deltaWad uint - Amount of debt to generate\n', '    /// @param liquidityWad uint - Amount of ETH to be provided as liquidity (the remainder of msg.value will be used to collateralize the Safe)\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function lockETHGenerateDebtProvideLiquidityUniswap(\n', '        address manager,\n', '        address taxCollector,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        address uniswapRouter,\n', '        uint safe,\n', '        uint deltaWad,\n', '        uint liquidityWad,\n', '        uint[2] calldata minTokenAmounts\n', '    ) external payable {\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '\n', '        _lockETH(manager, ethJoin, safe, subtract(msg.value, liquidityWad));\n', '\n', '        _generateDebt(manager, taxCollector, coinJoin, safe, deltaWad, address(this));\n', '\n', '        _provideLiquidityUniswap(coinJoin, uniswapRouter, deltaWad, liquidityWad, msg.sender, minTokenAmounts);\n', '\n', '        // sending back any leftover tokens/eth, necessary to manage change from providing liquidity\n', '        msg.sender.call{value: address(this).balance}("");\n', '        systemCoin.transfer(msg.sender, systemCoin.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Opens Safe, locks Eth, generates debt and sends COIN amount (deltaWad) and provides it as liquidity to Uniswap and stakes LP tokens in Farm\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param ethJoin address\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param collateralType bytes32 - The ETH type used to generate debt\n', '    /// @param deltaWad uint256 - Amount of debt to generate\n', '    /// @param liquidityWad uint256 - Amount of ETH to be provided as liquidity (the remainder of msg.value will be used to collateralize the Safe)\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function openLockETHGenerateDebtProvideLiquidityStake(\n', '        address manager,\n', '        address taxCollector,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        address uniswapRouter,\n', '        address incentives,\n', '        bytes32 collateralType,\n', '        uint256 deltaWad,\n', '        uint256 liquidityWad,\n', '        uint256[2] calldata minTokenAmounts\n', '    ) external payable returns (uint safe) {\n', '        safe = openSAFE(manager, collateralType, address(this));\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '\n', '        _lockETH(manager, ethJoin, safe, subtract(msg.value, liquidityWad));\n', '\n', '        _generateDebt(manager, taxCollector, coinJoin, safe, deltaWad, address(this));\n', '\n', '        _provideLiquidityUniswap(coinJoin, uniswapRouter, deltaWad, liquidityWad, address(this), minTokenAmounts);\n', '\n', '        _stakeInMine(incentives);\n', '\n', '        // sending back any leftover tokens/eth, necessary to manage change from providing liquidity\n', '        msg.sender.call{value: address(this).balance}("");\n', '        systemCoin.transfer(msg.sender, systemCoin.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Locks Eth, generates debt and sends COIN amount (deltaWad) and provides it as liquidity to Uniswap and stakes LP tokens in Farm\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param ethJoin address\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param safe uint - Safe Id\n', '    /// @param deltaWad uint - Amount of debt to generate\n', '    /// @param liquidityWad uint - Amount of ETH to be provided as liquidity (the remainder of msg.value will be used to collateralize the Safe)\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function lockETHGenerateDebtProvideLiquidityStake(\n', '        address manager,\n', '        address taxCollector,\n', '        address ethJoin,\n', '        address coinJoin,\n', '        address uniswapRouter,\n', '        address incentives,\n', '        uint safe,\n', '        uint deltaWad,\n', '        uint liquidityWad,\n', '        uint[2] memory minTokenAmounts\n', '    ) public payable {\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '\n', '        _lockETH(manager, ethJoin, safe, subtract(msg.value, liquidityWad));\n', '\n', '        _generateDebt(manager, taxCollector, coinJoin, safe, deltaWad, address(this));\n', '\n', '        _provideLiquidityUniswap(coinJoin, uniswapRouter, deltaWad, liquidityWad, address(this), minTokenAmounts);\n', '\n', '        _stakeInMine(incentives);\n', '\n', '        // sending back any leftover tokens/eth, necessary to manage change from providing liquidity\n', '        msg.sender.call{value: address(this).balance}("");\n', '        systemCoin.transfer(msg.sender, systemCoin.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Provides liquidity to Uniswap\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param wad uint - Amount of coin to provide (msg.value for ETH)\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function provideLiquidityUniswap(address coinJoin, address uniswapRouter, uint wad, uint[2] calldata minTokenAmounts) external payable {\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '        systemCoin.transferFrom(msg.sender, address(this), wad);\n', '        _provideLiquidityUniswap(coinJoin, uniswapRouter, wad, msg.value, msg.sender, minTokenAmounts);\n', '\n', '        // sending back any leftover tokens/eth, necessary to manage change from providing liquidity\n', '        msg.sender.call{value: address(this).balance}("");\n', '        systemCoin.transfer(msg.sender, systemCoin.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Generates debt and sends COIN amount (deltaWad) and provides it as liquidity to Uniswap and stakes LP tokens in Farm\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function provideLiquidityStake(\n', '        address coinJoin,\n', '        address uniswapRouter,\n', '        address incentives,\n', '        uint wad,\n', '        uint[2] memory minTokenAmounts\n', '    ) public payable {\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '        systemCoin.transferFrom(msg.sender, address(this), wad);\n', '        _provideLiquidityUniswap(coinJoin, uniswapRouter, wad, msg.value, address(this), minTokenAmounts);\n', '\n', '        _stakeInMine(incentives);\n', '\n', '        // sending back any leftover tokens/eth, necessary to manage change from providing liquidity\n', '        msg.sender.call{value: address(this).balance}("");\n', '        systemCoin.transfer(msg.sender, systemCoin.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Generates debt and sends COIN amount (deltaWad) and provides it as liquidity to Uniswap\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param safe uint - Safe Id\n', '    /// @param wad uint - Amount of debt to generate\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function generateDebtAndProvideLiquidityUniswap(\n', '        address manager,\n', '        address taxCollector,\n', '        address coinJoin,\n', '        address uniswapRouter,\n', '        uint safe,\n', '        uint wad,\n', '        uint[2] calldata minTokenAmounts\n', '    ) external payable {\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '        _generateDebt(manager, taxCollector, coinJoin, safe, wad, address(this));\n', '\n', '        _provideLiquidityUniswap(coinJoin, uniswapRouter, wad, msg.value, msg.sender, minTokenAmounts);\n', '\n', '        // sending back any leftover tokens/eth, necessary to manage change from providing liquidity\n', '        msg.sender.call{value: address(this).balance}("");\n', '        systemCoin.transfer(msg.sender, systemCoin.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Stakes in liquidity mining pool\n', '    /// @param incentives address - pool address\n', '    /// @param wad uint - amount\n', '    function stakeInMine(address incentives, uint wad) external {\n', '        DSTokenLike(GebIncentivesLike(incentives).stakingToken()).transferFrom(msg.sender, address(this), wad);\n', '        _stakeInMine(incentives);\n', '    }\n', '\n', '    /// @notice Generates debt and sends COIN amount (deltaWad) and provides it as liquidity to Uniswap and stakes LP tokens in Farm\n', '    /// @param manager address\n', '    /// @param taxCollector address\n', '    /// @param coinJoin address\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param safe uint - Safe Id\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function generateDebtAndProvideLiquidityStake(\n', '        address manager,\n', '        address taxCollector,\n', '        address coinJoin,\n', '        address uniswapRouter,\n', '        address incentives,\n', '        uint safe,\n', '        uint wad,\n', '        uint[2] calldata minTokenAmounts\n', '    ) external payable {\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '        _generateDebt(manager, taxCollector, coinJoin, safe, wad, address(this));\n', '        _provideLiquidityUniswap(coinJoin, uniswapRouter, wad, msg.value, address(this), minTokenAmounts);\n', '        _stakeInMine(incentives);\n', '\n', '        // sending back any leftover tokens/eth, necessary to manage change from providing liquidity\n', '        msg.sender.call{value: address(this).balance}("");\n', '        systemCoin.transfer(msg.sender, systemCoin.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Harvests rewards available (both instant and staked) \n', '    /// @param incentives address - Liquidity mining pool\n', '    function getRewards(address incentives) public {\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        DSTokenLike rewardToken = DSTokenLike(incentivesContract.rewardsToken());\n', '        incentivesContract.getReward();\n', '        rewardToken.transfer(msg.sender, rewardToken.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Exits liquidity mining pool (withdraw LP tokens and getRewards for current campaign)\n', '    /// @param incentives address - Liquidity mining pool\n', '    function exitMine(address incentives) external {\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        DSTokenLike rewardToken = DSTokenLike(incentivesContract.rewardsToken());\n', '        DSTokenLike lpToken = DSTokenLike(incentivesContract.stakingToken());\n', '        incentivesContract.exit();\n', '        rewardToken.transfer(msg.sender, rewardToken.balanceOf(address(this)));\n', '        lpToken.transfer(msg.sender, lpToken.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Migrates from one campaign to another, claiming rewards\n', '    /// @param _oldIncentives Old liquidity mining pool\n', '    /// @param _newIncentives New liquidity mining pool\n', '    function migrateCampaign(address _oldIncentives, address _newIncentives) external {\n', '        GebIncentivesLike incentives = GebIncentivesLike(_oldIncentives);\n', '        GebIncentivesLike newIncentives = GebIncentivesLike(_newIncentives);\n', '        require(incentives.stakingToken() == newIncentives.stakingToken(), "geb-incentives/mismatched-staking-tokens");\n', '        DSTokenLike rewardToken = DSTokenLike(incentives.rewardsToken());\n', '        DSTokenLike lpToken = DSTokenLike(incentives.stakingToken());\n', '        incentives.exit();\n', '\n', '        _stakeInMine(_newIncentives);\n', '\n', '        rewardToken.transfer(msg.sender, rewardToken.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Withdraw LP tokens from liquidity mining pool\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param value uint - value to withdraw\n', '    function withdrawFromMine(address incentives, uint value) external {\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        DSTokenLike lpToken = DSTokenLike(incentivesContract.stakingToken());\n', '        incentivesContract.withdraw(value);\n', '        lpToken.transfer(msg.sender, lpToken.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Withdraw LP tokens from liquidity mining pool and harvests rewards\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param value uint - value to withdraw\n', '    function withdrawAndHarvest(address incentives, uint value) external {\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        DSTokenLike rewardToken = DSTokenLike(incentivesContract.rewardsToken());\n', '        DSTokenLike lpToken = DSTokenLike(incentivesContract.stakingToken());\n', '        incentivesContract.withdraw(value);\n', '        getRewards(incentives);\n', '        lpToken.transfer(msg.sender, lpToken.balanceOf(address(this)));\n', '    }\n', '\n', '    /// @notice Withdraw LP tokens from liquidity mining pool and harvests rewards\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param systemCoin address\n', '    /// @param value uint - value to withdraw\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function withdrawHarvestRemoveLiquidity(address incentives, address uniswapRouter, address systemCoin, uint value, uint[2] memory minTokenAmounts) public returns (uint amountA, uint amountB) {\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        DSTokenLike rewardToken = DSTokenLike(incentivesContract.rewardsToken());\n', '        DSTokenLike lpToken = DSTokenLike(incentivesContract.stakingToken());\n', '        incentivesContract.withdraw(value);\n', '        getRewards(incentives);\n', '        rewardToken.transfer(msg.sender, rewardToken.balanceOf(address(this)));\n', '        return _removeLiquidityUniswap(uniswapRouter, systemCoin, lpToken.balanceOf(address(this)), msg.sender, minTokenAmounts);\n', '    }\n', '\n', '    /// @notice Removes liquidity from Uniswap\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param systemCoin address\n', '    /// @param value uint - Amount of LP tokens to remove\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function removeLiquidityUniswap(address uniswapRouter, address systemCoin, uint value, uint[2] calldata minTokenAmounts) external returns (uint amountA, uint amountB) {\n', '        DSTokenLike(getWethPair(uniswapRouter, systemCoin)).transferFrom(msg.sender, address(this), value);\n', '        return _removeLiquidityUniswap(uniswapRouter, systemCoin, value, msg.sender, minTokenAmounts);\n', '    }\n', '\n', '    /// @notice Withdraws from liquidity mining pool and removes liquidity from Uniswap\n', '    /// @param coinJoin address\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function withdrawAndRemoveLiquidity(address coinJoin, address incentives, uint value, address uniswapRouter, uint[2] calldata minTokenAmounts) external returns (uint amountA, uint amountB) {\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        incentivesContract.withdraw(value);\n', '        return _removeLiquidityUniswap(uniswapRouter, address(CoinJoinLike(coinJoin).systemCoin()), value, msg.sender, minTokenAmounts);\n', '    }\n', '\n', '    /// @notice Withdraws from liquidity mining pool, removes liquidity from Uniswap and repays debt\n', '    /// @param manager address\n', '    /// @param coinJoin address\n', '    /// @param safe uint - Safe Id\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function withdrawRemoveLiquidityRepayDebt(address manager, address coinJoin, uint safe, address incentives, uint value, address uniswapRouter, uint[2] calldata minTokenAmounts) external {\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        DSTokenLike rewardToken = DSTokenLike(incentivesContract.rewardsToken());\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '        incentivesContract.withdraw(value);\n', '\n', '        _removeLiquidityUniswap(uniswapRouter, address(systemCoin), value, address(this), minTokenAmounts);\n', '        _repayDebt(manager, coinJoin, safe, systemCoin.balanceOf(address(this)), false);\n', '        rewardToken.transfer(msg.sender, rewardToken.balanceOf(address(this)));\n', '        msg.sender.call{value: address(this).balance}("");\n', '    }\n', '\n', '    /// @notice Exits from liquidity mining pool and removes liquidity from Uniswap\n', '    /// @param coinJoin address\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function exitAndRemoveLiquidity(address coinJoin, address incentives, address uniswapRouter, uint[2] calldata minTokenAmounts) external returns (uint amountA, uint amountB) {\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        DSTokenLike rewardToken = DSTokenLike(incentivesContract.rewardsToken());\n', '        DSTokenLike lpToken = DSTokenLike(incentivesContract.stakingToken());\n', '        incentivesContract.exit();\n', '        rewardToken.transfer(msg.sender, rewardToken.balanceOf(address(this)));\n', '        return _removeLiquidityUniswap(uniswapRouter, address(CoinJoinLike(coinJoin).systemCoin()), lpToken.balanceOf(address(this)), msg.sender, minTokenAmounts);\n', '    }\n', '\n', '    /// @notice Exits from liquidity mining pool, removes liquidity from Uniswap and repays debt\n', '    /// @param manager address\n', '    /// @param coinJoin address\n', '    /// @param safe uint - Safe Id\n', '    /// @param incentives address - Liquidity mining pool\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param minTokenAmounts uint[2] - minimum ETH/Token amounts when providing liquidity to Uniswap (user set acceptable slippage)\n', '    function exitRemoveLiquidityRepayDebt(address manager, address coinJoin, uint safe, address incentives, address uniswapRouter, uint[2] calldata minTokenAmounts) external {\n', '\n', '        GebIncentivesLike incentivesContract = GebIncentivesLike(incentives);\n', '        DSTokenLike rewardToken = DSTokenLike(incentivesContract.rewardsToken());\n', '        DSTokenLike lpToken = DSTokenLike(incentivesContract.stakingToken());\n', '        DSTokenLike systemCoin = DSTokenLike(CoinJoinLike(coinJoin).systemCoin());\n', '        incentivesContract.exit();\n', '        rewardToken.transfer(msg.sender, rewardToken.balanceOf(address(this)));\n', '\n', '        _removeLiquidityUniswap(uniswapRouter, address(systemCoin), lpToken.balanceOf(address(this)), address(this), minTokenAmounts);\n', '\n', '        _repayDebt(manager, coinJoin, safe, systemCoin.balanceOf(address(this)), false);\n', '        msg.sender.call{value: address(this).balance}("");\n', '    }\n', '\n', '    /// @notice Returns the address of a token-weth pair\n', '    /// @param uniswapRouter address - Uniswap V2 Router\n', '    /// @param token address of the token\n', '    function getWethPair(address uniswapRouter, address token) public view returns (address) {\n', '        IUniswapV2Router02 router = IUniswapV2Router02(uniswapRouter);\n', '        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\n', '        return factory.getPair(token, router.WETH());\n', '    }\n', '}']