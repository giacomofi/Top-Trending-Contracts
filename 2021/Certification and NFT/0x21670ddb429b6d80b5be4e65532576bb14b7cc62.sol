['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-03\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.2;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/*******************************************************\n', ' *                     Ownable\n', ' *******************************************************/\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', '\n', '/*******************************************************\n', ' *                       Interfaces\n', ' *******************************************************/\n', 'interface ICyToken {\n', '    function underlying() external view returns (address);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function supplyRatePerBlock() external view returns (uint256);\n', '\n', '    function borrowRatePerBlock() external view returns (uint256);\n', '\n', '    function exchangeRateStored() external view returns (uint256);\n', '\n', '    function reserveFactorMantissa() external view returns (uint256);\n', '\n', '    function getCash() external view returns (uint256);\n', '\n', '    function totalBorrows() external view returns (uint256);\n', '\n', '    function borrowBalanceStored(address accountAddress)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function totalReserves() external view returns (uint256);\n', '\n', '    function balanceOf(address accountAddress) external view returns (uint256);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', 'interface IUnitroller {\n', '    struct Market {\n', '        bool isListed;\n', '        uint256 collateralFactorMantissa;\n', '    }\n', '\n', '    function oracle() external view returns (address);\n', '\n', '    function getAssetsIn(address accountAddress)\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '\n', '    function markets(address marketAddress)\n', '        external\n', '        view\n', '        returns (Market memory);\n', '}\n', '\n', 'interface IAddressesGenerator {\n', '    function assetsAddresses() external view returns (address[] memory);\n', '\n', '    function assetsLength() external view returns (uint256);\n', '\n', '    function registry() external view returns (address);\n', '\n', '    function getPositionSpenderAddresses()\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '}\n', '\n', 'interface IHelper {\n', '    struct Allowance {\n', '        address owner;\n', '        address spender;\n', '        uint256 amount;\n', '        address token;\n', '    }\n', '\n', '    function allowances(\n', '        address ownerAddress,\n', '        address[] memory tokensAddresses,\n', '        address[] memory spenderAddresses\n', '    ) external view returns (Allowance[] memory);\n', '\n', '    function uniqueAddresses(address[] memory input)\n', '        external\n', '        pure\n', '        returns (address[] memory);\n', '}\n', '\n', 'interface ICreamOracle {\n', '    function getUnderlyingPrice(address) external view returns (uint256);\n', '}\n', '\n', 'interface IOracle {\n', '    function getNormalizedValueUsdc(\n', '        address tokenAddress,\n', '        uint256 amount,\n', '        uint256 priceUsdc\n', '    ) external view returns (uint256);\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function approve(address spender, uint256 amount) external;\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address spender, address owner)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', '/*******************************************************\n', ' *                     Adapter Logic\n', ' *******************************************************/\n', 'contract RegistryAdapterIronBank is Ownable {\n', '    /*******************************************************\n', '     *           Common code shared by all adapters\n', '     *******************************************************/\n', '    address public comptrollerAddress; // Comptroller address\n', '    address public creamOracleAddress; // Cream oracle address\n', '    address public helperAddress; // Helper utility address\n', '    address public oracleAddress; // Yearn oracle address\n', '    uint256 public blocksPerYear = 2102400;\n', '    address[] private _extensionsAddresses; // Optional contract extensions provide a way to add new features at a later date\n', '    ICreamOracle creamOracle; // Cream oracle\n', '    IUnitroller comptroller; // Comptroller\n', '    IOracle oracle; // Yearn oracle\n', '    IHelper helper; // A helper utility is used for batch allowance fetching and address array merging\n', '    IAddressesGenerator public addressesGenerator; // A utility for fetching assets addresses and length\n', '\n', '    /**\n', '     * High level static information about an asset\n', '     */\n', '    struct AssetStatic {\n', '        address id; // Asset address\n', '        string typeId; // Asset typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        address tokenId; // Underlying token address\n', '        string name; // Asset Name\n', '        string version; // Asset version\n', '        string symbol; // Asset symbol\n', '        uint8 decimals; // Asset decimals\n', '    }\n', '\n', '    /**\n', '     * High level dynamic information about an asset\n', '     */\n', '    struct AssetDynamic {\n', '        address id; // Asset address\n', '        string typeId; // Asset typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        address tokenId; // Underlying token address;\n', '        TokenAmount underlyingTokenBalance; // Underlying token balances\n', '        AssetMetadata metadata; // Metadata specific to the asset type of this adapter\n', '    }\n', '\n', '    /**\n', "     * Information about a user's position relative to an asset\n", '     */\n', '    struct Position {\n', '        address assetId; // Asset address\n', '        address tokenId; // Underlying asset token address\n', '        string typeId; // Position typeId (for example "DEPOSIT," "BORROW," "LEND")\n', '        uint256 balance; // asset.balanceOf(account)\n', "        TokenAmount underlyingTokenBalance; // Represents a user's asset position in underlying tokens\n", '        Allowance[] tokenAllowances; // Underlying token allowances\n', '        Allowance[] assetAllowances; // Asset allowances\n', '    }\n', '\n', '    /**\n', '     * Token amount representation\n', '     */\n', '    struct TokenAmount {\n', '        uint256 amount; // Amount in underlying token decimals\n', '        uint256 amountUsdc; // Amount in USDC (6 decimals)\n', '    }\n', '\n', '    /**\n', '     * Allowance information\n', '     */\n', '    struct Allowance {\n', '        address owner; // Allowance owner\n', '        address spender; // Allowance spender\n', '        uint256 amount; // Allowance amount (in underlying token)\n', '    }\n', '\n', '    /**\n', '     * Information about the adapter\n', '     */\n', '    struct AdapterInfo {\n', '        address id; // Adapter address\n', '        string typeId; // Adapter typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        string categoryId; // Adapter categoryId (for example "VAULT")\n', '    }\n', '\n', '    /**\n', '     * Fetch static information about an array of assets. This method can be used for off-chain pagination.\n', '     */\n', '    function assetsStatic(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (AssetStatic[] memory)\n', '    {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        AssetStatic[] memory _assets = new AssetStatic[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            AssetStatic memory _asset = assetStatic(assetAddress);\n', '            _assets[assetIdx] = _asset;\n', '        }\n', '        return _assets;\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information about an array of assets. This method can be used for off-chain pagination.\n', '     */\n', '    function assetsDynamic(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (AssetDynamic[] memory)\n', '    {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        AssetDynamic[] memory _assets = new AssetDynamic[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            AssetDynamic memory _asset = assetDynamic(assetAddress);\n', '            _assets[assetIdx] = _asset;\n', '        }\n', '        return _assets;\n', '    }\n', '\n', '    /**\n', '     * Fetch static information for all assets\n', '     */\n', '    function assetsStatic() external view returns (AssetStatic[] memory) {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return assetsStatic(_assetsAddresses);\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information for all assets\n', '     */\n', '    function assetsDynamic() external view returns (AssetDynamic[] memory) {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return assetsDynamic(_assetsAddresses);\n', '    }\n', '\n', '    /**\n', '     * Fetch underlying token allowances relative to an asset.\n', '     * This is useful for determining whether or not a user has token approvals\n', '     * to allow depositing into an asset\n', '     */\n', '    function tokenAllowances(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (Allowance[] memory)\n', '    {\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        address[] memory tokenAddresses = new address[](1);\n', '        address[] memory assetAddresses = new address[](1);\n', '        tokenAddresses[0] = tokenAddress;\n', '        assetAddresses[0] = assetAddress;\n', '        bytes memory allowances =\n', '            abi.encode(\n', '                helper.allowances(\n', '                    accountAddress,\n', '                    tokenAddresses,\n', '                    assetAddresses\n', '                )\n', '            );\n', '        return abi.decode(allowances, (Allowance[]));\n', '    }\n', '\n', '    /**\n', '     * Fetch asset allowances based on positionSpenderAddresses (configurable).\n', '     * This is useful to determine if a particular zap contract is approved for the asset (zap out use case)\n', '     */\n', '    function assetAllowances(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (Allowance[] memory)\n', '    {\n', '        address[] memory assetAddresses = new address[](1);\n', '        assetAddresses[0] = assetAddress;\n', '        bytes memory allowances =\n', '            abi.encode(\n', '                helper.allowances(\n', '                    accountAddress,\n', '                    assetAddresses,\n', '                    addressesGenerator.getPositionSpenderAddresses()\n', '                )\n', '            );\n', '        return abi.decode(allowances, (Allowance[]));\n', '    }\n', '\n', '    /**\n', '     * Internal method for constructing a TokenAmount struct given a token balance and address\n', '     */\n', '    function tokenAmount(\n', '        uint256 amount,\n', '        address tokenAddress,\n', '        uint256 tokenPriceUsdc\n', '    ) internal view returns (TokenAmount memory) {\n', '        return\n', '            TokenAmount({\n', '                amount: amount,\n', '                amountUsdc: oracle.getNormalizedValueUsdc(\n', '                    tokenAddress,\n', '                    amount,\n', '                    tokenPriceUsdc\n', '                )\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch the total number of assets for this adapter\n', '     */\n', '    function assetsLength() public view returns (uint256) {\n', '        return addressesGenerator.assetsLength();\n', '    }\n', '\n', '    /**\n', '     * Fetch all asset addresses for this adapter\n', '     */\n', '    function assetsAddresses() public view returns (address[] memory) {\n', '        return addressesGenerator.assetsAddresses();\n', '    }\n', '\n', '    /**\n', '     * Fetch registry address from addresses generator\n', '     */\n', '    function registry() public view returns (address) {\n', '        return addressesGenerator.registry();\n', '    }\n', '\n', '    /**\n', '     * Allow storage slots to be manually updated\n', '     */\n', '    function updateSlot(bytes32 slot, bytes32 value) external onlyOwner {\n', '        assembly {\n', '            sstore(slot, value)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Set optional fallback extension addresses\n', '     */\n', '    function setExtensionsAddresses(address[] memory _newExtensionsAddresses)\n', '        external\n', '        onlyOwner\n', '    {\n', '        _extensionsAddresses = _newExtensionsAddresses;\n', '    }\n', '\n', '    /**\n', '     * Fetch fallback extension addresses\n', '     */\n', '    function extensionsAddresses() external view returns (address[] memory) {\n', '        return (_extensionsAddresses);\n', '    }\n', '\n', '    /**\n', '     * Configure adapter\n', '     */\n', '    constructor(\n', '        address _oracleAddress,\n', '        address _helperAddress,\n', '        address _addressesGeneratorAddress\n', '    ) {\n', '        require(_oracleAddress != address(0), "Missing oracle address");\n', '        oracleAddress = _oracleAddress;\n', '        helperAddress = _helperAddress;\n', '        addressesGenerator = IAddressesGenerator(_addressesGeneratorAddress);\n', '        address _comptrollerAddress = registry();\n', '        comptrollerAddress = _comptrollerAddress;\n', '        comptroller = IUnitroller(comptrollerAddress);\n', '        creamOracleAddress = comptroller.oracle();\n', '        creamOracle = ICreamOracle(creamOracleAddress);\n', '        oracle = IOracle(_oracleAddress);\n', '        helper = IHelper(_helperAddress);\n', '    }\n', '\n', '    /*******************************************************\n', '     *                     Iron Bank Adapter\n', '     *******************************************************/\n', '    /**\n', '     * Iron Bank Adapter\n', '     */\n', '    function adapterInfo() public view returns (AdapterInfo memory) {\n', '        return\n', '            AdapterInfo({\n', '                id: address(this),\n', '                typeId: "IRON_BANK_MARKET",\n', '                categoryId: "LENDING"\n', '            });\n', '    }\n', '\n', '    // Position types supported by this adapter\n', '    string constant positionLend = "LEND";\n', '    string constant positionBorrow = "BORROW";\n', '    string[] public supportedPositions = [positionLend, positionBorrow];\n', '\n', '    /**\n', '     * Metadata specific to this asset type\n', '     */\n', '    struct AssetMetadata {\n', '        uint256 totalSuppliedUsdc;\n', '        uint256 totalBorrowedUsdc;\n', '        uint256 lendApyBips;\n', '        uint256 borrowApyBips;\n', '        uint256 liquidity;\n', '        uint256 liquidityUsdc;\n', '        uint256 collateralFactor;\n', '        bool isActive;\n', '        uint256 reserveFactor;\n', '        uint256 exchangeRate;\n', '    }\n', '\n', '    /**\n', '     * High level adapter metadata scoped to a user\n', '     */\n', '    struct AdapterPosition {\n', '        uint256 supplyBalanceUsdc;\n', '        uint256 borrowBalanceUsdc;\n', '        uint256 borrowLimitUsdc;\n', '        uint256 utilizationRatioBips;\n', '    }\n', '\n', '    /**\n', '     * Metadata specific to an asset type scoped to a user\n', '     */\n', '    struct AssetUserMetadata {\n', '        address assetId;\n', '        bool enteredMarket;\n', '        uint256 supplyBalanceUsdc;\n', '        uint256 borrowBalanceUsdc;\n', '        uint256 borrowLimitUsdc;\n', '    }\n', '\n', '    /**\n', '     * Fetch asset metadata scoped to a user\n', '     */\n', '    function assetUserMetadata(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (AssetUserMetadata memory)\n', '    {\n', '        bool enteredMarket;\n', '        address[] memory markets = comptroller.getAssetsIn(accountAddress);\n', '        for (uint256 marketIdx; marketIdx < markets.length; marketIdx++) {\n', '            address marketAddress = markets[marketIdx];\n', '            if (marketAddress == assetAddress) {\n', '                enteredMarket = true;\n', '                break;\n', '            }\n', '        }\n', '        ICyToken asset = ICyToken(assetAddress);\n', '        IUnitroller.Market memory market = comptroller.markets(assetAddress);\n', '        uint256 supplyBalanceShares = asset.balanceOf(accountAddress);\n', '        uint256 supplyBalanceUnderlying =\n', '            (supplyBalanceShares * asset.exchangeRateStored()) / 10**18;\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        uint256 tokenPriceUsdc = assetUnderlyingTokenPriceUsdc(assetAddress);\n', '        uint256 supplyBalanceUsdc =\n', '            oracle.getNormalizedValueUsdc(\n', '                tokenAddress,\n', '                supplyBalanceUnderlying,\n', '                tokenPriceUsdc\n', '            );\n', '        uint256 borrowBalanceShares = asset.borrowBalanceStored(accountAddress);\n', '        uint256 borrowBalanceUsdc =\n', '            oracle.getNormalizedValueUsdc(\n', '                tokenAddress,\n', '                borrowBalanceShares,\n', '                tokenPriceUsdc\n', '            );\n', '        uint256 borrowLimitUsdc =\n', '            (supplyBalanceUsdc * market.collateralFactorMantissa) / 10**18;\n', '\n', '        return\n', '            AssetUserMetadata({\n', '                assetId: assetAddress,\n', '                enteredMarket: enteredMarket,\n', '                supplyBalanceUsdc: supplyBalanceUsdc,\n', '                borrowBalanceUsdc: borrowBalanceUsdc,\n', '                borrowLimitUsdc: borrowLimitUsdc\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch asset metadata scoped to a user\n', '     */\n', '    function assetsUserMetadata(address accountAddress)\n', '        public\n', '        view\n', '        returns (AssetUserMetadata[] memory)\n', '    {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        AssetUserMetadata[] memory _assetsUserMetadata =\n', '            new AssetUserMetadata[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            _assetsUserMetadata[assetIdx] = assetUserMetadata(\n', '                accountAddress,\n', '                assetAddress\n', '            );\n', '        }\n', '        return _assetsUserMetadata;\n', '    }\n', '\n', '    function underlyingTokenAddress(address assetAddress)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        ICyToken cyToken = ICyToken(assetAddress);\n', '        address tokenAddress = cyToken.underlying();\n', '        return tokenAddress;\n', '    }\n', '\n', '    /**\n', '     * Fetch static information about an asset\n', '     */\n', '    function assetStatic(address assetAddress)\n', '        public\n', '        view\n', '        returns (AssetStatic memory)\n', '    {\n', '        ICyToken asset = ICyToken(assetAddress);\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        return\n', '            AssetStatic({\n', '                id: assetAddress,\n', '                typeId: adapterInfo().typeId,\n', '                tokenId: tokenAddress,\n', '                name: asset.name(),\n', '                version: "2.0.0",\n', '                symbol: asset.symbol(),\n', '                decimals: asset.decimals()\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch underlying token price given a cyToken address\n', '     */\n', '    function assetUnderlyingTokenPriceUsdc(address assetAddress)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        address _underlyingTokenAddress = underlyingTokenAddress(assetAddress);\n', '        IERC20 underlyingToken = IERC20(_underlyingTokenAddress);\n', '        uint8 underlyingTokenDecimals = underlyingToken.decimals();\n', '        uint256 underlyingTokenPrice =\n', '            creamOracle.getUnderlyingPrice(assetAddress) /\n', '                (10**(36 - underlyingTokenDecimals - 6));\n', '        return underlyingTokenPrice;\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information about an asset\n', '     */\n', '    function assetDynamic(address assetAddress)\n', '        public\n', '        view\n', '        returns (AssetDynamic memory)\n', '    {\n', '        ICyToken asset = ICyToken(assetAddress);\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        uint256 liquidity = asset.getCash();\n', '        uint256 liquidityUsdc;\n', '        uint256 tokenPriceUsdc = assetUnderlyingTokenPriceUsdc(assetAddress);\n', '        if (liquidity > 0) {\n', '            liquidityUsdc = oracle.getNormalizedValueUsdc(\n', '                tokenAddress,\n', '                liquidity,\n', '                tokenPriceUsdc\n', '            );\n', '        }\n', '        IUnitroller.Market memory market = comptroller.markets(assetAddress);\n', '\n', '        uint256 balance = assetBalance(assetAddress);\n', '        TokenAmount memory underlyingTokenBalance =\n', '            tokenAmount(balance, tokenAddress, tokenPriceUsdc);\n', '\n', '        uint256 totalBorrowed = asset.totalBorrows();\n', '        uint256 totalBorrowedUsdc =\n', '            oracle.getNormalizedValueUsdc(\n', '                tokenAddress,\n', '                totalBorrowed,\n', '                tokenPriceUsdc\n', '            );\n', '\n', '        AssetMetadata memory metadata =\n', '            AssetMetadata({\n', '                totalSuppliedUsdc: underlyingTokenBalance.amountUsdc,\n', '                totalBorrowedUsdc: totalBorrowedUsdc,\n', '                lendApyBips: (asset.supplyRatePerBlock() * blocksPerYear) /\n', '                    10**14,\n', '                borrowApyBips: (asset.borrowRatePerBlock() * blocksPerYear) /\n', '                    10**14,\n', '                liquidity: liquidity,\n', '                liquidityUsdc: liquidityUsdc,\n', '                collateralFactor: market.collateralFactorMantissa,\n', '                isActive: market.isListed,\n', '                reserveFactor: asset.reserveFactorMantissa(),\n', '                exchangeRate: asset.exchangeRateStored()\n', '            });\n', '\n', '        return\n', '            AssetDynamic({\n', '                id: assetAddress,\n', '                typeId: adapterInfo().typeId,\n', '                tokenId: tokenAddress,\n', '                underlyingTokenBalance: underlyingTokenBalance,\n', '                metadata: metadata\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch asset positions of an account given an asset address\n', '     */\n', '    function assetPositionsOf(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (Position[] memory)\n', '    {\n', '        ICyToken asset = ICyToken(assetAddress);\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        uint256 supplyBalanceShares = asset.balanceOf(accountAddress);\n', '        uint256 borrowBalanceShares = asset.borrowBalanceStored(accountAddress);\n', '\n', '        uint8 currentPositionIdx;\n', '        Position[] memory positions = new Position[](2);\n', '\n', '        uint256 tokenPriceUsdc = assetUnderlyingTokenPriceUsdc(assetAddress);\n', '\n', '        if (supplyBalanceShares > 0) {\n', '            uint256 supplyBalanceUnderlying =\n', '                (supplyBalanceShares * asset.exchangeRateStored()) / 10**18;\n', '            positions[currentPositionIdx] = Position({\n', '                assetId: assetAddress,\n', '                tokenId: tokenAddress,\n', '                typeId: positionLend,\n', '                balance: supplyBalanceShares,\n', '                underlyingTokenBalance: tokenAmount(\n', '                    supplyBalanceUnderlying,\n', '                    tokenAddress,\n', '                    tokenPriceUsdc\n', '                ),\n', '                tokenAllowances: tokenAllowances(accountAddress, assetAddress),\n', '                assetAllowances: assetAllowances(accountAddress, assetAddress)\n', '            });\n', '            currentPositionIdx++;\n', '        }\n', '        if (borrowBalanceShares > 0) {\n', '            positions[currentPositionIdx] = Position({\n', '                assetId: assetAddress,\n', '                tokenId: tokenAddress,\n', '                typeId: positionBorrow,\n', '                balance: borrowBalanceShares,\n', '                underlyingTokenBalance: tokenAmount(\n', '                    borrowBalanceShares,\n', '                    tokenAddress,\n', '                    tokenPriceUsdc\n', '                ),\n', '                tokenAllowances: tokenAllowances(accountAddress, assetAddress),\n', '                assetAllowances: assetAllowances(accountAddress, assetAddress)\n', '            });\n', '            currentPositionIdx++;\n', '        }\n', '\n', '        // Trim positions\n', '        bytes memory positionsEncoded = abi.encode(positions);\n', '        assembly {\n', '            mstore(add(positionsEncoded, 0x40), currentPositionIdx)\n', '        }\n', '        positions = abi.decode(positionsEncoded, (Position[]));\n', '\n', '        return positions;\n', '    }\n', '\n', '    /**\n', '     * Fetch positions for an account given an asset address\n', '     */\n', '    function assetsPositionsOf(\n', '        address accountAddress,\n', '        address[] memory _assetsAddresses\n', '    ) public view returns (Position[] memory) {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '\n', '        // Maximum of two positions per market: LEND and BORROW\n', '        Position[] memory positions = new Position[](numberOfAssets * 2);\n', '        uint256 currentPositionIdx;\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            Position[] memory assetPositions =\n', '                assetPositionsOf(accountAddress, assetAddress);\n', '\n', '            for (\n', '                uint256 assetPositionIdx = 0;\n', '                assetPositionIdx < assetPositions.length;\n', '                assetPositionIdx++\n', '            ) {\n', '                Position memory position = assetPositions[assetPositionIdx];\n', '                if (position.balance > 0) {\n', '                    positions[currentPositionIdx] = position;\n', '                    currentPositionIdx++;\n', '                }\n', '            }\n', '        }\n', '\n', '        // Trim positions\n', '        bytes memory encodedData = abi.encode(positions);\n', '        assembly {\n', '            mstore(add(encodedData, 0x40), currentPositionIdx)\n', '        }\n', '        positions = abi.decode(encodedData, (Position[]));\n', '        return positions;\n', '    }\n', '\n', '    /**\n', '     * Fetch asset positions for an account for all assets\n', '     */\n', '    function assetsPositionsOf(address accountAddress)\n', '        public\n', '        view\n', '        returns (Position[] memory)\n', '    {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return assetsPositionsOf(accountAddress, _assetsAddresses);\n', '    }\n', '\n', '    /**\n', '     * Fetch asset balance in underlying tokens\n', '     */\n', '    function assetBalance(address assetAddress) public view returns (uint256) {\n', '        ICyToken cyToken = ICyToken(assetAddress);\n', '        uint256 cash = cyToken.getCash();\n', '        uint256 totalBorrows = cyToken.totalBorrows();\n', '        uint256 totalReserves = cyToken.totalReserves();\n', '        uint256 totalSupplied = (cash + totalBorrows - totalReserves);\n', '        return totalSupplied;\n', '    }\n', '\n', '    /**\n', '     * Fetch high level information about an account\n', '     */\n', '    function adapterPositionOf(address accountAddress)\n', '        external\n', '        view\n', '        returns (AdapterPosition memory)\n', '    {\n', '        AssetUserMetadata[] memory _assetsUserMetadata =\n', '            assetsUserMetadata(accountAddress);\n', '        uint256 supplyBalanceUsdc;\n', '        uint256 borrowBalanceUsdc;\n', '        uint256 borrowLimitUsdc;\n', '        for (\n', '            uint256 metadataIdx = 0;\n', '            metadataIdx < _assetsUserMetadata.length;\n', '            metadataIdx++\n', '        ) {\n', '            AssetUserMetadata memory _assetUserMetadata =\n', '                _assetsUserMetadata[metadataIdx];\n', '            supplyBalanceUsdc += _assetUserMetadata.supplyBalanceUsdc;\n', '            borrowBalanceUsdc += _assetUserMetadata.borrowBalanceUsdc;\n', '            borrowLimitUsdc += _assetUserMetadata.borrowLimitUsdc;\n', '        }\n', '        uint256 utilizationRatioBips;\n', '        if (borrowLimitUsdc > 0) {\n', '            utilizationRatioBips =\n', '                (borrowBalanceUsdc * 10000) /\n', '                borrowLimitUsdc;\n', '        }\n', '        return\n', '            AdapterPosition({\n', '                supplyBalanceUsdc: supplyBalanceUsdc,\n', '                borrowBalanceUsdc: borrowBalanceUsdc,\n', '                borrowLimitUsdc: borrowLimitUsdc,\n', '                utilizationRatioBips: utilizationRatioBips\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Returns unique list of token addresses associated with this adapter\n', '     */\n', '    function assetsTokensAddresses() public view returns (address[] memory) {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        address[] memory _tokensAddresses = new address[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            _tokensAddresses[assetIdx] = underlyingTokenAddress(assetAddress);\n', '        }\n', '        return _tokensAddresses;\n', '    }\n', '\n', '    /**\n', '     * Cascading fallback proxy provides the contract with the ability to add new features at a later time\n', '     */\n', '    fallback() external {\n', '        for (uint256 i = 0; i < _extensionsAddresses.length; i++) {\n', '            address extension = _extensionsAddresses[i];\n', '            assembly {\n', '                let _target := extension\n', '                calldatacopy(0, 0, calldatasize())\n', '                let success := staticcall(\n', '                    gas(),\n', '                    _target,\n', '                    0,\n', '                    calldatasize(),\n', '                    0,\n', '                    0\n', '                )\n', '                returndatacopy(0, 0, returndatasize())\n', '                if success {\n', '                    return(0, returndatasize())\n', '                }\n', '            }\n', '        }\n', '        revert("Extensions: Fallback proxy failed to return data");\n', '    }\n', '}']