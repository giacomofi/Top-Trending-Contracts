['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.3;\n', '\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n', ' * deploying minimal proxy contracts, also known as "clones".\n', ' *\n', ' * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n', ' * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n', ' *\n', ' * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n', ' * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n', ' * deterministic method.\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'library Clones {\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create opcode, which should never revert.\n', '     */\n', '    function clone(address implementation) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create(0, ptr, 0x37)\n', '        }\n', '        require(instance != address(0), "ERC1167: create failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create2 opcode and a `salt` to deterministically deploy\n', '     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n', '     * the clones cannot be deployed twice at the same address.\n', '     */\n', '    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create2(0, ptr, 0x37, salt)\n', '        }\n', '        require(instance != address(0), "ERC1167: create2 failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n', '            mstore(add(ptr, 0x38), shl(0x60, deployer))\n', '            mstore(add(ptr, 0x4c), salt)\n', '            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n', '            predicted := keccak256(add(ptr, 0x37), 0x55)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n', '        return predictDeterministicAddress(implementation, salt, address(this));\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '\n', 'contract Governance is ReentrancyGuard {\n', '\n', '\tuint constant public governance_challenging_period = 10 days;\n', '\tuint constant public governance_freeze_period = 30 days;\n', '\n', '\taddress public votingTokenAddress;\n', '\taddress public governedContractAddress;\n', '\n', '\tmapping(address => uint) public balances;\n', '\n', '\tVotedValue[] public votedValues;\n', '\tmapping(string => VotedValue) public votedValuesMap;\n', '\n', '\n', '\tconstructor(address _governedContractAddress, address _votingTokenAddress){\n', '\t\tinit(_governedContractAddress, _votingTokenAddress);\n', '\t}\n', '\n', '\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\n', '\t\trequire(governedContractAddress == address(0), "governance already initialized");\n', '\t\tgovernedContractAddress = _governedContractAddress;\n', '\t\tvotingTokenAddress = _votingTokenAddress;\n', '\t}\n', '\n', '\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\n', '\t\tfor (uint i = 0; i < votedValues.length; i++)\n', '\t\t\tif (address(votedValues[i]) == addr)\n', '\t\t\t\treturn true;\n', '\t\treturn false;\n', '\t}\n', '\n', '\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\n', '\t\tfor (uint i = 0; i < votedValues.length; i++)\n', '\t\t\tif (votedValues[i].hasVote(addr))\n', '\t\t\t\treturn false;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\n', '\t\trequire(msg.sender == governedContractAddress, "not authorized");\n', '\t\tvotedValues.push(votedValue);\n', '\t\tvotedValuesMap[name] = votedValue;\n', '\t}\n', '\n', '\n', '\t// deposit\n', '\n', '\tfunction deposit(uint amount) payable external {\n', '\t\tdeposit(msg.sender, amount);\n', '\t}\n', '\n', '\tfunction deposit(address from, uint amount) nonReentrant payable public {\n', '\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), "not allowed");\n', '\t\tif (votingTokenAddress == address(0))\n', '\t\t\trequire(msg.value == amount, "wrong amount received");\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "don\'t send ETH");\n', '\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), "failed to pull gov deposit");\n', '\t\t}\n', '\t\tbalances[from] += amount;\n', '\t}\n', '\n', '\n', '\t// withdrawal functions\n', '\n', '\tfunction withdraw() external {\n', '\t\twithdraw(balances[msg.sender]);\n', '\t}\n', '\n', '\tfunction withdraw(uint amount) nonReentrant public {\n', '\t\trequire(amount > 0, "zero withdrawal requested");\n', '\t\trequire(amount <= balances[msg.sender], "not enough balance");\n', '\t\trequire(isUntiedFromAllVotes(msg.sender), "some votes not removed yet");\n', '\t\tbalances[msg.sender] -= amount;\n', '\t\tif (votingTokenAddress == address(0))\n', '\t\t\tpayable(msg.sender).transfer(amount);\n', '\t\telse\n', '\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), "failed to withdraw gov deposit");\n', '\t}\n', '}\n', '\n', '\n', 'abstract contract VotedValue is ReentrancyGuard {\n', '\tGovernance public governance;\n', '\tuint public challenging_period_start_ts;\n', '\tmapping(address => bool) public hasVote;\n', '\n', '\tconstructor(Governance _governance){\n', '\t\tgovernance = _governance;\n', '\t}\n', '\n', '\tfunction checkVoteChangeLock() view public {\n', '\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, "you cannot change your vote yet");\n', '\t}\n', '\n', '\tfunction checkChallengingPeriodExpiry() view public {\n', '\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), "challenging period not expired yet");\n', '\t}\n', '}\n', '\n', '\n', 'contract VotedValueUint is VotedValue {\n', '\n', '\tfunction(uint) external validationCallback;\n', '\tfunction(uint) external commitCallback;\n', '\n', '\tuint public leader;\n', '\tuint public current_value;\n', '\n', '\tmapping(address => uint) public choices;\n', '\tmapping(uint => uint) public votesByValue;\n', '\tmapping(uint => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction vote(uint value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(uint value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(uint value) private {\n', '\t\tvalidationCallback(value);\n', '\t\tuint prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\n', '\t\t// first, remove votes from the previous choice\n', '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add them to the new choice\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[value] += balance;\n', '\t\tvotesByValueAddress[value][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[value] > votesByValue[leader]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\tuint prev_choice = choices[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(uint value) internal {\n', '\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\n', '\t\tvotesByValueAddress[value][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(leader != current_value, "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract VotedValueUintArray is VotedValue {\n', '\n', '\tfunction(uint[] memory) external validationCallback;\n', '\tfunction(uint[] memory) external commitCallback;\n', '\n', '\tuint[] public leader;\n', '\tuint[] public current_value;\n', '\n', '\tmapping(address => uint[]) public choices;\n', '\tmapping(bytes32 => uint) public votesByValue;\n', '\tmapping(bytes32 => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction equal(uint[] memory a1, uint[] memory a2) public pure returns (bool) {\n', '\t\tif (a1.length != a2.length)\n', '\t\t\treturn false;\n', '\t\tfor (uint i = 0; i < a1.length; i++)\n', '\t\t\tif (a1[i] != a2[i])\n', '\t\t\t\treturn false;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getKey(uint[] memory a) public pure returns (bytes32){\n', '\t\treturn keccak256(abi.encodePacked(a));\n', '\t}\n', '\n', '\tfunction vote(uint[] memory value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(uint[] memory value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(uint[] memory value) private {\n', '\t\tvalidationCallback(value);\n', '\t\tuint[] storage prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (equal(prev_choice, leader))\n', '\t\t\tcheckVoteChangeLock();\n', '\n', "\t\t// remove one's vote from the previous choice first\n", '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add it to the new choice, if any\n', '\t\tbytes32 key = getKey(value);\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[key] += balance;\n', '\t\tvotesByValueAddress[key][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[key] > votesByValue[getKey(leader)]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\tuint[] storage prev_choice = choices[msg.sender];\n', '\t\tif (equal(prev_choice, leader))\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(uint[] memory value) internal {\n', '\t\tbytes32 key = getKey(value);\n', '\t\tvotesByValue[key] -= votesByValueAddress[key][msg.sender];\n', '\t\tvotesByValueAddress[key][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(!equal(leader, current_value), "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract VotedValueAddress is VotedValue {\n', '\n', '\tfunction(address) external validationCallback;\n', '\tfunction(address) external commitCallback;\n', '\n', '\taddress public leader;\n', '\taddress public current_value;\n', '\n', '\t// mapping(who => value)\n', '\tmapping(address => address) public choices;\n', '\n', '\t// mapping(value => votes)\n', '\tmapping(address => uint) public votesByValue;\n', '\n', '\t// mapping(value => mapping(who => votes))\n', '\tmapping(address => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction vote(address value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(address value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(address value) private {\n', '\t\tvalidationCallback(value);\n', '\t\taddress prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\n', '\t\t// first, remove votes from the previous choice\n', '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add them to the new choice\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[value] += balance;\n', '\t\tvotesByValueAddress[value][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[value] > votesByValue[leader]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\taddress prev_choice = choices[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(address value) internal {\n', '\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\n', '\t\tvotesByValueAddress[value][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(leader != current_value, "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', 'contract VotedValueFactory {\n', '\n', '\taddress public votedValueUintMaster;\n', '\taddress public votedValueUintArrayMaster;\n', '\taddress public votedValueAddressMaster;\n', '\n', '\tconstructor(address _votedValueUintMaster, address _votedValueUintArrayMaster, address _votedValueAddressMaster) {\n', '\t\tvotedValueUintMaster = _votedValueUintMaster;\n', '\t\tvotedValueUintArrayMaster = _votedValueUintArrayMaster;\n', '\t\tvotedValueAddressMaster = _votedValueAddressMaster;\n', '\t}\n', '\n', '\n', '\tfunction createVotedValueUint(Governance governance, uint initial_value, function(uint) external validationCallback, function(uint) external commitCallback) external returns (VotedValueUint) {\n', '\t\tVotedValueUint vv = VotedValueUint(Clones.clone(votedValueUintMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '\tfunction createVotedValueUintArray(Governance governance, uint[] memory initial_value, function(uint[] memory) external validationCallback, function(uint[] memory) external commitCallback) external returns (VotedValueUintArray) {\n', '\t\tVotedValueUintArray vv = VotedValueUintArray(Clones.clone(votedValueUintArrayMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '\tfunction createVotedValueAddress(Governance governance, address initial_value, function(address) external validationCallback, function(address) external commitCallback) external returns (VotedValueAddress) {\n', '\t\tVotedValueAddress vv = VotedValueAddress(Clones.clone(votedValueAddressMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '}\n', '\n', '\n', '\n', '\n', 'contract GovernanceFactory {\n', '\n', '\taddress public governanceMaster;\n', '\n', '\tconstructor(address _governanceMaster) {\n', '\t\tgovernanceMaster = _governanceMaster;\n', '\t}\n', '\n', '\tfunction createGovernance(address governedContractAddress, address votingTokenAddress) external returns (Governance) {\n', '\t\tGovernance governance = Governance(Clones.clone(governanceMaster));\n', '\t\tgovernance.init(governedContractAddress, votingTokenAddress);\n', '\t\treturn governance;\n', '\t}\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', '// The purpose of the library is to separate some of the code out of the Export/Import contracts and keep their sizes under the 24KiB limit\n', '\n', '\n', 'library CounterstakeLibrary {\n', '\n', '\tenum Side {no, yes}\n', '\n', '\t// small values (bool, uint32, ...) are grouped together in order to be packed efficiently\n', '\tstruct Claim {\n', '\t\tuint amount;\n', '\t//\tint reward;\n', '\n', '\t\taddress payable recipient_address; // 20 bytes, 12 bytes left\n', '\t\tuint32 txts;\n', '\t\tuint32 ts;\n', '\t\t\n', '\t\taddress payable claimant_address;\n', '\t\tuint32 expiry_ts;\n', '\t\tuint16 period_number;\n', '\t\tSide current_outcome;\n', '\t\tbool is_large;\n', '\t\tbool withdrawn;\n', '\t\tbool finished;\n', '\t\t\n', '\t\tstring sender_address;\n', '\t//\tstring txid;\n', '\t\tstring data;\n', '\t\tuint yes_stake;\n', '\t\tuint no_stake;\n', '\t//\tuint challenging_target;\n', '\t}\n', '\n', '\tstruct Settings {\n', '\t\taddress tokenAddress;\n', '\t\tuint16 ratio100;// = 100;\n', '\t\tuint16 counterstake_coef100;// = 150;\n', '\t\tuint32 min_tx_age;\n', '\t\tuint min_stake;\n', '\t\tuint[] challenging_periods;// = [12 hours, 3 days, 1 weeks, 30 days];\n', '\t\tuint[] large_challenging_periods;// = [3 days, 1 weeks, 30 days];\n', '\t\tuint large_threshold;\n', '\t}\n', '\n', '\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\n', '\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, Side outcome, Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\n', '\tevent FinishedClaim(uint indexed claim_num, Side outcome);\n', '\n', '\n', '\tstruct ClaimRequest {\n', '\t\tstring txid;\n', '\t\tuint32 txts;\n', '\t\tuint amount;\n', '\t\tint reward;\n', '\t\tuint stake;\n', '\t\tuint required_stake;\n', '\t\taddress payable recipient_address;\n', '\t\tstring sender_address;\n', '\t\tstring data;\n', '\t}\n', '\n', '\tfunction claim(\n', '\t\tSettings storage settings,\n', '\t\tmapping(string => uint) storage claim_nums,\n', '\t\tmapping(uint => Claim) storage claims,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes,\n', '\t\tuint claim_num,\n', '\t\tClaimRequest memory req\n', '\t) external {\n', '\t\trequire(req.amount > 0, "0 claim");\n', '\t\trequire(req.stake >= req.required_stake, "the stake is too small");\n', '\t\trequire(block.timestamp >= req.txts + settings.min_tx_age, "too early");\n', '\t\tif (req.recipient_address == address(0))\n', '\t\t\treq.recipient_address = payable(msg.sender);\n', '\t\tif (req.reward < 0)\n', '\t\t\trequire(req.recipient_address == payable(msg.sender), "the sender disallowed third-party claiming by setting a negative reward");\n', '\t\tstring memory claim_id = getClaimId(req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.data);\n', '\t\trequire(claim_nums[claim_id] == 0, "this transfer has already been claimed");\n', '\t\tbool is_large = (settings.large_threshold > 0 && req.stake >= settings.large_threshold);\n', '\t\tuint32 expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, 0, is_large)); // might wrap\n', '\t\tclaim_nums[claim_id] = claim_num;\n', '\t//\tuint challenging_target = req.stake * settings.counterstake_coef100/100;\n', '\t\tclaims[claim_num] = Claim({\n', '\t\t\tamount: req.amount,\n', '\t\t//\treward: req.reward,\n', '\t\t\trecipient_address: req.recipient_address,\n', '\t\t\tclaimant_address: payable(msg.sender),\n', '\t\t\tsender_address: req.sender_address,\n', '\t\t//\ttxid: req.txid,\n', '\t\t\tdata: req.data,\n', '\t\t\tyes_stake: req.stake,\n', '\t\t\tno_stake: 0,\n', '\t\t\tcurrent_outcome: Side.yes,\n', '\t\t\tis_large: is_large,\n', '\t\t\tperiod_number: 0,\n', '\t\t\ttxts: req.txts,\n', '\t\t\tts: uint32(block.timestamp),\n', '\t\t\texpiry_ts: expiry_ts,\n', '\t\t//\tchallenging_target: req.stake * settings.counterstake_coef100/100,\n', '\t\t\twithdrawn: false,\n', '\t\t\tfinished: false\n', '\t\t});\n', '\t\tstakes[claim_num][Side.yes][msg.sender] = req.stake;\n', '\t\temit NewClaim(claim_num, msg.sender, req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.stake, req.data, expiry_ts);\n', '\t//\treturn claim_id;\n', '\t}\n', '\n', '\n', '\tfunction challenge(\n', '\t\tSettings storage settings, \n', '\t\tClaim storage c,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \n', '\t\tuint claim_num, \n', '\t\tSide stake_on, \n', '\t\tuint stake\n', '\t) external {\n', '\t\trequire(block.timestamp < c.expiry_ts, "the challenging period has expired");\n', '\t\trequire(stake_on != c.current_outcome, "this outcome is already current");\n', '\t\tuint excess;\n', '\t\tuint challenging_target = (c.current_outcome == Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100;\n', '\t\t{ // circumvent stack too deep\n', '\t\t\tuint stake_on_proposed_outcome = (stake_on == Side.yes ? c.yes_stake : c.no_stake) + stake;\n', '\t\t\tbool would_override_current_outcome = stake_on_proposed_outcome >= challenging_target;\n', '\t\t\texcess = would_override_current_outcome ? stake_on_proposed_outcome - challenging_target : 0;\n', '\t\t\tuint accepted_stake = stake - excess;\n', '\t\t\tif (stake_on == Side.yes)\n', '\t\t\t\tc.yes_stake += accepted_stake;\n', '\t\t\telse\n', '\t\t\t\tc.no_stake += accepted_stake;\n', '\t\t\tif (would_override_current_outcome){\n', '\t\t\t\tc.period_number++;\n', '\t\t\t\tc.current_outcome = stake_on;\n', '\t\t\t\tc.expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, c.period_number, c.is_large));\n', '\t\t\t\tchallenging_target = challenging_target * settings.counterstake_coef100/100;\n', '\t\t\t}\n', '\t\t\tstakes[claim_num][stake_on][msg.sender] += accepted_stake;\n', '\t\t}\n', '\t\temit NewChallenge(claim_num, msg.sender, stake, stake_on, c.current_outcome, c.yes_stake, c.no_stake, c.expiry_ts, challenging_target);\n', '\t\tif (excess > 0){\n', '\t\t\tif (settings.tokenAddress == address(0))\n', '\t\t\t\tpayable(msg.sender).transfer(excess);\n', '\t\t\telse\n', '\t\t\t\trequire(IERC20(settings.tokenAddress).transfer(msg.sender, excess), "failed to transfer the token");\n', '\t\t}\n', '\t}\n', '\n', '\n', '\n', '\tfunction finish(\n', '\t\tClaim storage c,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \n', '\t\tuint claim_num, \n', '\t\taddress payable to_address\n', '\t) external \n', '\treturns (bool, bool, uint)\n', '\t{\n', '\t\trequire(block.timestamp > c.expiry_ts, "challenging period is still ongoing");\n', '\t\tif (to_address == address(0))\n', '\t\t\tto_address = payable(msg.sender);\n', '\t\t\n', '\t\tbool is_winning_claimant = (to_address == c.claimant_address && c.current_outcome == Side.yes);\n', '\t\trequire(!(is_winning_claimant && c.withdrawn), "already withdrawn");\n', '\t\tuint won_stake;\n', '\t\t{ // circumvent stack too deep\n', '\t\t\tuint my_stake = stakes[claim_num][c.current_outcome][to_address];\n', '\t\t\trequire(my_stake > 0 || is_winning_claimant, "you are not the recipient and you didn\'t stake on the winning outcome or you have already withdrawn");\n', '\t\t\tuint winning_stake = c.current_outcome == Side.yes ? c.yes_stake : c.no_stake;\n', '\t\t\tif (my_stake > 0)\n', '\t\t\t\twon_stake = (c.yes_stake + c.no_stake) * my_stake / winning_stake;\n', '\t\t}\n', '\t\tif (is_winning_claimant)\n', '\t\t\tc.withdrawn = true;\n', '\t\tbool finished;\n', '\t\tif (!c.finished){\n', '\t\t\tfinished = true;\n', '\t\t\tc.finished = true;\n', '\t\t//\tSide losing_outcome = outcome == Side.yes ? Side.no : Side.yes;\n', "\t\t//\tdelete stakes[claim_id][losing_outcome]; // can't purge the stakes that will never be claimed\n", '\t\t\temit FinishedClaim(claim_num, c.current_outcome);\n', '\t\t}\n', '\t\tdelete stakes[claim_num][c.current_outcome][to_address];\n', '\t\treturn (finished, is_winning_claimant, won_stake);\n', '\t}\n', '\n', '\n', '\n', '\tfunction getChallengingPeriod(Settings storage settings, uint16 period_number, bool bLarge) public view returns (uint) {\n', '\t\tuint[] storage periods = bLarge ? settings.large_challenging_periods : settings.challenging_periods;\n', '\t\tif (period_number > periods.length - 1)\n', '\t\t\tperiod_number = uint16(periods.length - 1);\n', '\t\treturn periods[period_number];\n', '\t}\n', '\n', '\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\n', '\t\trequire(periods.length > 0, "empty periods");\n', '\t\tuint prev_period = 0;\n', '\t\tfor (uint i = 0; i < periods.length; i++) {\n', '\t\t\trequire(periods[i] < 3 * 365 days, "some periods are longer than 3 years");\n', '\t\t\trequire(periods[i] >= prev_period, "subsequent periods cannot get shorter");\n', '\t\t\tprev_period = periods[i];\n', '\t\t}\n', '\t}\n', '\n', '\tfunction getClaimId(string memory sender_address, address recipient_address, string memory txid, uint32 txts, uint amount, int reward, string memory data) public pure returns (string memory){\n', "\t\treturn string(abi.encodePacked(sender_address, '_', toAsciiString(recipient_address), '_', txid, '_', uint2str(txts), '_', uint2str(amount), '_', int2str(reward), '_', data));\n", '\t}\n', '\n', '\n', '\tfunction uint2str(uint256 _i) private pure returns (string memory) {\n', '\t\tif (_i == 0)\n', '\t\t\treturn "0";\n', '\t\tuint256 j = _i;\n', '\t\tuint256 length;\n', '\t\twhile (j != 0) {\n', '\t\t\tlength++;\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\tbytes memory bstr = new bytes(length);\n', '\t\tuint256 k = length;\n', '\t\tj = _i;\n', '\t\twhile (j != 0) {\n', '\t\t\tbstr[--k] = bytes1(uint8(48 + j % 10));\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\treturn string(bstr);\n', '\t}\n', '\n', '\tfunction int2str(int256 _i) private pure returns (string memory) {\n', '\t\trequire(_i < type(int).max, "int too large");\n', "\t\treturn _i >= 0 ? uint2str(uint(_i)) : string(abi.encodePacked('-', uint2str(uint(-_i))));\n", '\t}\n', '\n', '\tfunction toAsciiString(address x) private pure returns (string memory) {\n', '\t\tbytes memory s = new bytes(40);\n', '\t\tfor (uint i = 0; i < 20; i++) {\n', '\t\t\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\n', '\t\t\tbytes1 hi = bytes1(uint8(b) / 16);\n', '\t\t\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n', '\t\t\ts[2*i] = char(hi);\n', '\t\t\ts[2*i+1] = char(lo);            \n', '\t\t}\n', '\t\treturn string(s);\n', '\t}\n', '\n', '\tfunction char(bytes1 b) private pure returns (bytes1 c) {\n', '\t\tif (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n', '\t\telse return bytes1(uint8(b) + 0x57);\n', '\t}\n', '\n', '\tfunction isContract(address _addr) public view returns (bool){\n', '\t\tuint32 size;\n', '\t\tassembly {\n', '\t\t\tsize := extcodesize(_addr)\n', '\t\t}\n', '\t\treturn (size > 0);\n', '\t}\n', '}\n', '\n', '\n', '\n', '\n', 'interface CounterstakeReceiver {\n', '\tfunction onReceivedFromClaim(uint claim_num, uint net_claimed_amount, uint won_stake, string memory sender_address, address claim_recipient_address, string memory data) external;\n', '}\n', '\n', 'abstract contract Counterstake is ReentrancyGuard {\n', '\n', '\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\n', '\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, CounterstakeLibrary.Side outcome, CounterstakeLibrary.Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\n', '\tevent FinishedClaim(uint indexed claim_num, CounterstakeLibrary.Side outcome);\n', '\n', '\tGovernance public governance;\n', '\tCounterstakeLibrary.Settings public settings;\n', '\n', '\n', '\tuint64 public last_claim_num;\n', '\tuint64[] public ongoing_claim_nums;\n', '\tmapping(uint => uint) public num2index;\n', '\n', '\tmapping(string => uint) public claim_nums;\n', '\tmapping(uint => CounterstakeLibrary.Claim) private claims;\n', '\tmapping(uint => mapping(CounterstakeLibrary.Side => mapping(address => uint))) public stakes;\n', '\n', '\tfunction getClaim(uint claim_num) external view returns (CounterstakeLibrary.Claim memory) {\n', '\t\treturn claims[claim_num];\n', '\t}\n', '\n', '\tfunction getClaim(string memory claim_id) external view returns (CounterstakeLibrary.Claim memory) {\n', '\t\treturn claims[claim_nums[claim_id]];\n', '\t}\n', '\n', '\tfunction getOngoingClaimNums() external view returns (uint64[] memory) {\n', '\t\treturn ongoing_claim_nums;\n', '\t}\n', '\n', '\n', '\tconstructor (address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) {\n', '\t\tinitCounterstake(_tokenAddr, _counterstake_coef100, _ratio100, _large_threshold, _challenging_periods, _large_challenging_periods);\n', '\t}\n', '\n', '\tfunction initCounterstake(address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) public {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tsettings = CounterstakeLibrary.Settings({\n', '\t\t\ttokenAddress: _tokenAddr,\n', '\t\t\tcounterstake_coef100: _counterstake_coef100 > 100 ? _counterstake_coef100 : 150,\n', '\t\t\tratio100: _ratio100 > 0 ? _ratio100 : 100,\n', '\t\t\tmin_stake: 0,\n', '\t\t\tmin_tx_age: 0,\n', '\t\t\tchallenging_periods: _challenging_periods,\n', '\t\t\tlarge_challenging_periods: _large_challenging_periods,\n', '\t\t\tlarge_threshold: _large_threshold\n', '\t\t});\n', '\t}\n', '\n', '\t/*\n', '\tmodifier onlyETH(){\n', '\t\trequire(settings.tokenAddress == address(0), "ETH only");\n', '\t\t_;\n', '\t}\n', '\n', '\tmodifier onlyERC20(){\n', '\t\trequire(settings.tokenAddress != address(0), "ERC20 only");\n', '\t\t_;\n', '\t}*/\n', '\n', '\tmodifier onlyVotedValueContract(){\n', '\t\trequire(governance.addressBelongsToGovernance(msg.sender), "not from voted value contract");\n', '\t\t_;\n', '\t}\n', '\n', '\t// would be happy to call this from the constructor but unfortunately `this` is not set at that time yet\n', '\tfunction setupGovernance(GovernanceFactory governanceFactory, VotedValueFactory votedValueFactory) virtual public {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = governanceFactory.createGovernance(address(this), settings.tokenAddress);\n', '\n', '\t\tgovernance.addVotedValue("ratio100", votedValueFactory.createVotedValueUint(governance, settings.ratio100, this.validateRatio, this.setRatio));\n', '\t\tgovernance.addVotedValue("counterstake_coef100", votedValueFactory.createVotedValueUint(governance, settings.counterstake_coef100, this.validateCounterstakeCoef, this.setCounterstakeCoef));\n', '\t\tgovernance.addVotedValue("min_stake", votedValueFactory.createVotedValueUint(governance, settings.min_stake, this.validateMinStake, this.setMinStake));\n', '\t\tgovernance.addVotedValue("min_tx_age", votedValueFactory.createVotedValueUint(governance, settings.min_tx_age, this.validateMinTxAge, this.setMinTxAge));\n', '\t\tgovernance.addVotedValue("large_threshold", votedValueFactory.createVotedValueUint(governance, settings.large_threshold, this.validateLargeThreshold, this.setLargeThreshold));\n', '\t\tgovernance.addVotedValue("challenging_periods", votedValueFactory.createVotedValueUintArray(governance, settings.challenging_periods, this.validateChallengingPeriods, this.setChallengingPeriods));\n', '\t\tgovernance.addVotedValue("large_challenging_periods", votedValueFactory.createVotedValueUintArray(governance, settings.large_challenging_periods, this.validateChallengingPeriods, this.setLargeChallengingPeriods));\n', '\t}\n', '\n', '\tfunction validateRatio(uint _ratio100) pure external {\n', '\t\trequire(_ratio100 > 0 && _ratio100 < 64000, "bad ratio");\n', '\t}\n', '\n', '\tfunction setRatio(uint _ratio100) onlyVotedValueContract external {\n', '\t\tsettings.ratio100 = uint16(_ratio100);\n', '\t}\n', '\n', '\t\n', '\tfunction validateCounterstakeCoef(uint _counterstake_coef100) pure external {\n', '\t\trequire(_counterstake_coef100 > 100 && _counterstake_coef100 < 64000, "bad counterstake coef");\n', '\t}\n', '\n', '\tfunction setCounterstakeCoef(uint _counterstake_coef100) onlyVotedValueContract external {\n', '\t\tsettings.counterstake_coef100 = uint16(_counterstake_coef100);\n', '\t}\n', '\n', '\t\n', '\tfunction validateMinStake(uint _min_stake) pure external {\n', '\t\t// anything goes\n', '\t}\n', '\n', '\tfunction setMinStake(uint _min_stake) onlyVotedValueContract external {\n', '\t\tsettings.min_stake = _min_stake;\n', '\t}\n', '\n', '\n', '\tfunction validateMinTxAge(uint _min_tx_age) pure external {\n', '\t\trequire(_min_tx_age < 4 weeks, "min tx age too large");\n', '\t}\n', '\n', '\tfunction setMinTxAge(uint _min_tx_age) onlyVotedValueContract external {\n', '\t\tsettings.min_tx_age = uint32(_min_tx_age);\n', '\t}\n', '\n', '\n', '\tfunction validateLargeThreshold(uint _large_threshold) pure external {\n', '\t\t// anything goes\n', '\t}\n', '\n', '\tfunction setLargeThreshold(uint _large_threshold) onlyVotedValueContract external {\n', '\t\tsettings.large_threshold = _large_threshold;\n', '\t}\n', '\n', '\n', '\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\n', '\t\tCounterstakeLibrary.validateChallengingPeriods(periods);\n', '\t}\n', '\n', '\tfunction setChallengingPeriods(uint[] memory _challenging_periods) onlyVotedValueContract external {\n', '\t\tsettings.challenging_periods = _challenging_periods;\n', '\t}\n', '\n', '\tfunction setLargeChallengingPeriods(uint[] memory _large_challenging_periods) onlyVotedValueContract external {\n', '\t\tsettings.large_challenging_periods = _large_challenging_periods;\n', '\t}\n', '\n', '\n', '\tfunction getChallengingPeriod(uint16 period_number, bool bLarge) external view returns (uint) {\n', '\t\treturn CounterstakeLibrary.getChallengingPeriod(settings, period_number, bLarge);\n', '\t}\n', '\n', '\tfunction getRequiredStake(uint amount) public view virtual returns (uint);\n', '\n', '\tfunction getMissingStake(uint claim_num, CounterstakeLibrary.Side stake_on) external view returns (uint) {\n', '\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\n', '\t\trequire(c.yes_stake > 0, "no such claim");\n', '\t\tuint current_stake = (stake_on == CounterstakeLibrary.Side.yes) ? c.yes_stake : c.no_stake;\n', '\t\treturn (c.current_outcome == CounterstakeLibrary.Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100 - current_stake;\n', '\t}\n', '\n', '\n', '\n', '\tfunction claim(string memory txid, uint32 txts, uint amount, int reward, uint stake, string memory sender_address, address payable recipient_address, string memory data) nonReentrant payable external {\n', '\t\tif (recipient_address == address(0))\n', '\t\t\trecipient_address = payable(msg.sender);\n', '\t\tbool bThirdPartyClaiming = (recipient_address != payable(msg.sender) && reward >= 0);\n', '\t\tuint paid_amount;\n', '\t\tif (bThirdPartyClaiming) {\n', '\t\t\trequire(amount > uint(reward), "reward too large");\n', '\t\t\tpaid_amount = amount - uint(reward);\n', '\t\t}\n', '\t\treceiveMoneyInClaim(stake, paid_amount);\n', '\t\tuint required_stake = getRequiredStake(amount);\n', '\t\tCounterstakeLibrary.ClaimRequest memory req = CounterstakeLibrary.ClaimRequest({\n', '\t\t\ttxid: txid,\n', '\t\t\ttxts: txts,\n', '\t\t\tamount: amount,\n', '\t\t\treward: reward,\n', '\t\t\tstake: stake,\n', '\t\t\trequired_stake: required_stake,\n', '\t\t\trecipient_address: recipient_address,\n', '\t\t\tsender_address: sender_address,\n', '\t\t\tdata: data\n', '\t\t});\n', '\t\tlast_claim_num++;\n', '\t\tongoing_claim_nums.push(last_claim_num);\n', '\t\tnum2index[last_claim_num] = ongoing_claim_nums.length - 1;\n', '\n', '\t\tCounterstakeLibrary.claim(settings, claim_nums, claims, stakes, last_claim_num, req);\n', '\t\t\n', '\t\tif (bThirdPartyClaiming){\n', '\t\t\tsendToClaimRecipient(recipient_address, paid_amount);\n', '\t\t\tnotifyPaymentRecipient(recipient_address, paid_amount, 0, last_claim_num);\n', '\t\t}\n', '\t}\n', '\t\n', '\n', '\tfunction challenge(string calldata claim_id, CounterstakeLibrary.Side stake_on, uint stake) payable external {\n', '\t\tchallenge(claim_nums[claim_id], stake_on, stake);\n', '\t}\n', '\n', '\tfunction challenge(uint claim_num, CounterstakeLibrary.Side stake_on, uint stake) nonReentrant payable public {\n', '\t\treceiveStakeAsset(stake);\n', '\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\n', '\t\trequire(c.amount > 0, "no such claim");\n', '\t\tCounterstakeLibrary.challenge(settings, c, stakes, claim_num, stake_on, stake);\n', '\t}\n', '\n', '\tfunction withdraw(string memory claim_id) external {\n', '\t\twithdraw(claim_nums[claim_id], payable(0));\n', '\t}\n', '\n', '\tfunction withdraw(uint claim_num) external {\n', '\t\twithdraw(claim_num, payable(0));\n', '\t}\n', '\n', '\tfunction withdraw(string memory claim_id, address payable to_address) external {\n', '\t\twithdraw(claim_nums[claim_id], to_address);\n', '\t}\n', '\n', '\tfunction withdraw(uint claim_num, address payable to_address) nonReentrant public {\n', '\t\tif (to_address == address(0))\n', '\t\t\tto_address = payable(msg.sender);\n', '\t\trequire(claim_num > 0, "no such claim num");\n', '\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\n', '\t\trequire(c.amount > 0, "no such claim");\n', '\n', '\t\t(bool finished, bool is_winning_claimant, uint won_stake) = CounterstakeLibrary.finish(c, stakes, claim_num, to_address);\n', '\t\t\n', '\t\tif (finished){\n', '\t\t\tuint index = num2index[claim_num];\n', '\t\t\tuint last_index = ongoing_claim_nums.length - 1;\n', '\t\t\tif (index != last_index){ // move the last element in place of our removed element\n', '\t\t\t\trequire(index < last_index, "BUG index after last");\n', '\t\t\t\tuint64 claim_num_of_last_element = ongoing_claim_nums[last_index];\n', '\t\t\t\tnum2index[claim_num_of_last_element] = index;\n', '\t\t\t\tongoing_claim_nums[index] = claim_num_of_last_element;\n', '\t\t\t}\n', '\t\t\tongoing_claim_nums.pop();\n', '\t\t\tdelete num2index[claim_num];\n', '\t\t}\n', '\n', '\t\tuint claimed_amount_to_be_paid = is_winning_claimant ? c.amount : 0;\n', '\t\tsendWithdrawals(to_address, claimed_amount_to_be_paid, won_stake);\n', '\t\tnotifyPaymentRecipient(to_address, claimed_amount_to_be_paid, won_stake, claim_num);\n', '\t}\n', '\n', '\tfunction notifyPaymentRecipient(address payable payment_recipient_address, uint net_claimed_amount, uint won_stake, uint claim_num) private {\n', '\t\tif (CounterstakeLibrary.isContract(payment_recipient_address)){\n', '\t\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\n', '\t\t//\tCounterstakeReceiver(payment_recipient_address).onReceivedFromClaim(claim_num, is_winning_claimant ? claimed_amount : 0, won_stake);\n', '\t\t\t(bool res, ) = payment_recipient_address.call(abi.encodeWithSignature("onReceivedFromClaim(uint256,uint256,uint256,string,address,string)", claim_num, net_claimed_amount, won_stake, c.sender_address, c.recipient_address, c.data));\n', '\t\t\tif (!res){\n', '\t\t\t\t// ignore\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction receiveStakeAsset(uint stake_asset_amount) internal {\n', '\t\tif (settings.tokenAddress == address(0))\n', '\t\t\trequire(msg.value == stake_asset_amount, "wrong amount received");\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "don\'t send ETH");\n', '\t\t\trequire(IERC20(settings.tokenAddress).transferFrom(msg.sender, address(this), stake_asset_amount), "failed to pull the token");\n', '\t\t}\n', '\t}\n', '\n', '\tfunction sendWithdrawals(address payable to_address, uint claimed_amount_to_be_paid, uint won_stake) internal virtual;\n', '\t\n', '\tfunction sendToClaimRecipient(address payable to_address, uint paid_amount) internal virtual;\n', '\n', '\tfunction receiveMoneyInClaim(uint stake, uint paid_amount) internal virtual;\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract Export is Counterstake {\n', '\n', '\n', '\tevent NewExpatriation(address sender_address, uint amount, int reward, string foreign_address, string data);\n', '\n', '\tstring public foreign_network;\n', '\tstring public foreign_asset;\n', '\n', '\tconstructor (string memory _foreign_network, string memory _foreign_asset, address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods)\n', '\tCounterstake(_tokenAddr, _counterstake_coef100, _ratio100, _large_threshold, _challenging_periods, _large_challenging_periods)\n', '\t{\n', '\t\tforeign_network = _foreign_network;\n', '\t\tforeign_asset = _foreign_asset;\n', '\t}\n', '\n', '\tfunction initExport(string memory _foreign_network, string memory _foreign_asset) public\n', '\t{\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tforeign_network = _foreign_network;\n', '\t\tforeign_asset = _foreign_asset;\n', '\t}\n', '\n', '\n', '\tfunction transferToForeignChain(string memory foreign_address, string memory data, uint amount, int reward) payable nonReentrant external {\n', '\t\treceiveStakeAsset(amount);\n', '\t\tif (reward >= 0)\n', '\t\t\trequire(uint(reward) < amount, "reward too big");\n', '\t\temit NewExpatriation(msg.sender, amount, reward, foreign_address, data);\n', '\t}\n', '\n', '\n', '\tfunction getRequiredStake(uint amount) public view override returns (uint) {\n', '\t\treturn Math.max(amount * settings.ratio100 / 100, settings.min_stake);\n', '\t}\n', '\n', '\n', '\tfunction sendWithdrawals(address payable to_address, uint paid_claimed_amount, uint won_stake) internal override {\n', '\t\tuint total = won_stake + paid_claimed_amount;\n', '\t\tif (settings.tokenAddress == address(0)) {\n', '\t\t\tto_address.transfer(total);\n', '\t\t}\n', '\t\telse {\n', '\t\t\trequire(IERC20(settings.tokenAddress).transfer(to_address, total), "failed to send tokens");\n', '\t\t}\n', '\t}\n', '\n', '\tfunction receiveMoneyInClaim(uint stake, uint paid_amount) internal override {\n', '\t\treceiveStakeAsset(stake + paid_amount);\n', '\t}\n', '\n', '\tfunction sendToClaimRecipient(address payable to_address, uint paid_amount) internal override {\n', '\t\tif (settings.tokenAddress == address(0)) {\n', '\t\t\tto_address.transfer(paid_amount);\n', '\t\t}\n', '\t\telse {\n', '\t\t\trequire(IERC20(settings.tokenAddress).transfer(to_address, paid_amount), "failed to send tokens");\n', '\t\t}\n', '\t}\n', '\n', '}']