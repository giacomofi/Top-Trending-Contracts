['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-30\n', '*/\n', '\n', '// File: contracts/VeloxTransferHelper.sol\n', '\n', '// SPDX-FileCopyrightText: Â© 2020 Velox <[email\xa0protected]>\n', '// SPDX-License-Identifier: BSD-3-Clause\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library VeloxTransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        require(token != address(0), 'VeloxTransferHelper: ZERO_ADDRESS');\n", "        require(to != address(0), 'VeloxTransferHelper: TO_ZERO_ADDRESS');\n", '\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'VeloxTransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        require(token != address(0), 'VeloxTransferHelper: ZERO_ADDRESS');\n", "        require(to != address(0), 'VeloxTransferHelper: TO_ZERO_ADDRESS');\n", '\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'VeloxTransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        require(token != address(0), 'VeloxTransferHelper: TOKEN_ZERO_ADDRESS');\n", "        require(from != address(0), 'VeloxTransferHelper: FROM_ZERO_ADDRESS');\n", "        require(to != address(0), 'VeloxTransferHelper: TO_ZERO_ADDRESS');\n", '\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'VeloxTransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', "        require(to != address(0), 'VeloxTransferHelper: TO_ZERO_ADDRESS');\n", '        \n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '// File: contracts/interfaces/IERC20.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/IERC20NONStandard.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '/**\n', ' * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n', ' * See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n', ' */\n', 'abstract contract IERC20NONStandard {\n', '    /* This is a slight change to the ERC20 base standard.\n', '    function totalSupply() constant returns (uint256 supply);\n', '    is replaced with:\n', '    uint256 public totalSupply;\n', '    This automatically creates a getter function for the totalSupply.\n', '    This is moved to the base contract since public getter functions are not\n', '    currently recognised as an implementation of the matching abstract\n', '    function by the compiler.\n', '    */\n', '\n', '    uint256 public totalSupply;\n', '    function balanceOf(address owner) virtual public view returns (uint256 balance);\n', '\n', '    /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC20 specification\n', '    /// will return Whether the transfer was successful or not\n', '    function transfer(address to, uint256 value) virtual public;\n', '\n', '    /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC20 specification\n', '    /// will return Whether the transfer was successful or not\n', '    function transferFrom(address from, address to, uint256 value) virtual public;\n', '\n', '\n', '    function approve(address spender, uint256 value) virtual public returns (bool success);\n', '    function allowance(address owner, address spender) virtual public view returns (uint256 remaining);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/SwapExceptions.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'contract SwapExceptions {\n', '\n', '    event SwapException(uint exception, uint info, uint detail);\n', '\n', '    enum Exception {\n', '        NO_ERROR,\n', '        GENERIC_ERROR,\n', '        UNAUTHORIZED,\n', '        INTEGER_OVERFLOW,\n', '        INTEGER_UNDERFLOW,\n', '        DIVISION_BY_ZERO,\n', '        BAD_INPUT,\n', '        TOKEN_INSUFFICIENT_ALLOWANCE,\n', '        TOKEN_INSUFFICIENT_BALANCE,\n', '        TOKEN_TRANSFER_FAILED,\n', '        MARKET_NOT_SUPPORTED,\n', '        SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_RATE_CALCULATION_FAILED,\n', '        TOKEN_INSUFFICIENT_CASH,\n', '        TOKEN_TRANSFER_OUT_FAILED,\n', '        INSUFFICIENT_LIQUIDITY,\n', '        INSUFFICIENT_BALANCE,\n', '        INVALID_COLLATERAL_RATIO,\n', '        MISSING_ASSET_PRICE,\n', '        EQUITY_INSUFFICIENT_BALANCE,\n', '        INVALID_CLOSE_AMOUNT_REQUESTED,\n', '        ASSET_NOT_PRICED,\n', '        INVALID_LIQUIDATION_DISCOUNT,\n', '        INVALID_COMBINED_RISK_PARAMETERS,\n', '        ZERO_ORACLE_ADDRESS,\n', '        CONTRACT_PAUSED\n', '    }\n', '\n', '    /*\n', '     * Note: Reason (but not Exception) is kept in alphabetical order\n', '     *       This is because Reason grows significantly faster, and\n', '     *       the order of Exception has some meaning, while the order of Reason\n', '     *       is arbitrary.\n', '     */\n', '    enum Reason {\n', '        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n', '        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n', '        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        BORROW_CONTRACT_PAUSED,\n', '        BORROW_MARKET_NOT_SUPPORTED,\n', '        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n', '        BORROW_TRANSFER_OUT_FAILED,\n', '        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n', '        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n', '        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n', '        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n', '        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n', '        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n', '        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n', '        LIQUIDATE_CONTRACT_PAUSED,\n', '        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_FETCH_ASSET_PRICE_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n', '        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_CONTRACT_PAUSED,\n', '        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n', '        SET_ASSET_PRICE_CHECK_ORACLE,\n', '        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n', '        SET_ORACLE_OWNER_CHECK,\n', '        SET_ORIGINATION_FEE_OWNER_CHECK,\n', '        SET_PAUSED_OWNER_CHECK,\n', '        SET_PENDING_ADMIN_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_VALIDATION,\n', '        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_CONTRACT_PAUSED,\n', '        SUPPLY_MARKET_NOT_SUPPORTED,\n', '        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        SUPPLY_TRANSFER_IN_FAILED,\n', '        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n', '        SUPPORT_MARKET_FETCH_PRICE_FAILED,\n', '        SUPPORT_MARKET_OWNER_CHECK,\n', '        SUPPORT_MARKET_PRICE_CHECK,\n', '        SUSPEND_MARKET_OWNER_CHECK,\n', '        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n', '        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n', '        WITHDRAW_CONTRACT_PAUSED,\n', '        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE\n', '    }\n', '\n', '    /**\n', '      * @dev report a known exception\n', '      */\n', '    function raiseException(Exception exception, Reason reason) internal returns (uint) {\n', '        emit SwapException(uint(exception), uint(reason), 0);\n', '        return uint(exception);\n', '    }\n', '\n', '    /**\n', '      * @dev report an opaque error from an upgradeable collaborator contract\n', '      */\n', '    function raiseGenericException(Reason reason, uint genericException) internal returns (uint) {\n', '        emit SwapException(uint(Exception.GENERIC_ERROR), uint(reason), genericException);\n', '        return uint(Exception.GENERIC_ERROR);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/Swappable.sol\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', '\n', '\n', '/**\n', '  * @title Swappable Interface\n', '  */\n', 'contract Swappable is SwapExceptions {\n', '    /**\n', '      * @dev Checks whether or not there is sufficient allowance for this contract to move amount from `from` and\n', '      *      whether or not `from` has a balance of at least `amount`. Does NOT do a transfer.\n', '      */\n', '    function checkTransferIn(address asset, address from, uint amount) internal view returns (Exception) {\n', '\n', '        IERC20 token = IERC20(asset);\n', '\n', '        if (token.allowance(from, address(this)) < amount) {\n', '            return Exception.TOKEN_INSUFFICIENT_ALLOWANCE;\n', '        }\n', '\n', '        if (token.balanceOf(from) < amount) {\n', '            return Exception.TOKEN_INSUFFICIENT_BALANCE;\n', '        }\n', '\n', '        return Exception.NO_ERROR;\n', '    }\n', '\n', '    /**\n', '      *  @dev This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n', '      *  See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n', '      */\n', '    function doTransferIn(address asset, address from, uint amount) internal returns (Exception) {\n', '        IERC20NONStandard token = IERC20NONStandard(asset);\n', '        bool result;\n', '        // Should we use Helper.safeTransferFrom?\n', "        require(token.allowance(from, address(this)) >= amount, 'Not enough allowance from client');\n", '        token.transferFrom(from, address(this), amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {                      // This is a non-standard ERC-20\n', '                    result := not(0)          // set result to true\n', '                }\n', '                case 32 {                     // This is a complaint ERC-20\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)        // Set `result = returndata` of external call\n', '                }\n', '                default {                     // This is an excessively non-compliant ERC-20, revert.\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '\n', '        if (!result) {\n', '            return Exception.TOKEN_TRANSFER_FAILED;\n', '        }\n', '\n', '        return Exception.NO_ERROR;\n', '    }\n', '\n', '    /**\n', '      * @dev Checks balance of this contract in asset\n', '      */\n', '    function getCash(address asset) internal view returns (uint) {\n', '        IERC20 token = IERC20(asset);\n', '        return token.balanceOf(address(this));\n', '    }\n', '\n', '    /**\n', '      * @dev Checks balance of `from` in `asset`\n', '      */\n', '    function getBalanceOf(address asset, address from) internal view returns (uint) {\n', '        IERC20 token = IERC20(asset);\n', '        return token.balanceOf(from);\n', '    }\n', '\n', '    /**\n', '      * @dev Similar to EIP20 transfer, except it handles a False result from `transfer` and returns an explanatory\n', "      *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n", "      *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n", '      *      it is >= amount, this should not revert in normal conditions.\n', '      *\n', '      *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n', '      *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n', '      */\n', '    function doTransferOut(address asset, address to, uint amount) internal returns (Exception) {\n', '        IERC20NONStandard token = IERC20NONStandard(asset);\n', '        bool result;\n', '        token.transfer(to, amount);\n', '\n', '        assembly {\n', '            switch returndatasize()\n', '                case 0 {                      // This is a non-standard ERC-20\n', '                    result := not(0)          // set result to true\n', '                }\n', '                case 32 {                     // This is a complaint ERC-20\n', '                    returndatacopy(0, 0, 32)\n', '                    result := mload(0)        // Set `result = returndata` of external call\n', '                }\n', '                default {                     // This is an excessively non-compliant ERC-20, revert.\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '\n', '        if (!result) {\n', '            return Exception.TOKEN_TRANSFER_OUT_FAILED;\n', '        }\n', '\n', '        return Exception.NO_ERROR;\n', '    }\n', '}\n', '\n', '// File: contracts/Context.sol\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return payable(msg.sender);\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: contracts/Ownable.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IVeloxSwapV3.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IVeloxSwapV3 {\n', '\n', '    function withdrawToken(address token, uint256 amount) external;\n', '    \n', '    function withdrawETH(uint256 amount) external;\n', '\n', '    function sellExactTokensForTokens(\n', '        string calldata exchange,\n', '        uint256 strategyId,\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 tokenInAmount,\n', '        uint256 minTokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline) external returns (uint256 amountOut);\n', '\n', '    function sellExactTokensForTokens(\n', '        string calldata exchange,\n', '        uint256 strategyId,\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 tokenInAmount,\n', '        uint256 minTokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline,\n', '        uint estimatedGasFundingCost) external returns (uint256 amountOut);\n', '\n', '    function sellTokensForExactTokens(\n', '        string calldata exchange,\n', '        uint256 strategyId,\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 maxTokenInAmount,\n', '        uint256 tokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline) external returns (uint256 amountIn);\n', '\n', '    function sellTokensForExactTokens(\n', '        string calldata exchange,\n', '        uint256 strategyId,\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 maxTokenInAmount,\n', '        uint256 tokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline,\n', '        uint estimatedGasFundingCost) external returns (uint256 amountIn);\n', '\n', '    function fundGasCost(uint256  strategyId, address seller, bytes32 txHash, uint256 wethAmount) external;\n', '\n', '}\n', '\n', '// File: contracts/BackingStore.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'abstract contract BackingStore {\n', '    address public MAIN_CONTRACT;\n', '    address public UNISWAP_FACTORY_ADDRESS = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n', '    address public UNISWAP_ROUTER_ADDRESS = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '    address public ADMIN_ADDRESS;\n', '}\n', '\n', '// File: contracts/lib/IERC165.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: contracts/lib/ERC165.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n', ' * for the additional interface id that will be supported. For example:\n', ' *\n', ' * ```solidity\n', ' * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', ' *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n', ' * }\n', ' * ```\n', ' *\n', ' * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/AccessControl.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev External interface of AccessControl declared to support ERC165 detection.\n', ' */\n', 'interface IAccessControl {\n', '    function hasRole(bytes32 role, address account) external view returns (bool);\n', '    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n', '    function grantRole(bytes32 role, address account) external;\n', '    function revokeRole(bytes32 role, address account) external;\n', '    function renounceRole(bytes32 role, address account) external;\n', '}\n', '\n', '/**\n', ' * @dev Contract module that allows children to implement role-based access\n', " * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n", ' * members except through off-chain means by accessing the contract event logs. Some\n', ' * applications may benefit from on-chain enumerability, for those cases see\n', ' * {AccessControlEnumerable}.\n', ' *\n', ' * Roles are referred to by their `bytes32` identifier. These should be exposed\n', ' * in the external API and be unique. The best way to achieve this is by\n', ' * using `public constant` hash digests:\n', ' *\n', ' * ```\n', ' * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");\n', ' * ```\n', ' *\n', ' * Roles can be used to represent a set of permissions. To restrict access to a\n', ' * function call, use {hasRole}:\n', ' *\n', ' * ```\n', ' * function foo() public {\n', ' *     require(hasRole(MY_ROLE, msg.sender));\n', ' *     ...\n', ' * }\n', ' * ```\n', ' *\n', ' * Roles can be granted and revoked dynamically via the {grantRole} and\n', ' * {revokeRole} functions. Each role has an associated admin role, and only\n', " * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n", ' *\n', ' * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n', ' * that only accounts with this role will be able to grant or revoke other\n', ' * roles. More complex role relationships can be created by using\n', ' * {_setRoleAdmin}.\n', ' *\n', ' * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n', ' * grant and revoke this role. Extra precautions should be taken to secure\n', ' * accounts that have been granted it.\n', ' */\n', 'abstract contract AccessControl is Context, IAccessControl, ERC165 {\n', '    struct RoleData {\n', '        mapping (address => bool) members;\n', '        bytes32 adminRole;\n', '    }\n', '\n', '    mapping (bytes32 => RoleData) private _roles;\n', '\n', '    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n', '\n', '    /**\n', "     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n", '     *\n', '     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n', '     * {RoleAdminChanged} not being emitted signaling this.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n', '\n', '    /**\n', '     * @dev Emitted when `account` is granted `role`.\n', '     *\n', '     * `sender` is the account that originated the contract call, an admin role\n', '     * bearer except when using {_setupRole}.\n', '     */\n', '    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n', '\n', '    /**\n', '     * @dev Emitted when `account` is revoked `role`.\n', '     *\n', '     * `sender` is the account that originated the contract call:\n', '     *   - if using `revokeRole`, it is the admin role bearer\n', '     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n', '     */\n', '    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IAccessControl).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns `true` if `account` has been granted `role`.\n', '     */\n', '    function hasRole(bytes32 role, address account) public view override returns (bool) {\n', '        return _roles[role].members[account];\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the admin role that controls `role`. See {grantRole} and\n', '     * {revokeRole}.\n', '     *\n', "     * To change a role's admin, use {_setRoleAdmin}.\n", '     */\n', '    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n', '        return _roles[role].adminRole;\n', '    }\n', '\n', '    /**\n', '     * @dev Grants `role` to `account`.\n', '     *\n', '     * If `account` had not been already granted `role`, emits a {RoleGranted}\n', '     * event.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have ``role``'s admin role.\n", '     */\n', '    function grantRole(bytes32 role, address account) public virtual override {\n', '        require(hasRole(getRoleAdmin(role), _msgSender()), "AccessControl: sender must be an admin to grant");\n', '\n', '        _grantRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Revokes `role` from `account`.\n', '     *\n', '     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n', '     *\n', '     * Requirements:\n', '     *\n', "     * - the caller must have ``role``'s admin role.\n", '     */\n', '    function revokeRole(bytes32 role, address account) public virtual override {\n', '        require(hasRole(getRoleAdmin(role), _msgSender()), "AccessControl: sender must be an admin to revoke");\n', '\n', '        _revokeRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Revokes `role` from the calling account.\n', '     *\n', "     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n", '     * purpose is to provide a mechanism for accounts to lose their privileges\n', '     * if they are compromised (such as when a trusted device is misplaced).\n', '     *\n', '     * If the calling account had been granted `role`, emits a {RoleRevoked}\n', '     * event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be `account`.\n', '     */\n', '    function renounceRole(bytes32 role, address account) public virtual override {\n', '        require(account == _msgSender(), "AccessControl: can only renounce roles for self");\n', '\n', '        _revokeRole(role, account);\n', '    }\n', '\n', '    /**\n', '     * @dev Grants `role` to `account`.\n', '     *\n', '     * If `account` had not been already granted `role`, emits a {RoleGranted}\n', "     * event. Note that unlike {grantRole}, this function doesn't perform any\n", '     * checks on the calling account.\n', '     *\n', '     * [WARNING]\n', '     * ====\n', '     * This function should only be called from the constructor when setting\n', '     * up the initial roles for the system.\n', '     *\n', '     * Using this function in any other way is effectively circumventing the admin\n', '     * system imposed by {AccessControl}.\n', '     * ====\n', '     */\n', '    function _setupRole(bytes32 role, address account) internal virtual {\n', '        _grantRole(role, account);\n', '    }\n', '\n', '    /**\n', "     * @dev Sets `adminRole` as ``role``'s admin role.\n", '     *\n', '     * Emits a {RoleAdminChanged} event.\n', '     */\n', '    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n', '        emit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n', '        _roles[role].adminRole = adminRole;\n', '    }\n', '\n', '    function _grantRole(bytes32 role, address account) private {\n', '        if (!hasRole(role, account)) {\n', '            _roles[role].members[account] = true;\n', '            emit RoleGranted(role, account, _msgSender());\n', '        }\n', '    }\n', '\n', '    function _revokeRole(bytes32 role, address account) private {\n', '        if (hasRole(role, account)) {\n', '            _roles[role].members[account] = false;\n', '            emit RoleRevoked(role, account, _msgSender());\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/AccessManager.sol\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', 'contract AccessManager is AccessControl{\n', '\n', '    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");\n', '    /**\n', '        * @dev Throws if called by any account other than the admin.\n', '    */\n', '    modifier hasAdminRole() {\n', '        require(hasRole(ADMIN_ROLE, _msgSender()), "VELOXSWAP: NOT_ADMIN");\n', '        _;\n', '    } \n', '    \n', '}\n', '\n', '// File: contracts/VeloxSwapV3.sol\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title VeloxSwap based on algorithmic conditional trading exeuctions\n', '*/\n', 'abstract contract VeloxSwapV3 is BackingStore, Ownable, Swappable, IVeloxSwapV3, AccessManager {\n', '    function setUpAdminRole(address _c) public onlyOwner returns (bool succeeded) {\n', '        require(_c != owner(), "VELOXPROXY_ADMIN_OWNER");\n', '        _setupRole(ADMIN_ROLE, _c);\n', '        return true;\n', '    }\n', '    function setRootRole() public onlyOwner returns (bool succeeded) {\n', '        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n', '        return true;\n', '    }\n', '    function grantAdminRole(address _c) public onlyOwner returns (bool succeeded) {\n', '        require(_c != owner(), "VELOXPROXY_ADMIN_OWNER");\n', '        grantRole(ADMIN_ROLE, _c);\n', '        return true;\n', '    }\n', '    function revokeAdminRole(address _c) public onlyOwner returns (bool succeeded) {\n', '        require(_c != owner(), "VELOXPROXY_ADMIN_OWNER");\n', '        revokeRole(ADMIN_ROLE, _c);\n', '        return true;\n', '    }\n', '\n', '    struct SwapInput {\n', '        address seller;\n', '        address tokenInAddress;\n', '        address tokenOutAddress;\n', '        uint256 tokenInAmount;\n', '        uint256 tokenOutAmount;\n', '        uint16 feeFactor;\n', '        bool takeFeeFromInput;\n', '        uint256 deadline;\n', '    }\n', '\n', '    address private gasFundingTokenAddress;\n', '\n', '    uint constant FEE_SCALE = 10000;\n', '    uint constant GAS_FUNDING_ESTIMATED_GAS = 26233;\n', '\n', '    event ValueSwapped(uint256 indexed strategyId, address indexed seller, address tokenIn, address tokenOut, uint256 amountIn, uint256 amountOut);\n', '    event GasFunded(uint256 indexed strategyId, address indexed seller, bytes32 indexed txHash, uint256 gasCost);\n', '    event GasFundingTokenChanged(address oldValue, address newValue);\n', '    event ExchangeRegistered(string indexed exchange, address indexed routerAddress);\n', '\n', '    function setGasFundingTokenAddress(address tokenAddress) external onlyOwner {\n', '        require(tokenAddress != address(0), "VELOXSWAP: ZERO_GAS_FUNDING_TOKEN_ADDRESS");\n', '\n', '        address oldValue = gasFundingTokenAddress;\n', '\n', '        gasFundingTokenAddress = tokenAddress;\n', '\n', '        emit GasFundingTokenChanged(oldValue, gasFundingTokenAddress);\n', '    }\n', '\n', '    function getGasFundingTokenAddress() public view returns (address) {\n', '        return gasFundingTokenAddress;\n', '    }\n', '\n', '    function setKnownExchange(string calldata exchangeName, address routerAddress) onlyOwner external virtual {\n', '        require(routerAddress != address(0), "VELOXSWAP: INVALID_ROUTER_ZERO_ADDRESS");\n', '\n', '        _setKnownExchange(exchangeName, routerAddress);\n', '        \n', '        emit ExchangeRegistered(exchangeName, routerAddress);\n', '    }\n', '\n', '    function withdrawToken(address token, uint256 amount) onlyOwner override external {\n', '        VeloxTransferHelper.safeTransfer(token, msg.sender, amount);\n', '    }\n', '\n', '    function withdrawETH(uint256 amount) onlyOwner override external {\n', '        VeloxTransferHelper.safeTransferETH(msg.sender, amount);\n', '    }\n', '\n', '    function fundGasCost(uint256 strategyId, address seller, bytes32 txHash, uint256 wethAmount) hasAdminRole override external {\n', '        require(txHash.length > 0, "VELOXSWAP: INVALID_TX_HASH");\n', '\n', '        _fundGasCost(strategyId, seller, txHash, wethAmount);\n', '    }\n', '\n', '    function _fundGasCost(uint256 strategyId, address seller, bytes32 txHash, uint256 wethAmount) private {\n', '        VeloxTransferHelper.safeTransferFrom(gasFundingTokenAddress, seller, _msgSender(), wethAmount);\n', '        \n', '        emit GasFunded(strategyId, seller, txHash, wethAmount);\n', '    }\n', '\n', '    /**\n', '    *   @dev This function should ONLY be executed when algorithmic conditons are met\n', '    *   function sellExactTokensForTokens\n', '    *   @param exchange             string name of a existing exchange in routersByName\n', '    *   @param strategyId           uint256 - strategy ID\n', '    *   @param seller               address\n', '    *   @param tokenInAddress       address\n', '    *   @param tokenOutAddress      address\n', '    *   @param tokenInAmount        uint256\n', '    *   @param minTokenOutAmount    uint256\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param deadline             uint256 - UNIX timestamp\n', '    *   @param estimatedGasFundingCost uint - estimated gas for gas funding transaction\n', '    */\n', '    function sellExactTokensForTokens(\n', '        string calldata exchange,\n', '        uint256 strategyId,\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 tokenInAmount,\n', '        uint256 minTokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline,\n', '        uint estimatedGasFundingCost\n', '    ) override hasAdminRole public returns (uint256 amountOut) {\n', '        uint256 initialGas = gasleft();\n', '\n', '        SwapInput memory input = SwapInput({ \n', '            seller: seller, tokenInAddress: tokenInAddress,\n', '            tokenOutAddress: tokenOutAddress,\n', '            tokenInAmount: tokenInAmount,\n', '            tokenOutAmount: minTokenOutAmount,\n', '            feeFactor: feeFactor,\n', '            takeFeeFromInput: takeFeeFromInput,\n', '            deadline: deadline });\n', '        \n', '        ( , amountOut) = swapTokens(exchange, strategyId, input, true);\n', '\n', '        // Not sure if it should be 0 or just minus something\n', '        if (isTakingOutputFeeInGasToken(input)) {\n', '            estimatedGasFundingCost = 0;\n', '        }\n', '        \n', '        uint256 gasCost = (initialGas - gasleft() + estimatedGasFundingCost) * tx.gasprice;\n', '\n', '        bytes32 txHash;\n', '        _fundGasCost(strategyId, seller, txHash, gasCost);\n', '    }\n', '\n', '    /**\n', '    *   @dev This function should ONLY be executed when algorithmic conditons are met\n', '    *   function sellExactTokensForTokens\n', '    *   @param exchange             string name of a existing exchange in routersByName\n', '    *   @param strategyId           uint256 - strategy ID\n', '    *   @param seller               address\n', '    *   @param tokenInAddress       address\n', '    *   @param tokenOutAddress      address\n', '    *   @param tokenInAmount        uint256\n', '    *   @param minTokenOutAmount    uint256\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param deadline             uint256 - UNIX timestamp\n', '    */\n', '    function sellExactTokensForTokens(\n', '        string calldata exchange,\n', '        uint256 strategyId,\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 tokenInAmount,\n', '        uint256 minTokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline\n', '    ) override hasAdminRole public returns (uint256 amountOut) {\n', '        amountOut = sellExactTokensForTokens(exchange, strategyId, seller, tokenInAddress, tokenOutAddress, tokenInAmount, minTokenOutAmount, feeFactor, takeFeeFromInput, deadline, GAS_FUNDING_ESTIMATED_GAS);\n', '    }\n', '\n', '    /**\n', '    *   @dev This function should ONLY be executed when algorithmic conditons are met\n', '    *   function sellTokensForExactTokens\n', '    *   @param exchange             string name of a existing exchange in routersByName\n', '    *   @param strategyId           uint256 - strategy ID\n', '    *   @param seller               address\n', '    *   @param tokenInAddress       address\n', '    *   @param tokenOutAddress      address\n', '    *   @param maxTokenInAmount     uint256\n', '    *   @param tokenOutAmount       uint256\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param deadline             uint256 - UNIX timestamp\n', '    *   @param estimatedGasFundingCost uint - estimated gas for gas funding transaction\n', '    */\n', '    function sellTokensForExactTokens(\n', '        string calldata exchange,\n', '        uint256 strategyId,\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 maxTokenInAmount,\n', '        uint256 tokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline,\n', '        uint estimatedGasFundingCost) override hasAdminRole public returns (uint256 amountIn) {\n', '\n', '        uint256 initialGas = gasleft();\n', '\n', '        SwapInput memory input = SwapInput({ \n', '            seller: seller, tokenInAddress: tokenInAddress,\n', '            tokenOutAddress: tokenOutAddress,\n', '            tokenInAmount: maxTokenInAmount,\n', '            tokenOutAmount: tokenOutAmount,\n', '            feeFactor: feeFactor,\n', '            takeFeeFromInput: takeFeeFromInput,\n', '            deadline: deadline });\n', '        \n', '        (amountIn, ) = swapTokens(exchange, strategyId, input, false);\n', '\n', '        // Not sure if it should be 0 or just minus something\n', '        if (isTakingOutputFeeInGasToken(input)) {\n', '            estimatedGasFundingCost = 0;\n', '        }\n', '        \n', '        uint256 gasCost = (initialGas - gasleft() + estimatedGasFundingCost) * tx.gasprice;\n', '\n', '        bytes32 txHash;\n', '        _fundGasCost(strategyId, seller, txHash, gasCost);\n', '    }\n', '\n', '    /**\n', '    *   @dev This function should ONLY be executed when algorithmic conditons are met\n', '    *   function sellTokensForExactTokens\n', '    *   @param exchange             string name of a existing exchange in routersByName\n', '    *   @param strategyId           uint256 - strategy ID\n', '    *   @param seller               address\n', '    *   @param tokenInAddress       address\n', '    *   @param tokenOutAddress      address\n', '    *   @param maxTokenInAmount     uint256\n', '    *   @param tokenOutAmount       uint256\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param deadline             uint256 - UNIX timestamp\n', '    */\n', '    function sellTokensForExactTokens(\n', '        string calldata exchange,\n', '        uint256 strategyId,\n', '        address seller,\n', '        address tokenInAddress,\n', '        address tokenOutAddress,\n', '        uint256 maxTokenInAmount,\n', '        uint256 tokenOutAmount,\n', '        uint16 feeFactor,\n', '        bool takeFeeFromInput,\n', '        uint256 deadline) override hasAdminRole public returns (uint256 amountIn) {\n', '        amountIn = sellTokensForExactTokens(exchange, strategyId, seller, tokenInAddress, tokenOutAddress, maxTokenInAmount, tokenOutAmount, feeFactor, takeFeeFromInput, deadline, GAS_FUNDING_ESTIMATED_GAS);\n', '    }\n', '    \n', '    function swapTokens(string calldata exchange, uint256 strategyId, SwapInput memory input, bool exactIn) private returns (uint256 amountIn, uint256 amountOut) {\n', '        uint256 amountInForSwap;\n', '        uint256 amountOutForSwap;\n', '        address swapTargetAddress;\n', '\n', '        (amountInForSwap, amountOutForSwap, swapTargetAddress) \n', '            = prepareSwap(exchange, input);\n', '\n', '        uint actualAmountOut;\n', '\n', '        // Execute the swap\n', '        (amountIn, actualAmountOut) = doSwap(exchange, input.tokenInAddress, input.tokenOutAddress, amountInForSwap, amountOutForSwap, swapTargetAddress, input.deadline, exactIn);\n', '\n', '        // Take the fee from the output if not taken from the input\n', '        if (!input.takeFeeFromInput) {\n', '            amountOut = takeOutputFee(actualAmountOut, input.feeFactor, input.tokenOutAddress, input.seller);\n', '        }\n', '\n', '        emit ValueSwapped(strategyId, input.seller, input.tokenInAddress, input.tokenOutAddress, input.tokenInAmount, amountOut);\n', '    }\n', '\n', '    function prepareSwap(string calldata exchange, SwapInput memory input) private returns (uint256 amountInForSwap, uint256 amountOurForSwap, address targetAddress) {\n', '\n', '        // Sanity checks\n', '        validateInput(input.seller, input.tokenInAddress, input.tokenOutAddress, input.tokenInAmount, input.tokenOutAmount, input.feeFactor, input.deadline);\n', '\n', "        // Be 100% sure there's available allowance in this token contract\n", '        Exception exception = doTransferIn(input.tokenInAddress, input.seller, input.tokenInAmount);\n', "        require(exception == Exception.NO_ERROR, 'VELOXSWAP: ALLOWANCE_TOO_LOW');\n", '\n', '        // Checking In/Out reserves\n', '        checkLiquidity(exchange, input.tokenInAddress, input.tokenOutAddress, input.tokenOutAmount);\n', '\n', '        // Fee\n', '        (amountInForSwap, amountOurForSwap, targetAddress) = adjustInputBasedOnFee(input.takeFeeFromInput, input.feeFactor, input.tokenInAmount, input.tokenOutAmount, input.seller);\n', '    }\n', '\n', '    function validateInput(address seller, address tokenInAddress, address tokenOutAddress, uint256 tokenInAmount, uint256 tokenOutAmount, uint16 feeFactor, uint256 deadline) private view {\n', "        require(deadline >= block.timestamp, 'VELOXSWAP: EXPIRED');\n", "        require(feeFactor <= 30, 'VELOXSWAP: FEE_OVER_03_PERCENT');\n", '\n', "        require(gasFundingTokenAddress != address(0), 'VELOXSWAP: GAS_FUNDING_ADDRESS_NOT_FOUND');\n", '\n', '        require (seller != address(0) &&\n', '                tokenInAddress != address(0) &&\n', '                tokenOutAddress != address(0) &&\n', '                tokenInAmount > 0 &&\n', '                tokenOutAmount > 0,\n', "        'VELOXSWAP: ZERO_DETECTED');\n", '    }\n', '\n', '    /**\n', '    *   @dev Adjust input values based on the fee strategy\n', '    *   @param takeFeeFromInput     bool\n', '    *   @param feeFactor            uint - 1/10000 fraction of the amount, i.e. feeFactor of 1 means 0.01% fee\n', '    *   @param amountIn             uint256\n', '    *   @param amountOut            uint256\n', '    *   @param sellerAddress        address\n', '    */\n', '    function adjustInputBasedOnFee(bool takeFeeFromInput, uint16 feeFactor, uint256 amountIn, uint256 amountOut, address sellerAddress) private view\n', '        returns (uint256 amountInForSwap, uint256 amountOurForSwap, address targetAddress) {\n', '        // Take fee from input\n', '        if (takeFeeFromInput) {\n', '            // Use less tokens for swap so we can keep the difference and make one less transfer\n', '            amountInForSwap = deductFee(amountIn, feeFactor);\n', '            amountOurForSwap = deductFee(amountOut, feeFactor);\n', '\n', '        // If we took fee from the input, transfer the result directly to client,\n', '        // otherwise, transfer to contract address so we can take fee from output\n', '            targetAddress = sellerAddress;\n', '        } else {\n', '            amountInForSwap = amountIn;\n', '            amountOurForSwap = amountOut;\n', '            targetAddress = address(this);\n', '        }\n', '    }\n', '\n', '    function doSwap(string calldata exchange, address tokenInAddress, address tokenOutAddress, uint256 tokenInAmount, uint256 minTokenOutAmount, address targetAddress, uint256 deadline, bool exactIn) private returns (uint amountIn, uint amountOut) {\n', '        // Safely Approve UNISWAP V2 Router for token amount\n', '        safeApproveExchangeRouter(exchange, tokenInAddress, tokenInAmount);\n', '\n', '        // Path\n', '        address[] memory path = new address[](2);\n', '        path[0] = tokenInAddress;\n', '        path[1] = tokenOutAddress;\n', '\n', '        uint[] memory amounts;\n', '\n', '        if (exactIn) {\n', '            amounts = swapExactTokensForTokens(\n', '                exchange,\n', '                tokenInAmount,\n', '                minTokenOutAmount,\n', '                path,\n', '                targetAddress,\n', '                deadline\n', '            );\n', '        } else {\n', '            amounts = swapTokensForExactTokens(\n', '                exchange,\n', '                tokenInAmount,\n', '                minTokenOutAmount,\n', '                path,\n', '                targetAddress,\n', '                deadline\n', '            );\n', '        }\n', '\n', '        amountIn = amounts[0];\n', '        amountOut = amounts[amounts.length - 1];\n', '    }\n', '\n', '    function checkLiquidity(string calldata exchange, address tokenInAddress, address tokenOutAddress, uint256 minTokenOutAmount) private view {\n', '        (uint reserveIn, uint reserveOut) = getLiquidityForPair(exchange, tokenInAddress, tokenOutAddress);\n', '\n', "        require(reserveIn > 0 && reserveOut > 0, 'VELOXSWAP: ZERO_RESERVE_DETECTED');\n", "        require(reserveOut > minTokenOutAmount, 'VELOXSWAP: NOT_ENOUGH_LIQUIDITY');\n", '    }\n', '\n', '    function takeOutputFee(uint256 amountOut, uint16 feeFactor, address tokenOutAddress,\n', '                           address from) private returns (uint256 transferredAmount) {\n', '\n', '        // Transfer to client address the value of amountOut - fee and keep difference in contract address\n', '        transferredAmount = deductFee(amountOut, feeFactor);\n', '        Exception exception = doTransferOut(tokenOutAddress, from, transferredAmount);\n', "        require (exception == Exception.NO_ERROR, 'VELOXSWAP: ERROR_GETTING_OUTPUT_FEE');\n", '    }\n', '\n', '    function deductFee(uint256 amount, uint16 feeFactor) private pure returns (uint256 deductedAmount) {\n', '        deductedAmount = (amount * (FEE_SCALE - feeFactor)) / FEE_SCALE;\n', '    }\n', '    \n', '    function isTakingOutputFeeInGasToken(SwapInput memory input) private view returns (bool) {\n', '        return !input.takeFeeFromInput && input.tokenOutAddress == gasFundingTokenAddress;\n', '    }\n', '\n', '    /**\n', '    ABSTRACT METHODS\n', '     */\n', '\n', '    function _setKnownExchange(string calldata exchangeName, address routerAddress) internal virtual;\n', '\n', '    function safeApproveExchangeRouter(string calldata exchange, address tokenInAddress, uint256 tokenInAmount) internal virtual;\n', '\n', '    function getLiquidityForPair(string calldata exchange, address tokenInAddress, address tokenOutAddress) view internal virtual returns (uint reserveIn, uint reserveOut);\n', '\n', '    function swapExactTokensForTokens(\n', '        string calldata exchange,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) internal virtual returns (uint[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        string calldata exchange,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) internal virtual returns (uint[] memory amounts);\n', '}\n', '\n', '// File: contracts/interfaces/IUniswapV2Router01.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', '// File: contracts/interfaces/IUniswapV2Router02.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', '// File: contracts/interfaces/IUniswapV2Pair.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: contracts/interfaces/IUniswapV2Factory.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', '// File: contracts/EthereumVeloxSwapV3.sol\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* @title VeloxSwap based on algorithmic conditional trading exeuctions\n', '*/\n', 'contract EthereumVeloxSwapV3 is VeloxSwapV3 {\n', '\n', '    mapping (string=>IUniswapV2Router02) routersByName;\n', '\n', '    function _setKnownExchange(string calldata exchangeName, address uniswapLikeRouterAddress) onlyOwner override internal {\n', '        require(uniswapLikeRouterAddress != address(0), "VELOXSWAP: INVALID_ROUTER_ADDRESS");\n', '\n', '        // Check how to validate this\n', '        IUniswapV2Router02 newRouter = IUniswapV2Router02(uniswapLikeRouterAddress);\n', '\n', '        require(address(newRouter.factory()) != address(0), "VELOXSWAP: INVALID_ROUTER");\n', '\n', '        routersByName[exchangeName] = newRouter;\n', '    }\n', '\n', '    function safeApproveExchangeRouter(string calldata exchange, address tokenInAddress, uint256 tokenInAmount) override internal {\n', '        IUniswapV2Router02 router = getRouter(exchange);\n', '\n', '        VeloxTransferHelper.safeApprove(tokenInAddress, address(router), tokenInAmount);\n', '    }\n', '\n', '    function getLiquidityForPair(string calldata exchange, address tokenInAddress, address tokenOutAddress) view internal override returns (uint reserveIn, uint reserveOut) {\n', '        IUniswapV2Router02 router = getRouter(exchange);\n', '        IUniswapV2Factory factory = IUniswapV2Factory(router.factory());\n', '\n', '        IUniswapV2Pair pair = IUniswapV2Pair(factory.getPair(tokenInAddress, tokenOutAddress));\n', '        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n', '\n', '        if (pair.token0() == tokenOutAddress) {\n', '            reserveIn = reserve1;\n', '            reserveOut = reserve0;\n', '        } else {\n', '            reserveIn = reserve0;\n', '            reserveOut = reserve1;\n', '        }\n', '    }\n', '\n', '    function getRouter(string memory exchange) private view returns (IUniswapV2Router02 router) {\n', '        router = routersByName[exchange];\n', '\n', '        require(address(router) != address(0), "VELOXSWAP: UNKNOWN_EXCHANGE");\n', '    }\n', '\n', '    function swapExactTokensForTokens(\n', '        string calldata exchange,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) override internal virtual returns (uint[] memory amounts) {\n', '        IUniswapV2Router02 router = getRouter(exchange);\n', '        \n', '        amounts = router.swapExactTokensForTokens(\n', '            amountIn,\n', '            amountOutMin,\n', '            path,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '\n', '    function swapTokensForExactTokens(\n', '        string calldata exchange,\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] memory path,\n', '        address to,\n', '        uint deadline\n', '    ) override internal virtual returns (uint[] memory amounts) {\n', '        IUniswapV2Router02 router = getRouter(exchange);\n', '        \n', '        amounts = router.swapTokensForExactTokens(\n', '            amountIn,\n', '            amountOutMin,\n', '            path,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '}']