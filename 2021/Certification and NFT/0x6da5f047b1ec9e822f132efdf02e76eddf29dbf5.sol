['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-05\n', '*/\n', '\n', '// Sources flattened with hardhat v2.0.7 https://hardhat.org\n', '\n', '// File @openzeppelin/contracts/cryptography/[email\xa0protected]\n', '\n', '//SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.6.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @dev These functions deal with verification of Merkle trees (hash trees),\n', ' */\n', 'library MerkleProof {\n', '    /**\n', '     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n', '     * defined by `root`. For this, a `proof` must be provided, containing\n', '     * sibling hashes on the branch from the leaf to the root of the tree. Each\n', '     * pair of leaves and each pair of pre-images are assumed to be sorted.\n', '     */\n', '    function verify(\n', '        bytes32[] memory proof,\n', '        bytes32 root,\n', '        bytes32 leaf\n', '    ) internal pure returns (bool) {\n', '        bytes32 computedHash = leaf;\n', '\n', '        for (uint256 i = 0; i < proof.length; i++) {\n', '            bytes32 proofElement = proof[i];\n', '\n', '            if (computedHash <= proofElement) {\n', '                // Hash(current computed hash + current element of the proof)\n', '                computedHash = keccak256(\n', '                    abi.encodePacked(computedHash, proofElement)\n', '                );\n', '            } else {\n', '                // Hash(current element of the proof + current computed hash)\n', '                computedHash = keccak256(\n', '                    abi.encodePacked(proofElement, computedHash)\n', '                );\n', '            }\n', '        }\n', '\n', '        // Check if the computed hash (root) is equal to the provided root\n', '        return computedHash == root;\n', '    }\n', '}\n', '\n', '// File contracts/interfaces/IMirrorWriteToken.sol\n', '\n', 'interface IMirrorWriteToken {\n', '    function register(string calldata label, address owner) external;\n', '\n', '    function registrationCost() external view returns (uint256);\n', '\n', '    // ============ ERC20 Interface ============\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '}\n', '\n', '// File contracts/lib/SafeMath.sol\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '}\n', '\n', '// File contracts/helpers/WriteDistributionHelperV1.sol\n', '\n', '/**\n', ' * @title WriteDistributionHelperV1\n', ' * @author MirrorXYZ\n', ' *\n', ' * A helper contract for distributing $WRITE token.\n', ' */\n', 'contract WriteDistributionHelperV1 {\n', '    // ============ Constants ============\n', '\n', '    uint64 constant units = 1e18;\n', '\n', '    // ============ Immutable Storage ============\n', '\n', '    address public immutable token;\n', '\n', '    // ============ Mutable Storage ============\n', '\n', '    address private _owner;\n', '    /**\n', '     * @dev Allows for two-step ownership transfer, whereby the next owner\n', '     * needs to accept the ownership transfer explicitly.\n', '     */\n', '    address private _nextOwner;\n', '    bytes32 public merkleRoot;\n', '    mapping(uint256 => uint256) private claimedBitMap;\n', '\n', '    // ============ Events ============\n', '\n', '    event Distributed(address account);\n', '    event RootUpdated(bytes32 oldRoot, bytes32 newRoot);\n', '    event Claimed(uint256 index, address account, uint256 amount);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "WriteDistributionV1: caller is not the owner.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyNextOwner() {\n', '        require(\n', '            isNextOwner(),\n', '            "WriteDistributionV1: current owner must set caller as next owner."\n', '        );\n', '        _;\n', '    }\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor(address token_) public {\n', '        token = token_;\n', '\n', '        _owner = tx.origin;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    // ============ Ownership ============\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the next owner.\n', '     */\n', '    function isNextOwner() public view returns (bool) {\n', '        return msg.sender == _nextOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows a new account (`newOwner`) to accept ownership.\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address nextOwner_) external onlyOwner {\n', '        require(\n', '            nextOwner_ != address(0),\n', '            "WriteDistributionV1: next owner is the zero address."\n', '        );\n', '\n', '        _nextOwner = nextOwner_;\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel a transfer of ownership to a new account.\n', '     * Can only be called by the current owner.\n', '     */\n', '    function cancelOwnershipTransfer() external onlyOwner {\n', '        delete _nextOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to the caller.\n', '     * Can only be called by a new potential owner set by the current owner.\n', '     */\n', '    function acceptOwnership() external onlyNextOwner {\n', '        delete _nextOwner;\n', '\n', '        emit OwnershipTransferred(_owner, msg.sender);\n', '\n', '        _owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() external onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    // ============ Distribution ============\n', '\n', '    function distributeTo(address[] memory addresses)\n', '        public\n', '        onlyOwner\n', '        returns (bool ok)\n', '    {\n', '        IMirrorWriteToken tokenContract = IMirrorWriteToken(token);\n', '\n', '        for (uint256 i = 0; i < addresses.length; i++) {\n', '            tokenContract.transfer(addresses[i], units);\n', '            emit Distributed(addresses[i]);\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    // ============ Merkle-Tree Token Claim ============\n', '\n', '    function setMerkleRoot(bytes32 merkleRoot_) external onlyOwner {\n', '        emit RootUpdated(merkleRoot, merkleRoot_);\n', '        merkleRoot = merkleRoot_;\n', '    }\n', '\n', '    function isClaimed(uint256 index) public view returns (bool) {\n', '        uint256 claimedWordIndex = index / 256;\n', '        uint256 claimedBitIndex = index % 256;\n', '        uint256 claimedWord = claimedBitMap[claimedWordIndex];\n', '        uint256 mask = (1 << claimedBitIndex);\n', '        return claimedWord & mask == mask;\n', '    }\n', '\n', '    function _setClaimed(uint256 index) private {\n', '        uint256 claimedWordIndex = index / 256;\n', '        uint256 claimedBitIndex = index % 256;\n', '        claimedBitMap[claimedWordIndex] =\n', '            claimedBitMap[claimedWordIndex] |\n', '            (1 << claimedBitIndex);\n', '    }\n', '\n', '    function claim(\n', '        uint256 index,\n', '        address account,\n', '        uint256 amount,\n', '        bytes32[] calldata merkleProof\n', '    ) external {\n', '        require(!isClaimed(index), "WriteDistributionV1: already claimed.");\n', '\n', '        // Verify the merkle proof.\n', '        bytes32 node = keccak256(abi.encodePacked(index, account, amount));\n', '        require(\n', '            MerkleProof.verify(merkleProof, merkleRoot, node),\n', '            "WriteDistributionV1: Invalid proof."\n', '        );\n', '\n', '        // Mark it claimed and send the token.\n', '        _setClaimed(index);\n', '        require(\n', '            IMirrorWriteToken(token).transfer(account, amount),\n', '            "WriteDistributionV1: Transfer failed."\n', '        );\n', '\n', '        emit Claimed(index, account, amount);\n', '    }\n', '}']