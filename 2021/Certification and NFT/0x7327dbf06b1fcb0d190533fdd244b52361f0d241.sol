['pragma solidity ^0.7.0;\n', '\n', 'import "./Ownable.sol";\n', '\n', 'contract MasksMetadataStore is Ownable {\n', '    // Public variables\n', '\n', '    bytes32[] public ipfsHashesInHexadecimal;\n', '    bytes3[] public traitBytes;\n', '\n', '    // Public constants\n', '\n', '    uint256 public constant MAX_MASKS_SUPPLY = 16384;\n', '\n', '    // IPFS CID is generated using default options of the IPFS node version specified in the variable below\n', '    string public constant IPFS_VERSION = "go-ipfs 0.8.0"; // Version of IPFS node used. For reproducibility.\n', '    bytes2 public constant IPFS_PREFIX = 0x1220; // Multihash function: SHA2-256 Hashing algorithm\n', '    string public constant IPFS_CHUNKER = "size-262144"; // IPFS Chunker used: size-262144\n', '    uint256 public constant IPFS_CID_VERSION = 0; // IPFS CID Version: v0\n', '    bool public constant IPFS_RAW_LEAVES_FLAG = false; // IPFS Raw leaves option flag: Set to false\n', '    string public constant IPFS_DAG_FORMAT = "Merkle DAG"; // IPFS DAG: Merkle DAG by default\n', '\n', '    /*\n', '    Store Metadata comprising of IPFS Hashes (In Hexadecimal minus the first two fixed bytes) and explicit traits\n', '    Ordered according to original hashed sequence pertaining to the Hashmasks provenance\n', '    Ownership is intended to be burned (Renounced) after storage is completed\n', '    */\n', '    function storeMetadata(bytes32[] memory ipfsHex, bytes3[] memory traitsHex)\n', '        public\n', '        onlyOwner\n', '    {\n', '        storeMetadataStartingAtIndex(\n', '            ipfsHashesInHexadecimal.length,\n', '            ipfsHex,\n', '            traitsHex\n', '        );\n', '    }\n', '\n', '    /*\n', '    Store metadata starting at a particular index. In case any corrections are required before completion\n', '    */\n', '    function storeMetadataStartingAtIndex(\n', '        uint256 startIndex,\n', '        bytes32[] memory ipfsHex,\n', '        bytes3[] memory traitsHex\n', '    ) public onlyOwner {\n', '        require(startIndex <= ipfsHashesInHexadecimal.length);\n', '        require(\n', '            ipfsHex.length == traitsHex.length,\n', '            "Arrays must be equal in length"\n', '        );\n', '\n', '        for (uint256 i = 0; i < ipfsHex.length; i++) {\n', '            if ((i + startIndex) >= ipfsHashesInHexadecimal.length) {\n', '                ipfsHashesInHexadecimal.push(ipfsHex[i]);\n', '                traitBytes.push(traitsHex[i]);\n', '            } else {\n', '                ipfsHashesInHexadecimal[i + startIndex] = ipfsHex[i];\n', '                traitBytes[i + startIndex] = traitsHex[i];\n', '            }\n', '        }\n', '\n', '        // Post-assertions\n', '        require(ipfsHashesInHexadecimal.length <= MAX_MASKS_SUPPLY);\n', '        require(traitBytes.length <= MAX_MASKS_SUPPLY);\n', '    }\n', '\n', '    /*\n', '    Returns the IPFS Hash in Hexadecimal format for the Hashmask image at specified position in the original hashed sequence\n', '    */\n', '    function getIPFSHashHexAtIndex(uint256 index)\n', '        public\n', '        view\n', '        returns (bytes memory)\n', '    {\n', '        require(\n', '            index < ipfsHashesInHexadecimal.length,\n', '            "Metadata does not exist for the specified index"\n', '        );\n', '        return abi.encodePacked(IPFS_PREFIX, ipfsHashesInHexadecimal[index]);\n', '    }\n', '\n', '    /*\n', '    Returns the trait bytes for the Hashmask image at specified position in the original hashed sequence\n', '    */\n', '    function getTraitBytesAtIndex(uint256 index) public view returns (bytes3) {\n', '        require(\n', '            index < traitBytes.length,\n', '            "Metadata does not exist for the specified index"\n', '        );\n', '        return traitBytes[index];\n', '    }\n', '}']