['"""\n', '@title Greenwood Router\n', '@notice Used to calculate instantaneous APR for Aave V2 and Compound\n', '@author Greenwood Labs\n', '"""\n', '\n', '# define the interfaces used by the contract\n', 'interface CTOKEN:\n', '    def borrowRatePerBlock() -> uint256: view\n', '\n', 'interface REGISTRY:\n', '    def getAddress(_contract: String[20], _version: String[11], ) -> address: nonpayable\n', '    def governance() -> address: nonpayable\n', '\n', 'interface STORE:\n', '    def getAssetContext(_ticker: String[10]) -> AssetContext: view\n', '\n', '# define the constants used by the contract\n', 'BLOCKS_PER_DAY: constant(decimal) = 5760.0\n', 'CONTRACT_PRECISION: constant(decimal) = 10000000000.0\n', 'ETH_PRECISION: constant(decimal) = 1000000000000000000.0\n', '\n', '# define the events used by the contract\n', 'event SetRegistry:\n', '    previousRegistry: address\n', '    newRegistry: address\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', '# define the structs used by the contract\n', 'struct AssetContext:\n', '    aToken: address\n', '    aaveV2PriceFeed: address\n', '    aaveV2LendingPool: address\n', '    cToken: address\n', '    compoundPriceFeed: address\n', '    comptroller: address\n', '    decimals: uint256\n', '    underlying: address\n', '\n', 'struct Split:\n', '    compoundSplit: uint256\n', '    aaveV2Split: uint256\n', '    borrowContext: AssetContext\n', '    collateralContext: AssetContext\n', '\n', '# define the storage variables used by the contract\n', 'registry: public(address)\n', '\n', '@external\n', 'def __init__(_registry: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _registry The address of the Greenwood Registry\n', '    """\n', '\n', '    # set the address of the Escrow\n', '    self.registry = _registry\n', '\n', '@internal\n', 'def isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\n', '    """\n', '    @notice Method for role-based security\n', '    @param _caller The address that called the permissioned method\n', '    @param _role The requested authorization level\n', '    @param _version The version of Greenwood to use\n', '    @return True if the caller is authorized, False otherwise\n', '    """\n', '\n', '    # check if the requested role is "controller"\n', '    if keccak256(_role) == keccak256("controller"):\n', '\n', '        # get the address of the Controller from the Registry\n', '        controller: address = REGISTRY(self.registry).getAddress("controller", _version)\n', '\n', '        # return the equality comparison\n', '        return controller == _caller\n', '    \n', '    # check if the requested role is "governance"\n', '    elif keccak256(_role) == keccak256("governance"):\n', '\n', '        # get the address of the Governance from the Registry\n', '        governance: address = REGISTRY(self.registry).governance()\n', '\n', '        # return the equality comparison\n', '        return governance == _caller\n', '\n', '    # catch extraneous role arguments\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled role argument"\n', '\n', '\n', '\n', '@external\n', 'def split(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _protocol: String[10], _store: address, _version: String[11]) -> Split:\n', '    """\n', '    @notice Calculate which lending protocol has the lowest APR for the given borrow request\n', '    @param _borrow_ticker The ticker string of the asset that is being borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of asset being borrowed scaled by the asset's decimals\n", '    @param _protocol The name of the underlying lending protocol for the loan\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of the Greenwood Protocol to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    @return Split struct\n', '    """\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True, "Only Controller or Governance can call this method"\n', '\n', '    # get the borrow asset context and the collateral asset context from the Store\n', '    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '\n', '    # assert that the contexts were returned from the Store\n', '    assert borrowContext.underlying != ZERO_ADDRESS, "Borrow asset context has ZERO_ADDRESS for underlying"\n', '    assert collateralContext.underlying != ZERO_ADDRESS, "Collateral asset context has ZERO_ADDRESS for underlying"\n', '\n', '    # check if the specified lending protocol was Compound\n', '    if keccak256(_protocol) == keccak256("compound"):\n', '        \n', '        # route 100% of the borrow to Compound\n', '        return Split({\n', '            compoundSplit: 100, \n', '            aaveV2Split: 0,                    \n', '            borrowContext: borrowContext,\n', '            collateralContext: collateralContext\n', '        })\n', '\n', '    # check if the specified lending protocol was Aave V2\n', '    elif keccak256(_protocol) == keccak256("aavev2"):\n', '        \n', '        # route 100% of the borrow to Aave V2\n', '        return Split({\n', '            compoundSplit: 0, \n', '            aaveV2Split: 100,                    \n', '            borrowContext: borrowContext,\n', '            collateralContext: collateralContext\n', '        })\n', '        \n', '    # check if no lending protocol was specified\n', '    elif keccak256(_protocol) == keccak256(""):\n', '\n', '        # check if the borrow asset is supported by both protocols\n', '        if borrowContext.aToken != ZERO_ADDRESS and borrowContext.cToken != ZERO_ADDRESS:\n', '\n', '            # call borrowRatePerBlock on the cToken contract and calculate instantaneous APR for Compound\n', '            rate: decimal = convert(CTOKEN(borrowContext.cToken).borrowRatePerBlock(), decimal)\n', '            t0: decimal = rate / ETH_PRECISION * BLOCKS_PER_DAY + 1.0\n', '            t1: decimal = t0 * t0\n', '            for i in range(362):\n', '                t1 = t1 * t0\n', '            t2: decimal = t1 - 1.0\n', '            compoundAPR: uint256 = convert(t2 * CONTRACT_PRECISION, uint256)\n', '            \n', '            # call getReserveData on the Aave V2 LendingPool\n', '            _response: Bytes[768] = raw_call(\n', '                borrowContext.aaveV2LendingPool,\n', '                concat(\n', '                    method_id("getReserveData(address)"),\n', '                    convert(borrowContext.underlying, bytes32)\n', '                ),\n', '                max_outsize=768\n', '            )\n', '\n', '            # parse the instantaneous APR for Aave V2\n', '            # @dev getReserveData returns 12 items. currentVariableBorrowRate is the 5th item. each item is given 32 bytes in the list\n', '            aaveAPR: uint256 = convert((convert(slice(_response, 128, 32), decimal) / convert(10 ** 26, decimal)) * CONTRACT_PRECISION, uint256)\n', '\n', '            # check if the instantaneous APR for Aave V2 is less than the instantaneous APR for Compound\n', '            if aaveAPR < compoundAPR:\n', '\n', '                # route 100% of the borrow to Aave V2\n', '                return Split({\n', '                    compoundSplit: 0, \n', '                    aaveV2Split: 100,                    \n', '                    borrowContext: borrowContext,\n', '                    collateralContext: collateralContext\n', '                })\n', '\n', '            # check if the instantaneous APR for Compound is less than the instantaneous APR for Aave V2\n', '            elif compoundAPR < aaveAPR:\n', '\n', '                # route 100% of the borrow to Compound \n', '                return Split({\n', '                    compoundSplit: 100,\n', '                    aaveV2Split: 0,\n', '                    borrowContext: borrowContext,\n', '                    collateralContext: collateralContext\n', '                })\n', '\n', '            # handle matching instantaneous APRs\n', '            else:\n', '\n', '                # route 100% of the borrow to Compound \n', '                return Split({\n', '                    compoundSplit: 100,\n', '                    aaveV2Split: 0,\n', '                    borrowContext: borrowContext,\n', '                    collateralContext: collateralContext\n', '                })\n', '\n', '        # check if the borrow asset is only supported by Compound\n', '        elif borrowContext.aToken == ZERO_ADDRESS and borrowContext.cToken != ZERO_ADDRESS:\n', '\n', '            # route 100% of the borrow to Compound \n', '            return Split({\n', '                compoundSplit: 100,\n', '                aaveV2Split: 0,\n', '                borrowContext: borrowContext,\n', '                collateralContext: collateralContext\n', '            })\n', '\n', '        # check if the borrow asset is only supported by Aave V2\n', '        elif borrowContext.aToken != ZERO_ADDRESS and borrowContext.cToken == ZERO_ADDRESS:\n', '\n', '            # route 100% of the borrow to Aave V2 \n', '            return Split({\n', '                compoundSplit: 0,\n', '                aaveV2Split: 100,\n', '                borrowContext: borrowContext,\n', '                collateralContext: collateralContext\n', '            })\n', '\n', '        # catch unsupported assets\n', '        else:\n', '\n', '            # revert\n', '            raise "Unsupported borrow asset"\n', '\n', '    # catch unsupported lending protocols\n', '    else:\n', '\n', '        # revert\n', '        raise "Unsupported protocol"\n', '\n', '@external\n', 'def setRegistry(_new_registry: address):\n', '    """\n', '    @notice Updates the address of the Registry\n', '    @param _new_registry The address of the new Greenwood Registry\n', '    @dev Only the Governance can call this method\n', '    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isAuthorized(msg.sender, "governance", "") == True, "Only Governance can call this method"\n', '\n', '    # get the previous Registry\n', '    previousRegistry: address = self.registry\n', '\n', '    # update the address of the Registry\n', '    self.registry = _new_registry\n', '\n', '    # emit a SetRegistry event\n', '    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)']