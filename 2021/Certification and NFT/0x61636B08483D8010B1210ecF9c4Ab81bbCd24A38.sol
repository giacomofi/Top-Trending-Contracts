['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.3;\n', '\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n', ' * deploying minimal proxy contracts, also known as "clones".\n', ' *\n', ' * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n', ' * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n', ' *\n', ' * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n', ' * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n', ' * deterministic method.\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'library Clones {\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create opcode, which should never revert.\n', '     */\n', '    function clone(address implementation) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create(0, ptr, 0x37)\n', '        }\n', '        require(instance != address(0), "ERC1167: create failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create2 opcode and a `salt` to deterministically deploy\n', '     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n', '     * the clones cannot be deployed twice at the same address.\n', '     */\n', '    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create2(0, ptr, 0x37, salt)\n', '        }\n', '        require(instance != address(0), "ERC1167: create2 failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n', '            mstore(add(ptr, 0x38), shl(0x60, deployer))\n', '            mstore(add(ptr, 0x4c), salt)\n', '            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n', '            predicted := keccak256(add(ptr, 0x37), 0x55)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n', '        return predictDeterministicAddress(implementation, salt, address(this));\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '\n', 'contract Governance is ReentrancyGuard {\n', '\n', '\tuint constant public governance_challenging_period = 10 days;\n', '\tuint constant public governance_freeze_period = 30 days;\n', '\n', '\taddress public votingTokenAddress;\n', '\taddress public governedContractAddress;\n', '\n', '\tmapping(address => uint) public balances;\n', '\n', '\tVotedValue[] public votedValues;\n', '\tmapping(string => VotedValue) public votedValuesMap;\n', '\n', '\n', '\tconstructor(address _governedContractAddress, address _votingTokenAddress){\n', '\t\tinit(_governedContractAddress, _votingTokenAddress);\n', '\t}\n', '\n', '\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\n', '\t\trequire(governedContractAddress == address(0), "governance already initialized");\n', '\t\tgovernedContractAddress = _governedContractAddress;\n', '\t\tvotingTokenAddress = _votingTokenAddress;\n', '\t}\n', '\n', '\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\n', '\t\tfor (uint i = 0; i < votedValues.length; i++)\n', '\t\t\tif (address(votedValues[i]) == addr)\n', '\t\t\t\treturn true;\n', '\t\treturn false;\n', '\t}\n', '\n', '\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\n', '\t\tfor (uint i = 0; i < votedValues.length; i++)\n', '\t\t\tif (votedValues[i].hasVote(addr))\n', '\t\t\t\treturn false;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\n', '\t\trequire(msg.sender == governedContractAddress, "not authorized");\n', '\t\tvotedValues.push(votedValue);\n', '\t\tvotedValuesMap[name] = votedValue;\n', '\t}\n', '\n', '\n', '\t// deposit\n', '\n', '\tfunction deposit(uint amount) payable external {\n', '\t\tdeposit(msg.sender, amount);\n', '\t}\n', '\n', '\tfunction deposit(address from, uint amount) nonReentrant payable public {\n', '\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), "not allowed");\n', '\t\tif (votingTokenAddress == address(0))\n', '\t\t\trequire(msg.value == amount, "wrong amount received");\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "don\'t send ETH");\n', '\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), "failed to pull gov deposit");\n', '\t\t}\n', '\t\tbalances[from] += amount;\n', '\t}\n', '\n', '\n', '\t// withdrawal functions\n', '\n', '\tfunction withdraw() external {\n', '\t\twithdraw(balances[msg.sender]);\n', '\t}\n', '\n', '\tfunction withdraw(uint amount) nonReentrant public {\n', '\t\trequire(amount > 0, "zero withdrawal requested");\n', '\t\trequire(amount <= balances[msg.sender], "not enough balance");\n', '\t\trequire(isUntiedFromAllVotes(msg.sender), "some votes not removed yet");\n', '\t\tbalances[msg.sender] -= amount;\n', '\t\tif (votingTokenAddress == address(0))\n', '\t\t\tpayable(msg.sender).transfer(amount);\n', '\t\telse\n', '\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), "failed to withdraw gov deposit");\n', '\t}\n', '}\n', '\n', '\n', 'abstract contract VotedValue is ReentrancyGuard {\n', '\tGovernance public governance;\n', '\tuint public challenging_period_start_ts;\n', '\tmapping(address => bool) public hasVote;\n', '\n', '\tconstructor(Governance _governance){\n', '\t\tgovernance = _governance;\n', '\t}\n', '\n', '\tfunction checkVoteChangeLock() view public {\n', '\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, "you cannot change your vote yet");\n', '\t}\n', '\n', '\tfunction checkChallengingPeriodExpiry() view public {\n', '\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), "challenging period not expired yet");\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract GovernanceFactory {\n', '\n', '\taddress public governanceMaster;\n', '\n', '\tconstructor(address _governanceMaster) {\n', '\t\tgovernanceMaster = _governanceMaster;\n', '\t}\n', '\n', '\tfunction createGovernance(address governedContractAddress, address votingTokenAddress) external returns (Governance) {\n', '\t\tGovernance governance = Governance(Clones.clone(governanceMaster));\n', '\t\tgovernance.init(governedContractAddress, votingTokenAddress);\n', '\t\treturn governance;\n', '\t}\n', '\n', '}']