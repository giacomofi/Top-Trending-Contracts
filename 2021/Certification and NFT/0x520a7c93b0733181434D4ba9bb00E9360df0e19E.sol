['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/CounterstakeLibrary.sol\n', '\n', 'pragma solidity ^0.8.3;\n', '\n', '\n', '// The purpose of the library is to separate some of the code out of the Export/Import contracts and keep their sizes under the 24KiB limit\n', '\n', '\n', 'library CounterstakeLibrary {\n', '\n', '\tenum Side {no, yes}\n', '\n', '\t// small values (bool, uint32, ...) are grouped together in order to be packed efficiently\n', '\tstruct Claim {\n', '\t\tuint amount;\n', '\t//\tint reward;\n', '\n', '\t\taddress payable recipient_address; // 20 bytes, 12 bytes left\n', '\t\tuint32 txts;\n', '\t\tuint32 ts;\n', '\t\t\n', '\t\taddress payable claimant_address;\n', '\t\tuint32 expiry_ts;\n', '\t\tuint16 period_number;\n', '\t\tSide current_outcome;\n', '\t\tbool is_large;\n', '\t\tbool withdrawn;\n', '\t\tbool finished;\n', '\t\t\n', '\t\tstring sender_address;\n', '\t//\tstring txid;\n', '\t\tstring data;\n', '\t\tuint yes_stake;\n', '\t\tuint no_stake;\n', '\t//\tuint challenging_target;\n', '\t}\n', '\n', '\tstruct Settings {\n', '\t\taddress tokenAddress;\n', '\t\tuint16 ratio100;// = 100;\n', '\t\tuint16 counterstake_coef100;// = 150;\n', '\t\tuint32 min_tx_age;\n', '\t\tuint min_stake;\n', '\t\tuint[] challenging_periods;// = [12 hours, 3 days, 1 weeks, 30 days];\n', '\t\tuint[] large_challenging_periods;// = [3 days, 1 weeks, 30 days];\n', '\t\tuint large_threshold;\n', '\t}\n', '\n', '\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\n', '\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, Side outcome, Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\n', '\tevent FinishedClaim(uint indexed claim_num, Side outcome);\n', '\n', '\n', '\tstruct ClaimRequest {\n', '\t\tstring txid;\n', '\t\tuint32 txts;\n', '\t\tuint amount;\n', '\t\tint reward;\n', '\t\tuint stake;\n', '\t\tuint required_stake;\n', '\t\taddress payable recipient_address;\n', '\t\tstring sender_address;\n', '\t\tstring data;\n', '\t}\n', '\n', '\tfunction claim(\n', '\t\tSettings storage settings,\n', '\t\tmapping(string => uint) storage claim_nums,\n', '\t\tmapping(uint => Claim) storage claims,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes,\n', '\t\tuint claim_num,\n', '\t\tClaimRequest memory req\n', '\t) external {\n', '\t\trequire(req.amount > 0, "0 claim");\n', '\t\trequire(req.stake >= req.required_stake, "the stake is too small");\n', '\t\trequire(block.timestamp >= req.txts + settings.min_tx_age, "too early");\n', '\t\tif (req.recipient_address == address(0))\n', '\t\t\treq.recipient_address = payable(msg.sender);\n', '\t\tif (req.reward < 0)\n', '\t\t\trequire(req.recipient_address == payable(msg.sender), "the sender disallowed third-party claiming by setting a negative reward");\n', '\t\tstring memory claim_id = getClaimId(req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.data);\n', '\t\trequire(claim_nums[claim_id] == 0, "this transfer has already been claimed");\n', '\t\tbool is_large = (settings.large_threshold > 0 && req.stake >= settings.large_threshold);\n', '\t\tuint32 expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, 0, is_large)); // might wrap\n', '\t\tclaim_nums[claim_id] = claim_num;\n', '\t//\tuint challenging_target = req.stake * settings.counterstake_coef100/100;\n', '\t\tclaims[claim_num] = Claim({\n', '\t\t\tamount: req.amount,\n', '\t\t//\treward: req.reward,\n', '\t\t\trecipient_address: req.recipient_address,\n', '\t\t\tclaimant_address: payable(msg.sender),\n', '\t\t\tsender_address: req.sender_address,\n', '\t\t//\ttxid: req.txid,\n', '\t\t\tdata: req.data,\n', '\t\t\tyes_stake: req.stake,\n', '\t\t\tno_stake: 0,\n', '\t\t\tcurrent_outcome: Side.yes,\n', '\t\t\tis_large: is_large,\n', '\t\t\tperiod_number: 0,\n', '\t\t\ttxts: req.txts,\n', '\t\t\tts: uint32(block.timestamp),\n', '\t\t\texpiry_ts: expiry_ts,\n', '\t\t//\tchallenging_target: req.stake * settings.counterstake_coef100/100,\n', '\t\t\twithdrawn: false,\n', '\t\t\tfinished: false\n', '\t\t});\n', '\t\tstakes[claim_num][Side.yes][msg.sender] = req.stake;\n', '\t\temit NewClaim(claim_num, msg.sender, req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.stake, req.data, expiry_ts);\n', '\t//\treturn claim_id;\n', '\t}\n', '\n', '\n', '\tfunction challenge(\n', '\t\tSettings storage settings, \n', '\t\tClaim storage c,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \n', '\t\tuint claim_num, \n', '\t\tSide stake_on, \n', '\t\tuint stake\n', '\t) external {\n', '\t\trequire(block.timestamp < c.expiry_ts, "the challenging period has expired");\n', '\t\trequire(stake_on != c.current_outcome, "this outcome is already current");\n', '\t\tuint excess;\n', '\t\tuint challenging_target = (c.current_outcome == Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100;\n', '\t\t{ // circumvent stack too deep\n', '\t\t\tuint stake_on_proposed_outcome = (stake_on == Side.yes ? c.yes_stake : c.no_stake) + stake;\n', '\t\t\tbool would_override_current_outcome = stake_on_proposed_outcome >= challenging_target;\n', '\t\t\texcess = would_override_current_outcome ? stake_on_proposed_outcome - challenging_target : 0;\n', '\t\t\tuint accepted_stake = stake - excess;\n', '\t\t\tif (stake_on == Side.yes)\n', '\t\t\t\tc.yes_stake += accepted_stake;\n', '\t\t\telse\n', '\t\t\t\tc.no_stake += accepted_stake;\n', '\t\t\tif (would_override_current_outcome){\n', '\t\t\t\tc.period_number++;\n', '\t\t\t\tc.current_outcome = stake_on;\n', '\t\t\t\tc.expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, c.period_number, c.is_large));\n', '\t\t\t\tchallenging_target = challenging_target * settings.counterstake_coef100/100;\n', '\t\t\t}\n', '\t\t\tstakes[claim_num][stake_on][msg.sender] += accepted_stake;\n', '\t\t}\n', '\t\temit NewChallenge(claim_num, msg.sender, stake, stake_on, c.current_outcome, c.yes_stake, c.no_stake, c.expiry_ts, challenging_target);\n', '\t\tif (excess > 0){\n', '\t\t\tif (settings.tokenAddress == address(0))\n', '\t\t\t\tpayable(msg.sender).transfer(excess);\n', '\t\t\telse\n', '\t\t\t\trequire(IERC20(settings.tokenAddress).transfer(msg.sender, excess), "failed to transfer the token");\n', '\t\t}\n', '\t}\n', '\n', '\n', '\n', '\tfunction finish(\n', '\t\tClaim storage c,\n', '\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \n', '\t\tuint claim_num, \n', '\t\taddress payable to_address\n', '\t) external \n', '\treturns (bool, bool, uint)\n', '\t{\n', '\t\trequire(block.timestamp > c.expiry_ts, "challenging period is still ongoing");\n', '\t\tif (to_address == address(0))\n', '\t\t\tto_address = payable(msg.sender);\n', '\t\t\n', '\t\tbool is_winning_claimant = (to_address == c.claimant_address && c.current_outcome == Side.yes);\n', '\t\trequire(!(is_winning_claimant && c.withdrawn), "already withdrawn");\n', '\t\tuint won_stake;\n', '\t\t{ // circumvent stack too deep\n', '\t\t\tuint my_stake = stakes[claim_num][c.current_outcome][to_address];\n', '\t\t\trequire(my_stake > 0 || is_winning_claimant, "you are not the recipient and you didn\'t stake on the winning outcome or you have already withdrawn");\n', '\t\t\tuint winning_stake = c.current_outcome == Side.yes ? c.yes_stake : c.no_stake;\n', '\t\t\tif (my_stake > 0)\n', '\t\t\t\twon_stake = (c.yes_stake + c.no_stake) * my_stake / winning_stake;\n', '\t\t}\n', '\t\tif (is_winning_claimant)\n', '\t\t\tc.withdrawn = true;\n', '\t\tbool finished;\n', '\t\tif (!c.finished){\n', '\t\t\tfinished = true;\n', '\t\t\tc.finished = true;\n', '\t\t//\tSide losing_outcome = outcome == Side.yes ? Side.no : Side.yes;\n', "\t\t//\tdelete stakes[claim_id][losing_outcome]; // can't purge the stakes that will never be claimed\n", '\t\t\temit FinishedClaim(claim_num, c.current_outcome);\n', '\t\t}\n', '\t\tdelete stakes[claim_num][c.current_outcome][to_address];\n', '\t\treturn (finished, is_winning_claimant, won_stake);\n', '\t}\n', '\n', '\n', '\n', '\tfunction getChallengingPeriod(Settings storage settings, uint16 period_number, bool bLarge) public view returns (uint) {\n', '\t\tuint[] storage periods = bLarge ? settings.large_challenging_periods : settings.challenging_periods;\n', '\t\tif (period_number > periods.length - 1)\n', '\t\t\tperiod_number = uint16(periods.length - 1);\n', '\t\treturn periods[period_number];\n', '\t}\n', '\n', '\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\n', '\t\trequire(periods.length > 0, "empty periods");\n', '\t\tuint prev_period = 0;\n', '\t\tfor (uint i = 0; i < periods.length; i++) {\n', '\t\t\trequire(periods[i] < 3 * 365 days, "some periods are longer than 3 years");\n', '\t\t\trequire(periods[i] >= prev_period, "subsequent periods cannot get shorter");\n', '\t\t\tprev_period = periods[i];\n', '\t\t}\n', '\t}\n', '\n', '\tfunction getClaimId(string memory sender_address, address recipient_address, string memory txid, uint32 txts, uint amount, int reward, string memory data) public pure returns (string memory){\n', "\t\treturn string(abi.encodePacked(sender_address, '_', toAsciiString(recipient_address), '_', txid, '_', uint2str(txts), '_', uint2str(amount), '_', int2str(reward), '_', data));\n", '\t}\n', '\n', '\n', '\tfunction uint2str(uint256 _i) private pure returns (string memory) {\n', '\t\tif (_i == 0)\n', '\t\t\treturn "0";\n', '\t\tuint256 j = _i;\n', '\t\tuint256 length;\n', '\t\twhile (j != 0) {\n', '\t\t\tlength++;\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\tbytes memory bstr = new bytes(length);\n', '\t\tuint256 k = length;\n', '\t\tj = _i;\n', '\t\twhile (j != 0) {\n', '\t\t\tbstr[--k] = bytes1(uint8(48 + j % 10));\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\treturn string(bstr);\n', '\t}\n', '\n', '\tfunction int2str(int256 _i) private pure returns (string memory) {\n', '\t\trequire(_i < type(int).max, "int too large");\n', "\t\treturn _i >= 0 ? uint2str(uint(_i)) : string(abi.encodePacked('-', uint2str(uint(-_i))));\n", '\t}\n', '\n', '\tfunction toAsciiString(address x) private pure returns (string memory) {\n', '\t\tbytes memory s = new bytes(40);\n', '\t\tfor (uint i = 0; i < 20; i++) {\n', '\t\t\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\n', '\t\t\tbytes1 hi = bytes1(uint8(b) / 16);\n', '\t\t\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n', '\t\t\ts[2*i] = char(hi);\n', '\t\t\ts[2*i+1] = char(lo);            \n', '\t\t}\n', '\t\treturn string(s);\n', '\t}\n', '\n', '\tfunction char(bytes1 b) private pure returns (bytes1 c) {\n', '\t\tif (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n', '\t\telse return bytes1(uint8(b) + 0x57);\n', '\t}\n', '\n', '\tfunction isContract(address _addr) public view returns (bool){\n', '\t\tuint32 size;\n', '\t\tassembly {\n', '\t\t\tsize := extcodesize(_addr)\n', '\t\t}\n', '\t\treturn (size > 0);\n', '\t}\n', '}']