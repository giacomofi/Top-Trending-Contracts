['pragma solidity ^0.6.6;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./ACOAssetHelper.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IACOPool2.sol";\n', 'import "./IACOFactory.sol";\n', 'import "./IChiToken.sol";\n', '\n', 'contract ACOBuyer {\n', '    \n', '    IACOFactory immutable public acoFactory;\n', '\tIChiToken immutable public chiToken;\n', '\n', '    bool internal _notEntered;\n', '\n', '    modifier nonReentrant() {\n', '        require(_notEntered, "ACOBuyer::Reentry");\n', '        _notEntered = false;\n', '        _;\n', '        _notEntered = true;\n', '    }\n', '    \n', '    modifier discountCHI {\n', '        uint256 gasStart = gasleft();\n', '        _;\n', '        uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n', '        chiToken.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41947);\n', '    }\n', '    \n', '    constructor(address _acoFactory, address _chiToken) public {\n', '        acoFactory = IACOFactory(_acoFactory);\n', '\t    chiToken = IChiToken(_chiToken);\n', '        _notEntered = true;\n', '    }\n', '\n', '    receive() external payable {\n', '        require(tx.origin != msg.sender, "ACOBuyer:: Not allowed");\n', '    }\n', '\n', '    function buy(\n', '        address acoToken, \n', '        address to,\n', '        uint256 deadline,\n', '        address[] calldata acoPools,\n', '        uint256[] calldata amounts,\n', '        uint256[] calldata restrictions\n', '    ) \n', '        nonReentrant \n', '        external \n', '        payable\n', '    {\n', '        _buy(acoToken, to, deadline, acoPools, amounts, restrictions);\n', '    }\n', '    \n', '    function buyWithGasToken(\n', '        address acoToken, \n', '        address to,\n', '        uint256 deadline,\n', '        address[] calldata acoPools,\n', '        uint256[] calldata amounts,\n', '        uint256[] calldata restrictions\n', '    ) \n', '        discountCHI\n', '        nonReentrant \n', '        external \n', '        payable\n', '    {\n', '        _buy(acoToken, to, deadline, acoPools, amounts, restrictions);\n', '    }\n', '    \n', '    function _buy(\n', '        address acoToken, \n', '        address to,\n', '        uint256 deadline,\n', '        address[] memory acoPools,\n', '        uint256[] memory acoAmounts,\n', '        uint256[] memory restrictions\n', '    ) internal {\n', '        require(acoToken != address(0), "ACOBuyer::buy: Invalid ACO token");\n', '        require(acoPools.length > 0, "ACOBuyer::buy: Invalid pools");\n', '        require(acoPools.length == acoAmounts.length && acoPools.length == restrictions.length, "ACOBuyer::buy: Invalid arguments");\n', '        \n', '        (,address strikeAsset,,,) = acoFactory.acoTokenData(acoToken);\n', '        \n', '        uint256 amount = _getAssetAmount(acoAmounts, restrictions);\n', '        (uint256 previousBalance, uint256 extraAmount) = _receiveAsset(strikeAsset, amount);\n', '        \n', '        _poolSwap(strikeAsset, acoToken, to, deadline, acoPools, acoAmounts, restrictions);\n', '        \n', '        uint256 afterBalance = ACOAssetHelper._getAssetBalanceOf(strikeAsset, address(this));\n', '        uint256 remaining = SafeMath.add(extraAmount, SafeMath.sub(afterBalance, previousBalance));\n', '        if (remaining > 0) {\n', '            ACOAssetHelper._transferAsset(strikeAsset, msg.sender, remaining);\n', '        }\n', '    }\n', '\n', '    function _getAssetAmount(uint256[] memory acoAmounts, uint256[] memory restrictions) internal pure returns(uint256 amount) {\n', '        amount = 0;\n', '        for (uint256 i = 0; i < acoAmounts.length; ++i) {\n', '            require(acoAmounts[i] > 0, "ACOBuyer::buy: Invalid amount");\n', '            require(restrictions[i] > 0, "ACOBuyer::buy: Invalid restriction");\n', '            amount = SafeMath.add(amount, restrictions[i]);\n', '        }\n', '    }\n', '\n', '    function _receiveAsset(address strikeAsset, uint256 amount) internal returns(uint256 previousBalance, uint256 extraAmount) {\n', '        previousBalance = ACOAssetHelper._getAssetBalanceOf(strikeAsset, address(this));\n', '\n', '        extraAmount = 0;\n', '        if (ACOAssetHelper._isEther(strikeAsset)) {\n', '            require(msg.value >= amount, "ACOBuyer::buy:Invalid ETH amount");\n', '            previousBalance = SafeMath.sub(previousBalance, msg.value);\n', '            extraAmount = SafeMath.sub(msg.value, amount);\n', '        } else {\n', '            require(msg.value == 0, "ACOBuyer::buy:No payable");\n', '            ACOAssetHelper._callTransferFromERC20(strikeAsset, msg.sender, address(this), amount);\n', '        }\n', '    } \n', '\n', '    function _poolSwap(\n', '        address strikeAsset, \n', '        address acoToken, \n', '        address to,\n', '        uint256 deadline,\n', '        address[] memory acoPools,\n', '        uint256[] memory acoAmounts,\n', '        uint256[] memory restrictions\n', '    ) internal {\n', '        for (uint256 i = 0; i < acoPools.length; ++i) {\n', '            uint256 etherAmount = 0; \n', '            if (ACOAssetHelper._isEther(strikeAsset)) {\n', '                etherAmount = restrictions[i];\n', '            } else {\n', '                ACOAssetHelper._setAssetInfinityApprove(strikeAsset, address(this), acoPools[i], restrictions[i]);\n', '            }\n', '            IACOPool2(acoPools[i]).swap{value: etherAmount}(acoToken, acoAmounts[i], restrictions[i], to, deadline);\n', '        }\n', '    }\n', '}']