['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-10\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright (c) 2021 Varia LLC\n', '/// Wet Code by Erich Dylus & Sarah Brennan\n', '/// Dry Code by LexDAO LLC\n', 'pragma solidity 0.8.6;\n', '\n', '/// @notice This contract manages function access control, adapted from @boringcrypto (https://github.com/boringcrypto/BoringSolidity).\n', 'contract Ownable {\n', '    address public owner; \n', '    address public pendingOwner;\n', '    \n', '    event TransferOwnership(address indexed from, address indexed to); \n', '    event TransferOwnershipClaim(address indexed from, address indexed to);\n', '    \n', '    /// @notice Initialize contract.\n', '    constructor() {\n', '        owner = msg.sender;\n', '        emit TransferOwnership(address(0), msg.sender);\n', '    }\n', '    \n', '    /// @notice Access control modifier that requires modified function to be called by `owner` account.\n', '    modifier onlyOwner {\n', "        require(msg.sender == owner, 'Ownable:!owner');\n", '        _;\n', '    } \n', '    \n', '    /// @notice The `pendingOwner` can claim `owner` account.\n', '    function claimOwner() external {\n', "        require(msg.sender == pendingOwner, 'Ownable:!pendingOwner');\n", '        emit TransferOwnership(owner, msg.sender);\n', '        owner = msg.sender;\n', '        pendingOwner = address(0);\n', '    }\n', '    \n', '    /// @notice Transfer `owner` account.\n', '    /// @param to Account granted `owner` access control.\n', "    /// @param direct If 'true', ownership is directly transferred. \n", '    function transferOwnership(address to, bool direct) external onlyOwner {\n', '        if (direct) {\n', '            owner = to;\n', '            emit TransferOwnership(msg.sender, to);\n', '        } else {\n', '            pendingOwner = to;\n', '            emit TransferOwnershipClaim(msg.sender, to);\n', '        }\n', '    }\n', '}\n', '\n', '/// @notice This contract allows potential delegates of DAO voting power to ethSign disclosures.\n', 'contract VoteDelegateDisclosure is Ownable {\n', '    uint8 public version; // counter for ricardian template versions\n', '    uint256 public signatures; // counter for ricardian signatures - registration `id`\n', '    string public template; // string stored for ricardian template signature - amendable by `owner`\n', '    \n', '    mapping(address => uint256) public registrations; // maps signatures to registration `id` (revocation, composability, etc.)\n', '    \n', '    event Amend(string template);\n', '    event Sign(uint256 indexed id, string details);\n', '    event Revoke(uint256 indexed id, string details);\n', '    \n', '    constructor(string memory _template) {\n', '        template = _template; // initialize ricardian template\n', '    }\n', '    \n', '    function amend(string calldata _template) external onlyOwner {\n', '        version++; // increment ricardian template version\n', '        template = _template; // replace ricardian template string stored in this contract\n', '        emit Amend(_template); // emit amendment details in event for apps\n', '    }\n', '\n', '    function sign(string calldata details) external returns (uint256 id) {\n', '        signatures++; // increment `signatures` count for registration id\n', '        id = signatures; // gas-optimize stored variable with alias\n', '        registrations[msg.sender] = id; // assign registration id to caller signatory\n', '        emit Sign(id, details); // emit signature details in event for apps\n', '    }\n', '    \n', '    function revoke(uint256 id, string calldata details) external {\n', "        require(registrations[msg.sender] == id, '!signatory'); // confirm caller is `id` signatory\n", '        registrations[msg.sender] = 0; // nullify registration id\n', '        emit Revoke(id, details); // emit revocation details in event for apps\n', '    }\n', '}']