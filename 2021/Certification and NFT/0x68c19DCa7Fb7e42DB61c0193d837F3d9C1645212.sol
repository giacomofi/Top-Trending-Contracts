['"""\n', '@title Greenwood CompoundEscrow\n', '@notice Compound integrations for the Greenwood Protocol\n', '@author Greenwood Labs\n', '"""\n', '\n', '# define the interfaces used by the contract\n', 'from vyper.interfaces import ERC20\n', '\n', 'interface COMPOUND_CALCULATOR:\n', '    def calculateBorrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _collateralization_ratio: uint256, _version: String[11]) -> CompoundBorrowCalculation: nonpayable\n', '    def calculateWithdraw(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _loan: Loan, _version: String[11]) -> CompoundWithdrawCalculation: nonpayable\n', '    def calculateRepay(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _loan: Loan, _version: String[11]) -> CompoundRepayCalculation: nonpayable\n', '\n', 'interface CTOKEN:\n', '    def mint(_mint_amount: uint256) -> uint256: nonpayable\n', '    def borrow(_borrow_amount: uint256) -> uint256: nonpayable\n', '    def repayBorrow(_repay_amount: uint256) -> uint256: nonpayable\n', '    def borrowIndex() -> uint256: nonpayable\n', '    def redeemUnderlying(_redeem_amount: uint256) -> uint256: nonpayable\n', '    def exchangeRateStored() -> uint256: nonpayable\n', '    def borrowRatePerBlock() -> uint256: nonpayable\n', '    def borrowBalanceCurrent(_account: address) -> uint256: nonpayable\n', '    def accrualBlockNumber() -> uint256: nonpayable\n', '\n', 'interface REGISTRY:\n', '    def getAddress(_contract: String[20], _version: String[11]) -> address: nonpayable\n', '    def governance() -> address: nonpayable\n', '\n', 'interface STORE:\n', '    def getAssetContext(_ticker: String[10]) -> AssetContext: view\n', '    def recordLoan(_borrower: address, _borrow_asset: address, _collateral_asset: address, _collateralization_ratio: uint256, _collateral_locked: uint256, _index: uint256, _principal: uint256, _protocol: String[10], _version: String[11]): nonpayable\n', '    def updateLoan(_collateral_locked: uint256, _index: uint256, _loan_key: bytes32, _outstanding: uint256, _version: String[11]): nonpayable\n', '    def getLoan(_loan_key: bytes32) -> Loan: view\n', '    def getLoanProtocol(_loan_key: bytes32) -> String[10]: view\n', '\n', '# define the events emitted by the contract\n', 'event AddCollateral:\n', '    loanKey: bytes32\n', '    depositor: address\n', '    amount: uint256\n', '    collateralAsset: address\n', '    blockNumber: uint256\n', '\n', 'event Borrow:\n', '    borrower: address\n', '    amount: uint256\n', '    borrowAsset: address\n', '    collateralAsset: address\n', '    blockNumber: uint256\n', '\n', 'event Fallback:\n', '    value: uint256\n', '    sender: address\n', '    blockNumber: uint256\n', '\n', 'event Liquidate:\n', '    loanKey: bytes32\n', '    outstanding: uint256\n', '    borrowAsset: address\n', '    collateralAsset: address\n', '    blockNumber: uint256\n', '\n', 'event Liquidation:\n', '    borrowAsset: address\n', '    collateralAsset: address\n', '    liquidator: address\n', '    loanKeys: bytes32[100]\n', '    redemptionAmount: uint256\n', '    repayAmount: uint256\n', '    blockNumber: uint256\n', '\n', 'event Repay:\n', '    borrower: address\n', '    repaymentAmount: uint256\n', '    repaymentAsset: address\n', '    redemptionAmount: uint256\n', '    redemptionAsset: address\n', '    blockNumber: uint256\n', '\n', 'event SetRegistry:\n', '    previousRegistry: address\n', '    newRegistry: address\n', '    governance: address\n', '    blockNumber: uint256\n', '\n', 'event WithdrawCollateral:\n', '    loanKey: bytes32\n', '    amount: uint256\n', '    collateralAsset: address\n', '    collateralLocked: uint256\n', '    blockNumber: uint256\n', '\n', '# define the constants used by the contract\n', 'LOOP_LIMIT: constant(uint256) = 100\n', '\n', '# define the structs used by the contract\n', 'struct AssetContext:\n', '    aToken: address\n', '    aaveV2PriceFeed: address\n', '    aaveV2LendingPool: address\n', '    cToken: address\n', '    compoundPriceFeed: address\n', '    comptroller: address\n', '    decimals: uint256\n', '    underlying: address\n', '\n', 'struct CompoundBorrowCalculation:\n', '    requiredCollateral: uint256\n', '    borrowAmount: uint256\n', '    originationFee: uint256\n', '\n', 'struct CompoundRepayCalculation:\n', '    repayAmount: uint256\n', '    redemptionAmount: int128\n', '    requiredCollateral: uint256\n', '    outstanding: int128\n', '\n', 'struct CompoundWithdrawCalculation:\n', '    requiredCollateral: uint256\n', '    outstanding: uint256\n', '\n', 'struct Loan:\n', '    collateralAsset: address\n', '    borrowAsset: address\n', '    outstanding: uint256\n', '    collateralizationRatio: uint256\n', '    collateralLocked: uint256\n', '    borrower: address\n', '    lastBorrowIndex: uint256\n', '    repaymentTime: uint256\n', '\n', '# define the storage variables used by the contract\n', 'registry: public(address)\n', '\n', '@external\n', 'def __init__(_registry: address):\n', '    """\n', '    @notice Contract constructor\n', '    @param _registry The address of the Greenwood Registry\n', '    """\n', '\n', '    # set the address of the Escrow\n', '    self.registry = _registry\n', '\n', '@internal\n', 'def isAuthorized(_caller: address, _role: String[20], _version: String[11]) -> bool:\n', '    """\n', '    @notice Method for role-based security\n', '    @param _caller The address that called the permissioned method\n', '    @param _role The requested authorization level\n', '    @param _version The version of Greenwood to use\n', '    @return True if the caller is authorized, False otherwise\n', '    """\n', '\n', '    # check if the requested role is "controller"\n', '    if keccak256(_role) == keccak256("controller"):\n', '\n', '        # get the address of the Controller from the Registry\n', '        escrow: address = REGISTRY(self.registry).getAddress("controller", _version)\n', '\n', '        # return the equality comparison\n', '        return escrow == _caller\n', '    \n', '    # check if the requested role is "governance"\n', '    elif keccak256(_role) == keccak256("governance"):\n', '\n', '        # get the address of the Governance from the Registry\n', '        governance: address = REGISTRY(self.registry).governance()\n', '\n', '        # return the equality comparison\n', '        return governance == _caller\n', '\n', '    # check if the requested role is "liquidator"\n', '    elif keccak256(_role) == keccak256("liquidator"):\n', '\n', '        # get the address of the Liquidator from the Registry\n', '        liquidator: address = REGISTRY(self.registry).getAddress("liquidator", _version)\n', '\n', '        # return the equality comparison\n', '        return liquidator == _caller\n', '\n', '    # catch extraneous role arguments\n', '    else:\n', '\n', '        # revert\n', '        raise "Unhandled role argument"\n', '\n', '@internal\n', 'def handleEnterMarketsResponse(_byte_arr: Bytes[96]) -> uint256:\n', '  """\n', '  @notice Converts 96 byte array to a uint256\n', '  @param _byte_arr Byte array of length 96\n', '  @return uint256\n', '  @dev This assumes it is the output from a raw_call that takes form of offset + length + response\n', '  """\n', '\n', '  # assumes output is coming from an uint[], therefore start at byte 64\n', '  # because first two sets of 32 are offset & length\n', '  start: int128 = 32 * 2\n', '\n', '  # extract32 bytes of data\n', '  extracted: bytes32 = extract32(_byte_arr, start, output_type=bytes32)\n', '\n', '  # return converted 32 bytes to uint256\n', '  return convert(extracted, uint256)\n', '\n', '@external\n', '@payable\n', 'def borrow(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_context: AssetContext, _collateral_context: AssetContext, _amount: uint256, _borrower: address, _calculator: address, _collateralization_ratio: uint256, _store: address, _version: String[11]):\n', '    """\n', '    @notice Borrow assets from Compound\n', '    @param _borrow_ticker The ticker string of the asset being borrowed\n', '    @param _collateral_ticker The ticker string of the asset being used as collateral\n', '    @param _borrow_context The AssetContext struct of the asset being borrowed\n', '    @param _collateral_context The AssetContext struct of the asset being used as collateral\n', "    @param _amount The amount of asset being borrowed scaled by the asset's decimals\n", '    @param _borrower The address of the borrower\n', '    @param _calculator The address of the Grenwood Calculator to use\n', '    @param _collateralization_ratio The collateralization ratio for the loan as a percentage\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True\n', '\n', '    # require that the borrow amount is greater than 0 after scaling it down\n', '    assert convert(_amount, decimal) / convert(10 ** _borrow_context.decimals, decimal) > 0.0\n', '\n', '    # get required collateral, borrow index, borrow amount, and the origination fee from the Calculator\n', '    borrowCalculations: CompoundBorrowCalculation = COMPOUND_CALCULATOR(_calculator).calculateBorrow(_borrow_ticker, _collateral_ticker, _borrow_context, _collateral_context, _amount, _collateralization_ratio, _version)\n', '\n', '    # check if the collateral asset is ETH\n', '    if keccak256(_collateral_ticker) == keccak256("ETH"):\n', '\n', '        # check if the origination fee is greater than 0\n', '        if borrowCalculations.originationFee > 0:\n', '\n', '            # get the address of the Treasury from the Registry\n', '            treasury: address = REGISTRY(self.registry).getAddress("treasury", _version)\n', '\n', '            # require that a Treasury address was returned from the Store\n', '            assert treasury != ZERO_ADDRESS\n', '\n', '            # send the origination fee to the Treasury\n', '            send(treasury, borrowCalculations.originationFee)\n', '\n', '        # call mint() on the cEther contract and send msg.value, less the origination fee, in wei\n', '        raw_call(\n', '            _collateral_context.cToken,\n', '            method_id("mint()"),\n', '            value = msg.value - borrowCalculations.originationFee\n', '        )\n', '\n', '    else:\n', '\n', '        # check if the origination fee is greater than 0\n', '        if borrowCalculations.originationFee > 0:\n', '\n', '            # get the address of the Treasury from the Registry\n', '            treasury: address = REGISTRY(self.registry).getAddress("treasury", _version)\n', '\n', '            # require that a Treasury address was returned from the Store\n', '            assert treasury != ZERO_ADDRESS\n', '\n', '            # transfer the origination fee to the Treasury\n', '            transferResponse: Bytes[32] = raw_call(\n', '                _collateral_context.underlying,\n', '                concat(\n', '                    method_id("transferFrom(address,address,uint256)"),\n', '                    convert(_borrower, bytes32),\n', '                    convert(treasury, bytes32),\n', '                    convert(borrowCalculations.originationFee, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )\n', '            if len(transferResponse) > 0:\n', '                assert convert(transferResponse, bool)\n', '\n', '        # move collateral from the borrower to Escrow \n', '        transferFromResponse: Bytes[32] = raw_call(\n', '            _collateral_context.underlying,\n', '            concat(\n', '                method_id("transferFrom(address,address,uint256)"),\n', '                convert(_borrower, bytes32),\n', '                convert(self, bytes32),\n', '                convert(borrowCalculations.requiredCollateral, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        ) \n', '        if len(transferFromResponse) > 0:\n', '            assert convert(transferFromResponse, bool)\n', '\n', '        # approve the collateral transfer from Escrow to Compound\n', '        approveResponse: Bytes[32] = raw_call(\n', '            _collateral_context.underlying,\n', '            concat(\n', '                method_id("approve(address,uint256)"),\n', '                convert(_collateral_context.cToken, bytes32),\n', '                convert(borrowCalculations.requiredCollateral, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(approveResponse) > 0:\n', '            assert convert(approveResponse, bool)\n', '\n', '        # require that the cTokens were minted successfully\n', '        assert CTOKEN(_collateral_context.cToken).mint(borrowCalculations.requiredCollateral) == 0\n', '\n', '    # allow for the usage of the collateral asset as collateral in Compound\n', '    enterMarketsResponse: Bytes[96] = raw_call(\n', '        _collateral_context.comptroller,                                # compound comptroller address\n', '        concat(\n', '            method_id("enterMarkets(address[])", output_type=Bytes[4]), # enterMarkets() method signature (4 bytes)\n', '            convert(32, bytes32),                                       # offset (32 bytes)\n', '            convert(1, bytes32),                                        # arrayLength (32 bytes)\n', '            convert(_collateral_context.cToken, bytes32)                # addressArray (32 * 1 bytes)\n', '        ),\n', '        max_outsize=96,                                                 # outsize = offset + arrayLength + addressArray\n', '    )\n', '\n', '    # require that the market was entered successfully\n', '    assert self.handleEnterMarketsResponse(enterMarketsResponse) == 0\n', '\n', '    # require that the Compound borrow was successful\n', '    assert CTOKEN(_borrow_context.cToken).borrow(_amount) == 0\n', '\n', '    # get the current borrow index from the cToken\n', '    borrowIndex: uint256 = CTOKEN(_borrow_context.cToken).borrowIndex()\n', '\n', '    # check if the borrow asset is ETH\n', '    if keccak256(_borrow_ticker) == keccak256("ETH"):\n', '\n', '        # transfer ETH to the borrower\n', '        send(_borrower, _amount)\n', '\n', '    else:\n', '\n', '        # transfer the borrow asset to the borrower\n', '        transferResponse: Bytes[32] = raw_call(\n', '            _borrow_context.underlying,\n', '            concat(\n', '                method_id("transfer(address,uint256)"),\n', '                convert(_borrower, bytes32),\n', '                convert(_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(transferResponse) > 0:\n', '            assert convert(transferResponse, bool)\n', '\n', '    # pass loan data to the Store for storage\n', '    STORE(_store).recordLoan(_borrower, _borrow_context.underlying, _collateral_context.underlying, _collateralization_ratio, borrowCalculations.requiredCollateral, borrowIndex, _amount, "compound", _version)\n', '\n', '    # emit a Borrow event\n', '    log Borrow(_borrower, _amount, _borrow_context.underlying, _collateral_context.underlying, block.number)\n', '\n', '@external\n', '@payable\n', 'def repay(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32, _store: address, _version: String[11]):\n', '    """\n', '    @notice Repay a Compound loan\n', '    @param _borrow_ticker The ticker string of the asset that was borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of the repayment scaled by the asset's decimals\n", '    @param _calculator The address of the Greenwood Calculator to use\n', '    @param _loan_key The uinque identifier for the loan\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the controller or the governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True\n', '\n', '    # get the loan protocol from the Store\n', '    loanProtocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\n', '\n', '    # get the rest of the loan data from the Store\n', '    loan: Loan = STORE(_store).getLoan(_loan_key)\n', '\n', '    # require that the outstanding balance of the loan is greater than\n', '    assert loan.outstanding > 0\n', '\n', '    # get the asset contexts for the borrow asset and the collateral asset from the Store\n', '    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '\n', '    # require the the loan assets match the underlying assets of the contexts\n', '    assert borrowContext.underlying == loan.borrowAsset\n', '    assert collateralContext.underlying == loan.collateralAsset\n', '\n', '    # check if this is a full repayment\n', '    if _amount != MAX_UINT256:\n', '\n', '        # require that the repay amount is greater than 0 after scaling it down\n', '        assert convert(_amount, decimal) / convert(10 ** borrowContext.decimals, decimal) > 0.0\n', '        \n', '    # check that this loan was originated with Aave V2\n', '    if keccak256(loanProtocol) == keccak256("compound"):\n', '\n', '        # get the redemption amount from the Calculator\n', '        repayCalculations: CompoundRepayCalculation = COMPOUND_CALCULATOR(_calculator).calculateRepay(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext, _amount, loan, _version)\n', '\n', '        # check if the borrow asset is ETH\n', '        if keccak256(_borrow_ticker) == keccak256("ETH"):\n', '\n', '            # call repayBorrow() on the cEther contract and send msg.value in wei\n', '            raw_call(\n', '                borrowContext.cToken,\n', '                method_id("repayBorrow()"),\n', '                value=msg.value\n', '            )\n', '\n', '        else:\n', '            # move repayment asset (borrow asset) from borrower to Greenwood\n', '            transferFromResponse: Bytes[32] = raw_call(\n', '                borrowContext.underlying,\n', '                concat(\n', '                    method_id("transferFrom(address,address,uint256)"),\n', '                    convert(loan.borrower, bytes32),\n', '                    convert(self, bytes32),\n', '                    convert(repayCalculations.repayAmount, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            ) \n', '            if len(transferFromResponse) > 0:\n', '                assert convert(transferFromResponse, bool)\n', '\n', '            # approve the cToken of the borrow asset to access the token balance of Escrow\n', '            approveResponse: Bytes[32] = raw_call(\n', '                borrowContext.underlying,\n', '                concat(\n', '                    method_id("approve(address,uint256)"),\n', '                    convert(borrowContext.cToken, bytes32),\n', '                    convert(repayCalculations.repayAmount, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )\n', '            if len(approveResponse) > 0:\n', '                assert convert(approveResponse, bool)\n', '\n', '            # require that the repayment was successful\n', '            assert CTOKEN(borrowContext.cToken).repayBorrow(repayCalculations.repayAmount) == 0\n', '            \n', '        # if redemption amount is positive, redeem redemptionAmount of the collateral cToken for the underlying,\n', '        if repayCalculations.redemptionAmount < 0:\n', '\n', '            # emit a Liquidate event\n', '            log Liquidate(_loan_key, loan.outstanding, borrowContext.underlying, collateralContext.underlying, block.number)\n', '\n', '        elif repayCalculations.redemptionAmount > 0:\n', '\n', '            # get the current borrowIndex from the cToken\n', '            borrowIndex: uint256 = CTOKEN(borrowContext.cToken).borrowIndex()\n', '\n', '            # require that the redemption was successful\n', '            assert CTOKEN(collateralContext.cToken).redeemUnderlying(convert(repayCalculations.redemptionAmount, uint256)) == 0\n', '\n', '            # check if the collateral asset is ETH\n', '            if keccak256(_collateral_ticker) == keccak256("ETH"):\n', '\n', '                # send the redeemed ETH back to the borrower\n', '                send(loan.borrower, convert(repayCalculations.redemptionAmount, uint256))\n', '\n', '            else:\n', '            \n', '                # transfer the redeemed collateral asset back to the borrower\n', '                transferResponse: Bytes[32] = raw_call(\n', '                    collateralContext.underlying,\n', '                    concat(\n', '                        method_id("transfer(address,uint256)"),\n', '                        convert(loan.borrower, bytes32),\n', '                        convert(convert(repayCalculations.redemptionAmount, uint256), bytes32),\n', '                    ),\n', '                    max_outsize=32,\n', '                )\n', '                if len(transferResponse) > 0:\n', '                    assert convert(transferResponse, bool)\n', '\n', '            # update the loan with outstanding balance and collateral needed\n', '            STORE(_store).updateLoan(repayCalculations.requiredCollateral, borrowIndex, _loan_key, convert(repayCalculations.outstanding, uint256), _version)\n', '            \n', '            # emit a Repay event\n', '            log Repay(loan.borrower, repayCalculations.repayAmount, borrowContext.underlying, convert(repayCalculations.redemptionAmount, uint256), collateralContext.underlying, block.number)\n', '\n', '        elif repayCalculations.redemptionAmount == 0:\n', '\n', '            # emit a Repay event\n', '            log Repay(loan.borrower, repayCalculations.repayAmount, borrowContext.underlying, convert(repayCalculations.redemptionAmount, uint256), collateralContext.underlying, block.number)\n', '\n', '\n', '@external\n', '@payable\n', 'def addCollateral(_collateral_ticker: String[10], _amount: uint256, _depositor: address, _loan_key: bytes32, _store: address, _version: String[11]):\n', '    """\n', '    @notice Add collateral to Compound\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount of the deposit scaled by the asset's decimals\n", '    @param _depositor The address of the depositor\n', '    @param _loan_key The uinque identifier for the loan\n', '    @param _store The address of the Greenwood Store contract to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True\n', '\n', "    # get the loan's protocol from the Store\n", '    protocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\n', '\n', '    # require that a protocol was returned from the Store\n', '    assert keccak256(protocol) != keccak256("")\n', '\n', '    # get the loan data from the Store\n', '    loan: Loan = STORE(_store).getLoan(_loan_key)\n', '\n', '    # get the context of the collateral asset from the Store\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '\n', "    # require that the loan's collateral asset and underlying asset of the collateral context match\n", '    assert loan.collateralAsset == collateralContext.underlying\n', '\n', '    # require that the deposit amount is greater than 0 adter scaling it dow# require that the deposit amount is greater than 0 after scaling it down\n', '    assert convert(_amount, decimal) / convert(10 ** collateralContext.decimals, decimal) > 0.0\n', '\n', '    # check if this loan was originated with Compound\n', '    if keccak256(protocol) == keccak256("compound"):\n', '\n', '        # check if the collateral asset is ETH\n', '        if keccak256(_collateral_ticker) == keccak256("ETH"):\n', '\n', '            # require that the _value sent matches the _amount to add\n', '            assert _amount == msg.value\n', '\n', '            # call mint() on the cEther contract and send msg.value in wei\n', '            raw_call(\n', '                collateralContext.cToken,\n', '                method_id("mint()"),\n', '                value=msg.value\n', '            )\n', '        \n', '        else:\n', '\n', '            # move collateral from user to Escrow \n', '            transferFromResponse: Bytes[32] = raw_call(\n', '                collateralContext.underlying,\n', '                concat(\n', '                    method_id("transferFrom(address,address,uint256)"),\n', '                    convert(_depositor, bytes32),\n', '                    convert(self, bytes32),\n', '                    convert(_amount, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            ) \n', '            if len(transferFromResponse) > 0:\n', '                assert convert(transferFromResponse, bool)\n', '\n', '            # approve the collateral transfer from Escrow to Compound\n', '            approveResponse: Bytes[32] = raw_call(\n', '                collateralContext.underlying,\n', '                concat(\n', '                    method_id("approve(address,uint256)"),\n', '                    convert(collateralContext.cToken, bytes32),\n', '                    convert(_amount, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )\n', '            if len(approveResponse) > 0:\n', '                assert convert(approveResponse, bool)\n', '\n', '            # require that the cToken minst was successful\n', '            assert CTOKEN(collateralContext.cToken).mint(_amount) == 0\n', '\n', '        # add the amount of collateral to the existing amount of collateralLocked\n', '        collateralLocked: uint256 = loan.collateralLocked + _amount\n', '\n', '        # pass borrowIndex of 0 so this member of the struct is not updated\n', '        borrowIndex: uint256 = 0\n', '\n', '        # update the loan with the new value of collateral locked\n', '        STORE(_store).updateLoan(collateralLocked, borrowIndex, _loan_key, loan.outstanding, _version)\n', '\n', '        # emit an AddCollateral event\n', '        log AddCollateral(_loan_key, _depositor, _amount, collateralContext.underlying, block.number)\n', '        \n', '    else:\n', '        raise "malformed protocol string"\n', '\n', '@external\n', 'def withdrawCollateral(_borrow_ticker: String[10], _collateral_ticker: String[10], _amount: uint256, _calculator: address, _loan_key: bytes32, _store: address, _version: String[11]):\n', '    """\n', '    @notice Withdraw collateral from Compound\n', '    @param _borrow_ticker The ticker string of the asset that was borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', "    @param _amount The amount to withdraw scaled by the asset's decimals\n", '    @param _calculator The address of the Greenwood Calculator to use\n', '    @param _loan_key The uinque identifier for the loan\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Controller or the Governance\n', '    assert self.isAuthorized(msg.sender, "controller", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True\n', '\n', "    # get the loan's protocol from the Store \n", '    protocol: String[10] = STORE(_store).getLoanProtocol(_loan_key)\n', '\n', '    # require that a protocol was returned from the Store\n', '    assert keccak256(protocol) != keccak256("")\n', '\n', '    # get the loan data from the Store \n', '    loan: Loan = STORE(_store).getLoan(_loan_key)\n', '\n', '    # get the asset contexts for the borrow asset and the collateral asset from the Store\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\n', '\n', '    # require the the loan assets match the underlying assets of the contexts\n', '    assert loan.borrowAsset == borrowContext.underlying\n', '    assert loan.collateralAsset == collateralContext.underlying\n', '\n', '    # require that the withdraw amount is greater than 0 after scaling it down\n', '    assert convert(_amount, decimal) / convert(10 ** collateralContext.decimals, decimal) > 0.0\n', '\n', '    # check if this loan was originated with Compound\n', '    if keccak256(protocol) == keccak256("compound"):\n', '\n', '        # get the withdraw calculations from the Calculator\n', '        withdrawCalculations: CompoundWithdrawCalculation = COMPOUND_CALCULATOR(_calculator).calculateWithdraw(_borrow_ticker, _collateral_ticker, borrowContext, collateralContext, loan, _version)\n', '\n', '        # require that this withdraw does not violate collateral requirements\n', '        assert loan.collateralLocked - _amount >= withdrawCalculations.requiredCollateral\n', '\n', '        # redeem the collateral and require that the redemption was successful\n', '        assert CTOKEN(collateralContext.cToken).redeemUnderlying(_amount) == 0\n', '\n', '        # recalculate collateral locked by subtracting the withdraw amount from collateralLocked\n', '        collateralLocked: uint256 = loan.collateralLocked - _amount\n', '\n', '        # check if the collateral asset is ETH\n', '        if keccak256(_collateral_ticker) == keccak256("ETH"):\n', '\n', '            # send the redeemed ETH back to the borrower\n', '            send(loan.borrower, _amount)\n', '\n', '        else:\n', '\n', '            # transfer the redeemed collateral asset back to the borrower\n', '            transferResponse: Bytes[32] = raw_call(\n', '                collateralContext.underlying,\n', '                concat(\n', '                    method_id("transfer(address,uint256)"),\n', '                    convert(loan.borrower, bytes32),\n', '                    convert(_amount, bytes32),\n', '                ),\n', '                max_outsize=32,\n', '            )\n', '            if len(transferResponse) > 0:\n', '                assert convert(transferResponse, bool)\n', '\n', '        # pass borrowIndex of 0 so this member of the struct is not updated\n', '        borrowIndex: uint256 = 0\n', '\n', '        # update the loan with outstanding balance and collateral needed\n', '        STORE(_store).updateLoan(collateralLocked, borrowIndex, _loan_key, withdrawCalculations.outstanding, _version)\n', '\n', '        # emit a WithdrawCollateral event\n', '        log WithdrawCollateral(_loan_key, _amount, collateralContext.underlying, collateralLocked, block.number)\n', '        \n', '    # revert, unhandled loan.protocol\n', '    else:\n', '        raise "malformed protocol string"\n', '\n', '@external\n', '@payable\n', 'def liquidate(_borrow_ticker: String[10], _collateral_ticker: String[10], _borrow_index: uint256, _key_count: uint256, _loan_keys: bytes32[100], _liquidator: address, _redeem_amount: uint256, _repay_amount: uint256, _store: address, _version: String[11]):\n', '    """\n', '    @notice Liquidate undercollateralized loans\n', '    @param _borrow_ticker The ticker string of the asset that was borrowed\n', '    @param _collateral_ticker The ticker string of the asset that is being used as collateral\n', '    @param _borrow_index The latest borrow index from the underlying lending protocol\n', '    @param _key_count The number of keys in the _loan_keys array\n', '    @param _liquidator The address of the liquidator\n', '    @param _redeem_amount The amount of collateral asset to redeem\n', '    @param _repay_amount The amount of borrowed asset to repay\n', '    @param _store The address of the Greenwood Store to use\n', '    @param _version The version of Greenwood to use\n', '    @dev Only the Controller or the Governance can call this method\n', '    """\n', '\n', '    # require that the method is being called by the Liquidator or the Governance\n', '    assert self.isAuthorized(msg.sender, "liquidator", _version) == True or self.isAuthorized(msg.sender, "governance", _version) == True\n', '\n', '    # get the asset contexts for the borrow asset and the collateral asset from the Store\n', '    borrowContext: AssetContext = STORE(_store).getAssetContext(_borrow_ticker)\n', '    collateralContext: AssetContext = STORE(_store).getAssetContext(_collateral_ticker)\n', '\n', '    # require that the liquidation redemption amount is greater than 0\n', '    assert _redeem_amount > 0\n', '\n', '    # require that the liquidation repayment amount is greater than 0\n', '    assert _repay_amount > 0\n', '\n', '    # check if the borrow asset is ETH\n', '    if keccak256(_borrow_ticker) == keccak256("ETH"):\n', '\n', '        # call repayBorrow() on the cEther contract and send msg.value in wei\n', '        raw_call(\n', '            borrowContext.cToken,\n', '            method_id("repayBorrow()"),\n', '            value=msg.value\n', '        )\n', '\n', '    else:\n', '\n', '        # move repayment asset (borrow asset) from borrower to Escrow\n', '        transferFromResponse: Bytes[32] = raw_call(\n', '            borrowContext.underlying,\n', '            concat(\n', '                method_id("transferFrom(address,address,uint256)"),\n', '                convert(_liquidator, bytes32),\n', '                convert(self, bytes32),\n', '                convert(_repay_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        ) \n', '        if len(transferFromResponse) > 0:\n', '            assert convert(transferFromResponse, bool)\n', '\n', '        # approve the cToken of the borrow asset to access the token balance of Escrow\n', '        approveResponse: Bytes[32] = raw_call(\n', '            borrowContext.underlying,\n', '            concat(\n', '                method_id("approve(address,uint256)"),\n', '                convert(borrowContext.cToken, bytes32),\n', '                convert(_repay_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(approveResponse) > 0:\n', '            assert convert(approveResponse, bool)\n', '\n', '        # require that the repay was successful\n', '        assert CTOKEN(borrowContext.cToken).repayBorrow(_repay_amount) == 0\n', '\n', '    # require that the redemption was successful\n', '    assert CTOKEN(collateralContext.cToken).redeemUnderlying(_redeem_amount) == 0\n', '\n', '    # declare memory variable to store the number of loan keys that have been processed\n', '    loanKeyCounter: uint256 = 0\n', '\n', '    # update the outstanding balance and collateral needed for the loan\n', '    for i in range(LOOP_LIMIT):\n', '\n', '        # check if all loans have been liquidated\n', '        if loanKeyCounter < _key_count:\n', '            STORE(_store).updateLoan(0, _borrow_index, _loan_keys[i], 0, _version)\n', '\n', '            # increment the loan key counter\n', '            loanKeyCounter += 1\n', '        \n', '        # all loan keys have been liquidated\n', '        elif loanKeyCounter == _key_count:\n', '\n', '            # halt loop execution\n', '            break\n', '\n', '        else:\n', '\n', '            # halt loop execution as a fallback case\n', '            break\n', '\n', '    # check if the collateral asset is ETH\n', '    if keccak256(_collateral_ticker) == keccak256("ETH"):\n', '\n', '        # send the redeemed ETH to the liquidator\n', '        send(_liquidator, _redeem_amount)\n', '\n', '    else:\n', '    \n', '        # transfer the redeemed collateral asset back to the borrower\n', '        transferResponse: Bytes[32] = raw_call(\n', '            collateralContext.underlying,\n', '            concat(\n', '                method_id("transfer(address,uint256)"),\n', '                convert(_liquidator, bytes32),\n', '                convert(_redeem_amount, bytes32),\n', '            ),\n', '            max_outsize=32,\n', '        )\n', '        if len(transferResponse) > 0:\n', '            assert convert(transferResponse, bool)\n', '\n', '    # emit a Liquidation event\n', '    log Liquidation(borrowContext.underlying, collateralContext.underlying, _liquidator, _loan_keys, _redeem_amount, _repay_amount, block.number)\n', '\n', '@external\n', 'def claimComp(_comp: address, _comptroller: address, _version: String[11]):\n', '    """\n', '    @notice Claims COMP rewards\n', '    @param _comp The address of COMP\n', '    @param _comptroller The address of the Compound Comptroller\n', '    @param _treasury The address of the Greenwood Treasury\n', '    @dev Only the Governance can call this method\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isAuthorized(msg.sender, "governance", "") == True\n', '\n', '    # call claimComp on the Compound Comptroller\n', '    raw_call(\n', '        _comptroller,\n', '        concat(\n', '            method_id("claimComp(address)"),\n', '            convert(self, bytes32)\n', '        )\n', '    )\n', '\n', '    # get the COMP balance of the Escrow\n', '    compBalance: uint256 = ERC20(_comp).balanceOf(self)\n', '\n', '\n', '    # get the address of the Treasury from the Registry\n', '    treasury: address = REGISTRY(self.registry).getAddress("treasury", _version)\n', '\n', '\n', '    # transfer the claimed COMP to the Treasury\n', '    transferResponse: Bytes[32] = raw_call(\n', '        _comp,\n', '        concat(\n', '            method_id("transfer(address,uint256)"),\n', '            convert(treasury, bytes32),\n', '            convert(compBalance, bytes32),\n', '        ),\n', '        max_outsize=32,\n', '    )\n', '    if len(transferResponse) > 0:\n', '        assert convert(transferResponse, bool)\n', '\n', '@external\n', 'def setRegistry(_new_registry: address):\n', '    """\n', '    @notice Updates the address of the Registry\n', '    @param _new_registry The address of the new Greenwood Registry\n', '    @dev Only the Governance can call this method\n', '    @dev Only call this method with a valid Greenwood Registry or subsequent calls will fail!\n', '    """\n', '\n', '    # require that the method caller is the Governance\n', '    assert self.isAuthorized(msg.sender, "governance", "") == True\n', '\n', '    # get the previous Registry\n', '    previousRegistry: address = self.registry\n', '\n', '    # update the address of the Registry\n', '    self.registry = _new_registry\n', '\n', '    # emit a SetRegistry event\n', '    log SetRegistry(previousRegistry, _new_registry, msg.sender, block.number)\n', '\n', '\n', '@external\n', '@payable\n', 'def __default__():\n', '    """\n', '    @notice Fallback function for receiving ETH\n', '    """\n', '\n', '    log Fallback(msg.value, msg.sender, block.number)']