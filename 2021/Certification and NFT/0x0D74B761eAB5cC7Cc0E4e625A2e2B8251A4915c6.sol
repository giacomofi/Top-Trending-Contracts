['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-12\n', '*/\n', '\n', '// Sources flattened with hardhat v2.4.3 https://hardhat.org\n', '\n', '// File contracts/solidity/interface/INFTXEligibility.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface INFTXEligibility {\n', '    // Read functions.\n', '    function name() external pure returns (string memory);\n', '    function finalized() external view returns (bool);\n', '    function targetAsset() external pure returns (address);\n', '    function checkAllEligible(uint256[] calldata tokenIds)\n', '        external\n', '        view\n', '        returns (bool);\n', '    function checkEligible(uint256[] calldata tokenIds)\n', '        external\n', '        view\n', '        returns (bool[] memory);\n', '    function checkAllIneligible(uint256[] calldata tokenIds)\n', '        external\n', '        view\n', '        returns (bool);\n', '    function checkIsEligible(uint256 tokenId) external view returns (bool);\n', '\n', '    // Write functions.\n', '    function __NFTXEligibility_init_bytes(bytes calldata configData) external;\n', '    function beforeMintHook(uint256[] calldata tokenIds) external;\n', '    function afterMintHook(uint256[] calldata tokenIds) external;\n', '    function beforeRedeemHook(uint256[] calldata tokenIds) external;\n', '    function afterRedeemHook(uint256[] calldata tokenIds) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/proxy/IBeacon.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is the interface that {BeaconProxy} expects of its beacon.\n', ' */\n', 'interface IBeacon {\n', '    /**\n', '     * @dev Must return an address that can be used as a delegate call target.\n', '     *\n', '     * {BeaconProxy} will check that this address is a contract.\n', '     */\n', '    function childImplementation() external view returns (address);\n', '    function upgradeChildTo(address newImplementation) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/interface/INFTXVaultFactory.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface INFTXVaultFactory is IBeacon {\n', '  // Read functions.\n', '  function numVaults() external view returns (uint256);\n', '  function zapContract() external view returns (address);\n', '  function feeDistributor() external view returns (address);\n', '  function eligibilityManager() external view returns (address);\n', '  function vault(uint256 vaultId) external view returns (address);\n', '  function vaultsForAsset(address asset) external view returns (address[] memory);\n', '  function isLocked(uint256 id) external view returns (bool);\n', '\n', '  event NewFeeDistributor(address oldDistributor, address newDistributor);\n', '  event NewZapContract(address oldZap, address newZap);\n', '  event NewEligibilityManager(address oldEligManager, address newEligManager);\n', '  event NewVault(uint256 indexed vaultId, address vaultAddress, address assetAddress);\n', '\n', '  // Write functions.\n', '  function __NFTXVaultFactory_init(address _vaultImpl, address _feeDistributor) external;\n', '  function createVault(\n', '      string calldata name,\n', '      string calldata symbol,\n', '      address _assetAddress,\n', '      bool is1155,\n', '      bool allowAllItems\n', '  ) external returns (uint256);\n', '  function setFeeDistributor(address _feeDistributor) external;\n', '  function setEligibilityManager(address _eligibilityManager) external;\n', '  function setZapContract(address _zapContract) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/interface/INFTXVault.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', 'interface INFTXVault {\n', '    function manager() external returns (address);\n', '    function assetAddress() external returns (address);\n', '    function vaultFactory() external returns (INFTXVaultFactory);\n', '    function eligibilityStorage() external returns (INFTXEligibility);\n', '\n', '    function is1155() external returns (bool);\n', '    function allowAllItems() external returns (bool);\n', '    function enableMint() external returns (bool);\n', '    function enableRandomRedeem() external returns (bool);\n', '    function enableTargetRedeem() external returns (bool);\n', '\n', '    function vaultId() external returns (uint256);\n', '    function nftIdAt(uint256 holdingsIndex) external view returns (uint256);\n', '    function allHoldings() external view returns (uint256[] memory);\n', '    function totalHoldings() external view returns (uint256);\n', '    function mintFee() external returns (uint256);\n', '    function randomRedeemFee() external returns (uint256);\n', '    function targetRedeemFee() external returns (uint256);\n', '\n', '    event VaultInit(\n', '        uint256 indexed vaultId,\n', '        address assetAddress,\n', '        bool is1155,\n', '        bool allowAllItems\n', '    );\n', '\n', '    event ManagerSet(address manager);\n', '    event EligibilityDeployed(uint256 moduleIndex, address eligibilityAddr);\n', '    // event CustomEligibilityDeployed(address eligibilityAddr);\n', '\n', '    event EnableMintUpdated(bool enabled);\n', '    event EnableRandomRedeemUpdated(bool enabled);\n', '    event EnableTargetRedeemUpdated(bool enabled);\n', '\n', '    event MintFeeUpdated(uint256 mintFee);\n', '    event RandomRedeemFeeUpdated(uint256 randomRedeemFee);\n', '    event TargetRedeemFeeUpdated(uint256 targetRedeemFee);\n', '\n', '    event Minted(uint256[] nftIds, uint256[] amounts, address to);\n', '    event Redeemed(uint256[] nftIds, uint256[] specificIds, address to);\n', '    event Swapped(\n', '        uint256[] nftIds,\n', '        uint256[] amounts,\n', '        uint256[] specificIds,\n', '        uint256[] redeemedIds,\n', '        address to\n', '    );\n', '\n', '    function __NFTXVault_init(\n', '        string calldata _name,\n', '        string calldata _symbol,\n', '        address _assetAddress,\n', '        bool _is1155,\n', '        bool _allowAllItems\n', '    ) external;\n', '\n', '    function finalizeVault() external;\n', '\n', '    function setVaultMetadata(\n', '        string memory name_, \n', '        string memory symbol_\n', '    ) external;\n', '\n', '    function setVaultFeatures(\n', '        bool _enableMint,\n', '        bool _enableRandomRedeem,\n', '        bool _enableTargetRedeem\n', '    ) external;\n', '\n', '    function setFees(\n', '        uint256 _mintFee,\n', '        uint256 _randomRedeemFee,\n', '        uint256 _targetRedeemFee\n', '    ) external;\n', '\n', '    // This function allows for an easy setup of any eligibility module contract from the EligibilityManager.\n', '    // It takes in ABI encoded parameters for the desired module. This is to make sure they can all follow\n', '    // a similar interface.\n', '    function deployEligibilityStorage(\n', '        uint256 moduleIndex,\n', '        bytes calldata initData\n', '    ) external returns (address);\n', '\n', '    // The manager has control over options like fees and features\n', '    function setManager(address _manager) external;\n', '\n', '    function mint(\n', '        uint256[] calldata tokenIds,\n', '        uint256[] calldata amounts /* ignored for ERC721 vaults */\n', '    ) external returns (uint256);\n', '\n', '    function mintTo(\n', '        uint256[] calldata tokenIds,\n', '        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n', '        address to\n', '    ) external returns (uint256);\n', '\n', '    function redeem(uint256 amount, uint256[] calldata specificIds)\n', '        external\n', '        returns (uint256[] calldata);\n', '\n', '    function redeemTo(\n', '        uint256 amount,\n', '        uint256[] calldata specificIds,\n', '        address to\n', '    ) external returns (uint256[] calldata);\n', '\n', '    function swap(\n', '        uint256[] calldata tokenIds,\n', '        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n', '        uint256[] calldata specificIds\n', '    ) external returns (uint256[] calldata);\n', '\n', '    function swapTo(\n', '        uint256[] calldata tokenIds,\n', '        uint256[] calldata amounts, /* ignored for ERC721 vaults */\n', '        uint256[] calldata specificIds,\n', '        address to\n', '    ) external returns (uint256[] calldata);\n', '\n', '    function allValidNFTs(uint256[] calldata tokenIds)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '// File contracts/solidity/interface/INFTXLPStaking.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface INFTXLPStaking {\n', '    function nftxVaultFactory() external view returns (address);\n', '    function rewardDistTokenImpl() external view returns (address);\n', '    function stakingTokenProvider() external view returns (address);\n', '    function vaultToken(address _stakingToken) external view returns (address);\n', '    function stakingToken(address _vaultToken) external view returns (address);\n', '    function rewardDistributionToken(uint256 vaultId) external view returns (address);\n', '    function rewardDistributionTokenAddr(address stakingToken, address rewardToken) external view returns (address);\n', '    \n', '    // Write functions.\n', '    function __NFTXLPStaking__init(address _stakingTokenProvider) external;\n', '    function setNFTXVaultFactory(address newFactory) external;\n', '    function setStakingTokenProvider(address newProvider) external;\n', '    function addPoolForVault(uint256 vaultId) external;\n', '    function updatePoolForVault(uint256 vaultId) external;\n', '    function updatePoolForVaults(uint256[] calldata vaultId) external;\n', '    function receiveRewards(uint256 vaultId, uint256 amount) external returns (bool);\n', '    function deposit(uint256 vaultId, uint256 amount) external;\n', '    function depositFor(uint256 vaultId, uint256 amount, address to) external;\n', '    function exit(uint256 vaultId, uint256 amount) external;\n', '    function rescue(uint256 vaultId) external;\n', '    function withdraw(uint256 vaultId, uint256 amount) external;\n', '    function claimRewards(uint256 vaultId) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/interface/IUniswapV2Router01.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '    function swapExactETHForTokens(\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '    function swapTokensForExactETH(\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '    function swapExactTokensForETH(\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256[] memory amounts);\n', '    function swapETHForExactTokens(\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB)\n', '        external\n', '        pure\n', '        returns (uint256 amountB);\n', '    function getAmountOut(\n', '        uint256 amountIn,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountOut);\n', '    function getAmountIn(\n', '        uint256 amountOut,\n', '        uint256 reserveIn,\n', '        uint256 reserveOut\n', '    ) external pure returns (uint256 amountIn);\n', '    function getAmountsOut(uint256 amountIn, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path)\n', '        external\n', '        view\n', '        returns (uint256[] memory amounts);\n', '}\n', '\n', '\n', '// File contracts/solidity/interface/IERC165Upgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165Upgradeable {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '\n', '// File contracts/solidity/token/IERC721Upgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721Upgradeable is IERC165Upgradeable {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '      * - `from` cannot be the zero address.\n', '      * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/token/IERC1155Upgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Required interface of an ERC1155 compliant contract, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n', ' *\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155Upgradeable is IERC165Upgradeable {\n', '    /**\n', '     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n', '     */\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    /**\n', '     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n', '     * transfers.\n', '     */\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    /**\n', '     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n', '     * `approved`.\n', '     */\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    /**\n', '     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n', '     *\n', '     * If an {URI} event was emitted for `id`, the standard\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n', '     * returned by {IERC1155MetadataURI-uri}.\n', '     */\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     */\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    /**\n', "     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n", '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `operator` cannot be the caller.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    /**\n', "     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n", '     *\n', '     * See {setApprovalForAll}.\n', '     */\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', "     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n", '     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n', '     *\n', '     * Emits a {TransferBatch} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '\n', '// File contracts/solidity/token/IERC20Upgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20Upgradeable {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// File contracts/solidity/token/IERC721ReceiverUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721ReceiverUpgradeable {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', '\n', '// File contracts/solidity/token/ERC721HolderUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Implementation of the {IERC721Receiver} interface.\n', ' *\n', ' * Accepts all token transfers.\n', ' * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n', ' */\n', 'contract ERC721HolderUpgradeable is IERC721ReceiverUpgradeable {\n', '    /**\n', '     * @dev See {IERC721Receiver-onERC721Received}.\n', '     *\n', '     * Always returns `IERC721Receiver.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(\n', '        address,\n', '        address,\n', '        uint256,\n', '        bytes memory\n', '    ) public virtual override returns (bytes4) {\n', '        return this.onERC721Received.selector;\n', '    }\n', '}\n', '\n', '\n', '// File contracts/solidity/token/IERC1155ReceiverUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev _Available since v3.1._\n', ' */\n', 'interface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n', '\n', '    /**\n', '        @dev Handles the receipt of a single ERC1155 token type. This function is\n', '        called at the end of a `safeTransferFrom` after the balance has been updated.\n', '        To accept the transfer, this must return\n', '        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '        (i.e. 0xf23a6e61, or its own function selector).\n', '        @param operator The address which initiated the transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param id The ID of the token being transferred\n', '        @param value The amount of tokens being transferred\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '\n', '    /**\n', '        @dev Handles the receipt of a multiple ERC1155 token types. This function\n', '        is called at the end of a `safeBatchTransferFrom` after the balances have\n', '        been updated. To accept the transfer(s), this must return\n', '        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '        (i.e. 0xbc197c81, or its own function selector).\n', '        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param ids An array containing ids of each token being transferred (order and length must match values array)\n', '        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '}\n', '\n', '\n', '// File contracts/solidity/util/ERC165Upgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n', ' * for the additional interface id that will be supported. For example:\n', ' *\n', ' * ```solidity\n', ' * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', ' *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n', ' * }\n', ' * ```\n', ' *\n', ' * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n', ' */\n', 'abstract contract ERC165Upgradeable is IERC165Upgradeable {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == type(IERC165Upgradeable).interfaceId;\n', '    }\n', '}\n', '\n', '\n', '// File contracts/solidity/token/ERC1155ReceiverUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev _Available since v3.1._\n', ' */\n', 'abstract contract ERC1155ReceiverUpgradeable is ERC165Upgradeable, IERC1155ReceiverUpgradeable {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n', '        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '}\n', '\n', '\n', '// File contracts/solidity/token/ERC1155HolderUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev _Available since v3.1._\n', ' */\n', 'abstract contract ERC1155HolderUpgradeable is ERC1155ReceiverUpgradeable {\n', '    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '}\n', '\n', '\n', '// File contracts/solidity/proxy/Initializable.sol\n', '\n', '\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' *\n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n', ' *\n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/solidity/util/ContextUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract ContextUpgradeable is Initializable {\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '    }\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '    uint256[50] private __gap;\n', '}\n', '\n', '\n', '// File contracts/solidity/util/OwnableUpgradeable.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '    uint256[49] private __gap;\n', '}\n', '\n', '\n', '// File contracts/solidity/NFTXStakingZap.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '// Authors: @0xKiwi_.\n', '\n', 'interface IWETH {\n', '  function deposit() external payable;\n', '  function transfer(address to, uint value) external returns (bool);\n', '  function withdraw(uint) external;\n', '}\n', '\n', 'contract NFTXStakingZap is OwnableUpgradeable, ERC721HolderUpgradeable, ERC1155HolderUpgradeable {\n', '  IWETH public WETH; \n', '  INFTXLPStaking public lpStaking;\n', '  INFTXVaultFactory public nftxFactory;\n', '  IUniswapV2Router01 public sushiRouter;\n', '\n', '  uint256 public lockTime = 48 hours; \n', '\n', '  mapping(uint256 => mapping(address => uint256)) private zapLock;\n', '  mapping(uint256 => mapping(address => uint256)) private lockedBalance;\n', '\n', '  uint256 BASE = 10**18;\n', '\n', '  event UserStaked(uint256 vaultId, uint256 count, uint256 lpBalance, uint256 timelockUntil);\n', '  event Withdraw(uint256 vaultId, uint256 lpBalance);\n', '\n', '  constructor(address _nftxFactory, address _sushiRouter) {\n', '    __Ownable_init();\n', '    nftxFactory = INFTXVaultFactory(_nftxFactory);\n', '    sushiRouter = IUniswapV2Router01(_sushiRouter);\n', '    WETH = IWETH(sushiRouter.WETH());\n', '    IERC20Upgradeable(address(WETH)).approve(address(sushiRouter), type(uint256).max);\n', '  }\n', '\n', '  function setLpStakingAddress(address newLpStaking) external {\n', '    lpStaking = INFTXLPStaking(newLpStaking);\n', '  } \n', '\n', '  function addLiquidity721ETH(\n', '    uint256 vaultId, \n', '    uint256[] memory ids, \n', '    uint256 minWethIn\n', '  ) public payable returns (uint256) {\n', '    WETH.deposit{value: msg.value}();\n', '    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, msg.value);\n', '\n', '    // Return extras.\n', '    if (amountEth < msg.value) {\n', '      WETH.withdraw(msg.value-amountEth);\n', '      payable(msg.sender).transfer(msg.value-amountEth);\n', '    }\n', '\n', '    return liquidity;\n', '  }\n', '\n', '  function addLiquidity1155ETH(\n', '    uint256 vaultId, \n', '    uint256[] memory ids, \n', '    uint256[] memory amounts,\n', '    uint256 minEthIn\n', '  ) public payable returns (uint256) {\n', '    WETH.deposit{value: msg.value}();\n', '    // Finish this.\n', '    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minEthIn, msg.value);\n', '\n', '    // Return extras.\n', '    if (amountEth < msg.value) {\n', '      WETH.withdraw(msg.value-amountEth);\n', '      payable(msg.sender).transfer(msg.value-amountEth);\n', '    }\n', '\n', '    return liquidity;\n', '  }\n', '\n', '  function _addLiquidity721(\n', '    uint256 vaultId, \n', '    uint256[] memory ids, \n', '    uint256 minWethIn,\n', '    uint256 wethIn\n', '  ) public returns (uint256) {\n', '    (, uint256 amountEth, uint256 liquidity) = _addLiquidity721WETH(vaultId, ids, minWethIn, wethIn);\n', '\n', '    // Return extras.\n', '    if (amountEth < wethIn) {\n', '      WETH.transfer(msg.sender, wethIn-amountEth);\n', '    }\n', '\n', '    return liquidity;\n', '  }\n', '\n', '  function _addLiquidity1155(\n', '    uint256 vaultId, \n', '    uint256[] memory ids,\n', '    uint256[] memory amounts,\n', '    uint256 minWethIn,\n', '    uint256 wethIn\n', '  ) internal returns (uint256) {\n', '    (, uint256 amountEth, uint256 liquidity) = _addLiquidity1155WETH(vaultId, ids, amounts, minWethIn, wethIn);\n', '\n', '    // Return extras.\n', '    if (amountEth < wethIn) {\n', '      WETH.transfer(msg.sender, wethIn-amountEth);\n', '    }\n', '\n', '    return liquidity;\n', '  }\n', '\n', '  function withdrawXLPTokens(uint256 vaultId) public {\n', '    uint256 lockedBal = lockedBalance[vaultId][msg.sender];\n', '    require(block.timestamp >= zapLock[vaultId][msg.sender], "NFTXZap: Locked");\n', '    require(lockedBal > 0, "NFTXZap: Nothing locked");\n', '    \n', '    zapLock[vaultId][msg.sender] = 0;\n', '    lockedBalance[vaultId][msg.sender] = 0;\n', '\n', '    address xLPtoken = lpStaking.rewardDistributionToken(vaultId);\n', '    IERC20Upgradeable(xLPtoken).transfer(msg.sender, lockedBal);\n', '\n', '    emit Withdraw(vaultId, lockedBal);\n', '  }\n', '\n', '  function setLockTime(uint256 newLockTime) external onlyOwner {\n', '    lockTime = newLockTime;\n', '  } \n', '\n', '  function lockedUntil(uint256 vaultId, address who) external view returns (uint256) {\n', '    return zapLock[vaultId][who];\n', '  }\n', '\n', '  function lockedLPBalance(uint256 vaultId, address who) external view returns (uint256) {\n', '    return lockedBalance[vaultId][who];\n', '  }\n', '\n', '  function _addLiquidity721WETH(\n', '    uint256 vaultId, \n', '    uint256[] memory ids, \n', '    uint256 minWethIn,\n', '    uint256 wethIn\n', '  ) internal returns (uint256, uint256, uint256) {\n', '    address vault = nftxFactory.vault(vaultId);\n', '    require(vault != address(0), "NFTXZap: Vault does not exist");\n', '\n', '    // Transfer tokens to zap and mint to NFTX.\n', '    address assetAddress = INFTXVault(vault).assetAddress();\n', '    for (uint256 i = 0; i < ids.length; i++) {\n', '      transferFromERC721(assetAddress, ids[i]);\n', '      approveERC721(assetAddress, vault, ids[i]);\n', '    }\n', '    uint256[] memory emptyIds;\n', '    uint256 count = INFTXVault(vault).mint(ids, emptyIds);\n', '    uint256 balance = (count * BASE); // We should not be experiencing fees.\n', '    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), "Did not receive expected balance");\n', '    \n', '    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn);\n', '  }\n', '\n', '  function _addLiquidity1155WETH(\n', '    uint256 vaultId, \n', '    uint256[] memory ids,\n', '    uint256[] memory amounts,\n', '    uint256 minWethIn,\n', '    uint256 wethIn\n', '  ) internal returns (uint256, uint256, uint256) {\n', '    address vault = nftxFactory.vault(vaultId);\n', '    require(vault != address(0), "NFTXZap: Vault does not exist");\n', '\n', '    // Transfer tokens to zap and mint to NFTX.\n', '    address assetAddress = INFTXVault(vault).assetAddress();\n', '    IERC1155Upgradeable(assetAddress).safeBatchTransferFrom(msg.sender, address(this), ids, amounts, "");\n', '    IERC1155Upgradeable(assetAddress).setApprovalForAll(vault, true);\n', '    uint256 count = INFTXVault(vault).mint(ids, amounts);\n', '    uint256 balance = (count * BASE); // We should not be experiencing fees.\n', '    require(balance == IERC20Upgradeable(vault).balanceOf(address(this)), "Did not receive expected balance");\n', '    \n', '    return _addLiquidityAndLock(vaultId, vault, balance, minWethIn, wethIn);\n', '  }\n', '\n', '  function _addLiquidityAndLock(\n', '    uint256 vaultId, \n', '    address vault, \n', '    uint256 minTokenIn, \n', '    uint256 minWethIn, \n', '    uint256 wethIn\n', '  ) internal returns (uint256, uint256, uint256) {\n', '    // Provide liquidity.\n', '    IERC20Upgradeable(vault).approve(address(sushiRouter), minTokenIn);\n', '    (uint256 amountToken, uint256 amountEth, uint256 liquidity) = sushiRouter.addLiquidity(\n', '      address(vault), \n', '      sushiRouter.WETH(),\n', '      minTokenIn, \n', '      wethIn, \n', '      minTokenIn,\n', '      minWethIn,\n', '      address(this), \n', '      block.timestamp\n', '    );\n', '\n', '    // Stake in LP rewards contract \n', '    address lpToken = pairFor(vault, address(WETH));\n', '    IERC20Upgradeable(lpToken).approve(address(lpStaking), liquidity);\n', '    lpStaking.depositFor(vaultId, liquidity, msg.sender);\n', '    \n', '    lockedBalance[vaultId][msg.sender] += liquidity;\n', '    uint256 lockTime = block.timestamp + lockTime;\n', '    zapLock[vaultId][msg.sender] = lockTime;\n', '\n', '    if (amountToken < minTokenIn) {\n', '      IERC20Upgradeable(vault).transfer(msg.sender, minTokenIn-amountToken);\n', '    }\n', '\n', '    emit UserStaked(vaultId, minTokenIn, liquidity, lockTime);\n', '    return (amountToken, amountEth, liquidity);\n', '  }\n', '\n', '  function transferFromERC721(address assetAddr, uint256 tokenId) internal virtual {\n', '    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n', '    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n', '    bytes memory data;\n', '    if (assetAddr == kitties) {\n', '        // Cryptokitties.\n', '        data = abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, address(this), tokenId);\n', '    } else if (assetAddr == punks) {\n', '        // CryptoPunks.\n', '        // Fix here for frontrun attack. Added in v1.0.2.\n', '        bytes memory punkIndexToAddress = abi.encodeWithSignature("punkIndexToAddress(uint256)", tokenId);\n', '        (bool checkSuccess, bytes memory result) = address(assetAddr).staticcall(punkIndexToAddress);\n', '        (address owner) = abi.decode(result, (address));\n', '        require(checkSuccess && owner == msg.sender, "Not the owner");\n', '        data = abi.encodeWithSignature("buyPunk(uint256)", tokenId);\n', '    } else {\n', '        // Default.\n', '        data = abi.encodeWithSignature("safeTransferFrom(address,address,uint256)", msg.sender, address(this), tokenId);\n', '    }\n', '    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n', '    require(success, string(resultData));\n', '  }\n', '\n', '  function approveERC721(address assetAddr, address to, uint256 tokenId) internal virtual {\n', '    address kitties = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n', '    address punks = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\n', '    bytes memory data;\n', '    if (assetAddr == kitties) {\n', '        // Cryptokitties.\n', '        data = abi.encodeWithSignature("approve(address,uint256)", to, tokenId);\n', '    } else if (assetAddr == punks) {\n', '        // CryptoPunks.\n', '        data = abi.encodeWithSignature("offerPunkForSaleToAddress(uint256,uint256,address)", tokenId, 0, to);\n', '    } else {\n', '        if (IERC721Upgradeable(assetAddr).isApprovedForAll(address(this), to)) {\n', '          return;\n', '        }\n', '        // Default.\n', '        data = abi.encodeWithSignature("setApprovalForAll(address,bool)", to, true);\n', '    }\n', '    (bool success, bytes memory resultData) = address(assetAddr).call(data);\n', '    require(success, string(resultData));\n', '  }\n', '\n', '  // calculates the CREATE2 address for a pair without making any external calls\n', '  function pairFor(address tokenA, address tokenB) internal pure returns (address pair) {\n', '    (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '    pair = address(uint160(uint256(keccak256(abi.encodePacked(\n', "      hex'ff',\n", '      0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac,\n', '      keccak256(abi.encodePacked(token0, token1)),\n', "      hex'e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303' // init code hash\n", '    )))));\n', '  }\n', '\n', '  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '  function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "      require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '      (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "      require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '  }\n', '}']