['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.8.0 <0.9.0;\n', '\n', "import './Migratable.sol';\n", '\n', 'contract Vault is Migratable {\n', '\n', '    event Claim(address indexed account, uint256 amount, uint256 deadline, uint256 nonce);\n', '\n', "    string public constant name = 'MiningVault';\n", '\n', '    address public tokenAddress;\n', '\n', '    uint256 public chainId;\n', '\n', '    mapping (bytes32 => bool) public usedHash;\n', '\n', "    bytes32 public constant DOMAIN_TYPEHASH = keccak256('EIP712Domain(string name,uint256 chainId,address verifyingContract)');\n", '\n', "    bytes32 public constant CLAIM_TYPEHASH = keccak256('Claim(address account,uint256 amount,uint256 deadline,uint256 nonce)');\n", '\n', '    constructor (address tokenAddress_) {\n', '        controller = msg.sender;\n', '        tokenAddress = tokenAddress_;\n', '        uint256 _chainId;\n', '        assembly {\n', '            _chainId := chainid()\n', '        }\n', '        chainId = _chainId;\n', '    }\n', '\n', '    function approveMigration() public override _controller_ _valid_ {\n', "        require(migrationTimestamp != 0 && block.timestamp >= migrationTimestamp, 'Vault.approveMigration: migrationTimestamp not met yet');\n", '        IERC20(tokenAddress).approve(migrationDestination, type(uint256).max);\n', '        isMigrated = true;\n', '        emit ApproveMigration(migrationTimestamp, address(this), migrationDestination);\n', '    }\n', '\n', '    function executeMigration(address source) public override _controller_ _valid_ {\n', '        uint256 _migrationTimestamp = IVault(source).migrationTimestamp();\n', '        address _migrationDestination = IVault(source).migrationDestination();\n', "        require(_migrationTimestamp != 0 && block.timestamp >= _migrationTimestamp, 'Vault.executeMigration: migrationTimestamp not met yet');\n", "        require(_migrationDestination == address(this), 'Vault.executeMigration: not destination address');\n", '        IERC20(tokenAddress).transferFrom(source, address(this), IERC20(tokenAddress).balanceOf(source));\n', '        emit ExecuteMigration(_migrationTimestamp, source, address(this));\n', '    }\n', '\n', '    function claim(address account, uint256 amount, uint256 deadline, uint256 nonce, uint8 v, bytes32 r, bytes32 s) public _valid_ {\n', "        require(block.timestamp <= deadline, 'Vault.claim: signature expired');\n", '\n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), chainId, address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(CLAIM_TYPEHASH, account, amount, deadline, nonce));\n', "        require(!usedHash[structHash], 'Vault.claim: replay');\n", '        usedHash[structHash] = true;\n', '\n', "        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', domainSeparator, structHash));\n", '        address signatory = ecrecover(digest, v, r, s);\n', "        require(signatory == controller, 'Vault.claim: unauthorized');\n", '\n', '        IERC20(tokenAddress).transfer(account, amount);\n', '\n', '        emit Claim(account, amount, deadline, nonce);\n', '    }\n', '\n', '}\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function approve(address account, uint256 amount) external returns (bool);\n', '    function transfer(address to, uint256 amount) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IVault {\n', '    function migrationTimestamp() external view returns (uint256);\n', '    function migrationDestination() external view returns (address);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.8.0 <0.9.0;\n', '\n', 'abstract contract Migratable {\n', '\n', '    event PrepareMigration(uint256 migrationTimestamp, address source, address destination);\n', '\n', '    event ApproveMigration(uint256 migrationTimestamp, address source, address destination);\n', '\n', '    event ExecuteMigration(uint256 migrationTimestamp, address source, address destination);\n', '\n', '    address public controller;\n', '\n', '    uint256 public migrationTimestamp;\n', '\n', '    address public migrationDestination;\n', '\n', '    bool public isMigrated;\n', '\n', '    modifier _controller_() {\n', "        require(msg.sender == controller, 'Migratable._controller_: can only called by controller');\n", '        _;\n', '    }\n', '\n', '    modifier _valid_() {\n', "        require(!isMigrated, 'Migratable._valid_: cannot proceed, this contract has been migrated');\n", '        _;\n', '    }\n', '\n', '    function setController(address newController) public _controller_ _valid_ {\n', "        require(newController != address(0), 'Migratable.setController: to 0 address');\n", '        controller = newController;\n', '    }\n', '\n', '    function prepareMigration(address destination, uint256 graceDays) public _controller_ _valid_ {\n', "        require(destination != address(0), 'Migratable.prepareMigration: to 0 address');\n", "        require(graceDays >= 3 && graceDays <= 365, 'Migratable.prepareMigration: graceDays must be 3-365 days');\n", '\n', '        migrationTimestamp = block.timestamp + graceDays * 1 days;\n', '        migrationDestination = destination;\n', '\n', '        emit PrepareMigration(migrationTimestamp, address(this), migrationDestination);\n', '    }\n', '\n', '    function approveMigration() public virtual;\n', '\n', '    function executeMigration(address source) public virtual;\n', '\n', '}']