['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.8;\n', '\n', 'import "./NFTXv6.sol";\n', 'import "./IERC20.sol";\n', 'import "./IERC1155.sol";\n', 'import "./IERC1155Receiver.sol";\n', '\n', 'contract NFTXv7 is NFTXv6, IERC1155Receiver {\n', '\n', '    mapping(uint256 => bool) public isVault1155;\n', '\n', '    function setIs1155(\n', '        uint256 vaultId,\n', '        bool _boolean\n', '    ) public virtual {\n', '        onlyPrivileged(vaultId);\n', '        isVault1155[vaultId] = _boolean;\n', '    }\n', '\n', '    function _mint(uint256 vaultId, uint256[] memory nftIds, bool isDualOp)\n', '        internal\n', '        virtual\n', '        override\n', '    {\n', '        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n', '            uint256 nftId = nftIds[i];\n', '            require(isEligible(vaultId, nftId), "1");\n', '            \n', '            if (isVault1155[vaultId]) {\n', '                IERC1155 nft = IERC1155(store.nftAddress(vaultId));\n', '                nft.safeTransferFrom(msg.sender, address(this), nftId, 1, "");\n', '            } else {\n', '                require(\n', '                    store.nft(vaultId).ownerOf(nftId) != address(this),\n', '                    "2"\n', '                );\n', '                store.nft(vaultId).transferFrom(msg.sender, address(this), nftId);\n', '                require(\n', '                    store.nft(vaultId).ownerOf(nftId) == address(this),\n', '                    "3"\n', '                );\n', '            }\n', '            \n', '            store.holdingsAdd(vaultId, nftId);\n', '        }\n', '        store.xToken(vaultId).mint(msg.sender, nftIds.length.mul(10**18));\n', '    }\n', '\n', '    function _redeemHelper(\n', '        uint256 vaultId,\n', '        uint256[] memory nftIds,\n', '        bool isDualOp\n', '    ) internal virtual override {\n', '        store.xToken(vaultId).burnFrom(msg.sender, nftIds.length.mul(10**18));\n', '        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n', '            uint256 nftId = nftIds[i];\n', '            require(\n', '                store.holdingsContains(vaultId, nftId),\n', '                "1"\n', '            );\n', '            if (store.holdingsContains(vaultId, nftId)) {\n', '                store.holdingsRemove(vaultId, nftId);\n', '            }\n', '            if (store.flipEligOnRedeem(vaultId)) {\n', '                bool isElig = store.isEligible(vaultId, nftId);\n', '                store.setIsEligible(vaultId, nftId, !isElig);\n', '            }\n', '            if (isVault1155[vaultId]) {\n', '                IERC1155 nft = IERC1155(store.nftAddress(vaultId));\n', '                nft.safeTransferFrom(address(this), msg.sender, nftId, 1, "");\n', '            } else {\n', '                store.nft(vaultId).safeTransferFrom(\n', '                    address(this),\n', '                    msg.sender,\n', '                    nftId\n', '                );\n', '            }\n', '            \n', '        }\n', '    }\n', '\n', '    function requestMint(uint256 vaultId, uint256[] memory nftIds)\n', '        public\n', '        payable\n', '        virtual\n', '        override\n', '        nonReentrant\n', '    {\n', '        onlyOwnerIfPaused(1);\n', '        require(store.allowMintRequests(vaultId), "1");\n', '        // TODO: implement bounty + fees\n', '        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n', '            require(\n', '                store.nft(vaultId).ownerOf(nftIds[i]) != address(this),\n', '                "2"\n', '            );\n', '            store.nft(vaultId).safeTransferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                nftIds[i]\n', '            );\n', '            require(\n', '                store.nft(vaultId).ownerOf(nftIds[i]) == address(this),\n', '                "3"\n', '            );\n', '            store.setRequester(vaultId, nftIds[i], msg.sender);\n', '        }\n', '        emit MintRequested(vaultId, nftIds, msg.sender);\n', '    }\n', '\n', '    function setNegateEligibility(uint256 vaultId, bool shouldNegate)\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        onlyPrivileged(vaultId);\n', '        require(\n', '            store\n', '                .holdingsLength(vaultId)\n', '                .add(store.d2Holdings(vaultId)) ==\n', '                0,\n', '            "1"\n', '        );\n', '        store.setNegateEligibility(vaultId, shouldNegate);\n', '    }\n', '\n', '    function mint(uint256 vaultId, uint256[] memory nftIds, uint256 d2Amount)\n', '        public\n', '        payable\n', '        virtual\n', '        override\n', '        nonReentrant\n', '    {\n', '        onlyOwnerIfPaused(1);\n', '        // uint256 amount = store.isD2Vault(vaultId) ? d2Amount : nftIds.length;\n', '        // uint256 ethBounty = store.isD2Vault(vaultId)\n', '        //     ? _calcBountyD2(vaultId, d2Amount, false)\n', '        //     : _calcBounty(vaultId, amount, false);\n', '        // (uint256 ethBase, uint256 ethStep) = store.mintFees(vaultId);\n', '        // uint256 ethFee = _calcFee(\n', '        //     amount,\n', '        //     ethBase,\n', '        //     ethStep,\n', '        //     store.isD2Vault(vaultId)\n', '        // );\n', '        // if (ethFee > ethBounty) {\n', '        //     _receiveEthToVault(vaultId, ethFee.sub(ethBounty), msg.value);\n', '        // }\n', '        if (store.isD2Vault(vaultId)) {\n', '            _mintD2(vaultId, d2Amount);\n', '        } else {\n', '            _mint(vaultId, nftIds, false);\n', '        }\n', '        // if (ethBounty > ethFee) {\n', '        //     _payEthFromVault(vaultId, ethBounty.sub(ethFee), msg.sender);\n', '        // }\n', '        emit Mint(vaultId, nftIds, d2Amount, msg.sender);\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address,\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        bytes memory\n', '    ) public virtual override returns (bytes4) {\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address,\n', '        address,\n', '        uint256[] memory,\n', '        uint256[] memory,\n', '        bytes memory\n', '    ) public virtual override returns (bytes4) {\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceId)\n', '        external\n', '        override\n', '        view\n', '        returns (bool)\n', '    {}\n', '\n', '    function createVault(\n', '        address _xTokenAddress,\n', '        address _assetAddress,\n', '        bool _isD2Vault\n', '    ) public virtual override nonReentrant returns (uint256) {\n', '        revert();\n', '    }\n', '\n', '    function setMintFees(uint256 vaultId, uint256 _ethBase, uint256 _ethStep)\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        revert();\n', '    }\n', '\n', '    function setBurnFees(uint256 vaultId, uint256 _ethBase, uint256 _ethStep)\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        revert();\n', '    }\n', '\n', '    function setSupplierBounty(uint256 vaultId, uint256 ethMax, uint256 length)\n', '        public\n', '        virtual\n', '        override\n', '    {\n', '        revert();\n', '    }\n', '\n', '    mapping(uint256 => uint256) public rangeStart;\n', '    mapping(uint256 => uint256) public rangeEnd;\n', '\n', '    function setRange(\n', '        uint256 vaultId,\n', '        uint256 start,\n', '        uint256 end\n', '    ) public virtual {\n', '        onlyPrivileged(vaultId);\n', '        rangeStart[vaultId] = start;\n', '        rangeEnd[vaultId] = end;\n', '    }\n', '\n', '    function isEligible(uint256 vaultId, uint256 nftId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        if (rangeEnd[vaultId] > 0) {\n', '            if (nftId >= rangeStart[vaultId] && nftId <= rangeEnd[vaultId]) {\n', '                return true;\n', '            }\n', '        }\n', '        return\n', '            store.negateEligibility(vaultId)\n', '                ? !store.isEligible(vaultId, nftId)\n', '                : store.isEligible(vaultId, nftId);\n', '        \n', '    }\n', '}']