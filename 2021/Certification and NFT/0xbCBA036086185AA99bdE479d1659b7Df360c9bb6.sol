['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-27\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.7.6;\n', '\n', '// ----------------------------------------------------------------------------\n', '// CocktailBar Stake COC to earn MOJITO \n', '// Enter our universe : cocktailbar.finance\n', '//\n', '// Come join the disscussion: https://t.me/cocktailbar_discussion\n', '//\n', '//                                          Sincerely, Mr. Martini\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function ceil(uint a, uint m) internal pure returns (uint r) {\n', '        return (a + m - 1) / m * m;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', 'contract Owned {\n', '    address public owner;\n', '\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) external onlyOwner {\n', '        owner = _newOwner;\n', '        emit OwnershipTransferred(msg.sender, _newOwner);\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// ----------------------------------------------------------------------------\n', '\n', '\n', 'interface COC {\n', '    function balanceOf(address _owner) view external  returns (uint256 balance);\n', '\n', '    function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    function transfer(address _to, uint256 _amount) external  returns (bool success);\n', '    function transferFrom(address _from,address _to,uint256 _amount) external  returns (bool success);\n', '    function approve(address _to, uint256 _amount) external  returns (bool success);\n', '}\n', '\n', '\n', 'interface MOJITO {\n', '    function balanceOf(address _owner) view external  returns (uint256 balance);\n', '\n', '    function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    function transfer(address _to, uint256 _amount) external  returns (bool success);\n', '    function transferFrom(address _from,address _to,uint256 _amount) external  returns (bool success);\n', '    function approve(address _to, uint256 _amount) external  returns (bool success);\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '    bool private _notEntered;\n', '\n', '    constructor () {\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and assisted\n', '// token transfers\n', '// ----------------------------------------------------------------------------\n', 'contract StakeCOC is Owned, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '    uint256 private TotalMRewards;\n', '    uint256 public WeekRewardPercent = 100;\n', '    uint256 public TotalStakedETH = 0;\n', '    uint256 StakingFee = 10; // 1.0%\n', '    uint256 UnstakingFee = 30; // 3.0%\n', '    uint256 private TeamFeesCollector = 0;\n', '    address public stakeTokenAdd = 0x22B6C31c2bEB8f2d0d5373146Eed41Ab9eDe3caf;\n', '    address constant public rewardToken = 0xda579367c6ca7854009133D1B3739020ba350C23;\n', '    uint256 public creationTimeContract;\n', '\n', '\n', '\n', '    struct USER{\n', '        uint256 stakedAmount;\n', '        uint256 creationTime;\n', '        uint256 TotalMRewarded;\n', '        uint256 lastClaim;\n', '        uint256 MyTotalStaked;\n', '    }\n', '\n', '    mapping(address => USER) public stakers;\n', '    mapping(address=>uint256) public amounts;           // keeps record of each reward payout\n', '    uint256[] private rewardperday = [16000000000000000000,16000000000000000000,16000000000000000000,16000000000000000000,16000000000000000000,14000000000000000000,14000000000000000000,14000000000000000000,14000000000000000000,14000000000000000000,12000000000000000000,12000000000000000000,12000000000000000000,12000000000000000000,12000000000000000000,10000000000000000000,10000000000000000000,10000000000000000000,10000000000000000000,10000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,8000000000000000000,6000000000000000000,6000000000000000000,6000000000000000000,6000000000000000000,6000000000000000000,6000000000000000000,6000000000000000000,6000000000000000000,6000000000000000000,6000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,4000000000000000000,2000000000000000000,2000000000000000000,2000000000000000000,2000000000000000000,2000000000000000000];\n', '    event STAKED(address staker, uint256 tokens, uint256 StakingFee);\n', '    event UNSTAKED(address staker, uint256 tokens, uint256 UnstakingFee);\n', '    event CLAIMEDREWARD(address staker, uint256 reward);\n', '    event PERCENTCHANGED(address operator, uint256 percent);\n', '    event FkTake(uint256 amount);\n', '    event JkTake(uint256 amount);\n', '    constructor() {\n', '         creationTimeContract = block.timestamp;\n', '    }\n', '    // ------------------------------------------------------------------------\n', '    // Token holders can stake their tokens using this function\n', '    // @param tokens number of tokens to stake\n', '    // ------------------------------------------------------------------------\n', '    function STAKE(uint256 tokens) external nonReentrant returns(bool){\n', '\n', '        require(COC(stakeTokenAdd).transferFrom(msg.sender, address(this), tokens), "Tokens cannot be transferred from user account");\n', '        uint256 _stakingFee = (onePercentofTokens(tokens).mul(StakingFee)).div(10);\n', '        stakers[msg.sender].stakedAmount = (tokens.sub(_stakingFee)).add(stakers[msg.sender].stakedAmount);\n', '        TeamFeesCollector = TeamFeesCollector.add(_stakingFee);\n', '        stakers[msg.sender].creationTime = block.timestamp;\n', '        stakers[msg.sender].lastClaim =  stakers[msg.sender].creationTime;\n', '\n', '        stakers[msg.sender].MyTotalStaked = stakers[msg.sender].MyTotalStaked.add((tokens.sub(_stakingFee)).add(stakers[msg.sender].stakedAmount));\n', '        TotalStakedETH = TotalStakedETH.add((tokens).sub(_stakingFee));\n', '        emit STAKED(msg.sender, (tokens).sub(_stakingFee), _stakingFee);\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Stakers can claim their pending rewards using this function\n', '    // ------------------------------------------------------------------------\n', '\n', '\n', '    function WITHDRAW(uint256 tokens) external nonReentrant {\n', '        require(stakers[msg.sender].stakedAmount >= tokens && tokens > 0, "Invalid token amount to withdraw");\n', '        uint256 _unstakingFee = (onePercentofTokens(tokens).mul(UnstakingFee)).div(10);\n', '       TeamFeesCollector= TeamFeesCollector.add(_unstakingFee);\n', '        uint256 owing = 0;\n', '        require(COC(stakeTokenAdd).transfer(msg.sender, tokens.sub(_unstakingFee)), "Error in un-staking tokens");\n', '        stakers[msg.sender].stakedAmount = (stakers[msg.sender].stakedAmount).sub(tokens);\n', '        owing = TotalStakedETH;\n', '        TotalStakedETH = owing.sub(tokens);\n', '        stakers[msg.sender].creationTime = block.timestamp;\n', '        stakers[msg.sender].lastClaim = stakers[msg.sender].creationTime;\n', '        emit UNSTAKED(msg.sender, tokens.sub(_unstakingFee), _unstakingFee);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Private function to calculate 1% percentage\n', '    // ------------------------------------------------------------------------\n', '    function onePercentofTokens(uint256 _tokens) private pure returns (uint256){\n', '        uint256 roundValue = _tokens.ceil(100);\n', '        uint onePerc = roundValue.mul(100).div(100 * 10**uint(2));\n', '        return onePerc;\n', '    }\n', '\n', '\n', '    function calPercentofTokens(uint256 _tokens, uint256 cust) private pure returns (uint256){\n', '        uint256 roundValue = _tokens.ceil(100);\n', '        uint256 custPercentofTokens = roundValue.mul(cust).div(100 * 10**uint(2));\n', '        return custPercentofTokens;\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the number of tokens staked by a staker\n', '    // param _staker the address of the staker\n', '    // ------------------------------------------------------------------------\n', '    function yourStakedToken(address staker) external view returns(uint256 stakedT){\n', '        return stakers[staker].stakedAmount;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the TOKEN balance of the token holder\n', '    // @param user the address of the token holder\n', '    // ------------------------------------------------------------------------\n', '    function yourTokenBalance(address user) external view returns(uint256 TBalance){\n', '        return COC(stakeTokenAdd).balanceOf(user);\n', '    }\n', '\n', '    function setPercent(uint256 percent) external onlyOwner {\n', '      require(percent < 30);\n', '        if(percent >= 1)\n', '        {\n', '         WeekRewardPercent = percent;\n', '         emit PERCENTCHANGED(msg.sender, percent);\n', '        }\n', '\n', '    }\n', '\n', '    function OwnerTeamFeesCollectorRead() external view returns(uint256 jKeeper) {\n', '        return TeamFeesCollector;\n', '    }\n', '\n', '\n', '\n', '    function yourDailyReward(address user) external view returns(uint256 RewardBalance){\n', '      uint256 timeToday = block.timestamp - creationTimeContract; //what day it is\n', '            uint256 timeT = timeToday.div(86400);\n', '            if(stakers[user].stakedAmount > 0)\n', '            {\n', '\n', '           //  if(timeT > 0)\n', '             {\n', '                  uint256 rewardToGive = calculateReward(timeT,user);\n', '                  return rewardToGive;\n', '             }//else\n', '             //{\n', '               //  return 0;\n', '             //}\n', '            }\n', '            else\n', '            {\n', '                return 0;\n', '            }\n', '\n', '\n', '\n', '\n', '\n', '\n', '    }\n', '\n', ' function MyTotalRewards(address user) external view returns(uint256 poolreward)\n', '  {\n', '\n', '      if(stakers[user].stakedAmount > 0)\n', '      {\n', '           uint256 timeToday = block.timestamp - creationTimeContract;\n', '            uint256 timeT = timeToday.div(86400);\n', '\n', '        if(timeT > 59)\n', '        {\n', '            return 0;\n', '        }\n', '        else\n', '        {\n', '        uint256 staked = SafeMath.mul(470000000000000000000, (stakers[user].stakedAmount)).div(TotalStakedETH);\n', '        return staked;\n', '\n', '        }\n', '      }\n', '      else\n', '      return 0;\n', '\n', '\n', '\n', '  }\n', '     function CLAIMREWARD() external  {\n', '\n', '            uint256 timeToday = block.timestamp - creationTimeContract; //what day it is\n', '            uint256 timeT = timeToday.div(86400);\n', '            require(stakers[msg.sender].stakedAmount > 0,"you need to stake some coins");\n', '            //require(timeT > 0,"Claim Time has not started yet");\n', '            uint256 rewardToGive = calculateReward(timeT,msg.sender);\n', '            require(MOJITO(rewardToken).transfer(msg.sender,rewardToGive), "ERROR: error in sending reward from contract");\n', '            emit CLAIMEDREWARD(msg.sender, rewardToGive);\n', '            stakers[msg.sender].TotalMRewarded = (stakers[msg.sender].TotalMRewarded).add(rewardToGive);\n', '            stakers[msg.sender].lastClaim = block.timestamp;\n', '            TotalMRewards = TotalMRewards.add(rewardToGive);\n', '\n', '\n', '\n', '    }\n', '\n', '\n', '\n', '\n', '\n', '  function calculateReward(uint timeday, address user) private view returns(uint256 rew){\n', '\n', '\n', '       uint256 totalReward = 0;\n', '\n', '      if(timeday>60) //check reward for 0 day\n', '      {\n', '         uint256 daystocheck = stakers[user].lastClaim - creationTimeContract;\n', '         uint256 daysCount = daystocheck.div(86400);  \n', '         daystocheck = 60 - daysCount;\n', '\n', '\n', '         for(uint i =daystocheck; i<60; i++)\n', '         {\n', '            uint256 rewardpday =    ((stakers[user].stakedAmount)*(rewardperday[i])).div(TotalStakedETH);\n', '            totalReward = totalReward.add(rewardpday);\n', '         }\n', '\n', '\n', '\n', '      }else\n', '      {\n', '          uint256 daystocheck = stakers[user].lastClaim - creationTimeContract;  //when did user last withdrew funds\n', '          uint256 daysCount = daystocheck.div(86400);\n', '\n', '          uint256 daystogive = block.timestamp - creationTimeContract;  //check what day it is\n', '          uint256 daysCounts = daystogive.div(86400);\n', '\n', '          if(stakers[user].lastClaim == stakers[user].creationTime)\n', '          {\n', '         \n', '          uint256 somthing = daysCount * 86400;\n', '          daystogive = 0;\n', '          if(somthing == 0 )\n', '          {\n', '        // daystogive = 86400 - daystocheck;\n', '          daystogive =  block.timestamp - stakers[user].lastClaim;\n', '             \n', '          }\n', '          else{\n', '             daystogive = daystocheck.sub(somthing);\n', '          }\n', '\n', '          if(daysCount ==  daysCounts)\n', '          {\n', '\n', '              totalReward = (((stakers[user].stakedAmount)*(rewardperday[daysCounts]))).div(TotalStakedETH);\n', '              totalReward = (totalReward.mul(daystogive)).div(86400);\n', '\n', '          }\n', '          else\n', '          {\n', '             for(uint i = daysCount; i<daysCounts; i++)\n', '            {\n', '                uint256 rewardpday = ((stakers[user].stakedAmount)*(rewardperday[i])).div(TotalStakedETH);\n', '\n', '            if(i == daysCount)\n', '            {\n', '                rewardpday = (rewardpday.mul(daystogive)).div(86400);\n', '            }\n', '                 totalReward = totalReward.add(rewardpday);\n', '            }\n', '          }\n', '\n', '          }\n', '          else\n', '          {\n', '                if(daysCount == daysCounts)\n', '                {\n', '                daystogive =  block.timestamp - stakers[user].lastClaim;\n', '                totalReward = (((stakers[user].stakedAmount)*(rewardperday[daysCounts]))).div(TotalStakedETH);\n', '                totalReward = (totalReward.mul(daystogive)).div(86400);\n', '                }\n', '                else{\n', '             for(uint i = daysCount; i<daysCounts; i++)\n', '            {\n', '                uint256 rewardpday =    ((stakers[user].stakedAmount)*(rewardperday[i])).div(TotalStakedETH);\n', '                totalReward = totalReward.add(rewardpday);\n', '            }\n', '\n', '                    }\n', '          }\n', '\n', '\n', '      }\n', '        return totalReward;\n', '  }\n', '\n', '\n', '\n', '\n', '\n', '    function TotalPoolRewards() external pure returns(uint256 tpreward)\n', '    {\n', '        return 470000000000000000000;\n', '    }\n', '\n', '\n', '    function MyTotalStaked(address user) external view returns(uint256 totalstaked)\n', '    {\n', '       return stakers[user].MyTotalStaked;\n', '    }\n', '\n', 'function CurrentTokenReward() external view returns(uint256 crrtr)\n', '    {\n', '\n', '             uint256 timeToday = block.timestamp - creationTimeContract;\n', '        uint256 timeT = timeToday.div(86400);\n', '        if(timeT > 60)\n', '        {\n', '            return 0;\n', '        }\n', '        else\n', '        {\n', '\n', '        return rewardperday[timeT];\n', '\n', '        }\n', '\n', '    }\n', '\n', 'function TotalClaimedReward() external view returns (uint256 TotalM)\n', '{\n', '    return TotalMRewards;\n', '}\n', '\n', 'function SetStakeFee(uint256 percent) external onlyOwner {\n', '  require(percent < 10);\n', '    StakingFee = percent;\n', '}\n', '\n', 'function SetUNStakeFee(uint256 percent) external onlyOwner {\n', '  require(percent < 10);\n', '    UnstakingFee = percent;\n', '}\n', '\n', '\n', '\n', '}']