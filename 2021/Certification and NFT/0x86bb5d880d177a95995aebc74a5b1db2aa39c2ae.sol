['# @version 0.2.8\n', '# @author Lido <[email\xa0protected]>\n', '# @licence MIT\n', 'from vyper.interfaces import ERC20\n', '\n', '\n', '# Lido DAO Vault (Agent) contract\n', 'interface Vault:\n', '    def deposit(_token: address, _value: uint256): payable\n', '\n', '\n', '# The purchase has been executed exchanging ETH to vested LDO\n', 'event PurchaseExecuted:\n', '    # the address that has received the vested LDO tokens\n', '    ldo_receiver: indexed(address)\n', '    # the number of LDO tokens vested to ldo_receiver\n', '    ldo_allocation: uint256\n', '    # the amount of ETH that was paid and forwarded to the DAO\n', '    eth_cost: uint256\n', "    # the vesting id to be used with the DAO's TokenManager contract\n", '    vesting_id: uint256\n', '\n', 'event OfferStarted:\n', '    started_at: uint256\n', '    expires_at: uint256\n', '\n', '\n', 'MAX_PURCHASERS: constant(uint256) = 50\n', 'ETH_TO_LDO_RATE_PRECISION: constant(uint256) = 10**18\n', '\n', 'LDO_TOKEN: constant(address) = 0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32\n', 'LIDO_DAO_TOKEN_MANAGER: constant(address) = 0xf73a1260d222f447210581DDf212D915c09a3249\n', 'LIDO_DAO_VAULT: constant(address) = 0x3e40D73EB977Dc6a537aF587D48316feE66E9C8c\n', 'LIDO_DAO_VAULT_ETH_TOKEN: constant(address) = ZERO_ADDRESS\n', '\n', '\n', '# how much LDO in one ETH, ETH_TO_LDO_RATE_PRECISION being 1\n', 'eth_to_ldo_rate: public(uint256)\n', 'ldo_allocations: public(HashMap[address, uint256])\n', 'ldo_allocations_total: public(uint256)\n', '\n', '# in seconds\n', 'offer_expiration_delay: public(uint256)\n', 'offer_started_at: public(uint256)\n', 'offer_expires_at: public(uint256)\n', 'vesting_cliff_delay: public(uint256)\n', 'vesting_end_delay: public(uint256)\n', '\n', '\n', '@external\n', 'def __init__(\n', '    _eth_to_ldo_rate: uint256,\n', '    _vesting_cliff_delay: uint256,\n', '    _vesting_end_delay: uint256,\n', '    _offer_expiration_delay: uint256,\n', '    _ldo_purchasers: address[MAX_PURCHASERS],\n', '    _ldo_allocations: uint256[MAX_PURCHASERS],\n', '    _ldo_allocations_total: uint256\n', '):\n', '    """\n', '    @param _eth_to_ldo_rate How much LDO one gets for one ETH (multiplied by 10**18)\n', '    @param _vesting_cliff_delay Delay from vesting start to vesting cliff, in seconds\n', '    @param _vesting_end_delay Delay from vesting start to vesting end, in seconds\n', '    @param _offer_expiration_delay Delay from the contract deployment to offer expiration, in seconds\n', '    @param _ldo_purchasers List of valid LDO purchasers, padded by zeroes to the length of 50\n', '    @param _ldo_allocations List of LDO token allocations, padded by zeroes to the length of 50\n', '    @param _ldo_allocations_total Checksum of LDO token allocations\n', '    """\n', '    assert _eth_to_ldo_rate > 0\n', '    assert _vesting_end_delay >= _vesting_cliff_delay\n', '    assert _offer_expiration_delay > 0\n', '\n', '    self.eth_to_ldo_rate = _eth_to_ldo_rate\n', '    self.vesting_cliff_delay = _vesting_cliff_delay\n', '    self.vesting_end_delay = _vesting_end_delay\n', '    self.offer_expiration_delay = _offer_expiration_delay\n', '    self.ldo_allocations_total = _ldo_allocations_total\n', '\n', '    allocations_sum: uint256 = 0\n', '\n', '    for i in range(MAX_PURCHASERS):\n', '        purchaser: address = _ldo_purchasers[i]\n', '        if purchaser == ZERO_ADDRESS:\n', '            break\n', '        assert self.ldo_allocations[purchaser] == 0\n', '        allocation: uint256 = _ldo_allocations[i]\n', '        assert allocation > 0\n', '        self.ldo_allocations[purchaser] = allocation\n', '        allocations_sum += allocation\n', '\n', '    assert allocations_sum == _ldo_allocations_total\n', '\n', '\n', '@internal\n', '@view\n', 'def _get_allocation(_ldo_receiver: address) -> (uint256, uint256):\n', '    ldo_allocation: uint256 = self.ldo_allocations[_ldo_receiver]\n', '    eth_cost: uint256 = (ldo_allocation * ETH_TO_LDO_RATE_PRECISION) / self.eth_to_ldo_rate\n', '    return (ldo_allocation, eth_cost)\n', '\n', '\n', '@external\n', '@view\n', 'def offer_started() -> bool:\n', '    """\n', '    @return Whether the offer has started.\n', '    """\n', '    return self.offer_started_at != 0\n', '\n', '\n', '@external\n', '@view\n', 'def offer_expired() -> bool:\n', '    """\n', '    @return Whether the offer has expired.\n', '    """\n', '    return block.timestamp >= self.offer_expires_at\n', '\n', '\n', '@internal\n', 'def _start_unless_started():\n', '    if self.offer_started_at == 0:\n', '        assert ERC20(LDO_TOKEN).balanceOf(self) == self.ldo_allocations_total, "not funded"\n', '        started_at: uint256 = block.timestamp\n', '        expires_at: uint256 = started_at + self.offer_expiration_delay\n', '        self.offer_started_at = started_at\n', '        self.offer_expires_at = expires_at\n', '        log OfferStarted(started_at, expires_at)\n', '\n', '\n', '@external\n', 'def start():\n', '    """\n', "    @notice Starts the offer if it 1) hasn't been started yet and 2) has received funding in full.\n", '    """\n', '    self._start_unless_started()\n', '\n', '\n', '@external\n', '@view\n', 'def get_allocation(_ldo_receiver: address = msg.sender) -> (uint256, uint256):\n', '    """\n', '    @param _ldo_receiver The LDO purchaser address to check\n', '    @return\n', '        A tuple: the first element is the amount of LDO available for purchase (zero if\n', '        the purchase was already executed for that address), the second element is the\n', '        Ether cost of the purchase.\n', '    """\n', '    return self._get_allocation(_ldo_receiver)\n', '\n', '\n', '@internal\n', 'def _execute_purchase(_ldo_receiver: address, _caller: address, _eth_received: uint256) -> uint256:\n', '    """\n', '    @dev\n', "        We don't use any reentrancy lock here because, among all external calls in this\n", '        function (Vault.deposit, TokenManager.assignVested, LDO.transfer, and the default\n', '        payable function of the message sender), only the last one executes the code not\n', '        under our control, and we make this call after all state mutations.\n', '    """\n', '    self._start_unless_started()\n', '    assert block.timestamp < self.offer_expires_at, "offer expired"\n', '\n', '    ldo_allocation: uint256 = 0\n', '    eth_cost: uint256 = 0\n', '    ldo_allocation, eth_cost = self._get_allocation(_ldo_receiver)\n', '\n', '    assert ldo_allocation > 0, "no allocation"\n', '    assert _eth_received >= eth_cost, "insufficient funds"\n', '\n', "    # clear the purchaser's allocation\n", '    self.ldo_allocations[_ldo_receiver] = 0\n', '\n', '    # forward ETH cost of the purchase to the DAO treasury contract\n', '    Vault(LIDO_DAO_VAULT).deposit(\n', '        LIDO_DAO_VAULT_ETH_TOKEN,\n', '        eth_cost,\n', '        value=eth_cost\n', '    )\n', '\n', '    vesting_start: uint256 = block.timestamp\n', '    vesting_cliff: uint256 = vesting_start + self.vesting_cliff_delay\n', '    vesting_end: uint256 = vesting_start + self.vesting_end_delay\n', '\n', '    # TokenManager can only assign vested tokens from its own balance\n', '    assert ERC20(LDO_TOKEN).transfer(LIDO_DAO_TOKEN_MANAGER, ldo_allocation)\n', '\n', '    # assign vested LDO tokens to the purchaser from the DAO treasury reserves\n', '    # Vyper has no uint64 data type so we have to use raw_call instead of an interface\n', '    call_result: Bytes[32] = raw_call(\n', '        LIDO_DAO_TOKEN_MANAGER,\n', '        concat(\n', "            method_id('assignVested(address,uint256,uint64,uint64,uint64,bool)'),\n", '            convert(_ldo_receiver, bytes32),\n', '            convert(ldo_allocation, bytes32),\n', '            convert(vesting_start, bytes32),\n', '            convert(vesting_cliff, bytes32),\n', '            convert(vesting_end, bytes32),\n', '            convert(False, bytes32)\n', '        ),\n', '        max_outsize=32\n', '    )\n', '    vesting_id: uint256 = convert(extract32(call_result, 0), uint256)\n', '\n', '    log PurchaseExecuted(_ldo_receiver, ldo_allocation, eth_cost, vesting_id)\n', '\n', '    # refund any excess ETH to the caller\n', '    eth_refund: uint256 = _eth_received - eth_cost\n', '    if eth_refund > 0:\n', '        # use raw_call to forward all remaining gas just in case the caller is a smart contract\n', '        raw_call(_caller, b"", value=eth_refund)\n', '\n', '    return vesting_id\n', '\n', '\n', '@external\n', '@payable\n', 'def execute_purchase(_ldo_receiver: address = msg.sender) -> uint256:\n', '    """\n', '    @notice Purchases LDO for the specified address (defaults to message sender) in exchange for ETH.\n', '    @param _ldo_receiver The address the purchase is executed for. Must be a valid purchaser.\n', "    @return Vesting ID to be used with the DAO's `TokenManager` contract.\n", '    """\n', '    return self._execute_purchase(_ldo_receiver, msg.sender, msg.value)\n', '\n', '\n', '@external\n', '@payable\n', 'def __default__():\n', '    """\n', '    @notice Purchases LDO for the message sender in exchange for ETH.\n', '    """\n', '    self._execute_purchase(msg.sender, msg.sender, msg.value)\n', '\n', '\n', '@external\n', 'def recover_unsold_tokens():\n', '    """\n', '    @notice Transfers unsold LDO tokens back to the DAO treasury.\n', '    @dev May only be called after the offer expires.\n', '    """\n', '    assert self.offer_started_at != 0 and block.timestamp >= self.offer_expires_at\n', '    unsold_ldo_amount: uint256 = ERC20(LDO_TOKEN).balanceOf(self)\n', '    if unsold_ldo_amount > 0:\n', '        ERC20(LDO_TOKEN).transfer(LIDO_DAO_VAULT, unsold_ldo_amount)']