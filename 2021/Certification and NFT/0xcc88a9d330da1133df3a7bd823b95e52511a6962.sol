['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-13\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '/// SAFEEngine.sol -- SAFE database\n', '\n', '// Copyright (C) 2018 Rain <[email\xa0protected]>\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'contract SAFEEngine {\n', '    // --- Auth ---\n', '    mapping (address => uint256) public authorizedAccounts;\n', '    /**\n', '     * @notice Add auth to an account\n', '     * @param account Account to add auth to\n', '     */\n', '    function addAuthorization(address account) external isAuthorized {\n', '        require(contractEnabled == 1, "SAFEEngine/contract-not-enabled");\n', '        authorizedAccounts[account] = 1;\n', '        emit AddAuthorization(account);\n', '    }\n', '    /**\n', '     * @notice Remove auth from an account\n', '     * @param account Account to remove auth from\n', '     */\n', '    function removeAuthorization(address account) external isAuthorized {\n', '        require(contractEnabled == 1, "SAFEEngine/contract-not-enabled");\n', '        authorizedAccounts[account] = 0;\n', '        emit RemoveAuthorization(account);\n', '    }\n', '    /**\n', '    * @notice Checks whether msg.sender can call an authed function\n', '    **/\n', '    modifier isAuthorized {\n', '        require(authorizedAccounts[msg.sender] == 1, "SAFEEngine/account-not-authorized");\n', '        _;\n', '    }\n', '\n', '    // Who can transfer collateral & debt in/out of a SAFE\n', '    mapping(address => mapping (address => uint256)) public safeRights;\n', '    /**\n', '     * @notice Allow an address to modify your SAFE\n', '     * @param account Account to give SAFE permissions to\n', '     */\n', '    function approveSAFEModification(address account) external {\n', '        safeRights[msg.sender][account] = 1;\n', '        emit ApproveSAFEModification(msg.sender, account);\n', '    }\n', '    /**\n', '     * @notice Deny an address the rights to modify your SAFE\n', '     * @param account Account that is denied SAFE permissions\n', '     */\n', '    function denySAFEModification(address account) external {\n', '        safeRights[msg.sender][account] = 0;\n', '        emit DenySAFEModification(msg.sender, account);\n', '    }\n', '    /**\n', '    * @notice Checks whether msg.sender has the right to modify a SAFE\n', '    **/\n', '    function canModifySAFE(address safe, address account) public view returns (bool) {\n', '        return either(safe == account, safeRights[safe][account] == 1);\n', '    }\n', '\n', '    // --- Data ---\n', '    struct CollateralType {\n', '        // Total debt issued for this specific collateral type\n', '        uint256 debtAmount;        // [wad]\n', '        // Accumulator for interest accrued on this collateral type\n', '        uint256 accumulatedRate;   // [ray]\n', '        // Floor price at which a SAFE is allowed to generate debt\n', '        uint256 safetyPrice;       // [ray]\n', '        // Maximum amount of debt that can be generated with this collateral type\n', '        uint256 debtCeiling;       // [rad]\n', '        // Minimum amount of debt that must be generated by a SAFE using this collateral\n', '        uint256 debtFloor;         // [rad]\n', '        // Price at which a SAFE gets liquidated\n', '        uint256 liquidationPrice;  // [ray]\n', '    }\n', '    struct SAFE {\n', '        // Total amount of collateral locked in a SAFE\n', '        uint256 lockedCollateral;  // [wad]\n', '        // Total amount of debt generated by a SAFE\n', '        uint256 generatedDebt;     // [wad]\n', '    }\n', '\n', '    // Data about each collateral type\n', '    mapping (bytes32 => CollateralType)                public collateralTypes;\n', '    // Data about each SAFE\n', '    mapping (bytes32 => mapping (address => SAFE ))    public safes;\n', '    // Balance of each collateral type\n', '    mapping (bytes32 => mapping (address => uint256))  public tokenCollateral;  // [wad]\n', '    // Internal balance of system coins\n', '    mapping (address => uint256)                       public coinBalance;      // [rad]\n', '    // Amount of debt held by an account. Coins & debt are like matter and antimatter. They nullify each other\n', '    mapping (address => uint256)                       public debtBalance;      // [rad]\n', '\n', '    // Total amount of debt that a single safe can generate\n', '    uint256 public safeDebtCeiling;      // [wad]\n', '    // Total amount of debt (coins) currently issued\n', '    uint256  public globalDebt;          // [rad]\n', "    // 'Bad' debt that's not covered by collateral\n", '    uint256  public globalUnbackedDebt;  // [rad]\n', '    // Maximum amount of debt that can be issued\n', '    uint256  public globalDebtCeiling;   // [rad]\n', '    // Access flag, indicates whether this contract is still active\n', '    uint256  public contractEnabled;\n', '\n', '    // --- Events ---\n', '    event AddAuthorization(address account);\n', '    event RemoveAuthorization(address account);\n', '    event ApproveSAFEModification(address sender, address account);\n', '    event DenySAFEModification(address sender, address account);\n', '    event InitializeCollateralType(bytes32 collateralType);\n', '    event ModifyParameters(bytes32 parameter, uint256 data);\n', '    event ModifyParameters(bytes32 collateralType, bytes32 parameter, uint256 data);\n', '    event DisableContract();\n', '    event ModifyCollateralBalance(bytes32 indexed collateralType, address indexed account, int256 wad);\n', '    event TransferCollateral(bytes32 indexed collateralType, address indexed src, address indexed dst, uint256 wad);\n', '    event TransferInternalCoins(address indexed src, address indexed dst, uint256 rad);\n', '    event ModifySAFECollateralization(\n', '        bytes32 indexed collateralType,\n', '        address indexed safe,\n', '        address collateralSource,\n', '        address debtDestination,\n', '        int256 deltaCollateral,\n', '        int256 deltaDebt,\n', '        uint256 lockedCollateral,\n', '        uint256 generatedDebt,\n', '        uint256 globalDebt\n', '    );\n', '    event TransferSAFECollateralAndDebt(\n', '        bytes32 indexed collateralType,\n', '        address indexed src,\n', '        address indexed dst,\n', '        int256 deltaCollateral,\n', '        int256 deltaDebt,\n', '        uint256 srcLockedCollateral,\n', '        uint256 srcGeneratedDebt,\n', '        uint256 dstLockedCollateral,\n', '        uint256 dstGeneratedDebt\n', '    );\n', '    event ConfiscateSAFECollateralAndDebt(\n', '        bytes32 indexed collateralType,\n', '        address indexed safe,\n', '        address collateralCounterparty,\n', '        address debtCounterparty,\n', '        int256 deltaCollateral,\n', '        int256 deltaDebt,\n', '        uint256 globalUnbackedDebt\n', '    );\n', '    event SettleDebt(address indexed account, uint256 rad, uint256 debtBalance, uint256 coinBalance, uint256 globalUnbackedDebt, uint256 globalDebt);\n', '    event CreateUnbackedDebt(\n', '        address indexed debtDestination,\n', '        address indexed coinDestination,\n', '        uint256 rad,\n', '        uint256 debtDstBalance,\n', '        uint256 coinDstBalance,\n', '        uint256 globalUnbackedDebt,\n', '        uint256 globalDebt\n', '    );\n', '    event UpdateAccumulatedRate(\n', '        bytes32 indexed collateralType,\n', '        address surplusDst,\n', '        int256 rateMultiplier,\n', '        uint256 dstCoinBalance,\n', '        uint256 globalDebt\n', '    );\n', '\n', '    // --- Init ---\n', '    constructor() public {\n', '        authorizedAccounts[msg.sender] = 1;\n', '        safeDebtCeiling = uint256(-1);\n', '        contractEnabled = 1;\n', '        emit AddAuthorization(msg.sender);\n', '        emit ModifyParameters("safeDebtCeiling", uint256(-1));\n', '    }\n', '\n', '    // --- Math ---\n', '    function addition(uint256 x, int256 y) internal pure returns (uint256 z) {\n', '        z = x + uint256(y);\n', '        require(y >= 0 || z <= x, "SAFEEngine/add-uint-int-overflow");\n', '        require(y <= 0 || z >= x, "SAFEEngine/add-uint-int-underflow");\n', '    }\n', '    function addition(int256 x, int256 y) internal pure returns (int256 z) {\n', '        z = x + y;\n', '        require(y >= 0 || z <= x, "SAFEEngine/add-int-int-overflow");\n', '        require(y <= 0 || z >= x, "SAFEEngine/add-int-int-underflow");\n', '    }\n', '    function subtract(uint256 x, int256 y) internal pure returns (uint256 z) {\n', '        z = x - uint256(y);\n', '        require(y <= 0 || z <= x, "SAFEEngine/sub-uint-int-overflow");\n', '        require(y >= 0 || z >= x, "SAFEEngine/sub-uint-int-underflow");\n', '    }\n', '    function subtract(int256 x, int256 y) internal pure returns (int256 z) {\n', '        z = x - y;\n', '        require(y <= 0 || z <= x, "SAFEEngine/sub-int-int-overflow");\n', '        require(y >= 0 || z >= x, "SAFEEngine/sub-int-int-underflow");\n', '    }\n', '    function multiply(uint256 x, int256 y) internal pure returns (int256 z) {\n', '        z = int256(x) * y;\n', '        require(int256(x) >= 0, "SAFEEngine/mul-uint-int-null-x");\n', '        require(y == 0 || z / y == int256(x), "SAFEEngine/mul-uint-int-overflow");\n', '    }\n', '    function addition(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "SAFEEngine/add-uint-uint-overflow");\n', '    }\n', '    function subtract(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "SAFEEngine/sub-uint-uint-underflow");\n', '    }\n', '    function multiply(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "SAFEEngine/multiply-uint-uint-overflow");\n', '    }\n', '\n', '    // --- Administration ---\n', '\n', '    /**\n', '     * @notice Creates a brand new collateral type\n', '     * @param collateralType Collateral type name (e.g ETH-A, TBTC-B)\n', '     */\n', '    function initializeCollateralType(bytes32 collateralType) external isAuthorized {\n', '        require(collateralTypes[collateralType].accumulatedRate == 0, "SAFEEngine/collateral-type-already-exists");\n', '        collateralTypes[collateralType].accumulatedRate = 10 ** 27;\n', '        emit InitializeCollateralType(collateralType);\n', '    }\n', '    /**\n', '     * @notice Modify general uint256 params\n', '     * @param parameter The name of the parameter modified\n', '     * @param data New value for the parameter\n', '     */\n', '    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n', '        require(contractEnabled == 1, "SAFEEngine/contract-not-enabled");\n', '        if (parameter == "globalDebtCeiling") globalDebtCeiling = data;\n', '        else if (parameter == "safeDebtCeiling") safeDebtCeiling = data;\n', '        else revert("SAFEEngine/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '    /**\n', '     * @notice Modify collateral specific params\n', '     * @param collateralType Collateral type we modify params for\n', '     * @param parameter The name of the parameter modified\n', '     * @param data New value for the parameter\n', '     */\n', '    function modifyParameters(\n', '        bytes32 collateralType,\n', '        bytes32 parameter,\n', '        uint256 data\n', '    ) external isAuthorized {\n', '        require(contractEnabled == 1, "SAFEEngine/contract-not-enabled");\n', '        if (parameter == "safetyPrice") collateralTypes[collateralType].safetyPrice = data;\n', '        else if (parameter == "liquidationPrice") collateralTypes[collateralType].liquidationPrice = data;\n', '        else if (parameter == "debtCeiling") collateralTypes[collateralType].debtCeiling = data;\n', '        else if (parameter == "debtFloor") collateralTypes[collateralType].debtFloor = data;\n', '        else revert("SAFEEngine/modify-unrecognized-param");\n', '        emit ModifyParameters(collateralType, parameter, data);\n', '    }\n', '    /**\n', '     * @notice Disable this contract (normally called by GlobalSettlement)\n', '     */\n', '    function disableContract() external isAuthorized {\n', '        contractEnabled = 0;\n', '        emit DisableContract();\n', '    }\n', '\n', '    // --- Fungibility ---\n', '    /**\n', '     * @notice Join/exit collateral into and and out of the system\n', '     * @param collateralType Collateral type we join/exit\n', '     * @param account Account that gets credited/debited\n', '     * @param wad Amount of collateral\n', '     */\n', '    function modifyCollateralBalance(\n', '        bytes32 collateralType,\n', '        address account,\n', '        int256 wad\n', '    ) external isAuthorized {\n', '        tokenCollateral[collateralType][account] = addition(tokenCollateral[collateralType][account], wad);\n', '        emit ModifyCollateralBalance(collateralType, account, wad);\n', '    }\n', '    /**\n', '     * @notice Transfer collateral between accounts\n', '     * @param collateralType Collateral type transferred\n', '     * @param src Collateral source\n', '     * @param dst Collateral destination\n', '     * @param wad Amount of collateral transferred\n', '     */\n', '    function transferCollateral(\n', '        bytes32 collateralType,\n', '        address src,\n', '        address dst,\n', '        uint256 wad\n', '    ) external {\n', '        require(canModifySAFE(src, msg.sender), "SAFEEngine/not-allowed");\n', '        tokenCollateral[collateralType][src] = subtract(tokenCollateral[collateralType][src], wad);\n', '        tokenCollateral[collateralType][dst] = addition(tokenCollateral[collateralType][dst], wad);\n', '        emit TransferCollateral(collateralType, src, dst, wad);\n', '    }\n', '    /**\n', '     * @notice Transfer internal coins (does not affect external balances from Coin.sol)\n', '     * @param src Coins source\n', '     * @param dst Coins destination\n', '     * @param rad Amount of coins transferred\n', '     */\n', '    function transferInternalCoins(address src, address dst, uint256 rad) external {\n', '        require(canModifySAFE(src, msg.sender), "SAFEEngine/not-allowed");\n', '        coinBalance[src] = subtract(coinBalance[src], rad);\n', '        coinBalance[dst] = addition(coinBalance[dst], rad);\n', '        emit TransferInternalCoins(src, dst, rad);\n', '    }\n', '\n', '    function either(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := or(x, y)}\n', '    }\n', '    function both(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := and(x, y)}\n', '    }\n', '\n', '    // --- SAFE Manipulation ---\n', '    /**\n', '     * @notice Add/remove collateral or put back/generate more debt in a SAFE\n', '     * @param collateralType Type of collateral to withdraw/deposit in and from the SAFE\n', '     * @param safe Target SAFE\n', '     * @param collateralSource Account we take collateral from/put collateral into\n', '     * @param debtDestination Account from which we credit/debit coins and debt\n', '     * @param deltaCollateral Amount of collateral added/extract from the SAFE (wad)\n', '     * @param deltaDebt Amount of debt to generate/repay (wad)\n', '     */\n', '    function modifySAFECollateralization(\n', '        bytes32 collateralType,\n', '        address safe,\n', '        address collateralSource,\n', '        address debtDestination,\n', '        int256 deltaCollateral,\n', '        int256 deltaDebt\n', '    ) external {\n', '        // system is live\n', '        require(contractEnabled == 1, "SAFEEngine/contract-not-enabled");\n', '\n', '        SAFE memory safeData = safes[collateralType][safe];\n', '        CollateralType memory collateralTypeData = collateralTypes[collateralType];\n', '        // collateral type has been initialised\n', '        require(collateralTypeData.accumulatedRate != 0, "SAFEEngine/collateral-type-not-initialized");\n', '\n', '        safeData.lockedCollateral      = addition(safeData.lockedCollateral, deltaCollateral);\n', '        safeData.generatedDebt         = addition(safeData.generatedDebt, deltaDebt);\n', '        collateralTypeData.debtAmount  = addition(collateralTypeData.debtAmount, deltaDebt);\n', '\n', '        int256 deltaAdjustedDebt = multiply(collateralTypeData.accumulatedRate, deltaDebt);\n', '        uint256 totalDebtIssued  = multiply(collateralTypeData.accumulatedRate, safeData.generatedDebt);\n', '        globalDebt               = addition(globalDebt, deltaAdjustedDebt);\n', '\n', '        // either debt has decreased, or debt ceilings are not exceeded\n', '        require(\n', '          either(\n', '            deltaDebt <= 0,\n', '            both(multiply(collateralTypeData.debtAmount, collateralTypeData.accumulatedRate) <= collateralTypeData.debtCeiling,\n', '              globalDebt <= globalDebtCeiling)\n', '            ),\n', '          "SAFEEngine/ceiling-exceeded"\n', '        );\n', '        // safe is either less risky than before, or it is safe\n', '        require(\n', '          either(\n', '            both(deltaDebt <= 0, deltaCollateral >= 0),\n', '            totalDebtIssued <= multiply(safeData.lockedCollateral, collateralTypeData.safetyPrice)\n', '          ),\n', '          "SAFEEngine/not-safe"\n', '        );\n', '\n', '        // safe is either more safe, or the owner consents\n', '        require(either(both(deltaDebt <= 0, deltaCollateral >= 0), canModifySAFE(safe, msg.sender)), "SAFEEngine/not-allowed-to-modify-safe");\n', '        // collateral src consents\n', '        require(either(deltaCollateral <= 0, canModifySAFE(collateralSource, msg.sender)), "SAFEEngine/not-allowed-collateral-src");\n', '        // debt dst consents\n', '        require(either(deltaDebt >= 0, canModifySAFE(debtDestination, msg.sender)), "SAFEEngine/not-allowed-debt-dst");\n', '\n', '        // safe has no debt, or a non-dusty amount\n', '        require(either(safeData.generatedDebt == 0, totalDebtIssued >= collateralTypeData.debtFloor), "SAFEEngine/dust");\n', '\n', "        // safe didn't go above the safe debt limit\n", '        if (deltaDebt > 0) {\n', '          require(safeData.generatedDebt <= safeDebtCeiling, "SAFEEngine/above-debt-limit");\n', '        }\n', '\n', '        tokenCollateral[collateralType][collateralSource] =\n', '          subtract(tokenCollateral[collateralType][collateralSource], deltaCollateral);\n', '\n', '        coinBalance[debtDestination] = addition(coinBalance[debtDestination], deltaAdjustedDebt);\n', '\n', '        safes[collateralType][safe] = safeData;\n', '        collateralTypes[collateralType] = collateralTypeData;\n', '\n', '        emit ModifySAFECollateralization(\n', '            collateralType,\n', '            safe,\n', '            collateralSource,\n', '            debtDestination,\n', '            deltaCollateral,\n', '            deltaDebt,\n', '            safeData.lockedCollateral,\n', '            safeData.generatedDebt,\n', '            globalDebt\n', '        );\n', '    }\n', '\n', '    // --- SAFE Fungibility ---\n', '    /**\n', '     * @notice Transfer collateral and/or debt between SAFEs\n', '     * @param collateralType Collateral type transferred between SAFEs\n', '     * @param src Source SAFE\n', '     * @param dst Destination SAFE\n', '     * @param deltaCollateral Amount of collateral to take/add into src and give/take from dst (wad)\n', '     * @param deltaDebt Amount of debt to take/add into src and give/take from dst (wad)\n', '     */\n', '    function transferSAFECollateralAndDebt(\n', '        bytes32 collateralType,\n', '        address src,\n', '        address dst,\n', '        int256 deltaCollateral,\n', '        int256 deltaDebt\n', '    ) external {\n', '        SAFE storage srcSAFE = safes[collateralType][src];\n', '        SAFE storage dstSAFE = safes[collateralType][dst];\n', '        CollateralType storage collateralType_ = collateralTypes[collateralType];\n', '\n', '        srcSAFE.lockedCollateral = subtract(srcSAFE.lockedCollateral, deltaCollateral);\n', '        srcSAFE.generatedDebt    = subtract(srcSAFE.generatedDebt, deltaDebt);\n', '        dstSAFE.lockedCollateral = addition(dstSAFE.lockedCollateral, deltaCollateral);\n', '        dstSAFE.generatedDebt    = addition(dstSAFE.generatedDebt, deltaDebt);\n', '\n', '        uint256 srcTotalDebtIssued = multiply(srcSAFE.generatedDebt, collateralType_.accumulatedRate);\n', '        uint256 dstTotalDebtIssued = multiply(dstSAFE.generatedDebt, collateralType_.accumulatedRate);\n', '\n', '        // both sides consent\n', '        require(both(canModifySAFE(src, msg.sender), canModifySAFE(dst, msg.sender)), "SAFEEngine/not-allowed");\n', '\n', '        // both sides safe\n', '        require(srcTotalDebtIssued <= multiply(srcSAFE.lockedCollateral, collateralType_.safetyPrice), "SAFEEngine/not-safe-src");\n', '        require(dstTotalDebtIssued <= multiply(dstSAFE.lockedCollateral, collateralType_.safetyPrice), "SAFEEngine/not-safe-dst");\n', '\n', '        // both sides non-dusty\n', '        require(either(srcTotalDebtIssued >= collateralType_.debtFloor, srcSAFE.generatedDebt == 0), "SAFEEngine/dust-src");\n', '        require(either(dstTotalDebtIssued >= collateralType_.debtFloor, dstSAFE.generatedDebt == 0), "SAFEEngine/dust-dst");\n', '\n', '        emit TransferSAFECollateralAndDebt(\n', '            collateralType,\n', '            src,\n', '            dst,\n', '            deltaCollateral,\n', '            deltaDebt,\n', '            srcSAFE.lockedCollateral,\n', '            srcSAFE.generatedDebt,\n', '            dstSAFE.lockedCollateral,\n', '            dstSAFE.generatedDebt\n', '        );\n', '    }\n', '\n', '    // --- SAFE Confiscation ---\n', '    /**\n', '     * @notice Normally used by the LiquidationEngine in order to confiscate collateral and\n', '       debt from a SAFE and give them to someone else\n', '     * @param collateralType Collateral type the SAFE has locked inside\n', '     * @param safe Target SAFE\n', '     * @param collateralCounterparty Who we take/give collateral to\n', '     * @param debtCounterparty Who we take/give debt to\n', '     * @param deltaCollateral Amount of collateral taken/added into the SAFE (wad)\n', '     * @param deltaDebt Amount of debt taken/added into the SAFE (wad)\n', '     */\n', '    function confiscateSAFECollateralAndDebt(\n', '        bytes32 collateralType,\n', '        address safe,\n', '        address collateralCounterparty,\n', '        address debtCounterparty,\n', '        int256 deltaCollateral,\n', '        int256 deltaDebt\n', '    ) external isAuthorized {\n', '        SAFE storage safe_ = safes[collateralType][safe];\n', '        CollateralType storage collateralType_ = collateralTypes[collateralType];\n', '\n', '        safe_.lockedCollateral = addition(safe_.lockedCollateral, deltaCollateral);\n', '        safe_.generatedDebt = addition(safe_.generatedDebt, deltaDebt);\n', '        collateralType_.debtAmount = addition(collateralType_.debtAmount, deltaDebt);\n', '\n', '        int256 deltaTotalIssuedDebt = multiply(collateralType_.accumulatedRate, deltaDebt);\n', '\n', '        tokenCollateral[collateralType][collateralCounterparty] = subtract(\n', '          tokenCollateral[collateralType][collateralCounterparty],\n', '          deltaCollateral\n', '        );\n', '        debtBalance[debtCounterparty] = subtract(\n', '          debtBalance[debtCounterparty],\n', '          deltaTotalIssuedDebt\n', '        );\n', '        globalUnbackedDebt = subtract(\n', '          globalUnbackedDebt,\n', '          deltaTotalIssuedDebt\n', '        );\n', '\n', '        emit ConfiscateSAFECollateralAndDebt(\n', '            collateralType,\n', '            safe,\n', '            collateralCounterparty,\n', '            debtCounterparty,\n', '            deltaCollateral,\n', '            deltaDebt,\n', '            globalUnbackedDebt\n', '        );\n', '    }\n', '\n', '    // --- Settlement ---\n', '    /**\n', '     * @notice Nullify an amount of coins with an equal amount of debt\n', '     * @param rad Amount of debt & coins to destroy\n', '     */\n', '    function settleDebt(uint256 rad) external {\n', '        address account       = msg.sender;\n', '        debtBalance[account]  = subtract(debtBalance[account], rad);\n', '        coinBalance[account]  = subtract(coinBalance[account], rad);\n', '        globalUnbackedDebt    = subtract(globalUnbackedDebt, rad);\n', '        globalDebt            = subtract(globalDebt, rad);\n', '        emit SettleDebt(account, rad, debtBalance[account], coinBalance[account], globalUnbackedDebt, globalDebt);\n', '    }\n', '    /**\n', '     * @notice Usually called by CoinSavingsAccount in order to create unbacked debt\n', '     * @param debtDestination Usually AccountingEngine that can settle debt with surplus\n', '     * @param coinDestination Usually CoinSavingsAccount that passes the new coins to depositors\n', '     * @param rad Amount of debt to create\n', '     */\n', '    function createUnbackedDebt(\n', '        address debtDestination,\n', '        address coinDestination,\n', '        uint256 rad\n', '    ) external isAuthorized {\n', '        debtBalance[debtDestination]  = addition(debtBalance[debtDestination], rad);\n', '        coinBalance[coinDestination]  = addition(coinBalance[coinDestination], rad);\n', '        globalUnbackedDebt            = addition(globalUnbackedDebt, rad);\n', '        globalDebt                    = addition(globalDebt, rad);\n', '        emit CreateUnbackedDebt(\n', '            debtDestination,\n', '            coinDestination,\n', '            rad,\n', '            debtBalance[debtDestination],\n', '            coinBalance[coinDestination],\n', '            globalUnbackedDebt,\n', '            globalDebt\n', '        );\n', '    }\n', '\n', '    // --- Rates ---\n', '    /**\n', '     * @notice Usually called by TaxCollector in order to accrue interest on a specific collateral type\n', '     * @param collateralType Collateral type we accrue interest for\n', '     * @param surplusDst Destination for amount of surplus created by applying the interest rate\n', "       to debt created by SAFEs with 'collateralType'\n", '     * @param rateMultiplier Multiplier applied to the debtAmount in order to calculate the surplus [ray]\n', '     */\n', '    function updateAccumulatedRate(\n', '        bytes32 collateralType,\n', '        address surplusDst,\n', '        int256 rateMultiplier\n', '    ) external isAuthorized {\n', '        require(contractEnabled == 1, "SAFEEngine/contract-not-enabled");\n', '        CollateralType storage collateralType_ = collateralTypes[collateralType];\n', '        collateralType_.accumulatedRate        = addition(collateralType_.accumulatedRate, rateMultiplier);\n', '        int256 deltaSurplus                    = multiply(collateralType_.debtAmount, rateMultiplier);\n', '        coinBalance[surplusDst]                = addition(coinBalance[surplusDst], deltaSurplus);\n', '        globalDebt                             = addition(globalDebt, deltaSurplus);\n', '        emit UpdateAccumulatedRate(\n', '            collateralType,\n', '            surplusDst,\n', '            rateMultiplier,\n', '            coinBalance[surplusDst],\n', '            globalDebt\n', '        );\n', '    }\n', '}']