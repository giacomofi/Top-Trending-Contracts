['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-14\n', '*/\n', '\n', 'pragma solidity = 0.8.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '// Leak alpha for fun and profit with https://twitter.com/mevalphaleak\n', '\n', 'contract IAlphaLeakConstants {\n', '    address internal constant TOKEN_ETH   = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address internal constant TOKEN_WETH  = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    address internal constant TOKEN_WBTC  = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n', '    address internal constant TOKEN_DAI   = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '    address internal constant TOKEN_USDC  = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '    address internal constant TOKEN_USDT  = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '\n', '    address internal constant PROXY_DYDX  = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\n', '    address internal constant ORACLE_USDC = 0x986b5E1e1755e3C2440e960477f25201B0a8bbD4;\n', '    address internal constant ORACLE_DAI  = 0x773616E4d11A78F511299002da57A0a94577F1f4;\n', '\n', '    uint256 internal constant FLAG_FLASH_DYDY_WETH     = 0x1;\n', '    uint256 internal constant FLAG_FLASH_DYDY_USDC     = 0x2;\n', '    uint256 internal constant FLAG_FLASH_DYDY_DAI      = 0x4;\n', '    uint256 internal constant FLAG_EXIT_WETH           = 0x8;\n', '\n', '    uint256 internal constant FLAG_WETH_ACCOUNTING     = 0x10;\n', '    uint256 internal constant FLAG_USDC_ACCOUNTING     = 0x20;\n', '    uint256 internal constant FLAG_DAI_ACCOUNTING      = 0x40;\n', '\n', '    uint256 internal constant FLAG_RETURN_WETH         = 0x1000;\n', '    uint256 internal constant FLAG_RETURN_USDC         = 0x2000;\n', '    uint256 internal constant FLAG_RETURN_DAI          = 0x4000;\n', '    uint256 internal constant FLAG_RETURN_CUSTOM       = 0x8000;\n', '    uint256 internal constant FLAG_RETURN_CUSTOM_SHIFT = 0x100000000000000000000;\n', '\n', '    uint256 internal constant WRAP_FLAG_TRANSFORM_ETH_TO_WETH_AFTER_APE = 0x1;\n', '    uint256 internal constant WRAP_FLAG_TRANSFORM_WETH_TO_ETH_AFTER_APE = 0x2;\n', '    uint256 internal constant WRAP_FLAG_PAY_COINBASE                    = 0x4;\n', '    uint256 internal constant WRAP_FLAG_PAY_COINBASE_BIT_SHIFT          = 0x100000000000000000000000000000000;\n', '}\n', '\n', '// All funds left on this contract will be immediately lost to snipers\n', '// This contract is completely permision-less and allows anyone to execute any arbitrary logic\n', '// Overall goal is to make a contract which allows to execute all types of nested flash loans\n', '\n', '// Third version of apeBot which is better gas optimised and performs internal call during flash-loan callbacks\n', '// Introduced support of apeBank(0x00000000454a11ca3a574738c0aab442b62d5d45)\n', 'contract ApeBotV3 is IAlphaLeakConstants {\n', '    string public constant name = "https://twitter.com/mevalphaleak";\n', '\n', '    fallback() external payable {}\n', '\n', '    function smallApeCallback(bytes calldata data) external payable {\n', '        // Added to support apeBank(0x00000000454a11ca3a574738c0aab442b62d5d45) flash loans natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(data,(uint256[])));\n', '    }\n', '    function largeApeCallback(\n', '        address,\n', '        uint wethToReturn,\n', '        uint wbtcToReturn,\n', '        uint daiToReturn,\n', '        uint usdcToReturn,\n', '        uint usdtToReturn,\n', '        bytes calldata data\n', '    ) external payable {\n', '        // Added to support apeBank(0x00000000454a11ca3a574738c0aab442b62d5d45) flash loans natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(data,(uint256[])));\n', '\n', '        // Since largeApeCallback function was used, bot operator is too lazy to return funds using generalised logic\n', '        uint256 selfBalance = address(this).balance;\n', '        if (selfBalance > 1) {\n', '            msg.sender.call{value:(selfBalance == msg.value ? selfBalance : selfBalance - 1)}(new bytes(0));\n', '        }\n', '        if (wethToReturn > 0) {\n', '            uint256 tokenBalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\n', '            if (tokenBalance > 1) {\n', '                IERC20Token(TOKEN_WETH).transfer(\n', '                    msg.sender,\n', '                    tokenBalance == wethToReturn ? tokenBalance : tokenBalance - 1\n', '                );\n', '            }\n', '        }\n', '        if (wbtcToReturn > 0) {\n', '            uint256 tokenBalance = IERC20Token(TOKEN_WBTC).balanceOf(address(this));\n', '            if (tokenBalance > 1) {\n', '                IERC20Token(TOKEN_WBTC).transfer(\n', '                    msg.sender,\n', '                    tokenBalance == wbtcToReturn ? tokenBalance : tokenBalance - 1\n', '                );\n', '            }\n', '        }\n', '        if (daiToReturn > 0) {\n', '            uint256 tokenBalance = IERC20Token(TOKEN_DAI).balanceOf(address(this));\n', '            if (tokenBalance > 1) {\n', '                IERC20Token(TOKEN_DAI).transfer(\n', '                    msg.sender,\n', '                    tokenBalance == daiToReturn ? tokenBalance : tokenBalance - 1\n', '                );\n', '            }\n', '        }\n', '        if (usdcToReturn > 0) {\n', '            uint256 tokenBalance = IERC20Token(TOKEN_USDC).balanceOf(address(this));\n', '            if (tokenBalance > 1) {\n', '                IERC20Token(TOKEN_USDC).transfer(\n', '                    msg.sender,\n', '                    tokenBalance == usdcToReturn ? tokenBalance : tokenBalance - 1\n', '                );\n', '            }\n', '        }\n', '        if (usdtToReturn > 0) {\n', '            uint256 tokenBalance = IERC20Token(TOKEN_USDT).balanceOf(address(this));\n', '            if (tokenBalance > 1) {\n', '                IERC20Token(TOKEN_USDT).transfer(\n', '                    msg.sender,\n', '                    tokenBalance == usdtToReturn ? tokenBalance : tokenBalance - 1\n', '                );\n', '            }\n', '        }\n', '    }\n', '    function callFunction(\n', '        address,\n', '        Types.AccountInfo memory,\n', '        bytes calldata data\n', '    ) external {\n', '        // Added to support DyDx flash loans natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(data,(uint256[])));\n', '    }\n', '    function executeOperation(\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        bytes calldata _params\n', '    ) external {\n', '        // Added to support AAVE v1 flash loans natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(_params,(uint256[])));\n', '    }\n', '    function executeOperation(\n', '        address[] calldata,\n', '        uint256[] calldata,\n', '        uint256[] calldata,\n', '        address,\n', '        bytes calldata params\n', '    ) external returns (bool)\n', '    {\n', '        // Added to support AAVE v2 flash loans natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(params,(uint256[])));\n', '        return true;\n', '    }\n', '\n', '    function uniswapV2Call(\n', '        address,\n', '        uint,\n', '        uint,\n', '        bytes calldata data\n', '    ) external {\n', '        // Added to support uniswap v2 flash swaps natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(data,(uint256[])));\n', '    }\n', '    function uniswapV3FlashCallback(\n', '        uint256,\n', '        uint256,\n', '        bytes calldata data\n', '    ) external {\n', '        // Added to support uniswap v3 flash loans natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(data,(uint256[])));\n', '    }\n', '    function uniswapV3MintCallback(\n', '        uint256,\n', '        uint256,\n', '        bytes calldata data\n', '    ) external {\n', '        // Added to support uniswap v3 flash mints natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(data,(uint256[])));\n', '    }\n', '    function uniswapV3SwapCallback(\n', '        int256,\n', '        int256,\n', '        bytes calldata data\n', '    ) external {\n', '        // Added to support uniswap v3 flash swaps natively\n', "        // Security checks aren't necessary since I'm an ape\n", '        eldddhzr(abi.decode(data,(uint256[])));\n', '    }\n', '    function callbackWithReturn(address tokenToReturn, uint256 balanceToReturn, bytes calldata data) external payable {\n', '        eldddhzr(abi.decode(data,(uint256[])));\n', '        if (tokenToReturn != TOKEN_ETH) {\n', '            IERC20Token(tokenToReturn).transfer(msg.sender, balanceToReturn);\n', '        } else {\n', '            msg.sender.call{value:balanceToReturn}(new bytes(0));\n', '        }\n', '    }\n', '\n', '\n', '    // Function signature 0x00000000\n', '    // Was main entry point for origin apeBot: https://etherscan.io/address/0x666f80a198412bcb987c430831b57ad61facb666#code\n', '    // Still keeping to make backend migration to the newer version easier for me\n', '    function wfjizxua(\n', '        uint256 actionFlags,\n', '        uint256[] calldata actionData\n', '    ) public payable returns(int256 ethProfitDelta) {\n', '        int256[4] memory balanceDeltas;\n', '        balanceDeltas[0] = int256(address(this).balance - msg.value);\n', '        if ((actionFlags & (FLAG_WETH_ACCOUNTING | FLAG_USDC_ACCOUNTING | FLAG_DAI_ACCOUNTING)) > 0) {\n', '            // In general ACCOUNTING flags should be used only during simulation and not production to avoid wasting gas on oracle calls\n', '            if ((actionFlags & FLAG_WETH_ACCOUNTING) > 0) {\n', '                balanceDeltas[1] = int256(IERC20Token(TOKEN_WETH).balanceOf(address(this)));\n', '            }\n', '            if ((actionFlags & FLAG_USDC_ACCOUNTING) > 0) {\n', '                balanceDeltas[2] = int256(IERC20Token(TOKEN_USDC).balanceOf(address(this)));\n', '            }\n', '            if ((actionFlags & FLAG_DAI_ACCOUNTING) > 0) {\n', '                balanceDeltas[3] = int256(IERC20Token(TOKEN_DAI).balanceOf(address(this)));\n', '            }\n', '        }\n', '\n', '        if ((actionFlags & (FLAG_FLASH_DYDY_WETH | FLAG_FLASH_DYDY_USDC | FLAG_FLASH_DYDY_DAI)) > 0) {\n', '            // This simple logic only supports single token flashloans\n', "            // For multiple tokens or multiple providers you should use general purpose logic using 'ape' function\n", '            if ((actionFlags & FLAG_FLASH_DYDY_WETH) > 0) {\n', '                uint256 balanceToFlash = IERC20Token(TOKEN_WETH).balanceOf(PROXY_DYDX);\n', '                wrapWithDyDx(\n', '                    TOKEN_WETH,\n', '                    balanceToFlash - 1,\n', '                    IERC20Token(TOKEN_WETH).allowance(address(this), PROXY_DYDX) < balanceToFlash,\n', '                    abi.encode(actionData)\n', '                );\n', '            } else if ((actionFlags & FLAG_FLASH_DYDY_USDC) > 0) {\n', '                uint256 balanceToFlash = IERC20Token(TOKEN_USDC).balanceOf(PROXY_DYDX);\n', '                wrapWithDyDx(\n', '                    TOKEN_USDC,\n', '                    balanceToFlash - 1,\n', '                    IERC20Token(TOKEN_USDC).allowance(address(this), PROXY_DYDX) < balanceToFlash,\n', '                    abi.encode(actionData)\n', '                );\n', '            } else if ((actionFlags & FLAG_FLASH_DYDY_DAI) > 0) {\n', '                uint256 balanceToFlash = IERC20Token(TOKEN_DAI).balanceOf(PROXY_DYDX);\n', '                wrapWithDyDx(\n', '                    TOKEN_DAI,\n', '                    balanceToFlash - 1,\n', '                    IERC20Token(TOKEN_DAI).allowance(address(this), PROXY_DYDX) < balanceToFlash,\n', '                    abi.encode(actionData)\n', '                );\n', '            }\n', '        } else {\n', '            eldddhzr(actionData);\n', '        }\n', '\n', '        if ((actionFlags & FLAG_EXIT_WETH) > 0) {\n', '            uint wethbalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\n', '            if (wethbalance > 1) WETH9(TOKEN_WETH).withdraw(wethbalance - 1);\n', '        }\n', '\n', '        ethProfitDelta = int256(address(this).balance) - balanceDeltas[0];\n', '        if ((actionFlags & (FLAG_WETH_ACCOUNTING | FLAG_USDC_ACCOUNTING | FLAG_DAI_ACCOUNTING)) > 0) {\n', '            // In general ACCOUNTING flags should be used only during simulation and not production to avoid wasting gas on oracle calls\n', '            if ((actionFlags & FLAG_WETH_ACCOUNTING) > 0) {\n', '                ethProfitDelta += int256(IERC20Token(TOKEN_WETH).balanceOf(address(this))) - balanceDeltas[1];\n', '            }\n', '            if ((actionFlags & FLAG_USDC_ACCOUNTING) > 0) {\n', '                ethProfitDelta += (int256(IERC20Token(TOKEN_USDC).balanceOf(address(this))) - balanceDeltas[2]) * IChainlinkAggregator(ORACLE_USDC).latestAnswer() / (1 ether);\n', '            }\n', '            if ((actionFlags & FLAG_DAI_ACCOUNTING) > 0) {\n', '                ethProfitDelta += (int256(IERC20Token(TOKEN_DAI).balanceOf(address(this))) - balanceDeltas[3]) * IChainlinkAggregator(ORACLE_DAI).latestAnswer() / (1 ether);\n', '            }\n', '        }\n', '\n', '\n', '        uint selfBalance = address(this).balance;\n', '        if (selfBalance > 1 && msg.sender != address(this)) {\n', '            msg.sender.call{value:selfBalance - 1}(new bytes(0));\n', '        }\n', '        if ((actionFlags & (FLAG_RETURN_WETH | FLAG_RETURN_USDC | FLAG_RETURN_DAI | FLAG_RETURN_CUSTOM)) > 0 && msg.sender != address(this)) {\n', '            // Majority of simple atomic arbs should just need ETH\n', '            if ((actionFlags & FLAG_RETURN_WETH) > 0) {\n', '                uint tokenBalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\n', '                if (tokenBalance > 1) IERC20Token(TOKEN_WETH).transfer(msg.sender, tokenBalance - 1);\n', '            }\n', '            if ((actionFlags & FLAG_RETURN_USDC) > 0) {\n', '                uint tokenBalance = IERC20Token(TOKEN_USDC).balanceOf(address(this));\n', '                if (tokenBalance > 1) IERC20Token(TOKEN_USDC).transfer(msg.sender, tokenBalance - 1);\n', '            }\n', '            if ((actionFlags & FLAG_RETURN_DAI) > 0) {\n', '                uint tokenBalance = IERC20Token(TOKEN_DAI).balanceOf(address(this));\n', '                if (tokenBalance > 1) IERC20Token(TOKEN_DAI).transfer(msg.sender, tokenBalance - 1);\n', '            }\n', '            if ((actionFlags & FLAG_RETURN_CUSTOM) > 0) {\n', '                address tokenAddr = address(uint160(actionFlags / FLAG_RETURN_CUSTOM_SHIFT));\n', '                if (tokenAddr != TOKEN_ETH) {\n', "                    // We've already returned ETH above\n", '                    uint tokenBalance = IERC20Token(tokenAddr).balanceOf(address(this));\n', '                    if (tokenBalance > 1) IERC20Token(tokenAddr).transfer(msg.sender, tokenBalance - 1);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    // Function signature 0x0000000f\n', '    function eldddhzr(uint256[] memory actionData) public {\n', '        ape(actionData);\n', '\n', '        if ((actionData[0] & (WRAP_FLAG_TRANSFORM_ETH_TO_WETH_AFTER_APE | WRAP_FLAG_TRANSFORM_WETH_TO_ETH_AFTER_APE | WRAP_FLAG_PAY_COINBASE)) > 0) {\n', '            uint256 wrapFlags = actionData[0];\n', '            if ((wrapFlags & WRAP_FLAG_TRANSFORM_WETH_TO_ETH_AFTER_APE) > 0) {\n', '                uint wethbalance = IERC20Token(TOKEN_WETH).balanceOf(address(this));\n', '                if (wethbalance > 1) WETH9(TOKEN_WETH).withdraw(wethbalance - 1);\n', '                if ((wrapFlags & WRAP_FLAG_PAY_COINBASE) > 0) {\n', '                    block.coinbase.call{value:(wrapFlags / WRAP_FLAG_PAY_COINBASE_BIT_SHIFT)}(new bytes(0));\n', '                }\n', '            } else {\n', '                uint selfBalance = address(this).balance;\n', '                if ((wrapFlags & WRAP_FLAG_PAY_COINBASE) > 0) {\n', '                    uint amountToPay = wrapFlags / WRAP_FLAG_PAY_COINBASE_BIT_SHIFT;\n', '                    if (selfBalance < amountToPay) {\n', '                        WETH9(TOKEN_WETH).withdraw(amountToPay - selfBalance);\n', '                        selfBalance = 0;\n', '                    } else {\n', '                        selfBalance -= amountToPay;\n', '                    }\n', '                    block.coinbase.call{value:amountToPay}(new bytes(0));\n', '                }\n', '                if (((wrapFlags & WRAP_FLAG_TRANSFORM_ETH_TO_WETH_AFTER_APE) > 0) && selfBalance > 1) {\n', '                    WETH9(TOKEN_WETH).deposit{value: selfBalance - 1}();\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    function ape(uint256[] memory data) internal {\n', '        // data[0] was used for wrapFlags inside 0x0000000f function\n', '        uint callId = 1;\n', '        for (; callId < data.length;) {\n', '            assembly {\n', '                let callInfo := mload(add(data, mul(add(callId, 1), 0x20)))\n', '                let callLength := and(div(callInfo, 0x1000000000000000000000000000000000000000000000000000000), 0xffff)\n', '                let p := mload(0x40)   // Find empty storage location using "free memory pointer"\n', '                // Place signature at begining of empty storage, hacky logic to compute shift here\n', '                let callSignDataShiftResult := mul(and(callInfo, 0xffffffff0000000000000000000000000000000000000000000000), 0x10000000000)\n', '                switch callSignDataShiftResult\n', '                case 0 {\n', '                    callLength := mul(callLength, 0x20)\n', '                    callSignDataShiftResult := add(data, mul(0x20, add(callId, 3)))\n', '                    for { let i := 0 } lt(i, callLength) { i := add(i, 0x20) } {\n', '                        mstore(add(p, i), mload(add(callSignDataShiftResult, i)))\n', '                    }\n', '                }\n', '                default {\n', '                    mstore(p, callSignDataShiftResult)\n', '                    callLength := add(mul(callLength, 0x20), 4)\n', '                    callSignDataShiftResult := add(data, sub(mul(0x20, add(callId, 3)), 4))\n', '                    for { let i := 4 } lt(i, callLength) { i := add(i, 0x20) } {\n', '                        mstore(add(p, i), mload(add(callSignDataShiftResult, i)))\n', '                    }\n', '                }\n', '\n', '                mstore(0x40, add(p, add(callLength, 0x20)))\n', '                // new free pointer position after the output values of the called function.\n', '\n', '                let callContract := and(callInfo, 0xffffffffffffffffffffffffffffffffffffffff)\n', '                // Re-use callSignDataShiftResult as success\n', '                switch and(callInfo, 0xf000000000000000000000000000000000000000000000000000000000000000)\n', '                case 0x1000000000000000000000000000000000000000000000000000000000000000 {\n', '                    callSignDataShiftResult := delegatecall(\n', '                                    and(div(callInfo, 0x10000000000000000000000000000000000000000), 0xffffff), // allowed gas to use\n', '                                    callContract, // contract to execute\n', '                                    p,    // Inputs are at location p\n', '                                    callLength, //Inputs size\n', '                                    p,    //Store output over input\n', '                                    0x20) //Output is 32 bytes long\n', '                }\n', '                default {\n', '                    callSignDataShiftResult := call(\n', '                                    and(div(callInfo, 0x10000000000000000000000000000000000000000), 0xffffff), // allowed gas to use\n', '                                    callContract, // contract to execute\n', '                                    mload(add(data, mul(add(callId, 2), 0x20))), // wei value amount\n', '                                    p,    // Inputs are at location p\n', '                                    callLength, //Inputs size\n', '                                    p,    //Store output over input\n', '                                    0x20) //Output is 32 bytes long\n', '                }\n', '\n', '                callSignDataShiftResult := and(div(callInfo, 0x10000000000000000000000000000000000000000000000000000000000), 0xff)\n', '                if gt(callSignDataShiftResult, 0) {\n', "                    // We're copying call result as input to some futher call\n", '                    mstore(add(data, mul(callSignDataShiftResult, 0x20)), mload(p))\n', '                }\n', '                callId := add(callId, add(and(div(callInfo, 0x1000000000000000000000000000000000000000000000000000000), 0xffff), 2))\n', '                mstore(0x40, p) // Set storage pointer to empty space\n', '            }\n', '        }\n', '    }\n', '\n', '    // Executing DyDx flash-loans with generalised logic above is quite inefficient, this helper function attempts to decrease gas cost a bit\n', '    function wrapWithDyDx(address requiredToken, uint256 requiredBalance, bool requiredApprove, bytes memory data) public {\n', '        Types.ActionArgs[] memory operations = new Types.ActionArgs[](3);\n', '        operations[0] = Types.ActionArgs({\n', '            actionType: Types.ActionType.Withdraw,\n', '            accountId: 0,\n', '            amount: Types.AssetAmount({\n', '                sign: false,\n', '                denomination: Types.AssetDenomination.Wei,\n', '                ref: Types.AssetReference.Delta,\n', '                value: requiredBalance\n', '            }),\n', '            primaryMarketId: marketIdFromTokenAddress(requiredToken),\n', '            secondaryMarketId: 0,\n', '            otherAddress: address(this),\n', '            otherAccountId: 0,\n', '            data: ""\n', '        });\n', '        operations[1] = Types.ActionArgs({\n', '            actionType: Types.ActionType.Call,\n', '            accountId: 0,\n', '            amount: Types.AssetAmount({\n', '                sign: false,\n', '                denomination: Types.AssetDenomination.Wei,\n', '                ref: Types.AssetReference.Delta,\n', '                value: 0\n', '            }),\n', '            primaryMarketId: 0,\n', '            secondaryMarketId: 0,\n', '            otherAddress: address(this),\n', '            otherAccountId: 0,\n', '            data: data\n', '        });\n', '        operations[2] = Types.ActionArgs({\n', '            actionType: Types.ActionType.Deposit,\n', '            accountId: 0,\n', '            amount: Types.AssetAmount({\n', '                sign: true,\n', '                denomination: Types.AssetDenomination.Wei,\n', '                ref: Types.AssetReference.Delta,\n', '                value: requiredBalance + (requiredToken == TOKEN_WETH ? 1 : 2)\n', '            }),\n', '            primaryMarketId: marketIdFromTokenAddress(requiredToken),\n', '            secondaryMarketId: 0,\n', '            otherAddress: address(this),\n', '            otherAccountId: 0,\n', '            data: ""\n', '        });\n', '\n', '        Types.AccountInfo[] memory accountInfos = new Types.AccountInfo[](1);\n', '        accountInfos[0] = Types.AccountInfo({\n', '            owner: address(this),\n', '            number: 1\n', '        });\n', '        if (requiredApprove) {\n', '          // Approval might be already set or can be set inside of callback function\n', '          IERC20Token(requiredToken).approve(\n', '            PROXY_DYDX,\n', '            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n', '          );\n', '        }\n', '        ISoloMargin(PROXY_DYDX).operate(accountInfos, operations);\n', '    }\n', '    function marketIdFromTokenAddress(address tokenAddress) internal pure returns (uint256 resultId) {\n', '        assembly {\n', '            switch tokenAddress\n', '            case 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2 {\n', '                resultId := 0\n', '            }\n', '            case 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48 {\n', '                resultId := 2\n', '            }\n', '            case 0x6B175474E89094C44Da98b954EedeAC495271d0F {\n', '                resultId := 3\n', '            }\n', '            default {\n', '                revert(0, 0)\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'interface ISoloMargin {\n', '    function operate(Types.AccountInfo[] memory accounts, Types.ActionArgs[] memory actions) external;\n', '    function getMarketTokenAddress(uint256 marketId) external view returns (address);\n', '}\n', 'interface IERC20Token {\n', '    function balanceOf(address _owner) external view returns (uint256);\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '}\n', 'interface WETH9 {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', 'interface IGasToken {\n', '    function free(uint256 value) external returns (uint256);\n', '}\n', 'interface IChainlinkAggregator {\n', '  function latestAnswer() external view returns (int256);\n', '}\n', '\n', 'library Types {\n', '    enum ActionType {\n', '        Deposit,   // supply tokens\n', '        Withdraw,  // borrow tokens\n', '        Transfer,  // transfer balance between accounts\n', '        Buy,       // buy an amount of some token (externally)\n', '        Sell,      // sell an amount of some token (externally)\n', '        Trade,     // trade tokens against another account\n', '        Liquidate, // liquidate an undercollateralized or expiring account\n', '        Vaporize,  // use excess tokens to zero-out a completely negative account\n', '        Call       // send arbitrary data to an address\n', '    }\n', '\n', '    enum AssetDenomination {\n', '        Wei, // the amount is denominated in wei\n', '        Par  // the amount is denominated in par\n', '    }\n', '\n', '    enum AssetReference {\n', '        Delta, // the amount is given as a delta from the current value\n', '        Target // the amount is given as an exact number to end up at\n', '    }\n', '\n', '    struct AssetAmount {\n', '        bool sign; // true if positive\n', '        AssetDenomination denomination;\n', '        AssetReference ref;\n', '        uint256 value;\n', '    }\n', '\n', '    struct Wei {\n', '        bool sign; // true if positive\n', '        uint256 value;\n', '    }\n', '\n', '    struct ActionArgs {\n', '        ActionType actionType;\n', '        uint256 accountId;\n', '        AssetAmount amount;\n', '        uint256 primaryMarketId;\n', '        uint256 secondaryMarketId;\n', '        address otherAddress;\n', '        uint256 otherAccountId;\n', '        bytes data;\n', '    }\n', '\n', '    struct AccountInfo {\n', '        address owner;  // The address that owns the account\n', '        uint256 number; // A nonce that allows a single address to control many accounts\n', '    }\n', '}']