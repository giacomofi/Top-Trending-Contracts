['/*\n', '  Copyright 2019,2020 StarkWare Industries Ltd.\n', '\n', '  Licensed under the Apache License, Version 2.0 (the "License").\n', '  You may not use this file except in compliance with the License.\n', '  You may obtain a copy of the License at\n', '\n', '  https://www.starkware.co/open-source-license/\n', '\n', '  Unless required by applicable law or agreed to in writing,\n', '  software distributed under the License is distributed on an "AS IS" BASIS,\n', '  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '  See the License for the specific language governing permissions\n', '  and limitations under the License.\n', '*/\n', '// SPDX-License-Identifier: Apache-2.0.\n', 'pragma solidity ^0.6.11;\n', '\n', 'import "FactRegistry.sol";\n', 'import "PedersenMerkleVerifier.sol";\n', 'import "Identity.sol";\n', 'import "ProgramOutputOffsets.sol";\n', '\n', '/*\n', '  A PerpetualEscapeVerifier is a fact registry contract for claims of the form:\n', "    The owner of 'publicKey' may withdraw 'withdrawalAmount' qunatized collateral units\n", "    from 'positionId' assuming the hash of the shared state is 'sharedStateHash'\n", '\n', '  The fact is encoded as:\n', '    keccak256(abi.encodePacked(\n', '        publicKey, withdrawalAmount, sharedStateHash, positionId).\n', '*/\n', 'contract PerpetualEscapeVerifier is\n', '    PedersenMerkleVerifier, FactRegistry,\n', '    Identity, ProgramOutputOffsets {\n', '    event LogEscapeVerified(\n', '        uint256 publicKey,\n', '        int256 withdrawalAmount,\n', '        bytes32 sharedStateHash,\n', '        uint256 positionId\n', '    );\n', '\n', '    uint256 internal constant N_ASSETS_BITS = 16;\n', '    uint256 internal constant BALANCE_BITS = 64;\n', '    uint256 internal constant FUNDING_BITS = 64;\n', '    uint256 internal constant BALANCE_BIAS = 2**63;\n', '    uint256 internal constant FXP_BITS = 32;\n', '\n', '    uint256 internal constant FUNDING_ENTRY_SIZE = 2;\n', '    uint256 internal constant PRICE_ENTRY_SIZE = 2;\n', '\n', '    constructor(address[N_TABLES] memory tables)\n', '        PedersenMerkleVerifier(tables)\n', '        public\n', '    {\n', '    }\n', '\n', '    function identify()\n', '        external pure override virtual\n', '        returns(string memory)\n', '    {\n', '        return "StarkWare_PerpetualEscapeVerifier_2021_2";\n', '    }\n', '\n', '    /*\n', '      Finds an entry corresponding to assetId in the slice array[startIdx:endIdx].\n', '      Assumes that size of each entry is 2 and that the key is in offset 0 of an entry.\n', '    */\n', '    function findAssetId(\n', '        uint256 assetId, uint256[] memory array, uint256 startIdx, uint256 endIdx)\n', '        internal pure returns (uint256 idx) {\n', '        idx = startIdx;\n', '        while(array[idx] != assetId) {\n', '            idx += /*entry_size*/2;\n', '            require(idx < endIdx, "assetId not found.");\n', '        }\n', '    }\n', '\n', '\n', '    /*\n', '      Computes the balance of the position according to the sharedState.\n', '\n', '      Assumes the position is given as\n', '      [\n', '       positionAsset_0, positionAsset_1, ..., positionAsset_{n_assets},\n', '       publicKey, biasedBalance << N_ASSETS_BITS | nAssets,\n', '      ]\n', '      where positionAsset_{i} is encoded as\n', '         assedId << 128 | cachedFunding << BALANCE_BITS | biased_asset_balance.\n', '\n', '    */\n', '    function computeFxpBalance(\n', '        uint256[] memory position, uint256[] memory sharedState)\n', '        internal pure returns (int256) {\n', '\n', '        uint256 nAssets;\n', '        uint256 fxpBalance;\n', '\n', '        {\n', '            // Decode collateral_balance and nAssets.\n', '            uint256 lastWord = position[position.length - 1];\n', '            nAssets = lastWord & ((1 << N_ASSETS_BITS) - 1);\n', '            uint256 biasedBalance = lastWord >> N_ASSETS_BITS;\n', '\n', '            require(position.length == nAssets + 2, "Bad number of assets.");\n', '            require(biasedBalance < 2**BALANCE_BITS, "Bad balance.");\n', '\n', '            fxpBalance = (biasedBalance - BALANCE_BIAS) << FXP_BITS;\n', '        }\n', '\n', '        uint256 fundingIndicesOffset = STATE_OFFSET_FUNDING;\n', '        uint256 nFundingIndices = sharedState[fundingIndicesOffset - 1];\n', '\n', '        uint256 fundingEnd = fundingIndicesOffset + FUNDING_ENTRY_SIZE * nFundingIndices;\n', '\n', '        // Skip global_funding_indices.timestamp and nPrices.\n', '        uint256 pricesOffset = fundingEnd + 2;\n', '        uint256 nPrices = sharedState[pricesOffset - 1];\n', '        uint256 pricesEnd = pricesOffset + PRICE_ENTRY_SIZE * nPrices;\n', '        // Copy sharedState ptr to workaround stack too deep.\n', '        uint256[] memory sharedStateCopy = sharedState;\n', '\n', '        uint256 fundingTotal = 0;\n', '        for (uint256 i = 0; i < nAssets; i++) {\n', '            // Decodes a positionAsset (See encoding in the function description).\n', '            uint256 positionAsset = position[i];\n', '            uint256 assedId = positionAsset >> 128;\n', '\n', '            // Note that the funding_indices in both the position and the shared state\n', '            // are biased by the same amount.\n', '            uint256 cachedFunding = (positionAsset >> BALANCE_BITS) & (2**FUNDING_BITS - 1);\n', '            uint256 assetBalance = (positionAsset & (2**BALANCE_BITS - 1)) - BALANCE_BIAS;\n', '\n', '            fundingIndicesOffset = findAssetId(\n', '                assedId, sharedStateCopy, fundingIndicesOffset, fundingEnd);\n', '            fundingTotal -= assetBalance *\n', '                (sharedStateCopy[fundingIndicesOffset + 1] - cachedFunding);\n', '\n', '            pricesOffset = findAssetId(assedId, sharedStateCopy, pricesOffset, pricesEnd);\n', '            fxpBalance += assetBalance * sharedStateCopy[pricesOffset + 1];\n', '        }\n', '\n', '        uint256 truncatedFunding = fundingTotal & ~(2**FXP_BITS - 1);\n', '        return int256(fxpBalance + truncatedFunding);\n', '    }\n', '\n', '\n', '    /*\n', '      Extracts the position from the escapeProof.\n', '\n', '      Assumes the position is encoded in the first (nAssets + 2) right nodes in the merkleProof.\n', '      and that each pair of nodes is encoded in 2 256bits words as follows:\n', '      +-------------------------------+---------------------------+-----------+\n', '      | left_node_i (252)             | right_node_i (252)        | zeros (8) |\n', '      +-------------------------------+---------------------------+-----------+\n', '\n', '      See PedersenMerkleVerifier.sol for more details.\n', '    */\n', '    function extractPosition(uint256[] memory merkleProof, uint256 nAssets)\n', '        internal pure\n', '        returns (uint256 positionId, uint256[] memory position) {\n', '\n', "        require((merkleProof[0] >> 8) == 0, 'Position hash-chain must start with 0.');\n", '\n', '        uint256 positionLength = nAssets + 2;\n', '        position = new uint256[](positionLength);\n', '        uint256 nodeIdx = merkleProof[merkleProof.length - 1] >> 8;\n', '\n', "        // Check that the merkleProof starts with a hash_chain of 'positionLength' elements.\n", '        require(\n', '            (nodeIdx & ((1 << positionLength) - 1)) == 0,\n', '            "merkleProof is inconsistent with nAssets.");\n', '        positionId = nodeIdx >> positionLength;\n', '\n', '        assembly {\n', '            let positionPtr := add(position, 0x20)\n', '            let positionEnd := add(positionPtr, mul(mload(position), 0x20))\n', '            let proofPtr := add(merkleProof, 0x3f)\n', '\n', '            for { } lt(positionPtr, positionEnd)  { positionPtr := add(positionPtr, 0x20) } {\n', '                mstore(positionPtr, and(mload(proofPtr),\n', '                       0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))\n', '                proofPtr := add(proofPtr, 0x40)\n', '            }\n', '        }\n', '    }\n', '\n', '\n', '    /*\n', '      Verifies an escape and registers the corresponding fact as\n', '        keccak256(abi.encodePacked(\n', '            publicKey, withdrawalAmount, sharedStateHash, positionId)).\n', '\n', '      The escape verification has two parts:\n', '        a. verifying that a certain position belongs to the position tree in the shared state.\n', '        b. computing the amount that may be withdrawan from that position.\n', '\n', '      Part a is delegated to the PedersenMerkleVerifier.\n', '      To this end the position is encoded in the prefix of the merkleProof and the node_selector at\n', '      the end of the merkleProof is adjusted accordingly.\n', '    */\n', '    function verifyEscape(\n', '        uint256[] calldata merkleProof, uint256 nAssets, uint256[] calldata sharedState) external {\n', '        (uint256 positionId, uint256[] memory position) = extractPosition(merkleProof, nAssets);\n', '\n', '        int256 withdrawalAmount = computeFxpBalance(position, sharedState) >> FXP_BITS;\n', '\n', '        // Each hash takes 2 256bit words and the last two words are the root and nodeIdx.\n', '        uint256 nHashes = (merkleProof.length - 2) / 2; // NOLINT: divide-before-multiply.\n', '        uint256 positionTreeHeight = nHashes - position.length;\n', '\n', '        require(\n', '            sharedState[STATE_OFFSET_VAULTS_ROOT] == (merkleProof[merkleProof.length - 2] >> 4),\n', '            "merkleProof is inconsistent with the root in the sharedState.");\n', '\n', '        require(\n', '            sharedState[STATE_OFFSET_VAULTS_HEIGHT] == positionTreeHeight,\n', '            "merkleProof is inconsistent with the height in the sharedState.");\n', '\n', '        require(withdrawalAmount > 0, "Withdrawal amount must be positive.");\n', '        bytes32 sharedStateHash = keccak256(abi.encodePacked(sharedState));\n', '\n', '        uint256 publicKey = position[nAssets];\n', '        emit LogEscapeVerified(publicKey, withdrawalAmount, sharedStateHash, positionId);\n', '        bytes32 fact = keccak256(\n', '            abi.encodePacked(\n', '            publicKey, withdrawalAmount, sharedStateHash, positionId));\n', '\n', '        verifyMerkle(merkleProof);\n', '\n', '        registerFact(fact);\n', '    }\n', '}']