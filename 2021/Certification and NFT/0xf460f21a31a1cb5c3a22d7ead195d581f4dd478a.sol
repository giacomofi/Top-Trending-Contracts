['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath {\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', "    require(c / a == b, 'SafeMath: multiplication overflow');\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the integer division of two unsigned integers. Reverts on\n', '   * division by zero. The result is rounded towards zero.\n', '   *\n', "   * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '   * uses an invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    return div(a, b, 'SafeMath: division by zero');\n", '  }\n', '\n', '  /**\n', '   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '   * division by zero. The result is rounded towards zero.\n', '   *\n', "   * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '   * uses an invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function div(\n', '    uint256 a,\n', '    uint256 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint256) {\n', '    // Solidity only automatically asserts when dividing by 0\n', '    require(b > 0, errorMessage);\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '}\n', '\n', 'interface IExtendedAggregator {\n', '    function getToken() external view returns (address);\n', '    function getTokenType() external view returns (uint256);\n', '    function getSubTokens() external view returns(address[] memory);\n', '    function latestAnswer() external view returns (int256);\n', '}\n', '\n', 'interface IERC2O {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', 'contract XSushiPriceAdapter is IExtendedAggregator {\n', '    using SafeMath for uint256;\n', '    address public immutable SUSHI = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\n', '    address public immutable xSUSHI = 0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272;\n', '    address public immutable SUSHI_ORACLE = 0xe572CeF69f43c2E488b33924AF04BDacE19079cf;\n', '    \n', '    enum ProxyType {Invalid, Simple, Complex}\n', '    \n', '    function getToken() external view override returns(address) {\n', '        return xSUSHI;\n', '    }\n', '    function getTokenType() external view override returns (uint256) {\n', '        return uint256(ProxyType.Complex);\n', '    }\n', ' \n', '    function getSubTokens() external view override returns(address[] memory) {\n', '        address[] memory _subtTokens = new address[](1);\n', '        _subtTokens[0] = SUSHI;\n', '        return _subtTokens;\n', '    }\n', '    function latestAnswer() external view override returns (int256) {\n', '        uint256 exchangeRate = IERC2O(SUSHI).balanceOf(xSUSHI).div(IERC2O(xSUSHI).totalSupply());\n', '        uint256 sushiPrice = uint256(IExtendedAggregator(SUSHI_ORACLE).latestAnswer());\n', '        return int256(sushiPrice.mul(exchangeRate));\n', '    }\n', '}']