['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-14\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', '/// UNIV2LPOracle.sol\n', '\n', '// Copyright (C) 2017-2020 Maker Ecosystem Growth Holdings, INC.\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', '///////////////////////////////////////////////////////\n', '//                                                   //\n', '//    Methodology for Calculating LP Token Price     //\n', '//                                                   //\n', '///////////////////////////////////////////////////////\n', '\n', '// A naÃ¯ve approach to calculate the price of LP tokens, assuming the protocol\n', '// fee is zero, is to compute the price of the assets locked in its liquidity\n', '// pool, and divide it by the total amount of LP tokens issued:\n', '//\n', '// (p_0 * r_0 + p_1 * r_1) / LP_supply              (1)\n', '//\n', '// where r_0 and r_1 are the reserves of the two tokens held by the pool, and\n', '// p_0 and p_1 are their respective prices in some reference unit of account.\n', '//\n', '// However, the price of LP tokens (i.e. pool shares) needs to be evaluated\n', '// based on reserve values r_0 and r_1 that cannot be arbitraged, i.e. values\n', '// that give the two halves of the pool equal economic value:\n', '//\n', '// r_0 * p_0 = r_1 * p_1                            (2)\n', '// \n', '// Furthermore, two-asset constant product pools, neglecting fees, satisfy\n', '// (before and after trades):\n', '//\n', '// r_0 * r_1 = k                                    (3)\n', '//\n', '// Using (2) and (3) we can compute R_i, the arbitrage-free reserve values, in a\n', '// manner that depends only on k (which can be derived from the current reserve\n', '// balances, even if they are far from equilibrium) and market prices p_i\n', '// obtained from a trusted source:\n', '//\n', '// R_0 = sqrt(k * p_1 / p_0)                        (4)\n', '//   and\n', '// R_1 = sqrt(k * p_0 / p_1)                        (5)\n', '//\n', '// The value of an LP token is then, replacing (4) and (5) in (1):\n', '//\n', '// (p_0 * R_0 + p_1 * R_1) / LP_supply\n', '//     = 2 * sqrt(k * p_0 * p_1) / LP_supply        (6)\n', '//\n', '// k can be re-expressed in terms of the current pool reserves r_0 and r_1:\n', '//\n', '// 2 * sqrt((r_0 * p_0) * (r_1 * p_1)) / LP_supply  (7)\n', '//\n', '// The structure of (7) is well-suited for use in fixed-point EVM calculations, as the\n', '// terms (r_0 * p_0) and (r_1 * p_1), being the values of the reserves in the reference unit,\n', '// should have reasonably-bounded sizes. This reduces the likelihood of overflow due to\n', '// tokens with very low prices but large total supplies.\n', '\n', 'pragma solidity =0.6.12;\n', '\n', 'interface ERC20Like {\n', '    function decimals()         external view returns (uint8);\n', '    function balanceOf(address) external view returns (uint256);\n', '    function totalSupply()      external view returns (uint256);\n', '}\n', '\n', 'interface UniswapV2PairLike {\n', '    function sync()        external;\n', '    function token0()      external view returns (address);\n', '    function token1()      external view returns (address);\n', '    function getReserves() external view returns (uint112,uint112,uint32);  // reserve0, reserve1, blockTimestampLast\n', '}\n', '\n', 'interface OracleLike {\n', '    function read() external view returns (uint256);\n', '}\n', '\n', '// Factory for creating Uniswap V2 LP Token Oracle instances\n', 'contract UNIV2LPOracleFactory {\n', '\n', '    mapping(address => bool) public isOracle;\n', '\n', '    event NewUNIV2LPOracle(address owner, address orcl, bytes32 wat, address indexed tok0, address indexed tok1, address orb0, address orb1);\n', '\n', '    // Create new Uniswap V2 LP Token Oracle instance\n', '    function build(\n', '        address _owner,\n', '        address _src,\n', '        bytes32 _wat,\n', '        address _orb0,\n', '        address _orb1\n', '        ) public returns (address orcl) {\n', '        address tok0 = UniswapV2PairLike(_src).token0();\n', '        address tok1 = UniswapV2PairLike(_src).token1();\n', '        orcl = address(new UNIV2LPOracle(_src, _wat, _orb0, _orb1));\n', '        UNIV2LPOracle(orcl).rely(_owner);\n', '        UNIV2LPOracle(orcl).deny(address(this));\n', '        isOracle[orcl] = true;\n', '        emit NewUNIV2LPOracle(_owner, orcl, _wat, tok0, tok1, _orb0, _orb1);\n', '    }\n', '}\n', '\n', 'contract UNIV2LPOracle {\n', '\n', '    // --- Auth ---\n', '    mapping (address => uint256) public wards;                                       // Addresses with admin authority\n', '    function rely(address _usr) external auth { wards[_usr] = 1; emit Rely(_usr); }  // Add admin\n', '    function deny(address _usr) external auth { wards[_usr] = 0; emit Deny(_usr); }  // Remove admin\n', '    modifier auth {\n', '        require(wards[msg.sender] == 1, "UNIV2LPOracle/not-authorized");\n', '        _;\n', '    }\n', '\n', '    address public immutable src;   // Price source\n', '\n', '    // hop and zph are packed into single slot to reduce SLOADs;\n', '    // this outweighs the cost from added bitmasking operations.\n', '    uint8   public stopped;         // Stop/start ability to update\n', '    uint16  public hop = 1 hours;   // Minimum time in between price updates\n', '    uint232 public zph;             // Time of last price update plus hop\n', '\n', '    bytes32 public immutable wat;   // Label of token whose price is being tracked\n', '\n', '    // --- Whitelisting ---\n', '    mapping (address => uint256) public bud;\n', '    modifier toll { require(bud[msg.sender] == 1, "UNIV2LPOracle/contract-not-whitelisted"); _; }\n', '\n', '    struct Feed {\n', '        uint128 val;  // Price\n', '        uint128 has;  // Is price valid\n', '    }\n', '\n', '    Feed    internal cur;  // Current price  (mem slot 0x3)\n', '    Feed    internal nxt;  // Queued price   (mem slot 0x4)\n', '\n', '    // --- Data ---\n', '    uint256 private immutable UNIT_0;  // Numerical representation of one token of token0 (10^decimals) \n', '    uint256 private immutable UNIT_1;  // Numerical representation of one token of token1 (10^decimals) \n', '\n', '    address public            orb0;  // Oracle for token0, ideally a Medianizer\n', '    address public            orb1;  // Oracle for token1, ideally a Medianizer\n', '\n', '    // --- Math ---\n', '    uint256 constant WAD = 10 ** 18;\n', '\n', '    function add(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n', '        require((z = _x + _y) >= _x, "UNIV2LPOracle/add-overflow");\n', '    }\n', '    function sub(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n', '        require((z = _x - _y) <= _x, "UNIV2LPOracle/sub-underflow");\n', '    }\n', '    function mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) {\n', '        require(_y == 0 || (z = _x * _y) / _y == _x, "UNIV2LPOracle/mul-overflow");\n', '    }\n', '\n', '    // FROM https://github.com/abdk-consulting/abdk-libraries-solidity/blob/16d7e1dd8628dfa2f88d5dadab731df7ada70bdd/ABDKMath64x64.sol#L687\n', '    function sqrt (uint256 _x) private pure returns (uint128) {\n', '        if (_x == 0) return 0;\n', '        else {\n', '            uint256 xx = _x;\n', '            uint256 r = 1;\n', '            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n', '            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n', '            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n', '            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n', '            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n', '            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n', '            if (xx >= 0x8) { r <<= 1; }\n', '            r = (r + _x / r) >> 1;\n', '            r = (r + _x / r) >> 1;\n', '            r = (r + _x / r) >> 1;\n', '            r = (r + _x / r) >> 1;\n', '            r = (r + _x / r) >> 1;\n', '            r = (r + _x / r) >> 1;\n', '            r = (r + _x / r) >> 1; // Seven iterations should be enough\n', '            uint256 r1 = _x / r;\n', '            return uint128 (r < r1 ? r : r1);\n', '        }\n', '    }\n', '\n', '    // --- Events ---\n', '    event Rely(address indexed usr);\n', '    event Deny(address indexed usr);\n', '    event Step(uint256 hop);\n', '    event Stop();\n', '    event Start();\n', '    event Value(uint128 curVal, uint128 nxtVal);\n', '    event Link(uint256 id, address orb);\n', '    event Kiss(address a);\n', '    event Diss(address a);\n', '\n', '    // --- Init ---\n', '    constructor (address _src, bytes32 _wat, address _orb0, address _orb1) public {\n', '        require(_src  != address(0),                        "UNIV2LPOracle/invalid-src-address");\n', '        require(_orb0 != address(0) && _orb1 != address(0), "UNIV2LPOracle/invalid-oracle-address");\n', '        wards[msg.sender] = 1;\n', '        emit Rely(msg.sender);\n', '        src  = _src;\n', '        wat  = _wat;\n', '        uint256 dec0 = uint256(ERC20Like(UniswapV2PairLike(_src).token0()).decimals());\n', '        require(dec0 <= 18, "UNIV2LPOracle/token0-dec-gt-18");\n', '        UNIT_0 = 10 ** dec0;\n', '        uint256 dec1 = uint256(ERC20Like(UniswapV2PairLike(_src).token1()).decimals());\n', '        require(dec1 <= 18, "UNIV2LPOracle/token1-dec-gt-18");\n', '        UNIT_1 = 10 ** dec1;\n', '        orb0 = _orb0;\n', '        orb1 = _orb1;\n', '    }\n', '\n', '    function stop() external auth {\n', '        stopped = 1;\n', '        delete cur;\n', '        delete nxt;\n', '        zph = 0;\n', '        emit Stop();\n', '    }\n', '\n', '    function start() external auth {\n', '        stopped = 0;\n', '        emit Start();\n', '    }\n', '\n', '    function step(uint256 _hop) external auth {\n', '        require(_hop <= uint16(-1), "UNIV2LPOracle/invalid-hop");\n', '        hop = uint16(_hop);\n', '        emit Step(_hop);\n', '    }\n', '\n', '    function link(uint256 _id, address _orb) external auth {\n', '        require(_orb != address(0), "UNIV2LPOracle/no-contract-0");\n', '        if(_id == 0) {\n', '            orb0 = _orb;\n', '        } else if (_id == 1) {\n', '            orb1 = _orb;\n', '        } else {\n', '            revert("UNIV2LPOracle/invalid-id");\n', '        }\n', '        emit Link(_id, _orb);\n', '    }\n', '\n', '    // For consistency with other oracles.\n', '    function zzz() external view returns (uint256) {\n', '        if (zph == 0) return 0;  // backwards compatibility\n', '        return sub(zph, hop);\n', '    }\n', '\n', '    function pass() external view returns (bool) {\n', '        return block.timestamp >= zph;\n', '    }\n', '\n', '    function seek() internal returns (uint128 quote) {\n', '        // Sync up reserves of uniswap liquidity pool\n', '        UniswapV2PairLike(src).sync();\n', '\n', '        // Get reserves of uniswap liquidity pool\n', '        (uint112 r0, uint112 r1,) = UniswapV2PairLike(src).getReserves();\n', '        require(r0 > 0 && r1 > 0, "UNIV2LPOracle/invalid-reserves");\n', '\n', '        // All Oracle prices are priced with 18 decimals against USD\n', '        uint256 p0 = OracleLike(orb0).read();  // Query token0 price from oracle (WAD)\n', '        require(p0 != 0, "UNIV2LPOracle/invalid-oracle-0-price");\n', '        uint256 p1 = OracleLike(orb1).read();  // Query token1 price from oracle (WAD)\n', '        require(p1 != 0, "UNIV2LPOracle/invalid-oracle-1-price");\n', '\n', '        // Get LP token supply\n', '        uint256 supply = ERC20Like(src).totalSupply();\n', '\n', '        // This calculation should be overflow-resistant even for tokens with very high or very\n', '        // low prices, as the dollar value of each reserve should lie in a fairly controlled range\n', '        // regardless of the token prices.\n', '        uint256 value0 = mul(p0, uint256(r0)) / UNIT_0;  // WAD\n', '        uint256 value1 = mul(p1, uint256(r1)) / UNIT_1;  // WAD\n', '        uint256 preq = mul(2 * WAD, sqrt(mul(value0, value1))) / supply;  // Will revert if supply == 0\n', '        require(preq < 2 ** 128, "UNIV2LPOracle/quote-overflow");\n', '        quote = uint128(preq);  // WAD\n', '    }\n', '\n', '    function poke() external {\n', '\n', "        // Ensure a single SLOAD while avoiding solc's excessive bitmasking bureaucracy.\n", '        uint256 hop_;\n', '        {\n', '\n', '            // Block-scoping these variables saves some gas.\n', '            uint256 stopped_;\n', '            uint256 zph_;\n', '            assembly {\n', '                let slot1 := sload(1)\n', '                stopped_  := and(slot1,         0xff  )\n', '                hop_      := and(shr(8, slot1), 0xffff)\n', '                zph_      := shr(24, slot1)\n', '            }\n', '\n', '            // When stopped, values are set to zero and should remain such; thus, disallow updating in that case.\n', '            require(stopped_ == 0, "UNIV2LPOracle/is-stopped");\n', '\n', '            // Equivalent to requiring that pass() returns true.\n', '            // The logic is repeated instead of calling pass() to save gas\n', '            // (both by eliminating an internal call here, and allowing pass to be external).\n', '            require(block.timestamp >= zph_, "UNIV2LPOracle/not-passed");\n', '        }\n', '\n', '        uint128 val = seek();\n', '        require(val != 0, "UNIV2LPOracle/invalid-price");\n', '        Feed memory cur_ = nxt;  // This memory value is used to save an SLOAD later.\n', '        cur = cur_;\n', '        nxt = Feed(val, 1);\n', '\n', '        // The below is equivalent to:\n', '        //\n', '        //    zph = block.timestamp + hop\n', '        //\n', '        // but ensures no extra SLOADs are performed.\n', '        //\n', '        // Even if _hop = (2^16 - 1), the maximum possible value, add(timestamp(), _hop)\n', '        // will not overflow (even a 232 bit value) for a very long time.\n', '        //\n', '        // Also, we know stopped was zero, so there is no need to account for it explicitly here.\n', '        assembly {\n', '            sstore(\n', '                1,\n', '                add(\n', '                    // zph value starts 24 bits in\n', '                    shl(24, add(timestamp(), hop_)),\n', '\n', '                    // hop value starts 8 bits in\n', '                    shl(8, hop_)\n', '                )\n', '            )\n', '        }\n', '\n', '        // Equivalent to emitting Value(cur.val, nxt.val), but averts extra SLOADs.\n', '        emit Value(cur_.val, val);\n', '\n', '        // Safe to terminate immediately since no postfix modifiers are applied.\n', '        assembly {\n', '            stop()\n', '        }\n', '    }\n', '\n', '    function peek() external view toll returns (bytes32,bool) {\n', '        return (bytes32(uint256(cur.val)), cur.has == 1);\n', '    }\n', '\n', '    function peep() external view toll returns (bytes32,bool) {\n', '        return (bytes32(uint256(nxt.val)), nxt.has == 1);\n', '    }\n', '\n', '    function read() external view toll returns (bytes32) {\n', '        require(cur.has == 1, "UNIV2LPOracle/no-current-value");\n', '        return (bytes32(uint256(cur.val)));\n', '    }\n', '\n', '    function kiss(address _a) external auth {\n', '        require(_a != address(0), "UNIV2LPOracle/no-contract-0");\n', '        bud[_a] = 1;\n', '        emit Kiss(_a);\n', '    }\n', '\n', '    function kiss(address[] calldata _a) external auth {\n', '        for(uint256 i = 0; i < _a.length; i++) {\n', '            require(_a[i] != address(0), "UNIV2LPOracle/no-contract-0");\n', '            bud[_a[i]] = 1;\n', '            emit Kiss(_a[i]);\n', '        }\n', '    }\n', '\n', '    function diss(address _a) external auth {\n', '        bud[_a] = 0;\n', '        emit Diss(_a);\n', '    }\n', '\n', '    function diss(address[] calldata _a) external auth {\n', '        for(uint256 i = 0; i < _a.length; i++) {\n', '            bud[_a[i]] = 0;\n', '            emit Diss(_a[i]);\n', '        }\n', '    }\n', '}']