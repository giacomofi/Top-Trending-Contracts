['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// Copyright (C) 2019 David Terry <[email\xa0protected]>\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity >=0.6.7;\n', '\n', 'interface DSAuthority {\n', '    function canCall(\n', '        address src, address dst, bytes4 sig\n', '    ) external view returns (bool);\n', '}\n', '\n', 'abstract contract DSAuthEvents {\n', '    event LogSetAuthority (address indexed authority);\n', '    event LogSetOwner     (address indexed owner);\n', '}\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority  public  authority;\n', '    address      public  owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_)\n', '        virtual\n', '        public\n', '        auth\n', '    {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_)\n', '        virtual\n', '        public\n', '        auth\n', '    {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "ds-auth-unauthorized");\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) virtual internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, address(this), sig);\n', '        }\n', '    }\n', '}\n', '\n', 'contract DSProtestPause is DSAuth {\n', '    // --- Admin ---\n', '    modifier isDelayed { require(msg.sender == address(proxy), "ds-protest-pause-undelayed-call"); _; }\n', '\n', '    function setOwner(address owner_) override public isDelayed {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '    function setAuthority(DSAuthority authority_) override public isDelayed {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '    function setProtester(address protester_) external isDelayed {\n', '        protester = protester_;\n', '        emit SetProtester(address(protester));\n', '    }\n', '    function setDelay(uint delay_) external isDelayed {\n', '        require(delay_ <= MAX_DELAY, "ds-protest-pause-delay-not-within-bounds");\n', '        delay = delay_;\n', '        emit SetDelay(delay_);\n', '    }\n', '    function setDelayMultiplier(uint multiplier_) external isDelayed {\n', '        require(both(multiplier_ >= 1, multiplier_ <= MAX_DELAY_MULTIPLIER), "ds-protest-pause-multiplier-exceeds-bounds");\n', '        delayMultiplier = multiplier_;\n', '        emit ChangeDelayMultiplier(multiplier_);\n', '    }\n', '\n', '    // --- Structs ---\n', '    struct TransactionDelay {\n', '        bool protested;\n', '        uint scheduleTime;\n', '        uint totalDelay;\n', '    }\n', '\n', '    // --- Data ---\n', '    mapping (bytes32 => bool)             public scheduledTransactions;\n', '    mapping (bytes32 => TransactionDelay) internal transactionDelays;\n', '\n', '    DSPauseProxy     public proxy;\n', '    address          public protester;\n', '\n', '    uint             public delay;\n', '    uint             public delayMultiplier = 1;\n', '    uint             public currentlyScheduledTransactions;\n', '    uint             public deploymentTime;\n', '    uint             public protesterLifetime;\n', '\n', '    uint256 constant public EXEC_TIME                = 3 days;\n', '    uint256 constant public MAX_DELAY                = 28 days;\n', '    uint256 constant public maxScheduledTransactions = 10;\n', '    uint256 constant public protestEnd               = 500;                 // a tx can be protested against if max 1/2 of the time until earliest execution has passed\n', '    uint256 constant public MAX_DELAY_MULTIPLIER     = 3;\n', '    bytes32 constant public DS_PAUSE_TYPE            = bytes32("PROTEST");\n', '\n', '    // --- Events ---\n', '    event SetDelay(uint256 delay);\n', '    event SetProtester(address protester);\n', '    event ChangeDelayMultiplier(uint256 multiplier);\n', '    event ScheduleTransaction(address sender, address usr, bytes32 codeHash, bytes parameters, uint earliestExecutionTime);\n', '    event AbandonTransaction(address sender, address usr, bytes32 codeHash, bytes parameters, uint earliestExecutionTime);\n', '    event ProtestAgainstTransaction(address sender, address usr, bytes32 codeHash, bytes parameters, uint totalDelay);\n', '    event ExecuteTransaction(address sender, address usr, bytes32 codeHash, bytes parameters, uint earliestExecutionTime);\n', '    event AttachTransactionDescription(address sender, address usr, bytes32 codeHash, bytes parameters, uint earliestExecutionTime, string description);\n', '\n', '    // --- Init ---\n', '    constructor(uint protesterLifetime_, uint delay_, address owner_, DSAuthority authority_) public {\n', '        require(delay_ <= MAX_DELAY, "ds-protest-pause-delay-not-within-bounds");\n', '        delay = delay_;\n', '        owner = owner_;\n', '        authority = authority_;\n', '        deploymentTime = now;\n', '        protesterLifetime = protesterLifetime_;\n', '        proxy = new DSPauseProxy();\n', '    }\n', '\n', '    // --- Math ---\n', '    function addition(uint x, uint y) internal pure returns (uint z) {\n', '        z = x + y;\n', '        require(z >= x, "ds-protest-pause-add-overflow");\n', '    }\n', '    function subtract(uint x, uint y) internal pure returns (uint z) {\n', '        require((z = x - y) <= x, "ds-protest-pause-sub-underflow");\n', '    }\n', '    function multiply(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-protest-pause-mul-invalid");\n', '    }\n', '\n', '    // --- Boolean Logic ---\n', '    function both(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := and(x, y)}\n', '    }\n', '\n', '    // --- Util ---\n', '    function getTransactionDataHash(address usr, bytes32 codeHash, bytes memory parameters, uint earliestExecutionTime)\n', '        public pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(abi.encode(usr, codeHash, parameters, earliestExecutionTime));\n', '    }\n', '    function getTransactionDataHash(address usr, bytes32 codeHash, bytes memory parameters)\n', '        public pure\n', '        returns (bytes32)\n', '    {\n', '        return keccak256(abi.encode(usr, codeHash, parameters));\n', '    }\n', '    function getExtCodeHash(address usr)\n', '        internal view\n', '        returns (bytes32 codeHash)\n', '    {\n', '        assembly { codeHash := extcodehash(usr) }\n', '    }\n', '    function protestWindowAvailable(address usr, bytes32 codeHash, bytes calldata parameters) external view returns (bool) {\n', '        bytes32 partiallyHashedTx = getTransactionDataHash(usr, codeHash, parameters);\n', '        (bool protested, ,) = getTransactionDelays(partiallyHashedTx);\n', '        if (protested) return false;\n', '        return (\n', '          now < protestDeadline(partiallyHashedTx)\n', '        );\n', '    }\n', '    function protestWindowAvailable(bytes32 txHash) external view returns (bool) {\n', '        (bool protested, ,) = getTransactionDelays(txHash);\n', '        if (protested) return false;\n', '        return (\n', '          now < protestDeadline(txHash)\n', '        );\n', '    }\n', '    function timeUntilProposalProtestDeadline(address usr, bytes32 codeHash, bytes calldata parameters) external view returns (uint256) {\n', '        bytes32 partiallyHashedTx = getTransactionDataHash(usr, codeHash, parameters);\n', '        (bool protested, ,) = getTransactionDelays(partiallyHashedTx);\n', '        if (protested) return 0;\n', '        uint protestDeadline = protestDeadline(partiallyHashedTx);\n', '        if (now >= protestDeadline) return 0;\n', '        return subtract(protestDeadline, now);\n', '    }\n', '    function timeUntilProposalProtestDeadline(bytes32 txHash) external view returns (uint256) {\n', '        (bool protested, ,) = getTransactionDelays(txHash);\n', '        if (protested) return 0;\n', '        uint protestDeadline = protestDeadline(txHash);\n', '        if (now >= protestDeadline) return 0;\n', '        return subtract(protestDeadline, now);\n', '    }\n', '    function protestDeadline(bytes32 txHash) internal view returns (uint256) {\n', '        return addition(transactionDelays[txHash].scheduleTime, (multiply(transactionDelays[txHash].totalDelay, protestEnd) / 1000));\n', '    }\n', '\n', '    // --- Operations ---\n', '    function scheduleTransaction(address usr, bytes32 codeHash, bytes calldata parameters, uint earliestExecutionTime)\n', '        external auth\n', '    {\n', '        schedule(usr, codeHash, parameters, earliestExecutionTime);\n', '    }\n', '    function scheduleTransaction(address usr, bytes32 codeHash, bytes calldata parameters, uint earliestExecutionTime, string calldata description)\n', '        external auth\n', '    {\n', '        schedule(usr, codeHash, parameters, earliestExecutionTime);\n', '        emit AttachTransactionDescription(msg.sender, usr, codeHash, parameters, earliestExecutionTime, description);\n', '    }\n', '    function attachTransactionDescription(address usr, bytes32 codeHash, bytes memory parameters, uint earliestExecutionTime, string memory description)\n', '        public auth\n', '    {\n', '        bytes32 partiallyHashedTx = getTransactionDataHash(usr, codeHash, parameters);\n', '        require(transactionDelays[partiallyHashedTx].scheduleTime > 0, "ds-protest-pause-cannot-attach-for-null");\n', '        emit AttachTransactionDescription(msg.sender, usr, codeHash, parameters, earliestExecutionTime, description);\n', '    }\n', '    function protestAgainstTransaction(address usr, bytes32 codeHash, bytes calldata parameters)\n', '        external\n', '    {\n', '        require(msg.sender == protester, "ds-protest-pause-sender-not-protester");\n', '        require(addition(protesterLifetime, deploymentTime) > now, "ds-protest-pause-protester-lifetime-passed");\n', '        bytes32 partiallyHashedTx = getTransactionDataHash(usr, codeHash, parameters);\n', '        require(transactionDelays[partiallyHashedTx].scheduleTime > 0, "ds-protest-pause-null-inexistent-transaction");\n', '        require(!transactionDelays[partiallyHashedTx].protested, "ds-protest-pause-tx-already-protested");\n', '        require(\n', '          now < protestDeadline(partiallyHashedTx),\n', '          "ds-protest-pause-exceed-protest-deadline"\n', '        );\n', '\n', '        transactionDelays[partiallyHashedTx].protested = true;\n', '\n', '        uint multipliedDelay = multiply(delay, delayMultiplier);\n', '        if (multipliedDelay > MAX_DELAY) {\n', '          multipliedDelay = MAX_DELAY;\n', '        }\n', '        if (transactionDelays[partiallyHashedTx].totalDelay < multipliedDelay) {\n', '          transactionDelays[partiallyHashedTx].totalDelay = multipliedDelay;\n', '        }\n', '\n', '        emit ProtestAgainstTransaction(msg.sender, usr, codeHash, parameters, transactionDelays[partiallyHashedTx].totalDelay);\n', '    }\n', '    function abandonTransaction(address usr, bytes32 codeHash, bytes calldata parameters, uint earliestExecutionTime)\n', '        external auth\n', '    {\n', '        bytes32 fullyHashedTx = getTransactionDataHash(usr, codeHash, parameters, earliestExecutionTime);\n', '        bytes32 partiallyHashedTx = getTransactionDataHash(usr, codeHash, parameters);\n', '        require(transactionDelays[partiallyHashedTx].scheduleTime > 0, "ds-protest-pause-cannot-abandon-null");\n', '        scheduledTransactions[fullyHashedTx] = false;\n', '        delete(transactionDelays[partiallyHashedTx]);\n', '        currentlyScheduledTransactions = subtract(currentlyScheduledTransactions, 1);\n', '        emit AbandonTransaction(msg.sender, usr, codeHash, parameters, earliestExecutionTime);\n', '    }\n', '    function executeTransaction(address usr, bytes32 codeHash, bytes calldata parameters, uint earliestExecutionTime)\n', '        external\n', '        returns (bytes memory out)\n', '    {\n', '        bytes32 fullyHashedTx = getTransactionDataHash(usr, codeHash, parameters, earliestExecutionTime);\n', '        bytes32 partiallyHashedTx = getTransactionDataHash(usr, codeHash, parameters);\n', '        uint executionStart = addition(transactionDelays[partiallyHashedTx].scheduleTime, transactionDelays[partiallyHashedTx].totalDelay);\n', '        require(scheduledTransactions[fullyHashedTx], "ds-protest-pause-inexistent-transaction");\n', '        require(getExtCodeHash(usr) == codeHash, "ds-protest-pause-wrong-codehash");\n', '        require(now >= executionStart, "ds-protest-pause-premature-exec");\n', '        require(now < addition(executionStart, EXEC_TIME), "ds-protest-pause-expired-tx");\n', '\n', '        scheduledTransactions[fullyHashedTx] = false;\n', '        delete(transactionDelays[partiallyHashedTx]);\n', '        currentlyScheduledTransactions = subtract(currentlyScheduledTransactions, 1);\n', '\n', '        emit ExecuteTransaction(msg.sender, usr, codeHash, parameters, earliestExecutionTime);\n', '\n', '        out = proxy.executeTransaction(usr, parameters);\n', '        require(proxy.owner() == address(this), "ds-protest-pause-illegal-storage-change");\n', '    }\n', '\n', '    // --- Internal ---\n', '    function schedule(address usr, bytes32 codeHash, bytes memory parameters, uint earliestExecutionTime) internal {\n', '        require(subtract(earliestExecutionTime, now) <= MAX_DELAY, "ds-protest-pause-delay-not-within-bounds");\n', '        require(earliestExecutionTime >= addition(now, delay), "ds-protest-pause-delay-not-respected");\n', '        bytes32 fullyHashedTx = getTransactionDataHash(usr, codeHash, parameters, earliestExecutionTime);\n', '        bytes32 partiallyHashedTx = getTransactionDataHash(usr, codeHash, parameters);\n', '        require(transactionDelays[partiallyHashedTx].scheduleTime == 0, "ds-protest-pause-cannot-schedule-same-tx-twice");\n', '        require(currentlyScheduledTransactions < maxScheduledTransactions, "ds-protest-pause-too-many-scheduled");\n', '        currentlyScheduledTransactions = addition(currentlyScheduledTransactions, 1);\n', '        scheduledTransactions[fullyHashedTx] = true;\n', '        transactionDelays[partiallyHashedTx] = TransactionDelay(false, now, subtract(earliestExecutionTime, now));\n', '        emit ScheduleTransaction(msg.sender, usr, codeHash, parameters, earliestExecutionTime);\n', '    }\n', '\n', '    // --- Getters ---\n', '    function getTransactionDelays(address usr, bytes32 codeHash, bytes calldata parameters) external view returns (bool, uint256, uint256) {\n', '        bytes32 hashedTx = getTransactionDataHash(usr, codeHash, parameters);\n', '        return (\n', '          transactionDelays[hashedTx].protested,\n', '          transactionDelays[hashedTx].scheduleTime,\n', '          transactionDelays[hashedTx].totalDelay\n', '        );\n', '    }\n', '    function getTransactionDelays(bytes32 txHash) public view returns (bool, uint256, uint256) {\n', '        return (\n', '          transactionDelays[txHash].protested,\n', '          transactionDelays[txHash].scheduleTime,\n', '          transactionDelays[txHash].totalDelay\n', '        );\n', '    }\n', '}\n', '\n', '// scheduled txs are executed in an isolated storage context to protect the pause from\n', '// malicious storage modification during plan execution\n', 'contract DSPauseProxy {\n', '    address public owner;\n', '    modifier isAuthorized { require(msg.sender == owner, "ds-protest-pause-proxy-unauthorized"); _; }\n', '    constructor() public { owner = msg.sender; }\n', '\n', '    function executeTransaction(address usr, bytes memory parameters)\n', '        public isAuthorized\n', '        returns (bytes memory out)\n', '    {\n', '        bool ok;\n', '        (ok, out) = usr.delegatecall(parameters);\n', '        require(ok, "ds-protest-pause-delegatecall-error");\n', '    }\n', '}']