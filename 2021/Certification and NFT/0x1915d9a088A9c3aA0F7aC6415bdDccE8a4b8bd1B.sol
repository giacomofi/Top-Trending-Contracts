['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-15\n', '*/\n', '\n', '// Sources flattened with hardhat v2.3.3 https://hardhat.org\n', '\n', '// File contracts/interfaces/IArmorClient.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IArmorClient {\n', '    function submitProofOfLoss(uint256[] calldata _ids) external;\n', '}\n', '\n', '\n', '// File contracts/interfaces/IArmorMaster.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IArmorMaster {\n', '    function registerModule(bytes32 _key, address _module) external;\n', '    function getModule(bytes32 _key) external view returns(address);\n', '    function keep() external;\n', '}\n', '\n', '\n', '// File contracts/interfaces/IBalanceManager.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IBalanceManager {\n', '  event Deposit(address indexed user, uint256 amount);\n', '  event Withdraw(address indexed user, uint256 amount);\n', '  event Loss(address indexed user, uint256 amount);\n', '  event PriceChange(address indexed user, uint256 price);\n', '  event AffiliatePaid(address indexed affiliate, address indexed referral, uint256 amount, uint256 timestamp);\n', '  event ReferralAdded(address indexed affiliate, address indexed referral, uint256 timestamp);\n', '  function expireBalance(address _user) external;\n', '  function deposit(address _referrer) external payable;\n', '  function withdraw(uint256 _amount) external;\n', '  function initialize(address _armormaster, address _devWallet) external;\n', '  function balanceOf(address _user) external view returns (uint256);\n', '  function perSecondPrice(address _user) external view returns(uint256);\n', '  function changePrice(address user, uint64 _newPricePerSec) external;\n', '}\n', '\n', '\n', '// File contracts/interfaces/IPlanManager.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IPlanManager {\n', '  // Mapping = protocol => cover amount\n', '  struct Plan {\n', '      uint64 startTime;\n', '      uint64 endTime;\n', '      uint128 length;\n', '  }\n', '  \n', '  struct ProtocolPlan {\n', '      uint64 protocolId;\n', '      uint192 amount;\n', '  }\n', '    \n', '  // Event to notify frontend of plan update.\n', '  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\n', '  function userCoverageLimit(address _user, address _protocol) external view returns(uint256);\n', '  function markup() external view returns(uint256);\n', '  function nftCoverPrice(address _protocol) external view returns(uint256);\n', '  function initialize(address _armorManager) external;\n', '  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\n', '  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\n', '  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\n', '  function coverageLeft(address _protocol) external view returns(uint256);\n', '  function getCurrentPlan(address _user) external view returns(uint256 idx, uint128 start, uint128 end);\n', '  function updateExpireTime(address _user, uint256 _expiry) external;\n', '  function planRedeemed(address _user, uint256 _planIndex, address _protocol) external;\n', '  function totalUsedCover(address _scAddress) external view returns (uint256);\n', '}\n', '\n', '\n', '// File contracts/interfaces/IClaimManager.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IClaimManager {\n', '    function initialize(address _armorMaster) external;\n', '    function transferNft(address _to, uint256 _nftId) external;\n', '    function exchangeWithdrawal(uint256 _amount) external;\n', '    function redeemClaim(address _protocol, uint256 _hackTime, uint256 _amount) external;\n', '}\n', '\n', '\n', '// File contracts/interfaces/IStakeManager.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IStakeManager {\n', '    function totalStakedAmount(address protocol) external view returns(uint256);\n', '    function protocolAddress(uint64 id) external view returns(address);\n', '    function protocolId(address protocol) external view returns(uint64);\n', '    function initialize(address _armorMaster) external;\n', '    function allowedCover(address _newProtocol, uint256 _newTotalCover) external view returns (bool);\n', '    function subtractTotal(uint256 _nftId, address _protocol, uint256 _subtractAmount) external;\n', '}\n', '\n', '\n', '// File contracts/libraries/ArmorCore.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '/**\n', ' * @dev ArmorCore library simplifies integration of Armor Core into other contracts. It contains most functionality needed for a contract to use arCore.\n', '**/\n', 'library ArmorCore {\n', '\n', '    IArmorMaster internal constant armorMaster = IArmorMaster(0x1337DEF1900cEaabf5361C3df6aF653D814c6348);\n', '\n', '    /**\n', '     * @dev Get Armor module such as BalanceManager, PlanManager, etc.\n', '     * @param _name Name of the module (such as "BALANCE").\n', '    **/\n', '    function getModule(bytes32 _name) internal view returns(address) {\n', '        return armorMaster.getModule(_name);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate the price per second for a specific amount of Ether.\n', '     * @param _protocol Address of protocol to protect.\n', '     * @param _coverAmount Amount of Ether to cover (in Wei). We div by 1e18 at the end because both _coverAmount and pricePerETH return are 1e18.\n', '     * @return pricePerSec Ether (in Wei) price per second of this coverage.\n', '    **/\n', '    function calculatePricePerSec(address _protocol, uint256 _coverAmount) internal view returns (uint256 pricePerSec) {\n', '        return pricePerETH(_protocol) * _coverAmount / 1e18;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculate price per second for an array of protocols and amounts.\n', '     * @param _protocols Protocols to protect.\n', '     * @param _coverAmounts Amounts (in Wei) of Ether to protect.\n', '     * @return pricePerSec Ether (in Wei) price per second of this coverage,\n', '    **/\n', '    function calculatePricePerSec(address[] memory _protocols, uint256[] memory _coverAmounts) internal view returns (uint256 pricePerSec) {\n', '        require(_protocols.length == _coverAmounts.length, "Armor: array length diff");\n', '        for(uint256 i = 0; i<_protocols.length; i++){\n', '            pricePerSec = pricePerSec + pricePerETH(_protocols[i]) * _coverAmounts[i];\n', '        }\n', '        return pricePerSec / 1e18;\n', '    }\n', '\n', '    /**\n', '     * @dev Find amount of cover available for the specified protocol (up to amount desired).\n', '     * @param _protocol Protocol to check cover for.\n', '     * @param _amount Max amount of cover you would like.\n', '     * @return available Amount of cover that is available (in Wei) up to full amount desired.\n', '    **/\n', '    function availableCover(address _protocol, uint256 _amount) internal view returns (uint256 available) {\n', '        IPlanManager planManager = IPlanManager(getModule("PLAN"));\n', '        uint256 limit = planManager.userCoverageLimit(address(this), _protocol);\n', '        return limit >= _amount ? _amount : limit;\n', '    }\n', '\n', '    /**  \n', '     * @dev Find the price per second per Ether for the protocol.\n', '     * @param _protocol Protocol we are finding the price for.\n', '     * @return pricePerSecPerETH The price per second per each full Eth for the protocol.\n', '    **/\n', '    function pricePerETH(address _protocol) internal view returns(uint256 pricePerSecPerETH) {\n', '        IPlanManager planManager = IPlanManager(getModule("PLAN"));\n', '        pricePerSecPerETH = planManager.nftCoverPrice(_protocol) * planManager.markup() / 100;\n', '    }\n', '\n', '    /**\n', '     * @dev Subscribe to or update an Armor plan.\n', '     * @param _protocols Protocols to be covered for.\n', '     * @param _coverAmounts Ether amounts (in Wei) to purchase cover for. \n', '    **/\n', '    function subscribe(address[] memory _protocols, uint256[] memory _coverAmounts) internal {\n', '        IPlanManager planManager = IPlanManager(getModule("PLAN"));\n', '        planManager.updatePlan(_protocols, _coverAmounts);\n', '    }\n', '\n', '    /**\n', '     * @dev Subscribe to or update an Armor plan.\n', '     * @param _protocol Protocols to be covered for.\n', '     * @param _coverAmount Ether amounts (in Wei) to purchase cover for. \n', '    **/\n', '    function subscribe(address _protocol, uint256 _coverAmount) internal {\n', '        IPlanManager planManager = IPlanManager(getModule("PLAN"));\n', '        address[] memory protocols = new address[](1);\n', '        protocols[0] = _protocol;\n', '        uint256[] memory amounts = new uint256[](1);\n', '        amounts[0] = _coverAmount;\n', '        planManager.updatePlan(protocols, amounts);\n', '    }\n', '\n', '    /**\n', "     * @dev Return this contract's balance on the Armor Core BalanceManager.\n", "     * @return This contract's ablance on Armor Core.\n", '    **/\n', '    function balanceOf() internal view returns (uint256) {\n', '        IBalanceManager balanceManager = IBalanceManager(getModule("BALANCE"));\n', '        return balanceManager.balanceOf( address(this) );\n', '    }\n', '\n', '    /**\n', '     * @dev Deposit funds into the BalanceManager contract.\n', '     * @param amount Amount of Ether (in Wei) to deposit into the contract.\n', '    **/\n', '    function deposit(uint256 amount) internal {\n', '        IBalanceManager balanceManager = IBalanceManager(getModule("BALANCE"));\n', '        balanceManager.deposit{value:amount}(address(0));\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw balance from the BalanceManager contract.\n', '     * @param amount Amount (in Wei) if Ether to withdraw from the contract.\n', '    **/\n', '    function withdraw(uint256 amount) internal {\n', '        IBalanceManager balanceManager = IBalanceManager(getModule("BALANCE"));\n', '        balanceManager.withdraw(amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Claim funds after a hack has occurred on a protected protocol.\n', '     * @param _protocol The protocol that was hacked.\n', '     * @param _hackTime The Unix timestamp at which the hack occurred. Determined by Armor DAO.\n', '     * @param _amount Amount of funds to claim (in Ether Wei).\n', '    **/\n', '    function claim(address _protocol, uint256 _hackTime, uint256 _amount) internal {\n', '        IClaimManager claimManager = IClaimManager(getModule("CLAIM"));\n', '        claimManager.redeemClaim(_protocol, _hackTime, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev End Armor coverage. \n', '    **/\n', '    function cancelPlan() internal {\n', '        IPlanManager planManager = IPlanManager(getModule("PLAN"));\n', '        address[] memory emptyProtocols = new address[](0);\n', '        uint256[] memory emptyAmounts = new uint256[](0);\n', '        planManager.updatePlan(emptyProtocols, emptyAmounts);\n', '    }\n', '}\n', '\n', '\n', '// File contracts/client/ArmorClient.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '/**\n', ' * @dev ArmorClient is the main contract for non-Armor contracts to inherit when connecting to arCore. It contains all functionality needed for a contract to use arCore.\n', '**/\n', 'contract ArmorClient {\n', '\n', '    // Address that has permission to submit proof-of-loss. Armor will assign NFTs for this address to submit proof-of-loss for.\n', '    address public armorController;\n', '\n', '    constructor() {\n', '        armorController = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev ClaimManager calls into this contract to prompt 0 Ether transactions to addresses corresponding to NFTs that this contract must provide proof-of-loss for.\n', "     *      This is required because of Nexus' proof-of-loss system in which an amount of proof-of-loss is required to claim cover that was paid for.\n", '     *      EOAs would generally just sign a message to be sent in, but contracts send transactions to addresses corresponding to a cover ID (0xc1D000...000hex(coverId)).\n', '     * @param _addresses Ethereum addresses to send 0 Ether transactions to.\n', '    **/\n', '    function submitProofOfLoss(address payable[] calldata _addresses) external {\n', '        require(msg.sender == armorController || msg.sender == ArmorCore.getModule("CLAIM"),"Armor: only Armor controller or Claim Manager may call this function.");\n', '        for(uint256 i = 0; i < _addresses.length; i++){\n', '            _addresses[i].transfer(0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer the address that is allowed to call sensitive Armor transactions (submitting proof-of-loss).\n', '     * @param _newController Address to set as the new Armor controller. \n', '    **/\n', '    function transferArmorController(address _newController) external {\n', '        require(msg.sender == armorController, "Armor: only Armor controller may call this function.");\n', '        armorController = _newController;\n', '    }\n', '\n', '}\n', '\n', '\n', '// File contracts/interfaces/IarShield.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IarShield {\n', '    function initialize(\n', '        address _oracle,\n', '        address _pToken,\n', '        address _arToken,\n', '        address _uTokenLink,\n', '        uint256[] calldata _fees,\n', '        address[] calldata _covBases\n', '    ) \n', '      external;\n', '    function locked() external view returns(bool);\n', '}\n', '\n', '\n', '// File contracts/interfaces/IController.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IController {\n', '    function bonus() external view returns (uint256);\n', '    function refFee() external view returns (uint256);\n', '    function governor() external view returns (address);\n', '    function depositAmt() external view returns (uint256);\n', '    function beneficiary() external view returns (address payable);\n', '}\n', '\n', '\n', '// File contracts/core/CoverageBase.sol\n', '\n', '// SPDX-License-Identifier: (c) Armor.Fi, 2021\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '/**\n', ' * @title Coverage Base\n', ' * @notice Coverage base takes care of all Armor Core interactions for arShields.\n', ' * @author Armor.fi -- Robert M.C. Forster\n', '**/\n', 'contract CoverageBase is ArmorClient {\n', '    \n', '    // Denominator for coverage percent.\n', '    uint256 public constant DENOMINATOR = 10000;\n', '\n', '    // The protocol that this contract purchases coverage for.\n', '    address public protocol;\n', '    // Percent of funds from shields to cover.\n', '    uint256 public coverPct;\n', '    // Current cost per second for all Ether on contract.\n', '    uint256 public totalCostPerSec;\n', '    // Current cost per second per Ether.\n', '    uint256 public costPerEth;\n', '    // sum of cost per Ether for every second -- cumulative lol.\n', '    uint256 public cumCost;\n', '    // Last update of cumCost.\n', '    uint256 public lastUpdate;\n', '    // Total Ether value to be protecting in the contract.\n', '    uint256 public totalEthValue;\n', '    // Separate variable from above because there may be less than coverPct coverage available.\n', '    uint256 public totalEthCoverage;\n', '  \n', '    // Value in Ether and last updates of each shield vault.\n', '    mapping (address => ShieldStats) public shieldStats;\n', '\n', '    // Controller holds governance contract.\n', '    IController public controller;\n', '    \n', '    // Every time a shield updates it saves the full contracts cumulative cost, its Ether value, and \n', '    struct ShieldStats {\n', '        uint128 lastCumCost;\n', '        uint128 ethValue;\n', '        uint128 lastUpdate;\n', '        uint128 unpaid;\n', '    }\n', '    \n', '    // Only let the governance address or the ShieldController edit these functions.\n', '    modifier onlyGov \n', '    {\n', '        require(msg.sender == controller.governor() || msg.sender == address(controller), "Sender is not governor.");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Just used to set the controller for the coverage base.\n', '     * @param _controller ShieldController proxy address.\n', '     * @param _protocol Address of the protocol to cover (from Nexus Mutual).\n', '     * @param _coverPct Percent of the cover to purchase -- 10000 == 100%.\n', '    **/\n', '    function initialize(\n', '        address _controller,\n', '        address _protocol,\n', '        uint256 _coverPct\n', '    )\n', '      external\n', '    {\n', '        require(protocol == address(0), "Contract already initialized.");\n', '        controller = IController(_controller);\n', '        protocol = _protocol;\n', '        coverPct = _coverPct;\n', '    }\n', '    \n', '    // Needed to receive a claim payout.\n', '    receive() external payable {}\n', '\n', '    /**\n', '     * @notice Called by a keeper to update the amount covered by this contract on arCore.\n', '    **/\n', '    function updateCoverage()\n', '      external\n', '    {\n', '        ArmorCore.deposit(address(this).balance);\n', '        uint256 available = getAvailableCover();\n', '        ArmorCore.subscribe(protocol, available);\n', '        totalCostPerSec = getCoverageCost(available);\n', '        totalEthCoverage = available;\n', '        checkpoint();\n', '    }\n', '    \n', '    /**\n', '     * @notice arShield uses this to update the value of funds on their contract and deposit payments to here.\n', "     *      We're okay with being loose-y goose-y here in terms of making sure shields pay (no cut-offs, timeframes, etc.).\n", '     * @param _newEthValue The new Ether value of funds in the shield contract.\n', '    **/\n', '    function updateShield(\n', '        uint256 _newEthValue\n', '    )\n', '      external\n', '      payable\n', '    {\n', '        ShieldStats memory stats = shieldStats[msg.sender];\n', '        require(stats.lastUpdate > 0, "Only arShields may access this function.");\n', '        \n', '        // Determine how much the shield owes for the last period.\n', '        uint256 owed = getShieldOwed(msg.sender);\n', '        uint256 unpaid = owed <= msg.value ? \n', '                         0 \n', '                         : owed - msg.value;\n', '\n', '        totalEthValue = totalEthValue \n', '                        - uint256(stats.ethValue)\n', '                        + _newEthValue;\n', '\n', '        checkpoint();\n', '\n', '        shieldStats[msg.sender] = ShieldStats( \n', '                                    uint128(cumCost), \n', '                                    uint128(_newEthValue), \n', '                                    uint128(block.timestamp), \n', '                                    uint128(unpaid) \n', '                                  );\n', '    }\n', '    \n', '    /**\n', '     * @notice CoverageBase tells shield what % of current coverage it must pay.\n', '     * @param _shield Address of the shield to get owed amount for.\n', '     * @return owed Amount of Ether that the shield owes for past coverage.\n', '    **/\n', '    function getShieldOwed(\n', '        address _shield\n', '    )\n', '      public\n', '      view\n', '    returns(\n', '        uint256 owed\n', '    )\n', '    {\n', '        ShieldStats memory stats = shieldStats[_shield];\n', '        \n', '        // difference between current cumulative and cumulative at last shield update\n', '        uint256 pastDiff = cumCost - uint256(stats.lastCumCost);\n', '        uint256 currentDiff = costPerEth * ( block.timestamp - uint256(lastUpdate) );\n', '        \n', '        owed = (uint256(stats.ethValue) \n', '                  * pastDiff\n', '                  / 1 ether)\n', '                + (uint256(stats.ethValue)\n', '                  * currentDiff\n', '                  / 1 ether)\n', '                + uint256(stats.unpaid);\n', '    }\n', '    \n', '    /**\n', '     * @notice Record total values from last period and set new ones.\n', '    **/\n', '    function checkpoint()\n', '      internal\n', '    {\n', '        cumCost += costPerEth * (block.timestamp - lastUpdate);\n', '        costPerEth = totalCostPerSec\n', '                     * 1 ether \n', '                     / totalEthValue;\n', '        lastUpdate = block.timestamp;\n', '    }\n', '    \n', '    /**\n', "     * @notice Get the available amount of coverage for all shields' current values.\n", '    **/\n', '    function getAvailableCover()\n', '      public\n', '      view\n', '    returns(\n', '        uint256\n', '    )\n', '    {\n', '        uint256 ideal = totalEthValue \n', '                        * coverPct \n', '                        / DENOMINATOR;\n', '        return ArmorCore.availableCover(protocol, ideal);\n', '\n', '    }\n', '    \n', '    /**\n', "     * @notice Get the cost of coverage for all shields' current values.\n", '     * @param _amount The amount of coverage to get the cost of.\n', '    **/\n', '    function getCoverageCost(uint256 _amount)\n', '      public\n', '      view\n', '    returns(\n', '        uint256\n', '    )\n', '    {\n', '        return ArmorCore.calculatePricePerSec(protocol, _amount);\n', '    }\n', '    \n', '    /**\n', '     * @notice Check whether a new Ether value is available for purchase.\n', '     * @param _newEthValue The new Ether value of the shield.\n', '     * @return allowed True if we may purchase this much more coverage.\n', '    **/\n', '    function checkCoverage(\n', '      uint256 _newEthValue\n', '    )\n', '      public\n', '      view\n', '    returns(\n', '      bool allowed\n', '    )\n', '    {\n', '      uint256 desired = (totalEthValue \n', '                         + _newEthValue\n', '                         - uint256(shieldStats[msg.sender].ethValue) )\n', '                        * coverPct\n', '                        / DENOMINATOR;\n', '      allowed = ArmorCore.availableCover( protocol, desired ) == desired;\n', '    }\n', '\n', '    /**\n', '     * @notice Either add or delete a shield.\n', '     * @param _shield Address of the shield to edit.\n', '     * @param _active Whether we want it to be added or deleted.\n', '    **/\n', '    function editShield(\n', '        address _shield,\n', '        bool _active\n', '    )\n', '      external\n', '      onlyGov\n', '    {\n', '        // If active, set timestamp of last update to now, else delete.\n', '        if (_active) shieldStats[_shield] = ShieldStats( \n', '                                              uint128(cumCost), \n', '                                              0, \n', '                                              uint128(block.timestamp), \n', '                                              0 );\n', '        else delete shieldStats[_shield]; \n', '    }\n', '    \n', '    /**\n', '     * @notice Withdraw an amount of funds from arCore.\n', '    **/\n', '    function withdraw(address payable _beneficiary, uint256 _amount)\n', '      external\n', '      onlyGov\n', '    {\n', '        ArmorCore.withdraw(_amount);\n', '        _beneficiary.transfer(_amount);\n', '    }\n', '    \n', '    /**\n', '     * @notice Cancel entire arCore plan.\n', '    **/\n', '    function cancelCoverage()\n', '      external\n', '      onlyGov\n', '    {\n', '        ArmorCore.cancelPlan();\n', '    }\n', '    \n', '    /**\n', '     * @notice Governance may call to a redeem a claim for Ether that this contract held.\n', '     * @param _hackTime Time that the hack occurred.\n', '     * @param _amount Amount of funds to be redeemed.\n', '    **/\n', '    function redeemClaim(\n', '        uint256 _hackTime,\n', '        uint256 _amount\n', '    )\n', '      external\n', '      onlyGov\n', '    {\n', '        ArmorCore.claim(protocol, _hackTime, _amount);\n', '    }\n', '    \n', '    /**\n', '     * @notice Governance may disburse funds from a claim to the chosen shields.\n', '     * @param _shield Address of the shield to disburse funds to.\n', '     * @param _amount Amount of funds to disburse to the shield.\n', '    **/\n', '    function disburseClaim(\n', '        address payable _shield,\n', '        uint256 _amount\n', '    )\n', '      external\n', '      onlyGov\n', '    {\n', '        require(shieldStats[_shield].lastUpdate > 0 && IarShield(_shield).locked(), "Shield is not authorized to use this contract or shield is not locked.");\n', '        _shield.transfer(_amount);\n', '    }\n', '    \n', '    /**\n', '     * @notice Change the percent of coverage that should be bought. For example, 500 means that 50% of Ether value will be covered.\n', '     * @param _newPct New percent of coverage to be bought--1000 == 100%.\n', '    **/\n', '    function changeCoverPct(\n', '        uint256 _newPct\n', '    )\n', '      external\n', '      onlyGov\n', '    {\n', '        require(_newPct <= 10000, "Coverage percent may not be greater than 100%.");\n', '        coverPct = _newPct;    \n', '    }\n', '    \n', '}']