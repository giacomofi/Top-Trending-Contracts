['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-16\n', '*/\n', '\n', '// SPDX-License-Identifier: SimPL-2.0\n', 'pragma solidity ^0.6.2;\n', '\n', 'contract ToBeElonMusk {\n', '    string public name     = "ToBeElonMusk";\n', '    string public symbol   = "BEMUSK";\n', '    uint8  public decimals = 18;\n', '\n', '    // from WETH\n', '    event  Approval(address indexed src, address indexed guy, uint wad);\n', '    event  Transfer(address indexed src, address indexed dst, uint wad);\n', '    event  Deposit(address indexed dst, uint wad);\n', '    event  Withdrawal(address indexed src, uint wad);\n', '    \n', '    event  DepositTo(address indexed src, address indexed dst, uint toLevel, uint wad);\n', '    event  NewUser(address indexed src, address indexed parent);\n', '    event  Upgrade(address indexed src, uint toLevel);\n', '    event  MissOrder(address indexed src, address indexed dst, uint toLevel);\n', '\n', '    mapping (address => uint)                       public  balanceOf;\n', '    mapping (address => mapping (address => uint))  public  allowance;\n', '    \n', '    // main data\n', '    \n', '    mapping (address => uint)                       public  userLevel; // user => level\n', '    mapping (address => address)                    public  userTree; // child => parent\n', '    mapping (address => uint)                       public  childrenCount; // parnet => childrenCount\n', '    mapping (address => mapping (uint => uint))     public  userLevelReceivedAmount; // {user => {level => amount}}\n', '    mapping (address => mapping (uint => uint))     public  userLevelReceivedOrderCount; // {user => {level => success order num}}\n', '    mapping (address => mapping (uint => uint))     public  userLevelMissedOrderCount; // {parent => {level => missed order num}}\n', '\n', '    // address[9] public initedUser; // 9 address from level 1-> 9\n', '    address public king; // level 9\n', '    address public farmer; // level 1\n', '    \n', '    uint public price;\n', '    uint public maxLevel;\n', '    \n', '    address private owner;\n', '    uint private maxLoopTimes;\n', '    \n', '    bool public stopped = false;\n', '\n', '    // stoppable\n', '    modifier stoppable() {\n', '        require(!stopped);\n', '        _;\n', '    }\n', ' \n', '    function stop() public onlyOwner {\n', '        stopped = true;\n', '    }\n', '    function start() public onlyOwner {\n', '        stopped = false;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(\n', '            msg.sender == owner,\n', '            "Only owner can call this."\n', '        );\n', '        _;\n', '    }\n', '   \n', '    // constructor () public {\n', '    //     owner = msg.sender;\n', '    // }\n', '    \n', '    constructor (address[] memory _initedUser, uint _price) public {\n', '        owner = msg.sender;\n', '        init(_initedUser, _price);\n', '    }\n', '    \n', '    function init (address[] memory _initedUser, uint _price) public onlyOwner {\n', "        require(_initedUser.length >= 5, 'inited user error');\n", '        \n', '        initPrice(_price);\n', '        \n', '        maxLevel = _initedUser.length;\n', '        maxLoopTimes = maxLevel;\n', '        \n', '        king = _initedUser[0];\n', '        farmer = _initedUser[maxLevel - 1];\n', '\n', '        address parent = _initedUser[0]; \n', '        userLevel[parent] = maxLevel;\n', '        \n', '        for (uint i = 1; i < maxLevel; i++) {\n', '            address cur = _initedUser[i];\n', '            \n', '            userLevel[cur] = maxLevel - i;\n', '            userTree[cur] = parent;\n', '            \n', '            childrenCount[parent] += 1;\n', '            \n', '            parent = cur;\n', '        }\n', '    }\n', '    \n', '    function initPrice (uint _price) public onlyOwner {\n', "        require(_price > 0, 'price error');\n", '        price = _price;\n', '    }\n', '    \n', '    function findMyKing (address cur) view private returns (address)  {\n', '        if (cur == farmer) {\n', '            return king;\n', '        }\n', '        \n', '        // for limited loop i \n', '        uint i = 0;\n', '        address parent = cur;\n', '        while(i++ < maxLoopTimes) {\n', '            parent = userTree[parent];\n', '            if (userLevel[parent] == maxLevel) {\n', '                return parent;\n', '            }\n', '        }\n', '        return king;\n', '    }\n', '    \n', '    function depositTo (address to, uint toLevel, uint value) private {\n', '        balanceOf[to] += value;\n', '        \n', '        uint level = userLevel[to];\n', '        userLevelReceivedAmount[to][level] += value;\n', '        userLevelReceivedOrderCount[to][level] += 1;\n', '        \n', '        emit DepositTo(msg.sender, to, toLevel, value);\n', '    }\n', '    \n', '    function missOrder (address to, uint level) private {\n', '        userLevelMissedOrderCount[to][level] += 1;\n', '        \n', '        emit MissOrder(msg.sender, to, level);\n', '    }\n', '    \n', '    function isFull (address to, uint level) view private returns (bool) {\n', '        return userLevelReceivedAmount[to][level] >= maxReceiveAtLevel(level); // 3**level * price;\n', '    }\n', '    \n', '    function maxReceiveAtLevel (uint level) view private returns (uint) {\n', '        return 3**level * price;\n', '    }\n', '    \n', '    function canTotalReceive () view private returns (uint) {\n', '        uint total = 0;\n', '        for (uint level = 1; level <= maxLevel; level++) {\n', '            total += maxReceiveAtLevel(level);\n', '        }\n', '        return total;\n', '    }\n', '    \n', '    function payForUpgrade (address me, uint value) private returns (bool) {\n', "        require(value == price && price != 0, 'value error');\n", '        \n', '        uint myLevel = userLevel[me];\n', '        uint toLevel = myLevel + 1;\n', "        require(toLevel <= maxLevel, 'cannot upgrade');\n", '        \n', "        require (!(toLevel == 2 && userLevelReceivedOrderCount[me][1] < 3), 'to upgrade level 2, need at least 3 children');\n", '        \n', '        uint i = 0;\n', '        address parent = me;\n', '        bool found = false;\n', '        while(i++ < maxLoopTimes) {\n', '            parent = userTree[parent];\n', '            \n', '            if (parent == address(0)) {\n', '                break;\n', '            }\n', '            \n', '            if (userLevel[parent] == toLevel && !isFull(parent, toLevel)) {\n', '                found = true;\n', '                break;\n', '            }\n', '            else {\n', '               missOrder(parent, toLevel); \n', '            }\n', '        }\n', '        \n', '        if (!found) {\n', '            parent = king;\n', '        }\n', '        \n', '        depositTo(parent, toLevel, value);\n', '        userLevel[me] = toLevel;\n', '        \n', '        emit Upgrade(me, toLevel);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    \n', '    function payForNew (address me, address to, uint value) private returns (bool) {\n', "        require(value == price * 2 && price != 0, 'value error');\n", '        \n', '        if (to == address(0) || me == to || userLevel[to] == 0) {\n', '            to = farmer;\n', '        }\n', '        \n', '        address myKing = findMyKing(to);\n', '        \n', '        depositTo(to, 1, value/2);\n', '        depositTo(myKing, 1, value/2);\n', '        \n', '        userLevel[me] = 1;\n', '        userTree[me] = to;\n', '        \n', '        childrenCount[to] += 1;\n', '\n', '        emit NewUser(me, to);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    // pay to contract direct\n', '    // function() public payable {\n', '    //     pay(address(0));\n', '    // }\n', '    \n', '    function pay(address to) public payable stoppable returns (address) {\n', '        address me = msg.sender;\n', '        // old user\n', '        if (userLevel[me] > 0) {\n', '            payForUpgrade(me, msg.value);\n', '        }\n', '        // new user\n', '        else {\n', '            payForNew(me, to, msg.value);\n', '        }\n', '        return me;\n', '    }\n', '   \n', '    function deposit() public payable stoppable {\n', '        require(msg.value > 0);\n', '        balanceOf[msg.sender] += msg.value;\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '    \n', '    function withdraw(uint wad) public stoppable {\n', '        require(balanceOf[msg.sender] >= wad);\n', '        balanceOf[msg.sender] -= wad;\n', '        msg.sender.transfer(wad);\n', '        emit Withdrawal(msg.sender, wad);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return address(this).balance;\n', '    }\n', '\n', '    function approve(address guy, uint wad) public stoppable returns (bool) {\n', '        allowance[msg.sender][guy] = wad;\n', '        emit Approval(msg.sender, guy, wad);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address dst, uint wad) public stoppable returns (bool) {\n', '        return transferFrom(msg.sender, dst, wad);\n', '    }\n', '\n', '    function transferFrom(address src, address dst, uint wad)\n', '        public\n', '        stoppable\n', '        returns (bool)\n', '    {\n', '        require(balanceOf[src] >= wad);\n', '\n', '        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n', '            require(allowance[src][msg.sender] >= wad);\n', '            allowance[src][msg.sender] -= wad;\n', '        }\n', '\n', '        balanceOf[src] -= wad;\n', '        balanceOf[dst] += wad;\n', '\n', '        emit Transfer(src, dst, wad);\n', '\n', '        return true;\n', '    }\n', '}']