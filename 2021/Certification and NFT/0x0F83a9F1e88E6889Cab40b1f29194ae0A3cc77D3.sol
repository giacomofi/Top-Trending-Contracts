['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.9;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "Initializable.sol";\n', 'import "SafeMath.sol";\n', 'import "Ownable.sol";\n', 'import "IIdeaTokenFactory.sol";\n', 'import "IIdeaToken.sol";\n', 'import "IIdeaTokenNameVerifier.sol";\n', 'import "MinimalProxy.sol";\n', '/**\n', ' * @title IdeaTokenFactory\n', ' * @author Alexander Schlindwein\n', ' *\n', ' * Manages the creation of markets and IdeaTokens\n', ' * Sits behind an AdminUpgradabilityProxy\n', ' */\n', 'contract IdeaTokenFactory is IIdeaTokenFactory, Initializable, Ownable {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // Contains details for each market\n', '    struct MarketInfo {\n', '        mapping(uint => TokenInfo) tokens;\n', '        mapping(string => uint) tokenIDs;\n', '        mapping(string => bool) tokenNameUsed;\n', '\n', '        MarketDetails marketDetails;\n', '    }\n', '\n', '    uint constant FEE_SCALE = 10000;\n', '\n', '    // Address of the IdeaTokenExchange contract\n', '    // This is needed to transfer ownership of a newly created IdeaToken to the IdeaTokenExchange\n', '    address _ideaTokenExchange;\n', '\n', '    // Address of the IdeaToken logic contract\n', '    address _ideaTokenLogic;\n', '\n', '    // IdeaTokenAddress => IDPair. Stores an IDPair (marketID, tokenID) for an IdeaToken\n', '    mapping(address => IDPair) _tokenIDPairs;\n', '\n', '    // marketID => MarketInfo. Stores information for a market\n', '    mapping(uint => MarketInfo) _markets;\n', '    // market name => marketID. Translates market names to market IDs.\n', '    mapping(string => uint) _marketIDs;\n', '    // The amount of existing markets.\n', '    uint _numMarkets;\n', '\n', '    event NewMarket(uint id,\n', '                    string name,\n', '                    uint baseCost,\n', '                    uint priceRise,\n', '                    uint hatchTokens,\n', '                    uint tradingFeeRate,\n', '                    uint platformFeeRate,\n', '                    bool allInterestToPlatform,\n', '                    address nameVerifier);\n', '\n', '    event NewToken(uint id, uint marketID, string name, address addr, address lister);\n', '    event NewTradingFee(uint marketID, uint tradingFeeRate);\n', '    event NewPlatformFee(uint marketID, uint platformFeeRate);\n', '    event NewNameVerifier(uint marketID, address nameVerifier);\n', '\n', '    /**\n', '     * Initializes the contract with all required values\n', '     *\n', '     * @param owner The owner of the contract\n', '     */\n', '    function initialize(address owner, address ideaTokenExchange, address ideaTokenLogic) external initializer {\n', '        require(ideaTokenExchange != address(0) && ideaTokenLogic != address(0), "invalid-params");\n', '\n', '        setOwnerInternal(owner); // Checks owner to be non-zero\n', '        _ideaTokenExchange = ideaTokenExchange;\n', '        _ideaTokenLogic = ideaTokenLogic;\n', '    }\n', '\n', '    /**\n', '     * Adds a new market\n', '     * May only be called by the owner\n', '     *\n', '     * @param marketName The name of the market\n', '     * @param nameVerifier The address of the name verifier\n', '     * @param baseCost: The initial cost in Dai per IdeaToken in the first interval\n', '     * @param priceRise: The price rise in Dai per IdeaToken per completed interval\n', '     * @param hatchTokens: The amount of IdeaTokens for which the price does not change initially\n', '     * @param tradingFeeRate: The trading fee rate\n', '     * @param platformFeeRate: The platform fee rate\n', '     * @param allInterestToPlatform: If true, all interest goes to the platform instead of the token owner\n', '     */\n', '    function addMarket(string calldata marketName, address nameVerifier,\n', '                       uint baseCost, uint priceRise, uint hatchTokens,\n', '                       uint tradingFeeRate, uint platformFeeRate, bool allInterestToPlatform) external override onlyOwner {\n', '        require(_marketIDs[marketName] == 0, "market-exists");\n', '\n', '        require(nameVerifier != address(0) &&\n', '                baseCost > 0 &&\n', '                tradingFeeRate.add(platformFeeRate) <= FEE_SCALE,\n', '                "invalid-params");\n', '\n', '        uint marketID = ++_numMarkets;\n', '\n', '        MarketInfo memory marketInfo = MarketInfo({\n', '            marketDetails: MarketDetails({\n', '                exists: true,\n', '                id: marketID,\n', '                name: marketName,\n', '                nameVerifier: IIdeaTokenNameVerifier(nameVerifier),\n', '                numTokens: 0,\n', '                baseCost: baseCost,\n', '                priceRise: priceRise,\n', '                hatchTokens: hatchTokens,\n', '                tradingFeeRate: tradingFeeRate,\n', '                platformFeeRate: platformFeeRate,\n', '                allInterestToPlatform: allInterestToPlatform\n', '            })\n', '        });\n', '\n', '        _markets[marketID] = marketInfo;\n', '        _marketIDs[marketName] = marketID;\n', '\n', '        emitNewMarketEvent(marketInfo.marketDetails);\n', '    }\n', '\n', '    /// Stack too deep if we do it directly in `addMarket`\n', '    function emitNewMarketEvent(MarketDetails memory marketDetails) internal {\n', '        emit NewMarket(marketDetails.id,\n', '                       marketDetails.name,\n', '                       marketDetails.baseCost,\n', '                       marketDetails.priceRise,\n', '                       marketDetails.hatchTokens,\n', '                       marketDetails.tradingFeeRate,\n', '                       marketDetails.platformFeeRate,\n', '                       marketDetails.allInterestToPlatform,\n', '                       address(marketDetails.nameVerifier));\n', '    }\n', '\n', '    /**\n', '     * Adds a new IdeaToken using MinimalProxy\n', '     *\n', '     * @param tokenName The name of the token\n', '     * @param marketID The ID of the market\n', '     * @param lister The address of the account which off-chain software shall see as lister of this token. Only emitted, not stored\n', '     */\n', '    function addToken(string calldata tokenName, uint marketID, address lister) external override {\n', '        MarketInfo storage marketInfo = _markets[marketID];\n', '        require(marketInfo.marketDetails.exists, "market-not-exist");\n', '        require(isValidTokenName(tokenName, marketID), "invalid-name");\n', '\n', '        IIdeaToken ideaToken = IIdeaToken(address(new MinimalProxy(_ideaTokenLogic)));\n', '        ideaToken.initialize(string(abi.encodePacked(marketInfo.marketDetails.name, ": ", tokenName)), _ideaTokenExchange);\n', '\n', '        uint tokenID = ++marketInfo.marketDetails.numTokens;\n', '        TokenInfo memory tokenInfo = TokenInfo({\n', '            exists: true,\n', '            id: tokenID,\n', '            name: tokenName,\n', '            ideaToken: ideaToken\n', '        });\n', '\n', '        marketInfo.tokens[tokenID] = tokenInfo;\n', '        marketInfo.tokenIDs[tokenName] = tokenID;\n', '        marketInfo.tokenNameUsed[tokenName] = true;\n', '        _tokenIDPairs[address(ideaToken)] = IDPair({\n', '            exists: true,\n', '            marketID: marketID,\n', '            tokenID: tokenID\n', '        });\n', '\n', '        emit NewToken(tokenID, marketID, tokenName, address(ideaToken), lister);\n', '    }\n', '\n', '    /**\n', '     * Checks whether a token name is allowed and not used already\n', '     *\n', '     * @param tokenName The intended token name\n', '     * @param marketID The market on which the token is to be listed\n', '     *\n', '     * @return True if the name is allowed, false otherwise\n', '     */\n', '    function isValidTokenName(string calldata tokenName, uint marketID) public view override returns (bool) {\n', '\n', '        MarketInfo storage marketInfo = _markets[marketID];\n', '        MarketDetails storage marketDetails = marketInfo.marketDetails;\n', '\n', '        if(marketInfo.tokenNameUsed[tokenName] || !marketDetails.nameVerifier.verifyTokenName(tokenName)) {\n', '            return false;\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Returns the market id by the market name\n', '     *\n', '     * @param marketName The market name\n', '     *\n', '     * @return The market id\n', '     */\n', '    function getMarketIDByName(string calldata marketName) external view override returns (uint) {\n', '        return _marketIDs[marketName];\n', '    }\n', '\n', '    /**\n', '     * Returns the market details by the market id\n', '     *\n', '     * @param marketID The market id\n', '     *\n', '     * @return The market details\n', '     */\n', '    function getMarketDetailsByID(uint marketID) external view override returns (MarketDetails memory) {\n', '        return _markets[marketID].marketDetails;\n', '    }\n', '\n', '    /**\n', '     * Returns the market details by the market name\n', '     *\n', '     * @param marketName The market name\n', '     *\n', '     * @return The market details\n', '     */\n', '    function getMarketDetailsByName(string calldata marketName) external view override returns (MarketDetails memory) {\n', '        return _markets[_marketIDs[marketName]].marketDetails;\n', '    }\n', '\n', '    function getMarketDetailsByTokenAddress(address ideaToken) external view override returns (MarketDetails memory) {\n', '        return _markets[_tokenIDPairs[ideaToken].marketID].marketDetails;\n', '    }\n', '\n', '    /**\n', '     * Returns the amount of existing markets\n', '     *\n', '     * @return The amount of existing markets\n', '     */\n', '    function getNumMarkets() external view override  returns (uint) {\n', '        return _numMarkets;\n', '    }\n', '\n', '    /**\n', '     * Returns the token id by the token name and market id\n', '     *\n', '     * @param tokenName The token name\n', '     * @param marketID The market id\n', '     *\n', '     * @return The token id\n', '     */\n', '    function getTokenIDByName(string calldata tokenName, uint marketID) external view override returns (uint) {\n', '        return _markets[marketID].tokenIDs[tokenName];\n', '    }\n', '\n', '    /**\n', '     * Returns the token info by the token id and market id\n', '     *\n', '     * @param marketID The market id\n', '     * @param tokenID The token id\n', '     *\n', '     * @return The token info\n', '     */\n', '    function getTokenInfo(uint marketID, uint tokenID) external view override returns (TokenInfo memory) {\n', '        return _markets[marketID].tokens[tokenID];\n', '    }\n', '\n', '    /**\n', '     * Returns the token id pair by the tokens address\n', '     *\n', '     * @param token The tokens address\n', '     *\n', '     * @return The token id pair\n', '     */\n', '    function getTokenIDPair(address token) external view override returns (IDPair memory) {\n', '        return _tokenIDPairs[token];\n', '    }\n', '\n', '    /**\n', '     * Sets the trading fee for a market\n', '     * May only be called by the owner\n', '     *\n', '     * @param marketID The market id for which to set the trading fee\n', '     * @param tradingFeeRate The trading fee\n', '     */\n', '    function setTradingFee(uint marketID, uint tradingFeeRate) external override onlyOwner {\n', '        MarketDetails storage marketDetails = _markets[marketID].marketDetails;\n', '        require(marketDetails.exists, "market-not-exist");\n', '        require(marketDetails.platformFeeRate.add(tradingFeeRate) <= FEE_SCALE, "invalid-fees");\n', '        marketDetails.tradingFeeRate = tradingFeeRate;\n', '        \n', '        emit NewTradingFee(marketID, tradingFeeRate);\n', '    }\n', '\n', '    /**\n', '     * Sets the platform fee for a market\n', '     * May only be called by the owner\n', '     *\n', '     * @param marketID The market id for which to set the platform fee\n', '     * @param platformFeeRate The platform fee\n', '     */\n', '    function setPlatformFee(uint marketID, uint platformFeeRate) external override onlyOwner {\n', '        MarketDetails storage marketDetails = _markets[marketID].marketDetails;\n', '        require(marketDetails.exists, "market-not-exist");\n', '        require(marketDetails.tradingFeeRate.add(platformFeeRate) <= FEE_SCALE, "invalid-fees");\n', '        marketDetails.platformFeeRate = platformFeeRate;\n', '\n', '        emit NewPlatformFee(marketID, platformFeeRate);\n', '    }\n', '\n', '    /**\n', '     * Changes the address of the name verifier for a market\n', '     * May only be called by the owner\n', '     *\n', '     * @param marketID The marketID for which to change the name verifier\n', '     * @param nameVerifier The new name verifier address\n', '     */\n', '    function setNameVerifier(uint marketID, address nameVerifier) external override onlyOwner {\n', '        require(nameVerifier != address(0), "zero-verifier");\n', '\n', '        MarketDetails storage marketDetails = _markets[marketID].marketDetails;\n', '        require(marketDetails.exists, "market-not-exist");\n', '        marketDetails.nameVerifier = IIdeaTokenNameVerifier(nameVerifier);\n', '\n', '        emit NewNameVerifier(marketID, nameVerifier);\n', '    }\n', '}']