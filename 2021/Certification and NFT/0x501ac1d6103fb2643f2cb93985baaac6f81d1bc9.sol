['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-30\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.6;\n', '\n', '\n', '//------------------------------------------------------------------------------------------------------------------\n', '//\n', '// ethbox\n', '//\n', '// https://www.ethbox.org/\n', '//\n', '//\n', '// ethbox is a smart contract based escrow service. Instead of sending funds from A to B,\n', '// users send funds through ethbox. This enables users to abort outgoing transactions\n', '// in case of a wrong recipient address.\n', '//\n', '// Funds are put in "boxes". Each box contains all the relevant data for that transaction.\n', '// Boxes can be secured with a passphrase. Users can request ETH or tokens in return\n', '// for their deposit (= OTC trade).\n', '//\n', '// The passphrase gets hashed twice. This is because the smart contract needs to do\n', "// its own hashing so that it cannot be manipulated - But the passphrase shouldn't\n", '// be submitted in clear-text all over the web, so it gets hashed, and the hash of\n', '// that is stored on the smart contract, so it can recognize when it is given the\n', '// correct passphrase.\n', '//\n', '// Depositing funds into contract = createBox(...)\n', '// Retrieving funds from contract = clearBox(...)\n', '//\n', '//------------------------------------------------------------------------------------------------------------------\n', '\n', '\n', 'contract ethbox\n', '{\n', '    // Transaction data\n', '    struct Box {\n', '        address         payable sender;\n', '        address         recipient;\n', '        bytes32         passHashHash;\n', '        ERC20Interface  sendToken;\n', '        uint            sendValue;\n', '        ERC20Interface  requestToken;\n', '        uint            requestValue;\n', '        uint            timestamp;\n', '        bool            taken;\n', '    }\n', '\n', '\tstruct BoxWithPrivacy {\n', '        bytes32         senderHash;\n', '        bytes32         recipientHash;\n', '        bytes32         passHashHash;\n', '        ERC20Interface  sendToken;\n', '        uint            sendValue;\n', '        uint            timestamp;\n', '        bool            taken;\n', '    }\n', '    \n', '\taddress owner;\n', '\tbool public stopDeposits = false; \n', '\n', '\tBox[] boxes;\n', '\tBoxWithPrivacy[] boxesWithPrivacy;   \n', '\n', '    // Map box indexes to addresses for easier handling / privacy, so users are shown only their own boxes by the contract\n', '    mapping(address => uint[]) senderMap;\n', '    mapping(address => uint[]) recipientMap;\n', '\tmapping(bytes32 => uint[]) senderMapWithPrivacy;\n', '    mapping(bytes32 => uint[]) recipientMapWithPrivacy;\n', '\n', '\n', '    // Deposit funds into contract\n', '    function createBox(address _recipient, ERC20Interface _sendToken, uint _sendValue, ERC20Interface _requestToken, uint _requestValue, bytes32 _passHashHash) external payable\n', '    {\n', "        // Make sure deposits haven't been disabled (will be done when switching to new contract version)\n", '        require(!stopDeposits, "Depositing to this ethbox contract has been disabled. You can still withdraw funds.");\n', '        \n', '        // Max 20 outgoing boxes per address, for now\n', '        require(senderMap[msg.sender].length < 20, "ethbox currently supports a maximum of 20 outgoing transactions per address.");\n', '    \n', '        Box memory newBox;\n', '        newBox.sender       = payable(msg.sender);\n', '        newBox.recipient    = _recipient;\n', '        newBox.passHashHash = _passHashHash;\n', '        newBox.sendToken    = _sendToken;\n', '        newBox.sendValue    = _sendValue;\n', '        newBox.requestToken = _requestToken;\n', '        newBox.requestValue = _requestValue;\n', '        newBox.timestamp    = block.timestamp;\n', '        newBox.taken        = false;\n', '        boxes.push(newBox);\n', '        \n', '        // Save box index to mappings for sender & recipient\n', '        senderMap[msg.sender].push(boxes.length - 1);\n', '        recipientMap[_recipient].push(boxes.length - 1);\n', '        \n', '        if(_sendToken == ERC20Interface(address(0)))\n', '            // Sending ETH\n', '            require(msg.value == _sendValue, "Insufficient ETH!");\n', '        else {\n', '            // Sending tokens\n', '            require(_sendToken.balanceOf(msg.sender) >= _sendValue, "Insufficient tokens!");\n', '            require(_sendToken.transferFrom(msg.sender, address(this), _sendValue), "Transferring tokens to ethbox smart contract failed!");\n', '        }\n', '    }\n', '\n', '\tfunction createBoxWithPrivacy(bytes32 _recipientHash, ERC20Interface _sendToken, uint _sendValue, bytes32 _passHashHash) external payable\n', '    {\n', "        // Make sure deposits haven't been disabled (will be done when switching to new contract version)\n", '        require(!stopDeposits, "Depositing to this ethbox contract has been disabled. You can still withdraw funds.");\n', '        \n', '        // Max 20 outgoing boxes per address, for now\n', '        require(senderMapWithPrivacy[keccak256(abi.encodePacked(msg.sender))].length < 20, "ethbox currently supports a maximum of 20 outgoing transactions per address.");\n', '    \n', '        BoxWithPrivacy memory newBox;\n', '        newBox.senderHash       = keccak256(abi.encodePacked(msg.sender));\n', '        newBox.recipientHash    = _recipientHash;\n', '        newBox.passHashHash     = _passHashHash;\n', '        newBox.sendToken        = _sendToken;\n', '        newBox.sendValue        = _sendValue;\n', '        newBox.timestamp        = block.timestamp;\n', '        newBox.taken            = false;\n', '        boxesWithPrivacy.push(newBox);\n', '        \n', '        // Save box index to mappings for sender & recipient\n', '        senderMapWithPrivacy[newBox.senderHash].push(boxesWithPrivacy.length - 1);\n', '        recipientMapWithPrivacy[newBox.recipientHash].push(boxesWithPrivacy.length - 1);\n', '        \n', '        if(_sendToken == ERC20Interface(address(0)))\n', '            // Sending ETH\n', '            require(msg.value == _sendValue, "Insufficient ETH!");\n', '        else {\n', '            // Sending tokens\n', '            require(_sendToken.balanceOf(msg.sender) >= _sendValue, "Insufficient tokens!");\n', '            require(_sendToken.transferFrom(msg.sender, address(this), _sendValue), "Transferring tokens to ethbox smart contract failed!");\n', '        }\n', '    }\n', '    \n', '    // Retrieve funds from contract, only as recipient (when sending tokens: have to ask for approval beforehand in web browser interface)\n', '    function clearBox(uint _boxIndex, bytes32 _passHash) external payable\n', '    {\n', '        require((_boxIndex < boxes.length) && (!boxes[_boxIndex].taken), "Invalid box index!");\n', '        require(msg.sender != boxes[_boxIndex].sender, "Please use \'cancelBox\' to cancel transactions as sender!");\n', '\n', '        // Recipient needs to have correct passphrase (hashed) and requested ETH / tokens\n', '        require(\n', '            (msg.sender == boxes[_boxIndex].recipient)\n', '            && (boxes[_boxIndex].passHashHash == keccak256(abi.encodePacked(_passHash)))\n', '        ,\n', '            "Deposited funds can only be retrieved by recipient with correct passphrase."\n', '        );\n', '        \n', "\t\t// Mark box as taken, so it can't be taken another time\n", '        boxes[_boxIndex].taken = true;\n', '        \n', '        // Transfer requested ETH / tokens to sender\n', '        if(boxes[_boxIndex].requestValue != 0) {\n', '            if(boxes[_boxIndex].requestToken == ERC20Interface(address(0))) {\n', '                require(msg.value == boxes[_boxIndex].requestValue, "Incorrect amount of ETH attached to transaction, has to be exactly as much as requested!");\n', '                payable(boxes[_boxIndex].sender).transfer(msg.value);\n', '            } else {\n', '                require(boxes[_boxIndex].requestToken.balanceOf(msg.sender) >= boxes[_boxIndex].requestValue, "Recipient does not have enough tokens to fulfill sender\'s request!");\n', '                require(boxes[_boxIndex].requestToken.transferFrom(msg.sender, boxes[_boxIndex].sender, boxes[_boxIndex].requestValue), "Transferring requested tokens to sender failed!");\n', '            }\n', '        }\n', '\n', '        // Transfer sent ETH / tokens to recipient\n', '        if(boxes[_boxIndex].sendToken == ERC20Interface(address(0)))\n', '            payable(msg.sender).transfer(boxes[_boxIndex].sendValue);\n', '        else\n', '            require(boxes[_boxIndex].sendToken.transfer(msg.sender, boxes[_boxIndex].sendValue), "Transferring tokens to recipient failed!");\n', '    }\n', '\n', '\tfunction clearBoxWithPrivacy(uint _boxIndex, bytes32 _passHash) external payable\n', '    {\n', '        require((_boxIndex < boxesWithPrivacy.length) && (!boxesWithPrivacy[_boxIndex].taken), "Invalid box index!");\n', '        require(keccak256(abi.encodePacked(msg.sender)) != boxesWithPrivacy[_boxIndex].senderHash, "Please use \'cancelBox\' to cancel transactions as sender!");\n', '\n', '        // Recipient needs to have correct passphrase (hashed)\n', '        require(\n', '            (keccak256(abi.encodePacked(msg.sender)) == boxesWithPrivacy[_boxIndex].recipientHash)\n', '            && (boxesWithPrivacy[_boxIndex].passHashHash == keccak256(abi.encodePacked(_passHash)))\n', '        ,\n', '            "Deposited funds can only be retrieved by recipient with correct passphrase."\n', '        );\n', '        \n', "        // Mark box as taken, so it can't be taken another time\n", '        boxesWithPrivacy[_boxIndex].taken = true;\n', '        \n', '        // Transfer sent ETH / tokens to recipient\n', '        if(boxesWithPrivacy[_boxIndex].sendToken == ERC20Interface(address(0)))\n', '            payable(msg.sender).transfer(boxesWithPrivacy[_boxIndex].sendValue);\n', '        else\n', '            require(boxesWithPrivacy[_boxIndex].sendToken.transfer(msg.sender, boxesWithPrivacy[_boxIndex].sendValue), "Transferring tokens to recipient failed!");\n', '    }\n', '    \n', '    // Cancel transaction, only as sender (when sending tokens: have to ask for approval beforehand in web browser interface)\n', '    function cancelBox(uint _boxIndex) external payable\n', '    {\n', '        require((_boxIndex < boxes.length) && (!boxes[_boxIndex].taken), "Invalid box index!");\n', '        require(msg.sender == boxes[_boxIndex].sender, "Transactions can only be cancelled by sender.");\n', '        \n', "        // Mark box as taken, so it can't be taken another time\n", '        boxes[_boxIndex].taken = true;\n', '        \n', '        // Transfer ETH / tokens back to sender\n', '        if(boxes[_boxIndex].sendToken == ERC20Interface(address(0)))\n', '            payable(msg.sender).transfer(boxes[_boxIndex].sendValue);\n', '        else\n', '            require(boxes[_boxIndex].sendToken.transfer(msg.sender, boxes[_boxIndex].sendValue), "Transferring tokens back to sender failed!");\n', '    }\n', '\n', '\tfunction cancelBoxWithPrivacy(uint _boxIndex) external payable\n', '    {\n', '        require((_boxIndex < boxesWithPrivacy.length) && (!boxesWithPrivacy[_boxIndex].taken), "Invalid box index!");\n', '        require(keccak256(abi.encodePacked(msg.sender)) == boxesWithPrivacy[_boxIndex].senderHash, "Transactions can only be cancelled by sender.");\n', '        \n', "         // Mark box as taken, so it can't be taken another time\n", '        boxesWithPrivacy[_boxIndex].taken = true;\n', '        \n', '        // Transfer ETH / tokens back to sender\n', '        if(boxesWithPrivacy[_boxIndex].sendToken == ERC20Interface(address(0)))\n', '            payable(msg.sender).transfer(boxesWithPrivacy[_boxIndex].sendValue);\n', '        else\n', '            require(boxesWithPrivacy[_boxIndex].sendToken.transfer(msg.sender, boxesWithPrivacy[_boxIndex].sendValue), "Transferring tokens back to sender failed!");\n', '    }\n', '      \n', '    // Retrieve single box by index - only for sender / recipient & contract owner\n', '    function getBox(uint _boxIndex) external view returns(Box memory)\n', '    {\n', '        require(\n', '            (msg.sender == owner)\n', '            || (msg.sender == boxes[_boxIndex].sender)\n', '            || (msg.sender == boxes[_boxIndex].recipient)\n', '        , \n', '            "Transaction data is only accessible by sender or recipient."\n', '        );\n', '        \n', '        return boxes[_boxIndex];\n', '    }\n', '\n', '\tfunction getBoxWithPrivacy(uint _boxIndex) external view returns(BoxWithPrivacy memory)\n', '    {\n', '        require(\n', '            (msg.sender == owner)\n', '            || (keccak256(abi.encodePacked(msg.sender)) == boxesWithPrivacy[_boxIndex].senderHash)\n', '            || (keccak256(abi.encodePacked(msg.sender)) == boxesWithPrivacy[_boxIndex].recipientHash)\n', '        , \n', '            "Transaction data is only accessible by sender or recipient."\n', '        );\n', '        \n', '        return boxesWithPrivacy[_boxIndex];\n', '    }\n', '    \n', '    // Retrieve sender address => box index mapping for user\n', '    function getBoxesOutgoing() external view returns(uint[] memory)\n', '    {\n', '        return senderMap[msg.sender];\n', '    }\n', '\n', '\tfunction getBoxesOutgoingWithPrivacy() external view returns(uint[] memory)\n', '    {\n', '        return senderMapWithPrivacy[keccak256(abi.encodePacked(msg.sender))];\n', '    }\n', '    \n', '    // Retrieve recipient address => box index mapping for user\n', '    function getBoxesIncoming() external view returns(uint[] memory)\n', '    {\n', '        return recipientMap[msg.sender];\n', '    }\n', '\n', '\tfunction getBoxesIncomingWithPrivacy() external view returns(uint[] memory)\n', '    {\n', '        return recipientMapWithPrivacy[keccak256(abi.encodePacked(msg.sender))];\n', '    }\n', '    \n', '    // Retrieve complete boxes array, only for contract owner\n', '    function getBoxesAll() external view returns(Box[] memory)\n', '    {\n', '        require(msg.sender == owner, "Non-specific transaction data is not accessible by the general public.");\n', '        return boxes;\n', '    }\n', '\n', '\tfunction getBoxesAllWithPrivacy() external view returns(BoxWithPrivacy[] memory)\n', '    {\n', '        require(msg.sender == owner, "Non-specific transaction data is not accessible by the general public.");\n', '        return boxesWithPrivacy;\n', '    }\n', '    \n', '    // Retrieve number of boxes, only for contract owner\n', '    function getNumBoxes() external view returns(uint)\n', '    {\n', '        require(msg.sender == owner, "Non-specific transaction data is not accessible by the general public.");\n', '        return boxes.length;\n', '    }\n', '\n', '\tfunction getNumBoxesWithPrivacy() external view returns(uint)\n', '    {\n', '        require(msg.sender == owner, "Non-specific transaction data is not accessible by the general public.");\n', '        return boxesWithPrivacy.length;\n', '    }\n', '\n', '\tfunction cancelAllNonPrivacyBoxes() external\n', '    {\n', '\t\trequire(msg.sender == owner, "This function is reserved for administration.");\n', '\n', '\t\tfor(uint i = 0; i < boxes.length; i++)\n', '\t\t\tif(!boxes[i].taken) {\n', "\t\t\t\t// Mark box as taken, so it can't be taken another time\n", '\t\t\t\tboxes[i].taken = true;\n', '\n', '\t\t\t\t// Transfer ETH / tokens back to sender\n', '\t\t\t\tif(boxes[i].sendToken == ERC20Interface(address(0)))\n', '\t\t\t\t\tboxes[i].sender.transfer(boxes[i].sendValue);\n', '\t\t\t\telse\n', '\t\t\t\t\trequire(boxes[i].sendToken.transfer(boxes[i].sender, boxes[i].sendValue), "Transferring tokens back to sender failed!");\n', '\t\t\t}\n', '    }\n', '\n', '\tfunction setStopDeposits(bool _state) external\n', '\t{\n', '\t\trequire(msg.sender == owner, "This function is reserved for administration.");\n', '\n', '\t\tstopDeposits = _state;\n', '\t}\n', '    \n', "    // Don't accept incoming ETH\n", '    fallback() external payable\n', '    {\n', '        revert("Please don\'t send funds directly to the ethbox smart contract.");\n', '    }\n', '    \n', '    constructor()\n', '    {\n', '        owner = msg.sender;\n', '    }\n', '}\n', '\n', '\n', 'interface ERC20Interface\n', '{\n', '    // Standard ERC 20 token interface\n', '\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}']