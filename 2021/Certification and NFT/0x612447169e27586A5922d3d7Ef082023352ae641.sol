['pragma solidity ^0.5.16;\n', '\n', 'import "./GToken.sol";\n', 'import "./ErrorReporter.sol";\n', 'import "./PriceOracle.sol";\n', 'import "./ComptrollerInterface.sol";\n', 'import "./ComptrollerStorage.sol";\n', 'import "./ComptrollerProxy.sol";\n', '\n', '\n', '/**\n', ' * @title Comptroller Contract\n', ' * \n', ' */\n', 'contract Comptroller is ComptrollerV5Storage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {\n', '    /// @notice Emitted when an admin supports a market\n', '    event MarketListed(GToken gToken);\n', '\n', '    /// @notice Emitted when an account enters a market\n', '    event MarketEntered(GToken gToken, address account);\n', '\n', '    /// @notice Emitted when an account exits a market\n', '    event MarketExited(GToken gToken, address account);\n', '\n', '    /// @notice Emitted when close factor is changed by admin\n', '    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n', '\n', '    /// @notice Emitted when a collateral factor is changed by admin\n', '    event NewCollateralFactor(GToken gToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n', '\n', '    /// @notice Emitted when liquidation incentive is changed by admin\n', '    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n', '\n', '    /// @notice Emitted when price oracle is changed\n', '    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n', '\n', '    /// @notice Emitted when pause guardian is changed\n', '    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n', '\n', '    /// @notice Emitted when an action is paused globally\n', '    event ActionPaused(string action, bool pauseState);\n', '\n', '    /// @notice Emitted when an action is paused on a market\n', '    event ActionPaused(GToken gToken, string action, bool pauseState);\n', '\n', '    /// @notice Emitted when a new GOF speed is calculated for a market\n', '    event GofSpeedUpdated(GToken indexed gToken, uint newSpeed);\n', '\n', '    /// @notice Emitted when a new GOF speed is set for a contributor\n', '    event ContributorGofSpeedUpdated(address indexed contributor, uint newSpeed);\n', '\n', '    /// @notice Emitted when GOF is distributed to a supplier\n', '    event DistributedSupplierGof(GToken indexed gToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n', '\n', '    /// @notice Emitted when GOF is distributed to a borrower\n', '    event DistributedBorrowerGof(GToken indexed gToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n', '\n', '    /// @notice Emitted when borrow cap for a gToken is changed\n', '    event NewBorrowCap(GToken indexed gToken, uint newBorrowCap);\n', '\n', '    /// @notice Emitted when borrow cap guardian is changed\n', '    event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n', '\n', '    /// @notice Emitted when GOF is granted by admin\n', '    event GofGranted(address recipient, uint amount);\n', '\n', '    /// @notice The initial GOF index for a market\n', '    uint224 public constant gofInitialIndex = 1e36;\n', '\n', '    // closeFactorMantissa must be strictly greater than this value\n', '    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n', '\n', '    // closeFactorMantissa must not exceed this value\n', '    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n', '\n', '    // No collateralFactorMantissa may exceed this value\n', '    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n', '\n', '    constructor() public {\n', '        admin = msg.sender;\n', '    }\n', '\n', '    /*** Assets You Are In ***/\n', '\n', '    /**\n', '     * @notice Returns the assets an account has entered\n', '     * @param account The address of the account to pull assets for\n', '     * @return A dynamic list with the assets the account has entered\n', '     */\n', '    function getAssetsIn(address account) external view returns (GToken[] memory) {\n', '        GToken[] memory assetsIn = accountAssets[account];\n', '\n', '        return assetsIn;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns whether the given account is entered in the given asset\n', '     * @param account The address of the account to check\n', '     * @param gToken The gToken to check\n', '     * @return True if the account is in the asset, otherwise false.\n', '     */\n', '    function checkMembership(address account, GToken gToken) external view returns (bool) {\n', '        return markets[address(gToken)].accountMembership[account];\n', '    }\n', '\n', '    /**\n', '     * @notice Add assets to be included in account liquidity calculation\n', '     * @param gTokens The list of addresses of the gToken markets to be enabled\n', '     * @return Success indicator for whether each corresponding market was entered\n', '     */\n', '    function enterMarkets(address[] memory gTokens) public returns (uint[] memory) {\n', '        uint len = gTokens.length;\n', '        require(len <= 100, "Too many");\n', '\n', '        uint[] memory results = new uint[](len);\n', '        for (uint i = 0; i < len; i++) {\n', '            GToken gToken = GToken(gTokens[i]);\n', '\n', '            results[i] = uint(addToMarketInternal(gToken, msg.sender));\n', '        }\n', '\n', '        return results;\n', '    }\n', '\n', '    /**\n', '     * @notice Add the market to the borrower\'s "assets in" for liquidity calculations\n', '     * @param gToken The market to enter\n', '     * @param borrower The address of the account to modify\n', '     * @return Success indicator for whether the market was entered\n', '     */\n', '    function addToMarketInternal(GToken gToken, address borrower) internal returns (Error) {\n', '        Market storage marketToJoin = markets[address(gToken)];\n', '\n', '        if (!marketToJoin.isListed) {\n', '            // market is not listed, cannot join\n', '            return Error.MARKET_NOT_LISTED;\n', '        }\n', '\n', '        if (marketToJoin.accountMembership[borrower] == true) {\n', '            // already joined\n', '            return Error.NO_ERROR;\n', '        }\n', '\n', '        // survived the gauntlet, add to list\n', '        // NOTE: we store these somewhat redundantly as a significant optimization\n', '        //  this avoids having to iterate through the list for the most common use cases\n', '        //  that is, only when we need to perform liquidity checks\n', '        //  and not whenever we want to check if an account is in a particular market\n', '        marketToJoin.accountMembership[borrower] = true;\n', '        accountAssets[borrower].push(gToken);\n', '\n', '        emit MarketEntered(gToken, borrower);\n', '\n', '        return Error.NO_ERROR;\n', '    }\n', '\n', '    /**\n', "     * @notice Removes asset from sender's account liquidity calculation\n", '     * @dev Sender must not have an outstanding borrow balance in the asset,\n', '     *  or be providing necessary collateral for an outstanding borrow.\n', '     * @param gTokenAddress The address of the asset to be removed\n', '     * @return Whether or not the account successfully exited the market\n', '     */\n', '    function exitMarket(address gTokenAddress) external returns (uint) {\n', '        GToken gToken = GToken(gTokenAddress);\n', '        /* Get sender tokensHeld and amountOwed underlying from the gToken */\n', '        (uint oErr, uint tokensHeld, uint amountOwed, ) = gToken.getAccountSnapshot(msg.sender);\n', '        require(oErr == 0, "exitMarket: getAccountSnapshot failed"); // semi-opaque error code\n', '\n', '        /* Fail if the sender has a borrow balance */\n', '        if (amountOwed != 0) {\n', '            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n', '        }\n', '\n', '        /* Fail if the sender is not permitted to redeem all of their tokens */\n', '        uint allowed = redeemAllowedInternal(gTokenAddress, msg.sender, tokensHeld);\n', '        if (allowed != 0) {\n', '            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n', '        }\n', '\n', '        Market storage marketToExit = markets[address(gToken)];\n', '\n', '        /* Return true if the sender is not already ‘in’ the market */\n', '        if (!marketToExit.accountMembership[msg.sender]) {\n', '            return uint(Error.NO_ERROR);\n', '        }\n', '\n', '        /* Set gToken account membership to false */\n', '        delete marketToExit.accountMembership[msg.sender];\n', '\n', '        /* Delete gToken from the account’s list of assets */\n', '        // load into memory for faster iteration\n', '        GToken[] memory userAssetList = accountAssets[msg.sender];\n', '        uint len = userAssetList.length;\n', '        uint assetIndex = len;\n', '        for (uint i = 0; i < len; i++) {\n', '            if (userAssetList[i] == gToken) {\n', '                assetIndex = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        // We *must* have found the asset in the list or our redundant data structure is broken\n', '        assert(assetIndex < len);\n', '\n', '        // copy last item in list to location of item to be removed, reduce length by 1\n', '        GToken[] storage storedList = accountAssets[msg.sender];\n', '        storedList[assetIndex] = storedList[storedList.length - 1];\n', '        storedList.length--;\n', '\n', '        emit MarketExited(gToken, msg.sender);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /*** Policy Hooks ***/\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to mint tokens in the given market\n', '     * @param gToken The market to verify the mint against\n', '     * @param minter The account which would get the minted tokens\n', '     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n', '     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function mintAllowed(address gToken, address minter, uint mintAmount) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!mintGuardianPaused[gToken], "mint is paused");\n', '\n', '        // Shh - currently unused\n', '        minter;\n', '        mintAmount;\n', '\n', '        if (!markets[gToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        updateGofSupplyIndex(gToken);\n', '        distributeSupplierGof(gToken, minter);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates mint and reverts on rejection. May emit logs.\n', '     * @param gToken Asset being minted\n', '     * @param minter The address minting the tokens\n', '     * @param actualMintAmount The amount of the underlying asset being minted\n', '     * @param mintTokens The number of tokens being minted\n', '     */\n', '    function mintVerify(address gToken, address minter, uint actualMintAmount, uint mintTokens) external {\n', '        // Shh - currently unused\n', '        gToken;\n', '        minter;\n', '        actualMintAmount;\n', '        mintTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to redeem tokens in the given market\n', '     * @param gToken The market to verify the redeem against\n', '     * @param redeemer The account which would redeem the tokens\n', '     * @param redeemTokens The number of gTokens to exchange for the underlying asset in the market\n', '     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function redeemAllowed(address gToken, address redeemer, uint redeemTokens) external returns (uint) {\n', '        uint allowed = redeemAllowedInternal(gToken, redeemer, redeemTokens);\n', '        if (allowed != uint(Error.NO_ERROR)) {\n', '            return allowed;\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        updateGofSupplyIndex(gToken);\n', '        distributeSupplierGof(gToken, redeemer);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    function redeemAllowedInternal(address gToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n', '        if (!markets[gToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', "        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n", '        if (!markets[gToken].accountMembership[redeemer]) {\n', '            return uint(Error.NO_ERROR);\n', '        }\n', '\n', '        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n', '        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, GToken(gToken), redeemTokens, 0);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall > 0) {\n', '            return uint(Error.INSUFFICIENT_LIQUIDITY);\n', '        }\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates redeem and reverts on rejection. May emit logs.\n', '     * @param gToken Asset being redeemed\n', '     * @param redeemer The address redeeming the tokens\n', '     * @param redeemAmount The amount of the underlying asset being redeemed\n', '     * @param redeemTokens The number of tokens being redeemed\n', '     */\n', '    function redeemVerify(address gToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\n', '        // Shh - currently unused\n', '        gToken;\n', '        redeemer;\n', '\n', '        // Require tokens is zero or amount is also zero\n', '        if (redeemTokens == 0 && redeemAmount > 0) {\n', '            revert("redeemTokens zero");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n', '     * @param gToken The market to verify the borrow against\n', '     * @param borrower The account which would borrow the asset\n', '     * @param borrowAmount The amount of underlying the account would borrow\n', '     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function borrowAllowed(address gToken, address borrower, uint borrowAmount) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!borrowGuardianPaused[gToken], "borrow is paused");\n', '\n', '        if (!markets[gToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        if (!markets[gToken].accountMembership[borrower]) {\n', '            // only gTokens may call borrowAllowed if borrower not in market\n', '            require(msg.sender == gToken, "sender must be gToken");\n', '\n', '            // attempt to add borrower to the market\n', '            Error err = addToMarketInternal(GToken(msg.sender), borrower);\n', '            if (err != Error.NO_ERROR) {\n', '                return uint(err);\n', '            }\n', '\n', '            // it should be impossible to break the important invariant\n', '            assert(markets[gToken].accountMembership[borrower]);\n', '        }\n', '\n', '        if (oracle.getUnderlyingPrice(GToken(gToken)) == 0) {\n', '            return uint(Error.PRICE_ERROR);\n', '        }\n', '\n', '\n', '        uint borrowCap = borrowCaps[gToken];\n', '        // Borrow cap of 0 corresponds to unlimited borrowing\n', '        if (borrowCap != 0) {\n', '            uint totalBorrows = GToken(gToken).totalBorrows();\n', '            uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\n', '            require(nextTotalBorrows < borrowCap, "market borrow cap reached");\n', '        }\n', '\n', '        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, GToken(gToken), 0, borrowAmount);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall > 0) {\n', '            return uint(Error.INSUFFICIENT_LIQUIDITY);\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        Exp memory borrowIndex = Exp({mantissa: GToken(gToken).borrowIndex()});\n', '        updateGofBorrowIndex(gToken, borrowIndex);\n', '        distributeBorrowerGof(gToken, borrower, borrowIndex);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates borrow and reverts on rejection. May emit logs.\n', '     * @param gToken Asset whose underlying is being borrowed\n', '     * @param borrower The address borrowing the underlying\n', '     * @param borrowAmount The amount of the underlying asset requested to borrow\n', '     */\n', '    function borrowVerify(address gToken, address borrower, uint borrowAmount) external {\n', '        // Shh - currently unused\n', '        gToken;\n', '        borrower;\n', '        borrowAmount;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to repay a borrow in the given market\n', '     * @param gToken The market to verify the repay against\n', '     * @param payer The account which would repay the asset\n', '     * @param borrower The account which would borrowed the asset\n', '     * @param repayAmount The amount of the underlying asset the account would repay\n', '     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function repayBorrowAllowed(\n', '        address gToken,\n', '        address payer,\n', '        address borrower,\n', '        uint repayAmount) external returns (uint) {\n', '        // Shh - currently unused\n', '        payer;\n', '        borrower;\n', '        repayAmount;\n', '\n', '        if (!markets[gToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        Exp memory borrowIndex = Exp({mantissa: GToken(gToken).borrowIndex()});\n', '        updateGofBorrowIndex(gToken, borrowIndex);\n', '        distributeBorrowerGof(gToken, borrower, borrowIndex);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n', '     * @param gToken Asset being repaid\n', '     * @param payer The address repaying the borrow\n', '     * @param borrower The address of the borrower\n', '     * @param actualRepayAmount The amount of underlying being repaid\n', '     */\n', '    function repayBorrowVerify(\n', '        address gToken,\n', '        address payer,\n', '        address borrower,\n', '        uint actualRepayAmount,\n', '        uint borrowerIndex) external {\n', '        // Shh - currently unused\n', '        gToken;\n', '        payer;\n', '        borrower;\n', '        actualRepayAmount;\n', '        borrowerIndex;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the liquidation should be allowed to occur\n', '     * @param gTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param gTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param repayAmount The amount of underlying being repaid\n', '     */\n', '    function liquidateBorrowAllowed(\n', '        address gTokenBorrowed,\n', '        address gTokenCollateral,\n', '        address liquidator,\n', '        address borrower,\n', '        uint repayAmount) external returns (uint) {\n', '        // Shh - currently unused\n', '        liquidator;\n', '\n', '        if (!markets[gTokenBorrowed].isListed || !markets[gTokenCollateral].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        /* The borrower must have shortfall in order to be liquidatable */\n', '        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall == 0) {\n', '            return uint(Error.INSUFFICIENT_SHORTFALL);\n', '        }\n', '\n', '        /* The liquidator may not repay more than what is allowed by the closeFactor */\n', '        uint borrowBalance = GToken(gTokenBorrowed).borrowBalanceStored(borrower);\n', '        uint maxClose = mul_ScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n', '        if (repayAmount > maxClose) {\n', '            return uint(Error.TOO_MUCH_REPAY);\n', '        }\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n', '     * @param gTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param gTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param actualRepayAmount The amount of underlying being repaid\n', '     */\n', '    function liquidateBorrowVerify(\n', '        address gTokenBorrowed,\n', '        address gTokenCollateral,\n', '        address liquidator,\n', '        address borrower,\n', '        uint actualRepayAmount,\n', '        uint seizeTokens) external {\n', '        // Shh - currently unused\n', '        gTokenBorrowed;\n', '        gTokenCollateral;\n', '        liquidator;\n', '        borrower;\n', '        actualRepayAmount;\n', '        seizeTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the seizing of assets should be allowed to occur\n', '     * @param gTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param gTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param seizeTokens The number of collateral tokens to seize\n', '     */\n', '    function seizeAllowed(\n', '        address gTokenCollateral,\n', '        address gTokenBorrowed,\n', '        address liquidator,\n', '        address borrower,\n', '        uint seizeTokens) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!seizeGuardianPaused, "seize is paused");\n', '\n', '        // Shh - currently unused\n', '        seizeTokens;\n', '\n', '        if (!markets[gTokenCollateral].isListed || !markets[gTokenBorrowed].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        if (GToken(gTokenCollateral).comptroller() != GToken(gTokenBorrowed).comptroller()) {\n', '            return uint(Error.COMPTROLLER_MISMATCH);\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        updateGofSupplyIndex(gTokenCollateral);\n', '        distributeSupplierGof(gTokenCollateral, borrower);\n', '        distributeSupplierGof(gTokenCollateral, liquidator);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates seize and reverts on rejection. May emit logs.\n', '     * @param gTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param gTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param seizeTokens The number of collateral tokens to seize\n', '     */\n', '    function seizeVerify(\n', '        address gTokenCollateral,\n', '        address gTokenBorrowed,\n', '        address liquidator,\n', '        address borrower,\n', '        uint seizeTokens) external {\n', '        // Shh - currently unused\n', '        gTokenCollateral;\n', '        gTokenBorrowed;\n', '        liquidator;\n', '        borrower;\n', '        seizeTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to transfer tokens in the given market\n', '     * @param gToken The market to verify the transfer against\n', '     * @param src The account which sources the tokens\n', '     * @param dst The account which receives the tokens\n', '     * @param transferTokens The number of gTokens to transfer\n', '     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function transferAllowed(address gToken, address src, address dst, uint transferTokens) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!transferGuardianPaused, "transfer is paused");\n', '\n', '        // Currently the only consideration is whether or not\n', '        //  the src is allowed to redeem this many tokens\n', '        uint allowed = redeemAllowedInternal(gToken, src, transferTokens);\n', '        if (allowed != uint(Error.NO_ERROR)) {\n', '            return allowed;\n', '        }\n', '\n', '        // Keep the flywheel moving\n', '        updateGofSupplyIndex(gToken);\n', '        distributeSupplierGof(gToken, src);\n', '        distributeSupplierGof(gToken, dst);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates transfer and reverts on rejection. May emit logs.\n', '     * @param gToken Asset being transferred\n', '     * @param src The account which sources the tokens\n', '     * @param dst The account which receives the tokens\n', '     * @param transferTokens The number of gTokens to transfer\n', '     */\n', '    function transferVerify(address gToken, address src, address dst, uint transferTokens) external {\n', '        // Shh - currently unused\n', '        gToken;\n', '        src;\n', '        dst;\n', '        transferTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /*** Liquidity/Liquidation Calculations ***/\n', '\n', '    /**\n', '     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n', '     *  Note that `gTokenBalance` is the number of gTokens the account owns in the market,\n', '     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n', '     */\n', '    struct AccountLiquidityLocalVars {\n', '        uint sumCollateral;\n', '        uint sumBorrowPlusEffects;\n', '        uint gTokenBalance;\n', '        uint borrowBalance;\n', '        uint exchangeRateMantissa;\n', '        uint oraclePriceMantissa;\n', '        Exp collateralFactor;\n', '        Exp exchangeRate;\n', '        Exp oraclePrice;\n', '        Exp tokensToDenom;\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the current account liquidity wrt collateral requirements\n', '     * @return (possible error code (semi-opaque),\n', '                account liquidity in excess of collateral requirements,\n', '     *          account shortfall below collateral requirements)\n', '     */\n', '    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n', '        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, GToken(0), 0, 0);\n', '\n', '        return (uint(err), liquidity, shortfall);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the current account liquidity wrt collateral requirements\n', '     * @return (possible error code,\n', '                account liquidity in excess of collateral requirements,\n', '     *          account shortfall below collateral requirements)\n', '     */\n', '    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n', '        return getHypotheticalAccountLiquidityInternal(account, GToken(0), 0, 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n', '     * @param gTokenModify The market to hypothetically redeem/borrow in\n', '     * @param account The account to determine liquidity for\n', '     * @param redeemTokens The number of tokens to hypothetically redeem\n', '     * @param borrowAmount The amount of underlying to hypothetically borrow\n', '     * @return (possible error code (semi-opaque),\n', '                hypothetical account liquidity in excess of collateral requirements,\n', '     *          hypothetical account shortfall below collateral requirements)\n', '     */\n', '    function getHypotheticalAccountLiquidity(\n', '        address account,\n', '        address gTokenModify,\n', '        uint redeemTokens,\n', '        uint borrowAmount) public view returns (uint, uint, uint) {\n', '        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, GToken(gTokenModify), redeemTokens, borrowAmount);\n', '        return (uint(err), liquidity, shortfall);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n', '     * @param gTokenModify The market to hypothetically redeem/borrow in\n', '     * @param account The account to determine liquidity for\n', '     * @param redeemTokens The number of tokens to hypothetically redeem\n', '     * @param borrowAmount The amount of underlying to hypothetically borrow\n', '     * @dev Note that we calculate the exchangeRateStored for each collateral gToken using stored data,\n', '     *  without calculating accumulated interest.\n', '     * @return (possible error code,\n', '                hypothetical account liquidity in excess of collateral requirements,\n', '     *          hypothetical account shortfall below collateral requirements)\n', '     */\n', '    function getHypotheticalAccountLiquidityInternal(\n', '        address account,\n', '        GToken gTokenModify,\n', '        uint redeemTokens,\n', '        uint borrowAmount) internal view returns (Error, uint, uint) {\n', '\n', '        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n', '        uint oErr;\n', '\n', '        // For each asset the account is in\n', '        GToken[] memory assets = accountAssets[account];\n', '        for (uint i = 0; i < assets.length; i++) {\n', '            GToken asset = assets[i];\n', '\n', '            // Read the balances and exchange rate from the gToken\n', '            (oErr, vars.gTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n', '            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n', '                return (Error.SNAPSHOT_ERROR, 0, 0);\n', '            }\n', '            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n', '            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n', '\n', '            // Get the normalized price of the asset\n', '            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n', '            if (vars.oraclePriceMantissa == 0) {\n', '                return (Error.PRICE_ERROR, 0, 0);\n', '            }\n', '            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n', '\n', '            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n', '            vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n', '\n', '            // sumCollateral += tokensToDenom * gTokenBalance\n', '            vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.gTokenBalance, vars.sumCollateral);\n', '\n', '            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n', '            vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n', '\n', '            // Calculate effects of interacting with gTokenModify\n', '            if (asset == gTokenModify) {\n', '                // redeem effect\n', '                // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n', '                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n', '\n', '                // borrow effect\n', '                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n', '                vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n', '            }\n', '        }\n', '\n', '        // These are safe, as the underflow condition is checked first\n', '        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n', '            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n', '        } else {\n', '            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n', '     * @dev Used in liquidation (called in gToken.liquidateBorrowFresh)\n', '     * @param gTokenBorrowed The address of the borrowed gToken\n', '     * @param gTokenCollateral The address of the collateral gToken\n', '     * @param actualRepayAmount The amount of gTokenBorrowed underlying to convert into gTokenCollateral tokens\n', '     * @return (errorCode, number of gTokenCollateral tokens to be seized in a liquidation)\n', '     */\n', '    function liquidateCalculateSeizeTokens(address gTokenBorrowed, address gTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n', '        /* Read oracle prices for borrowed and collateral markets */\n', '        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(GToken(gTokenBorrowed));\n', '        uint priceCollateralMantissa = oracle.getUnderlyingPrice(GToken(gTokenCollateral));\n', '        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n', '            return (uint(Error.PRICE_ERROR), 0);\n', '        }\n', '\n', '        /*\n', '         * Get the exchange rate and calculate the number of collateral tokens to seize:\n', '         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n', '         *  seizeTokens = seizeAmount / exchangeRate\n', '         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n', '         */\n', '        uint exchangeRateMantissa = GToken(gTokenCollateral).exchangeRateStored(); // Note: reverts on error\n', '        uint seizeTokens;\n', '        Exp memory numerator;\n', '        Exp memory denominator;\n', '        Exp memory ratio;\n', '\n', '        numerator = mul_(Exp({mantissa: liquidationIncentiveMantissa}), Exp({mantissa: priceBorrowedMantissa}));\n', '        denominator = mul_(Exp({mantissa: priceCollateralMantissa}), Exp({mantissa: exchangeRateMantissa}));\n', '        ratio = div_(numerator, denominator);\n', '\n', '        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n', '\n', '        return (uint(Error.NO_ERROR), seizeTokens);\n', '    }\n', '\n', '    /*** Admin Functions ***/\n', '\n', '    /**\n', '      * @notice Sets a new price oracle for the comptroller\n', '      * @dev Admin function to set a new price oracle\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n', '        // Check caller is admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n', '        }\n', '\n', '        // Track the old oracle for the comptroller\n', '        PriceOracle oldOracle = oracle;\n', '\n', "        // Set comptroller's oracle to newOracle\n", '        oracle = newOracle;\n', '\n', '        // Emit NewPriceOracle(oldOracle, newOracle)\n', '        emit NewPriceOracle(oldOracle, newOracle);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets the closeFactor used when liquidating borrows\n', '      * @dev Admin function to set closeFactor\n', '      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure\n', '      */\n', '    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n', '        // Check caller is admin\n', '    \trequire(msg.sender == admin, "only admin can set close factor");\n', '\n', '        uint oldCloseFactorMantissa = closeFactorMantissa;\n', '        closeFactorMantissa = newCloseFactorMantissa;\n', '        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets the collateralFactor for a market\n', '      * @dev Admin function to set per-market collateralFactor\n', '      * @param gToken The market to set the factor on\n', '      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setCollateralFactor(GToken gToken, uint newCollateralFactorMantissa) external returns (uint) {\n', '        // Check caller is admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n', '        }\n', '\n', '        // Verify market is listed\n', '        Market storage market = markets[address(gToken)];\n', '        if (!market.isListed) {\n', '            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n', '        }\n', '\n', '        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n', '\n', '        // Check collateral factor <= 0.9\n', '        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n', '        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n', '            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n', '        }\n', '\n', '        // If collateral factor != 0, fail if price == 0\n', '        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(gToken) == 0) {\n', '            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n', '        }\n', '\n', "        // Set market's collateral factor to new collateral factor, remember old value\n", '        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n', '        market.collateralFactorMantissa = newCollateralFactorMantissa;\n', '\n', '        // Emit event with asset, old collateral factor, and new collateral factor\n', '        emit NewCollateralFactor(gToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets liquidationIncentive\n', '      * @dev Admin function to set liquidationIncentive\n', '      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n', '        // Check caller is admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n', '        }\n', '\n', '        // Save current value for use in log\n', '        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n', '\n', '        // Set liquidation incentive to new incentive\n', '        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n', '\n', '        // Emit event with old incentive, new incentive\n', '        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Add the market to the markets mapping and set it as listed\n', '      * @dev Admin function to set isListed and add support for the market\n', '      * @param gToken The address of the market (token) to list\n', '      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n', '      */\n', '    function _supportMarket(GToken gToken) external returns (uint) {\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n', '        }\n', '\n', '        if (markets[address(gToken)].isListed) {\n', '            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n', '        }\n', '\n', '        gToken.isGToken(); // Sanity check to make sure its really a GToken\n', '\n', '        // Note that isGofed is not in active use anymore\n', '        markets[address(gToken)] = Market({isListed: true, isGofed: false, collateralFactorMantissa: 0});\n', '\n', '        _addMarketInternal(address(gToken));\n', '\n', '        emit MarketListed(gToken);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    function _addMarketInternal(address gToken) internal {\n', '        for (uint i = 0; i < allMarkets.length; i ++) {\n', '            require(allMarkets[i] != GToken(gToken), "market already added");\n', '        }\n', '        allMarkets.push(GToken(gToken));\n', '    }\n', '\n', '\n', '    /**\n', '      * @notice Set the given borrow caps for the given gToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n', '      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n', '      * @param gTokens The addresses of the markets (tokens) to change the borrow caps for\n', '      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n', '      */\n', '    function _setMarketBorrowCaps(GToken[] calldata gTokens, uint[] calldata newBorrowCaps) external {\n', '    \trequire(msg.sender == admin || msg.sender == borrowCapGuardian, "only admin or borrow cap guardian can set borrow caps"); \n', '        require(gTokens.length <= 100, "Too many gTokens");\n', '\n', '        uint numMarkets = gTokens.length;\n', '        uint numBorrowCaps = newBorrowCaps.length;\n', '\n', '        require(numMarkets != 0 && numMarkets == numBorrowCaps, "invalid input");\n', '\n', '        for(uint i = 0; i < numMarkets; i++) {\n', '            borrowCaps[address(gTokens[i])] = newBorrowCaps[i];\n', '            emit NewBorrowCap(gTokens[i], newBorrowCaps[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Admin function to change the Borrow Cap Guardian\n', '     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n', '     */\n', '    function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n', '        require(msg.sender == admin, "only admin can set borrow cap guardian");\n', '\n', '        // Save current value for inclusion in log\n', '        address oldBorrowCapGuardian = borrowCapGuardian;\n', '\n', '        // Store borrowCapGuardian with value newBorrowCapGuardian\n', '        borrowCapGuardian = newBorrowCapGuardian;\n', '\n', '        // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n', '        emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n', '    }\n', '\n', '    /**\n', '     * @notice Admin function to change the Pause Guardian\n', '     * @param newPauseGuardian The address of the new Pause Guardian\n', '     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n', '     */\n', '    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n', '        }\n', '\n', '        // Save current value for inclusion in log\n', '        address oldPauseGuardian = pauseGuardian;\n', '\n', '        // Store pauseGuardian with value newPauseGuardian\n', '        pauseGuardian = newPauseGuardian;\n', '\n', '        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n', '        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    function _setMintPaused(GToken gToken, bool state) public returns (bool) {\n', '        require(markets[address(gToken)].isListed, "cannot pause a market that is not listed");\n', '        require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");\n', '        require(msg.sender == admin || state == true, "only admin can unpause");\n', '\n', '        mintGuardianPaused[address(gToken)] = state;\n', '        emit ActionPaused(gToken, "Mint", state);\n', '        return state;\n', '    }\n', '\n', '    function _setBorrowPaused(GToken gToken, bool state) public returns (bool) {\n', '        require(markets[address(gToken)].isListed, "cannot pause a market that is not listed");\n', '        require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");\n', '        require(msg.sender == admin || state == true, "only admin can unpause");\n', '\n', '        borrowGuardianPaused[address(gToken)] = state;\n', '        emit ActionPaused(gToken, "Borrow", state);\n', '        return state;\n', '    }\n', '\n', '    function _setTransferPaused(bool state) public returns (bool) {\n', '        require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");\n', '        require(msg.sender == admin || state == true, "only admin can unpause");\n', '\n', '        transferGuardianPaused = state;\n', '        emit ActionPaused("Transfer", state);\n', '        return state;\n', '    }\n', '\n', '    function _setSeizePaused(bool state) public returns (bool) {\n', '        require(msg.sender == pauseGuardian || msg.sender == admin, "only pause guardian and admin can pause");\n', '        require(msg.sender == admin || state == true, "only admin can unpause");\n', '\n', '        seizeGuardianPaused = state;\n', '        emit ActionPaused("Seize", state);\n', '        return state;\n', '    }\n', '\n', '    function _become(ComptrollerProxy proxy) public {\n', '        require(msg.sender == proxy.admin(), "only proxy admin can change brains");\n', '        require(proxy._acceptImplementation() == 0, "change not authorized");\n', '    }\n', '\n', '    /**\n', '     * @notice Checks caller is admin, or this contract is becoming the new implementation\n', '     */\n', '    function adminOrInitializing() internal view returns (bool) {\n', '        return msg.sender == admin || msg.sender == comptrollerImplementation;\n', '    }\n', '\n', '    /*** GOF Distribution ***/\n', '\n', '    /**\n', '     * @notice Set GOF speed for a single market\n', '     * @param gToken The market whose GOF speed to update\n', '     * @param gofSpeed New GOF speed for market\n', '     */\n', '    function setGofSpeedInternal(GToken gToken, uint gofSpeed) internal {\n', '        uint currentGofSpeed = gofSpeeds[address(gToken)];\n', '        if (currentGofSpeed != 0) {\n', '            // note that GOF speed could be set to 0 to halt liquidity rewards for a market\n', '            Exp memory borrowIndex = Exp({mantissa: gToken.borrowIndex()});\n', '            updateGofSupplyIndex(address(gToken));\n', '            updateGofBorrowIndex(address(gToken), borrowIndex);\n', '        } else if (gofSpeed != 0) {\n', '            // Add the GOF market\n', '            Market storage market = markets[address(gToken)];\n', '            require(market.isListed == true, "gof market is not listed");\n', '\n', '            if (gofSupplyState[address(gToken)].index == 0 && gofSupplyState[address(gToken)].block == 0) {\n', '                gofSupplyState[address(gToken)] = GofMarketState({\n', '                    index: gofInitialIndex,\n', '                    block: safe32(getBlockNumber(), "block number exceeds 32 bits")\n', '                });\n', '            }\n', '\n', '            if (gofBorrowState[address(gToken)].index == 0 && gofBorrowState[address(gToken)].block == 0) {\n', '                gofBorrowState[address(gToken)] = GofMarketState({\n', '                    index: gofInitialIndex,\n', '                    block: safe32(getBlockNumber(), "block number exceeds 32 bits")\n', '                });\n', '            }\n', '        }\n', '\n', '        if (currentGofSpeed != gofSpeed) {\n', '            gofSpeeds[address(gToken)] = gofSpeed;\n', '            emit GofSpeedUpdated(gToken, gofSpeed);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Accrue GOF to the market by updating the supply index\n', '     * @param gToken The market whose supply index to update\n', '     */\n', '    function updateGofSupplyIndex(address gToken) internal {\n', '        GofMarketState storage supplyState = gofSupplyState[gToken];\n', '        uint supplySpeed = gofSpeeds[gToken];\n', '        uint blockNumber = getBlockNumber();\n', '        uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n', '        if (deltaBlocks > 0 && supplySpeed > 0) {\n', '            uint supplyTokens = GToken(gToken).totalSupply();\n', '            uint gofAccrued = mul_(deltaBlocks, supplySpeed);\n', '            Double memory ratio = supplyTokens > 0 ? fraction(gofAccrued, supplyTokens) : Double({mantissa: 0});\n', '            Double memory index = add_(Double({mantissa: supplyState.index}), ratio);\n', '            gofSupplyState[gToken] = GofMarketState({\n', '                index: safe224(index.mantissa, "new index exceeds 224 bits"),\n', '                block: safe32(blockNumber, "block number exceeds 32 bits")\n', '            });\n', '        } else if (deltaBlocks > 0) {\n', '            supplyState.block = safe32(blockNumber, "block number exceeds 32 bits");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Accrue GOF to the market by updating the borrow index\n', '     * @param gToken The market whose borrow index to update\n', '     */\n', '    function updateGofBorrowIndex(address gToken, Exp memory marketBorrowIndex) internal {\n', '        GofMarketState storage borrowState = gofBorrowState[gToken];\n', '        uint borrowSpeed = gofSpeeds[gToken];\n', '        uint blockNumber = getBlockNumber();\n', '        uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n', '        if (deltaBlocks > 0 && borrowSpeed > 0) {\n', '            uint borrowAmount = div_(GToken(gToken).totalBorrows(), marketBorrowIndex);\n', '            uint gofAccrued = mul_(deltaBlocks, borrowSpeed);\n', '            Double memory ratio = borrowAmount > 0 ? fraction(gofAccrued, borrowAmount) : Double({mantissa: 0});\n', '            Double memory index = add_(Double({mantissa: borrowState.index}), ratio);\n', '            gofBorrowState[gToken] = GofMarketState({\n', '                index: safe224(index.mantissa, "new index exceeds 224 bits"),\n', '                block: safe32(blockNumber, "block number exceeds 32 bits")\n', '            });\n', '        } else if (deltaBlocks > 0) {\n', '            borrowState.block = safe32(blockNumber, "block number exceeds 32 bits");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate GOF accrued by a supplier and possibly transfer it to them\n', '     * @param gToken The market in which the supplier is interacting\n', '     * @param supplier The address of the supplier to distribute GOF to\n', '     */\n', '    function distributeSupplierGof(address gToken, address supplier) internal {\n', '        GofMarketState storage supplyState = gofSupplyState[gToken];\n', '        Double memory supplyIndex = Double({mantissa: supplyState.index});\n', '        Double memory supplierIndex = Double({mantissa: gofSupplierIndex[gToken][supplier]});\n', '        gofSupplierIndex[gToken][supplier] = supplyIndex.mantissa;\n', '\n', '        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n', '            supplierIndex.mantissa = gofInitialIndex;\n', '        }\n', '\n', '        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n', '        uint supplierTokens = GToken(gToken).balanceOf(supplier);\n', '        uint supplierDelta = mul_(supplierTokens, deltaIndex);\n', '        uint supplierAccrued = add_(gofAccrued[supplier], supplierDelta);\n', '        gofAccrued[supplier] = supplierAccrued;\n', '        emit DistributedSupplierGof(GToken(gToken), supplier, supplierDelta, supplyIndex.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate GOF accrued by a borrower and possibly transfer it to them\n', '     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n', '     * @param gToken The market in which the borrower is interacting\n', '     * @param borrower The address of the borrower to distribute GOF to\n', '     */\n', '    function distributeBorrowerGof(address gToken, address borrower, Exp memory marketBorrowIndex) internal {\n', '        GofMarketState storage borrowState = gofBorrowState[gToken];\n', '        Double memory borrowIndex = Double({mantissa: borrowState.index});\n', '        Double memory borrowerIndex = Double({mantissa: gofBorrowerIndex[gToken][borrower]});\n', '        gofBorrowerIndex[gToken][borrower] = borrowIndex.mantissa;\n', '\n', '        if (borrowerIndex.mantissa > 0) {\n', '            Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n', '            uint borrowerAmount = div_(GToken(gToken).borrowBalanceStored(borrower), marketBorrowIndex);\n', '            uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n', '            uint borrowerAccrued = add_(gofAccrued[borrower], borrowerDelta);\n', '            gofAccrued[borrower] = borrowerAccrued;\n', '            emit DistributedBorrowerGof(GToken(gToken), borrower, borrowerDelta, borrowIndex.mantissa);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate additional accrued GOF for a contributor since last accrual\n', '     * @param contributor The address to calculate contributor rewards for\n', '     */\n', '    function updateContributorRewards(address contributor) public {\n', '        uint gofSpeed = gofContributorSpeeds[contributor];\n', '        uint blockNumber = getBlockNumber();\n', '        uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n', '        if (deltaBlocks > 0 && gofSpeed > 0) {\n', '            uint newAccrued = mul_(deltaBlocks, gofSpeed);\n', '            uint contributorAccrued = add_(gofAccrued[contributor], newAccrued);\n', '\n', '            gofAccrued[contributor] = contributorAccrued;\n', '            lastContributorBlock[contributor] = blockNumber;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Claim all the GOF accrued by holder in all markets\n', '     * @param holder The address to claim GOF for\n', '     */\n', '    function claimGof(address holder) public {\n', '        return claimGof(holder, allMarkets);\n', '    }\n', '\n', '    /**\n', '     * @notice Claim all the GOF accrued by holder in the specified markets\n', '     * @param holder The address to claim GOF for\n', '     * @param gTokens The list of markets to claim GOF in\n', '     */\n', '    function claimGof(address holder, GToken[] memory gTokens) public {\n', '        address[] memory holders = new address[](1);\n', '        holders[0] = holder;\n', '        claimGof(holders, gTokens, true, true);\n', '    }\n', '\n', '    /**\n', '     * @notice Claim all GOF accrued by the holders\n', '     * @param holders The addresses to claim GOF for\n', '     * @param gTokens The list of markets to claim GOF in\n', '     * @param borrowers Whether or not to claim GOF earned by borrowing\n', '     * @param suppliers Whether or not to claim GOF earned by supplying\n', '     */\n', '    function claimGof(address[] memory holders, GToken[] memory gTokens, bool borrowers, bool suppliers) public {\n', '        require(gTokens.length <= 100, "Too many gTokens");\n', '        require(holders.length <= 100, "Too many holders");\n', '\n', '        for (uint i = 0; i < gTokens.length; i++) {\n', '            GToken gToken = gTokens[i];\n', '            require(markets[address(gToken)].isListed, "market must be listed");\n', '            if (borrowers == true) {\n', '                Exp memory borrowIndex = Exp({mantissa: gToken.borrowIndex()});\n', '                updateGofBorrowIndex(address(gToken), borrowIndex);\n', '                for (uint j = 0; j < holders.length; j++) {\n', '                    distributeBorrowerGof(address(gToken), holders[j], borrowIndex);\n', '                    gofAccrued[holders[j]] = grantGofInternal(holders[j], gofAccrued[holders[j]]);\n', '                }\n', '            }\n', '            if (suppliers == true) {\n', '                updateGofSupplyIndex(address(gToken));\n', '                for (uint j = 0; j < holders.length; j++) {\n', '                    distributeSupplierGof(address(gToken), holders[j]);\n', '                    gofAccrued[holders[j]] = grantGofInternal(holders[j], gofAccrued[holders[j]]);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer GOF to the user\n', '     * @dev Note: If there is not enough GOF, we do not perform the transfer all.\n', '     * @param user The address of the user to transfer GOF to\n', '     * @param amount The amount of GOF to (possibly) transfer\n', '     * @return The amount of GOF which was NOT transferred to the user\n', '     */\n', '    function grantGofInternal(address user, uint amount) internal returns (uint) {\n', '        GOF gof = GOF(getGofAddress());\n', '        uint gofRemaining = gof.balanceOf(address(this));\n', '        if (amount > 0 && amount <= gofRemaining) {\n', '            gof.transfer(user, amount);\n', '            return 0;\n', '        }\n', '        return amount;\n', '    }\n', '\n', '    /*** GOF Distribution Admin ***/\n', '\n', '    /**\n', '     * @notice Transfer GOF to the recipient\n', '     * @dev Note: If there is not enough GOF, we do not perform the transfer all.\n', '     * @param recipient The address of the recipient to transfer GOF to\n', '     * @param amount The amount of GOF to (possibly) transfer\n', '     */\n', '    function _grantGof(address recipient, uint amount) public {\n', '        require(adminOrInitializing(), "only admin can grant GOF");\n', '        uint amountLeft = grantGofInternal(recipient, amount);\n', '        require(amountLeft == 0, "insufficient GOF for grant");\n', '        emit GofGranted(recipient, amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Set GOF speed for a single market\n', '     * @param gToken The market whose GOF speed to update\n', '     * @param gofSpeed New GOF speed for market\n', '     */\n', '    function _setGofSpeed(GToken gToken, uint gofSpeed) public {\n', '        require(adminOrInitializing(), "only admin can set GOF speed");\n', '        setGofSpeedInternal(gToken, gofSpeed);\n', '    }\n', '\n', '    /**\n', '     * @notice Set GOF speed for a single contributor\n', '     * @param contributor The contributor whose COGOFMP speed to update\n', '     * @param gofSpeed New GOF speed for contributor\n', '     */\n', '    function _setContributorGofSpeed(address contributor, uint gofSpeed) public {\n', '        require(adminOrInitializing(), "only admin can set GOF speed");\n', '\n', '        // note that GOF speed could be set to 0 to halt liquidity rewards for a contributor\n', '        updateContributorRewards(contributor);\n', '        if (gofSpeed == 0) {\n', '            // release storage\n', '            delete lastContributorBlock[contributor];\n', '        } else {\n', '            lastContributorBlock[contributor] = getBlockNumber();\n', '        }\n', '        gofContributorSpeeds[contributor] = gofSpeed;\n', '\n', '        emit ContributorGofSpeedUpdated(contributor, gofSpeed);\n', '    }\n', '\n', '    /**\n', '     * @notice Return all of the markets\n', '     * @dev The automatic getter may be used to access an individual market.\n', '     * @return The list of market addresses\n', '     */\n', '    function getAllMarkets() public view returns (GToken[] memory) {\n', '        return allMarkets;\n', '    }\n', '\n', '    function getBlockNumber() public view returns (uint) {\n', '        return block.number;\n', '    }\n', '\n', '    /**\n', '     * @notice Return the address of the GOF token\n', '     * @return The address of GOF\n', '     */\n', '    function getGofAddress() public pure returns (address) {\n', '        return 0x488E0369f9BC5C40C002eA7c1fe4fd01A198801c;\n', '    }\n', '}\n', '\n', 'interface GOF {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '}']