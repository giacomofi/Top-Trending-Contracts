['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-07\n', '*/\n', '\n', '// File: lib/ReentrancyGuard.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () public {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '// File: iface/IPriceController.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IPriceController {\n', '    function getPriceForPToken(address token, address uToken, address payback) external payable returns (uint256 tokenPrice, uint256 pTokenPrice);\n', '}\n', '// File: iface/IInsurancePool.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IInsurancePool {\n', '    function setPTokenToIns(address pToken, address ins) external;\n', '    function destroyPToken(address pToken, uint256 amount, address token) external;\n', '    function eliminate(address pToken, address token) external;\n', '    function setLatestTime(address token) external;\n', '}\n', '// File: iface/IERC20.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IERC20 {\n', '\tfunction decimals() external view returns (uint8);\n', '\tfunction name() external view returns (string memory);\n', '\tfunction symbol() external view returns (string memory);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// File: lib/Address.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '        (bool success, ) = recipient.call{value:amount}("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '// File: lib/SafeERC20.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '    function callOptionalReturn(ERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) {\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// File: lib/TransferHelper.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '// File: iface/IPTokenFactory.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IPTokenFactory {\n', '    function getGovernance() external view returns(address);\n', '    function getPTokenOperator(address contractAddress) external view returns(bool);\n', '    function getPTokenAuthenticity(address pToken) external view returns(bool);\n', '}\n', '// File: iface/IParasset.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IParasset {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '    function destroy(uint256 amount, address account) external;\n', '    function issuance(uint256 amount, address account) external;\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '// File: lib/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow');\n", '    }\n', '\n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n", '    }\n', '\n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        require(y > 0, "ds-math-div-zero");\n', '        z = x / y;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    }\n', '}\n', '// File: PToken.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'contract PToken is IParasset {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowed;\n', '    uint256 public _totalSupply = 0;                                        \n', '    string public name = "";\n', '    string public symbol = "";\n', '    uint8 public decimals = 18;\n', '\n', '    IPTokenFactory pTokenFactory;\n', '\n', '    constructor (string memory _name, \n', '                 string memory _symbol) public {\n', '    \tname = _name;                                                               \n', '    \tsymbol = _symbol;\n', '    \tpTokenFactory = IPTokenFactory(address(msg.sender));\n', '    }\n', '\n', '    //---------modifier---------\n', '\n', '    modifier onlyGovernance() {\n', '        require(address(msg.sender) == pTokenFactory.getGovernance(), "Log:PToken:!governance");\n', '        _;\n', '    }\n', '\n', '    modifier onlyPool() {\n', '    \trequire(pTokenFactory.getPTokenOperator(address(msg.sender)), "Log:PToken:!Pool");\n', '    \t_;\n', '    }\n', '\n', '    //---------view---------\n', '\n', '    // Query factory contract address\n', '    function getPTokenFactory() public view returns(address) {\n', '        return address(pTokenFactory);\n', '    }\n', '\n', '    /// @notice The view of totalSupply\n', '    /// @return The total supply of ntoken\n', '    function totalSupply() override public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /// @dev The view of balances\n', '    /// @param owner The address of an account\n', '    /// @return The balance of the account\n', '    function balanceOf(address owner) override public view returns (uint256) {\n', '        return _balances[owner];\n', '    }\n', '\n', '    function allowance(address owner, address spender) override public view returns (uint256) {\n', '        return _allowed[owner][spender];\n', '    }\n', '\n', '    //---------transaction---------\n', '\n', '    function changeFactory(address factory) public onlyGovernance {\n', '        pTokenFactory = IPTokenFactory(address(factory));\n', '    }\n', '\n', '    function rename(string memory _name, \n', '                    string memory _symbol) public onlyGovernance {\n', '        name = _name;                                                               \n', '        symbol = _symbol;\n', '    }\n', '\n', '    function transfer(address to, uint256 value) override public returns (bool) \n', '    {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function approve(address spender, uint256 value) override public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '        _allowed[msg.sender][spender] = value;\n', '        emit Approval(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint256 value) override public returns (bool) \n', '    {\n', '        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n', '        _transfer(from, to, value);\n', '        emit Approval(from, msg.sender, _allowed[from][msg.sender]);\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) \n', '    {\n', '        require(spender != address(0));\n', '\n', '        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].sub(subtractedValue);\n', '        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address from, address to, uint256 value) internal {\n', '        _balances[from] = _balances[from].sub(value);\n', '        _balances[to] = _balances[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function destroy(uint256 amount, address account) override external onlyPool{\n', '    \trequire(_balances[account] >= amount, "Log:PToken:!destroy");\n', '    \t_balances[account] = _balances[account].sub(amount);\n', '    \t_totalSupply = _totalSupply.sub(amount);\n', '    \temit Transfer(account, address(0x0), amount);\n', '    }\n', '\n', '    function issuance(uint256 amount, address account) override external onlyPool{\n', '    \t_balances[account] = _balances[account].add(amount);\n', '    \t_totalSupply = _totalSupply.add(amount);\n', '    \temit Transfer(address(0x0), account, amount);\n', '    }\n', '}\n', '// File: MortgagePool.sol\n', '\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'contract MortgagePool is ReentrancyGuard {\n', '\tusing SafeMath for uint256;\n', '\tusing SafeERC20 for ERC20;\n', '\n', '    // Governance address\n', '\taddress public governance;\n', '\t// Underlying asset address => PToken address\n', '\tmapping(address=>address) public underlyingToPToken;\n', '\t// PToken address => Underlying asset address\n', '\tmapping(address=>address) public pTokenToUnderlying;\n', '    // PToken address => Mortgage asset address => Bool\n', '\tmapping(address=>mapping(address=>bool)) mortgageAllow;\n', '    // PToken address => Mortgage asset address => User address => Debt data\n', '\tmapping(address=>mapping(address=>mapping(address=>PersonalLedger))) ledger;\n', '    // PToken address => Mortgage asset address => Users who have created debt positions(address)\n', '    mapping(address=>mapping(address=>address[])) ledgerArray;\n', '    // Mortgage asset address => Maximum mortgage rate\n', '    mapping(address=>uint256) maxRate;\n', '    // Mortgage asset address => Liquidation line\n', '    mapping(address=>uint256) liquidationLine;\n', '    // PriceController contract\n', '    IPriceController quary;\n', '    // Insurance pool contract\n', '    IInsurancePool insurancePool;\n', '    // PToken creation factory contract\n', '    IPTokenFactory pTokenFactory;\n', '\t// Market base interest rate\n', '\tuint256 r0 = 0.025 ether;\n', '\t// Amount of blocks produced in a year\n', '\tuint256 oneYear = 2400000;\n', '    // Status\n', '    uint8 public flag;      // = 0: pause\n', '                            // = 1: active\n', '                            // = 2: out only\n', '\n', '\tstruct PersonalLedger {\n', '        uint256 mortgageAssets;         // Amount of mortgaged assets\n', '        uint256 parassetAssets;         // Amount of debt(Ptoken,Stability fee not included)\n', '        uint256 blockHeight;            // The block height of the last operation\n', '        uint256 rate;                   // Mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)\n', '        bool created;                   // Is it created\n', '    }\n', '\n', '    event FeeValue(address pToken, uint256 value);\n', '\n', '    /// @dev Initialization method\n', '    /// @param factoryAddress PToken creation factory contract\n', '\tconstructor (address factoryAddress) public {\n', '        pTokenFactory = IPTokenFactory(factoryAddress);\n', '        governance = pTokenFactory.getGovernance();\n', '        flag = 0;\n', '    }\n', '\n', '    //---------modifier---------\n', '\n', '    modifier onlyGovernance() {\n', '        require(msg.sender == governance, "Log:MortgagePool:!gov");\n', '        _;\n', '    }\n', '\n', '    modifier whenActive() {\n', '        require(flag == 1, "Log:MortgagePool:!active");\n', '        _;\n', '    }\n', '\n', '    modifier outOnly() {\n', '        require(flag != 0, "Log:MortgagePool:!0");\n', '        _;\n', '    }\n', '\n', '    //---------view---------\n', '\n', '    /// @dev Calculate the stability fee\n', '    /// @param parassetAssets Amount of debt(Ptoken,Stability fee not included)\n', '    /// @param blockHeight The block height of the last operation\n', '    /// @param rate Mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)\n', '    /// @param nowRate Current mortgage rate (not including stability fee)\n', '    /// @return fee\n', '    function getFee(uint256 parassetAssets, \n', '    \t            uint256 blockHeight,\n', '    \t            uint256 rate,\n', '                    uint256 nowRate) public view returns(uint256) {\n', '        uint256 topOne = parassetAssets.mul(r0).mul(block.number.sub(blockHeight));\n', '        uint256 ratePlus = rate.add(nowRate);\n', '        uint256 topTwo = parassetAssets.mul(r0).mul(block.number.sub(blockHeight)).mul(uint256(3).mul(ratePlus));\n', '    \tuint256 bottom = oneYear.mul(1 ether);\n', '    \treturn topOne.div(bottom).add(topTwo.div(bottom.mul(1 ether).mul(2)));\n', '    }\n', '\n', '    /// @dev Calculate the mortgage rate\n', '    /// @param mortgageAssets Amount of mortgaged assets\n', '    /// @param parassetAssets Amount of debt\n', '    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\n', '    /// @param pTokenPrice PToken price(1 ETH = ? pToken)\n', '    /// @return mortgage rate\n', '    function getMortgageRate(uint256 mortgageAssets,\n', '    \t                     uint256 parassetAssets, \n', '    \t                     uint256 tokenPrice, \n', '    \t                     uint256 pTokenPrice) public pure returns(uint256) {\n', '        if (mortgageAssets == 0 || pTokenPrice == 0) {\n', '            return 0;\n', '        }\n', '    \treturn parassetAssets.mul(tokenPrice).mul(1 ether).div(pTokenPrice.mul(mortgageAssets));\n', '    }\n', '\n', '    /// @dev Get real-time data of the current debt warehouse\n', '    /// @param mortgageToken Mortgage asset address\n', '    /// @param pToken PToken address\n', '    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\n', '    /// @param uTokenPrice Underlying asset price(1 ETH = ? Underlying asset)\n', '    /// @param maxRateNum Maximum mortgage rate\n', '    /// @param owner Debt owner\n', '    /// @return fee Stability fee\n', '    /// @return mortgageRate Real-time mortgage rate(Including stability fee)\n', '    /// @return maxSubM The maximum amount of mortgage assets can be reduced\n', '    /// @return maxAddP Maximum number of coins that can be added\n', '    function getInfoRealTime(address mortgageToken, \n', '                             address pToken, \n', '                             uint256 tokenPrice, \n', '                             uint256 uTokenPrice,\n', '                             uint256 maxRateNum,\n', '                             uint256 owner) public view returns(uint256 fee, \n', '                                                                uint256 mortgageRate, \n', '                                                                uint256 maxSubM, \n', '                                                                uint256 maxAddP) {\n', '        PersonalLedger memory pLedger = ledger[pToken][mortgageToken][address(owner)];\n', '        if (pLedger.mortgageAssets == 0 && pLedger.parassetAssets == 0) {\n', '            return (0,0,0,0);\n', '        }\n', '        uint256 pTokenPrice = getDecimalConversion(pTokenToUnderlying[pToken], uTokenPrice, pToken);\n', '        uint256 tokenPriceAmount = tokenPrice;\n', '        fee = getFee(pLedger.parassetAssets, pLedger.blockHeight, pLedger.rate, getMortgageRate(pLedger.mortgageAssets, pLedger.parassetAssets, tokenPriceAmount, pTokenPrice));\n', '        mortgageRate = getMortgageRate(pLedger.mortgageAssets, pLedger.parassetAssets.add(fee), tokenPriceAmount, pTokenPrice);\n', '        uint256 maxRateEther = maxRateNum.mul(0.01 ether);\n', '        if (mortgageRate >= maxRateEther) {\n', '            maxSubM = 0;\n', '            maxAddP = 0;\n', '        } else {\n', '            maxSubM = pLedger.mortgageAssets.sub(pLedger.parassetAssets.mul(tokenPriceAmount).mul(1 ether).div(maxRateEther.mul(pTokenPrice)));\n', '            maxAddP = pLedger.mortgageAssets.mul(pTokenPrice).mul(maxRateEther).div(uint256(1 ether).mul(tokenPriceAmount)).sub(pLedger.parassetAssets);\n', '        }\n', '    }\n', '    \n', '    /// @dev Uniform accuracy\n', '    /// @param inputToken Initial token\n', '    /// @param inputTokenAmount Amount of token\n', '    /// @param outputToken Converted token\n', '    /// @return stability Amount of outputToken\n', '    function getDecimalConversion(address inputToken, \n', '    \t                          uint256 inputTokenAmount, \n', '    \t                          address outputToken) public view returns(uint256) {\n', '    \tuint256 inputTokenDec = 18;\n', '    \tuint256 outputTokenDec = 18;\n', '    \tif (inputToken != address(0x0)) {\n', '    \t\tinputTokenDec = IERC20(inputToken).decimals();\n', '    \t}\n', '\n', '    \tif (outputToken != address(0x0)) {\n', '    \t\toutputTokenDec = IERC20(outputToken).decimals();\n', '    \t}\n', '    \treturn inputTokenAmount.mul(10**outputTokenDec).div(10**inputTokenDec);\n', '    }\n', '\n', '    /// @dev View debt warehouse data\n', '    /// @param pToken pToken address\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param owner debt owner\n', '    /// @return mortgageAssets amount of mortgaged assets\n', '    /// @return parassetAssets amount of debt(Ptoken,Stability fee not included)\n', '    /// @return blockHeight the block height of the last operation\n', '    /// @return rate Mortgage rate(Initial mortgage rate,Mortgage rate after the last operation)\n', '    /// @return created is it created\n', '    function getLedger(address pToken, \n', '    \t               address mortgageToken,\n', '                       address owner) public view returns(uint256 mortgageAssets, \n', '    \t\t                                              uint256 parassetAssets, \n', '    \t\t                                              uint256 blockHeight,\n', '                                                          uint256 rate,\n', '                                                          bool created) {\n', '    \tPersonalLedger memory pLedger = ledger[pToken][mortgageToken][address(owner)];\n', '    \treturn (pLedger.mortgageAssets, pLedger.parassetAssets, pLedger.blockHeight, pLedger.rate, pLedger.created);\n', '    }\n', '\n', '    /// @dev View governance address\n', '    /// @return governance address\n', '    function getGovernance() external view returns(address) {\n', '        return governance;\n', '    }\n', '\n', '    /// @dev View insurance pool address\n', '    /// @return insurance pool address\n', '    function getInsurancePool() external view returns(address) {\n', '        return address(insurancePool);\n', '    }\n', '\n', '    /// @dev View the market base interest rate\n', '    /// @return market base interest rate\n', '    function getR0() external view returns(uint256) {\n', '    \treturn r0;\n', '    }\n', '\n', '    /// @dev View the amount of blocks produced in a year\n', '    /// @return amount of blocks produced in a year\n', '    function getOneYear() external view returns(uint256) {\n', '    \treturn oneYear;\n', '    }\n', '\n', '    /// @dev View the maximum mortgage rate\n', '    /// @param mortgageToken Mortgage asset address\n', '    /// @return maximum mortgage rate\n', '    function getMaxRate(address mortgageToken) external view returns(uint256) {\n', '    \treturn maxRate[mortgageToken];\n', '    }\n', '\n', '    /// @dev View the liquidation line\n', '    /// @param mortgageToken Mortgage asset address\n', '    /// @return liquidation line\n', '    function getLiquidationLine(address mortgageToken) external view returns(uint256) {\n', '        return liquidationLine[mortgageToken];\n', '    }\n', '\n', '    /// @dev View the priceController contract address\n', '    /// @return priceController contract address\n', '    function getPriceController() external view returns(address) {\n', '        return address(quary);\n', '    }\n', '\n', '    /// @dev View the ptoken address according to the underlying asset\n', '    /// @param uToken Underlying asset address\n', '    /// @return ptoken address\n', '    function getUnderlyingToPToken(address uToken) external view returns(address) {\n', '        return underlyingToPToken[uToken];\n', '    }\n', '\n', '    /// @dev View the underlying asset according to the ptoken address\n', '    /// @param pToken ptoken address\n', '    /// @return underlying asset\n', '    function getPTokenToUnderlying(address pToken) external view returns(address) {\n', '        return pTokenToUnderlying[pToken];\n', '    }\n', '\n', '    /// @dev View the debt array length\n', '    /// @param pToken ptoken address\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @return debt array length\n', '    function getLedgerArrayNum(address pToken, \n', '                               address mortgageToken) external view returns(uint256) {\n', '        return ledgerArray[pToken][mortgageToken].length;\n', '    }\n', '\n', '    /// @dev View the debt owner\n', '    /// @param pToken ptoken address\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param index array subscript\n', '    /// @return debt owner\n', '    function getLedgerAddress(address pToken, \n', '                              address mortgageToken, \n', '                              uint256 index) external view returns(address) {\n', '        return ledgerArray[pToken][mortgageToken][index];\n', '    }\n', '\n', '    //---------governance----------\n', '\n', '    /// @dev Set contract status\n', '    /// @param num 0: pause, 1: active, 2: out only\n', '    function setFlag(uint8 num) public onlyGovernance {\n', '        flag = num;\n', '    }\n', '\n', '    /// @dev Allow asset mortgage to generate ptoken\n', '    /// @param pToken ptoken address\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param allow allow mortgage\n', '    function setMortgageAllow(address pToken, \n', '    \t                      address mortgageToken, \n', '    \t                      bool allow) public onlyGovernance {\n', '    \tmortgageAllow[pToken][mortgageToken] = allow;\n', '    }\n', '\n', '    /// @dev Set insurance pool contract\n', '    /// @param add insurance pool contract\n', '    function setInsurancePool(address add) public onlyGovernance {\n', '        insurancePool = IInsurancePool(add);\n', '    }\n', '\n', '    /// @dev Set market base interest rate\n', '    /// @param num market base interest rate(num = ? * 1 ether)\n', '    function setR0(uint256 num) public onlyGovernance {\n', '    \tr0 = num;\n', '    }\n', '\n', '    /// @dev Set the amount of blocks produced in a year\n', '    /// @param num amount of blocks produced in a year\n', '    function setOneYear(uint256 num) public onlyGovernance {\n', '    \toneYear = num;\n', '    }\n', '\n', '    /// @dev Set liquidation line\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param num liquidation line(num = ? * 100)\n', '    function setLiquidationLine(address mortgageToken, \n', '                                uint256 num) public onlyGovernance {\n', '        liquidationLine[mortgageToken] = num.mul(0.01 ether);\n', '    }\n', '\n', '    /// @dev Set the maximum mortgage rate\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param num maximum mortgage rate(num = ? * 100)\n', '    function setMaxRate(address mortgageToken, \n', '                        uint256 num) public onlyGovernance {\n', '    \tmaxRate[mortgageToken] = num.mul(0.01 ether);\n', '    }\n', '\n', '    /// @dev Set priceController contract address\n', '    /// @param add priceController contract address\n', '    function setPriceController(address add) public onlyGovernance {\n', '        quary = IPriceController(add);\n', '    }\n', '\n', '    /// @dev Set the underlying asset and ptoken mapping and\n', '    ///      Set the latest redemption time of ptoken insurance\n', '    /// @param uToken underlying asset address\n', '    /// @param pToken ptoken address\n', '    function setInfo(address uToken, \n', '                     address pToken) public onlyGovernance {\n', '        require(underlyingToPToken[uToken] == address(0x0), "Log:MortgagePool:underlyingToPToken");\n', '        require(address(insurancePool) != address(0x0), "Log:MortgagePool:0x0");\n', '        underlyingToPToken[uToken] = address(pToken);\n', '        pTokenToUnderlying[address(pToken)] = uToken;\n', '        insurancePool.setLatestTime(uToken);\n', '    }\n', '\n', '    //---------transaction---------\n', '\n', '    /// @dev Set governance address\n', '    function setGovernance() public {\n', '        governance = pTokenFactory.getGovernance();\n', '        require(governance != address(0x0), "Log:MortgagePool:0x0");\n', '    }\n', '\n', '    /// @dev Mortgage asset casting ptoken\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param pToken ptoken address\n', '    /// @param amount amount of mortgaged assets\n', '    /// @param rate custom mortgage rate\n', '    function coin(address mortgageToken, \n', '                  address pToken, \n', '                  uint256 amount, \n', '                  uint256 rate) public payable whenActive nonReentrant {\n', '\n', '    \trequire(mortgageAllow[pToken][mortgageToken], "Log:MortgagePool:!mortgageAllow");\n', '        require(rate > 0 && rate <= maxRate[mortgageToken], "Log:MortgagePool:rate!=0");\n', '        require(amount > 0, "Log:MortgagePool:amount!=0");\n', '    \tPersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\n', '        uint256 parassetAssets = pLedger.parassetAssets;\n', '        uint256 mortgageAssets = pLedger.mortgageAssets;\n', '\n', '    \t// Get the price and transfer to the mortgage token\n', '        uint256 tokenPrice;\n', '        uint256 pTokenPrice;\n', '        if (mortgageToken != address(0x0)) {\n', '            ERC20(mortgageToken).safeTransferFrom(address(msg.sender), address(this), amount);\n', '            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], msg.value);\n', '        } else {\n', '            require(msg.value >= amount, "Log:MortgagePool:!msg.value");\n', '            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], uint256(msg.value).sub(amount));\n', '        }\n', '\n', '        // Calculate the stability fee\n', '        uint256 blockHeight = pLedger.blockHeight;\n', '        uint256 fee = 0;\n', '    \tif (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\n', '            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\n', '            // The stability fee is transferred to the insurance pool\n', '            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), fee);\n', '            // Eliminate negative accounts\n', '            insurancePool.eliminate(pToken, pTokenToUnderlying[pToken]);\n', '            emit FeeValue(pToken, fee);\n', '    \t}\n', '\n', '        // Additional ptoken issuance\n', '        uint256 pTokenAmount = amount.mul(pTokenPrice).mul(rate).div(tokenPrice.mul(100));\n', '        PToken(pToken).issuance(pTokenAmount, address(msg.sender));\n', '\n', '        // Update debt information\n', '        pLedger.mortgageAssets = mortgageAssets.add(amount);\n', '        pLedger.parassetAssets = parassetAssets.add(pTokenAmount);\n', '        pLedger.blockHeight = block.number;\n', '        pLedger.rate = getMortgageRate(pLedger.mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice);\n', '\n', '        // Tag created\n', '        if (pLedger.created == false) {\n', '            ledgerArray[pToken][mortgageToken].push(address(msg.sender));\n', '            pLedger.created = true;\n', '        }\n', '    }\n', '    \n', '    /// @dev Increase mortgage assets\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param pToken ptoken address\n', '    /// @param amount amount of mortgaged assets\n', '    function supplement(address mortgageToken, \n', '                        address pToken, \n', '                        uint256 amount) public payable outOnly nonReentrant {\n', '\n', '    \trequire(mortgageAllow[pToken][mortgageToken], "Log:MortgagePool:!mortgageAllow");\n', '        require(amount > 0, "Log:MortgagePool:!amount");\n', '    \tPersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\n', '        uint256 parassetAssets = pLedger.parassetAssets;\n', '        uint256 mortgageAssets = pLedger.mortgageAssets;\n', '        require(pLedger.created, "Log:MortgagePool:!created");\n', '\n', '    \t// Get the price and transfer to the mortgage token\n', '        uint256 tokenPrice;\n', '        uint256 pTokenPrice;\n', '        if (mortgageToken != address(0x0)) {\n', '            ERC20(mortgageToken).safeTransferFrom(address(msg.sender), address(this), amount);\n', '            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], msg.value);\n', '        } else {\n', '            require(msg.value >= amount, "Log:MortgagePool:!msg.value");\n', '            (tokenPrice, pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], uint256(msg.value).sub(amount));\n', '        }\n', '\n', '        // Calculate the stability fee\n', '        uint256 blockHeight = pLedger.blockHeight;\n', '        uint256 fee = 0;\n', '    \tif (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\n', '            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\n', '            // The stability fee is transferred to the insurance pool\n', '            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), fee);\n', '            // Eliminate negative accounts\n', '            insurancePool.eliminate(pToken, pTokenToUnderlying[pToken]);\n', '            emit FeeValue(pToken, fee);\n', '    \t}\n', '\n', '        // Update debt information\n', '    \tpLedger.mortgageAssets = mortgageAssets.add(amount);\n', '    \tpLedger.blockHeight = block.number;\n', '        pLedger.rate = getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice);\n', '    }\n', '\n', '    /// @dev Reduce mortgage assets\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param pToken ptoken address\n', '    /// @param amount amount of mortgaged assets\n', '    function decrease(address mortgageToken, \n', '                      address pToken, \n', '                      uint256 amount) public payable outOnly nonReentrant {\n', '\n', '    \trequire(mortgageAllow[pToken][mortgageToken], "Log:MortgagePool:!mortgageAllow");\n', '    \tPersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\n', '        uint256 parassetAssets = pLedger.parassetAssets;\n', '        uint256 mortgageAssets = pLedger.mortgageAssets;\n', '        require(amount > 0 && amount <= mortgageAssets, "Log:MortgagePool:!amount");\n', '        require(pLedger.created, "Log:MortgagePool:!created");\n', '\n', '    \t// Get the price\n', '        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], msg.value);\n', '\n', '        // Calculate the stability fee\n', '        uint256 blockHeight = pLedger.blockHeight;\n', '        uint256 fee = 0;\n', '    \tif (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\n', '            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\n', '            // The stability fee is transferred to the insurance pool\n', '            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), fee);\n', '            // Eliminate negative accounts\n', '            insurancePool.eliminate(pToken, pTokenToUnderlying[pToken]);\n', '            emit FeeValue(pToken, fee);\n', '    \t}\n', '\n', '        // Update debt information\n', '    \tpLedger.mortgageAssets = mortgageAssets.sub(amount);\n', '    \tpLedger.blockHeight = block.number;\n', '        pLedger.rate = getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice);\n', '\n', '        // The debt warehouse mortgage rate cannot be greater than the maximum mortgage rate\n', '    \trequire(pLedger.rate <= maxRate[mortgageToken], "Log:MortgagePool:!maxRate");\n', '\n', '    \t// Transfer out mortgage assets\n', '    \tif (mortgageToken != address(0x0)) {\n', '    \t\tERC20(mortgageToken).safeTransfer(address(msg.sender), amount);\n', '    \t} else {\n', '            TransferHelper.safeTransferETH(address(msg.sender), amount);\n', '    \t}\n', '    }\n', '\n', '    /// @dev Increase debt (increase coinage)\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param pToken ptoken address\n', '    /// @param amount amount of debt\n', '    function increaseCoinage(address mortgageToken,\n', '                             address pToken,\n', '                             uint256 amount) public payable whenActive nonReentrant {\n', '\n', '        require(mortgageAllow[pToken][mortgageToken], "Log:MortgagePool:!mortgageAllow");\n', '        require(amount > 0, "Log:MortgagePool:!amount");\n', '        PersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\n', '        uint256 parassetAssets = pLedger.parassetAssets;\n', '        uint256 mortgageAssets = pLedger.mortgageAssets;\n', '        require(pLedger.created, "Log:MortgagePool:!created");\n', '\n', '        // Get the price\n', '        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, pTokenToUnderlying[pToken], msg.value);\n', '\n', '        // Calculate the stability fee\n', '        uint256 blockHeight = pLedger.blockHeight;\n', '        uint256 fee = 0;\n', '        if (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\n', '            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\n', '            // The stability fee is transferred to the insurance pool\n', '            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), fee);\n', '            // Eliminate negative accounts\n', '            insurancePool.eliminate(pToken, pTokenToUnderlying[pToken]);\n', '            emit FeeValue(pToken, fee);\n', '        }\n', '\n', '        // Update debt information\n', '        pLedger.parassetAssets = parassetAssets.add(amount);\n', '        pLedger.blockHeight = block.number;\n', '        pLedger.rate = getMortgageRate(mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice);\n', '\n', '        // The debt warehouse mortgage rate cannot be greater than the maximum mortgage rate\n', '        require(pLedger.rate <= maxRate[mortgageToken], "Log:MortgagePool:!maxRate");\n', '\n', '        // Additional ptoken issuance\n', '        PToken(pToken).issuance(amount, address(msg.sender));\n', '    }\n', '\n', '    /// @dev Reduce debt (increase coinage)\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param pToken ptoken address\n', '    /// @param amount amount of debt\n', '    function reducedCoinage(address mortgageToken,\n', '                            address pToken,\n', '                            uint256 amount) public payable outOnly nonReentrant {\n', '\n', '        require(mortgageAllow[pToken][mortgageToken], "Log:MortgagePool:!mortgageAllow");\n', '        PersonalLedger storage pLedger = ledger[pToken][mortgageToken][address(msg.sender)];\n', '        uint256 parassetAssets = pLedger.parassetAssets;\n', '        uint256 mortgageAssets = pLedger.mortgageAssets;\n', '        address uToken = pTokenToUnderlying[pToken];\n', '        require(amount > 0 && amount <= parassetAssets, "Log:MortgagePool:!amount");\n', '        require(pLedger.created, "Log:MortgagePool:!created");\n', '\n', '        // Get the price\n', '        (uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, uToken, msg.value);\n', '\n', '        // Calculate the stability fee\n', '        uint256 blockHeight = pLedger.blockHeight;\n', '        uint256 fee = 0;\n', '        if (parassetAssets > 0 && block.number > blockHeight && blockHeight != 0) {\n', '            fee = getFee(parassetAssets, blockHeight, pLedger.rate, getMortgageRate(mortgageAssets, parassetAssets, tokenPrice, pTokenPrice));\n', '            // The stability fee is transferred to the insurance pool\n', '            ERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), amount.add(fee));\n', '            // Eliminate negative accounts\n', '            insurancePool.eliminate(pToken, uToken);\n', '            emit FeeValue(pToken, fee);\n', '        }\n', '\n', '        // Update debt information\n', '        pLedger.parassetAssets = parassetAssets.sub(amount);\n', '        pLedger.blockHeight = block.number;\n', '        pLedger.rate = getMortgageRate(mortgageAssets, pLedger.parassetAssets, tokenPrice, pTokenPrice);\n', '\n', '        // Destroy ptoken\n', '        insurancePool.destroyPToken(pToken, amount, uToken);\n', '    }\n', '\n', '    /// @dev Liquidation of debt\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param pToken ptoken address\n', '    /// @param account debt owner address\n', '    /// @param amount amount of mortgaged assets\n', '    function liquidation(address mortgageToken, \n', '                         address pToken,\n', '                         address account,\n', '                         uint256 amount) public payable outOnly nonReentrant {\n', '\n', '    \trequire(mortgageAllow[pToken][mortgageToken], "Log:MortgagePool:!mortgageAllow");\n', '    \tPersonalLedger storage pLedger = ledger[pToken][mortgageToken][account];\n', '        require(pLedger.created, "Log:MortgagePool:!created");\n', '        uint256 parassetAssets = pLedger.parassetAssets;\n', '        uint256 mortgageAssets = pLedger.mortgageAssets;\n', '        require(amount > 0 && amount <= mortgageAssets, "Log:MortgagePool:!amount");\n', '\n', '    \t// Get the price\n', '        address uToken = pTokenToUnderlying[pToken];\n', '    \t(uint256 tokenPrice, uint256 pTokenPrice) = getPriceForPToken(mortgageToken, uToken, msg.value);\n', '        \n', '        // Judging the liquidation line\n', '        checkLine(pLedger, tokenPrice, pTokenPrice, mortgageToken);\n', '\n', '        // Calculate the amount of ptoken\n', '        uint256 pTokenAmount = amount.mul(pTokenPrice).mul(90).div(tokenPrice.mul(100));\n', '    \t// Transfer to ptoken\n', '    \tERC20(pToken).safeTransferFrom(address(msg.sender), address(insurancePool), pTokenAmount);\n', '\n', '    \t// Eliminate negative accounts\n', '        insurancePool.eliminate(pToken, uToken);\n', '\n', '        // Calculate the debt for destruction\n', '        uint256 offset = parassetAssets.mul(amount).div(mortgageAssets);\n', '\n', '        // Destroy ptoken\n', '    \tinsurancePool.destroyPToken(pToken, offset, uToken);\n', '\n', '    \t// Update debt information\n', '    \tpLedger.mortgageAssets = mortgageAssets.sub(amount);\n', '        pLedger.parassetAssets = parassetAssets.sub(offset);\n', '        // MortgageAssets liquidation, mortgage rate and block number are not updated\n', '        if (pLedger.mortgageAssets == 0) {\n', '            pLedger.parassetAssets = 0;\n', '            pLedger.blockHeight = 0;\n', '            pLedger.rate = 0;\n', '        }\n', '\n', '    \t// Transfer out mortgage asset\n', '    \tif (mortgageToken != address(0x0)) {\n', '    \t\tERC20(mortgageToken).safeTransfer(address(msg.sender), amount);\n', '    \t} else {\n', '            TransferHelper.safeTransferETH(address(msg.sender), amount);\n', '    \t}\n', '    }\n', '\n', '    /// @dev Check the liquidation line\n', '    /// @param pLedger debt warehouse ledger\n', '    /// @param tokenPrice Mortgage asset price(1 ETH = ? token)\n', '    /// @param pTokenPrice PToken price(1 ETH = ? pToken)\n', '    /// @param mortgageToken mortgage asset address\n', '    function checkLine(PersonalLedger memory pLedger, \n', '                       uint256 tokenPrice, \n', '                       uint256 pTokenPrice, \n', '                       address mortgageToken) private view {\n', '        uint256 parassetAssets = pLedger.parassetAssets;\n', '        uint256 mortgageAssets = pLedger.mortgageAssets;\n', '        // The current mortgage rate cannot exceed the liquidation line\n', '        uint256 mortgageRate = getMortgageRate(pLedger.mortgageAssets, parassetAssets, tokenPrice, pTokenPrice);\n', '        uint256 fee = 0;\n', '        if (parassetAssets > 0 && block.number > pLedger.blockHeight && pLedger.blockHeight != 0) {\n', '            fee = getFee(parassetAssets, pLedger.blockHeight, pLedger.rate, mortgageRate);\n', '        }\n', '        require(getMortgageRate(mortgageAssets, parassetAssets.add(fee), tokenPrice, pTokenPrice) > liquidationLine[mortgageToken], "Log:MortgagePool:!liquidationLine");\n', '    }\n', '\n', '    /// @dev Get price\n', '    /// @param mortgageToken mortgage asset address\n', '    /// @param uToken underlying asset address\n', '    /// @param priceValue price fee\n', '    /// @return tokenPrice Mortgage asset price(1 ETH = ? token)\n', '    /// @return pTokenPrice PToken price(1 ETH = ? pToken)\n', '    function getPriceForPToken(address mortgageToken, \n', '                               address uToken,\n', '                               uint256 priceValue) private returns (uint256 tokenPrice, \n', '                                                                    uint256 pTokenPrice) {\n', '        (tokenPrice, pTokenPrice) = quary.getPriceForPToken{value:priceValue}(mortgageToken, uToken, msg.sender);   \n', '    }\n', '\n', '\n', '    // function takeOutERC20(address token, uint256 amount, address to) public onlyGovernance {\n', '    //     ERC20(token).safeTransfer(address(to), amount);\n', '    // }\n', '\n', '    // function takeOutETH(uint256 amount, address to) public onlyGovernance {\n', '    //     TransferHelper.safeTransferETH(address(to), amount);\n', '    // }\n', '\n', '}']