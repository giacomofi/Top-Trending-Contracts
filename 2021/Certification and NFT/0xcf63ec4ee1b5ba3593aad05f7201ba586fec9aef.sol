['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-12\n', '*/\n', '\n', 'pragma solidity ^0.8.2;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', 'contract CommissionsStudio {\n', '    \n', '    using SafeMath for uint256;\n', '    \n', '    enum CommissionStatus { queued, accepted, removed  }\n', '    \n', '    struct Creator {\n', '        uint newQueueId;\n', '        mapping (uint => Queue) queues;\n', '    }\n', '    \n', '    struct Queue {\n', '        uint minBid;\n', '        uint newCommissionId;\n', '        mapping (uint => Commission) commissions;\n', '    }\n', '    \n', '    struct Commission {\n', '        address payable recipient;\n', '        uint bid;\n', '        CommissionStatus status;\n', '    }\n', '\n', '    address payable public admin; // the recipient of all fees\n', '    uint public fee; // stored as basis points\n', '    \n', '    mapping(address => Creator) public creators;\n', '        \n', '    bool public callStarted; // ensures no re-entrancy can occur\n', '\n', '    modifier callNotStarted () {\n', '      require(!callStarted);\n', '      callStarted = true;\n', '      _;\n', '      callStarted = false;\n', '    }\n', '    \n', '    modifier onlyAdmin () {\n', '        require(msg.sender == admin, "not the admin");\n', '        _;\n', '    }\n', '    \n', '    modifier isValidQueue (address _creator, uint _queueId) {\n', '        require(_queueId < creators[_creator].newQueueId, "queue not valid");\n', '        _;\n', '    }\n', '    \n', '    modifier isValidCommission (address _creator, uint _queueId, uint _commissionId) {\n', '        require(_commissionId < creators[_creator].queues[_queueId].newCommissionId, "commission not valid");\n', '        _;\n', '    }\n', '    \n', '    constructor(address payable _admin, uint _fee) {\n', '        admin = _admin;\n', '        fee = _fee;\n', '    }\n', '     \n', '    function updateAdmin (address payable _newAdmin)\n', '    public\n', '    callNotStarted\n', '    onlyAdmin\n', '    {\n', '        admin = _newAdmin;\n', '        emit AdminUpdated(_newAdmin);\n', '    }\n', '    \n', '    function updateFee (uint _newFee)\n', '    public\n', '    callNotStarted\n', '    onlyAdmin\n', '    {\n', '        fee = _newFee;\n', '        emit FeeUpdated(_newFee);\n', '    }\n', '    \n', '    function registerQueue(uint _minBid, string memory _queueHash) \n', '    public\n', '    callNotStarted\n', '    {        \n', '        Queue storage newQueue = creators[msg.sender].queues[creators[msg.sender].newQueueId];\n', '        newQueue.minBid = _minBid;\n', '        \n', '        emit QueueRegistered(msg.sender, creators[msg.sender].newQueueId, _minBid, _queueHash);\n', '        creators[msg.sender].newQueueId++;\n', '    }\n', '    \n', '    function updateQueueMinBid(uint _queueId, uint _newMinBid)\n', '    public\n', '    callNotStarted\n', '    isValidQueue(msg.sender, _queueId)\n', '    {\n', '        Queue storage queue = creators[msg.sender].queues[_queueId];        \n', '        queue.minBid = _newMinBid;\n', '        \n', '        emit MinBidUpdated(msg.sender, _queueId, _newMinBid);\n', '    }\n', '    \n', '    function commission (address _creator, uint _queueId, string memory _hash)\n', '    public\n', '    payable\n', '    callNotStarted\n', '    isValidQueue(_creator, _queueId)\n', '    {\n', '        Queue storage queue = creators[_creator].queues[_queueId];        \n', '        require(msg.value >= queue.minBid, "bid below minimum for this queue"); // must send the proper amount of into the bid\n', '        \n', '        // Next, initialize the new commission\n', '        Commission storage newCommission = queue.commissions[queue.newCommissionId];\n', '        newCommission.recipient = payable(msg.sender);\n', '        newCommission.bid = msg.value;\n', '        newCommission.status = CommissionStatus.queued;\n', '                      \n', '        emit NewCommission(_creator, _queueId, queue.newCommissionId, _hash);\n', '        \n', '        queue.newCommissionId++;\n', '    }\n', '    \n', '    function rescindCommission (address _creator, uint _queueId, uint _commissionId) \n', '    public\n', '    callNotStarted\n', '    isValidQueue(_creator, _queueId)\n', '    {\n', '        Queue storage queue = creators[_creator].queues[_queueId];        \n', '        require(_commissionId < queue.newCommissionId, "commission not valid"); // must be a valid previously instantiated commission\n', '        Commission storage selectedCommission = queue.commissions[_commissionId];\n', '        require(msg.sender == selectedCommission.recipient, "commission not yours"); // may only be performed by the person who commissioned it\n', '        require(selectedCommission.status == CommissionStatus.queued, "commission not in queue"); // the commission must still be queued\n', '      \n', '        // we mark it as removed and return the individual their bid\n', '        selectedCommission.status = CommissionStatus.removed;\n', '        selectedCommission.recipient.transfer(selectedCommission.bid);\n', '        \n', '        emit CommissionRescinded(_creator, _queueId, _commissionId);\n', '    }\n', '    \n', '    function increaseCommissionBid (address _creator, uint _queueId, uint _commissionId)\n', '    public\n', '    payable\n', '    callNotStarted\n', '    isValidQueue(_creator, _queueId)\n', '    {\n', '        Queue storage queue = creators[_creator].queues[_queueId];        \n', '        require(_commissionId < queue.newCommissionId, "commission not valid"); // must be a valid previously instantiated commission\n', '        Commission storage selectedCommission = queue.commissions[_commissionId];\n', '        require(msg.sender == selectedCommission.recipient, "commission not yours"); // may only be performed by the person who commissioned it\n', '        require(selectedCommission.status == CommissionStatus.queued, "commission not in queue"); // the commission must still be queued\n', '\n', "        // then we update the commission's bid\n", '        selectedCommission.bid = msg.value + selectedCommission.bid;\n', '        \n', '        emit CommissionBidUpdated(_creator, _queueId, _commissionId, selectedCommission.bid);\n', '    }\n', '    \n', '    function processCommissions(uint _queueId, uint[] memory _commissionIds)\n', '    public\n', '    callNotStarted\n', '    isValidQueue(msg.sender, _queueId)\n', '    {\n', '        Queue storage queue = creators[msg.sender].queues[_queueId];        \n', '        for (uint i = 0; i < _commissionIds.length; i++){\n', '            require(_commissionIds[i] < queue.newCommissionId, "commission not valid"); // must be a valid previously instantiated commission\n', '            Commission storage selectedCommission = queue.commissions[_commissionIds[i]];\n', '            require(selectedCommission.status == CommissionStatus.queued, "commission not in queue");  \n', '            \n', '            uint feePaid = (selectedCommission.bid * fee) / 10000;\n', '            admin.transfer(feePaid);\n', '            \n', '            selectedCommission.status = CommissionStatus.accepted; // first, we change the status of the commission to accepted\n', '            payable(msg.sender).transfer(selectedCommission.bid - feePaid); // next we accept the payment for the commission\n', '            \n', '            emit CommissionProcessed(msg.sender, _queueId, _commissionIds[i]);\n', '        }\n', '    }\n', '    \n', '    function getCreator(address _creator)\n', '    public\n', '    view\n', '    returns (uint)\n', '    {\n', '        return creators[_creator].newQueueId;\n', '    }\n', '    \n', '    function getQueue(address _creator, uint _queueId)\n', '    public\n', '    view\n', '    returns (uint, uint)\n', '    {\n', '        return ( creators[_creator].queues[_queueId].minBid, creators[_creator].queues[_queueId].newCommissionId );\n', '    }\n', '    \n', '    function getCommission(address _creator, uint _queueId, uint _commissionId)\n', '    public\n', '    view\n', '    returns (Commission memory)\n', '    {\n', '        return creators[_creator].queues[_queueId].commissions[_commissionId];\n', '    }\n', '    \n', '    event AdminUpdated(address _newAdmin);\n', '    event FeeUpdated(uint _newFee);\n', '    event MinBidUpdated(address _creator, uint _queueId, uint _newMinBid);\n', '    event QueueRegistered(address _creator, uint _queueId, uint _minBid, string _hash);\n', '    event NewCommission(address _creator, uint _queueId, uint _commissionId, string _hash);\n', '    event CommissionBidUpdated(address _creator, uint _queueId, uint _commissionId, uint _newBid);\n', '    event CommissionRescinded(address _creator, uint _queueId, uint _commissionId);\n', '    event CommissionProcessed(address _creator, uint _queueId, uint _commissionId);\n', '}']