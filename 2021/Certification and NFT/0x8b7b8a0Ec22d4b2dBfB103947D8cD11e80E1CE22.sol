['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-25\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2020-08-18\n', '*/\n', '\n', 'pragma solidity ^0.6.0; \n', 'pragma experimental ABIEncoderV2;\n', '\n', 'contract DSMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x);\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '\n', '    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        return x / y;\n', '    }\n', '\n', '\n', '    uint256 constant WAD = 10**18;\n', '    uint256 constant RAY = 10**27;\n', '\n', '    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = add(mul(x, y), WAD / 2) / WAD;\n', '    }\n', '\n', '    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = add(mul(x, y), RAY / 2) / RAY;\n', '    }\n', '\n', '    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = add(mul(x, WAD), y / 2) / y;\n', '    }\n', '\n', '    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = add(mul(x, RAY), y / 2) / y;\n', '    }\n', '\n', '} abstract contract CompoundOracleInterface {\n', '    function getUnderlyingPrice(address cToken) external view virtual returns (uint);\n', '} abstract contract ComptrollerInterface {\n', '    function enterMarkets(address[] calldata cTokens) external virtual returns (uint256[] memory);\n', '\n', '    function exitMarket(address cToken) external virtual returns (uint256);\n', '\n', '    function getAssetsIn(address account) external virtual view returns (address[] memory);\n', '\n', '    function markets(address account) public virtual view returns (bool, uint256);\n', '\n', '    function getAccountLiquidity(address account) external virtual view returns (uint256, uint256, uint256);\n', '\n', '    function claimComp(address holder) virtual public;\n', '\n', '    function oracle() public virtual view returns (address);\n', '    \n', '    mapping(address => uint) public compSpeeds;\n', '\n', '    mapping(address => uint) public borrowCaps;\n', '} interface ERC20 {\n', '    function totalSupply() external view returns (uint256 supply);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool success);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value) external returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\n', '\n', '    function decimals() external view returns (uint256 digits);\n', '\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '} abstract contract CTokenInterface is ERC20 {\n', '    function mint(uint256 mintAmount) external virtual returns (uint256);\n', '\n', '    // function mint() external virtual payable;\n', '\n', '    function accrueInterest() public virtual returns (uint);\n', '\n', '    function redeem(uint256 redeemTokens) external virtual returns (uint256);\n', '\n', '    function redeemUnderlying(uint256 redeemAmount) external virtual returns (uint256);\n', '\n', '    function borrow(uint256 borrowAmount) external virtual returns (uint256);\n', '\n', '    function repayBorrow(uint256 repayAmount) external virtual returns (uint256);\n', '\n', '    function repayBorrow() external virtual payable;\n', '\n', '    function repayBorrowBehalf(address borrower, uint256 repayAmount) external virtual returns (uint256);\n', '\n', '    function repayBorrowBehalf(address borrower) external virtual payable;\n', '\n', '    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral)\n', '        external virtual\n', '        returns (uint256);\n', '\n', '    function liquidateBorrow(address borrower, address cTokenCollateral) external virtual payable;\n', '\n', '    function exchangeRateCurrent() external virtual returns (uint256);\n', '\n', '    function supplyRatePerBlock() external virtual returns (uint256);\n', '\n', '    function borrowRatePerBlock() external virtual returns (uint256);\n', '\n', '    function totalReserves() external virtual returns (uint256);\n', '\n', '    function reserveFactorMantissa() external virtual returns (uint256);\n', '\n', '    function borrowBalanceCurrent(address account) external virtual returns (uint256);\n', '\n', '    function totalBorrowsCurrent() external virtual returns (uint256);\n', '\n', '    function getCash() external virtual returns (uint256);\n', '\n', '    function balanceOfUnderlying(address owner) external virtual returns (uint256);\n', '\n', '    function underlying() external virtual returns (address);\n', '\n', '    function getAccountSnapshot(address account) external virtual view returns (uint, uint, uint, uint);\n', '} contract CarefulMath {\n', '\n', '    /**\n', '     * @dev Possible error codes that we can return\n', '     */\n', '    enum MathError {\n', '        NO_ERROR,\n', '        DIVISION_BY_ZERO,\n', '        INTEGER_OVERFLOW,\n', '        INTEGER_UNDERFLOW\n', '    }\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, returns an error on overflow.\n', '    */\n', '    function mulUInt(uint a, uint b) internal pure returns (MathError, uint) {\n', '        if (a == 0) {\n', '            return (MathError.NO_ERROR, 0);\n', '        }\n', '\n', '        uint c = a * b;\n', '\n', '        if (c / a != b) {\n', '            return (MathError.INTEGER_OVERFLOW, 0);\n', '        } else {\n', '            return (MathError.NO_ERROR, c);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function divUInt(uint a, uint b) internal pure returns (MathError, uint) {\n', '        if (b == 0) {\n', '            return (MathError.DIVISION_BY_ZERO, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, a / b);\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function subUInt(uint a, uint b) internal pure returns (MathError, uint) {\n', '        if (b <= a) {\n', '            return (MathError.NO_ERROR, a - b);\n', '        } else {\n', '            return (MathError.INTEGER_UNDERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, returns an error on overflow.\n', '    */\n', '    function addUInt(uint a, uint b) internal pure returns (MathError, uint) {\n', '        uint c = a + b;\n', '\n', '        if (c >= a) {\n', '            return (MathError.NO_ERROR, c);\n', '        } else {\n', '            return (MathError.INTEGER_OVERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev add a and b and then subtract c\n', '    */\n', '    function addThenSubUInt(uint a, uint b, uint c) internal pure returns (MathError, uint) {\n', '        (MathError err0, uint sum) = addUInt(a, b);\n', '\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        return subUInt(sum, c);\n', '    }\n', '} contract Exponential is CarefulMath {\n', '    uint constant expScale = 1e18;\n', '    uint constant halfExpScale = expScale/2;\n', '    uint constant mantissaOne = expScale;\n', '\n', '    struct Exp {\n', '        uint mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Creates an exponential from numerator and denominator values.\n', '     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n', '     *            or if `denom` is zero.\n', '     */\n', '    function getExp(uint num, uint denom) pure internal returns (MathError, Exp memory) {\n', '        (MathError err0, uint scaledNumerator) = mulUInt(num, expScale);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (MathError err1, uint rational) = divUInt(scaledNumerator, denom);\n', '        if (err1 != MathError.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: rational}));\n', '    }\n', '\n', '  \n', '  \n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, returning a new Exp.\n', '     */\n', '    function mulScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n', '        (MathError err0, uint scaledMantissa) = mulUInt(a.mantissa, scalar);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: scaledMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n', '     */\n', '    function mulScalarTruncate(Exp memory a, uint scalar) pure internal returns (MathError, uint) {\n', '        (MathError err, Exp memory product) = mulScalar(a, scalar);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, truncate(product));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n', '     */\n', '    function mulScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (MathError, uint) {\n', '        (MathError err, Exp memory product) = mulScalar(a, scalar);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return addUInt(truncate(product), addend);\n', '    }\n', '\n', '    /**\n', '     * @dev Divide an Exp by a scalar, returning a new Exp.\n', '     */\n', '    function divScalar(Exp memory a, uint scalar) pure internal returns (MathError, Exp memory) {\n', '        (MathError err0, uint descaledMantissa) = divUInt(a.mantissa, scalar);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: descaledMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @dev Divide a scalar by an Exp, returning a new Exp.\n', '     */\n', '    function divScalarByExp(uint scalar, Exp memory divisor) pure internal returns (MathError, Exp memory) {\n', '        /*\n', '          We are doing this as:\n', '          getExp(mulUInt(expScale, scalar), divisor.mantissa)\n', '\n', '          How it works:\n', '          Exp = a / b;\n', '          Scalar = s;\n', '          `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n', '        */\n', '        (MathError err0, uint numerator) = mulUInt(expScale, scalar);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '        return getExp(numerator, divisor.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @dev Divide a scalar by an Exp, then truncate to return an unsigned integer.\n', '     */\n', '    function divScalarByExpTruncate(uint scalar, Exp memory divisor) pure internal returns (MathError, uint) {\n', '        (MathError err, Exp memory fraction) = divScalarByExp(scalar, divisor);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (MathError.NO_ERROR, truncate(fraction));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two exponentials, returning a new exponential.\n', '     */\n', '    function mulExp(Exp memory a, Exp memory b) pure internal returns (MathError, Exp memory) {\n', '\n', '        (MathError err0, uint doubleScaledProduct) = mulUInt(a.mantissa, b.mantissa);\n', '        if (err0 != MathError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        // We add half the scale before dividing so that we get rounding instead of truncation.\n', '        //  See "Listing 6" and text above it at https://accu.org/index.php/journals/1717\n', '        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n', '        (MathError err1, uint doubleScaledProductWithHalfScale) = addUInt(halfExpScale, doubleScaledProduct);\n', '        if (err1 != MathError.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (MathError err2, uint product) = divUInt(doubleScaledProductWithHalfScale, expScale);\n', '        // The only error `div` can return is MathError.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n', '        assert(err2 == MathError.NO_ERROR);\n', '\n', '        return (MathError.NO_ERROR, Exp({mantissa: product}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two exponentials given their mantissas, returning a new exponential.\n', '     */\n', '    function mulExp(uint a, uint b) pure internal returns (MathError, Exp memory) {\n', '        return mulExp(Exp({mantissa: a}), Exp({mantissa: b}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies three exponentials, returning a new exponential.\n', '     */\n', '    function mulExp3(Exp memory a, Exp memory b, Exp memory c) pure internal returns (MathError, Exp memory) {\n', '        (MathError err, Exp memory ab) = mulExp(a, b);\n', '        if (err != MathError.NO_ERROR) {\n', '            return (err, ab);\n', '        }\n', '        return mulExp(ab, c);\n', '    }\n', '\n', '  \n', '    /**\n', '     * @dev Truncates the given exp to a whole number value.\n', '     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n', '     */\n', '    function truncate(Exp memory exp) pure internal returns (uint) {\n', "        // Note: We are not using careful math here as we're performing a division that cannot fail\n", '        return exp.mantissa / expScale;\n', '    }\n', '\n', ' \n', '} contract CompoundSafetyRatio is Exponential, DSMath {\n', '    // solhint-disable-next-line const-name-snakecase\n', '    ComptrollerInterface public constant comp = ComptrollerInterface(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\n', '\n', '    /// @notice Calcualted the ratio of debt / adjusted collateral\n', '    /// @param _user Address of the user\n', '    function getSafetyRatio(address _user) public view returns (uint) {\n', '        // For each asset the account is in\n', '        address[] memory assets = comp.getAssetsIn(_user);\n', '        address oracleAddr = comp.oracle();\n', '\n', '\n', '        uint sumCollateral = 0;\n', '        uint sumBorrow = 0;\n', '\n', '        for (uint i = 0; i < assets.length; i++) {\n', '            address asset = assets[i];\n', '\n', '            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n', '                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n', '\n', '            Exp memory oraclePrice;\n', '\n', '            if (cTokenBalance != 0 || borrowBalance != 0) {\n', '                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n', '            }\n', '\n', '            // Sum up collateral in Usd\n', '            if (cTokenBalance != 0) {\n', '\n', '                (, uint collFactorMantissa) = comp.markets(address(asset));\n', '\n', '                Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n', '                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n', '\n', '                (, Exp memory tokensToUsd) = mulExp3(collateralFactor, exchangeRate, oraclePrice);\n', '\n', '                (, sumCollateral) = mulScalarTruncateAddUInt(tokensToUsd, cTokenBalance, sumCollateral);\n', '            }\n', '\n', '            // Sum up debt in Usd\n', '            if (borrowBalance != 0) {\n', '                (, sumBorrow) = mulScalarTruncateAddUInt(oraclePrice, borrowBalance, sumBorrow);\n', '            }\n', '        }\n', '\n', '        if (sumBorrow == 0) return uint(-1);\n', '\n', '        uint borrowPowerUsed = (sumBorrow * 10**18) / sumCollateral;\n', '        return wdiv(1e18, borrowPowerUsed);\n', '    }\n', '} \n', '\n', 'abstract contract CEtherInterface {\n', '    function mint() external virtual payable;\n', '    function repayBorrow() external virtual payable;\n', '} \n', '\n', 'contract Discount {\n', '    address public owner;\n', '    mapping(address => CustomServiceFee) public serviceFees;\n', '\n', '    uint256 constant MAX_SERVICE_FEE = 400;\n', '\n', '    struct CustomServiceFee {\n', '        bool active;\n', '        uint256 amount;\n', '    }\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    function isCustomFeeSet(address _user) public view returns (bool) {\n', '        return serviceFees[_user].active;\n', '    }\n', '\n', '    function getCustomServiceFee(address _user) public view returns (uint256) {\n', '        return serviceFees[_user].amount;\n', '    }\n', '\n', '    function setServiceFee(address _user, uint256 _fee) public {\n', '        require(msg.sender == owner, "Only owner");\n', '        require(_fee >= MAX_SERVICE_FEE || _fee == 0);\n', '\n', '        serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n', '    }\n', '\n', '    function disableServiceFee(address _user) public {\n', '        require(msg.sender == owner, "Only owner");\n', '\n', '        serviceFees[_user] = CustomServiceFee({active: false, amount: 0});\n', '    }\n', '} abstract contract DSAuthority {\n', '    function canCall(address src, address dst, bytes4 sig) public virtual view returns (bool);\n', '} contract DSAuthEvents {\n', '    event LogSetAuthority(address indexed authority);\n', '    event LogSetOwner(address indexed owner);\n', '}\n', '\n', '\n', 'contract DSAuth is DSAuthEvents {\n', '    DSAuthority public authority;\n', '    address public owner;\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit LogSetOwner(msg.sender);\n', '    }\n', '\n', '    function setOwner(address owner_) public auth {\n', '        owner = owner_;\n', '        emit LogSetOwner(owner);\n', '    }\n', '\n', '    function setAuthority(DSAuthority authority_) public auth {\n', '        authority = authority_;\n', '        emit LogSetAuthority(address(authority));\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig));\n', '        _;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == DSAuthority(0)) {\n', '            return false;\n', '        } else {\n', '            return authority.canCall(src, address(this), sig);\n', '        }\n', '    }\n', '} contract DSNote {\n', '    event LogNote(\n', '        bytes4 indexed sig,\n', '        address indexed guy,\n', '        bytes32 indexed foo,\n', '        bytes32 indexed bar,\n', '        uint256 wad,\n', '        bytes fax\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        bytes32 foo;\n', '        bytes32 bar;\n', '\n', '        assembly {\n', '            foo := calldataload(4)\n', '            bar := calldataload(36)\n', '        }\n', '\n', '        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);\n', '\n', '        _;\n', '    }\n', '} abstract contract DSProxy is DSAuth, DSNote {\n', '    DSProxyCache public cache; // global cache for contracts\n', '\n', '    constructor(address _cacheAddr) public {\n', '        require(setCache(_cacheAddr));\n', '    }\n', '\n', '    // solhint-disable-next-line no-empty-blocks\n', '    receive() external payable {}\n', '\n', '    // use the proxy to execute calldata _data on contract _code\n', '    // function execute(bytes memory _code, bytes memory _data)\n', '    //     public\n', '    //     payable\n', '    //     virtual\n', '    //     returns (address target, bytes32 response);\n', '\n', '    function execute(address _target, bytes memory _data)\n', '        public\n', '        payable\n', '        virtual\n', '        returns (bytes32 response);\n', '\n', '    //set new cache\n', '    function setCache(address _cacheAddr) public virtual payable returns (bool);\n', '}\n', '\n', '\n', 'contract DSProxyCache {\n', '    mapping(bytes32 => address) cache;\n', '\n', '    function read(bytes memory _code) public view returns (address) {\n', '        bytes32 hash = keccak256(_code);\n', '        return cache[hash];\n', '    }\n', '\n', '    function write(bytes memory _code) public returns (address target) {\n', '        assembly {\n', '            target := create(0, add(_code, 0x20), mload(_code))\n', '            switch iszero(extcodesize(target))\n', '                case 1 {\n', '                    // throw if contract failed to deploy\n', '                    revert(0, 0)\n', '                }\n', '        }\n', '        bytes32 hash = keccak256(_code);\n', '        cache[hash] = target;\n', '    }\n', '} library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(ERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     */\n', '    function safeApprove(ERC20 token, address spender, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(ERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function _callOptionalReturn(ERC20 token, bytes memory data) private {\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '} /// @title Utlity functions for Compound contracts\n', 'contract CompoundSaverHelper is DSMath, Exponential {\n', '\n', '    using SafeERC20 for ERC20;\n', '\n', '    address payable public constant WALLET_ADDR = 0x322d58b9E75a6918f7e7849AEe0fF09369977e08;\n', '    address public constant DISCOUNT_ADDR = 0x1b14E8D511c9A4395425314f849bD737BAF8208F;\n', '\n', '    uint public constant SERVICE_FEE = 400; // 0.25% Fee\n', '    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n', '    address public constant COMPTROLLER = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n', '\n', '    address public constant COMPOUND_LOGGER = 0x3DD0CDf5fFA28C6847B4B276e2fD256046a44bb7;\n', '\n', '\n', '    /// @notice Returns the underlying address of the cToken asset\n', '    /// @param _cTokenAddress cToken address\n', '    /// @return Token address of the cToken specified\n', '    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n', '        if (_cTokenAddress == CETH_ADDRESS) {\n', '            return ETH_ADDRESS;\n', '        } else {\n', '            return CTokenInterface(_cTokenAddress).underlying();\n', '        }\n', '    }\n', '\n', '    /// @notice Returns the owner of the DSProxy that called the contract\n', '    function getUserAddress() internal view returns (address) {\n', '        DSProxy proxy = DSProxy(uint160(address(this)));\n', '\n', '        return proxy.owner();\n', '    }\n', '\n', '    /// @notice Returns the maximum amount of collateral available to withdraw\n', '    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n', '    /// @param _cCollAddress Collateral we are getting the max value of\n', '    /// @param _account Users account\n', '    /// @return Returns the max. collateral amount in that token\n', '    function getMaxCollateral(address _cCollAddress, address _account) public returns (uint) {\n', '        (, uint liquidityInUsd, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n', '        uint usersBalance = CTokenInterface(_cCollAddress).balanceOfUnderlying(_account);\n', '        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n', '\n', '        if (liquidityInUsd == 0) return usersBalance;\n', '\n', '        CTokenInterface(_cCollAddress).accrueInterest();\n', '\n', '        (, uint collFactorMantissa) = ComptrollerInterface(COMPTROLLER).markets(_cCollAddress);\n', '        Exp memory collateralFactor = Exp({mantissa: collFactorMantissa});\n', '\n', '        (, uint tokensToUsd) = divScalarByExpTruncate(liquidityInUsd, collateralFactor);\n', '\n', '        uint usdPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cCollAddress);\n', '        uint liqInToken = wdiv(tokensToUsd, usdPrice);\n', '\n', '        if (liqInToken > usersBalance) return usersBalance;\n', '\n', '        return sub(liqInToken, (liqInToken / 100)); // cut off 1% due to rounding issues\n', '    }\n', '\n', '    /// @notice Returns the maximum amount of borrow amount available\n', '    /// @dev Due to rounding errors the result is - 1% wei from the exact amount\n', '    /// @param _cBorrowAddress Borrow token we are getting the max value of\n', '    /// @param _account Users account\n', '    /// @return Returns the max. borrow amount in that token\n', '    function getMaxBorrow(address _cBorrowAddress, address _account) public returns (uint) {\n', '        (, uint liquidityInUsd, ) = ComptrollerInterface(COMPTROLLER).getAccountLiquidity(_account);\n', '        address oracle = ComptrollerInterface(COMPTROLLER).oracle();\n', '\n', '        CTokenInterface(_cBorrowAddress).accrueInterest();\n', '\n', '        uint usdPrice = CompoundOracleInterface(oracle).getUnderlyingPrice(_cBorrowAddress);\n', '        uint liquidityInToken = wdiv(liquidityInUsd, usdPrice);\n', '\n', '        return sub(liquidityInToken, (liquidityInToken / 100)); // cut off 1% due to rounding issues\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', '\n', '/// @title Gets data about Compound positions\n', 'contract CompoundLoanInfo is CompoundSafetyRatio {\n', '\n', '    struct LoanData {\n', '        address user;\n', '        uint128 ratio;\n', '        address[] collAddr;\n', '        address[] borrowAddr;\n', '        uint[] collAmounts;\n', '        uint[] borrowAmounts;\n', '    }\n', '\n', '    struct TokenInfo {\n', '        address cTokenAddress;\n', '        address underlyingTokenAddress;\n', '        uint collateralFactor;\n', '        uint price;\n', '    }\n', '\n', '    struct TokenInfoFull {\n', '        address underlyingTokenAddress;\n', '        uint supplyRate;\n', '        uint borrowRate;\n', '        uint exchangeRate;\n', '        uint marketLiquidity;\n', '        uint totalSupply;\n', '        uint totalBorrow;\n', '        uint collateralFactor;\n', '        uint price;\n', '        uint compSpeed;\n', '        uint borrowCap;\n', '    }\n', '\n', '    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address public constant CETH_ADDRESS = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n', '\n', '\n', '    /// @notice Calcualted the ratio of coll/debt for a compound user\n', '    /// @param _user Address of the user\n', '    function getRatio(address _user) public view returns (uint) {\n', '        // For each asset the account is in\n', '        return getSafetyRatio(_user);\n', '    }\n', '\n', '    /// @notice Fetches Compound prices for tokens\n', '    /// @param _cTokens Arr. of cTokens for which to get the prices\n', '    /// @return prices Array of prices\n', '    function getPrices(address[] memory _cTokens) public view returns (uint[] memory prices) {\n', '        prices = new uint[](_cTokens.length);\n', '        address oracleAddr = comp.oracle();\n', '\n', '        for (uint i = 0; i < _cTokens.length; ++i) {\n', '            prices[i] = CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokens[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Fetches Compound collateral factors for tokens\n', '    /// @param _cTokens Arr. of cTokens for which to get the coll. factors\n', '    /// @return collFactors Array of coll. factors\n', '    function getCollFactors(address[] memory _cTokens) public view returns (uint[] memory collFactors) {\n', '        collFactors = new uint[](_cTokens.length);\n', '\n', '        for (uint i = 0; i < _cTokens.length; ++i) {\n', '            (, collFactors[i]) = comp.markets(_cTokens[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\n', '    /// @param _user Address of the user\n', '    /// @return data LoanData information\n', '    function getLoanData(address _user) public view returns (LoanData memory data) {\n', '        address[] memory assets = comp.getAssetsIn(_user);\n', '        address oracleAddr = comp.oracle();\n', '\n', '        data = LoanData({\n', '            user: _user,\n', '            ratio: 0,\n', '            collAddr: new address[](assets.length),\n', '            borrowAddr: new address[](assets.length),\n', '            collAmounts: new uint[](assets.length),\n', '            borrowAmounts: new uint[](assets.length)\n', '        });\n', '\n', '        uint collPos = 0;\n', '        uint borrowPos = 0;\n', '\n', '        for (uint i = 0; i < assets.length; i++) {\n', '            address asset = assets[i];\n', '\n', '            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n', '                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n', '\n', '            Exp memory oraclePrice;\n', '\n', '            if (cTokenBalance != 0 || borrowBalance != 0) {\n', '                oraclePrice = Exp({mantissa: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(asset)});\n', '            }\n', '\n', '            // Sum up collateral in Usd\n', '            if (cTokenBalance != 0) {\n', '                Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n', '                (, Exp memory tokensToUsd) = mulExp(exchangeRate, oraclePrice);\n', '\n', '                data.collAddr[collPos] = asset;\n', '                (, data.collAmounts[collPos]) = mulScalarTruncate(tokensToUsd, cTokenBalance);\n', '                collPos++;\n', '            }\n', '\n', '            // Sum up debt in Usd\n', '            if (borrowBalance != 0) {\n', '                data.borrowAddr[borrowPos] = asset;\n', '                (, data.borrowAmounts[borrowPos]) = mulScalarTruncate(oraclePrice, borrowBalance);\n', '                borrowPos++;\n', '            }\n', '        }\n', '\n', '        data.ratio = uint128(getSafetyRatio(_user));\n', '\n', '        return data;\n', '    }\n', '\n', '    function getTokenBalances(address _user, address[] memory _cTokens) public view returns (uint[] memory balances, uint[] memory borrows) {\n', '        balances = new uint[](_cTokens.length);\n', '        borrows = new uint[](_cTokens.length);\n', '\n', '        for (uint i = 0; i < _cTokens.length; i++) {\n', '            address asset = _cTokens[i];\n', '\n', '            (, uint cTokenBalance, uint borrowBalance, uint exchangeRateMantissa)\n', '                                        = CTokenInterface(asset).getAccountSnapshot(_user);\n', '\n', '            Exp memory exchangeRate = Exp({mantissa: exchangeRateMantissa});\n', '            (, balances[i]) = mulScalarTruncate(exchangeRate, cTokenBalance);\n', '\n', '            borrows[i] = borrowBalance;\n', '        }\n', '\n', '    }\n', '\n', '    /// @notice Fetches all the collateral/debt address and amounts, denominated in usd\n', '    /// @param _users Addresses of the user\n', '    /// @return loans Array of LoanData information\n', '    function getLoanDataArr(address[] memory _users) public view returns (LoanData[] memory loans) {\n', '        loans = new LoanData[](_users.length);\n', '\n', '        for (uint i = 0; i < _users.length; ++i) {\n', '            loans[i] = getLoanData(_users[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Calcualted the ratio of coll/debt for a compound user\n', '    /// @param _users Addresses of the user\n', '    /// @return ratios Array of ratios\n', '    function getRatios(address[] memory _users) public view returns (uint[] memory ratios) {\n', '        ratios = new uint[](_users.length);\n', '\n', '        for (uint i = 0; i < _users.length; ++i) {\n', '            ratios[i] = getSafetyRatio(_users[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Information about cTokens\n', '    /// @param _cTokenAddresses Array of cTokens addresses\n', '    /// @return tokens Array of cTokens infomartion\n', '    function getTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfo[] memory tokens) {\n', '        tokens = new TokenInfo[](_cTokenAddresses.length);\n', '        address oracleAddr = comp.oracle();\n', '\n', '        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n', '            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n', '\n', '            tokens[i] = TokenInfo({\n', '                cTokenAddress: _cTokenAddresses[i],\n', '                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n', '                collateralFactor: collFactor,\n', '                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i])\n', '            });\n', '        }\n', '    }\n', '\n', '    /// @notice Information about cTokens\n', '    /// @param _cTokenAddresses Array of cTokens addresses\n', '    /// @return tokens Array of cTokens infomartion\n', '    function getFullTokensInfo(address[] memory _cTokenAddresses) public returns(TokenInfoFull[] memory tokens) {\n', '        tokens = new TokenInfoFull[](_cTokenAddresses.length);\n', '        address oracleAddr = comp.oracle();\n', '\n', '        for (uint i = 0; i < _cTokenAddresses.length; ++i) {\n', '            (, uint collFactor) = comp.markets(_cTokenAddresses[i]);\n', '            CTokenInterface cToken = CTokenInterface(_cTokenAddresses[i]);\n', '\n', '            tokens[i] = TokenInfoFull({\n', '                underlyingTokenAddress: getUnderlyingAddr(_cTokenAddresses[i]),\n', '                supplyRate: cToken.supplyRatePerBlock(),\n', '                borrowRate: cToken.borrowRatePerBlock(),\n', '                exchangeRate: cToken.exchangeRateCurrent(),\n', '                marketLiquidity: cToken.getCash(),\n', '                totalSupply: cToken.totalSupply(),\n', '                totalBorrow: cToken.totalBorrowsCurrent(),\n', '                collateralFactor: collFactor,\n', '                price: CompoundOracleInterface(oracleAddr).getUnderlyingPrice(_cTokenAddresses[i]),\n', '                compSpeed: comp.compSpeeds(_cTokenAddresses[i]),\n', '                borrowCap: comp.borrowCaps(_cTokenAddresses[i])\n', '            });\n', '        }\n', '    }\n', '\n', '    /// @notice Returns the underlying address of the cToken asset\n', '    /// @param _cTokenAddress cToken address\n', '    /// @return Token address of the cToken specified\n', '    function getUnderlyingAddr(address _cTokenAddress) internal returns (address) {\n', '        if (_cTokenAddress == CETH_ADDRESS) {\n', '            return ETH_ADDRESS;\n', '        } else {\n', '            return CTokenInterface(_cTokenAddress).underlying();\n', '        }\n', '    }\n', '}']