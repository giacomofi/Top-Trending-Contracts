['// SPDX-License-Identifier: J-J-J-JENGA!!!\n', 'pragma solidity ^0.7.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/* ROOTKIT:\n', 'A transfer gate (GatedERC20) for use with RootKit tokens\n', '\n', 'It:\n', '    Allows customization of tax and burn rates\n', '    Allows transfer to/from approved UniswapV2 pools\n', '    Disallows transfer to/from non-approved UniswapV2 pools\n', '    Allows transfer to/from anywhere else\n', '    Allows for free transfers if permission granted\n', '    Allows for unrestricted transfers if permission granted\n', '    Provides a safe and tax-free liquidity adding function\n', '*/\n', '\n', 'import "./Owned.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./IERC20.sol";\n', 'import "./IUniswapV2Pair.sol";\n', 'import "./RootKit.sol";\n', 'import "./Address.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./TokensRecoverable.sol";\n', 'import "./ITransferGate.sol";\n', '\n', 'struct RootKitTransferGateParameters\n', '{\n', '    address dev;\n', '    uint16 stakeRate; // 10000 = 100%\n', '    uint16 burnRate; // 10000 = 100%\n', '    uint16 devRate;  // 10000 = 100%\n', '    address stake;\n', '}\n', '\n', 'contract RootKitTransferGate is TokensRecoverable, ITransferGate\n', '{   \n', '    using Address for address;\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    enum AddressState\n', '    {\n', '        Unknown,\n', '        NotPool,\n', '        DisallowedPool,\n', '        AllowedPool\n', '    }\n', '\n', '    RootKitTransferGateParameters public parameters;\n', '    IUniswapV2Router02 public uniswapV2Router;\n', '    IUniswapV2Factory public uniswapV2Factory;\n', '    RootKit immutable rootKit;\n', '\n', '    mapping (address => AddressState) public addressStates;\n', '    IERC20[] public allowedPoolTokens;\n', '    \n', '    bool public unrestricted;\n', '    mapping (address => bool) public unrestrictedControllers;\n', '    mapping (address => bool) public feeControllers;\n', '    mapping (address => bool) public freeParticipantControllers;\n', '    mapping (address => bool) public freeParticipant;\n', '    mapping (address => uint16) public poolsTaxRates;\n', '\n', '    mapping (address => uint256) public liquiditySupply;\n', '    address public mustUpdate;\n', '\n', '    uint16 public dumpTaxStartRate; \n', '    uint256 public dumpTaxDurationInSeconds;\n', '    uint256 public dumpTaxEndTimestamp;\n', '\n', '    constructor(RootKit _rootKit, IUniswapV2Router02 _uniswapV2Router)\n', '    {\n', '        rootKit = _rootKit;\n', '        uniswapV2Router = _uniswapV2Router;\n', '        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\n', '    }\n', '\n', '    function setRouterAndFactory(IUniswapV2Router02 _uniswapV2Router) public ownerOnly()\n', '    {\n', '        uniswapV2Router = _uniswapV2Router;\n', '        uniswapV2Factory = IUniswapV2Factory(_uniswapV2Router.factory());\n', '    }\n', '\n', '    function allowedPoolTokensCount() public view returns (uint256) { return allowedPoolTokens.length; }\n', '\n', '    function setUnrestrictedController(address unrestrictedController, bool allow) public ownerOnly()\n', '    {\n', '        unrestrictedControllers[unrestrictedController] = allow;\n', '    }\n', '\n', '    function setFreeParticipantController(address freeParticipantController, bool allow) public ownerOnly()\n', '    {\n', '        freeParticipantControllers[freeParticipantController] = allow;\n', '    }\n', '\n', '    function setFeeControllers(address feeController, bool allow) public ownerOnly()\n', '    {\n', '        feeControllers[feeController] = allow;\n', '    }\n', '    \n', '    function setFreeParticipant(address participant, bool free) public\n', '    {\n', '        require (freeParticipantControllers[msg.sender] || msg.sender == owner, "Not an owner or fee controller");\n', '        freeParticipant[participant] = free;\n', '    }\n', '    \n', '    function setUnrestricted(bool _unrestricted) public\n', '    {\n', '        require (unrestrictedControllers[msg.sender], "Not an unrestricted controller");\n', '        unrestricted = _unrestricted;\n', '    }\n', '\n', '    function setParameters(address _dev, address _stake, uint16 _stakeRate, uint16 _burnRate, uint16 _devRate) public ownerOnly()\n', '    {\n', '        require (_stakeRate <= 10000 && _burnRate <= 10000 && _devRate <= 10000 && _stakeRate + _burnRate + _devRate <= 10000, "> 100%");\n', '        require (_dev != address(0) && _stake != address(0));\n', '        require (_stakeRate <= 500 && _burnRate <= 500 && _devRate <= 10, "Sanity");\n', '        \n', '        RootKitTransferGateParameters memory _parameters;\n', '        _parameters.dev = _dev;\n', '        _parameters.stakeRate = _stakeRate;\n', '        _parameters.burnRate = _burnRate;\n', '        _parameters.devRate = _devRate;\n', '        _parameters.stake = _stake;\n', '        parameters = _parameters;\n', '    }\n', '\n', '    function setPoolTaxRate(address pool, uint16 taxRate) public\n', '    {\n', '        require (feeControllers[msg.sender] || msg.sender == owner, "Not an owner or fee controller");\n', '        require (taxRate <= 10000, "Fee rate must be less than or equal to 100%");\n', '        poolsTaxRates[pool] = taxRate;\n', '    }\n', '\n', '    function setDumpTax(uint16 startTaxRate, uint256 durationInSeconds) public\n', '    {\n', '        require (feeControllers[msg.sender] || msg.sender == owner, "Not an owner or fee controller");\n', '        require (startTaxRate <= 2500, "Dump tax rate must be less than or equal to 25%");\n', '\n', '        dumpTaxStartRate = startTaxRate;\n', '        dumpTaxDurationInSeconds = durationInSeconds;\n', '        dumpTaxEndTimestamp = block.timestamp + durationInSeconds;\n', '    }\n', '\n', '    function getDumpTax() public view returns (uint256)\n', '    {\n', '        if (block.timestamp >= dumpTaxEndTimestamp) \n', '        {\n', '            return 0;\n', '        }       \n', '        \n', '        return dumpTaxStartRate*(dumpTaxEndTimestamp - block.timestamp)*1e18/dumpTaxDurationInSeconds/1e18;\n', '    }\n', '\n', '    function allowPool(IERC20 token) public ownerOnly()\n', '    {\n', '        address pool = uniswapV2Factory.getPair(address(rootKit), address(token));\n', '        if (pool == address(0)) {\n', '            pool = uniswapV2Factory.createPair(address(rootKit), address(token));\n', '        }\n', '        AddressState state = addressStates[pool];\n', '        require (state != AddressState.AllowedPool, "Already allowed");\n', '        addressStates[pool] = AddressState.AllowedPool;\n', '        allowedPoolTokens.push(token);\n', '        liquiditySupply[pool] = IERC20(pool).totalSupply();\n', '    }\n', '\n', '    function safeAddLiquidity(IERC20 token, uint256 tokenAmount, uint256 rootKitAmount, uint256 minTokenAmount, uint256 minRootKitAmount, address to, uint256 deadline) public\n', '        returns (uint256 rootKitUsed, uint256 tokenUsed, uint256 liquidity)\n', '    {\n', '        address pool = uniswapV2Factory.getPair(address(rootKit), address(token));\n', '        require (pool != address(0) && addressStates[pool] == AddressState.AllowedPool, "Pool not approved");\n', '        require (!unrestricted);\n', '        unrestricted = true;\n', '\n', '        uint256 tokenBalance = token.balanceOf(address(this));\n', '        token.safeTransferFrom(msg.sender, address(this), tokenAmount);\n', '        rootKit.transferFrom(msg.sender, address(this), rootKitAmount);\n', '        rootKit.approve(address(uniswapV2Router), rootKitAmount);\n', '        token.safeApprove(address(uniswapV2Router), tokenAmount);\n', '        (rootKitUsed, tokenUsed, liquidity) = uniswapV2Router.addLiquidity(address(rootKit), address(token), rootKitAmount, tokenAmount, minRootKitAmount, minTokenAmount, to, deadline);\n', '        liquiditySupply[pool] = IERC20(pool).totalSupply();\n', '        if (mustUpdate == pool) {\n', '            mustUpdate = address(0);\n', '        }\n', '\n', '        if (rootKitUsed < rootKitAmount) {\n', '            rootKit.transfer(msg.sender, rootKitAmount - rootKitUsed);\n', '        }\n', "        tokenBalance = token.balanceOf(address(this)).sub(tokenBalance); // we do it this way in case there's a burn\n", '        if (tokenBalance > 0) {\n', '            token.safeTransfer(msg.sender, tokenBalance);\n', '        }\n', '        \n', '        unrestricted = false;\n', '    }\n', '\n', '    function handleTransfer(address, address from, address to, uint256 amount) external override\n', '        returns (uint256 burn, TransferGateTarget[] memory targets)\n', '    {\n', '        {\n', '            address mustUpdateAddress = mustUpdate;\n', '            if (mustUpdateAddress != address(0)) {\n', '                mustUpdate = address(0);\n', '                uint256 newSupply = IERC20(mustUpdateAddress).totalSupply();\n', '                uint256 oldSupply = liquiditySupply[mustUpdateAddress];\n', '                if (newSupply != oldSupply) {\n', '                    liquiditySupply[mustUpdateAddress] = unrestricted ? newSupply : (newSupply > oldSupply ? newSupply : oldSupply);\n', '                }\n', '            }\n', '        }\n', '        {\n', '            AddressState fromState = addressStates[from];\n', '            AddressState toState = addressStates[to];\n', '            if (fromState != AddressState.AllowedPool && toState != AddressState.AllowedPool) {\n', '                if (fromState == AddressState.Unknown) { fromState = detectState(from); }\n', '                if (toState == AddressState.Unknown) { toState = detectState(to); }\n', '                require (unrestricted || (fromState != AddressState.DisallowedPool && toState != AddressState.DisallowedPool), "Pool not approved");\n', '            }\n', '            if (toState == AddressState.AllowedPool) {\n', '                mustUpdate = to;\n', '            }\n', '            if (fromState == AddressState.AllowedPool) {\n', '                if (unrestricted) {\n', '                    liquiditySupply[from] = IERC20(from).totalSupply();\n', '                }\n', '                require (IERC20(from).totalSupply() >= liquiditySupply[from], "Cannot remove liquidity");            \n', '            }\n', '        }\n', '        if (unrestricted || freeParticipant[from] || freeParticipant[to]) {\n', '            return (0, new TransferGateTarget[](0));\n', '        }\n', '        RootKitTransferGateParameters memory params = parameters;\n', '        \n', '        burn = amount * (poolsTaxRates[to] > params.burnRate ? poolsTaxRates[to] + getDumpTax() : params.burnRate) / 10000;\n', '\n', '        targets = new TransferGateTarget[]((params.devRate > 0 ? 1 : 0) + (params.stakeRate > 0 ? 1 : 0));\n', '        uint256 index = 0;\n', '        if (params.stakeRate > 0) {\n', '            targets[index].destination = params.stake;\n', '            targets[index++].amount = amount * params.stakeRate / 10000;\n', '        }\n', '        if (params.devRate > 0) {\n', '            targets[index].destination = params.dev;\n', '            targets[index].amount = amount * params.devRate / 10000;\n', '        }\n', '    }\n', '\n', '    function setAddressState(address a, AddressState state) public ownerOnly()\n', '    {\n', '        addressStates[a] = state;\n', '    }\n', '\n', '    function detectState(address a) public returns (AddressState state) \n', '    {\n', '        state = AddressState.NotPool;\n', '        if (a.isContract()) {\n', '            try this.throwAddressState(a)\n', '            {\n', '                assert(false);\n', '            }\n', '            catch Error(string memory result) {\n', '                // if (bytes(result).length == 1) {\n', '                //     state = AddressState.NotPool;\n', '                // }\n', '                if (bytes(result).length == 2) {\n', '                    state = AddressState.DisallowedPool;\n', '                }\n', '            }\n', '            catch {\n', '            }\n', '        }\n', '        addressStates[a] = state;\n', '        return state;\n', '    }\n', '    \n', '    // Not intended for external consumption\n', '    // Always throws\n', "    // We want to call functions to probe for things, but don't want to open ourselves up to\n", '    // possible state-changes\n', '    // So we return a value by reverting with a message\n', '    function throwAddressState(address a) external view\n', '    {\n', '        try IUniswapV2Pair(a).factory() returns (address factory)\n', '        {\n', "            // don't care if it's some crappy alt-amm\n", '            if (factory == address(uniswapV2Factory)) {\n', '                // these checks for token0/token1 are just for additional\n', "                // certainty that we're interacting with a uniswap pair\n", '                try IUniswapV2Pair(a).token0() returns (address token0)\n', '                {\n', '                    if (token0 == address(rootKit)) {\n', '                        revert("22");\n', '                    }\n', '                    try IUniswapV2Pair(a).token1() returns (address token1)\n', '                    {\n', '                        if (token1 == address(rootKit)) {\n', '                            revert("22");\n', '                        }                        \n', '                    }\n', '                    catch { \n', '                    }                    \n', '                }\n', '                catch { \n', '                }\n', '            }\n', '        }\n', '        catch {             \n', '        }\n', '        revert("1");\n', '    }\n', '}']