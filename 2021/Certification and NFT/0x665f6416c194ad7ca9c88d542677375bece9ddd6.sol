['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-10\n', '*/\n', '\n', '// SPDX-License-Identifier: Apache-2.0\n', 'pragma solidity ^0.7.0;\n', 'pragma experimental ABIEncoderV2;\n', '// File: contracts/lib/ReentrancyGuard.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title ReentrancyGuard\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev Exposes a modifier that guards a function against reentrancy\n', '///      Changing the value of the same storage value multiple times in a transaction\n', '///      is cheap (starting from Istanbul) so there is no need to minimize\n', '///      the number of times the value is changed\n', 'contract ReentrancyGuard\n', '{\n', '    //The default value must be 0 in order to work behind a proxy.\n', '    uint private _guardValue;\n', '\n', '    // Use this modifier on a function to prevent reentrancy\n', '    modifier nonReentrant()\n', '    {\n', '        // Check if the guard value has its original value\n', '        require(_guardValue == 0, "REENTRANCY");\n', '\n', '        // Set the value to something else\n', '        _guardValue = 1;\n', '\n', '        // Function body\n', '        _;\n', '\n', '        // Set the value back\n', '        _guardValue = 0;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/AddressUtil.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title Utility Functions for addresses\n', '/// @author Daniel Wang - <[email\xa0protected]>\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library AddressUtil\n', '{\n', '    using AddressUtil for *;\n', '\n', '    function isContract(\n', '        address addr\n', '        )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(addr) }\n', '        return (codehash != 0x0 &&\n', '                codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n', '    }\n', '\n', '    function toPayable(\n', '        address addr\n', '        )\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return payable(addr);\n', '    }\n', '\n', '    // Works like address.send but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETH(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        if (amount == 0) {\n', '            return true;\n', '        }\n', '        address payable recipient = to.toPayable();\n', '        /* solium-disable-next-line */\n', '        (success, ) = recipient.call{value: amount, gas: gasLimit}("");\n', '    }\n', '\n', '    // Works like address.transfer but with a customizable gas limit\n', '    // Make sure your code is safe for reentrancy when using this function!\n', '    function sendETHAndVerify(\n', '        address to,\n', '        uint    amount,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool success)\n', '    {\n', '        success = to.sendETH(amount, gasLimit);\n', '        require(success, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    // Works like call but is slightly more efficient when data\n', '    // needs to be copied from memory to do the call.\n', '    function fastCall(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bool success, bytes memory returnData)\n', '    {\n', '        if (to != address(0)) {\n', '            assembly {\n', '                // Do the call\n', '                success := call(gasLimit, to, value, add(data, 32), mload(data), 0, 0)\n', '                // Copy the return data\n', '                let size := returndatasize()\n', '                returnData := mload(0x40)\n', '                mstore(returnData, size)\n', '                returndatacopy(add(returnData, 32), 0, size)\n', '                // Update free memory pointer\n', '                mstore(0x40, add(returnData, add(32, size)))\n', '            }\n', '        }\n', '    }\n', '\n', '    // Like fastCall, but throws when the call is unsuccessful.\n', '    function fastCallAndVerify(\n', '        address to,\n', '        uint    gasLimit,\n', '        uint    value,\n', '        bytes   memory data\n', '        )\n', '        internal\n', '        returns (bytes memory returnData)\n', '    {\n', '        bool success;\n', '        (success, returnData) = fastCall(to, gasLimit, value, data);\n', '        if (!success) {\n', '            assembly {\n', '                revert(add(returnData, 32), mload(returnData))\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ERC20.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title ERC20 Token Interface\n', '/// @dev see https://github.com/ethereum/EIPs/issues/20\n', '/// @author Daniel Wang - <[email\xa0protected]>\n', 'abstract contract ERC20\n', '{\n', '    function totalSupply()\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function balanceOf(\n', '        address who\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function allowance(\n', '        address owner,\n', '        address spender\n', '        )\n', '        public\n', '        virtual\n', '        view\n', '        returns (uint);\n', '\n', '    function transfer(\n', '        address to,\n', '        uint value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '\n', '    function approve(\n', '        address spender,\n', '        uint    value\n', '        )\n', '        public\n', '        virtual\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/lib/ERC20SafeTransfer.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '/// @title ERC20 safe transfer\n', '/// @dev see https://github.com/sec-bit/badERC20Fix\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', 'library ERC20SafeTransfer\n', '{\n', '    function safeTransferAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferWithGasLimitAndVerify(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferWithGasLimit(\n', '            token,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimitAndVerify(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        require(\n', '            safeTransferWithGasLimit(token, to, value, gasLimit),\n', '            "TRANSFER_FAILURE"\n', '        );\n', '    }\n', '\n', '    function safeTransferWithGasLimit(\n', '        address token,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transfer is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transfer(address,uint256)")) = 0xa9059cbb\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0xa9059cbb),\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function safeTransferFromAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '    {\n', '        safeTransferFromWithGasLimitAndVerify(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', '        return safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasleft()\n', '        );\n', '    }\n', '\n', '    function safeTransferFromWithGasLimitAndVerify(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '    {\n', '        bool result = safeTransferFromWithGasLimit(\n', '            token,\n', '            from,\n', '            to,\n', '            value,\n', '            gasLimit\n', '        );\n', '        require(result, "TRANSFER_FAILURE");\n', '    }\n', '\n', '    function safeTransferFromWithGasLimit(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint    value,\n', '        uint    gasLimit\n', '        )\n', '        internal\n', '        returns (bool)\n', '    {\n', "        // A transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '\n', '        // bytes4(keccak256("transferFrom(address,address,uint256)")) = 0x23b872dd\n', '        bytes memory callData = abi.encodeWithSelector(\n', '            bytes4(0x23b872dd),\n', '            from,\n', '            to,\n', '            value\n', '        );\n', '        (bool success, ) = token.call{gas: gasLimit}(callData);\n', '        return checkReturnValue(success);\n', '    }\n', '\n', '    function checkReturnValue(\n', '        bool success\n', '        )\n', '        internal\n', '        pure\n', '        returns (bool)\n', '    {\n', "        // A transfer/transferFrom is successful when 'call' is successful and depending on the token:\n", "        // - No value is returned: we assume a revert when the transfer failed (i.e. 'call' returns false)\n", '        // - A single boolean is returned: this boolean needs to be true (non-zero)\n', '        if (success) {\n', '            assembly {\n', '                switch returndatasize()\n', "                // Non-standard ERC20: nothing is returned so if 'call' was successful we assume the transfer succeeded\n", '                case 0 {\n', '                    success := 1\n', '                }\n', '                // Standard ERC20: a single boolean value is returned which needs to be true\n', '                case 32 {\n', '                    returndatacopy(0, 0, 32)\n', '                    success := mload(0)\n', '                }\n', '                // None of the above: not successful\n', '                default {\n', '                    success := 0\n', '                }\n', '            }\n', '        }\n', '        return success;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Drainable.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', '\n', '\n', '/// @title Drainable\n', '/// @author Brecht Devos - <[email\xa0protected]>\n', '/// @dev Standard functionality to allow draining funds from a contract.\n', 'abstract contract Drainable\n', '{\n', '    using AddressUtil       for address;\n', '    using ERC20SafeTransfer for address;\n', '\n', '    event Drained(\n', '        address to,\n', '        address token,\n', '        uint    amount\n', '    );\n', '\n', '    function drain(\n', '        address to,\n', '        address token\n', '        )\n', '        public\n', '        returns (uint amount)\n', '    {\n', '        require(canDrain(msg.sender, token), "UNAUTHORIZED");\n', '\n', '        if (token == address(0)) {\n', '            amount = address(this).balance;\n', '            to.sendETHAndVerify(amount, gasleft());   // ETH\n', '        } else {\n', '            amount = ERC20(token).balanceOf(address(this));\n', '            token.safeTransferAndVerify(to, amount);  // ERC20 token\n', '        }\n', '\n', '        emit Drained(to, token, amount);\n', '    }\n', '\n', '    // Needs to return if the address is authorized to call drain.\n', '    function canDrain(address drainer, address token)\n', '        public\n', '        virtual\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// File: contracts/aux/migrate/MigrationToLoopringExchangeV2.sol\n', '\n', '// Copyright 2017 Loopring Technology Limited.\n', '\n', '\n', '\n', 'abstract contract ILoopringV3Partial\n', '{\n', '    function withdrawExchangeStake(\n', '        uint    exchangeId,\n', '        address recipient,\n', '        uint    requestedAmount\n', '        )\n', '        external\n', '        virtual\n', '        returns (uint amount);\n', '}\n', '\n', '/// @author Kongliang Zhong - <[email\xa0protected]>\n', '/// @dev This contract enables an alternative approach of getting back assets from Loopring Exchange v1.\n', "/// Now you don't have to withdraw using merkle proofs (very expensive);\n", "/// instead, all assets will be distributed on Loopring Exchange v2 - Loopring's new zkRollup implementation.\n", '/// Please activate and unlock your address on https://exchange.loopring.io to claim your assets.\n', 'contract MigrationToLoopringExchangeV2 is Drainable\n', '{\n', '    function canDrain(address /*drainer*/, address /*token*/)\n', '        public\n', '        override\n', '        view\n', '        returns (bool) {\n', '        return isMigrationOperator();\n', '    }\n', '\n', '    function withdrawExchangeStake(\n', '        address loopringV3,\n', '        uint exchangeId,\n', '        uint amount,\n', '        address recipient\n', '        )\n', '        external\n', '    {\n', '        require(isMigrationOperator(), "INVALID_SENDER");\n', '        ILoopringV3Partial(loopringV3).withdrawExchangeStake(exchangeId, recipient, amount);\n', '    }\n', '\n', '    function isMigrationOperator() internal view returns (bool) {\n', '        return msg.sender == 0x4374D3d032B3c96785094ec9f384f07077792768;\n', '    }\n', '\n', '}']