['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-20\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', '\n', 'pragma solidity 0.7.4;\n', '\n', '\n', 'interface ITrollbox {\n', '    function withdrawWinnings(uint voterId) external;\n', '    function updateAccount(uint voterId, uint tournamentId, uint roundId) external;\n', '    function isSynced(uint voterId, uint tournamentId, uint roundId) external view returns (bool);\n', '    function roundAlreadyResolved(uint tournamentId, uint roundId) external view returns (bool);\n', '    function resolveRound(uint tournamentId, uint roundId, uint winningOption) external;\n', '    function getCurrentRoundId(uint tournamentId) external view returns (uint);\n', '}\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface KeeperCompatibleInterface {\n', '\n', '  /**\n', '   * @notice method that is simulated by the keepers to see if any work actually\n', '   * needs to be performed. This method does does not actually need to be\n', '   * executable, and since it is only ever simulated it can consume lots of gas.\n', '   * @dev To ensure that it is never called, you may want to add the\n', '   * cannotExecute modifier from KeeperBase to your implementation of this\n', '   * method.\n', '   * @param checkData specified in the upkeep registration so it is always the\n', '   * same for a registered upkeep. This can easily be broken down into specific\n', '   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n', '   * same contract and easily differentiated by the contract.\n', '   * @return upkeepNeeded boolean to indicate whether the keeper should call\n', '   * performUpkeep or not.\n', '   * @return performData bytes that the keeper should call performUpkeep with, if\n', '   * upkeep is needed. If you would like to encode data to decode later, try\n', '   * `abi.encode`.\n', '   */\n', '  function checkUpkeep(\n', '    bytes calldata checkData\n', '  )\n', '    external\n', '    returns (\n', '      bool upkeepNeeded,\n', '      bytes memory performData\n', '    );\n', '  /**\n', '   * @notice method that is actually executed by the keepers, via the registry.\n', '   * The data returned by the checkUpkeep simulation will be passed into\n', '   * this method to actually be executed.\n', '   * @dev The input to this method should not be trusted, and the caller of the\n', '   * method should not even be restricted to any single registry. Anyone should\n', '   * be able call it, and the input should be validated, there is no guarantee\n', '   * that the data passed in is the performData returned from checkUpkeep. This\n', '   * could happen due to malicious keepers, racing keepers, or simply a state\n', '   * change while the performUpkeep transaction is waiting for confirmation.\n', '   * Always validate the data passed in.\n', '   * @param performData is the data which was passed back from the checkData\n', '   * simulation. If it is encoded, it can easily be decoded into other types by\n', '   * calling `abi.decode`. This data should not be trusted, and should be\n', "   * validated against the contract's current state.\n", '   */\n', '  function performUpkeep(\n', '    bytes calldata performData\n', '  ) external;\n', '}\n', '\n', 'interface AggregatorV3Interface {\n', '\n', '  function decimals() external view returns (uint8);\n', '  function description() external view returns (string memory);\n', '  function version() external view returns (uint256);\n', '\n', '  // getRoundData and latestRoundData should both raise "No data present"\n', '  // if they do not have data to report, instead of returning unset values\n', '  // which could be misinterpreted as actual reported values.\n', '  function getRoundData(uint80 _roundId)\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '  function latestRoundData()\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '\n', '}\n', '\n', 'contract ChainLinkOracle2 is KeeperCompatibleInterface {\n', '\n', '    struct Proposal {\n', '        uint id;\n', '        uint time;\n', '        bool confirmed;\n', '        uint roundId;\n', '        uint winnerIndex;\n', '        uint challengeWinnerIndex;\n', '        address challenger;\n', '        bytes32 challengeEvidence;\n', '        bytes32 confirmationEvidence;\n', '    }\n', '\n', '    mapping (bytes32 => address) public feedMap; // ticker symbol => price aggregator address\n', '    mapping (bytes32 => int) public prices; // symbol => price\n', '    mapping (uint => Proposal) public proposals;\n', '\n', '    address public management;\n', '    ITrollbox public trollbox;\n', '    IERC20 public token;\n', '\n', '    int constant public PRECISION = 1000000;\n', '    uint public numProposals = 0;\n', '    uint public challengeDeposit = 0;\n', '    uint public challengePeriodSeconds = 60 * 60 * 24;\n', '    uint public tournamentId = 1;\n', '    uint public startingRoundId = 0;\n', '\n', '    bytes32[] public tickerSymbols;\n', '\n', '    // mgmt events\n', '    event FeedUpdated(bytes32 indexed key, address indexed feedAddr);\n', '    event ManagementUpdated(address oldManagement, address newManagement);\n', '    event DepositUpdated(uint oldDeposit, uint newDeposit);\n', '    event ChallengePeriodUpdated(uint oldPeriod, uint newPeriod);\n', '    event TickerSymbolsUpdated(bytes32[] oldKeys, bytes32[] newKeys, int[] newPrices);\n', '\n', '    // winner events\n', '    event WinnerProposed(uint indexed roundId, uint indexed proposalId, uint winnerIndex, int[] prices);\n', '    event WinnerConfirmed(uint indexed roundId, uint indexed proposalId, int[] prices);\n', '\n', '    // challenger events\n', '    event ChallengeMade(uint indexed proposalId, address indexed challenger, uint indexed claimedWinner, bytes32 evidence);\n', '    event ChallengerSlashed(uint indexed proposalId, address indexed challenger, uint indexed slashAmount, bytes32 evidence);\n', '    event ChallengerVindicated(uint indexed proposalId, address indexed challenger, bytes32 evidence);\n', '\n', '    modifier managementOnly() {\n', "        require (msg.sender == management, 'Only management may call this');\n", '        _;\n', '    }\n', '\n', '    modifier latestProposalConfirmed() {\n', "        require (proposals[numProposals].confirmed == true || numProposals == 0, 'Unconfirmed proposal present');\n", '        _;\n', '    }\n', '\n', '    constructor(address mgmt, address trollboxAddr, address tokenAddr, uint tournament, uint roundId, bytes32[] memory initialSymbols, int[] memory initialPrices) {\n', '        management = mgmt;\n', '        trollbox = ITrollbox(trollboxAddr);\n', '        token = IERC20(tokenAddr);\n', '        tournamentId = tournament;\n', '        startingRoundId = roundId;\n', '        tickerSymbols = initialSymbols;\n', '        setPricesInternal(initialPrices);\n', '    }\n', '\n', '    function setManagement(address newMgmt) public managementOnly {\n', '        address oldMgmt = management;\n', '        management = newMgmt;\n', '        emit ManagementUpdated(oldMgmt, newMgmt);\n', '    }\n', '\n', '    function setChallengeDeposit(uint newDeposit) public managementOnly latestProposalConfirmed {\n', '        uint oldDeposit = challengeDeposit;\n', '        challengeDeposit = newDeposit;\n', '        emit DepositUpdated(oldDeposit, newDeposit);\n', '    }\n', '\n', '    function setChallengePeriod(uint newPeriod) public managementOnly latestProposalConfirmed {\n', '        uint oldPeriod = challengePeriodSeconds;\n', '        challengePeriodSeconds = newPeriod;\n', '        emit ChallengePeriodUpdated(oldPeriod, newPeriod);\n', '    }\n', '\n', '    function setPricesInternal(int[] memory newPrices) internal {\n', '        for (uint i = 0; i < tickerSymbols.length; i++) {\n', '            prices[tickerSymbols[i]] = newPrices[i];\n', '        }\n', '    }\n', '\n', '    function getTickerSymbols() public view returns (bytes32[] memory) {\n', '        return tickerSymbols;\n', '    }\n', '\n', '    function getCurrentRoundId() public view returns (uint) {\n', '        if (numProposals == 0) {\n', '            return startingRoundId;\n', '        } else {\n', '            return proposals[numProposals].roundId;\n', '        }\n', '    }\n', '\n', '    function setTickerSymbols(bytes32[] memory newKeys, int[] memory newPrices) public managementOnly latestProposalConfirmed {\n', '        bytes32[] memory oldKeys = tickerSymbols;\n', '        tickerSymbols = newKeys;\n', '        setPricesInternal(newPrices);\n', '        // test that this function does not fail before setting\n', '        getWinner();\n', '        emit TickerSymbolsUpdated(oldKeys, newKeys, newPrices);\n', '    }\n', '\n', '    function addFeed(bytes32 key, address feedAddr) public managementOnly {\n', '        feedMap[key] = feedAddr;\n', '        emit FeedUpdated(key, feedAddr);\n', '    }\n', '\n', '    function getWinner() public view returns (int[] memory, uint) {\n', '        int256 maxPriceDiff = -100 * PRECISION;\n', '        uint winnerIndex = 0;\n', '        int[] memory pricesLocal = new int[](tickerSymbols.length);\n', '        for (uint i = 0; i < tickerSymbols.length; i++) {\n', '            bytes32 key = tickerSymbols[i];\n', '            int priceBefore = prices[key];\n', '            address feedAddr = feedMap[key];\n', "            require(feedAddr != address(0), 'Must set feed for all ticker symbols');\n", '            AggregatorV3Interface chainlink = AggregatorV3Interface(feedAddr);\n', '            (,int256 priceNow,,,) = chainlink.latestRoundData();\n', '            pricesLocal[i] = priceNow;\n', '            int256 priceDiff = ((priceNow - priceBefore) * PRECISION) / priceBefore;\n', '            if (priceDiff > maxPriceDiff) {\n', '                maxPriceDiff = priceDiff;\n', '                // add one to index to account for 1 based indexing on Trollbox contract\n', '                winnerIndex = i + 1;\n', '            }\n', '        }\n', '        return (pricesLocal, winnerIndex);\n', '    }\n', '\n', '    function proposeWinner() public latestProposalConfirmed {\n', '        uint roundId = getCurrentRoundId() + 1;\n', "        require(trollbox.roundAlreadyResolved(tournamentId, roundId) == false, 'Round already resolve');\n", "        require(trollbox.getCurrentRoundId(tournamentId) > roundId + 1, 'Round not ready to resolve');\n", '        Proposal storage proposal = proposals[++numProposals];\n', '        proposal.id = numProposals;\n', '        proposal.time = block.timestamp;\n', '        proposal.roundId = roundId;\n', '        (int[] memory newPrices, uint winnerIndex) = getWinner();\n', '        setPricesInternal(newPrices);\n', '        proposal.winnerIndex = winnerIndex;\n', '        emit WinnerProposed(roundId, numProposals, proposal.winnerIndex, newPrices);\n', '    }\n', '\n', '    function challengeWinner(uint claimedWinner, bytes32 evidence) public {\n', '        token.transferFrom(msg.sender, address(this), challengeDeposit);\n', '        Proposal storage proposal = proposals[numProposals];\n', "        require(proposal.challenger == address(0), 'Proposal already challenged');\n", "        require(claimedWinner != proposal.winnerIndex, 'Must claim different winner than proposed winner');\n", "        require(block.timestamp - proposal.time < challengePeriodSeconds, 'Challenge period has passed');\n", '        proposal.challenger = msg.sender;\n', '        proposal.challengeWinnerIndex = claimedWinner;\n', '        proposal.challengeEvidence = evidence;\n', '        emit ChallengeMade(numProposals, msg.sender, claimedWinner, evidence);\n', '    }\n', '\n', '    function confirmWinnerUnchallenged() public {\n', '        Proposal memory proposal = proposals[numProposals];\n', "        require(proposal.challenger == address(0), 'Proposal has been challenged');\n", "        require(block.timestamp - proposal.time > challengePeriodSeconds, 'Challenge period has not passed');\n", '        confirmWinnerInternal();\n', '    }\n', '\n', '    function confirmWinnerChallenged(uint chosenWinnerIndex, int[] memory localPrices, bytes32 evidence) public managementOnly {\n', '        Proposal storage proposal = proposals[numProposals];\n', "        require(proposal.challenger != address(0), 'Proposal has not been challenged');\n", "        require(chosenWinnerIndex <= tickerSymbols.length, 'Winner index out of range');\n", "        require(chosenWinnerIndex > 0, 'Winner index must be positive');\n", "        require(localPrices.length == tickerSymbols.length, 'Must specify prices for all ticker symbols');\n", '\n', '        // set official winner\n', '        proposal.winnerIndex = chosenWinnerIndex;\n', '        proposal.confirmationEvidence = evidence;\n', '\n', '        // record prices\n', '        setPricesInternal(localPrices);\n', '\n', '        confirmWinnerInternal();\n', '\n', '        // if challenger failed, slash their deposit\n', '        if (chosenWinnerIndex != proposal.challengeWinnerIndex) {\n', '            token.transfer(address(0), challengeDeposit);\n', '            emit ChallengerSlashed(numProposals, proposal.challenger, challengeDeposit, evidence);\n', '        // else send it back to them\n', '        } else {\n', '            token.transfer(proposal.challenger, challengeDeposit);\n', '            emit ChallengerVindicated(numProposals, proposal.challenger, evidence);\n', '        }\n', '    }\n', '\n', '    function confirmWinnerInternal() internal {\n', '        Proposal storage proposal = proposals[numProposals];\n', "        require(proposal.id == numProposals, 'Invalid proposalId');\n", "        require(proposal.confirmed == false, 'Already confirmed proposal');\n", '        proposal.confirmed = true;\n', '        int[] memory pricesLocal = new int[](tickerSymbols.length);\n', '        for (uint i = 0; i < tickerSymbols.length; i++) {\n', '            pricesLocal[i] = prices[tickerSymbols[i]];\n', '        }\n', '        emit WinnerConfirmed(proposal.roundId, proposal.id, pricesLocal);\n', '        trollbox.resolveRound(tournamentId, proposal.roundId, proposal.winnerIndex);\n', '    }\n', '\n', '    // K3PR functions\n', '    function checkUpkeep(bytes calldata checkData) external view override returns (bool, bytes memory) {\n', '        Proposal storage currentProposal = proposals[numProposals];\n', "        // if it's confirmed, we may need to propose a new one\n", '        if (currentProposal.confirmed || numProposals == 0) {\n', '            uint roundId = getCurrentRoundId() + 1;\n', '            bool roundAlreadyResolved = trollbox.roundAlreadyResolved(tournamentId, roundId);\n', '            bool roundResolvable = trollbox.getCurrentRoundId(tournamentId) > roundId + 1;\n', '            return (!roundAlreadyResolved && roundResolvable, abi.encode(false));\n', '        // otherwise if there is no challenger\n', '        } else {\n', '            bool unchallenged = currentProposal.challenger == address(0);\n', '            bool pastChallengePeriod = block.timestamp - currentProposal.time > challengePeriodSeconds;\n', '            return (unchallenged && pastChallengePeriod, abi.encode(true));\n', '        }\n', '    }\n', '\n', '    function performUpkeep(bytes calldata performData) external override {\n', '        bool confirm = abi.decode(performData, (bool));\n', '        // confirm\n', '        if (confirm) {\n', '            confirmWinnerUnchallenged();\n', '        // propose\n', '        } else {\n', '            proposeWinner();\n', '        }\n', '    }\n', '}']