['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-01\n', '*/\n', '\n', '// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Managerable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Managerable is Ownable {\n', '\n', '    address private _managerAddress;\n', '    /**\n', '     * @dev modifier, Only manager can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyManager() {\n', '        require(_managerAddress == msg.sender,"Managerable: caller is not the Manager");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev set manager by owner. \n', '     *\n', '     */\n', '    function setManager(address managerAddress)\n', '    public\n', '    onlyOwner\n', '    {\n', '        _managerAddress = managerAddress;\n', '    }\n', '    /**\n', '     * @dev get manager address. \n', '     *\n', '     */\n', '    function getManager()public view returns (address) {\n', '        return _managerAddress;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\whiteList.sol\n', '\n', 'pragma solidity >=0.5.16;\n', '/**\n', ' * SPDX-License-Identifier: GPL-3.0-or-later\n', ' * FinNexus\n', ' * Copyright (C) 2020 FinNexus Options Protocol\n', ' */\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint32.\n', '     */\n', 'library whiteListUint32 {\n', '    /**\n', '     * @dev add uint32 into white list.\n', '     * @param whiteList the storage whiteList.\n', '     * @param temp input value\n', '     */\n', '\n', '    function addWhiteListUint32(uint32[] storage whiteList,uint32 temp) internal{\n', '        if (!isEligibleUint32(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    /**\n', '     * @dev remove uint32 from whitelist.\n', '     */\n', '    function removeWhiteListUint32(uint32[] storage whiteList,uint32 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint32(uint32[] memory whiteList,uint32 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible uint256.\n', '     */\n', 'library whiteListUint256 {\n', '    // add whiteList\n', '    function addWhiteListUint256(uint256[] storage whiteList,uint256 temp) internal{\n', '        if (!isEligibleUint256(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListUint256(uint256[] storage whiteList,uint256 temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexUint256(uint256[] memory whiteList,uint256 temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '    /**\n', '     * @dev Implementation of a whitelist which filters a eligible address.\n', '     */\n', 'library whiteListAddress {\n', '    // add whiteList\n', '    function addWhiteListAddress(address[] storage whiteList,address temp) internal{\n', '        if (!isEligibleAddress(whiteList,temp)){\n', '            whiteList.push(temp);\n', '        }\n', '    }\n', '    function removeWhiteListAddress(address[] storage whiteList,address temp)internal returns (bool) {\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        if (i<len){\n', '            if (i!=len-1) {\n', '                whiteList[i] = whiteList[len-1];\n', '            }\n', '            whiteList.length--;\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '    function isEligibleAddress(address[] memory whiteList,address temp) internal pure returns (bool){\n', '        uint256 len = whiteList.length;\n', '        for (uint256 i=0;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                return true;\n', '        }\n', '        return false;\n', '    }\n', '    function _getEligibleIndexAddress(address[] memory whiteList,address temp) internal pure returns (uint256){\n', '        uint256 len = whiteList.length;\n', '        uint256 i=0;\n', '        for (;i<len;i++){\n', '            if (whiteList[i] == temp)\n', '                break;\n', '        }\n', '        return i;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Operator.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * each operator can be granted exclusive access to specific functions.\n', ' *\n', ' */\n', 'contract Operator is Ownable {\n', '    mapping(uint256=>address) private _operators;\n', '    /**\n', '     * @dev modifier, Only indexed operator can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyOperator(uint256 index) {\n', '        require(_operators[index] == msg.sender,"Operator: caller is not the eligible Operator");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev modify indexed operator by owner. \n', '     *\n', '     */\n', '    function setOperator(uint256 index,address addAddress)public onlyOwner{\n', '        _operators[index] = addAddress;\n', '    }\n', '    function getOperator(uint256 index)public view returns (address) {\n', '        return _operators[index];\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Halt.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract Halt is Ownable {\n', '    \n', '    bool private halted = false; \n', '    \n', '    modifier notHalted() {\n', '        require(!halted,"This contract is halted");\n', '        _;\n', '    }\n', '\n', '    modifier isHalted() {\n', '        require(halted,"This contract is not halted");\n', '        _;\n', '    }\n', '    \n', '    /// @notice function Emergency situation that requires \n', '    /// @notice contribution period to stop or not.\n', '    function setHalt(bool halt) \n', '        public \n', '        onlyOwner\n', '    {\n', '        halted = halt;\n', '    }\n', '}\n', '\n', '// File: contracts\\Airdrop\\AirdropVaultData.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', 'contract AirDropVaultData is Operator,Halt {\n', '\n', '    \n', '    address public optionColPool;//the option manager address\n', '    address public minePool;    //the fixed minePool address\n', '    address public cfnxToken;   //the cfnx toekn address\n', '    address public fnxToken;    //fnx token address\n', '    address public ftpbToken;   //ftpb toekn address\n', '    \n', '    uint256 public totalWhiteListAirdrop; //total ammout for white list seting accounting\n', '    uint256 public totalWhiteListClaimed; //total claimed amount by the user in white list\n', '    uint256 public totalFreeClaimed;      //total claimed amount by the user in curve or hegic\n', '    uint256 public maxWhiteListFnxAirDrop;//the max claimable limit for white list user\n', '    uint256 public maxFreeFnxAirDrop;     // the max claimable limit for hegic or curve user\n', '    \n', '    uint256 public claimBeginTime;  //airdrop start time\n', '    uint256 public claimEndTime;    //airdrop finish time\n', '    uint256 public fnxPerFreeClaimUser; //the fnx amount for each person in curve or hegic\n', '\n', '\n', '    mapping (address => uint256) public userWhiteList; //the white list user info\n', '    mapping (address => uint256)  public tkBalanceRequire; //target airdrop token list address=>min balance require\n', '    address[] public tokenWhiteList; //the token address for free air drop\n', '    \n', '    //the user which is claimed already for different token\n', '    mapping (address=>mapping(address => bool)) public freeClaimedUserList; //the users list for the user claimed already from curve or hegic\n', '    \n', '    uint256 public sushiTotalMine;  //sushi total mine amount for accounting\n', '    uint256 public sushiMineStartTime; //suhi mine start time\n', '    uint256 public sushimineInterval = 30 days; //sushi mine reward interval time\n', '    mapping (address => uint256) public suhiUserMineBalance; //the user balance for subcidy for sushi mine\n', '    mapping (uint256=>mapping(address => bool)) sushiMineRecord;//the user list which user mine is set already\n', '    \n', '    event AddWhiteList(address indexed claimer, uint256 indexed amount);\n', '    event WhiteListClaim(address indexed claimer, uint256 indexed amount,uint256 indexed ftpbnum);\n', '    event UserFreeClaim(address indexed claimer, uint256 indexed amount,uint256 indexed ftpbnum);\n', '    \n', '    event AddSushiList(address indexed claimer, uint256 indexed amount);\n', '    event SushiMineClaim(address indexed claimer, uint256 indexed amount);\n', '}\n', '\n', '// File: contracts\\modules\\SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts\\ERC20\\IERC20.sol\n', '\n', 'pragma solidity =0.5.16;\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts\\Airdrop\\AirdropVault.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', '\n', 'interface IOptionMgrPoxy {\n', '    function addCollateral(address collateral,uint256 amount) external payable;\n', '}\n', '\n', 'interface IMinePool {\n', '    function lockAirDrop(address user,uint256 ftp_b_amount) external;\n', '}\n', '\n', 'interface ITargetToken {\n', '     function balanceOf(address account) external view returns (uint256);\n', '}\n', '\n', '\n', 'contract AirDropVault is AirDropVaultData {\n', '    using SafeMath for uint256;\n', '    \n', '    modifier airdropinited() {\n', '        require(optionColPool!=address(0),"collateral pool address should be set");\n', '        require(minePool!=address(0),"mine pool address should be set");\n', '        require(fnxToken!=address(0),"fnx token address should be set");\n', '        require(ftpbToken!=address(0),"ftpb token address should be set");\n', '        require(claimBeginTime>0,"airdrop claim begin time should be set");\n', '        require(claimEndTime>0,"airdrop claim end time should be set");\n', '        require(fnxPerFreeClaimUser>0,"the air drop number for each free claimer should be set");\n', '        require(maxWhiteListFnxAirDrop>0,"the max fnx number for whitelist air drop should be set");\n', '        require(maxFreeFnxAirDrop>0,"the max fnx number for free air drop should be set");\n', '        _;\n', '    }\n', '    \n', '    modifier suhsimineinited() {\n', '        require(cfnxToken!=address(0),"cfnc token address should be set");\n', '        require(sushiMineStartTime>0,"sushi mine start time should be set");\n', '        require(sushimineInterval>0,"sushi mine interval should be set");\n', '        _;\n', '    }    \n', '\n', '    function initialize() onlyOwner public {}\n', '    \n', '    function update() onlyOwner public{ \n', '\n', '        \n', '        userWhiteList[0x6fC1B3e4aEB54772D0CB96F5aCb4c60E70c29aB9] = 1000 ether;//https://etherscan.io/tx/0xec6021191e5e3f5d3af2494ee265e68bfa5f721dca9c82fbc96c2d666477d097\n', '        userWhiteList[0x0c18cc3A37E6969Df5CCe67D1579d645115b4861] = 1000 ether;//https://etherscan.io/tx/0x9c0ff821b4cca5ef08a61f33e77d9e595a814369ceb4ddf76e8b20773f659dfa\n', '        userWhiteList[0x4a96B3C9997E06eD17CE4948586F87D7d14D8d7e] = 1000 ether;//https://etherscan.io/tx/0x51758bf71230f0b5ae66a485f4fd4e0f1fce191c0e8d4d27a25d1c713e419ea8\n', '        \n', '\n', '        uint256 j;\n', '        //recover it to false\n', '        for(j=0;j<tokenWhiteList.length;j++) {\n', '            freeClaimedUserList[tokenWhiteList[j]][0xAbd252CfbaE138043e4fB5E667B489710964D572] = false;//https://etherscan.io/tx/0xe67383074eefe031fcdca9db63c7d582b410275bfabf1c4834aa1b01e764de28\n', '            freeClaimedUserList[tokenWhiteList[j]][0x2D8e5b082dFA5cD2A8EcFA5A0a93956cAD3dF91A] = false;//https://etherscan.io/tx/0x91aa4d999df2d6782bb884973c11f51fc7bdc423e75e2cfed51bde04f8885dcf\n', '        }\n', '        \n', '        uint256  MAX_UINT = (2**256 - 1);\n', '        IERC20(ftpbToken).approve(minePool,MAX_UINT);\n', '        \n', '    }\n', '    \n', '    \n', '    /**\n', '     * @dev init function,init air drop\n', '     * @param _optionColPool  the option collateral contract address\n', '     * @param _fnxToken  the fnx token address\n', '     * @param _ftpbToken the ftpb token address\n', '     * @param _claimBeginTime the start time for airdrop\n', '     * @param _claimEndTime  the end time for airdrop\n', '     * @param _fnxPerFreeClaimUser the fnx amo for each person in airdrop\n', '     * @param _maxFreeFnxAirDrop the max fnx amount for free claimer from hegic,curve\n', '     * @param _maxWhiteListFnxAirDrop the mx fnx number in whitelist ways\n', '     */\n', '    function initAirdrop( address _optionColPool,\n', '                                address _minePool,\n', '                                address _fnxToken,\n', '                                address _ftpbToken,\n', '                                uint256 _claimBeginTime,\n', '                                uint256 _claimEndTime,\n', '                                uint256 _fnxPerFreeClaimUser,\n', '                                uint256 _maxFreeFnxAirDrop,\n', '                                uint256 _maxWhiteListFnxAirDrop) public onlyOwner {\n', '        if(_optionColPool!=address(0))                            \n', '            optionColPool = _optionColPool;\n', '        if(_minePool!=address(0))    \n', '            minePool = _minePool;\n', '        if(_fnxToken!=address(0))    \n', '            fnxToken = _fnxToken;  \n', '        if(_ftpbToken!=address(0))    \n', '            ftpbToken = _ftpbToken;\n', '        \n', '        if(_claimBeginTime>0)    \n', '            claimBeginTime = _claimBeginTime;\n', '         \n', '        if(_claimEndTime>0)    \n', '            claimEndTime = _claimEndTime;\n', '            \n', '        if(_fnxPerFreeClaimUser>0)    \n', '            fnxPerFreeClaimUser = _fnxPerFreeClaimUser;\n', '\n', '        if(_maxFreeFnxAirDrop>0)\n', '            maxFreeFnxAirDrop = _maxFreeFnxAirDrop;\n', '            \n', '        if(_maxWhiteListFnxAirDrop>0)    \n', '            maxWhiteListFnxAirDrop = _maxWhiteListFnxAirDrop;\n', '    }\n', '    \n', '    /**\n', '     * @dev init function,init sushi mine\n', '     * @param _cfnxToken  the mined reward token\n', '     * @param _sushiMineStartTime mine start time\n', '     * @param _sushimineInterval the sushi mine time interval\n', '     */\n', '    function initSushiMine(address _cfnxToken,uint256 _sushiMineStartTime,uint256 _sushimineInterval) public onlyOwner{\n', '        if(_cfnxToken!=address(0))\n', '            cfnxToken = _cfnxToken;\n', '        if(_sushiMineStartTime>0)    \n', '            sushiMineStartTime = _sushiMineStartTime;\n', '        if(_sushimineInterval>0)    \n', '            sushimineInterval = _sushimineInterval;\n', '    }\n', '    \n', '\n', '    /**\n', '     * @dev getting back the left mine token\n', '     * @param _reciever the reciever for getting back mine token\n', '     */\n', '    function getbackLeftFnx(address _reciever)  public onlyOwner {\n', '        uint256 bal =  IERC20(fnxToken).balanceOf(address(this));\n', '        if(bal>0)\n', '            IERC20(fnxToken).transfer(_reciever,bal);\n', '        \n', '        bal = IERC20(ftpbToken).balanceOf(address(this));\n', '        if(bal>0)\n', '            IERC20(ftpbToken).transfer(_reciever,bal);\n', '\n', '        bal = IERC20(cfnxToken).balanceOf(address(this));\n', '        if(bal>0)\n', '            IERC20(cfnxToken).transfer(_reciever,bal);            \n', '            \n', '    }  \n', '    \n', '    /**\n', '     * reset token setting in case of setting is wrong\n', '     */\n', '    function resetTokenList()  public onlyOwner {\n', '        uint256 i;\n', '        for(i=0;i<tokenWhiteList.length;i++) {\n', '            delete tkBalanceRequire[tokenWhiteList[i]];\n', '        }\n', '        \n', '        tokenWhiteList.length = 0;\n', '    }     \n', '\n', '    /**\n', "     * @dev Retrieve user's locked balance. \n", "     * @param _account user's account.\n", '     */ \n', '    function balanceOfWhitListUser(address _account) private view returns (uint256) {\n', '        \n', '        if(totalWhiteListClaimed < maxWhiteListFnxAirDrop) {\n', '            uint256 amount = userWhiteList[_account];\n', '            uint256 total = totalWhiteListClaimed.add(amount);\n', '            \n', '            if (total>maxWhiteListFnxAirDrop){\n', '                amount = maxWhiteListFnxAirDrop.sub(totalWhiteListClaimed);\n', '            }\n', '            \n', '            return amount;\n', '        }\n', '        \n', '        return 0;\n', '       \n', '    }\n', '\n', '   /**\n', '   * @dev setting function.set airdrop users address and balance in whitelist ways\n', '   * @param _accounts   the user address.tested support 200 address in one tx\n', "   * @param _fnxnumbers the user's airdrop fnx number\n", '   */   \n', '    function setWhiteList(address[] memory _accounts,uint256[] memory _fnxnumbers) public onlyOperator(1) {\n', '        require(_accounts.length==_fnxnumbers.length,"the input array length is not equal");\n', '        uint256 i = 0;\n', '        for(;i<_accounts.length;i++) {\n', '            if(userWhiteList[_accounts[i]]==0) {\n', '               require(_fnxnumbers[i]>0,"fnx number must be over 0!");\n', '               //just for tatics    \n', '               totalWhiteListAirdrop = totalWhiteListAirdrop.add(_fnxnumbers[i]);\n', '               userWhiteList[_accounts[i]] = _fnxnumbers[i];\n', '               emit AddWhiteList(_accounts[i],_fnxnumbers[i]);\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '    * @dev claim the airdrop for user in whitelist ways\n', '    */\n', '    function whitelistClaim() internal /*airdropinited*/ {\n', '        // require(now >= claimBeginTime,"claim not begin");\n', '        // require(now < claimEndTime,"claim finished");\n', '\n', '        if(totalWhiteListClaimed < maxWhiteListFnxAirDrop) {\n', '          \n', '           if(userWhiteList[msg.sender]>0) {\n', '               \n', '                uint256 amount = userWhiteList[msg.sender];\n', '                userWhiteList[msg.sender] = 0;\n', '                uint256 total = totalWhiteListClaimed.add(amount);\n', '                if (total>maxWhiteListFnxAirDrop){\n', '                    amount = maxWhiteListFnxAirDrop.sub(totalWhiteListClaimed);\n', '                }\n', '                totalWhiteListClaimed = totalWhiteListClaimed.add(amount);\n', '                \n', '                // IERC20(fnxToken).approve(optionColPool,amount);\n', '                // uint256 prefptb = IERC20(ftpbToken).balanceOf(address(this));\n', '                // IOptionMgrPoxy(optionColPool).addCollateral(fnxToken,amount);\n', '                // uint256 afterftpb = IERC20(ftpbToken).balanceOf(address(this));\n', '                // uint256 ftpbnum = afterftpb.sub(prefptb);\n', '                // IERC20(ftpbToken).approve(minePool,ftpbnum);\n', '                // IMinePool(minePool).lockAirDrop(msg.sender,ftpbnum);\n', '                // emit WhiteListClaim(msg.sender,amount,ftpbnum);\n', '                \n', '                //1000 fnx = 94 fpt\n', '                uint256 ftpbnum = 100 ether;\n', '               // IERC20(ftpbToken).approve(minePool,ftpbnum);\n', '                IMinePool(minePool).lockAirDrop(msg.sender,ftpbnum);\n', '                emit UserFreeClaim(msg.sender,amount,ftpbnum);\n', '            }\n', '         }\n', '    }\n', '    \n', '   /**\n', '   * @dev setting function.set target token and required balance for airdrop token\n', '   * @param _tokens   the tokens address.tested support 200 address in one tx\n', '   * @param _minBalForFreeClaim  the required minimal balance for the claimer\n', '   */    \n', '    function setTokenList(address[] memory _tokens,uint256[] memory _minBalForFreeClaim) public onlyOwner {\n', '        uint256 i = 0;\n', '        require(_tokens.length==_minBalForFreeClaim.length,"array length is not match");\n', '        for (i=0;i<_tokens.length;i++) {\n', '            if(tkBalanceRequire[_tokens[i]]==0) {\n', '                require(_minBalForFreeClaim[i]>0,"the min balance require must be over 0!");\n', '                tkBalanceRequire[_tokens[i]] = _minBalForFreeClaim[i];\n', '                tokenWhiteList.push(_tokens[i]);\n', '            }\n', '        }\n', '    }\n', '    \n', '   /**\n', '   * @dev getting function.get user claimable airdrop balance for curve.hegic user\n', '   * @param _targetToken the token address for getting balance from it for user \n', '   * @param _account user address\n', '   */     \n', '    function balanceOfFreeClaimAirDrop(address _targetToken,address _account) public view airdropinited returns(uint256){\n', '        require(tkBalanceRequire[_targetToken]>0,"the target token is not set active");\n', '        require(now >= claimBeginTime,"claim not begin");\n', '        require(now < claimEndTime,"claim finished");\n', '        if(!freeClaimedUserList[_targetToken][_account]) {\n', '            if(totalFreeClaimed < maxFreeFnxAirDrop) {\n', '                uint256 bal = ITargetToken(_targetToken).balanceOf(_account);\n', '                if(bal>=tkBalanceRequire[_targetToken]) {\n', '                    uint256 amount = fnxPerFreeClaimUser;\n', '                    uint256 total = totalFreeClaimed.add(amount);\n', '                    if(total>maxFreeFnxAirDrop) {\n', '                        amount = maxFreeFnxAirDrop.sub(totalFreeClaimed);\n', '                    }\n', '                    return amount;\n', '                }\n', '            }\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '   /**\n', '   * @dev user claim airdrop for curve.hegic user\n', '   * @param _targetToken the token address for getting balance from it for user \n', '   */ \n', '    function freeClaim(address _targetToken) internal /*airdropinited*/ {\n', '        // require(tkBalanceRequire[_targetToken]>0,"the target token is not set active");\n', '        // require(now >= claimBeginTime,"claim not begin");\n', '        // require(now < claimEndTime,"claim finished");\n', '        \n', '        //the user not claimed yet\n', '        if(!freeClaimedUserList[_targetToken][msg.sender]) {\n', '            //total claimed fnx not over the max free claim limit\n', '           if(totalFreeClaimed < maxFreeFnxAirDrop) {\n', '                //get user balance in target token\n', '                uint256 bal = ITargetToken(_targetToken).balanceOf(msg.sender);\n', '                //over the required balance number\n', '                if(bal >= tkBalanceRequire[_targetToken]){\n', '                    \n', '                    //set user claimed already\n', '                    freeClaimedUserList[_targetToken][msg.sender] = true;\n', '\n', '                    uint256 amount = fnxPerFreeClaimUser; \n', '                    uint256 total = totalFreeClaimed.add(amount);\n', '                    if(total>maxFreeFnxAirDrop) {\n', '                        amount = maxFreeFnxAirDrop.sub(totalFreeClaimed);\n', '                    }\n', '                    totalFreeClaimed = totalFreeClaimed.add(amount);\n', '                    \n', '                  //  IERC20(fnxToken).approve(optionColPool,amount);\n', '                   // uint256 prefptb = IERC20(ftpbToken).balanceOf(address(this));\n', '                   // IOptionMgrPoxy(optionColPool).addCollateral(fnxToken,amount);\n', '                   // uint256 afterftpb = IERC20(ftpbToken).balanceOf(address(this));\n', '                  //  uint256 ftpbnum = afterftpb.sub(prefptb);\n', '                  //  IERC20(ftpbToken).approve(minePool,ftpbnum);\n', '                  //  IMinePool(minePool).lockAirDrop(msg.sender,ftpbnum);\n', '                  //  emit UserFreeClaim(msg.sender,amount,ftpbnum);\n', '                  //1000 fnx = 94 fpt\n', '                  \n', '                  uint256 ftpbnum = 100 ether;\n', '                 // IERC20(ftpbToken).approve(minePool,ftpbnum);\n', '                  IMinePool(minePool).lockAirDrop(msg.sender,ftpbnum);\n', '                  emit UserFreeClaim(_targetToken,amount,ftpbnum);\n', '                }\n', '            }\n', '        }\n', '    }   \n', '\n', '        \n', '   /**\n', '   * @dev setting function.set user the subcidy balance for sushi fnx-eth miners\n', '   * @param _accounts   the user address.tested support 200 address in one tx\n', "   * @param _fnxnumbers the user's mined fnx number\n", '   */    \n', '   function setSushiMineList(address[] memory _accounts,uint256[] memory _fnxnumbers) public onlyOperator(2) {\n', '        require(_accounts.length==_fnxnumbers.length,"the input array length is not equal");\n', '        uint256 i = 0;\n', '        uint256 idx = (now - sushiMineStartTime)/sushimineInterval;\n', '        for(;i<_accounts.length;i++) {\n', '            if(!sushiMineRecord[idx][_accounts[i]]) {\n', '                require(_fnxnumbers[i] > 0, "fnx number must be over 0!");\n', '                \n', '                sushiMineRecord[idx][_accounts[i]] = true;\n', '                suhiUserMineBalance[_accounts[i]] = suhiUserMineBalance[_accounts[i]].add(_fnxnumbers[i]);\n', '                sushiTotalMine = sushiTotalMine.add(_fnxnumbers[i]);\n', '                \n', '                emit AddSushiList(_accounts[i],_fnxnumbers[i]);\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev  user get fnx subsidy for sushi fnx-eth mine pool\n', '     */\n', '    function sushiMineClaim() public suhsimineinited {\n', '        require(suhiUserMineBalance[msg.sender]>0,"sushi mine balance is not enough");\n', '        \n', '        uint256 amount = suhiUserMineBalance[msg.sender];\n', '        suhiUserMineBalance[msg.sender] = 0;\n', '        \n', '        uint256 precfnx = IERC20(cfnxToken).balanceOf(address(this));\n', '        IERC20(cfnxToken).transfer(msg.sender,amount);\n', '        uint256 aftercfnc = IERC20(cfnxToken).balanceOf(address(this));\n', '        uint256 cfncnum = precfnx.sub(aftercfnc);\n', '        require(cfncnum==amount,"transfer balance is wrong");\n', '        emit SushiMineClaim(msg.sender,amount);\n', '    }\n', '    \n', '    /**\n', '     * @dev getting function.retrieve all of the balance for airdrop include whitelist and free claimer\n', '     * @param _account  the user \n', '     */    \n', '    function balanceOfAirDrop(address _account) public view returns(uint256){\n', '        uint256 whitelsBal = balanceOfWhitListUser(_account);\n', '        uint256 i = 0;\n', '        uint256 freeClaimBal = 0;\n', '        for(i=0;i<tokenWhiteList.length;i++) {\n', '           freeClaimBal = freeClaimBal.add(balanceOfFreeClaimAirDrop(tokenWhiteList[i],_account));\n', '        }\n', '        \n', '        return whitelsBal.add(freeClaimBal);\n', '    }\n', '    \n', '    /**\n', '     * @dev claim all of the airdrop include whitelist and free claimer\n', '     */\n', '    function claimAirdrop() public airdropinited{\n', '        require(now >= claimBeginTime,"claim not begin");\n', '        require(now < claimEndTime,"claim finished");        \n', '        whitelistClaim();\n', '        \n', '        uint256 i;\n', '        address targetToken;\n', '         for(i=0;i<tokenWhiteList.length;i++) {\n', '            targetToken = tokenWhiteList[i]; \n', '            if(tkBalanceRequire[targetToken]>0) {\n', '                freeClaim(targetToken);\n', '            }\n', '         }\n', '    }\n', '      \n', '}']