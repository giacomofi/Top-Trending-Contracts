['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-10\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '// -------------------\n', '// Router Version: 2.0\n', '// -------------------\n', 'pragma solidity 0.8.3;\n', '\n', '// ERC20 Interface\n', 'interface iERC20 {\n', '    function balanceOf(address) external view returns (uint256);\n', '    function burn(uint) external;\n', '}\n', '// RUNE Interface\n', 'interface iRUNE {\n', '    function transferTo(address, uint) external returns (bool);\n', '}\n', '// ROUTER Interface\n', 'interface iROUTER {\n', '    function depositWithExpiry(address, address, uint, string calldata, uint) external;\n', '}\n', '\n', '// THORChain_Router is managed by THORChain Vaults\n', 'contract THORChain_Router {\n', '    address public RUNE;\n', '\n', '    struct Coin {\n', '        address asset;\n', '        uint amount;\n', '    }\n', '\n', '    // Vault allowance for each asset\n', '    mapping(address => mapping(address => uint)) public vaultAllowance;\n', '\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '    uint256 private _status;\n', '\n', '    // Emitted for all deposits, the memo distinguishes for swap, add, remove, donate etc\n', '    event Deposit(address indexed to, address indexed asset, uint amount, string memo);\n', '\n', '    // Emitted for all outgoing transfers, the vault dictates who sent it, memo used to track.\n', '    event TransferOut(address indexed vault, address indexed to, address asset, uint amount, string memo);\n', '\n', '    // Changes the spend allowance between vaults\n', '    event TransferAllowance(address indexed oldVault, address indexed newVault, address asset, uint amount, string memo);\n', '\n', '    // Specifically used to batch send the entire vault assets\n', '    event VaultTransfer(address indexed oldVault, address indexed newVault, Coin[] coins, string memo);\n', '\n', '    modifier nonReentrant() {\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '        _status = _ENTERED;\n', '        _;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    constructor(address rune) {\n', '        RUNE = rune;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    // Deposit with Expiry (preferred)\n', '    function depositWithExpiry(address payable vault, address asset, uint amount, string memory memo, uint expiration) external payable {\n', '        require(block.timestamp < expiration, "THORChain_Router: expired");\n', '        deposit(vault, asset, amount, memo);\n', '    }\n', '\n', '    // Deposit an asset with a memo. ETH is forwarded, ERC-20 stays in ROUTER\n', '    function deposit(address payable vault, address asset, uint amount, string memory memo) public payable nonReentrant{\n', '        uint safeAmount;\n', '        if(asset == address(0)){\n', '            safeAmount = msg.value;\n', '            (bool success,) = vault.call{value:safeAmount}("");\n', '            require(success);\n', '        } else if(asset == RUNE) {\n', '            safeAmount = amount;\n', '            iRUNE(RUNE).transferTo(address(this), amount);\n', '            iERC20(RUNE).burn(amount);\n', '        } else {\n', '            safeAmount = safeTransferFrom(asset, amount); // Transfer asset\n', '            vaultAllowance[vault][asset] += safeAmount; // Credit to chosen vault\n', '        }\n', '        emit Deposit(vault, asset, safeAmount, memo);\n', '    }\n', '\n', '    //############################## ALLOWANCE TRANSFERS ##############################\n', '\n', '    // Use for "moving" assets between vaults (asgard<>ygg), as well "churning" to a new Asgard\n', '    function transferAllowance(address router, address newVault, address asset, uint amount, string memory memo) external {\n', '        if (router == address(this)){\n', '            _adjustAllowances(newVault, asset, amount);\n', '            emit TransferAllowance(msg.sender, newVault, asset, amount, memo);\n', '        } else {\n', '            _routerDeposit(router, newVault, asset, amount, memo);\n', '        }\n', '    }\n', '\n', '    //############################## ASSET TRANSFERS ##############################\n', '\n', '    // Any vault calls to transfer any asset to any recipient.\n', '    function transferOut(address payable to, address asset, uint amount, string memory memo) public payable nonReentrant {\n', '        uint safeAmount; bool success;\n', '        if(asset == address(0)){\n', '            safeAmount = msg.value;\n', '            (success,) = to.call{value:msg.value}(""); // Send ETH\n', '        } else {\n', '            vaultAllowance[msg.sender][asset] -= amount; // Reduce allowance\n', '            (success,) = asset.call(abi.encodeWithSignature("transfer(address,uint256)" , to, amount));\n', '            safeAmount = amount;\n', '        }\n', '        require(success);\n', '        emit TransferOut(msg.sender, to, asset, safeAmount, memo);\n', '    }\n', '\n', '    // Batch Transfer\n', '    function batchTransferOut(address[] memory recipients, Coin[] memory coins, string[] memory memos) external payable {\n', '        require((recipients.length == coins.length) && (coins.length == memos.length));\n', '        for(uint i = 0; i < coins.length; i++){\n', '            transferOut(payable(recipients[i]), coins[i].asset, coins[i].amount, memos[i]);\n', '        }\n', '    }\n', '\n', '    //############################## VAULT MANAGEMENT ##############################\n', '\n', '    // A vault can call to "return" all assets to an asgard, including ETH. \n', '    function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n', '        if (router == address(this)){\n', '            for(uint i = 0; i < coins.length; i++){\n', '                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n', '            }\n', '            emit VaultTransfer(msg.sender, asgard, coins, memo); // Does not include ETH.           \n', '        } else {\n', '            for(uint i = 0; i < coins.length; i++){\n', '                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n', '            }\n', '        }\n', '        (bool success,) = asgard.call{value:msg.value}(""); //ETH amount needs to be parsed from tx.\n', '        require(success);\n', '    }\n', '\n', '    //############################## HELPERS ##############################\n', '\n', '    // Safe transferFrom in case asset charges transfer fees\n', '    function safeTransferFrom(address _asset, uint _amount) internal returns(uint amount) {\n', '        uint _startBal = iERC20(_asset).balanceOf(address(this));\n', '        (bool success,) = _asset.call(abi.encodeWithSignature("transferFrom(address,address,uint256)", msg.sender, address(this), _amount));\n', '        require(success);\n', '        return (iERC20(_asset).balanceOf(address(this)) - _startBal);\n', '    }\n', '\n', '    // Decrements and Increments Allowances between two vaults\n', '    function _adjustAllowances(address _newVault, address _asset, uint _amount) internal {\n', '        vaultAllowance[msg.sender][_asset] -= _amount;\n', '        vaultAllowance[_newVault][_asset] += _amount;\n', '    }\n', '\n', '    // Adjust allowance and forwards funds to new router, credits allowance to desired vault\n', '    function _routerDeposit(address _router, address _vault, address _asset, uint _amount, string memory _memo) internal {\n', '        vaultAllowance[msg.sender][_asset] -= _amount;\n', '        (bool success,) = _asset.call(abi.encodeWithSignature("approve(address,uint256)", _router, _amount)); // Approve to transfer\n', '        require(success);\n', '        iROUTER(_router).depositWithExpiry(_vault, _asset, _amount, _memo, type(uint).max); // Transfer by depositing\n', '    }\n', '}']