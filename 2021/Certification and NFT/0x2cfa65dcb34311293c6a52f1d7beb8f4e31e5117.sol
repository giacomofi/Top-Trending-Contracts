['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-11\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', 'contract Context {\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Contract for  allowing  removal of global supply of locked mintable erc20 tokens by converted from DAI using uniswap v2 router contract\n', ' * @author Request Network\n', ' */ \n', ' \n', ' \n', 'interface IUniswapV2Router02 {\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address _owner) external view returns (uint balance);\n', '    function approve(address _spender, uint _value) external returns (bool success);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '}\n', '\n', '/*interface*/ contract IBurnableErc20 is IERC20 {\n', '    function burn(uint value) external;\n', '}\n', '\n', '\n', '/** @title DaiBasedREQBurner\n', ' * @notice A contract to burn REQ tokens from DAI.\n', ' * @dev All DAIs sent to this contract can only be exchanged for REQs that are then burnt, using Uniswap.\n', ' */\n', 'contract DaiBasedREQBurner is Ownable {\n', '\n', '    address constant DAI_ADDRESS = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '    address constant REQ_ADDRESS = 0x8f8221aFbB33998d8584A2B05749bA73c37a938a;\n', '\n', '    address constant LOCKED_TOKEN_ADDRESS = DAI_ADDRESS;\n', '    address constant BURNABLE_TOKEN_ADDRESS = REQ_ADDRESS;\n', '    // swap router used to convert LOCKED into BURNABLE tokens\n', '    IUniswapV2Router02 public swapRouter;\n', '\n', '    /**\n', '     * @notice Constructor of the DAI based REQ burner\n', '     * @param _swapRouterAddress address of the uniswap token router (which follow the same method signature ).\n', '     */\n', '    constructor(address _swapRouterAddress) public {\n', '        require(_swapRouterAddress != address(0), "The swap router address should not be 0");\n', '        swapRouter = IUniswapV2Router02(_swapRouterAddress);\n', '    }\n', '\n', '    /// @dev gives the permission to uniswap to accept the swapping of the BURNABLE token \n', '    function approveRouterToSpend() public {\n', '        uint256 max = 2**256 - 1;\n', '        IERC20 dai = IERC20(LOCKED_TOKEN_ADDRESS);\n', '        dai.approve(address(swapRouter), max);\n', '    }\n', '\n', '\n', '    ///@dev the main function to be executed\n', '    ///@param _minReqBurnt  REQ token needed to be burned.\n', '    ///@param _deadline  maximum timestamp to accept the trade from the router\n', '    function burn(uint _minReqBurnt, uint256 _deadline)\n', '        external\n', '        returns(uint)\n', '    {\n', '        IERC20 dai = IERC20(LOCKED_TOKEN_ADDRESS);\n', '        IBurnableErc20 req = IBurnableErc20(BURNABLE_TOKEN_ADDRESS);\n', '        uint daiToConvert = dai.balanceOf(address(this));\n', '\n', '        if (_deadline == 0) {\n', '            _deadline = block.timestamp + 1000;\n', '        }\n', '\n', '        // 1 step swapping path (only works if there is a sufficient liquidity behind the router)\n', '        address[] memory path = new address[](2);\n', '        path[0] = LOCKED_TOKEN_ADDRESS;\n', '        path[1] = BURNABLE_TOKEN_ADDRESS;\n', '\n', '        // Do the swap and get the amount of REQ purchased\n', '        uint reqToBurn = swapRouter.swapExactTokensForTokens(\n', '          daiToConvert,\n', '          _minReqBurnt,\n', '          path,\n', '          address(this),\n', '          _deadline\n', '        )[1];\n', '\n', '        // Burn all the purchased REQ and return this amount\n', '        req.burn(reqToBurn);\n', '        return reqToBurn;\n', '    }\n', '}']