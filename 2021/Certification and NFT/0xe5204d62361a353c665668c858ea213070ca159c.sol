['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'import "Ownable.sol";\n', 'import "SafeERC20.sol";\n', 'import "SafeMath.sol";\n', 'import "Pausable.sol";\n', 'import "ZeroCopySink.sol";\n', 'import "ZeroCopySource.sol";\n', 'import "IERC721.sol";\n', 'import "IERC721Enumerable.sol";\n', 'import "IERC721Metadata.sol";\n', 'import "ReentrancyGuard.sol";\n', 'import "IPolyNFTLockProxy.sol";\n', '\n', 'contract PolyNFTWrapper is Ownable, Pausable, ReentrancyGuard {\n', '    using SafeMath for uint;\n', '    using SafeERC20 for IERC20;\n', '\n', '    uint public chainId;\n', '    address public feeCollector;\n', '    address public lockProxy;\n', '    \n', '    struct CallArgs {\n', '        bytes toAddress;\n', '        uint64 toChainId;\n', '    }\n', '\n', '    event PolyWrapperLock(address indexed fromAsset, address indexed sender, uint64 toChainId, address toAddress, uint256 tokenId, address feeToken, uint256 fee, uint id);\n', '    event PolyWrapperSpeedUp(address indexed feeToken, bytes indexed txHash, address indexed sender, uint256 efee);\n', '\n', '    constructor(address _owner, uint _chainId) public {\n', '        require(_chainId != 0, "!legal");\n', '        transferOwnership(_owner);\n', '        chainId = _chainId;\n', '    }\n', '    \n', '    function setFeeCollector(address collector) external onlyOwner {\n', '        require(collector != address(0), "emtpy address");\n', '        feeCollector = collector;\n', '    }\n', '\n', '    function setLockProxy(address _lockProxy) external onlyOwner {\n', '        require(_lockProxy != address(0));\n', '        lockProxy = _lockProxy;\n', '        require(IPolyNFTLockProxy(lockProxy).managerProxyContract() != address(0), "not lock proxy");\n', '    }\n', '\n', '    function pause() external onlyOwner {\n', '        _pause();\n', '    }\n', '\n', '    function unpause() external onlyOwner {\n', '        _unpause();\n', '    }\n', '\n', '    function extractFee(address token) external {\n', '        require(msg.sender == feeCollector, "!feeCollector");\n', '        if (token == address(0)) {\n', '            payable(msg.sender).transfer(address(this).balance);\n', '        } else {\n', '            IERC20(token).safeTransfer(feeCollector, IERC20(token).balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    function lock(address fromAsset, uint64 toChainId, address toAddress, uint256 tokenId, address feeToken, uint256 fee, uint id) external payable nonReentrant whenNotPaused {    \n', '        require(toChainId != chainId && toChainId != 0, "!toChainId");\n', '\n', '        _pull(feeToken, fee);\n', '        _push(fromAsset, toChainId, toAddress, tokenId);\n', '        emit PolyWrapperLock(fromAsset, msg.sender, toChainId, toAddress, tokenId, feeToken, fee, id);\n', '    }\n', '\n', '    function speedUp(address feeToken, bytes memory txHash, uint256 fee) external payable nonReentrant whenNotPaused {\n', '        _pull(feeToken, fee);\n', '        emit PolyWrapperSpeedUp(feeToken, txHash, msg.sender, fee);\n', '    }\n', '\n', '    function _pull(address feeToken, uint256 fee) internal {\n', '        if (feeToken == address(0)) {\n', '            require(msg.value == fee, "insufficient ether");\n', '        } else {\n', '            IERC20(feeToken).safeTransferFrom(msg.sender, address(this), fee);\n', '        }\n', '    }\n', '\n', '    function _push(address fromAsset, uint64 toChainId, address toAddress, uint256 tokenId) internal {\n', '        CallArgs memory callArgs = CallArgs({\n', '            toAddress: abi.encodePacked(toAddress),\n', '            toChainId: toChainId\n', '        });\n', '        bytes memory callData = _serializeCallArgs(callArgs);\n', '        IERC721(fromAsset).safeTransferFrom(msg.sender, lockProxy, tokenId, callData);\n', '    }\n', '\n', '    function _serializeCallArgs(CallArgs memory args) internal pure returns (bytes memory) {\n', '        bytes memory buff;\n', '        buff = abi.encodePacked(\n', '            ZeroCopySink.WriteVarBytes(args.toAddress),\n', '            ZeroCopySink.WriteUint64(args.toChainId)\n', '            );\n', '        return buff;\n', '    }\n', '\n', '    function _serializeProfile(bytes memory buff, uint tokenId, string memory url) internal pure returns (bytes memory) {\n', '        buff = abi.encodePacked(\n', '            buff,\n', '            ZeroCopySink.WriteUint256(tokenId),\n', '            ZeroCopySink.WriteVarBytes(bytes(url))\n', '        );\n', '        return buff;\n', '    }\n', '\n', '    function _calcEndIndex(uint start, uint length, uint total) internal pure returns (uint) {\n', '        uint end = start + length - 1;\n', '        if (end >= total) {\n', '            end = total - 1;\n', '        }\n', '        return end;\n', '    }\n', '}']