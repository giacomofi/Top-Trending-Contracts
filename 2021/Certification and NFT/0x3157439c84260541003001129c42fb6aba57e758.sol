['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-19\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract Governance {\n', '\n', '  // The duration of voting on a proposal\n', '  uint public constant votingPeriod = 86000;\n', '\n', '  // Time since submission before the proposal can be executed\n', '  uint public constant executionPeriod = 86000 * 2;\n', '\n', '  // The required minimum number of votes in support of a proposal for it to succeed\n', '  uint public constant quorumVotes = 5000e18;\n', '\n', '  // The minimum number of votes required for an account to create a proposal\n', '  uint public constant proposalThreshold = 100e18;\n', '\n', '  IERC20 public votingToken;\n', '\n', '  // The total number of proposals\n', '  uint public proposalCount;\n', '\n', '  // The record of all proposals ever proposed\n', '  mapping (uint => Proposal) public proposals;\n', '\n', '  // receipts[ProposalId][voter]\n', '  mapping (uint => mapping (address => Receipt)) public receipts;\n', '\n', '  // The time until which tokens used for voting will be locked\n', '  mapping (address => uint) public voteLock;\n', '\n', '  // Keeps track of locked tokens per address\n', '  mapping(address => uint) public balanceOf;\n', '\n', '  struct Proposal {\n', '    // Unique id for looking up a proposal\n', '    uint id;\n', '\n', '    // Creator of the proposal\n', '    address proposer;\n', '\n', '    // The time at which voting starts\n', '    uint startTime;\n', '\n', '    // Current number of votes in favor of this proposal\n', '    uint forVotes;\n', '\n', '    // Current number of votes in opposition to this proposal\n', '    uint againstVotes;\n', '\n', '    // Queued transaction hash\n', '    bytes32 txHash;\n', '\n', '    bool executed;\n', '  }\n', '\n', '  // Ballot receipt record for a voter\n', '  struct Receipt {\n', '    // Whether or not a vote has been cast\n', '    bool hasVoted;\n', '\n', '    // Whether or not the voter supports the proposal\n', '    bool support;\n', '\n', '    // The number of votes the voter had, which were cast\n', '    uint votes;\n', '  }\n', '\n', '  // Possible states that a proposal may be in\n', '  enum ProposalState {\n', '    Active,            // 0\n', '    Defeated,          // 1\n', '    PendingExecution,  // 2\n', '    ReadyForExecution, // 3\n', '    Executed           // 4\n', '  }\n', '\n', '  // If the votingPeriod is changed and the user votes again, the lock period will be reset.\n', '  modifier lockVotes() {\n', '    uint tokenBalance = votingToken.balanceOf(msg.sender);\n', '    votingToken.transferFrom(msg.sender, address(this), tokenBalance);\n', '    _mint(msg.sender, tokenBalance);\n', '    voteLock[msg.sender] = block.timestamp + votingPeriod;\n', '    _;\n', '  }\n', '\n', '  constructor(IERC20 _votingToken) {\n', '      votingToken = _votingToken;\n', '  }\n', '\n', '  function state(uint proposalId) public view returns (ProposalState) {\n', '    require(proposalCount >= proposalId && proposalId > 0, "Governance::state: invalid proposal id");\n', '    Proposal storage proposal = proposals[proposalId];\n', '\n', '    if (block.timestamp <= proposal.startTime + votingPeriod) {\n', '      return ProposalState.Active;\n', '\n', '    } else if (proposal.executed == true) {\n', '      return ProposalState.Executed;\n', '\n', '    } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n', '      return ProposalState.Defeated;\n', '\n', '    } else if (block.timestamp < proposal.startTime + executionPeriod) {\n', '      return ProposalState.PendingExecution;\n', '\n', '    } else {\n', '      return ProposalState.ReadyForExecution;\n', '    }\n', '  }\n', '\n', '  function execute(uint _proposalId, address _target, bytes memory _data)\n', '    public\n', '    payable\n', '    returns (bytes memory)\n', '  {\n', '    bytes32 txHash = keccak256(abi.encode(_target, _data));\n', '    Proposal storage proposal = proposals[_proposalId];\n', '    require(proposal.txHash == txHash, "Governance::execute: Invalid proposal");\n', '    require(state(_proposalId) == ProposalState.ReadyForExecution, "Governance::execute: Cannot be executed");\n', '\n', '    (bool success, bytes memory returnData) = _target.delegatecall(_data);\n', '    require(success, "Governance::execute: Transaction execution reverted.");\n', '    proposal.executed = true;\n', '\n', '    return returnData;\n', '  }\n', '\n', '  function propose(address _target, bytes memory _data) public lockVotes returns (uint) {\n', '\n', '    require(balanceOf[msg.sender] >= proposalThreshold, "Governance::propose: proposer votes below proposal threshold");\n', '\n', '    bytes32 txHash = keccak256(abi.encode(_target, _data));\n', '\n', '    proposalCount++;\n', '    Proposal memory newProposal = Proposal({\n', '      id:           proposalCount,\n', '      proposer:     msg.sender,\n', '      startTime:    block.timestamp,\n', '      forVotes:     0,\n', '      againstVotes: 0,\n', '      txHash:       txHash,\n', '      executed:     false\n', '    });\n', '\n', '    proposals[newProposal.id] = newProposal;\n', '\n', '    return proposalCount;\n', '  }\n', '\n', '  function vote(uint _proposalId, bool _support) public lockVotes {\n', '\n', '    require(state(_proposalId) == ProposalState.Active, "Governance::vote: voting is closed");\n', '    Proposal storage proposal = proposals[_proposalId];\n', '    Receipt storage receipt = receipts[_proposalId][msg.sender];\n', '    require(receipt.hasVoted == false, "Governance::vote: voter already voted");\n', '\n', '    uint votes = balanceOf[msg.sender];\n', '\n', '    if (_support) {\n', '      proposal.forVotes += votes;\n', '    } else {\n', '      proposal.againstVotes += votes;\n', '    }\n', '\n', '    receipt.hasVoted = true;\n', '    receipt.support = _support;\n', '    receipt.votes = votes;\n', '  }\n', '\n', '  function withdraw() public {\n', '    require(block.timestamp > voteLock[msg.sender], "Governance::withdraw: wait until voteLock expiration");\n', '    votingToken.transfer(msg.sender, balanceOf[msg.sender]);\n', '    _burn(msg.sender, balanceOf[msg.sender]);\n', '  }\n', '\n', '  function _mint(address _account, uint _amount) internal {\n', '    balanceOf[_account] += _amount;\n', '  }\n', '\n', '  function _burn(address _account, uint _amount) internal {\n', '    balanceOf[_account] -= _amount;\n', '  }\n', '}']