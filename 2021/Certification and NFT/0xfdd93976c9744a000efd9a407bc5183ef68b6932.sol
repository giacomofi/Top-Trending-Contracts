['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-09\n', '*/\n', '\n', '// SPDX-License-Identifier: SEE LICENSE IN LICENSE\n', '\n', 'pragma abicoder v2;\n', 'pragma solidity >=0.7.6;\n', '\n', 'interface IStakePoolCreator {\n', '    function version() external returns (uint256);\n', '\n', '    function create() external returns (address);\n', '\n', '    function initialize(\n', '        address poolAddress,\n', '        address pair,\n', '        address rewardToken,\n', '        address timelock,\n', '        address stakePoolRewardFund,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', 'interface IStakePoolController {\n', '    event MasterCreated(address indexed farm, address indexed pair, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\n', '    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\n', '    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\n', '    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\n', '    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\n', '    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\n', '    event SetStakePoolVerifier(address indexed contractAddress, bool value);\n', '    event ChangeGovernance(address indexed governance);\n', '    event SetFeeCollector(address indexed feeCollector);\n', '    event SetFeeToken(address indexed token);\n', '    event SetFeeAmount(uint256 indexed amount);\n', '\n', '    function allStakePools(uint256) external view returns (address stakePool);\n', '\n', '    function isStakePool(address contractAddress) external view returns (bool);\n', '\n', '    function isStakePoolVerifier(address contractAddress) external view returns (bool);\n', '\n', '    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\n', '\n', '    function isWhitelistStakePool(address contractAddress) external view returns (int8);\n', '\n', '    function setStakePoolVerifier(address contractAddress, bool state) external;\n', '\n', '    function setWhitelistStakingFor(address contractAddress, bool state) external;\n', '\n', '    function setWhitelistStakePool(address contractAddress, int8 state) external;\n', '\n', '    function addStakePoolCreator(address contractAddress) external;\n', '\n', '    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\n', '\n', '    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\n', '\n', '    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\n', '\n', '    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\n', '\n', '    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\n', '\n', '    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\n', '\n', '    function setEnableWhitelistRewardRebaser(bool value) external;\n', '\n', '    function setEnableWhitelistRewardMultiplier(bool value) external;\n', '\n', '    function allStakePoolsLength() external view returns (uint256);\n', '\n', '    function create(\n', '        uint256 version,\n', '        address pair,\n', '        address rewardToken,\n', '        uint256 rewardFundAmount,\n', '        uint256 delayTimeLock,\n', '        bytes calldata data,\n', '        uint8 flag\n', '    ) external returns (address);\n', '\n', '    function createPair(\n', '        uint256 version,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee,\n', '        address rewardToken,\n', '        uint256 rewardFundAmount,\n', '        uint256 delayTimeLock,\n', '        bytes calldata poolRewardInfo,\n', '        uint8 flag\n', '    ) external returns (address);\n', '\n', '    function setGovernance(address) external;\n', '\n', '    function setFeeCollector(address _address) external;\n', '\n', '    function setFeeToken(address _token) external;\n', '\n', '    function setFeeAmount(uint256 _token) external;\n', '}\n', '\n', 'interface IValueLiquidRouter {\n', '    struct Swap {\n', '        address pool;\n', '        address tokenIn;\n', '        address tokenOut;\n', '        uint256 swapAmount; // tokenInAmount / tokenOutAmount\n', '        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n', '        uint256 maxPrice;\n', '        bool isBPool;\n', '    }\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function controller() external view returns (address);\n', '\n', '    function formula() external view returns (address);\n', '\n', '    function WETH() external view returns (address);\n', '\n', '    function addLiquidity(\n', '        address pair,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address pair,\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function swapExactTokensForTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        address tokenOut,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        address tokenIn,\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        address tokenOut,\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external;\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        address tokenOut,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable;\n', '\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external;\n', '\n', '    function addStakeLiquidity(\n', '        address stakePool,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addStakeLiquidityETH(\n', '        address stakePool,\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function multihopBatchSwapExactIn(\n', '        Swap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 totalAmountIn,\n', '        uint256 minTotalAmountOut,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256 totalAmountOut);\n', '\n', '    function multihopBatchSwapExactOut(\n', '        Swap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 maxTotalAmountIn,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256 totalAmountIn);\n', '\n', '    function createPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountA,\n', '        uint256 amountB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee,\n', '        address to,\n', '        uint8 flag\n', '    ) external returns (uint256 liquidity);\n', '\n', '    function createPairETH(\n', '        address token,\n', '        uint256 amountToken,\n', '        uint32 tokenWeight,\n', '        uint32 swapFee,\n', '        address to,\n', '        uint8 flag\n', '    ) external payable returns (uint256 liquidity);\n', '}\n', '\n', 'interface IValueLiquidFactory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint256);\n', '\n', '    function feeTo() external view returns (address);\n', '\n', '    function formula() external view returns (address);\n', '\n', '    function protocolFee() external view returns (uint256);\n', '\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee\n', '    ) external view returns (address pair);\n', '\n', '    function allPairs(uint256) external view returns (address pair);\n', '\n', '    function isPair(address) external view returns (bool);\n', '\n', '    function allPairsLength() external view returns (uint256);\n', '\n', '    function createPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee\n', '    ) external returns (address pair);\n', '\n', '    function getWeightsAndSwapFee(address pair)\n', '        external\n', '        view\n', '        returns (\n', '            uint32 tokenWeight0,\n', '            uint32 tokenWeight1,\n', '            uint32 swapFee\n', '        );\n', '\n', '    function setFeeTo(address) external;\n', '\n', '    function setFeeToSetter(address) external;\n', '\n', '    function setProtocolFee(uint256) external;\n', '}\n', '\n', 'interface IStakePool {\n', '    event Deposit(address indexed account, uint256 amount);\n', '    event AddRewardPool(uint256 indexed poolId);\n', '    event UpdateRewardPool(uint256 indexed poolId, uint256 endRewardBlock, uint256 rewardPerBlock);\n', '    event PayRewardPool(\n', '        uint256 indexed poolId,\n', '        address indexed rewardToken,\n', '        address indexed account,\n', '        uint256 pendingReward,\n', '        uint256 rebaseAmount,\n', '        uint256 paidReward\n', '    );\n', '    event UpdateRewardRebaser(uint256 indexed poolId, address rewardRebaser);\n', '    event UpdateRewardMultiplier(uint256 indexed poolId, address rewardMultiplier);\n', '    event Withdraw(address indexed account, uint256 amount);\n', '\n', '    function version() external returns (uint256);\n', '\n', '    function pair() external returns (address);\n', '\n', '    function initialize(\n', '        address _pair,\n', '        uint256 _unstakingFrozenTime,\n', '        address _rewardFund,\n', '        address _timelock\n', '    ) external;\n', '\n', '    function stake(uint256) external;\n', '\n', '    function stakeFor(address _account) external;\n', '\n', '    function withdraw(uint256) external;\n', '\n', '    function getReward(uint8 _pid, address _account) external;\n', '\n', '    function getAllRewards(address _account) external;\n', '\n', '    function claimReward() external;\n', '\n', '    function pendingReward(uint8 _pid, address _account) external view returns (uint256);\n', '\n', '    function allowRecoverRewardToken(address _token) external returns (bool);\n', '\n', '    function getRewardPerBlock(uint8 pid) external view returns (uint256);\n', '\n', '    function rewardPoolInfoLength() external view returns (uint256);\n', '\n', '    function unfrozenStakeTime(address _account) external view returns (uint256);\n', '\n', '    function emergencyWithdraw() external;\n', '\n', '    function updateReward() external;\n', '\n', '    function updateReward(uint8 _pid) external;\n', '\n', '    function updateRewardPool(\n', '        uint8 _pid,\n', '        uint256 _endRewardBlock,\n', '        uint256 _rewardPerBlock\n', '    ) external;\n', '\n', '    function getRewardMultiplier(\n', '        uint8 _pid,\n', '        uint256 _from,\n', '        uint256 _to,\n', '        uint256 _rewardPerBlock\n', '    ) external view returns (uint256);\n', '\n', '    function getRewardRebase(\n', '        uint8 _pid,\n', '        address _rewardToken,\n', '        uint256 _pendingReward\n', '    ) external view returns (uint256);\n', '\n', '    function updateRewardRebaser(uint8 _pid, address _rewardRebaser) external;\n', '\n', '    function updateRewardMultiplier(uint8 _pid, address _rewardMultiplier) external;\n', '\n', '    function getUserInfo(uint8 _pid, address _account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 amount,\n', '            uint256 rewardDebt,\n', '            uint256 accumulatedEarned,\n', '            uint256 lockReward,\n', '            uint256 lockRewardReleased\n', '        );\n', '\n', '    function addRewardPool(\n', '        address _rewardToken,\n', '        address _rewardRebaser,\n', '        address _rewardMultiplier,\n', '        uint256 _startBlock,\n', '        uint256 _endRewardBlock,\n', '        uint256 _rewardPerBlock,\n', '        uint256 _lockRewardPercent,\n', '        uint256 _startVestingBlock,\n', '        uint256 _endVestingBlock\n', '    ) external;\n', '\n', '    function removeLiquidity(\n', '        address provider,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETH(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '}\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: APPROVE_FAILED");\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: TRANSFER_FAILED");\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: TRANSFER_FROM_FAILED");\n', '    }\n', '\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', '        require(success, "TransferHelper: ETH_TRANSFER_FAILED");\n', '    }\n', '}\n', '\n', 'interface IValueLiquidPair {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external pure returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n', '    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n', '    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n', '    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n', '\n', '    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n', '\n', '    function getSwapFee() external view returns (uint32);\n', '\n', '    function price0CumulativeLast() external view returns (uint256);\n', '\n', '    function price1CumulativeLast() external view returns (uint256);\n', '\n', '    function mint(address to) external returns (uint256 liquidity);\n', '\n', '    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    function swap(\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address to,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function skim(address to) external;\n', '\n', '    function sync() external;\n', '\n', '    function initialize(\n', '        address,\n', '        address,\n', '        uint32,\n', '        uint32\n', '    ) external;\n', '}\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0, "ds-math-division-by-zero");\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract TimeLock {\n', '    using SafeMath for uint256;\n', '    event NewAdmin(address indexed newAdmin);\n', '    event NewPendingAdmin(address indexed newPendingAdmin);\n', '    event NewDelay(uint256 indexed newDelay);\n', '    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '\n', '    uint256 public constant GRACE_PERIOD = 14 days;\n', '    uint256 public constant MINIMUM_DELAY = 1 days;\n', '    uint256 public constant MAXIMUM_DELAY = 30 days;\n', '    bool private _initialized;\n', '    address public admin;\n', '    address public pendingAdmin;\n', '    uint256 public delay;\n', '    bool public admin_initialized;\n', '    mapping(bytes32 => bool) public queuedTransactions;\n', '\n', '    constructor() {\n', '        admin_initialized = false;\n', '        _initialized = false;\n', '    }\n', '\n', '    function initialize(address _admin, uint256 _delay) public {\n', '        require(_initialized == false, "Timelock::constructor: Initialized must be false.");\n', '        require(_delay >= MINIMUM_DELAY, "Timelock::setDelay: Delay must exceed minimum delay.");\n', '        require(_delay <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");\n', '        delay = _delay;\n', '        admin = _admin;\n', '        _initialized = true;\n', '        emit NewAdmin(admin);\n', '        emit NewDelay(delay);\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    function setDelay(uint256 _delay) public {\n', '        require(msg.sender == address(this), "Timelock::setDelay: Call must come from Timelock.");\n', '        require(_delay >= MINIMUM_DELAY, "Timelock::setDelay: Delay must exceed minimum delay.");\n', '        require(_delay <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");\n', '        delay = _delay;\n', '        emit NewDelay(delay);\n', '    }\n', '\n', '    function acceptAdmin() public {\n', '        require(msg.sender == pendingAdmin, "Timelock::acceptAdmin: Call must come from pendingAdmin.");\n', '        admin = msg.sender;\n', '        pendingAdmin = address(0);\n', '        emit NewAdmin(admin);\n', '    }\n', '\n', '    function setPendingAdmin(address _pendingAdmin) public {\n', '        // allows one time setting of admin for deployment purposes\n', '        if (admin_initialized) {\n', '            require(msg.sender == address(this), "Timelock::setPendingAdmin: Call must come from Timelock.");\n', '        } else {\n', '            require(msg.sender == admin, "Timelock::setPendingAdmin: First call must come from admin.");\n', '            admin_initialized = true;\n', '        }\n', '        pendingAdmin = _pendingAdmin;\n', '\n', '        emit NewPendingAdmin(pendingAdmin);\n', '    }\n', '\n', '    function queueTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public returns (bytes32) {\n', '        require(msg.sender == admin, "Timelock::queueTransaction: Call must come from admin.");\n', '        require(eta >= getBlockTimestamp().add(delay), "Timelock::queueTransaction: Estimated execution block must satisfy delay.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        queuedTransactions[txHash] = true;\n', '\n', '        emit QueueTransaction(txHash, target, value, signature, data, eta);\n', '        return txHash;\n', '    }\n', '\n', '    function cancelTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public {\n', '        require(msg.sender == admin, "Timelock::cancelTransaction: Call must come from admin.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        queuedTransactions[txHash] = false;\n', '\n', '        emit CancelTransaction(txHash, target, value, signature, data, eta);\n', '    }\n', '\n', '    function executeTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public payable returns (bytes memory) {\n', '        require(msg.sender == admin, "Timelock::executeTransaction: Call must come from admin.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        require(queuedTransactions[txHash], "Timelock::executeTransaction: Transaction hasn\'t been queued.");\n', '        require(getBlockTimestamp() >= eta, "Timelock::executeTransaction: Transaction hasn\'t surpassed time lock.");\n', '        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), "Timelock::executeTransaction: Transaction is stale.");\n', '\n', '        queuedTransactions[txHash] = false;\n', '\n', '        bytes memory callData;\n', '\n', '        if (bytes(signature).length == 0) {\n', '            callData = data;\n', '        } else {\n', '            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n', '        }\n', '\n', '        // solium-disable-next-line security/no-call-value\n', '        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n', '        require(success, "Timelock::executeTransaction: Transaction execution reverted.");\n', '\n', '        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n', '\n', '        return returnData;\n', '    }\n', '\n', '    function getBlockTimestamp() internal view returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '}\n', '\n', 'interface IStakePoolRewardFund {\n', '    function initialize(address _stakePool, address _timelock) external;\n', '\n', '    function safeTransfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _value\n', '    ) external;\n', '}\n', '\n', 'interface IStakePoolRewardRebaser {\n', '    function getRebaseAmount(address rewardToken, uint256 baseAmount) external view returns (uint256);\n', '}\n', '\n', 'interface IStakePoolRewardMultiplier {\n', '    function getRewardMultiplier(\n', '        uint256 _start,\n', '        uint256 _end,\n', '        uint256 _from,\n', '        uint256 _to,\n', '        uint256 _rewardPerBlock\n', '    ) external view returns (uint256);\n', '}\n', '\n', 'contract StakePoolRewardFund is IStakePoolRewardFund {\n', '    uint256 public constant BLOCKS_PER_DAY = 6528;\n', '    address public stakePool;\n', '    address public timelock;\n', '    bool private _initialized;\n', '\n', '    function initialize(address _stakePool, address _timelock) external override {\n', '        require(_initialized == false, "StakePoolRewardFund: already initialized");\n', '        stakePool = _stakePool;\n', '        timelock = _timelock;\n', '        _initialized = true;\n', '    }\n', '\n', '    function safeTransfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _value\n', '    ) external override {\n', '        require(msg.sender == stakePool, "StakePoolRewardFund: !stakePool");\n', '        TransferHelper.safeTransfer(_token, _to, _value);\n', '    }\n', '\n', '    function recoverRewardToken(\n', '        address _token,\n', '        uint256,\n', '        address\n', '    ) external {\n', '        require(msg.sender == timelock, "StakePoolRewardFund: !timelock");\n', '        require(IStakePool(stakePool).allowRecoverRewardToken(_token), "StakePoolRewardFund: not allow recover reward token");\n', '    }\n', '}\n', '\n', 'interface IFreeFromUpTo {\n', '    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n', '}\n', '\n', 'contract StakePoolController is IStakePoolController {\n', '    IValueLiquidFactory public swapFactory;\n', '    address public governance;\n', '\n', '    address public feeCollector;\n', '    address public feeToken;\n', '    uint256 public feeAmount;\n', '\n', '    mapping(address => bool) private _stakePools;\n', '    mapping(address => bool) private _whitelistStakingFor;\n', '    mapping(address => bool) private _whitelistRewardRebaser;\n', '    mapping(address => bool) private _whitelistRewardMultiplier;\n', '    mapping(address => int8) private _whitelistStakePools;\n', '    mapping(address => bool) public _stakePoolVerifiers;\n', '    mapping(uint256 => address) public stakePoolCreators;\n', '    address[] public override allStakePools;\n', '    bool public enableWhitelistRewardRebaser = true;\n', '    bool public enableWhitelistRewardMultiplier = true;\n', '    bool private _initialized = false;\n', '\n', '    IFreeFromUpTo public constant chi = IFreeFromUpTo(0x0000000000004946c0e9F43F4Dee607b0eF1fA1c);\n', '    mapping(address => bool) public allowEmergencyWithdrawStakePools;\n', '\n', '    modifier discountCHI(uint8 flag) {\n', '        uint256 gasStart = gasleft();\n', '        _;\n', '        if ((flag & 0x1) == 1) {\n', '            uint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n', '            chi.freeFromUpTo(msg.sender, (gasSpent + 14154) / 41130);\n', '        }\n', '    }\n', '\n', '    function initialize(address _swapFactory) public {\n', '        require(_initialized == false, "StakePoolController: initialized");\n', '        governance = msg.sender;\n', '        swapFactory = IValueLiquidFactory(_swapFactory);\n', '        _initialized = true;\n', '    }\n', '\n', '    function isStakePool(address b) external view override returns (bool) {\n', '        return _stakePools[b];\n', '    }\n', '\n', '    modifier onlyGovernance() {\n', '        require(msg.sender == governance, "StakePoolController: !governance");\n', '        _;\n', '    }\n', '\n', '    function setFeeCollector(address _address) external override onlyGovernance {\n', '        require(_address != address(0), "StakePoolController: invalid address");\n', '        feeCollector = _address;\n', '        emit SetFeeCollector(_address);\n', '    }\n', '\n', '    function setEnableWhitelistRewardRebaser(bool value) external override onlyGovernance {\n', '        enableWhitelistRewardRebaser = value;\n', '    }\n', '\n', '    function setEnableWhitelistRewardMultiplier(bool value) external override onlyGovernance {\n', '        enableWhitelistRewardMultiplier = value;\n', '    }\n', '\n', '    function setFeeToken(address _token) external override onlyGovernance {\n', '        require(_token != address(0), "StakePoolController: invalid _token");\n', '        feeToken = _token;\n', '        emit SetFeeToken(_token);\n', '    }\n', '\n', '    function setFeeAmount(uint256 _feeAmount) external override onlyGovernance {\n', '        feeAmount = _feeAmount;\n', '        emit SetFeeAmount(_feeAmount);\n', '    }\n', '\n', '    function isWhitelistStakingFor(address _address) external view override returns (bool) {\n', '        return _whitelistStakingFor[_address];\n', '    }\n', '\n', '    function isWhitelistStakePool(address _address) external view override returns (int8) {\n', '        return _whitelistStakePools[_address];\n', '    }\n', '\n', '    function isStakePoolVerifier(address _address) external view override returns (bool) {\n', '        return _stakePoolVerifiers[_address];\n', '    }\n', '\n', '    function isAllowEmergencyWithdrawStakePool(address _address) external view override returns (bool) {\n', '        return allowEmergencyWithdrawStakePools[_address];\n', '    }\n', '\n', '    function setWhitelistStakingFor(address _address, bool state) external override onlyGovernance {\n', '        require(_address != address(0), "StakePoolController: invalid address");\n', '        _whitelistStakingFor[_address] = state;\n', '        emit SetWhitelistStakingFor(_address, state);\n', '    }\n', '\n', '    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external override onlyGovernance {\n', '        require(_address != address(0), "StakePoolController: invalid address");\n', '        allowEmergencyWithdrawStakePools[_address] = state;\n', '    }\n', '\n', '    function setStakePoolVerifier(address _address, bool state) external override onlyGovernance {\n', '        require(_address != address(0), "StakePoolController: invalid address");\n', '        _stakePoolVerifiers[_address] = state;\n', '        emit SetStakePoolVerifier(_address, state);\n', '    }\n', '\n', '    function setWhitelistStakePool(address _address, int8 state) external override {\n', '        require(_address != address(0), "StakePoolController: invalid address");\n', '        require(_stakePoolVerifiers[msg.sender] == true, "StakePoolController: invalid stake pool verifier");\n', '        _whitelistStakePools[_address] = state;\n', '        emit SetWhitelistStakePool(_address, state);\n', '    }\n', '\n', '    function addStakePoolCreator(address _address) external override onlyGovernance {\n', '        require(_address != address(0), "StakePoolController: invalid address");\n', '        uint256 version = IStakePoolCreator(_address).version();\n', '        require(version >= 1000, "Invalid stake pool creator version");\n', '        stakePoolCreators[version] = _address;\n', '        emit SetStakePoolCreator(_address, version);\n', '    }\n', '\n', '    function isWhitelistRewardRebaser(address _address) external view override returns (bool) {\n', '        if (!enableWhitelistRewardRebaser) return true;\n', '        return _address == address(0) ? true : _whitelistRewardRebaser[_address];\n', '    }\n', '\n', '    function setWhitelistRewardRebaser(address _address, bool state) external override onlyGovernance {\n', '        require(_address != address(0), "StakePoolController: invalid address");\n', '        _whitelistRewardRebaser[_address] = state;\n', '        emit SetWhitelistRewardRebaser(_address, state);\n', '    }\n', '\n', '    function isWhitelistRewardMultiplier(address _address) external view override returns (bool) {\n', '        if (!enableWhitelistRewardMultiplier) return true;\n', '        return _address == address(0) ? true : _whitelistRewardMultiplier[_address];\n', '    }\n', '\n', '    function setWhitelistRewardMultiplier(address _address, bool state) external override onlyGovernance {\n', '        require(_address != address(0), "StakePoolController: invalid address");\n', '        _whitelistRewardMultiplier[_address] = state;\n', '        emit SetWhitelistRewardMultiplier(_address, state);\n', '    }\n', '\n', '    function setGovernance(address _governance) external override onlyGovernance {\n', '        require(_governance != address(0), "StakePoolController: invalid governance");\n', '        governance = _governance;\n', '        emit ChangeGovernance(_governance);\n', '    }\n', '\n', '    function allStakePoolsLength() external view override returns (uint256) {\n', '        return allStakePools.length;\n', '    }\n', '\n', '    function createPair(\n', '        uint256 version,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee,\n', '        address rewardToken,\n', '        uint256 rewardFundAmount,\n', '        uint256 delayTimeLock,\n', '        bytes calldata poolRewardInfo,\n', '        uint8 flag\n', '    ) public override discountCHI(flag) returns (address) {\n', '        address pair = swapFactory.getPair(tokenA, tokenB, tokenWeightA, swapFee);\n', '        if (pair == address(0)) {\n', '            pair = swapFactory.createPair(tokenA, tokenB, tokenWeightA, swapFee);\n', '        }\n', '        return create(version, pair, rewardToken, rewardFundAmount, delayTimeLock, poolRewardInfo, 0);\n', '    }\n', '\n', '    function createInternal(\n', '        address stakePoolCreator,\n', '        address pair,\n', '        address stakePoolRewardFund,\n', '        address rewardToken,\n', '        uint256 delayTimeLock,\n', '        bytes calldata data\n', '    ) internal returns (address) {\n', '        TimeLock timelock = new TimeLock();\n', '        IStakePool pool = IStakePool(IStakePoolCreator(stakePoolCreator).create());\n', '        allStakePools.push(address(pool));\n', '        _stakePools[address(pool)] = true;\n', '        emit MasterCreated(address(pool), pair, pool.version(), address(timelock), stakePoolRewardFund, allStakePools.length);\n', '        IStakePoolCreator(stakePoolCreator).initialize(address(pool), pair, rewardToken, address(timelock), address(stakePoolRewardFund), data);\n', '        StakePoolRewardFund(stakePoolRewardFund).initialize(address(pool), address(timelock));\n', '        timelock.initialize(msg.sender, delayTimeLock);\n', '        return address(pool);\n', '    }\n', '\n', '    function create(\n', '        uint256 version,\n', '        address pair,\n', '        address rewardToken,\n', '        uint256 rewardFundAmount,\n', '        uint256 delayTimeLock,\n', '        bytes calldata data,\n', '        uint8 flag\n', '    ) public override discountCHI(flag) returns (address) {\n', '        require(swapFactory.isPair(pair), "StakePoolController: invalid pair");\n', '        address stakePoolCreator = stakePoolCreators[version];\n', '        require(stakePoolCreator != address(0), "StakePoolController: Invalid stake pool creator version");\n', '\n', '        if (feeCollector != address(0) && feeToken != address(0) && feeAmount > 0) {\n', '            TransferHelper.safeTransferFrom(feeToken, msg.sender, feeCollector, feeAmount);\n', '        }\n', '\n', '        StakePoolRewardFund stakePoolRewardFund = new StakePoolRewardFund();\n', '        if (rewardFundAmount > 0) {\n', '            require(IERC20(rewardToken).balanceOf(msg.sender) >= rewardFundAmount, "StakePoolController: Not enough rewardFundAmount");\n', '            TransferHelper.safeTransferFrom(rewardToken, msg.sender, address(stakePoolRewardFund), rewardFundAmount);\n', '        }\n', '        return createInternal(stakePoolCreator, pair, address(stakePoolRewardFund), rewardToken, delayTimeLock, data);\n', '    }\n', '}']