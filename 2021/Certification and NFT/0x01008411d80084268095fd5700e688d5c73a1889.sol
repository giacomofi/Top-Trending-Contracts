['//SPDX-License-Identifier: Unlicense\n', 'pragma solidity ^0.6.8;\n', '\n', 'import "./ServiceInterface.sol";\n', 'import "./IERC1155Preset.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Context.sol";\n', '\n', 'contract StrongNFTBonus is Context {\n', '\n', '  using SafeMath for uint256;\n', '\n', '  event Staked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\n', '  event Unstaked(address indexed sender, uint256 tokenId, uint128 nodeId, uint256 block);\n', '\n', '  ServiceInterface public service;\n', '  IERC1155Preset public nft;\n', '\n', '  bool public initDone;\n', '\n', '  address public serviceAdmin;\n', '  address public superAdmin;\n', '\n', '  string[] public nftBonusNames;\n', '  mapping(string => uint256) public nftBonusLowerBound;\n', '  mapping(string => uint256) public nftBonusUpperBound;\n', '  mapping(string => uint256) public nftBonusValue;\n', '\n', '  mapping(uint256 => uint256) public nftIdStakedForNodeId;\n', '  mapping(address => mapping(uint128 => uint256)) public entityNodeStakedNftId;\n', '  mapping(address => mapping(uint128 => uint256)) public entityNodeStakedNftBlock;\n', '\n', '  function init(address serviceContract, address nftContract, address serviceAdminAddress, address superAdminAddress) public {\n', '    require(initDone == false, "init done");\n', '\n', '    serviceAdmin = serviceAdminAddress;\n', '    superAdmin = superAdminAddress;\n', '    service = ServiceInterface(serviceContract);\n', '    nft = IERC1155Preset(nftContract);\n', '    initDone = true;\n', '  }\n', '\n', '  function isNftStaked(uint256 _tokenId) public view returns (bool) {\n', '    return nftIdStakedForNodeId[_tokenId] != 0;\n', '  }\n', '\n', '  function getNftStakedForNodeId(uint256 _tokenId) public view returns (uint256) {\n', '    return nftIdStakedForNodeId[_tokenId];\n', '  }\n', '\n', '  function getStakedNftId(address _entity, uint128 _nodeId) public view returns (uint256) {\n', '    return entityNodeStakedNftId[_entity][_nodeId];\n', '  }\n', '\n', '  function getStakedNftBlock(address _entity, uint128 _nodeId) public view returns (uint256) {\n', '    return entityNodeStakedNftBlock[_entity][_nodeId];\n', '  }\n', '\n', '  function getBonus(address _entity, uint128 _nodeId, uint256 _fromBlock, uint256 _toBlock) public view returns (uint256) {\n', '    uint256 nftId = entityNodeStakedNftId[_entity][_nodeId];\n', '\n', '    if (nftId == 0) return 0;\n', '    if (nftId < nftBonusLowerBound["BRONZE"]) return 0;\n', '    if (nftId > nftBonusUpperBound["BRONZE"]) return 0;\n', '    if (nft.balanceOf(_entity, nftId) == 0) return 0;\n', '    if (_fromBlock >= _toBlock) return 0;\n', '\n', '    uint256 stakedAtBlock = entityNodeStakedNftBlock[_entity][_nodeId];\n', '\n', '    if (stakedAtBlock == 0) return 0;\n', '\n', '    uint256 startFromBlock = stakedAtBlock > _fromBlock ? stakedAtBlock : _fromBlock;\n', '\n', '    if (startFromBlock >= _toBlock) return 0;\n', '\n', '    return _toBlock.sub(startFromBlock).mul(nftBonusValue["BRONZE"]);\n', '  }\n', '\n', '  function stakeNFT(uint256 _tokenId, uint128 _nodeId) public payable {\n', '    require(nft.balanceOf(_msgSender(), _tokenId) != 0, "not enough");\n', '    require(_tokenId >= nftBonusLowerBound["BRONZE"] && _tokenId <= nftBonusUpperBound["BRONZE"], "not eligible");\n', '    require(nftIdStakedForNodeId[_tokenId] == 0, "already staked");\n', '    require(service.doesNodeExist(_msgSender(), _nodeId), "node doesnt exist");\n', '\n', '    nftIdStakedForNodeId[_tokenId] = _nodeId;\n', '    entityNodeStakedNftId[_msgSender()][_nodeId] = _tokenId;\n', '    entityNodeStakedNftBlock[_msgSender()][_nodeId] = block.number;\n', '\n', '    emit Staked(msg.sender, _tokenId, _nodeId, block.number);\n', '  }\n', '\n', '  function unStakeNFT(uint256 _tokenId, uint128 _nodeId, uint256 _blockNumber) public payable {\n', '    require(nft.balanceOf(_msgSender(), _tokenId) != 0, "not enough");\n', '    require(nftIdStakedForNodeId[_tokenId] == _nodeId, "not this node");\n', '\n', '    service.claim{value : msg.value}(_nodeId, _blockNumber, false);\n', '\n', '    nftIdStakedForNodeId[_tokenId] = 0;\n', '    entityNodeStakedNftId[_msgSender()][_nodeId] = 0;\n', '    entityNodeStakedNftBlock[_msgSender()][_nodeId] = 0;\n', '\n', '    emit Unstaked(msg.sender, _tokenId, _nodeId, _blockNumber);\n', '  }\n', '\n', '  function updateBonus(string memory _name, uint256 _lowerBound, uint256 _upperBound, uint256 _value) public {\n', '    require(msg.sender == serviceAdmin || msg.sender == superAdmin, "not admin");\n', '\n', '    bool alreadyExit = false;\n', '    for (uint i = 0; i < nftBonusNames.length; i++) {\n', '      if (keccak256(abi.encode(nftBonusNames[i])) == keccak256(abi.encode(_name))) {\n', '        alreadyExit = true;\n', '      }\n', '    }\n', '\n', '    if (!alreadyExit) {\n', '      nftBonusNames.push(_name);\n', '    }\n', '\n', '    nftBonusLowerBound[_name] = _lowerBound;\n', '    nftBonusUpperBound[_name] = _upperBound;\n', '    nftBonusValue[_name] = _value;\n', '  }\n', '\n', '  function updateContracts(address serviceContract, address nftContract) public {\n', '    require(msg.sender == superAdmin, "not admin");\n', '    service = ServiceInterface(serviceContract);\n', '    nft = IERC1155Preset(nftContract);\n', '  }\n', '\n', '  function updateServiceAdmin(address newServiceAdmin) public {\n', '    require(msg.sender == superAdmin, "not admin");\n', '    serviceAdmin = newServiceAdmin;\n', '  }\n', '}']