['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-29\n', '*/\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/marketplace/MarketplaceStorage.sol\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-20\n', ' */\n', 'interface ERC20Interface {\n', '  function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '}\n', '\n', '\n', '/**\n', ' * @title Interface for contracts conforming to ERC-721\n', ' */\n', 'interface ERC721Interface {\n', '  function ownerOf(uint256 _tokenId) external view returns (address _owner);\n', '  function approve(address _to, uint256 _tokenId) external;\n', '  function getApproved(uint256 _tokenId) external view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\n', '  function supportsInterface(bytes4) external view returns (bool);\n', '}\n', '\n', '\n', 'interface ERC721Verifiable is ERC721Interface {\n', '  function verifyFingerprint(uint256, bytes memory) external view returns (bool);\n', '}\n', '\n', '\n', 'contract MarketplaceStorage {\n', '  ERC20Interface public acceptedToken;\n', '\n', '  struct Order {\n', '    // Order ID\n', '    bytes32 id;\n', '    // Owner of the NFT\n', '    address seller;\n', '    // NFT registry address\n', '    address nftAddress;\n', '    // Price (in wei) for the published item\n', '    uint256 price;\n', '    // Time when this sale ends\n', '    uint256 expiresAt;\n', '  }\n', '\n', '  // From ERC721 registry assetId to Order (to avoid asset collision)\n', '  mapping (address => mapping(uint256 => Order)) public orderByAssetId;\n', '\n', '  uint256 public ownerCutPerMillion;\n', '  uint256 public publicationFeeInWei;\n', '\n', '  bytes4 public constant InterfaceId_ValidateFingerprint = bytes4(\n', '    keccak256("verifyFingerprint(uint256,bytes)")\n', '  );\n', '\n', '  bytes4 public constant ERC721_Interface = bytes4(0x80ac58cd);\n', '\n', '  // EVENTS\n', '  event OrderCreated(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    address nftAddress,\n', '    uint256 priceInWei,\n', '    uint256 expiresAt\n', '  );\n', '  event OrderSuccessful(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    address nftAddress,\n', '    uint256 totalPrice,\n', '    address indexed buyer\n', '  );\n', '  event OrderCancelled(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    address nftAddress\n', '  );\n', '\n', '  event ChangedPublicationFee(uint256 publicationFee);\n', '  event ChangedOwnerCutPerMillion(uint256 ownerCutPerMillion);\n', '\n', '  event SpayMining(\n', '    bytes32 id,\n', '    uint256 indexed assetId,\n', '    address indexed seller,\n', '    address indexed buyer,\n', '    address nftAddress,\n', '    uint256 priceInWei,\n', '    uint256 minedSpay\n', '  );\n', '}\n', '\n', '// File: contracts/commons/ContextMixin.sol\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'contract ContextMixin {\n', '    function _msgSender()\n', '        internal\n', '        view\n', '        returns (address sender)\n', '    {\n', '        if (msg.sender == address(this)) {\n', '            bytes memory array = msg.data;\n', '            uint256 index = msg.data.length;\n', '            assembly {\n', '                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n', '                sender := and(\n', '                    mload(add(array, index)),\n', '                    0xffffffffffffffffffffffffffffffffffffffff\n', '                )\n', '            }\n', '        } else {\n', '            sender = msg.sender;\n', '        }\n', '        return sender;\n', '    }\n', '}\n', '\n', '// File: contracts/commons/Ownable.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is ContextMixin {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/commons/Pausable.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'abstract contract Pausable is ContextMixin {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state.\n', '     */\n', '    constructor () {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view virtual returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!paused(), "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(paused(), "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', '// File: contracts/commons/EIP712Base.sol\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'contract EIP712Base {\n', '    struct EIP712Domain {\n', '        string name;\n', '        string version;\n', '        address verifyingContract;\n', '        bytes32 salt;\n', '    }\n', '\n', '    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\n', '        bytes(\n', '            "EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)"\n', '        )\n', '    );\n', '    bytes32 public domainSeparator;\n', '\n', '    // supposed to be called once while initializing.\n', '    // one of the contractsa that inherits this contract follows proxy pattern\n', '    // so it is not possible to do this in a constructor\n', '    function _initializeEIP712(\n', '        string memory name,\n', '        string memory version\n', '    )\n', '        internal\n', '    {\n', '        domainSeparator = keccak256(\n', '            abi.encode(\n', '                EIP712_DOMAIN_TYPEHASH,\n', '                keccak256(bytes(name)),\n', '                keccak256(bytes(version)),\n', '                address(this),\n', '                bytes32(getChainId())\n', '            )\n', '        );\n', '    }\n', '\n', '    function getChainId() public view virtual returns (uint256) {\n', '        uint256 id;\n', '        assembly {\n', '            id := chainid()\n', '        }\n', '        return id;\n', '    }\n', '\n', '    /**\n', '     * Accept message hash and returns hash message in EIP712 compatible form\n', '     * So that it can be used to recover signer from signature signed using EIP712 formatted data\n', '     * https://eips.ethereum.org/EIPS/eip-712\n', '     * "\\\\x19" makes the encoding deterministic\n', '     * "\\\\x01" is the version byte to make it compatible to EIP-191\n', '     */\n', '    function toTypedMessageHash(bytes32 messageHash)\n', '        internal\n', '        view\n', '        returns (bytes32)\n', '    {\n', '        return\n', '            keccak256(\n', '                abi.encodePacked("\\x19\\x01", domainSeparator, messageHash)\n', '            );\n', '    }\n', '}\n', '\n', '// File: contracts/commons/NativeMetaTransaction.sol\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'contract NativeMetaTransaction is EIP712Base {\n', '    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\n', '        bytes(\n', '            "MetaTransaction(uint256 nonce,address from,bytes functionSignature)"\n', '        )\n', '    );\n', '    event MetaTransactionExecuted(\n', '        address userAddress,\n', '        address relayerAddress,\n', '        bytes functionSignature\n', '    );\n', '    mapping(address => uint256) nonces;\n', '\n', '    /*\n', '     * Meta transaction structure.\n', '     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\n', '     * He should call the desired function directly in that case.\n', '     */\n', '    struct MetaTransaction {\n', '        uint256 nonce;\n', '        address from;\n', '        bytes functionSignature;\n', '    }\n', '\n', '    function executeMetaTransaction(\n', '        address userAddress,\n', '        bytes memory functionSignature,\n', '        bytes32 sigR,\n', '        bytes32 sigS,\n', '        uint8 sigV\n', '    ) public payable returns (bytes memory) {\n', '        MetaTransaction memory metaTx = MetaTransaction({\n', '            nonce: nonces[userAddress],\n', '            from: userAddress,\n', '            functionSignature: functionSignature\n', '        });\n', '\n', '        require(\n', '            verify(userAddress, metaTx, sigR, sigS, sigV),\n', '            "NMT#executeMetaTransaction: SIGNER_AND_SIGNATURE_DO_NOT_MATCH"\n', '        );\n', '\n', '        // increase nonce for user (to avoid re-use)\n', '        nonces[userAddress] = nonces[userAddress] + 1;\n', '\n', '        emit MetaTransactionExecuted(\n', '            userAddress,\n', '            msg.sender,\n', '            functionSignature\n', '        );\n', '\n', '        // Append userAddress and relayer address at the end to extract it from calling context\n', '        (bool success, bytes memory returnData) = address(this).call(\n', '            abi.encodePacked(functionSignature, userAddress)\n', '        );\n', '        require(success, "NMT#executeMetaTransaction: CALL_FAILED");\n', '\n', '        return returnData;\n', '    }\n', '\n', '    function hashMetaTransaction(MetaTransaction memory metaTx)\n', '        internal\n', '        pure\n', '        returns (bytes32)\n', '    {\n', '        return\n', '            keccak256(\n', '                abi.encode(\n', '                    META_TRANSACTION_TYPEHASH,\n', '                    metaTx.nonce,\n', '                    metaTx.from,\n', '                    keccak256(metaTx.functionSignature)\n', '                )\n', '            );\n', '    }\n', '\n', '    function getNonce(address user) public view returns (uint256 nonce) {\n', '        nonce = nonces[user];\n', '    }\n', '\n', '    function verify(\n', '        address signer,\n', '        MetaTransaction memory metaTx,\n', '        bytes32 sigR,\n', '        bytes32 sigS,\n', '        uint8 sigV\n', '    ) internal view returns (bool) {\n', '        require(signer != address(0), "NMT#verify: INVALID_SIGNER");\n', '        return\n', '            signer ==\n', '            ecrecover(\n', '                toTypedMessageHash(hashMetaTransaction(metaTx)),\n', '                sigV,\n', '                sigR,\n', '                sigS\n', '            );\n', '    }\n', '}\n', '\n', '// File: contracts/marketplace/Marketplace.sol\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'contract Marketplace is Ownable, Pausable, MarketplaceStorage, NativeMetaTransaction {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '\n', '  address sellerAddress;\n', '\n', '  /**\n', '    * @dev Initialize this contract. Acts as a constructor\n', '    * @param _acceptedToken - Address of the ERC20 accepted for this marketplace\n', '    * @param _ownerCutPerMillion - owner cut per million\n', '\n', '    */\n', '  constructor (\n', '    address _acceptedToken,\n', '    uint256 _ownerCutPerMillion,\n', '    address _owner,\n', '    address _seller\n', '  )\n', '  {\n', '    // EIP712 init\n', "    _initializeEIP712('SpaceY Marketplace', '1');\n", '\n', '    // Fee init\n', '    setOwnerCutPerMillion(_ownerCutPerMillion);\n', '\n', '    require(_owner != address(0), "Invalid owner");\n', '    transferOwnership(_owner);\n', '\n', '    require(_acceptedToken.isContract(), "The accepted token address must be a deployed contract");\n', '    acceptedToken = ERC20Interface(_acceptedToken);\n', '\n', '    sellerAddress = _seller;\n', '  }\n', '\n', '\n', '  /**\n', "    * @dev Sets the publication fee that's charged to users to publish items\n", '    * @param _publicationFee - Fee amount in wei this contract charges to publish an item\n', '    */\n', '  function setPublicationFee(uint256 _publicationFee) external onlyOwner {\n', '    publicationFeeInWei = _publicationFee;\n', '    emit ChangedPublicationFee(publicationFeeInWei);\n', '  }\n', '\n', '  /**\n', "    * @dev Sets the share cut for the owner of the contract that's\n", '    *  charged to the seller on a successful sale\n', '    * @param _ownerCutPerMillion - Share amount, from 0 to 999,999\n', '    */\n', '  function setOwnerCutPerMillion(uint256 _ownerCutPerMillion) public onlyOwner {\n', '    require(_ownerCutPerMillion < 1000000, "The owner cut should be between 0 and 999,999");\n', '\n', '    ownerCutPerMillion = _ownerCutPerMillion;\n', '    emit ChangedOwnerCutPerMillion(ownerCutPerMillion);\n', '  }\n', '\n', '  /**\n', '    * @dev Creates a new order\n', '    * @param nftAddress - Non fungible registry address\n', '    * @param assetId - ID of the published NFT\n', '    * @param priceInWei - Price in Wei for the supported coin\n', '    * @param expiresAt - Duration of the order (in hours)\n', '    */\n', '  function createOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 priceInWei,\n', '    uint256 expiresAt\n', '  )\n', '    public\n', '    whenNotPaused\n', '  {\n', '    _createOrder(\n', '      nftAddress,\n', '      assetId,\n', '      priceInWei,\n', '      expiresAt\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev Cancel an already published order\n', '    *  can only be canceled by seller or the contract owner\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    */\n', '  function cancelOrder(address nftAddress, uint256 assetId) public whenNotPaused {\n', '    _cancelOrder(nftAddress, assetId);\n', '  }\n', '\n', '  /**\n', '    * @dev Executes the sale for a published NFT and checks for the asset fingerprint\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    * @param price - Order price\n', '    * @param fingerprint - Verification info for the asset\n', '    */\n', '  function safeExecuteOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 price,\n', '    bytes memory fingerprint\n', '  )\n', '   public\n', '   whenNotPaused\n', '  {\n', '    _executeOrder(\n', '      nftAddress,\n', '      assetId,\n', '      price,\n', '      fingerprint\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev Executes the sale for a published NFT\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    * @param price - Order price\n', '    */\n', '  function executeOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 price\n', '  )\n', '   public\n', '   whenNotPaused\n', '  {\n', '    _executeOrder(\n', '      nftAddress,\n', '      assetId,\n', '      price,\n', '      ""\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev Creates a new order\n', '    * @param nftAddress - Non fungible registry address\n', '    * @param assetId - ID of the published NFT\n', '    * @param priceInWei - Price in Wei for the supported coin\n', '    * @param expiresAt - Duration of the order (in hours)\n', '    */\n', '  function _createOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 priceInWei,\n', '    uint256 expiresAt\n', '  )\n', '    internal\n', '  {\n', '    _requireERC721(nftAddress);\n', '\n', '    address sender = _msgSender();\n', '\n', '    ERC721Interface nftRegistry = ERC721Interface(nftAddress);\n', '    address assetOwner = nftRegistry.ownerOf(assetId);\n', '\n', '    require(sender == assetOwner, "Only the owner can create orders");\n', '    require(\n', '      nftRegistry.getApproved(assetId) == address(this) || nftRegistry.isApprovedForAll(assetOwner, address(this)),\n', '      "The contract is not authorized to manage the asset"\n', '    );\n', '    require(priceInWei > 0, "Price should be bigger than 0");\n', '    require(expiresAt > block.timestamp.add(1 minutes), "Publication should be more than 1 minute in the future");\n', '\n', '    bytes32 orderId = keccak256(\n', '      abi.encodePacked(\n', '        block.timestamp,\n', '        assetOwner,\n', '        assetId,\n', '        nftAddress,\n', '        priceInWei\n', '      )\n', '    );\n', '\n', '    orderByAssetId[nftAddress][assetId] = Order({\n', '      id: orderId,\n', '      seller: assetOwner,\n', '      nftAddress: nftAddress,\n', '      price: priceInWei,\n', '      expiresAt: expiresAt\n', '    });\n', '\n', "    // Check if there's a publication fee and\n", '    // transfer the amount to marketplace owner\n', '    if (publicationFeeInWei > 0) {\n', '      require(\n', '        acceptedToken.transferFrom(sender, owner(), publicationFeeInWei),\n', '        "Transfering the publication fee to the Marketplace owner failed"\n', '      );\n', '    }\n', '\n', '    emit OrderCreated(\n', '      orderId,\n', '      assetId,\n', '      assetOwner,\n', '      nftAddress,\n', '      priceInWei,\n', '      expiresAt\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev Cancel an already published order\n', '    *  can only be canceled by seller or the contract owner\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    */\n', '  function _cancelOrder(address nftAddress, uint256 assetId) internal returns (Order memory) {\n', '    address sender = _msgSender();\n', '    Order memory order = orderByAssetId[nftAddress][assetId];\n', '\n', '    require(order.id != 0, "Asset not published");\n', '    require(order.seller == sender || sender == owner(), "Unauthorized user");\n', '\n', '    bytes32 orderId = order.id;\n', '    address orderSeller = order.seller;\n', '    address orderNftAddress = order.nftAddress;\n', '    delete orderByAssetId[nftAddress][assetId];\n', '\n', '    emit OrderCancelled(\n', '      orderId,\n', '      assetId,\n', '      orderSeller,\n', '      orderNftAddress\n', '    );\n', '\n', '    return order;\n', '  }\n', '\n', '  /**\n', '    * @dev Executes the sale for a published NFT\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    * @param price - Order price\n', '    * @param fingerprint - Verification info for the asset\n', '    */\n', '  function _executeOrder(\n', '    address nftAddress,\n', '    uint256 assetId,\n', '    uint256 price,\n', '    bytes memory fingerprint\n', '  )\n', '   internal returns (Order memory)\n', '  {\n', '    _requireERC721(nftAddress);\n', '\n', '    address sender = _msgSender();\n', '\n', '    ERC721Verifiable nftRegistry = ERC721Verifiable(nftAddress);\n', '\n', '    if (nftRegistry.supportsInterface(InterfaceId_ValidateFingerprint)) {\n', '      require(\n', '        nftRegistry.verifyFingerprint(assetId, fingerprint),\n', '        "The asset fingerprint is not valid"\n', '      );\n', '    }\n', '    Order memory order = orderByAssetId[nftAddress][assetId];\n', '\n', '    require(order.id != 0, "Asset not published");\n', '\n', '    address seller = order.seller;\n', '\n', '    require(seller != address(0), "Invalid address");\n', '    require(seller != sender, "Unauthorized user");\n', '    require(order.price == price, "The price is not correct");\n', '    require(block.timestamp < order.expiresAt, "The order expired");\n', '    require(seller == nftRegistry.ownerOf(assetId), "The seller is no longer the owner");\n', '\n', '    uint mineShareAmount = 0;\n', '\n', '    bytes32 orderId = order.id;\n', '    delete orderByAssetId[nftAddress][assetId];\n', '\n', '    if (ownerCutPerMillion > 0 && seller == sellerAddress) {\n', '      // Calculate sale share\n', '      mineShareAmount = price.mul(ownerCutPerMillion).div(1000000);\n', '\n', '      emit SpayMining(\n', '        orderId,\n', '        assetId,\n', '        seller,\n', '        sender,\n', '        nftAddress,\n', '        price,\n', '        mineShareAmount\n', '      );\n', '    }\n', '\n', '    // Transfer sale amount to seller\n', '    require(\n', '      acceptedToken.transferFrom(sender, seller, price),\n', '      "Transfering the sale amount to the seller failed"\n', '    );\n', '\n', '    // Transfer asset owner\n', '    nftRegistry.safeTransferFrom(\n', '      seller,\n', '      sender,\n', '      assetId\n', '    );\n', '\n', '    emit OrderSuccessful(\n', '      orderId,\n', '      assetId,\n', '      seller,\n', '      nftAddress,\n', '      price,\n', '      sender\n', '    );\n', '\n', '    return order;\n', '  }\n', '\n', '  function _requireERC721(address nftAddress) internal view {\n', '    require(nftAddress.isContract(), "The NFT Address should be a contract");\n', '\n', '    ERC721Interface nftRegistry = ERC721Interface(nftAddress);\n', '    require(\n', '      nftRegistry.supportsInterface(ERC721_Interface),\n', '      "The NFT contract has an invalid ERC721 implementation"\n', '    );\n', '  }\n', '}']