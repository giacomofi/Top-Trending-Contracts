['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', "import {SafeMath} from './SafeMath.sol';\n", "import {IReserveInterestRateStrategy} from './IReserveInterestRateStrategy.sol';\n", "import {WadRayMath} from './WadRayMath.sol';\n", "import {PercentageMath} from './PercentageMath.sol';\n", "import {ILendingPoolAddressesProvider} from './ILendingPoolAddressesProvider.sol';\n", "import {ILendingRateOracle} from './ILendingRateOracle.sol';\n", '\n', '/**\n', ' * @title DefaultReserveInterestRateStrategy contract\n', ' * @notice Implements the calculation of the interest rates depending on the reserve state\n', ' * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE`\n', ' * point of utilization and another from that one to 100%\n', " * - An instance of this same contract, can't be used across different Aave markets, due to the caching\n", ' *   of the LendingPoolAddressesProvider\n', ' * @author Aave\n', ' **/\n', 'contract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n', '  using WadRayMath for uint256;\n', '  using SafeMath for uint256;\n', '  using PercentageMath for uint256;\n', '\n', '  /**\n', '   * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates.\n', '   * Expressed in ray\n', '   **/\n', '  uint256 public immutable OPTIMAL_UTILIZATION_RATE;\n', '\n', '  /**\n', "   * @dev This constant represents the excess utilization rate above the optimal. It's always equal to\n", '   * 1-optimal utilization rate. Added as a constant here for gas optimizations.\n', '   * Expressed in ray\n', '   **/\n', '\n', '  uint256 public immutable EXCESS_UTILIZATION_RATE;\n', '\n', '  ILendingPoolAddressesProvider public immutable addressesProvider;\n', '\n', '  // Base variable borrow rate when Utilization rate = 0. Expressed in ray\n', '  uint256 internal immutable _baseVariableBorrowRate;\n', '\n', '  // Slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n', '  uint256 internal immutable _variableRateSlope1;\n', '\n', '  // Slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n', '  uint256 internal immutable _variableRateSlope2;\n', '\n', '  // Slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n', '  uint256 internal immutable _stableRateSlope1;\n', '\n', '  // Slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n', '  uint256 internal immutable _stableRateSlope2;\n', '\n', '  constructor(\n', '    ILendingPoolAddressesProvider provider,\n', '    uint256 optimalUtilizationRate,\n', '    uint256 baseVariableBorrowRate,\n', '    uint256 variableRateSlope1,\n', '    uint256 variableRateSlope2,\n', '    uint256 stableRateSlope1,\n', '    uint256 stableRateSlope2\n', '  ) public {\n', '    OPTIMAL_UTILIZATION_RATE = optimalUtilizationRate;\n', '    EXCESS_UTILIZATION_RATE = WadRayMath.ray().sub(optimalUtilizationRate);\n', '    addressesProvider = provider;\n', '    _baseVariableBorrowRate = baseVariableBorrowRate;\n', '    _variableRateSlope1 = variableRateSlope1;\n', '    _variableRateSlope2 = variableRateSlope2;\n', '    _stableRateSlope1 = stableRateSlope1;\n', '    _stableRateSlope2 = stableRateSlope2;\n', '  }\n', '\n', '  function variableRateSlope1() external view returns (uint256) {\n', '    return _variableRateSlope1;\n', '  }\n', '\n', '  function variableRateSlope2() external view returns (uint256) {\n', '    return _variableRateSlope2;\n', '  }\n', '\n', '  function stableRateSlope1() external view returns (uint256) {\n', '    return _stableRateSlope1;\n', '  }\n', '\n', '  function stableRateSlope2() external view returns (uint256) {\n', '    return _stableRateSlope2;\n', '  }\n', '\n', '  function baseVariableBorrowRate() external view override returns (uint256) {\n', '    return _baseVariableBorrowRate;\n', '  }\n', '\n', '  function getMaxVariableBorrowRate() external view override returns (uint256) {\n', '    return _baseVariableBorrowRate.add(_variableRateSlope1).add(_variableRateSlope2);\n', '  }\n', '\n', '  struct CalcInterestRatesLocalVars {\n', '    uint256 totalDebt;\n', '    uint256 currentVariableBorrowRate;\n', '    uint256 currentStableBorrowRate;\n', '    uint256 currentLiquidityRate;\n', '    uint256 utilizationRate;\n', '  }\n', '\n', '  /**\n', "   * @dev Calculates the interest rates depending on the reserve's state and configurations\n", '   * @param reserve The address of the reserve\n', '   * @param availableLiquidity The liquidity available in the reserve\n', '   * @param totalStableDebt The total borrowed from the reserve a stable rate\n', '   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n', '   * @param averageStableBorrowRate The weighted average of all the stable rate loans\n', '   * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n', '   * @return The liquidity rate, the stable borrow rate and the variable borrow rate\n', '   **/\n', '  function calculateInterestRates(\n', '    address reserve,\n', '    uint256 availableLiquidity,\n', '    uint256 totalStableDebt,\n', '    uint256 totalVariableDebt,\n', '    uint256 averageStableBorrowRate,\n', '    uint256 reserveFactor\n', '  )\n', '    external\n', '    view\n', '    override\n', '    returns (\n', '      uint256,\n', '      uint256,\n', '      uint256\n', '    )\n', '  {\n', '    CalcInterestRatesLocalVars memory vars;\n', '\n', '    vars.totalDebt = totalStableDebt.add(totalVariableDebt);\n', '    vars.currentVariableBorrowRate = 0;\n', '    vars.currentStableBorrowRate = 0;\n', '    vars.currentLiquidityRate = 0;\n', '\n', '    uint256 utilizationRate =\n', '      vars.totalDebt == 0 ? 0 : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\n', '\n', '    vars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle())\n', '      .getMarketBorrowRate(reserve);\n', '\n', '    if (utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n', '      uint256 excessUtilizationRateRatio =\n', '        utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE);\n', '\n', '      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add(\n', '        _stableRateSlope2.rayMul(excessUtilizationRateRatio)\n', '      );\n', '\n', '      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add(\n', '        _variableRateSlope2.rayMul(excessUtilizationRateRatio)\n', '      );\n', '    } else {\n', '      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\n', '        _stableRateSlope1.rayMul(utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE))\n', '      );\n', '      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(\n', '        utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE)\n', '      );\n', '    }\n', '\n', '    vars.currentLiquidityRate = _getOverallBorrowRate(\n', '      totalStableDebt,\n', '      totalVariableDebt,\n', '      vars\n', '        .currentVariableBorrowRate,\n', '      averageStableBorrowRate\n', '    )\n', '      .rayMul(utilizationRate)\n', '      .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor));\n', '\n', '    return (\n', '      vars.currentLiquidityRate,\n', '      vars.currentStableBorrowRate,\n', '      vars.currentVariableBorrowRate\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable debt\n', '   * @param totalStableDebt The total borrowed from the reserve a stable rate\n', '   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n', '   * @param currentVariableBorrowRate The current variable borrow rate of the reserve\n', '   * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\n', '   * @return The weighted averaged borrow rate\n', '   **/\n', '  function _getOverallBorrowRate(\n', '    uint256 totalStableDebt,\n', '    uint256 totalVariableDebt,\n', '    uint256 currentVariableBorrowRate,\n', '    uint256 currentAverageStableBorrowRate\n', '  ) internal pure returns (uint256) {\n', '    uint256 totalDebt = totalStableDebt.add(totalVariableDebt);\n', '\n', '    if (totalDebt == 0) return 0;\n', '\n', '    uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\n', '\n', '    uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\n', '\n', '    uint256 overallBorrowRate =\n', '      weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay());\n', '\n', '    return overallBorrowRate;\n', '  }\n', '}']