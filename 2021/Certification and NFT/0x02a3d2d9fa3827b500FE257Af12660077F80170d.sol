['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.7.3;\n', '\n', 'import "./Helpers.sol";\n', '\n', 'import "./IATokenV1.sol";\n', 'import "./ICToken.sol";\n', 'import "./IComptroller.sol";\n', 'import "./ISushiBar.sol";\n', 'import "./ILendingPoolV1.sol";\n', 'import "./ICompoundLens.sol";\n', 'import "./IUniswapV2.sol";\n', 'import "./IBasicIssuanceModule.sol";\n', '\n', 'import "./SafeMath.sol";\n', 'import "./ERC20.sol";\n', 'import "./IERC20.sol";\n', 'import "./SafeERC20.sol";\n', '\n', '// Basket Weaver is a way to socialize gas costs related to minting baskets tokens\n', 'contract StandaloneWeaverV1 is Helpers {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    IBDPI public constant BDPI = IBDPI(0x0309c98B1bffA350bcb3F9fB9780970CA32a5060);\n', '\n', '    address public governance;\n', '\n', '    // **** Constructor and modifiers ****\n', '\n', '    constructor(address _governance) {\n', '        governance = _governance;\n', '\n', '        // Enter compound markets\n', '        address[] memory markets = new address[](2);\n', '        markets[0] = CUNI;\n', '        markets[0] = CCOMP;\n', '        enterMarkets(markets);\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == governance, "!governance");\n', '        _;\n', '    }\n', '\n', '    // **** Restricted functions ****\n', '\n', '    function setGov(address _governance) public onlyGov {\n', '        governance = _governance;\n', '    }\n', '\n', '    function recoverERC20(address _token) public onlyGov {\n', '        IERC20(_token).safeTransfer(governance, IERC20(_token).balanceOf(address(this)));\n', '    }\n', '\n', '    // **** Public Functions ****\n', '\n', '    /// @notice Converts ETH into a Basket, socializing gas cost\n', '    /// @param  derivatives  Address of the derivatives (e.g. cUNI, aYFI)\n', '    /// @param  underlyings  Address of the underlyings (e.g. UNI,   YFI)\n', '    /// @param  underlyingsInEthPerBasket  Off-chain calculation - how much each underlying is\n', '    ///                                    worth in ETH per 1 unit of basket token\n', '    /// @param  ethPerBasket  How much 1 basket token is worth in ETH\n', '    /// @param  minMintAmount Minimum amount of basket token to mint\n', '    /// @param  deadline      Deadline to mint by\n', '    function mintWithETH(\n', '        address[] memory derivatives,\n', '        address[] memory underlyings,\n', '        uint256[] memory underlyingsInEthPerBasket,\n', '        uint256 ethPerBasket,\n', '        uint256 minMintAmount,\n', '        uint256 deadline\n', '    ) public payable returns (uint256) {\n', '        require(block.timestamp <= deadline, "expired");\n', '        \n', '        // BDPI to mint\n', '        uint256 bdpiToMint =\n', '            _convertETHToDerivativeAndGetMintAmount(derivatives, underlyings, underlyingsInEthPerBasket, ethPerBasket);\n', '\n', '        require(bdpiToMint >= minMintAmount, "!mint-min-amount");\n', '\n', '        // Mint tokens and transfer to user\n', '        BDPI.mint(bdpiToMint);\n', '        IERC20(address(BDPI)).safeTransfer(msg.sender, bdpiToMint);\n', '\n', '        return bdpiToMint;\n', '    }\n', '\n', '    // **** Internals ****\n', '\n', '    /// @notice Chooses which router address to use\n', '    function _getRouterAddressForToken(address _token) internal pure returns (address) {\n', '        // Chooses which router (uniswap or sushiswap) to use to swap tokens\n', '        // By default: SUSHI\n', "        // But some tokens don't have liquidity on SUSHI, so we use UNI\n", "        // Don't want to use 1inch as its too costly gas-wise\n", '\n', '        if (_token == KNC || _token == LRC || _token == BAL || _token == MTA) {\n', '            return UNIV2_ROUTER;\n', '        }\n', '\n', '        return SUSHISWAP_ROUTER;\n', '    }\n', '\n', '    /// @notice Converts ETH into the specific derivative and get mint amount for basket\n', '    /// @param  derivatives  Address of the derivatives (e.g. cUNI, aYFI)\n', '    /// @param  underlyings  Address of the underlyings (e.g. UNI,   YFI)\n', '    /// @param  underlyingsInEthPerBasketToken  Off-chain calculation - how much each underlying is\n', '    ///                                    worth in ETH per 1 unit of basket token\n', '    /// @param  ethPerBasketToken  How much 1 basket token is worth in ETH\n', '    function _convertETHToDerivativeAndGetMintAmount(\n', '        address[] memory derivatives,\n', '        address[] memory underlyings,\n', '        uint256[] memory underlyingsInEthPerBasketToken,\n', '        uint256 ethPerBasketToken\n', '    ) internal returns (uint256) {\n', '        // Path\n', '        address[] memory path = new address[](2);\n', '        path[0] = WETH;\n', '\n', '        // Convert them all to the underlyings\n', '        uint256 bdpiToMint;\n', '\n', '        // Get total amount in bdpi\n', '        (, uint256[] memory tokenAmountsInBasket) = BDPI.getAssetsAndBalances();\n', '\n', '        // BDPI total supply\n', '        uint256 basketTotalSupply = BDPI.totalSupply();\n', '\n', '        // ETH received\n', '        uint256 totalETHReceived = address(this).balance;\n', '\n', '        {\n', '            uint256 ratio;\n', '            uint256 ethToSend;\n', '            for (uint256 i = 0; i < derivatives.length; i++) {\n', '                ratio = underlyingsInEthPerBasketToken[i].mul(1e18).div(ethPerBasketToken);\n', '\n', '                // Convert them from ETH to their respective tokens (truncate 1e6 for rounding errors)\n', '                ethToSend = totalETHReceived.mul(ratio).div(1e24).mul(1e6);\n', '\n', '                path[1] = underlyings[i];\n', '                IUniswapV2Router02(_getRouterAddressForToken(underlyings[i])).swapExactETHForTokens{ value: ethToSend }(\n', '                    0,\n', '                    path,\n', '                    address(this),\n', '                    block.timestamp + 60\n', '                );\n', '\n', '                // Convert to from respective token to derivative\n', '                _toDerivative(underlyings[i], derivatives[i]);\n', '\n', '                // Approve derivative and calculate mint amount\n', '                bdpiToMint = _approveDerivativeAndGetMintAmount(\n', '                    derivatives[i],\n', '                    basketTotalSupply,\n', '                    tokenAmountsInBasket[i],\n', '                    bdpiToMint\n', '                );\n', '            }\n', '        }\n', '\n', '        return bdpiToMint;\n', '    }\n', '\n', '    /// @notice Approves derivative to the basket address and gets the mint amount.\n', '    ///         Mainly here to avoid stack too deep errors\n', '    /// @param  derivative  Address of the derivative (e.g. cUNI, aYFI)\n', '    /// @param  basketTotalSupply  Total supply of the basket token\n', '    /// @param  tokenAmountInBasket  Amount of derivative currently in the basket\n', '    /// @param  curMintAmount  Accumulator - whats the minimum mint amount right now\n', '    function _approveDerivativeAndGetMintAmount(\n', '        address derivative,\n', '        uint256 basketTotalSupply,\n', '        uint256 tokenAmountInBasket,\n', '        uint256 curMintAmount\n', '    ) internal returns (uint256) {\n', '        uint256 derivativeBal = IERC20(derivative).balanceOf(address(this));\n', '\n', '        IERC20(derivative).safeApprove(address(BDPI), derivativeBal);\n', '\n', '        // Calculate how much BDPI we can mint at max\n', '        // Formula: min(e for e in bdpiSupply * tokenWeHave[e] / tokenInBDPI[e])\n', '        if (curMintAmount == 0) {\n', '            return basketTotalSupply.mul(derivativeBal).div(tokenAmountInBasket);\n', '        }\n', '\n', '        uint256 temp = basketTotalSupply.mul(derivativeBal).div(tokenAmountInBasket);\n', '        if (temp < curMintAmount) {\n', '            return temp;\n', '        }\n', '\n', '        return curMintAmount;\n', '    }\n', '}']