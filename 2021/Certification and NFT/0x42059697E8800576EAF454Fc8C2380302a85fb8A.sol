['// SPDX-License-Identifier: --GRISE--\n', '\n', 'pragma solidity =0.7.6;\n', '\n', 'import "./Snapshot.sol";\n', '\n', 'contract StakingToken is Snapshot {\n', '\n', '    using SafeMath for uint256;\n', '    receive() payable external {}\n', '\n', '    constructor(address _immutableAddress) Declaration(_immutableAddress) {}\n', '\n', '   /**\n', '     * @notice allows to create stake directly with ETH\n', "     * if you don't have GRISE tokens method will convert\n", '     * and use amount returned from UNISWAP to open a stake\n', '     * @param _lockDays amount of days it is locked for.\n', '     */\n', '    function createStakeWithETH(\n', '        uint256 _stakedAmount,\n', '        StakeType _stakeType,\n', '        uint64 _lockDays\n', '    )\n', '        external\n', '        payable\n', '        returns (bytes16, uint256)\n', '    {\n', '        address[] memory path = new address[](2);\n', '            path[0] = WETH;\n', '            path[1] = address(GRISE_CONTRACT);\n', '\n', '        uint256[] memory amounts =\n', '        UNISWAP_ROUTER.swapETHForExactTokens{value: msg.value}(\n', '            _stakedAmount.add(_stakedAmount.mul(400).div(10000)),\n', '            path,\n', '            msg.sender,\n', '            block.timestamp + 2 hours\n', '        );\n', '\n', '        if (msg.value > amounts[0])\n', '        {\n', '            (bool success, ) = msg.sender.call{value: msg.value.sub(amounts[0])}("Pending Ether");\n', "            require(success, 'Grise: Pending ETH transfer failed');\n", '        }\n', '\n', '        return createStake(\n', '            _stakedAmount,\n', '            _stakeType,\n', '            _lockDays\n', '        );\n', '    }\n', '    \n', '    /**\n', '     * @notice A method for a staker to create a stake\n', '     * @param _stakedAmount amount of GRISE staked.\n', '     * @param _stakeType Small/Medium/Large.\n', '     * @param _lockDays amount of days it is locked for.\n', '     */\n', '    function createStake(\n', '        uint256 _stakedAmount,\n', '        StakeType _stakeType,\n', '        uint64 _lockDays\n', '    )\n', '        snapshotTrigger\n', '        public\n', '        returns (bytes16, uint256)\n', '    {\n', '        // stakingSlot will be 0 for short/long term staking and\n', '        // stakingSlot will be 0,1,2 for 3,6,9 month medium term staking respectively.\n', '        uint8 stakingSlot; \n', '\n', '        if (_stakeType == StakeType.MEDIUM_TERM){\n', '            if (_lockDays == 168){ // 6 Month\n', '                stakingSlot = 1;\n', '            } else if (_lockDays == 252){ // 9 Month\n', '                stakingSlot = 2;\n', '            }\n', '        }\n', '\n', '        require(\n', '            _lockDays % GRISE_WEEK == 0 &&\n', '            _lockDays >= stakeDayLimit[_stakeType].minStakeDay &&\n', '            _lockDays <= stakeDayLimit[_stakeType].maxStakeDay,\n', "            'GRISE: stake is not in range'\n", '        );\n', '\n', '        require(\n', '            _stakedAmount >= stakeCaps[_stakeType][stakingSlot].minStakingAmount && \n', '            _stakedAmount.mod(stakeCaps[_stakeType][stakingSlot].minStakingAmount) == 0,\n', "            'GRISE: stake is not large enough or StakingAmount is not Valid'\n", '        );\n', '\n', '        require(\n', '            stakeCaps[_stakeType][stakingSlot].stakingSlotCount <= \n', '                    stakeCaps[_stakeType][stakingSlot].maxStakingSlot ,\n', "            'GRISE: All staking slot is occupied not extra slot is available'\n", '        );\n', '\n', '        uint256 newOccupiedSlotCount = _stakedAmount\n', '                                      .mod(stakeCaps[_stakeType][stakingSlot].minStakingAmount) != 0?\n', '                                      _stakedAmount\n', '                                      .div(stakeCaps[_stakeType][stakingSlot].minStakingAmount) + 1 :\n', '                                      _stakedAmount\n', '                                      .div(stakeCaps[_stakeType][stakingSlot].minStakingAmount);\n', '\n', '        require(\n', '            (stakeCaps[_stakeType][stakingSlot].stakingSlotCount + newOccupiedSlotCount <= \n', '                    stakeCaps[_stakeType][stakingSlot].maxStakingSlot),\n', "            'GRISE: All staking slot is occupied not extra slot is available'\n", '        );\n', '\n', '        stakeCaps[_stakeType][stakingSlot].stakingSlotCount = \n', '        stakeCaps[_stakeType][stakingSlot].stakingSlotCount.add(newOccupiedSlotCount);\n', '\n', '        (\n', '            Stake memory newStake,\n', '            bytes16 stakeID,\n', '            uint256 _startDay\n', '        ) =\n', '\n', '        _createStake(msg.sender, _stakedAmount, _lockDays, _stakeType, newOccupiedSlotCount);\n', '\n', '        stakes[msg.sender][stakeID] = newStake;\n', '\n', '        _increaseStakeCount(\n', '            msg.sender\n', '        );\n', '\n', '        _increaseGlobals(\n', '            uint8(newStake.stakeType),\n', '            newStake.stakedAmount,\n', '            newStake.stakesShares\n', '        );\n', '        \n', '        _addScheduledShares(\n', '            newStake.finalDay,\n', '            newStake.stakesShares\n', '        );\n', '\n', '        GRISE_CONTRACT.setStaker(msg.sender);\n', '        GRISE_CONTRACT.updateStakedToken(globals.totalStaked);\n', '\n', '        if (newStake.stakeType != StakeType.SHORT_TERM) {\n', '            GRISE_CONTRACT.updateMedTermShares(globals.MLTShares);\n', '        }\n', '\n', '        stakeCaps[_stakeType][stakingSlot].totalStakeCount++;\n', '\n', '        emit StakeStart(\n', '            stakeID,\n', '            msg.sender,\n', '            uint256(newStake.stakeType),\n', '            newStake.stakedAmount,\n', '            newStake.stakesShares,\n', '            newStake.startDay,\n', '            newStake.lockDays\n', '        );\n', '\n', '        return (stakeID, _startDay);\n', '    }\n', '\n', '    /**\n', '    * @notice A method for a staker to start a stake\n', '    * @param _staker ...\n', '    * @param _stakedAmount ...\n', '    * @param _lockDays ...\n', '    * @param _stakeType ...\n', '    * @param _totalOccupiedSlot ...\n', '    */\n', '    function _createStake(\n', '        address _staker,\n', '        uint256 _stakedAmount,\n', '        uint64 _lockDays,\n', '        StakeType  _stakeType,\n', '        uint256 _totalOccupiedSlot\n', '    )\n', '        private\n', '        returns (\n', '            Stake memory _newStake,\n', '            bytes16 _stakeID,\n', '            uint256 _startDay\n', '        )\n', '    {\n', '        require(\n', '            GRISE_CONTRACT.balanceOfStaker(_staker) >= _stakedAmount,\n', '            "GRISE: Staker doesn\'t have enough balance"\n', '        );\n', '\n', '        GRISE_CONTRACT.burnSupply(\n', '            _staker,\n', '            _stakedAmount\n', '        );\n', '\n', '        _startDay = currentGriseDay() + 1;\n', '        _stakeID = generateStakeID(_staker);\n', '\n', '        _newStake.stakeType = _stakeType;\n', '        _newStake.totalOccupiedSlot = _totalOccupiedSlot;\n', '        _newStake.lockDays = _lockDays;\n', '        _newStake.startDay = _startDay;\n', '        _newStake.finalDay = _startDay + _lockDays;\n', '        _newStake.isActive = true;\n', '\n', '        _newStake.stakedAmount = _stakedAmount;\n', '        _newStake.stakesShares = _stakesShares(\n', '            _stakedAmount,\n', '            globals.sharePrice\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @notice A method for a staker to remove a stake\n', '    * belonging to his address by providing ID of a stake.\n', '    * @param _stakeID unique bytes sequence reference to the stake\n', '    */\n', '    function endStake(\n', '        bytes16 _stakeID\n', '    )\n', '        snapshotTrigger\n', '        external\n', '        returns (uint256)\n', '    {\n', '        (\n', '            Stake memory endedStake,\n', '            uint256 penaltyAmount\n', '        ) =\n', '\n', '        _endStake(\n', '            msg.sender,\n', '            _stakeID\n', '        );\n', '\n', '        _decreaseGlobals(\n', '            uint8(endedStake.stakeType),\n', '            endedStake.stakedAmount,\n', '            endedStake.stakesShares\n', '        );\n', '\n', '        _removeScheduledShares(\n', '            endedStake.finalDay,\n', '            endedStake.stakesShares\n', '        );\n', '\n', '        _storePenalty(\n', '            endedStake.closeDay,\n', '            penaltyAmount\n', '        );\n', '\n', '        uint8 stakingSlot; \n', '        if (endedStake.stakeType == StakeType.MEDIUM_TERM){\n', '            if (endedStake.lockDays == 168) { // 6 Month\n', '                stakingSlot = 1;\n', '            } else if (endedStake.lockDays == 252) { // 9 Month\n', '                stakingSlot = 2;\n', '            }\n', '        }\n', '\n', '        stakeCaps[endedStake.stakeType][stakingSlot].stakingSlotCount = \n', '        stakeCaps[endedStake.stakeType][stakingSlot].stakingSlotCount.sub(endedStake.totalOccupiedSlot);\n', '        \n', '        GRISE_CONTRACT.resetStaker(msg.sender);\n', '        GRISE_CONTRACT.updateStakedToken(globals.totalStaked);\n', '\n', '        if (endedStake.stakeType != StakeType.SHORT_TERM) {\n', '            GRISE_CONTRACT.updateMedTermShares(globals.MLTShares);\n', '        }\n', '        \n', '        stakeCaps[endedStake.stakeType][stakingSlot].totalStakeCount--;\n', '\n', '        emit StakeEnd(\n', '            _stakeID,\n', '            msg.sender,\n', '            uint256(endedStake.stakeType),\n', '            endedStake.stakedAmount,\n', '            endedStake.stakesShares,\n', '            endedStake.rewardAmount,\n', '            endedStake.closeDay,\n', '            penaltyAmount\n', '        );\n', '\n', '        return endedStake.rewardAmount;\n', '    }\n', '\n', '    /**\n', '    * @notice A method for a staker to end a stake\n', '    * @param _staker ...\n', '    * @param _stakeID ...\n', '    */\n', '    function _endStake(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    )\n', '        private\n', '        returns (\n', '            Stake storage _stake,\n', '            uint256 _penalty\n', '        )\n', '    {\n', '        require(\n', '            stakes[_staker][_stakeID].isActive,\n', "            'GRISE: Not an active stake'\n", '        );\n', '\n', '        uint256 transFeeCompensation;\n', '        _stake = stakes[_staker][_stakeID];\n', '        _stake.closeDay = currentGriseDay();\n', '        _stake.rewardAmount = _calculateRewardAmount(_stake);\n', '        _penalty = _calculatePenaltyAmount(_stake);\n', '\n', '        if (_stake.stakeType == StakeType.SHORT_TERM)\n', '        {\n', '            transFeeCompensation = (_stake.stakedAmount\n', '                                    .add(_stake.rewardAmount)\n', '                                    .sub(_penalty))\n', '                                    .mul(ST_STAKER_COMPENSATION)\n', '                                    .div(REWARD_PRECISION_RATE);\n', '        }\n', '        else\n', '        {\n', '            transFeeCompensation = (_stake.stakedAmount\n', '                                    .add(_stake.rewardAmount)\n', '                                    .sub(_penalty))\n', '                                    .mul(MLT_STAKER_COMPENSATION)\n', '                                    .div(REWARD_PRECISION_RATE);\n', '        }\n', '        _stake.isActive = false;\n', '\n', '        GRISE_CONTRACT.mintSupply(\n', '            _staker,\n', '            _stake.stakedAmount > _penalty ?\n', '            _stake.stakedAmount - _penalty : 0\n', '        );\n', '\n', '        GRISE_CONTRACT.mintSupply(\n', '            _staker,\n', '            _stake.rewardAmount\n', '        );\n', '\n', '        GRISE_CONTRACT.mintSupply(\n', '            _staker,\n', '            transFeeCompensation\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @notice alloes to scrape Reward from active stake\n', '    * @param _stakeID unique bytes sequence reference to the stake\n', '    */\n', '    function scrapeReward(\n', '        bytes16 _stakeID\n', '    )\n', '        external\n', '        snapshotTrigger\n', '        returns (\n', '            uint256 scrapeDay,\n', '            uint256 scrapeAmount\n', '        )\n', '    {\n', '        require(\n', '            stakes[msg.sender][_stakeID].isActive,\n', "            'GRISE: Not an active stake'\n", '        );\n', '\n', '        Stake memory stake = stakes[msg.sender][_stakeID];\n', '\n', '        require(\n', '            globals.currentGriseDay >= stake.finalDay || \n', '                _startingDay(stake) < currentGriseDay().sub(currentGriseDay().mod(GRISE_WEEK)),\n', "            'GRISE: Stake is not yet mature to claim Reward'\n", '        );\n', '\n', '        scrapeDay = _calculationDay(stake);\n', '\n', '        scrapeDay = scrapeDay < stake.finalDay\n', '            ? scrapeDay.sub(scrapeDay.mod(GRISE_WEEK))\n', '            : scrapeDay;\n', '\n', '        scrapeAmount = getTranscRewardAmount(msg.sender, _stakeID);\n', '\n', '        scrapeAmount += getPenaltyRewardAmount(msg.sender, _stakeID);\n', '\n', '        scrapeAmount += getReservoirRewardAmount(msg.sender, _stakeID);\n', '\n', '        scrapes[msg.sender][_stakeID] =\n', '        scrapes[msg.sender][_stakeID].add(scrapeAmount);\n', '        \n', '        stake.scrapeDay = scrapeDay;\n', '        stakes[msg.sender][_stakeID] = stake;\n', '\n', '        GRISE_CONTRACT.mintSupply(\n', '            msg.sender,\n', '            scrapeAmount\n', '        );\n', '\n', '        emit InterestScraped(\n', '            _stakeID,\n', '            msg.sender,\n', '            scrapeAmount,\n', '            scrapeDay,\n', '            currentGriseDay()\n', '        );\n', '    }\n', '\n', '    function _addScheduledShares(\n', '        uint256 _finalDay,\n', '        uint256 _shares\n', '    )\n', '        internal\n', '    {\n', '        scheduledToEnd[_finalDay] =\n', '        scheduledToEnd[_finalDay].add(_shares);\n', '    }\n', '\n', '    function _removeScheduledShares(\n', '        uint256 _finalDay,\n', '        uint256 _shares\n', '    )\n', '        internal\n', '    {\n', '        if (_notPast(_finalDay)) {\n', '\n', '            scheduledToEnd[_finalDay] =\n', '            scheduledToEnd[_finalDay] > _shares ?\n', '            scheduledToEnd[_finalDay] - _shares : 0;\n', '\n', '        } else {\n', '\n', '            uint256 _day = currentGriseDay() - 1;\n', '            snapshots[_day].scheduledToEnd =\n', '            snapshots[_day].scheduledToEnd > _shares ?\n', '            snapshots[_day].scheduledToEnd - _shares : 0;\n', '        }\n', '    }\n', '\n', '    function checkMatureStake(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    )\n', '        external\n', '        view\n', '        returns (bool isMature)\n', '    {\n', '        Stake memory stake = stakes[_staker][_stakeID];\n', '        isMature = _isMatureStake(stake);\n', '    }\n', '\n', '    function checkStakeByID(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    )\n', '        external\n', '        view\n', '        returns \n', '    (\n', '        uint256 startDay,\n', '        uint256 lockDays,\n', '        uint256 finalDay,\n', '        uint256 closeDay,\n', '        uint256 scrapeDay,\n', '        StakeType stakeType,\n', '        uint256 slotOccupied,\n', '        uint256 stakedAmount,\n', '        uint256 penaltyAmount,\n', '        bool isActive,\n', '        bool isMature\n', '    )\n', '    {\n', '        Stake memory stake = stakes[_staker][_stakeID];\n', '        startDay = stake.startDay;\n', '        lockDays = stake.lockDays;\n', '        finalDay = stake.finalDay;\n', '        closeDay = stake.closeDay;\n', '        scrapeDay = stake.scrapeDay;\n', '        stakeType = stake.stakeType;\n', '        slotOccupied = stake.totalOccupiedSlot;\n', '        stakedAmount = stake.stakedAmount;\n', '        penaltyAmount = _calculatePenaltyAmount(stake);\n', '        isActive = stake.isActive;\n', '        isMature = _isMatureStake(stake);\n', '    }\n', '\n', '    function checkStakeRewards(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    )\n', '        external\n', '        view\n', '        returns \n', '    (\n', '        uint256 transcRewardAmount,\n', '        uint256 penaltyRewardAmount,\n', '        uint256 reservoirRewardAmount,\n', '        uint256 inflationRewardAmount\n', '    )\n', '    {\n', '        transcRewardAmount = getTranscRewardAmount(_staker, _stakeID);\n', '        penaltyRewardAmount = getPenaltyRewardAmount(_staker, _stakeID);\n', '        reservoirRewardAmount = getReservoirRewardAmount(_staker, _stakeID);\n', '        inflationRewardAmount = getInflationRewardAmount(_staker, _stakeID);\n', '    }\n', '\n', '    function updateStakingSlotLimit(\n', '        uint256 STSlotLimit,\n', '        uint256 MT3MonthSlotLimit,\n', '        uint256 MT6MonthSlotLimit,\n', '        uint256 MT9MonthSlotLimit,\n', '        uint256 LTSlotLimit\n', '    )\n', '    external\n', '    {\n', '        require(\n', '            msg.sender == contractDeployer,\n', "            'Operation Denied'\n", '        );\n', '\n', '        stakeCaps[StakeType.SHORT_TERM][0].maxStakingSlot = STSlotLimit;\n', '        stakeCaps[StakeType.MEDIUM_TERM][0].maxStakingSlot = MT3MonthSlotLimit;\n', '        stakeCaps[StakeType.MEDIUM_TERM][1].maxStakingSlot = MT6MonthSlotLimit;\n', '        stakeCaps[StakeType.MEDIUM_TERM][2].maxStakingSlot = MT9MonthSlotLimit;\n', '        stakeCaps[StakeType.LONG_TERM][0].maxStakingSlot = LTSlotLimit;\n', '    }\n', '\n', '    function getTranscRewardAmount(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    ) \n', '        private\n', '        view\n', '        returns (uint256 rewardAmount)\n', '    {\n', '        Stake memory _stake = stakes[_staker][_stakeID];\n', '\n', '        if ( _stakeEligibleForWeeklyReward(_stake))\n', '        {\n', '            uint256 _endDay = currentGriseDay() >= _stake.finalDay ? \n', '                                _stake.finalDay : \n', '                                currentGriseDay().sub(currentGriseDay().mod(GRISE_WEEK));\n', '\n', '            rewardAmount = _loopTranscRewardAmount(\n', '                _stake.stakesShares,\n', '                _startingDay(_stake),\n', '                _endDay,\n', '                _stake.stakeType);\n', '        }\n', '    }\n', '\n', '    function getPenaltyRewardAmount(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    ) \n', '        private \n', '        view \n', '        returns (uint256 rewardAmount) \n', '    {\n', '        Stake memory _stake = stakes[_staker][_stakeID];\n', '\n', '        if ( _stakeEligibleForWeeklyReward(_stake))\n', '        {\n', '            uint256 _endDay = currentGriseDay() >= _stake.finalDay ? \n', '                                _stake.finalDay : \n', '                                currentGriseDay().sub(currentGriseDay().mod(GRISE_WEEK));\n', '\n', '            rewardAmount = _loopPenaltyRewardAmount(\n', '                _stake.stakesShares,\n', '                _startingDay(_stake),\n', '                _endDay,\n', '                _stake.stakeType);\n', '        }\n', '    }\n', '\n', '    function getReservoirRewardAmount(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    ) \n', '        private \n', '        view \n', '        returns (uint256 rewardAmount) \n', '    {\n', '        Stake memory _stake = stakes[_staker][_stakeID];\n', '\n', '        if ( _stakeEligibleForMonthlyReward(_stake))\n', '        {\n', '            uint256 _endDay = currentGriseDay() >= _stake.finalDay ? \n', '                                _stake.finalDay : \n', '                                currentGriseDay().sub(currentGriseDay().mod(GRISE_MONTH));\n', '\n', '            rewardAmount = _loopReservoirRewardAmount(\n', '                _stake.stakesShares,\n', '                _startingDay(_stake),\n', '                _endDay,\n', '                _stake.stakeType\n', '            );\n', '        }\n', '    }\n', '\n', '    function getInflationRewardAmount(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    ) \n', '        private \n', '        view \n', '        returns (uint256 rewardAmount) \n', '    {    \n', '        Stake memory _stake = stakes[_staker][_stakeID];\n', '\n', '        if ( _stake.isActive && !_stakeNotStarted(_stake))\n', '        {\n', '            rewardAmount = _loopInflationRewardAmount(\n', '            _stake.stakesShares,\n', '            _stake.startDay,\n', '            _calculationDay(_stake),\n', '            _stake.stakeType);\n', '        }\n', '    }\n', '\n', '    function _stakesShares(\n', '        uint256 _stakedAmount,\n', '        uint256 _sharePrice\n', '    )\n', '        private\n', '        pure\n', '        returns (uint256)\n', '    {\n', '        return _stakedAmount\n', '                .div(_sharePrice);\n', '    }\n', '\n', '    function _storePenalty(\n', '        uint256 _storeDay,\n', '        uint256 _penalty\n', '    )\n', '        private\n', '    {\n', '        if (_penalty > 0) {\n', '            totalPenalties[_storeDay] =\n', '            totalPenalties[_storeDay].add(_penalty);\n', '\n', '            MLTPenaltiesRewardPerShares[_storeDay] += \n', '                _penalty.mul(MED_LONG_STAKER_PENALTY_REWARD)\n', '                        .div(REWARD_PRECISION_RATE)\n', '                        .div(globals.MLTShares);\n', '\n', '            STPenaltiesRewardPerShares[_storeDay] +=\n', '                _penalty.mul(SHORT_STAKER_PENALTY_REWARD)\n', '                        .div(REWARD_PRECISION_RATE)\n', '                        .div(globals.STShares);\n', '\n', '            ReservoirPenaltiesRewardPerShares[_storeDay] +=\n', '                _penalty.mul(RESERVOIR_PENALTY_REWARD)\n', '                        .div(REWARD_PRECISION_RATE)\n', '                        .div(globals.MLTShares);\n', '\n', '            GRISE_CONTRACT.mintSupply(\n', '                TEAM_ADDRESS,\n', '                _penalty.mul(TEAM_PENALTY_REWARD)\n', '                        .div(REWARD_PRECISION_RATE)\n', '            );\n', '\n', '            GRISE_CONTRACT.mintSupply(\n', '                DEVELOPER_ADDRESS,\n', '                _penalty.mul(DEVELOPER_PENALTY_REWARD)\n', '                        .div(REWARD_PRECISION_RATE)\n', '            );\n', '        }\n', '    }\n', '\n', '    function _calculatePenaltyAmount(\n', '        Stake memory _stake\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _stakeNotStarted(_stake) || _isMatureStake(_stake) ? 0 : _getPenalties(_stake);\n', '    }\n', '\n', '    function _getPenalties(\n', '        Stake memory _stake\n', '    )\n', '        private\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _stake.stakedAmount * ((PENALTY_RATE * (_daysLeft(_stake) - 1) / (_getLockDays(_stake)))) / 10000;\n', '    }\n', '\n', '    function _calculateRewardAmount(\n', '        Stake memory _stake\n', '    )\n', '        private\n', '        view\n', '        returns (uint256 _rewardAmount)\n', '    {\n', '        _rewardAmount = _loopPenaltyRewardAmount(\n', '            _stake.stakesShares,\n', '            _startingDay(_stake),\n', '            _calculationDay(_stake),\n', '            _stake.stakeType\n', '        );\n', '\n', '        _rewardAmount += _loopTranscRewardAmount(\n', '            _stake.stakesShares,\n', '            _startingDay(_stake),\n', '            _calculationDay(_stake),\n', '            _stake.stakeType\n', '        );\n', '\n', '        _rewardAmount += _loopReservoirRewardAmount(\n', '            _stake.stakesShares,\n', '            _startingDay(_stake),\n', '            _calculationDay(_stake),\n', '             _stake.stakeType\n', '        );\n', '        \n', '        _rewardAmount += _loopInflationRewardAmount(\n', '            _stake.stakesShares,\n', '            _stake.startDay,\n', '            _calculationDay(_stake),\n', '            _stake.stakeType\n', '        );\n', '    }\n', '\n', '    function _loopInflationRewardAmount(\n', '        uint256 _stakeShares,\n', '        uint256 _startDay,\n', '        uint256 _finalDay,\n', '        StakeType _stakeType\n', '    )\n', '        private\n', '        view\n', '        returns (uint256 _rewardAmount)\n', '    {\n', '        uint256 inflationAmount;\n', '        if (_stakeType == StakeType.SHORT_TERM)\n', '        {\n', '            return 0;\n', '        }\n', '\n', '        for (uint256 _day = _startDay; _day < _finalDay; _day++) {\n', '\n', '            inflationAmount = (_stakeType == StakeType.MEDIUM_TERM) ? \n', '                                snapshots[_day].inflationAmount\n', '                                .mul(MED_TERM_INFLATION_REWARD)\n', '                                .div(REWARD_PRECISION_RATE) :\n', '                                snapshots[_day].inflationAmount\n', '                                .mul(LONG_TERM_INFLATION_REWARD)\n', '                                .div(REWARD_PRECISION_RATE);\n', '\n', '            _rewardAmount = _rewardAmount\n', '                            .add(_stakeShares\n', '                                    .mul(PRECISION_RATE)\n', '                                    .div(inflationAmount));\n', '        }\n', '    }\n', '\n', '    function _loopPenaltyRewardAmount(\n', '        uint256 _stakeShares,\n', '        uint256 _startDay,\n', '        uint256 _finalDay,\n', '        StakeType _stakeType\n', '    )\n', '        private\n', '        view\n', '        returns (uint256 _rewardAmount)\n', '    {\n', '        for (uint256 day = _startDay; day < _finalDay; day++) \n', '        {\n', '            if (_stakeType == StakeType.SHORT_TERM)\n', '            {\n', '                _rewardAmount += STPenaltiesRewardPerShares[day]\n', '                                    .mul(_stakeShares);\n', '            } else {\n', '                _rewardAmount += MLTPenaltiesRewardPerShares[day]\n', '                                    .mul(_stakeShares);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _loopReservoirRewardAmount(\n', '        uint256 _stakeShares,\n', '        uint256 _startDay,\n', '        uint256 _finalDay,\n', '        StakeType _stakeType\n', '    )\n', '        private\n', '        view\n', '        returns (uint256 _rewardAmount)\n', '    {\n', '        if (_stakeType == StakeType.SHORT_TERM)\n', '        {\n', '            return 0;\n', '        }\n', '\n', '        for (uint256 day = _startDay; day < _finalDay; day++) \n', '        {\n', '            _rewardAmount = \n', '            _rewardAmount.add(ReservoirPenaltiesRewardPerShares[day]);\n', '        }\n', '\n', '        _rewardAmount = \n', '        _rewardAmount.add(GRISE_CONTRACT.getReservoirReward(_startDay, _finalDay));\n', '\n', '        _rewardAmount = \n', '        _rewardAmount.mul(_stakeShares);\n', '    }\n', '\n', '    function _loopTranscRewardAmount(\n', '        uint256 _stakeShares,\n', '        uint256 _startDay,\n', '        uint256 _finalDay,\n', '        StakeType _stakeType\n', '    )\n', '        private\n', '        view\n', '        returns (uint256 _rewardAmount)\n', '    {\n', '        uint256 stakedAmount = _stakeShares.mul(globals.sharePrice);\n', '        \n', '        if (_stakeType != StakeType.SHORT_TERM)\n', '        {\n', '            _rewardAmount =\n', '            _rewardAmount.add(GRISE_CONTRACT.getTransFeeReward(_startDay, _finalDay)\n', '                                .mul(_stakeShares)); \n', '        }\n', '\n', '        _rewardAmount =\n', '        _rewardAmount.add(GRISE_CONTRACT.getTokenHolderReward(_startDay, _finalDay)\n', '                            .mul(stakedAmount)\n', '                            .div(PRECISION_RATE));\n', '    }\n', '\n', '    function getSlotLeft() \n', '        external \n', '        view \n', '        returns \n', '    (\n', '        uint256 STSlotLeft, \n', '        uint256 MT3MonthSlotLeft,\n', '        uint256 MT6MonthSlotLeft, \n', '        uint256 MT9MonthSlotLeft, \n', '        uint256 LTSlotLeft\n', '    ) \n', '    {\n', '\n', '        STSlotLeft = stakeCaps[StakeType.SHORT_TERM][0].maxStakingSlot\n', '                            .sub(stakeCaps[StakeType.SHORT_TERM][0].stakingSlotCount);\n', '\n', '        MT3MonthSlotLeft = stakeCaps[StakeType.MEDIUM_TERM][0].maxStakingSlot\n', '                            .sub(stakeCaps[StakeType.MEDIUM_TERM][0].stakingSlotCount);\n', '                            \n', '        MT6MonthSlotLeft = stakeCaps[StakeType.MEDIUM_TERM][1].maxStakingSlot\n', '                            .sub(stakeCaps[StakeType.MEDIUM_TERM][1].stakingSlotCount);\n', '\n', '        MT9MonthSlotLeft = stakeCaps[StakeType.MEDIUM_TERM][2].maxStakingSlot\n', '                            .sub(stakeCaps[StakeType.MEDIUM_TERM][2].stakingSlotCount);\n', '        \n', '        LTSlotLeft = stakeCaps[StakeType.LONG_TERM][0].maxStakingSlot\n', '                            .sub(stakeCaps[StakeType.LONG_TERM][0].stakingSlotCount);\n', '    }\n', '\n', '    function getStakeCount() \n', '        external \n', '        view \n', '        returns \n', '    (\n', '        uint256 STStakeCount, \n', '        uint256 MT3MonthStakeCount,\n', '        uint256 MT6MonthStakeCount,\n', '        uint256 MT9MonthStakeCount,\n', '        uint256 LTStakeCount\n', '    )\n', '    {\n', '        STStakeCount = stakeCaps[StakeType.SHORT_TERM][0].totalStakeCount;\n', '        MT3MonthStakeCount = stakeCaps[StakeType.MEDIUM_TERM][0].totalStakeCount;\n', '        MT6MonthStakeCount = stakeCaps[StakeType.MEDIUM_TERM][1].totalStakeCount;\n', '        MT9MonthStakeCount = stakeCaps[StakeType.MEDIUM_TERM][2].totalStakeCount;\n', '        LTStakeCount = stakeCaps[StakeType.LONG_TERM][0].totalStakeCount;\n', '    }\n', '\n', '    function getTotalStakedToken()\n', '        external\n', '        view \n', '        returns (uint256) \n', '    {\n', '        return globals.totalStaked;\n', '    }\n', '}']