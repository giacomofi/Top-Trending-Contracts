['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-19\n', '*/\n', '\n', '/// SPDX-License-Identifier: GPL-3.0-or-later\n', '/*\n', ' ▄         ▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄         ▄  ▄▄▄▄▄▄▄▄▄▄▄ \n', '▐░▌       ▐░▌▐░░░░░░░░░░░▌▐░▌       ▐░▌▐░░░░░░░░░░░▌\n', '▐░▌       ▐░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░▌       ▐░▌ ▀▀▀▀█░█▀▀▀▀ \n', '▐░▌       ▐░▌▐░▌          ▐░▌       ▐░▌     ▐░▌     \n', '▐░▌       ▐░▌▐░▌          ▐░█▄▄▄▄▄▄▄█░▌     ▐░▌     \n', '▐░▌       ▐░▌▐░▌          ▐░░░░░░░░░░░▌     ▐░▌     \n', '▐░▌       ▐░▌▐░▌          ▐░█▀▀▀▀▀▀▀█░▌     ▐░▌     \n', '▐░▌       ▐░▌▐░▌          ▐░▌       ▐░▌     ▐░▌     \n', '▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░▌       ▐░▌ ▄▄▄▄█░█▄▄▄▄ \n', '▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░▌       ▐░▌▐░░░░░░░░░░░▌\n', ' ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀         ▀  ▀▀▀▀▀▀▀▀▀▀▀ */\n', 'pragma solidity 0.8.3;\n', '\n', '/// @notice Interface for SushiSwap pair creation and ETH liquidity provision.\n', 'interface ISushiSwapLaunch {\n', '    function approve(address to, uint amount) external returns (bool); \n', '    function transferFrom(address from, address to, uint amount) external returns (bool);\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '}\n', '\n', '/// @notice Whitelist ERC20 token with SushiSwap launch.\n', 'contract UchiToken {\n', '    ISushiSwapLaunch constant sushiSwapFactory=ISushiSwapLaunch(0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac);\n', '    address constant sushiSwapRouter=0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n', '    address constant wETH=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; \n', '    address public governance;\n', '    string public name;\n', '    string public symbol;\n', '    uint8 constant public decimals=18;\n', '    uint public totalSupply;\n', '    uint immutable public totalSupplyCap;\n', '    bool public uchiRestricted;\n', '    \n', '    mapping(address=>mapping(address=>uint)) public allowance;\n', '    mapping(address=>uint) public balanceOf;\n', '    mapping(address=>bool) public uchi;\n', '    \n', '    event Approval(address indexed owner, address indexed spender, uint amount);\n', '    event Transfer(address indexed from, address indexed to, uint amount);\n', '    event UpdateUchi(address indexed account, bool approved);\n', '    \n', '    constructor(\n', '        address[] memory _uchi, // initial whitelist array of accounts\n', "        string memory _name, // erc20-formatted UchiToken 'name'\n", "        string memory _symbol, // erc20-formatted UchiToken 'symbol'\n", '        uint _totalSupplyCap, // supply cap for UchiToken mint\n', '        uint pairDistro, // UchiToken amount minted for `sushiPair`\n', '        uint[] memory uchiDistro, // UchiToken amount minted to `uchi`\n', "        bool market // if 'true', launch pair and add ETH liquidity on SushiSwap via 'Factory'\n", '    ){\n', '        for(uint i=0;i<_uchi.length;i++){\n', '            balanceOf[_uchi[i]]=uchiDistro[i];\n', '            totalSupply+=uchiDistro[i];\n', '            uchi[_uchi[i]]=true;\n', '            emit Transfer(address(0), _uchi[i], uchiDistro[i]);}\n', '        if(market){\n', '            address sushiPair=sushiSwapFactory.createPair(address(this), wETH);\n', '            uchi[msg.sender]=true;\n', '            uchi[sushiSwapRouter]=true;\n', '            uchi[sushiPair]=true;\n', '            balanceOf[msg.sender]=pairDistro;\n', '            totalSupply+=pairDistro;\n', '            emit Transfer(address(0), msg.sender, pairDistro);}\n', "        require(totalSupply<=_totalSupplyCap,'capped'); \n", '        governance=_uchi[0]; // first `uchi` is `governance`\n', '        name=_name;\n', '        symbol=_symbol;\n', '        totalSupplyCap=_totalSupplyCap;\n', '        uchiRestricted=true;\n', '        balanceOf[address(this)]=type(uint).max; // max local balance blocks sends to UchiToken via overflow check (+saves gas)\n', '    }\n', '\n', '    /// - RESTRICTED ERC20 - ///\n', '    function approve(address to, uint amount) external returns (bool) {\n', '        allowance[msg.sender][to]=amount;\n', '        emit Approval(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transfer(address to, uint amount) external returns (bool) {\n', "        if(uchiRestricted){require(uchi[msg.sender]&&uchi[to],'!uchi');}\n", '        balanceOf[msg.sender]-=amount;\n', '        balanceOf[to]+=amount;\n', '        emit Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint amount) external returns (bool) {\n', "        if(uchiRestricted){require(uchi[from]&&uchi[to],'!uchi');}\n", '        allowance[from][msg.sender]-=amount;\n', '        balanceOf[from]-=amount;\n', '        balanceOf[to]+=amount;\n', '        emit Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    /// - GOVERNANCE - ///\n', '    modifier onlyGovernance {\n', "        require(msg.sender==governance,'!governance');\n", '        _;\n', '    }\n', '    \n', '    function mint(address to, uint amount) external onlyGovernance {\n', "        require(totalSupply+amount<=totalSupplyCap,'capped'); \n", '        balanceOf[to]+=amount; \n', '        totalSupply+=amount; \n', '        emit Transfer(address(0), to, amount); \n', '    }\n', '    \n', '    function transferGovernance(address _governance) external onlyGovernance {\n', '        governance=_governance;\n', '    }\n', '\n', '    function updateUchi(address[] calldata account, bool[] calldata approved) external onlyGovernance {\n', '        for(uint i=0;i<account.length;i++){\n', '            uchi[account[i]]=approved[i];\n', '            emit UpdateUchi(account[i], approved[i]);\n', '        }\n', '    }\n', '\n', '    function updateUchiRestriction(bool _uchiRestricted) external onlyGovernance {\n', '        uchiRestricted=_uchiRestricted;\n', '    }\n', '}\n', '\n', '/// @notice Factory for UchiToken deployment.\n', 'contract UchiTokenFactory {\n', '    ISushiSwapLaunch constant sushiSwapRouter=ISushiSwapLaunch(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F);\n', '    address public uchiDAO=msg.sender;\n', '\n', '    mapping(address=>uint) public uchiList;\n', '    \n', '    event DeployUchiToken(address indexed uchiToken);\n', '    event UpdateUchiList(address indexed account, uint indexed list, string details);\n', '    \n', '    function deployUchiToken(\n', '        address[] calldata _uchi, // initial whitelist array of accounts\n', "        string calldata _name, // erc20-formatted UchiToken 'name'\n", "        string calldata _symbol, // erc20-formatted UchiToken 'symbol'\n", '        uint _totalSupplyCap, // supply cap for UchiToken mint\n', '        uint pairDistro, // UchiToken amount minted for `sushiPair`\n', '        uint[] calldata uchiDistro, // UchiToken amount minted to `uchi`\n', "        uint list, // if not '0', add check to `uchi` against given `uchiList`\n", "        bool market // if 'true', launch pair and add ETH liquidity on SushiSwap\n", '    ) external payable returns (UchiToken uchiToken) {\n', '        if(list!=0){checkList(_uchi, list);}\n', '        uchiToken=new UchiToken(\n', '            _uchi,\n', '            _name, \n', '            _symbol,\n', '            _totalSupplyCap,\n', '            pairDistro,\n', '            uchiDistro,\n', '            market);\n', '        if(market){\n', '            uchiToken.approve(address(sushiSwapRouter), pairDistro);\n', '            initMarket(_uchi[0], address(uchiToken), pairDistro);}\n', '        emit DeployUchiToken(address(uchiToken));\n', '    }\n', '    \n', "    function checkList(address[] calldata _uchi, uint list) private view { // deployment helper to avoid 'stack too deep' error\n", "        for(uint i=0;i<_uchi.length;i++){require(uchiList[_uchi[i]]==list,'!listed');}\n", '    }\n', '    \n', "    function initMarket(address governance, address uchiToken, uint pairDistro) private { // deployment helper to avoid 'stack too deep' error\n", '        sushiSwapRouter.addLiquidityETH{value: msg.value}(uchiToken, pairDistro, 0, 0, governance, 2533930386);\n', '    }\n', '    \n', '    /// - GOVERNANCE - ///\n', '    function transferGovernance(address _uchiDAO) external {\n', "        require(msg.sender==uchiDAO,'!uchiDAO');\n", '        uchiDAO=_uchiDAO;\n', '    }\n', '    \n', '    function updateUchiList(address[] calldata account, uint[] calldata list, string calldata details) external { // `0` is default and delisting action\n', "        require(msg.sender==uchiDAO,'!uchiDAO');\n", '        for(uint i=0;i<account.length;i++){\n', '            uchiList[account[i]]=list[i]; \n', '            emit UpdateUchiList(account[i], list[i], details);\n', '        }\n', '    }\n', '}']