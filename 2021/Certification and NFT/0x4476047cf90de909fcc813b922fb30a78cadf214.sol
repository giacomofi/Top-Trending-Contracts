['pragma solidity 0.5.10;\n', '\n', "import './LibInteger.sol';\n", "import './LibBlob.sol';\n", "import './InterfaceProduce.sol';\n", "import './BlobDefinition.sol';\n", "import './BlobFormation.sol';\n", "import './BlobStorage.sol';\n", '\n', '/**\n', ' * @title BlobManager \n', ' * @dev Manage the core functionalities of blobs\n', ' */\n', 'contract BlobManager\n', '{\n', '    using LibInteger for uint;\n', '\n', '    BlobDefinition private _definition;\n', '    BlobFormation private _formation;\n', '    BlobStorage private _storage;\n', '    InterfaceProduce private _producer;\n', '\n', '    event Log(address indexed account, uint indexed blob, string action, uint data1, uint data2);\n', '\n', '    /**\n', '     * @dev The admin of the contract\n', '     */\n', '    address payable private _admin;\n', '\n', '    /**\n', '     * @dev The address of the definition token contract\n', '     */\n', '    address private _definition_contract;\n', '    \n', '    /**\n', '     * @dev The address of the formation token contract\n', '     */\n', '    address private _formation_contract;\n', '\n', '    /**\n', '     * @dev The address of the blob storage contract\n', '     */\n', '    address private _storage_contract;\n', '\n', '    /**\n', '     * @dev The address of the blob producer contract\n', '     */\n', '    address private _producer_contract;\n', '\n', '    /**\n', '     * Number of tokens per minting segment\n', '     */\n', '    uint private constant _tokens_per_segment = 2048;\n', '\n', '    /**\n', '     * Starting price of minting\n', '     */\n', '    uint private constant _minting_starting_price = 10**17;\n', '\n', '    /**\n', '     * Minting price increment per segment\n', '     */\n', '    uint private constant _minting_price_increment = 10**17;\n', '\n', '    /**\n', '     * Formation grant multiplier when minting\n', '     */\n', '    uint private constant _minting_grant_multiplier = 10**18;\n', '\n', '    /**\n', '     * The formation tokens charged for merging, splitting and renaming\n', '     */\n', '    uint private constant _transformation_token_fee = 10**18;\n', '\n', '    /**\n', '     * The minimum transformation fee charged if payed by native currency\n', '     */\n', '    uint private constant _transformation_native_fee_min = 40 * 10**15;\n', '\n', '    /**\n', '     * The transformation fee increment per segment\n', '     */\n', '    uint private constant _transformation_native_fee_increment = 10**15;\n', '\n', '    /**\n', '     * The transformation fee increment gap\n', '     */\n', '    uint private constant _transformation_native_fee_gap = 2500 * 10**18;\n', '\n', '    /**\n', '     * The original minter selling fee percentage\n', '     */\n', '    uint private constant _minter_selling_fee_percentage = 2;\n', '\n', '    /**\n', '     * @dev Initialise the contract\n', '     */\n', '    constructor() public\n', '    {\n', '        //The contract creator becomes the admin\n', '        _admin = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Allow access only for the admin of contract\n', '     */\n', '    modifier onlyAdmin()\n', '    {\n', '        require(msg.sender == _admin);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw from the balance of this contract\n', '     * @param amount The amount to be withdrawn, if zero is provided the whole balance will be withdrawn\n', '     */\n', '    function clean(uint amount) public onlyAdmin\n', '    {\n', '        if (amount == 0){\n', '            _admin.transfer(address(this).balance);\n', '        } else {\n', '            _admin.transfer(amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw formation tokens of this contract\n', '     * @param amount The amount to be withdrawn, if zero is provided the whole formation token balance will be withdrawn\n', '     */\n', '    function empty(uint amount) public onlyAdmin\n', '    {\n', '        if (amount == 0){\n', '            _formation.transfer(_admin, _formation.balanceOf(address(this)));\n', '        } else {\n', '            _formation.transfer(_admin, amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Update definition contract reference\n', '     * @param account The address of contract\n', '     */\n', '    function setDefinition(address account) public onlyAdmin\n', '    {\n', '        _definition_contract = account;\n', '        _definition = BlobDefinition(account);\n', '    }\n', '\n', '    /**\n', '     * @dev Update formation contract reference\n', '     * @param account The address of contract\n', '     */\n', '    function setFormation(address account) public onlyAdmin\n', '    {\n', '        _formation_contract = account;\n', '        _formation = BlobFormation(account);\n', '    }\n', '\n', '    /**\n', '     * @dev Update storage contract reference\n', '     * @param account The address of contract\n', '     */\n', '    function setStorage(address account) public onlyAdmin\n', '    {\n', '        _storage_contract = account;\n', '        _storage = BlobStorage(account);\n', '    }\n', '\n', '    /**\n', '     * @dev Update producer contract reference\n', '     * @param account The address of contract\n', '     */\n', '    function setProducer(address account) public onlyAdmin\n', '    {\n', '        _producer_contract = account;\n', '        _producer = InterfaceProduce(account);\n', '    }\n', '\n', '    /**\n', '     * @dev Mint new blobs\n', '     */\n', '    function mint() public payable\n', '    {        \n', '        //Must pay for minting\n', '        require(msg.value > 0);\n', '\n', '        //Get currently minted tokens\n', '        uint minted = _definition.totalSupply();\n', '\n', '        //Must pay the price\n', '        require(_calcSegmentPrice(minted) == msg.value);\n', '\n', '        //Grant formation tokens\n', '        _formation.transfer(msg.sender, _calcSegmentGrant(minted));\n', '\n', '        //Mint the token\n', '        uint id = _definition.mint(msg.sender);\n', '\n', '        //Save metadata\n', '        _storage.incrementMetadata(id, _producer.init(id));\n', '\n', '        //Save original minter\n', '        _storage.setMinter(id, msg.sender);\n', '\n', '        //Transfer fee\n', '        _admin.transfer(msg.value.mul(90).div(100));\n', '\n', '        //Emit events\n', '        emit Log(msg.sender, id, "mint", msg.value, 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Merge two blobs\n', '     * @param father The father blob id\n', '     * @param mother The mother blob id\n', '     */\n', '    function merge(uint father, uint mother, uint[] memory params) public payable\n', '    {\n', '        //The parents must be owned by the sender\n', '        require(msg.sender == _definition.ownerOf(father));\n', '        require(msg.sender == _definition.ownerOf(mother));\n', '\n', '        //The parents must not be the same\n', '        require(father != mother);\n', '\n', '        //Blobs must not be currently listed\n', '        require(_storage.getListing(father) == 0);\n', '        require(_storage.getListing(mother) == 0);\n', '\n', '        //Parameters should be valid\n', '        require(params.length == 6);\n', '        for (uint i = 0; i < 6; i++) {\n', '            require(params[i] == father || params[i] == mother);\n', '        }\n', '\n', '        //Read metadata of parents\n', '        LibBlob.Metadata memory father_metadata = LibBlob.uintToMetadata(_storage.getLatestMetadata(father));\n', '        LibBlob.Metadata memory mother_metadata = LibBlob.uintToMetadata(_storage.getLatestMetadata(mother));\n', '\n', '        //Both father and mother should be in same level\n', '        require(father_metadata.level == mother_metadata.level);\n', '\n', '        //Cannot merge further after reaching level six\n', '        require(father_metadata.level < 6 && mother_metadata.level < 6);\n', '\n', '        //Setup partners\n', '        father_metadata.partner = mother;\n', '        mother_metadata.partner = father;\n', '\n', '        //Merging increases the level of blob\n', '        father_metadata.level = father_metadata.level.add(1);\n', '        mother_metadata.level = mother_metadata.level.add(1);\n', '\n', '        //Setting up father parameters\n', '        father_metadata.param1 = (params[0] == father) ? father_metadata.param1 : mother_metadata.param1;\n', '        father_metadata.param2 = (params[1] == father) ? father_metadata.param2 : mother_metadata.param2;\n', '        father_metadata.param3 = (params[2] == father) ? father_metadata.param3 : mother_metadata.param3;\n', '        father_metadata.param4 = (params[3] == father) ? father_metadata.param4 : mother_metadata.param4;\n', '        father_metadata.param5 = (params[4] == father) ? father_metadata.param5 : mother_metadata.param5;\n', '        father_metadata.param6 = (params[5] == father) ? father_metadata.param6 : mother_metadata.param6;\n', '\n', '        //Setting up mother parameters\n', '        mother_metadata.param1 = (params[0] == father) ? father_metadata.param1 : mother_metadata.param1;\n', '        mother_metadata.param2 = (params[1] == father) ? father_metadata.param2 : mother_metadata.param2;\n', '        mother_metadata.param3 = (params[2] == father) ? father_metadata.param3 : mother_metadata.param3;\n', '        mother_metadata.param4 = (params[3] == father) ? father_metadata.param4 : mother_metadata.param4;\n', '        mother_metadata.param5 = (params[4] == father) ? father_metadata.param5 : mother_metadata.param5;\n', '        mother_metadata.param6 = (params[5] == father) ? father_metadata.param6 : mother_metadata.param6;\n', '\n', '        //Charge for the action\n', '        if (msg.value > 0) {\n', '            require(msg.value == _calcTransformationNativeFee());\n', '        } else {\n', '            _formation.burn(msg.sender, _transformation_token_fee);\n', '        }\n', '\n', '        //Update metadata\n', '        _storage.incrementMetadata(father, LibBlob.metadataToUint(father_metadata));\n', '        _storage.incrementMetadata(mother, LibBlob.metadataToUint(mother_metadata));\n', '\n', '        //Only father survives after merging\n', '        _definition.disable(msg.sender, mother);\n', '    \n', '        //Emit events\n', '        emit Log(msg.sender, father, "merge", msg.value, mother);\n', '    }\n', '\n', '    /**\n', '     * @dev Split a blob back to its parents\n', '     * @param id The id of blob\n', '     */\n', '    function split(uint id) public payable\n', '    {\n', '        //Blob must be owned by the sender\n', '        require(msg.sender == _definition.ownerOf(id));\n', '\n', '        //Blob must not be currently listed\n', '        require(_storage.getListing(id) == 0);\n', '\n', '        //Read metadata\n', '        LibBlob.Metadata memory metadata = LibBlob.uintToMetadata(_storage.getLatestMetadata(id));\n', '\n', '        //Cannot split further after reaching level one\n', '        require(metadata.level > 1);\n', '\n', '        //Charge for the action\n', '        if (msg.value > 0) {\n', '            require(msg.value == _calcTransformationNativeFee());\n', '        } else {\n', '            _formation.burn(msg.sender, _transformation_token_fee);\n', '        }\n', '\n', '        //Summon the partner\n', '        _definition.enable(msg.sender, metadata.partner);\n', '\n', '        //Restore metadata\n', '        _storage.decrementMetadata(id);\n', '        _storage.decrementMetadata(metadata.partner);\n', '            \n', '        //Emit events\n', '        emit Log(msg.sender, id, "split", msg.value, metadata.partner);\n', '    }\n', '\n', '    /**\n', '     * @dev Rename a blob\n', '     * @param id The id of blob\n', '     * @param chars The name to be set\n', '     */\n', '    function rename(uint id, uint[] memory chars) public payable\n', '    {\n', '        //Characters should be valid\n', '        require(chars.length == 8);\n', '        for (uint i = 0; i < 8; i++) {\n', '            require(chars[i] >= 0 && chars[i] <= 62);\n', '        }\n', '\n', '        //Building name\n', '        LibBlob.Name memory name_params;\n', '        name_params.char1 = chars[0];\n', '        name_params.char2 = chars[1];\n', '        name_params.char3 = chars[2];\n', '        name_params.char4 = chars[3];\n', '        name_params.char5 = chars[4];\n', '        name_params.char6 = chars[5];\n', '        name_params.char7 = chars[6];\n', '        name_params.char8 = chars[7];\n', '        uint name = LibBlob.nameToUint(name_params);\n', '\n', '        //Get current name\n', '        uint current = _storage.getName(id);\n', '\n', '        //The new name must be different from current name\n', '        require(name != current);\n', '\n', '        //The new name must be unique\n', '        require(!_storage.isReserved(name));\n', '\n', '        //The token must be owned by the sender\n', '        require(msg.sender == _definition.ownerOf(id));\n', '\n', '        //Blob must not be currently listed\n', '        require(_storage.getListing(id) == 0);\n', '\n', '        //Charge for the action\n', '        if (msg.value > 0) {\n', '            require(msg.value == _calcTransformationNativeFee());\n', '        } else {\n', '            _formation.burn(msg.sender, _transformation_token_fee);\n', '        }\n', '        \n', '        //Release the previously reserved name\n', '        if (current > 0) {\n', '            _storage.setReservation(current, false);\n', '        }\n', '\n', '        //Set new name\n', '        _storage.setReservation(name, true);\n', '        _storage.setName(id, name);\n', '\n', '        //Emit events\n', '        emit Log(msg.sender, id, "rename", msg.value, name);\n', '    }\n', '\n', '    /**\n', '     * @dev List blob for selling\n', '     * @param id The id of blob\n', '     * @param price The selling price\n', '     */\n', '    function list(uint id, uint price) public\n', '    {\n', '        //The price needs to be set\n', '        require(price > 0);\n', '\n', '        //Blob must be owned by the sender\n', '        require(msg.sender == _definition.ownerOf(id));\n', '\n', '        //Set selling price\n', '        _storage.setListing(id, price); \n', '\n', '        //Emit events\n', '        emit Log(msg.sender, id, "list", price, 0);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraw blob from selling\n', '     * @param id The id of blob\n', '     */\n', '    function withdraw(uint id) public\n', '    {\n', '        //Blob must be owned by the sender\n', '        require(msg.sender == _definition.ownerOf(id));\n', '\n', '        //Blob must be currently listed\n', '        require(_storage.getListing(id) > 0);\n', '\n', '        //Reset selling price\n', '        _storage.setListing(id, 0); \n', '\n', '        //Emit events\n', '        emit Log(msg.sender, id, "withdraw", 0, 0);           \n', '    }\n', '\n', '    /**\n', '     * @dev Buy a listed blob\n', '     * @param id The id of blob\n', '     */\n', '    function buy(uint id) public payable\n', '    {\n', '        uint price = _storage.getListing(id);\n', '        uint minter_share = price.mul(_minter_selling_fee_percentage).div(100);\n', '        uint seller_share = price.sub(minter_share);\n', '        address payable seller = address(uint160(_definition.ownerOf(id)));\n', '\n', '        //Blob must not be owned by the sender\n', '        require(msg.sender != seller);\n', '\n', '        //Blob must be currently listed\n', '        require(price > 0);\n', '\n', '        //Must send the buying amount\n', '        require(msg.value == price);\n', '\n', '        //Settle payments\n', '        seller.transfer(seller_share);\n', '        _storage.getMinter(id).transfer(minter_share);\n', '\n', '        //Reset selling price\n', '        _storage.setListing(id, 0); \n', '\n', '        //Transfer ownership\n', '        _definition.move(seller, msg.sender, id);\n', '\n', '        //Emit events\n', '        emit Log(msg.sender, id, "buy", price, 0);           \n', '    }\n', '\n', '    /**\n', '     * @dev Get common details of the system\n', '     * @return The details\n', '     */\n', '    function getSystemDetails() public view returns (uint[8] memory)\n', '    {\n', '        uint minted = _definition.totalSupply();\n', '\n', '        return [\n', '            _calcSegmentId(minted),\n', '            _calcSegmentPrice(minted),\n', '            _calcSegmentGrant(minted),\n', '            _calcTransformationNativeFee(),\n', '            _formation.maxSupply(),\n', '            _formation.totalSupply(),\n', '            _definition.maxSupply(),\n', '            _definition.totalSupply()\n', '        ];\n', '    }\n', '\n', '    /**\n', '     * @dev Get account related details of the system\n', '     * @param account The account to get details about\n', '     * @return The details\n', '     */\n', '    function getAccountDetails(address account) public view returns (uint[2] memory)\n', '    {\n', '        return [\n', '            _definition.balanceOf(account),\n', '            _formation.balanceOf(account)\n', '        ];\n', '    }\n', '\n', '    /**\n', '     * @dev Get blob details\n', '     * @return The details\n', '     */\n', '    function getBlobDetails(uint id) public view returns (uint[] memory, uint[] memory, uint[] memory, uint, address, address)\n', '    {\n', '        return (\n', '            getBlobLatestMetadataDetails(id),\n', '            getBlobPreviousMetadataDetails(id),\n', '            getBlobNameDetails(id),\n', '            _storage.getListing(id),\n', '            _storage.getMinter(id),\n', '            _definition.ownerOf(id)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Get blob latest metadata details\n', '     * @return The details\n', '     */\n', '    function getBlobLatestMetadataDetails(uint id) public view returns (uint[] memory)\n', '    {\n', '        LibBlob.Metadata memory latest_metadata = LibBlob.uintToMetadata(_storage.getLatestMetadata(id));\n', '        uint[] memory latest_metadata_params = new uint[](8);\n', '        latest_metadata_params[0] = latest_metadata.partner;\n', '        latest_metadata_params[1] = latest_metadata.level;\n', '        latest_metadata_params[2] = latest_metadata.param1;\n', '        latest_metadata_params[3] = latest_metadata.param2;\n', '        latest_metadata_params[4] = latest_metadata.param3;\n', '        latest_metadata_params[5] = latest_metadata.param4;\n', '        latest_metadata_params[6] = latest_metadata.param5;\n', '        latest_metadata_params[7] = latest_metadata.param6;\n', '\n', '        return latest_metadata_params;\n', '    }\n', '\n', '    /**\n', '     * @dev Get blob previous metadata details\n', '     * @return The details\n', '     */\n', '    function getBlobPreviousMetadataDetails(uint id) public view returns (uint[] memory)\n', '    {\n', '        LibBlob.Metadata memory previous_metadata = LibBlob.uintToMetadata(_storage.getPreviousMetadata(id));\n', '        uint[] memory previous_metadata_params = new uint[](8);\n', '        previous_metadata_params[0] = previous_metadata.partner;\n', '        previous_metadata_params[1] = previous_metadata.level;\n', '        previous_metadata_params[2] = previous_metadata.param1;\n', '        previous_metadata_params[3] = previous_metadata.param2;\n', '        previous_metadata_params[4] = previous_metadata.param3;\n', '        previous_metadata_params[5] = previous_metadata.param4;\n', '        previous_metadata_params[6] = previous_metadata.param5;\n', '        previous_metadata_params[7] = previous_metadata.param6;\n', '\n', '        return previous_metadata_params;\n', '    }\n', '\n', '    /**\n', '     * @dev Get blob name details\n', '     * @return The details\n', '     */\n', '    function getBlobNameDetails(uint id) public view returns (uint[] memory)\n', '    {\n', '        LibBlob.Name memory name = LibBlob.uintToName(_storage.getName(id));\n', '        uint[] memory name_params = new uint[](8);\n', '        name_params[0] = name.char1;\n', '        name_params[1] = name.char2;\n', '        name_params[2] = name.char3;\n', '        name_params[3] = name.char4;\n', '        name_params[4] = name.char5;\n', '        name_params[5] = name.char6;\n', '        name_params[6] = name.char7;\n', '        name_params[7] = name.char8;\n', '\n', '        return name_params;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the current mining segment id\n', '     * @param minted The number of tokens minted so far\n', '     * @return uint The current mining segment id\n', '     */\n', '    function _calcSegmentId(uint minted) private pure returns (uint)\n', '    {\n', '        return minted.div(_tokens_per_segment);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the current mining segment price\n', '     * @param minted The number of tokens minted so far\n', '     * @return uint The current mining segment price\n', '     */\n', '    function _calcSegmentPrice(uint minted) private pure returns (uint)\n', '    {\n', '        return _minting_starting_price.add(_calcSegmentId(minted).mul(_minting_price_increment));\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the current mining segment formation tokens grant\n', '     * @param minted The number of tokens minted so far\n', '     * @return uint The current mining segment formation tokens grant\n', '     */\n', '    function _calcSegmentGrant(uint minted) private pure returns (uint)\n', '    {\n', '        uint multiplier = _calcSegmentId(minted).add(2);\n', '        return _minting_grant_multiplier.mul(multiplier.mul(multiplier.add(1))).div(2);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the native fee that should be payed for transformation\n', '     * @return uint The current transformation native fee\n', '     */\n', '    function _calcTransformationNativeFee() private view returns (uint)\n', '    {\n', '        uint burnt_supply = _formation.maxSupply().sub(_formation.totalSupply());\n', '        uint transformation_segment = burnt_supply.div(_transformation_native_fee_gap);\n', '\n', '        return _transformation_native_fee_min.add(transformation_segment.mul(_transformation_native_fee_increment));\n', '    }\n', '}']