['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-17\n', '*/\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in ``owner``'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '      * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '      *\n', '      * Requirements:\n', '      *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '      * - `tokenId` token must exist and be owned by `from`.\n', '      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n', '      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '      *\n', '      * Emits a {Transfer} event.\n', '      */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IGoaldToken is IERC20 {\n', '    /** Gets the base url for Goald metadata. */\n', '    function getBaseTokenURI() external view returns (string memory);\n', '\n', '    /** Gets the total number of deployed Goalds. */\n', '    function getGoaldCount() external view returns (uint256);\n', '\n', "    /** Returns the current stage of the DAO's governance. */\n", '    function getGovernanceStage() external view returns (uint256);\n', '\n', '    /** Gets the current DAO address. */\n', '    function getLatestDAO() external view returns (address);\n', '\n', '    /** Called by the latest DAO when a new Goald has been deployed. */\n', '    function goaldDeployed(address recipient, address goaldAddress) external returns (uint256);\n', '}\n', '\n', '/** Tracks all DAO functionality for the Goald token. Each version of the DAO manages its own balances and rewards. */\n', 'contract GoaldDAO {\n', '    /** @dev The number of decimals is small to allow for rewards of tokens with substantially different exchange rates. */\n', '    uint8 private constant DECIMALS = 2;\n', '\n', '    /** \n', '     * @dev The minimum amount of tokens necessary to be eligible for a reward. This is "one token", considering decimal places. We\n', '     * are choosing two decimal places because we are initially targeting WBTC, which has 8. This way we can do a minimum reward ratio\n', '     * of 1 / 1,000,000 of a WBTC, relative to our token. So at $25,000 (2020 value), the minimum reward would be $250 (assuming we\n', '     * have issued all 10,000 tokens).\n', '     */\n', '    uint256 private constant REWARD_THRESHOLD = 10**uint256(DECIMALS);\n', '\n', '    /** @dev The current owner of the proxy. This will become the Goald token (as delgated DAO manager) when the DAO is initiated. */\n', '    address public  _owner;\n', '\n', "    /** @dev Which Uniswap router we're currently using for trades. */\n", '    address private _uniswapRouterAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n', '\n', '    /** @dev The address of the Goald token. Set in constructer and should never have to be changed. */\n', '    address public  _goaldToken = 0x5Cd9207c3A81FB7A73c9D71CDd413B85b4a7D045;\n', '\n', '\n', '    /** @dev Which deployers are allowed to create new Goalds. We use a mapping for O(1) lookups and an array for complete list. */\n', '    mapping (address => bool) private _allowedDeployersMap;\n', '    address[] private _allowedDeployersList;\n', '\n', '    /** @dev The addresses of all deployed goalds. */\n', '    address[] private _deployedGoalds;\n', '\n', '    /** @dev The owner of each deployed goald. */\n', '    address[] private _goaldOwners;\n', '\n', '    /** @dev The id offset to account for Goalds deployed in previous versions of the DAO. */\n', '    uint256   private _idOffset;\n', '\n', '\n', '    /** @dev Which ERC20 contract will be used for rewards (e.g., WBTC). */\n', '    address   private _rewardToken = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599; // WBTC\n', '\n', '    /** @dev How many holders are eligible for rewards. This is used to determine how much should be reserved. */\n', '    uint256   private _rewardHolders;\n', '\n', '    /** @dev How much of the current balance is reserved for rewards. */\n', '    uint256   private _reservedRewardBalance;\n', '\n', '    /** @dev How many holders have yet to withdraw a given reward. */\n', '    uint256[] private _rewardHolderCounts;\n', '\n', '    /** @dev The multipliers for each reward. */\n', '    uint256[] private _rewardMultipliers;\n', '\n', '    /** @dev The remaining reserves for a given reward. */\n', '    uint256[] private _rewardReserves;\n', '\n', '    /** @dev The minimum reward index to check eligibility against for a given address. */\n', '    mapping (address => uint256) private _minimumRewardIndex;\n', '    \n', '    /** @dev The available reward balance for a given address. */\n', '    mapping (address => uint256) private _rewardBalance;\n', '\n', '    /**\n', '     * @dev The stage of the governance token. Tokens can be issued based on deployments regardless of what stage we are in. Identical\n', '     * to `GoaldToken.governanceStage`. Cannot be set directly.\n', '     *\n', '     * Statuses:\n', '     *      0: Created, with no governance protocol initiated. The initial governance issuance can be claimed.\n', '     *      1: Initial governance issuance has been claimed.\n', '     *      2: The governance protocal has been initiated.\n', '     *      3: All governance tokens have been issued.\n', '     */\n', '    uint256 private constant STAGE_INITIAL               = 0;\n', '    uint256 private constant STAGE_ISSUANCE_CLAIMED      = 1;\n', '    uint256 private constant STAGE_DAO_INITIATED         = 2;\n', '    uint256 private constant STAGE_ALL_GOVERNANCE_ISSUED = 3;\n', '    uint256 private _governanceStage;\n', '\n', "    // Reentrancy reversions are the only calls to revert (in this contract) that do not have reasons. We add a third state, 'frozen'\n", '    // to allow for locking non-admin functions. The contract may be permanently frozen if it has been upgraded.\n', '    uint256 private constant RE_NOT_ENTERED = 1;\n', '    uint256 private constant RE_ENTERED     = 2;\n', '    uint256 private constant RE_FROZEN      = 3;\n', '    uint256 private _status;\n', '\n', '    // Set when the DAO is ready to deploy things.\n', '    uint256 private constant NOT_READY = 0;\n', '    uint256 private constant READY = 1;\n', '    uint256 private _ready;\n', '\n', '    constructor() public {\n', '        _owner = msg.sender;\n', '\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /// Events ///\n', '\n', '    event RewardCreated(uint256 multiplier, string reason);\n', '\n', '    /// Admin Functions ///\n', '\n', '    /** Adds more allowed deployers. */\n', '    function addAllowedDeployers(address[] calldata newDeployers) external {\n', '        // Reentrancy guard.\n', '        require(_status == RE_NOT_ENTERED || _status == RE_FROZEN);\n', '        require(msg.sender == _owner, "Not owner");\n', '\n', '        uint256 count = newDeployers.length;\n', '        uint256 index;\n', '        address newDeployer;\n', '        for (; index < count; index++) {\n', '            newDeployer = newDeployers[index];\n', '\n', "            // Don't revert if it already exists.\n", '            if (!_allowedDeployersMap[newDeployer]) {\n', '                // Add the deployer.\n', '                _allowedDeployersMap[newDeployer] = true;\n', '                _allowedDeployersList.push(newDeployer);\n', '            }\n', '        }\n', '    }\n', '\n', '    /** Freezes the proxy contract. Only admin functions can be called. */\n', '    function freeze() external {\n', '        // Reentrancy guard.\n', '        require(\n', '               _status == RE_NOT_ENTERED\n', '            && msg.sender == _owner\n', '        );\n', '\n', '        _status = RE_FROZEN;\n', '    }\n', '\n', '    /** Called if the DAO manager is no longer a holder after burning the initialization tokens. */\n', '    function initializeDecreasesHolders() external {\n', '        // Reentrancy guard. Caller must be goald token. Must be non-initialized.\n', '        require(\n', '               _status == RE_NOT_ENTERED\n', '            && msg.sender == _goaldToken\n', '            && _governanceStage == STAGE_ISSUANCE_CLAIMED\n', '        );\n', '\n', '        _rewardHolders --;\n', '    }\n', '\n', '    /** Called if the DAO manager is now a holder after claiming the initialization tokens. */\n', '    function issuanceIncreasesHolders() external {\n', "        // Reentrancy guard. Caller must be goald token. Issuance can't be claimed.\n", '        require(\n', '               _status == RE_NOT_ENTERED\n', '            && msg.sender == _goaldToken\n', '            && _governanceStage == STAGE_INITIAL\n', '        );\n', '\n', '        _rewardHolders ++;\n', '    }\n', '\n', '    /** Makes this DAO ready for deployments (regardless of whether or not there are authorized ones). */\n', '    function makeReady(uint256 governanceStage, uint256 idOffset) external {\n', '        require(\n', '               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\n', '            && msg.sender == _goaldToken                           // Not Goald token.\n', '            && _ready == NOT_READY                                 // Already ready.\n', '        );\n', '\n', '        _governanceStage = governanceStage;\n', '        _idOffset = idOffset;\n', '        _ready = READY;\n', '        \n', '        // The owner of this contract depends on whether or not the DAO has been initialized.\n', '        if (governanceStage >= STAGE_DAO_INITIATED) {\n', '            _owner = _goaldToken;\n', '        }\n', '    }\n', '\n', '    /** Removes an allowed deployer by index. We require the index for no-traversal removal against a known address. */\n', '    function removeAllowedDeployer(address deployerAddress, uint256 index) external {\n', '        address indexAddress = _allowedDeployersList[index];\n', '        require(\n', '               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\n', '            && msg.sender == _owner                                // Not owner.\n', '            && indexAddress == deployerAddress                     // Address mismatch.\n', '            && _allowedDeployersMap[deployerAddress]               // Already restricted.\n', '        );\n', '\n', '        // Remove the deployer.\n', '        _allowedDeployersMap[deployerAddress] = false;\n', '        _allowedDeployersList[index] = _allowedDeployersList[_allowedDeployersList.length - 1];\n', '        _allowedDeployersList.pop();\n', '    }\n', '\n', '    /** Updates the goald token. Should never have to be called. */\n', '    function setGoaldToken(address newAddress) external {\n', '        require(\n', '               _status == RE_FROZEN        // Reentrancy guard.\n', '            && msg.sender == _owner        // Caller must be owner.\n', '            && newAddress != address(0)    // Invalid address.\n', '            && newAddress != address(this) // Invalid address.\n', '        );\n', '\n', '        // The DAO has been initialized, so carry over the new address.\n', '        if (_owner == _goaldToken) {\n', '            _owner = newAddress;\n', '        }\n', '\n', '        _goaldToken = newAddress;\n', '    }\n', '\n', "    /** Update the owner, so long as the DAO hasn't been initialized. */\n", '    function setOwner(address newOwner) external {\n', '        require(\n', '               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\n', "            && msg.sender == _owner                                // Caller can't be owner.\n", "            && _owner != _goaldToken                               // Can't be initialized.\n", '            && newOwner != address(0)                              // Validate new owner.\n', '        );\n', '\n', '        _owner = newOwner;\n', '    }\n', '\n', '    /**\n', '     * The uniswap router for converting tokens within this DAO. Setting to the zero address disables swapping for newly created\n', '     * Goalds, but their owners can still manually change it for each Goald.\n', '     */\n', '    function setUniswapRouterAddress(address newAddress) external {\n', '        require(\n', '               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\n', '            && msg.sender == _owner                                // Caller must be owner.\n', '        );\n', '\n', '        _uniswapRouterAddress = newAddress;\n', '    }\n', '\n', '    /** Unfreezes the proxy contract. Non-admin functions can again be called. */\n', '    function unfreeze() external {\n', '        require(\n', '               _status == RE_FROZEN // Reentrancy guard.\n', '            && msg.sender == _owner // Caller must be owner.\n', '        );\n', '\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /// Goald Deployers ///\n', '\n', '    /** Returns the address of the deployer at the specified index. */\n', '    function getDeployerAt(uint256 index) external view returns (address) {\n', '        return _allowedDeployersList[index];\n', '    }\n', '\n', '    /** Returns the number of allowed deployers. */\n', '    function getDeployerCount() external view returns (uint256) {\n', '        return _allowedDeployersList.length;\n', '    }\n', '\n', '    /** Returns the address and owner of the Goald at the specified index. */\n', '    function getGoaldAt(uint256 index) external view returns (address[2] memory) {\n', '        return [_deployedGoalds[index], _goaldOwners[index]];\n', '    }\n', '\n', '    /** Returns the number of goalds deployed from this DAO. */\n', '    function getGoaldCount() external view returns (uint256) {\n', '        return _deployedGoalds.length;\n', '    }\n', '\n', '    /** Returns the ID offset of the Goalds tracked by this DAO. */\n', '    function getIDOffset() external view returns (uint256) {\n', '        return _idOffset;\n', '    }\n', '\n', '    /** Returns the next Goald id so that we have a unique ID for each NFT, regardless of which deployer was used. */\n', '    function getNextGoaldId() external view returns (uint256) {\n', '        return IGoaldToken(_goaldToken).getGoaldCount() + 1;\n', '    }\n', '\n', '    /** Returns the current address that fees will be sent to. */\n', '    function getProxyAddress() external view returns (address) {\n', '        return IGoaldToken(_goaldToken).getLatestDAO();\n', '    }\n', '\n', '    /** Return the metadata for a specific Goald. */\n', '    function getTokenURI(uint256 tokenId) external view returns (string memory) {\n', "        // Inspired by OraclizeAPI's implementation - MIT licence\n", '        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n', '\n', '        uint256 temp = tokenId;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        uint256 index = digits - 1;\n', '        temp = tokenId;\n', '        while (temp != 0) {\n', '            buffer[index--] = byte(uint8(48 + temp % 10));\n', '            temp /= 10;\n', '        }\n', '\n', '        return string(abi.encodePacked(IGoaldToken(_goaldToken).getBaseTokenURI(), string(buffer)));\n', '    }\n', '\n', '    /** Returns the address of the uniswap router. */\n', '    function getUniswapRouterAddress() external view returns (address) {\n', '        return _uniswapRouterAddress;\n', '    }\n', '\n', '    /** Returns if the address is an allowed deployer. */\n', '    function isAllowedDeployer(address deployer) external view returns (bool) {\n', '        return _allowedDeployersMap[deployer];\n', '    }\n', '\n', '    /**\n', '     * Called when a deployer deploys a new Goald. Currently we use this to distribute the governance token according to the following\n', '     * schedule. An additional 120,000 tokens will be claimable by the deployer of this proxy. This will create a total supply of\n', '     * 210,000 tokens. Once the governance protocal is set up, 110,000 tokens will be burned to initiate that mechanism. That will leave\n', '     * 10% ownership for the deployer of the contract, with the remaining 90% disbused on Goald creations. No rewards can be paid out\n', '     * before the governance protocal has been initiated.\n', '     *\n', '     *      # Goalds    # Tokens\n', '     *       0 -  9       1000\n', '     *      10 - 19        900\n', '     *      20 - 29        800\n', '     *      30 - 39        700\n', '     *      40 - 49        600\n', '     *      50 - 59        500\n', '     *      60 - 69        400\n', '     *      70 - 79        300\n', '     *      80 - 89        200\n', '     *      90 - 99        100\n', '     *       < 3600         10\n', '     */\n', '    function notifyGoaldCreated(address creator, address goaldAddress) external {\n', '        // Reentrancy guard.\n', '        require(_status == RE_NOT_ENTERED);\n', '        _status = RE_ENTERED;\n', '\n', '        require(_allowedDeployersMap[msg.sender], "Not allowed deployer");\n', '\n', '        IGoaldToken goaldToken = IGoaldToken(_goaldToken);\n', '        require(goaldToken.getLatestDAO() == address(this), "Not latest DAO");\n', '\n', '        // Must be ready for deployment.\n', '        require(_ready == READY, "Not ready");\n', '\n', '        // All governance tokens have been issued.\n', '        if (_governanceStage == STAGE_ALL_GOVERNANCE_ISSUED) {\n', '            goaldToken.goaldDeployed(creator, goaldAddress);\n', '\n', '            // Track the goald and its owner.\n', '            _deployedGoalds.push(goaldAddress);\n', '            _goaldOwners.push(creator);\n', '\n', '            return;\n', '        }\n', '\n', '        // We might be creating a new holder.\n', '        bool increaseHolders;\n', '        if (goaldToken.balanceOf(creator) < REWARD_THRESHOLD) {\n', '            increaseHolders = true;\n', '        }\n', '\n', '        // Get the amount of tokens minted.\n', '        uint256 amount = goaldToken.goaldDeployed(creator, goaldAddress);\n', '\n', "        // It's possible we have issued all governance tokens without the DAO initiated.\n", '        if (amount > 0) {\n', '            // Update their reward balance.\n', '            _checkRewardBalance(creator);\n', '\n', '            if (increaseHolders) {\n', '                _rewardHolders ++;\n', '            }\n', '        }\n', '\n', '        // We have issued all tokens, so move to the last stage of governance. This will short circuit this function on future calls.\n', '        // This will result in unnecessary gas if the DAO is never initiated and all 3600 token-earning goalds are created. But the\n', '        // DAO should be initiated long before that.\n', '        else if (_governanceStage == STAGE_DAO_INITIATED) {\n', '            _governanceStage = STAGE_ALL_GOVERNANCE_ISSUED;\n', '        }\n', '\n', '        // Track the goald and its owner.\n', '        _deployedGoalds.push(goaldAddress);\n', '        _goaldOwners.push(creator);\n', '\n', '        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * Updates the owner of a deployed Goald.\n', '     * Due to a bug in GoaldFlexibleDeployer, id here is off by one (it is the index)\n', '     */\n', '    function setGoaldOwner(uint256 id) external {\n', '        // Reentrancy guard.\n', '        require(_status == RE_NOT_ENTERED);\n', '        _status = RE_ENTERED;\n', '\n', '        // Get the index of the Goald.\n', '        uint256 index = id - _idOffset;\n', '        require(index < _deployedGoalds.length, "Invalid id");\n', '\n', "        // We don't have the address as a parameter to make sure we have the correct value stored here.\n", '        address owner = IERC721(_deployedGoalds[index]).ownerOf(id + 1);\n', '        _goaldOwners[index] = owner;\n', '\n', '        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /// Governance ///\n', '\n', '    /** Uses Uniswap to convert all held amount of a specific token into the reward token, using the provided path. */\n', '    function convertToken(address[] calldata path, uint256 deadline) external {\n', '        require(\n', '               _status == RE_NOT_ENTERED             // Reentrancy guard.\n', '            && msg.sender == _owner                  // Caller must be owner.\n', '            && path[path.length - 1] == _rewardToken // Last must be reward token. Array is calldata; this avoids gas for pushing.\n', '        );\n', '        _status = RE_ENTERED;\n', '\n', '        // Swap the tokens.\n', '        IERC20 tokenContract = IERC20(path[0]);\n', '        uint256 amount = tokenContract.balanceOf(address(this));\n', '        tokenContract.approve(_uniswapRouterAddress, amount);\n', '        IUniswapV2Router02(_uniswapRouterAddress).swapExactTokensForTokens(amount, 1, path, address(this), deadline);\n', '\n', '        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * Uses Uniswap to convert all held amount of specific tokens into the reward token. The tokens must have a direct path,\n', '     * otherwise the intermediary is used for increased liquidity.\n', '     */\n', '    function convertTokens(address[] calldata tokenAddresses, address intermediaryTokenOrZeroAddress, uint256 deadline) external {\n', '        require(\n', '               _status == RE_NOT_ENTERED             // Reentrancy guard.\n', '            && msg.sender == _owner                  // Caller must be owner.\n', '        );\n', '        _status = RE_ENTERED;\n', '\n', '        // The path between a given token and the reward token within Uniswap.\n', '        address[] memory path;\n', '        if (intermediaryTokenOrZeroAddress != address(0)) {\n', '            path = new address[](3);\n', '            path[1] = intermediaryTokenOrZeroAddress;\n', '            path[2] = _rewardToken;\n', '        } else {\n', '            path = new address[](2);\n', '            path[1] = _rewardToken;\n', '        }\n', '        IUniswapV2Router02 uniswap = IUniswapV2Router02(_uniswapRouterAddress);\n', '\n', '        address tokenAddress;\n', '        IERC20 tokenContract;\n', '        \n', '        uint256 amount;\n', '        uint256 count = tokenAddresses.length;\n', '        for (uint256 i; i < count; i ++) {\n', '            // Validate the token.\n', '            tokenAddress = tokenAddresses[i];\n', '            require(\n', '                   tokenAddress != address(0)\n', '                && tokenAddress != address(this)\n', '                && tokenAddress != _rewardToken\n', '            , "Invalid address");\n', '\n', '            // Make sure this contract actually has a balance.\n', '            tokenContract = IERC20(tokenAddress);\n', '            amount = tokenContract.balanceOf(address(this));\n', '            if (amount == 0) {\n', '                continue;\n', '            }\n', '\n', '            // Swap the tokens.\n', '            tokenContract.approve(_uniswapRouterAddress, amount);\n', '            path[0] = tokenAddress;\n', '            uniswap.swapExactTokensForTokens(amount, 1, path, address(this), deadline);\n', '        }\n', '\n', '        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /** This should always be the same as `GoaldToken.getGovernanceStage()`. */\n', '    function getGovernanceStage() external view returns (uint256) {\n', '        return _governanceStage;\n', '    }\n', '\n', '    /** Called when the DAO has been initialized. */\n', '    function updateGovernanceStage() external {\n', '        uint256 governanceStage = IGoaldToken(_goaldToken).getGovernanceStage();\n', '\n', '        // Make sure the owner is updated to the goald token if the DAO has been initiated.\n', '        if (governanceStage >= STAGE_DAO_INITIATED && _owner != _goaldToken) {\n', '            _owner = _goaldToken;\n', '        }\n', '\n', '        _governanceStage = governanceStage;\n', '    }\n', '\n', '    /**\n', '     * Changes which token will be the reward token. This can only happen if there is no balance in reserve held for rewards. If a\n', '     * change is desired despite there being excess rewards, call `withdrawReward()` on behalf of each holder to drain the reserve.\n', '     */\n', '    function setRewardToken(address newToken) external {\n', '        require(\n', '               (_status == RE_NOT_ENTERED || _status == RE_FROZEN) // Reentrancy guard.\n', '            && msg.sender == _owner        // Not owner.\n', "            && newToken != address(0)      // Can't be zero address.\n", "            && newToken != address(this)   // Can't be this address.\n", '            && _reservedRewardBalance == 0 // Have reserved balance.\n', '        );\n', '\n', '        _rewardToken = newToken;\n', '    }\n', '\n', '    /// Rewards ///\n', '\n', '    /**\n', '     * Check which rewards a given address is eligible for, and update their current reward balance to reflect that total. Since\n', '     * balances are static until transferred (or minted in the case of a new Goald being created), this function is called before\n', "     * any change to a given addresses' balance. Ths will bring them up to date with any past, unclaimed rewards. Any future rewards\n", '     * will be dependant on their balance after the change.\n', '     */\n', '    function _checkRewardBalance(address holder) internal {\n', '        // There is no need for reentrancy since this only updates the `_rewardBalance` for a given holder according to the amounts\n', '        // they are already owed according to the current state. If this is an unexpected reentrant call, then that holder gets the\n', '        // benefit of this math without having to pay the gas.\n', '\n', '        // The total number of rewards issued.\n', '        uint256 count = _rewardMultipliers.length;\n', '\n', '        // The holder has already claimed all rewards.\n', '        uint256 currentMinimumIndex = _minimumRewardIndex[holder];\n', '        if (currentMinimumIndex == count) {\n', '            return;\n', '        }\n', '\n', '        // The holder is not eligible for a reward according to their current balance.\n', '        uint256 balance = IGoaldToken(_goaldToken).balanceOf(holder);\n', '        if (balance < REWARD_THRESHOLD) {\n', '            // Mark that they have been checked for all rewards.\n', '            if (currentMinimumIndex < count) {\n', '                _minimumRewardIndex[holder] = count;\n', '            }\n', '\n', '            return;\n', '        }\n', '\n', "        // Calculate the balance increase according to which rewards the holder has yet to claim. We don't change how much is held in\n", '        // reserve, even if the balance would close out a given reward. Those tokens must still be held until such time as the holder\n', '        // chooses to claim (or someone claims on their behalf).\n', '        uint256 multiplier;\n', '        uint256 totalMultiplier;\n', '        for (; currentMinimumIndex < count; currentMinimumIndex ++) {\n', "            // This can never overflow since a reward can't be created unless there is enough reserve balance to cover its\n", '            // multiplier, which already checks for overflows, likewise `multiplier * balance` can never overflow.\n', '            multiplier = _rewardMultipliers[currentMinimumIndex];\n', '            totalMultiplier += multiplier;\n', '\n', '            // Close out this reward.\n', '            if (_rewardHolderCounts[currentMinimumIndex] == 1) {\n', '                _rewardHolderCounts[currentMinimumIndex] = 0;\n', '                _rewardReserves[currentMinimumIndex] = 0;\n', "                // We don't wipe `_rewardMultipliers` here despite this being the last holder, so we have a historical record.\n", '            } else {\n', '                _rewardHolderCounts[currentMinimumIndex]--;\n', '                _rewardReserves[currentMinimumIndex] -= multiplier * balance;\n', '            }\n', '        }\n', '        _minimumRewardIndex[holder] = count;\n', '\n', '        // Update their claimable balance.\n', '        uint256 currentBalance = _rewardBalance[holder];\n', '        require(currentBalance + (totalMultiplier * balance) > currentBalance, "Balance overflow");\n', '        _rewardBalance[holder] = currentBalance + (totalMultiplier * balance);\n', '    }\n', '\n', '    /**\n', '     * Creates a new reward. Rewards are only paid out to holders who have at least "one token" at time of creation. The reward\n', '     * is a multiplier, representing how many reward tokens (e.g., WBTC) should be paid out for one governance token. reward\n', '     * eligibility is only updated in state in two cases:\n', '     *      1) When a reward is being withdrawn (in which it is set to zero).\n', '     *      2) When the governance token is transferred (balances are checked before the transfer, on both sender and recipient).\n', '     */\n', '    function createReward(uint256 multiplier, string calldata reason) external {\n', '        uint256 holders = _rewardHolders;\n', '        require(\n', '               _status == RE_NOT_ENTERED               // Reentrancy guard.\n', '            && msg.sender == _owner                    // Not owner.\n', '            && _governanceStage >= STAGE_DAO_INITIATED // DAO not initiated.\n', '            && multiplier > 0                          // Multiplier must be > 0.\n', '            && holders > 0                             // Must have a holder\n', '        );\n', '        _status = RE_ENTERED;\n', '\n', '        // Make sure we can actually create a reward with that amount. This balance of the reward token at this proxy address should\n', '        // never decrease except when rewards are claimed by holders.\n', '        uint256 reservedRewardBalance = _reservedRewardBalance;\n', '        uint256 currentBalance = IERC20(_rewardToken).balanceOf(address(this));\n', '        require(currentBalance >= reservedRewardBalance, "Current reserve insufficient");\n', '        uint256 reserveIncrease = IGoaldToken(_goaldToken).totalSupply() * multiplier;\n', '        require(reserveIncrease <= (currentBalance - reservedRewardBalance), "Multiplier too large");\n', '\n', '        // Increase the reserve.\n', '        require((reservedRewardBalance + reserveIncrease) > reservedRewardBalance, "Reserved overflow error");\n', '        _reservedRewardBalance += reserveIncrease;\n', '\n', '        // Keep track of the holders, reserve, and multiplier for this reward. These values will not increase after being set here.\n', '        _rewardHolderCounts.push(holders);\n', '        _rewardMultipliers.push(multiplier);\n', '        _rewardReserves.push(reserveIncrease);\n', '\n', '        // Hello world!\n', '        emit RewardCreated(multiplier, reason);\n', '\n', '        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /** Returns the reward balance for a holder according to the true state, not the hard state. See: `_checkRewardBalance()`. */\n', '    function getHolderRewardBalance(address holder) external view returns (uint256) {\n', '        uint256 count = _rewardMultipliers.length;\n', '        uint256 balance = IGoaldToken(_goaldToken).balanceOf(holder);\n', '        uint256 rewardBalance = _rewardBalance[holder];\n', '        uint256 currentMinimumIndex = _minimumRewardIndex[holder];\n', '        for (; currentMinimumIndex < count; currentMinimumIndex ++) {\n', '            rewardBalance += _rewardMultipliers[currentMinimumIndex] * balance;\n', '        }\n', '\n', '        return rewardBalance;\n', '    }\n', '\n', '    /** Return the general reward details. */\n', '    function getRewardDetails() external view returns (uint256[4] memory) {\n', '        return [\n', '            uint256(_rewardToken),\n', '            _rewardReserves.length,\n', '            _rewardHolders,\n', '            _reservedRewardBalance\n', '        ];\n', '    }\n', '\n', '    /** Get the details of the reward at the specified index.*/\n', '    function getRewardDetailsAt(uint256 index) external view returns (uint256[3] memory) {\n', '        return [\n', '            _rewardMultipliers[index],\n', '            _rewardHolderCounts[index],\n', '            _rewardReserves[index]\n', '        ];\n', '    }\n', '\n', '    /**\n', "     * Withdraws the current reward balance. The sender doesn't need to have any current balance of the governance token to\n", '     * withdraw, so long as they have a preexisting outstanding balance. This has a provided recipient so that we can drain the\n', '     * reward pool as necessary (e.g., for changing the reward token).\n', '     */\n', '    function withdrawReward(address holder) external {\n', '        // Reentrancy guard. Allow owner to drain the pool even if frozen.\n', '        require(_status == RE_NOT_ENTERED || (_status == RE_FROZEN && msg.sender == _owner));\n', '        _status = RE_ENTERED;\n', '\n', '        // Update their balance.\n', '        _checkRewardBalance(holder);\n', '\n', '        // Revert so gas estimators will show a failure.\n', '        uint256 balance = _rewardBalance[holder];\n', '        require(balance > 0, "No reward balance");\n', '\n', '        // Wipe the balance.\n', '        _rewardBalance[holder] = 0;\n', '        require(_reservedRewardBalance - balance > 0, "Reserved balance underflow");\n', '        _reservedRewardBalance -= balance;\n', '\n', '        // Give them their balance.\n', '        IERC20(_rewardToken).transfer(holder, balance);\n', '\n', '        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /// ERC20 Overrides ///\n', '\n', '    /** Update the reward balances prior to the transfer completing. */\n', '    function preTransfer(address sender, address recipient) external {\n', '        // Reentrancy guard. Caller must be the Goald token.\n', '        require(_status == RE_NOT_ENTERED && msg.sender == _goaldToken);\n', '        _status = RE_ENTERED;\n', '\n', '        // Update the reward balances prior to the transfer for both sender and receiver.\n', '        _checkRewardBalance(sender);\n', '        _checkRewardBalance(recipient);\n', '\n', '        // By storing the original amount once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200).\n', '        _status = RE_NOT_ENTERED;\n', '    }\n', '\n', '    /** Updates holder counts after doing a transfer. */\n', '    function postTransfer(address sender, uint256 senderBefore, uint256 senderAfter, uint256 recipientBefore, uint256 recipientAfter) external {\n', '        // Reentrancy guard. Caller must be the Goald token.\n', '        require(\n', '               (_status == RE_NOT_ENTERED || _status == RE_FROZEN)\n', '            && msg.sender == _goaldToken\n', '        );\n', '\n', '        // See if we need to change `_rewardHolders`.\n', '        if        (senderBefore  < REWARD_THRESHOLD && senderAfter >= REWARD_THRESHOLD) {\n', '            _rewardHolders ++;\n', '        } else if (senderBefore >= REWARD_THRESHOLD && senderAfter  < REWARD_THRESHOLD) {\n', '            _rewardHolders --;\n', '        }\n', '        if        (recipientBefore  < REWARD_THRESHOLD && recipientAfter >= REWARD_THRESHOLD) {\n', '            _rewardHolders ++;\n', '        } else if (recipientBefore >= REWARD_THRESHOLD && recipientAfter  < REWARD_THRESHOLD) {\n', '            _rewardHolders --;\n', '        }\n', '\n', '        // The sender has no balance, so clear their minimum index. This should save on total storage space for this contract. We do\n', '        // not clear the reward balance even if their token balance is zero, since they still have a claim to that balance.\n', '        if (senderAfter == 0) {\n', '            _minimumRewardIndex[sender] = 0;\n', '        }\n', '    }\n', '}']