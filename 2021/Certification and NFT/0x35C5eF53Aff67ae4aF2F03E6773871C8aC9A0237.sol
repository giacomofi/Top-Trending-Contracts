['// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   Primitive Connector\n', ' * @author  Primitive\n', ' * @notice  Low-level abstract contract for Primitive Connectors to inherit from.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', '// Open Zeppelin\n', 'import {Context} from "@openzeppelin/contracts/GSN/Context.sol";\n', 'import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', '// Primitive\n', 'import {CoreLib, IOption} from "../libraries/CoreLib.sol";\n', 'import {\n', '    IPrimitiveConnector,\n', '    IPrimitiveRouter,\n', '    IWETH\n', '} from "../interfaces/IPrimitiveConnector.sol";\n', '\n', 'abstract contract PrimitiveConnector is IPrimitiveConnector, Context {\n', "    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\n", '\n', '    IWETH internal _weth; // Canonical WETH9\n', '    IPrimitiveRouter internal _primitiveRouter; // The PrimitiveRouter contract which executes calls.\n', '    mapping(address => mapping(address => bool)) internal _approved; // Stores approvals for future checks.\n', '\n', '    // ===== Constructor =====\n', '\n', '    constructor(address weth_, address primitiveRouter_) public {\n', '        _weth = IWETH(weth_);\n', '        _primitiveRouter = IPrimitiveRouter(primitiveRouter_);\n', "        checkApproval(weth_, primitiveRouter_); // Approves this contract's weth to be spent by router.\n", '    }\n', '\n', '    /**\n', '     * @notice  Reverts if the `option` is not registered in the PrimitiveRouter contract.\n', '     * @dev     Any `option` which is deployed from the Primitive Registry can be registered with the Router.\n', '     * @param   option The Primitive Option to check if registered.\n', '     */\n', '    modifier onlyRegistered(IOption option) {\n', '        require(\n', '            _primitiveRouter.getRegisteredOption(address(option)),\n', '            "PrimitiveSwaps: EVIL_OPTION"\n', '        );\n', '        _;\n', '    }\n', '\n', '    // ===== External =====\n', '\n', '    /**\n', '     * @notice  Approves the `spender` to pull `token` from this contract.\n', '     * @dev     This contract does not hold funds, infinite approvals cannot be exploited for profit.\n', '     * @param   token The token to approve spending for.\n', '     * @param   spender The address to allow to spend `token`.\n', '     */\n', '    function checkApproval(address token, address spender)\n', '        public\n', '        override\n', '        returns (bool)\n', '    {\n', '        if (!_approved[token][spender]) {\n', '            IERC20(token).safeApprove(spender, uint256(-1));\n', '            _approved[token][spender] = true;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // ===== Internal =====\n', '\n', '    /**\n', '     * @notice  Deposits `msg.value` into the Weth contract for Weth tokens.\n', '     * @return  Whether or not ether was deposited into Weth.\n', '     */\n', '    function _depositETH() internal returns (bool) {\n', '        if (msg.value > 0) {\n', '            _weth.deposit.value(msg.value)();\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', "     * @notice  Uses this contract's balance of Weth to withdraw Ether and send it to `getCaller()`.\n", '     */\n', '    function _withdrawETH() internal returns (bool) {\n', '        uint256 quantity = IERC20(address(_weth)).balanceOf(address(this));\n', '        if (quantity > 0) {\n', '            // Withdraw ethers with weth.\n', '            _weth.withdraw(quantity);\n', '            // Send ether.\n', '            (bool success, ) = getCaller().call.value(quantity)("");\n', '            // Revert is call is unsuccessful.\n', '            require(success, "Connector: ERR_SENDING_ETHER");\n', '            return success;\n', '        }\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice  Calls the Router to pull `token` from the getCaller() and send them to this contract.\n', '     * @dev     This eliminates the need for users to approve the Router and each connector.\n', '     * @param   token The token to pull from `getCaller()` into this contract.\n', '     * @param   quantity The amount of `token` to pull into this contract.\n', '     * @return  Whether or not the `token` was transferred into this contract.\n', '     */\n', '    function _transferFromCaller(address token, uint256 quantity)\n', '        internal\n', '        returns (bool)\n', '    {\n', '        if (quantity > 0) {\n', '            _primitiveRouter.transferFromCaller(token, quantity);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', "     * @notice  Pushes this contract's balance of `token` to `getCaller()`.\n", "     * @dev     getCaller() is the original `msg.sender` of the Router's `execute` fn.\n", '     * @param   token The token to transfer to `getCaller()`.\n', '     * @return  Whether or not the `token` was transferred to `getCaller()`.\n', '     */\n', '    function _transferToCaller(address token) internal returns (bool) {\n', '        uint256 quantity = IERC20(token).balanceOf(address(this));\n', '        if (quantity > 0) {\n', '            IERC20(token).safeTransfer(getCaller(), quantity);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice  Calls the Router to pull `token` from the getCaller() and send them to this contract.\n', '     * @dev     This eliminates the need for users to approve the Router and each connector.\n', '     * @param   token The token to pull from `getCaller()`.\n', '     * @param   quantity The amount of `token` to pull.\n', '     * @param   receiver The `to` address to send `quantity` of `token` to.\n', '     * @return  Whether or not `token` was transferred to `receiver`.\n', '     */\n', '    function _transferFromCallerToReceiver(\n', '        address token,\n', '        uint256 quantity,\n', '        address receiver\n', '    ) internal returns (bool) {\n', '        if (quantity > 0) {\n', '            _primitiveRouter.transferFromCallerToReceiver(token, quantity, receiver);\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    /**\n', "     * @notice  Uses this contract's balance of underlyingTokens to mint optionTokens to this contract.\n", '     * @param   optionToken The Primitive Option to mint.\n', '     * @return  (uint, uint) (longOptions, shortOptions)\n', '     */\n', '    function _mintOptions(IOption optionToken) internal returns (uint256, uint256) {\n', '        address underlying = optionToken.getUnderlyingTokenAddress();\n', '        _transferBalanceToReceiver(underlying, address(optionToken)); // Sends to option contract\n', '        return optionToken.mintOptions(address(this));\n', '    }\n', '\n', '    /**\n', "     * @notice  Uses this contract's balance of underlyingTokens to mint optionTokens to `receiver`.\n", '     * @param   optionToken The Primitive Option to mint.\n', '     * @param   receiver The address that will received the minted long and short optionTokens.\n', '     * @return  (uint, uint) Returns the (long, short) option tokens minted\n', '     */\n', '    function _mintOptionsToReceiver(IOption optionToken, address receiver)\n', '        internal\n', '        returns (uint256, uint256)\n', '    {\n', '        address underlying = optionToken.getUnderlyingTokenAddress();\n', '        _transferBalanceToReceiver(underlying, address(optionToken)); // Sends to option contract\n', '        return optionToken.mintOptions(receiver);\n', '    }\n', '\n', '    /**\n', '     * @notice  Pulls underlying tokens from `getCaller()` to option contract, then invokes mintOptions().\n', '     * @param   optionToken The option token to mint.\n', '     * @param   quantity The amount of option tokens to mint.\n', '     * @return  (uint, uint) Returns the (long, short) option tokens minted\n', '     */\n', '    function _mintOptionsFromCaller(IOption optionToken, uint256 quantity)\n', '        internal\n', '        returns (uint256, uint256)\n', '    {\n', '        require(quantity > 0, "ERR_ZERO");\n', '        _transferFromCallerToReceiver(\n', '            optionToken.getUnderlyingTokenAddress(),\n', '            quantity,\n', '            address(optionToken)\n', '        );\n', '        return optionToken.mintOptions(address(this));\n', '    }\n', '\n', '    /**\n', '     * @notice  Multi-step operation to close options.\n', '     *          1. Transfer balanceOf `redeem` option token to the option contract.\n', '     *          2. If NOT expired, pull `option` tokens from `getCaller()` and send to option contract.\n', '     *          3. Invoke `closeOptions()` to burn the options and release underlyings to this contract.\n', '     * @return  The amount of underlyingTokens released to this contract.\n', '     */\n', '    function _closeOptions(IOption optionToken) internal returns (uint256) {\n', '        address redeem = optionToken.redeemToken();\n', '        uint256 short = IERC20(redeem).balanceOf(address(this));\n', '        uint256 long = IERC20(address(optionToken)).balanceOf(getCaller());\n', '        uint256 proportional = CoreLib.getProportionalShortOptions(optionToken, long);\n', '        // IF user has more longs than proportional shorts, close the `short` amount.\n', '        if (proportional > short) {\n', '            proportional = short;\n', '        }\n', '\n', '        // If option is expired, transfer the amt of proportional thats larger.\n', '        if (optionToken.getExpiryTime() >= now) {\n', '            // Transfers the max proportional amount of short options to option contract.\n', '            IERC20(redeem).safeTransfer(address(optionToken), proportional);\n', '            // Pulls the max amount of long options and sends to option contract.\n', '            _transferFromCallerToReceiver(\n', '                address(optionToken),\n', '                CoreLib.getProportionalLongOptions(optionToken, proportional),\n', '                address(optionToken)\n', '            );\n', '        } else {\n', '            // If not expired, transfer all redeem in balance.\n', '            IERC20(redeem).safeTransfer(address(optionToken), short);\n', '        }\n', '        uint outputUnderlyings;\n', '        if(proportional > 0) {\n', '            (, ,  outputUnderlyings) = optionToken.closeOptions(address(this));\n', '        }\n', '        return outputUnderlyings;\n', '    }\n', '\n', '    /**\n', '     * @notice  Multi-step operation to exercise options.\n', '     *          1. Transfer balanceOf `strike` token to option contract.\n', '     *          2. Transfer `amount` of options to exercise to option contract.\n', '     *          3. Invoke `exerciseOptions()` and specify `getCaller()` as the receiver.\n', '     * @dev     If the balanceOf `strike` and `amount` of options are not in correct proportions, call will fail.\n', '     * @param   optionToken The option to exercise.\n', '     * @param   amount The quantity of options to exercise.\n', '     */\n', '    function _exerciseOptions(IOption optionToken, uint256 amount)\n', '        internal\n', '        returns (uint256, uint256)\n', '    {\n', '        address strike = optionToken.getStrikeTokenAddress();\n', '        _transferBalanceToReceiver(strike, address(optionToken));\n', '        IERC20(address(optionToken)).safeTransfer(address(optionToken), amount);\n', '        return optionToken.exerciseOptions(getCaller(), amount, new bytes(0));\n', '    }\n', '\n', '    /**\n', "     * @notice  Transfers this contract's balance of Redeem tokens and invokes the redemption function.\n", '     * @param   optionToken The optionToken to redeem, not the redeem token itself.\n', '     */\n', '    function _redeemOptions(IOption optionToken) internal returns (uint256) {\n', '        address redeem = optionToken.redeemToken();\n', '        _transferBalanceToReceiver(redeem, address(optionToken));\n', '        return optionToken.redeemStrikeTokens(getCaller());\n', '    }\n', '\n', '    /**\n', "     * @notice  Utility function to transfer this contract's balance of `token` to `receiver`.\n", '     * @param   token The token to transfer.\n', '     * @param   receiver The address that receives the token.\n', '     * @return  Returns the quantity of `token` transferred.\n', '     */\n', '    function _transferBalanceToReceiver(address token, address receiver)\n', '        internal\n', '        returns (uint256)\n', '    {\n', '        uint256 quantity = IERC20(token).balanceOf(address(this));\n', '        IERC20(token).safeTransfer(receiver, quantity);\n', '        return quantity;\n', '    }\n', '\n', '    // ===== Fallback =====\n', '\n', '    receive() external payable {\n', '        assert(_msgSender() == address(_weth)); // only accept ETH via fallback from the WETH contract\n', '    }\n', '\n', '    // ===== View =====\n', '\n', '    /**\n', '     * @notice  Returns the Weth contract address.\n', '     */\n', '    function getWeth() public view override returns (IWETH) {\n', '        return _weth;\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns the state variable `_CALLER` in the Primitive Router.\n', '     */\n', '    function getCaller() public view override returns (address) {\n', '        return _primitiveRouter.getCaller();\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns the Primitive Router contract address.\n', '     */\n', '    function getPrimitiveRouter() public view override returns (IPrimitiveRouter) {\n', '        return _primitiveRouter;\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns whether or not `spender` is approved to spend `token`, from this contract.\n', '     */\n', '    function isApproved(address token, address spender)\n', '        public\n', '        view\n', '        override\n', '        returns (bool)\n', '    {\n', '        return _approved[token][spender];\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "./IERC20.sol";\n', 'import "../../math/SafeMath.sol";\n', 'import "../../utils/Address.sol";\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   Primitive Swaps Lib\n', ' * @author  Primitive\n', ' * @notice  Library for calculating different proportions of long and short option tokens.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', 'import {IOption} from "@primitivefi/contracts/contracts/option/interfaces/ITrader.sol";\n', 'import {SafeMath} from "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', 'library CoreLib {\n', '    using SafeMath for uint256; // Reverts on math underflows/overflows\n', '\n', '    /**\n', '     * @dev     Calculates the proportional quantity of long option tokens per short option token.\n', '     * @notice  For each long option token, there is quoteValue / baseValue quantity of short option tokens.\n', '     * @param   optionToken The Option to use to calculate proportional amounts. Each option has different proportions.\n', '     * @param   short The amount of short options used to calculate the proportional amount of long option tokens.\n', '     * @return  The proportional amount of long option tokens based on `short`.\n', '     */\n', '    function getProportionalLongOptions(IOption optionToken, uint256 short)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return short.mul(optionToken.getBaseValue()).div(optionToken.getQuoteValue());\n', '    }\n', '\n', '    /**\n', '     * @dev     Calculates the proportional quantity of short option tokens per long option token.\n', '     * @notice  For each short option token, there is baseValue / quoteValue quantity of long option tokens.\n', '     * @param   optionToken The Option to use to calculate proportional amounts. Each option has different proportions.\n', '     * @param   long The amount of long options used to calculate the proportional amount of short option tokens.\n', '     * @return  The proportional amount of short option tokens based on `long`.\n', '     */\n', '    function getProportionalShortOptions(IOption optionToken, uint256 long)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return long.mul(optionToken.getQuoteValue()).div(optionToken.getBaseValue());\n', '    }\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB)\n', '        internal\n', '        pure\n', '        returns (address token0, address token1)\n', '    {\n', '        require(tokenA != tokenB, "UniswapV2Library: IDENTICAL_ADDRESSES");\n', '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '        require(token0 != address(0), "UniswapV2Library: ZERO_ADDRESS");\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', 'import {IPrimitiveRouter} from "../interfaces/IPrimitiveRouter.sol";\n', 'import {IWETH} from "../interfaces/IWETH.sol";\n', '\n', 'interface IPrimitiveConnector {\n', '    // ===== External =====\n', '\n', '    function checkApproval(address token, address spender) external returns (bool);\n', '\n', '    // ===== View =====\n', '\n', '    function getWeth() external view returns (IWETH);\n', '\n', '    function getCaller() external view returns (address);\n', '\n', '    function getPrimitiveRouter() external view returns (IPrimitiveRouter);\n', '\n', '    function isApproved(address token, address spender) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.2;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        return _functionCallWithValue(target, data, value, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.2;\n', '\n', 'import { IOption } from "./IOption.sol";\n', '\n', 'interface ITrader {\n', '    function safeMint(\n', '        IOption optionToken,\n', '        uint256 mintQuantity,\n', '        address receiver\n', '    ) external returns (uint256, uint256);\n', '\n', '    function safeExercise(\n', '        IOption optionToken,\n', '        uint256 exerciseQuantity,\n', '        address receiver\n', '    ) external returns (uint256, uint256);\n', '\n', '    function safeRedeem(\n', '        IOption optionToken,\n', '        uint256 redeemQuantity,\n', '        address receiver\n', '    ) external returns (uint256);\n', '\n', '    function safeClose(\n', '        IOption optionToken,\n', '        uint256 closeQuantity,\n', '        address receiver\n', '    )\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function safeUnwind(\n', '        IOption optionToken,\n', '        uint256 unwindQuantity,\n', '        address receiver\n', '    )\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.2;\n', '\n', 'import { IERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";\n', '\n', 'interface IOption is IERC20 {\n', '    function mintOptions(address receiver) external returns (uint256, uint256);\n', '\n', '    function exerciseOptions(\n', '        address receiver,\n', '        uint256 outUnderlyings,\n', '        bytes calldata data\n', '    ) external returns (uint256, uint256);\n', '\n', '    function redeemStrikeTokens(address receiver) external returns (uint256);\n', '\n', '    function closeOptions(address receiver)\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function redeemToken() external view returns (address);\n', '\n', '    function getStrikeTokenAddress() external view returns (address);\n', '\n', '    function getUnderlyingTokenAddress() external view returns (address);\n', '\n', '    function getBaseValue() external view returns (uint256);\n', '\n', '    function getQuoteValue() external view returns (uint256);\n', '\n', '    function getExpiryTime() external view returns (uint256);\n', '\n', '    function underlyingCache() external view returns (uint256);\n', '\n', '    function strikeCache() external view returns (uint256);\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function getCacheBalances() external view returns (uint256, uint256);\n', '\n', '    function getAssetAddresses()\n', '        external\n', '        view\n', '        returns (\n', '            address,\n', '            address,\n', '            address\n', '        );\n', '\n', '    function getParameters()\n', '        external\n', '        view\n', '        returns (\n', '            address _underlyingToken,\n', '            address _strikeToken,\n', '            address _redeemToken,\n', '            uint256 _base,\n', '            uint256 _quote,\n', '            uint256 _expiry\n', '        );\n', '\n', '    function initRedeemToken(address _redeemToken) external;\n', '\n', '    function updateCacheBalances() external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "../../GSN/Context.sol";\n', 'import "./IERC20.sol";\n', 'import "../../math/SafeMath.sol";\n', 'import "../../utils/Address.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '     * a default value of 18.\n', '     *\n', '     * To select a different value for {decimals}, use {_setupDecimals}.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', 'import {\n', '    IOption,\n', '    IERC20\n', '} from "@primitivefi/contracts/contracts/option/interfaces/IOption.sol";\n', 'import {\n', '    IRegistry\n', '} from "@primitivefi/contracts/contracts/option/interfaces/IRegistry.sol";\n', 'import {IWETH} from "./IWETH.sol";\n', '\n', 'interface IPrimitiveRouter {\n', '    // ===== Admin =====\n', '\n', '    function halt() external;\n', '\n', '    // ===== Registration =====\n', '    function setRegisteredOptions(address[] calldata optionAddresses)\n', '        external\n', '        returns (bool);\n', '\n', '    function setRegisteredConnectors(\n', '        address[] calldata connectors,\n', '        bool[] calldata isValid\n', '    ) external returns (bool);\n', '\n', '    // ===== Operations =====\n', '\n', '    function transferFromCaller(address token, uint256 amount) external returns (bool);\n', '\n', '    function transferFromCallerToReceiver(\n', '        address token,\n', '        uint256 amount,\n', '        address receiver\n', '    ) external returns (bool);\n', '\n', '    // ===== Execution =====\n', '\n', '    function executeCall(address connector, bytes calldata params) external payable;\n', '\n', '    // ==== View ====\n', '\n', '    function getWeth() external view returns (IWETH);\n', '\n', '    function getRoute() external view returns (address);\n', '\n', '    function getCaller() external view returns (address);\n', '\n', '    function getRegistry() external view returns (IRegistry);\n', '\n', '    function getRegisteredOption(address option) external view returns (bool);\n', '\n', '    function getRegisteredConnector(address connector) external view returns (bool);\n', '\n', '    function apiVersion() external pure returns (string memory);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function withdraw(uint256) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.2;\n', '\n', 'interface IRegistry {\n', '    function pauseDeployments() external;\n', '\n', '    function unpauseDeployments() external;\n', '\n', '    function deployOption(\n', '        address underlyingToken,\n', '        address strikeToken,\n', '        uint256 base,\n', '        uint256 quote,\n', '        uint256 expiry\n', '    ) external returns (address);\n', '\n', '    function setOptionFactory(address optionFactory_) external;\n', '\n', '    function setRedeemFactory(address redeemFactory_) external;\n', '\n', '    function optionFactory() external returns (address);\n', '\n', '    function redeemFactory() external returns (address);\n', '\n', '    function verifyToken(address tokenAddress) external;\n', '\n', '    function verifyExpiry(uint256 expiry) external;\n', '\n', '    function unverifyToken(address tokenAddress) external;\n', '\n', '    function unverifyExpiry(uint256 expiry) external;\n', '\n', '    function calculateOptionAddress(\n', '        address underlyingToken,\n', '        address strikeToken,\n', '        uint256 base,\n', '        uint256 quote,\n', '        uint256 expiry\n', '    ) external view returns (address);\n', '\n', '    function getOptionAddress(\n', '        address underlyingToken,\n', '        address strikeToken,\n', '        uint256 base,\n', '        uint256 quote,\n', '        uint256 expiry\n', '    ) external view returns (address);\n', '\n', '    function isVerifiedOption(address optionAddress)\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   Primitive Connector TEST\n', ' * @author  Primitive\n', ' * @notice  Low-level abstract contract for Primitive Connectors to inherit from.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', 'import {PrimitiveConnector, IOption} from "../connectors/PrimitiveConnector.sol";\n', '\n', 'contract ConnectorTest is PrimitiveConnector {\n', '    event Log(address indexed caller);\n', '\n', '    constructor(address weth_, address primitiveRouter_)\n', '        public\n', '        PrimitiveConnector(weth_, primitiveRouter_)\n', '    {}\n', '\n', '    function depositETH() external payable returns (bool) {\n', '        emit Log(getCaller());\n', '        return _depositETH();\n', '    }\n', '\n', '    function withdrawETH() external returns (bool) {\n', '        emit Log(getCaller());\n', '        return _withdrawETH();\n', '    }\n', '\n', '    function transferFromCaller(address token, uint256 quantity) external returns (bool) {\n', '        emit Log(getCaller());\n', '        return _transferFromCaller(token, quantity);\n', '    }\n', '\n', '    function transferToCaller(address token) external returns (bool) {\n', '        emit Log(getCaller());\n', '        return _transferToCaller(token);\n', '    }\n', '\n', '    function transferFromCallerToReceiver(\n', '        address token,\n', '        uint256 quantity,\n', '        address receiver\n', '    ) external returns (bool) {\n', '        emit Log(getCaller());\n', '        return _transferFromCallerToReceiver(token, quantity, receiver);\n', '    }\n', '\n', '    function mintOptions(IOption optionToken, uint256 quantity)\n', '        external\n', '        returns (uint256, uint256)\n', '    {\n', '        emit Log(getCaller());\n', '        _transferFromCaller(optionToken.getUnderlyingTokenAddress(), quantity);\n', '        return _mintOptions(optionToken);\n', '    }\n', '\n', '    function mintOptionsToReceiver(\n', '        IOption optionToken,\n', '        uint256 quantity,\n', '        address receiver\n', '    ) external returns (uint256, uint256) {\n', '        emit Log(getCaller());\n', '        _transferFromCaller(optionToken.getUnderlyingTokenAddress(), quantity);\n', '        return _mintOptionsToReceiver(optionToken, receiver);\n', '    }\n', '\n', '    function mintOptionsFromCaller(IOption optionToken, uint256 quantity)\n', '        external\n', '        returns (uint256, uint256)\n', '    {\n', '        emit Log(getCaller());\n', '        return _mintOptionsFromCaller(optionToken, quantity);\n', '    }\n', '\n', '    function closeOptions(IOption optionToken, uint256 short) external returns (uint256) {\n', '        emit Log(getCaller());\n', '        _transferFromCaller(optionToken.redeemToken(), short);\n', '        return _closeOptions(optionToken);\n', '    }\n', '\n', '    function exerciseOptions(\n', '        IOption optionToken,\n', '        uint256 amount,\n', '        uint256 strikeAmount\n', '    ) external returns (uint256, uint256) {\n', '        _transferFromCaller(optionToken.getStrikeTokenAddress(), strikeAmount);\n', '        _transferFromCaller(address(optionToken), amount);\n', '        emit Log(getCaller());\n', '        return _exerciseOptions(optionToken, amount);\n', '    }\n', '\n', '    function redeemOptions(IOption optionToken, uint256 short)\n', '        external\n', '        returns (uint256)\n', '    {\n', '        _transferFromCaller(optionToken.redeemToken(), short);\n', '        emit Log(getCaller());\n', '        return _redeemOptions(optionToken);\n', '    }\n', '\n', '    function transferBalanceToReceiver(address token, address receiver)\n', '        external\n', '        returns (uint256)\n', '    {\n', '        emit Log(getCaller());\n', '        return _transferBalanceToReceiver(token, receiver);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   Primitive Router\n', ' * @author  Primitive\n', ' * @notice  Swap option tokens on Uniswap & Sushiswap venues.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', '// Open Zeppelin\n', 'import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', 'import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n', '// Uniswap\n', 'import {\n', '    IUniswapV2Callee\n', '} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Callee.sol";\n', '// Primitive\n', 'import {\n', '    IPrimitiveSwaps,\n', '    IUniswapV2Router02,\n', '    IUniswapV2Factory,\n', '    IUniswapV2Pair,\n', '    IOption,\n', '    IERC20Permit\n', '} from "../interfaces/IPrimitiveSwaps.sol";\n', 'import {PrimitiveConnector} from "./PrimitiveConnector.sol";\n', 'import {SwapsLib, SafeMath} from "../libraries/SwapsLib.sol";\n', '\n', 'interface DaiPermit {\n', '    function permit(\n', '        address holder,\n', '        address spender,\n', '        uint256 nonce,\n', '        uint256 expiry,\n', '        bool allowed,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', 'contract PrimitiveSwaps is\n', '    PrimitiveConnector,\n', '    IPrimitiveSwaps,\n', '    IUniswapV2Callee,\n', '    ReentrancyGuard\n', '{\n', "    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\n", '    using SafeMath for uint256; // Reverts on math underflows/overflows\n', '\n', '    event Initialized(address indexed from); // Emitted on deployment.\n', '    event Buy(\n', '        address indexed from,\n', '        address indexed option,\n', '        uint256 quantity,\n', '        uint256 premium\n', '    );\n', '    event Sell(\n', '        address indexed from,\n', '        address indexed option,\n', '        uint256 quantity,\n', '        uint256 payout\n', '    );\n', '\n', '    IUniswapV2Factory private _factory; // The Uniswap V2 _factory contract to get pair addresses from\n', '    IUniswapV2Router02 private _router; // The Uniswap contract used to interact with the protocol\n', '\n', '    modifier onlySelf() {\n', '        require(_msgSender() == address(this), "PrimitiveSwaps: NOT_SELF");\n', '        _;\n', '    }\n', '\n', '    // ===== Constructor =====\n', '    constructor(\n', '        address weth_,\n', '        address primitiveRouter_,\n', '        address factory_,\n', '        address router_\n', '    ) public PrimitiveConnector(weth_, primitiveRouter_) {\n', '        _factory = IUniswapV2Factory(factory_);\n', '        _router = IUniswapV2Router02(router_);\n', '        emit Initialized(_msgSender());\n', '    }\n', '\n', '    // ===== Swap Operations =====\n', '\n', '    /**\n', '     * @notice  IMPORTANT: amountOutMin parameter is the price to swap shortOptionTokens to underlyingTokens.\n', '     *          IMPORTANT: If the ratio between shortOptionTokens and underlyingTokens is 1:1, then only the swap fee (0.30%) has to be paid.\n', '     * @dev     Opens a longOptionToken position by minting long + short tokens, then selling the short tokens.\n', '     * @param   optionToken The option address.\n', '     * @param   amountOptions The quantity of longOptionTokens to purchase.\n', '     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\n', '     * @return  Whether or not the call succeeded.\n', '     */\n', '    function openFlashLong(\n', '        IOption optionToken,\n', '        uint256 amountOptions,\n', '        uint256 maxPremium\n', '    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {\n', '        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\n', '        (IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\n', '        SwapsLib._flashSwap(\n', '            pair, // Pair to flash swap from.\n', '            underlying, // Token to swap to, i.e. receive optimistically.\n', '            amountOptions, // Amount of underlying to optimistically receive to mint options with.\n', '            abi.encodeWithSelector( // Start: Function to call in the callback.\n', '                bytes4(\n', '                    keccak256(\n', '                        bytes("flashMintShortOptionsThenSwap(address,uint256,uint256)")\n', '                    )\n', '                ),\n', '                optionToken, // Option token to mint with flash loaned tokens.\n', '                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\n', '                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\n', '            ) // End: Function to call in the callback.\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice  Executes the same as `openFlashLong`, but calls `permit` to pull underlying tokens.\n', '     */\n', '    function openFlashLongWithPermit(\n', '        IOption optionToken,\n', '        uint256 amountOptions,\n', '        uint256 maxPremium,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {\n', '        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\n', '        (IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\n', '        IERC20Permit(underlying).permit(\n', '            getCaller(),\n', '            address(_primitiveRouter),\n', '            maxPremium,\n', '            deadline,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        SwapsLib._flashSwap(\n', '            pair, // Pair to flash swap from.\n', '            underlying, // Token to swap to, i.e. receive optimistically.\n', '            amountOptions, // Amount of underlying to optimistically receive to mint options with.\n', '            abi.encodeWithSelector( // Start: Function to call in the callback.\n', '                bytes4(\n', '                    keccak256(\n', '                        bytes("flashMintShortOptionsThenSwap(address,uint256,uint256)")\n', '                    )\n', '                ),\n', '                optionToken, // Option token to mint with flash loaned tokens.\n', '                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\n', '                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\n', '            ) // End: Function to call in the callback.\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice  Executes the same as `openFlashLongWithPermit`, but for DAI.\n', '     */\n', '    function openFlashLongWithDAIPermit(\n', '        IOption optionToken,\n', '        uint256 amountOptions,\n', '        uint256 maxPremium,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public override nonReentrant onlyRegistered(optionToken) returns (bool) {\n', '        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\n', '        (IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\n', '        DaiPermit(underlying).permit(\n', '            getCaller(),\n', '            address(_primitiveRouter),\n', '            IERC20Permit(underlying).nonces(getCaller()),\n', '            deadline,\n', '            true,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        SwapsLib._flashSwap(\n', '            pair, // Pair to flash swap from.\n', '            underlying, // Token to swap to, i.e. receive optimistically.\n', '            amountOptions, // Amount of underlying to optimistically receive to mint options with.\n', '            abi.encodeWithSelector( // Start: Function to call in the callback.\n', '                bytes4(\n', '                    keccak256(\n', '                        bytes("flashMintShortOptionsThenSwap(address,uint256,uint256)")\n', '                    )\n', '                ),\n', '                optionToken, // Option token to mint with flash loaned tokens.\n', '                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\n', '                maxPremium // Total price paid (in underlyingTokens) for selling shortOptionTokens.\n', '            ) // End: Function to call in the callback.\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice  Uses Ether to pay to purchase the option tokens.\n', '     *          IMPORTANT: amountOutMin parameter is the price to swap shortOptionTokens to underlyingTokens.\n', '     *          IMPORTANT: If the ratio between shortOptionTokens and underlyingTokens is 1:1, then only the swap fee (0.30%) has to be paid.\n', '     * @dev     Opens a longOptionToken position by minting long + short tokens, then selling the short tokens.\n', '     * @param   optionToken The option address.\n', '     * @param   amountOptions The quantity of longOptionTokens to purchase.\n', '     */\n', '    function openFlashLongWithETH(IOption optionToken, uint256 amountOptions)\n', '        external\n', '        payable\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(optionToken)\n', '        returns (bool)\n', '    {\n', '        require(msg.value > 0, "PrimitiveSwaps: ZERO"); // Fail early if no Ether was sent.\n', '        // Calls pair.swap(), and executes `flashMintShortOptionsThenSwap` in the `uniswapV2Callee` callback.\n', '        (IUniswapV2Pair pair, address underlying, ) = getOptionPair(optionToken);\n', '        SwapsLib._flashSwap(\n', '            pair, // Pair to flash swap from.\n', '            underlying, // Token to swap to, i.e. receive optimistically.\n', '            amountOptions, // Amount of underlying to optimistically receive to mint options with.\n', '            abi.encodeWithSelector( // Start: Function to call in the callback.\n', '                bytes4(\n', '                    keccak256(\n', '                        bytes(\n', '                            "flashMintShortOptionsThenSwapWithETH(address,uint256,uint256)"\n', '                        )\n', '                    )\n', '                ),\n', '                optionToken, // Option token to mint with flash loaned tokens\n', '                amountOptions, // Quantity of underlyingTokens from flash loan to use to mint options.\n', '                msg.value // total price paid (in underlyingTokens) for selling shortOptionTokens.\n', '            ) // End: Function to call in the callback.\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev     Closes a longOptionToken position by flash swapping in redeemTokens,\n', '     *          closing the option, and paying back in underlyingTokens.\n', '     * @notice  IMPORTANT: If minPayout is 0, this function will cost the caller to close the option, for no gain.\n', '     * @param   optionToken The address of the longOptionTokens to close.\n', '     * @param   amountRedeems The quantity of redeemTokens to borrow to close the options.\n', '     * @param   minPayout The minimum payout of underlyingTokens sent out to the user.\n', '     */\n', '    function closeFlashLong(\n', '        IOption optionToken,\n', '        uint256 amountRedeems,\n', '        uint256 minPayout\n', '    ) external override nonReentrant onlyRegistered(optionToken) returns (bool) {\n', '        // Calls pair.swap(), and executes `flashCloseLongOptionsThenSwap` in the `uniswapV2Callee` callback.\n', '        (IUniswapV2Pair pair, , address redeem) = getOptionPair(optionToken);\n', '        SwapsLib._flashSwap(\n', '            pair, // Pair to flash swap from.\n', '            redeem, // Token to swap to, i.e. receive optimistically.\n', '            amountRedeems, // Amount of underlying to optimistically receive to close options with.\n', '            abi.encodeWithSelector( // Start: Function to call in the callback.\n', '                bytes4(\n', '                    keccak256(\n', '                        bytes("flashCloseLongOptionsThenSwap(address,uint256,uint256)")\n', '                    )\n', '                ),\n', '                optionToken, // Option token to close with flash loaned redeemTokens.\n', '                amountRedeems, // Quantity of redeemTokens from flash loan to use to close options.\n', '                minPayout // Total remaining underlyingTokens after flash loan is paid.\n', '            ) // End: Function to call in the callback.\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev     Closes a longOptionToken position by flash swapping in redeemTokens,\n', '     *          closing the option, and paying back in underlyingTokens.\n', '     * @notice  IMPORTANT: If minPayout is 0, this function will cost the caller to close the option, for no gain.\n', '     * @param   optionToken The address of the longOptionTokens to close.\n', '     * @param   amountRedeems The quantity of redeemTokens to borrow to close the options.\n', '     * @param   minPayout The minimum payout of underlyingTokens sent out to the user.\n', '     */\n', '    function closeFlashLongForETH(\n', '        IOption optionToken,\n', '        uint256 amountRedeems,\n', '        uint256 minPayout\n', '    ) external override nonReentrant onlyRegistered(optionToken) returns (bool) {\n', '        // Calls pair.swap(), and executes `flashCloseLongOptionsThenSwapForETH` in the `uniswapV2Callee` callback.\n', '        (IUniswapV2Pair pair, , address redeem) = getOptionPair(optionToken);\n', '        SwapsLib._flashSwap(\n', '            pair, // Pair to flash swap from.\n', '            redeem, // Token to swap to, i.e. receive optimistically.\n', '            amountRedeems, // Amount of underlying to optimistically receive to close options with.\n', '            abi.encodeWithSelector( // Start: Function to call in the callback.\n', '                bytes4(\n', '                    keccak256(\n', '                        bytes(\n', '                            "flashCloseLongOptionsThenSwapForETH(address,uint256,uint256)"\n', '                        )\n', '                    )\n', '                ),\n', '                optionToken, // Option token to close with flash loaned redeemTokens.\n', '                amountRedeems, // Quantity of redeemTokens from flash loan to use to close options.\n', '                minPayout // Total remaining underlyingTokens after flash loan is paid.\n', '            ) // End: Function to call in the callback.\n', '        );\n', '        return true;\n', '    }\n', '\n', '    // ===== Flash Callback Functions =====\n', '\n', '    /**\n', '     * @notice  Callback function executed in a UniswapV2Pair.swap() call for `openFlashLong`.\n', '     * @dev     Pays underlying token `premium` for `quantity` of `optionAddress` tokens.\n', '     * @param   optionAddress The address of the Option contract.\n', '     * @param   quantity The quantity of options to mint using borrowed underlyingTokens.\n', '     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\n', '     * @return  Returns (amount, premium) of options purchased for total premium price.\n', '     */\n', '    function flashMintShortOptionsThenSwap(\n', '        address optionAddress,\n', '        uint256 quantity,\n', '        uint256 maxPremium\n', '    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {\n', '        IOption optionToken = IOption(optionAddress);\n', '        (IUniswapV2Pair pair, address underlying, address redeem) =\n', '            getOptionPair(optionToken);\n', '        // Mint option and redeem tokens to this contract.\n', '        _mintOptions(optionToken);\n', '        // Get the repayment amounts.\n', '        (uint256 premium, uint256 redeemPremium) =\n', '            SwapsLib.repayOpen(_router, optionToken, quantity);\n', '        // If premium is non-zero and non-negative (most cases), send underlyingTokens to the pair as payment (premium).\n', '        if (premium > 0) {\n', '            // Check for users to not pay over their max desired value.\n', '            require(maxPremium >= premium, "PrimitiveSwaps: MAX_PREMIUM");\n', '            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\n', '            // Push underlying tokens back to the pair as repayment.\n', '            _transferFromCallerToReceiver(underlying, premium, address(pair));\n', '        }\n', '        // Pay pair in redeem tokens.\n', '        if (redeemPremium > 0) {\n', '            IERC20(redeem).safeTransfer(address(pair), redeemPremium);\n', '        }\n', '        // Return tokens to `getCaller()`.\n', '        _transferToCaller(redeem);\n', '        _transferToCaller(optionAddress);\n', '        emit Buy(getCaller(), optionAddress, quantity, premium);\n', '        return (quantity, premium);\n', '    }\n', '\n', '    /**\n', '     * @notice  Callback function executed in a UniswapV2Pair.swap() call for `openFlashLongWithETH`.\n', '     * @dev     Pays `premium` in ether for `quantity` of `optionAddress` tokens.\n', '     * @param   optionAddress The address of the Option contract.\n', '     * @param   quantity The quantity of options to mint using borrowed underlyingTokens.\n', '     * @param   maxPremium The maximum quantity of underlyingTokens to pay for the optionTokens.\n', '     * @return  Returns (amount, premium) of options purchased for total premium price.\n', '     */\n', '    function flashMintShortOptionsThenSwapWithETH(\n', '        address optionAddress,\n', '        uint256 quantity,\n', '        uint256 maxPremium\n', '    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {\n', '        IOption optionToken = IOption(optionAddress);\n', '        (IUniswapV2Pair pair, address underlying, address redeem) =\n', '            getOptionPair(optionToken);\n', '        require(underlying == address(_weth), "PrimitiveSwaps: NOT_WETH"); // Ensure Weth Call.\n', '        // Mint option and redeem tokens to this contract.\n', '        _mintOptions(optionToken);\n', '        // Get the repayment amounts.\n', '        (uint256 premium, uint256 redeemPremium) =\n', '            SwapsLib.repayOpen(_router, optionToken, quantity);\n', '        // If premium is non-zero and non-negative (most cases), send underlyingTokens to the pair as payment (premium).\n', '        if (premium > 0) {\n', '            // Check for users to not pay over their max desired value.\n', '            require(maxPremium >= premium, "PrimitiveSwaps: MAX_PREMIUM");\n', '            // Wrap exact Ether amount of `premium`.\n', '            _weth.deposit.value(premium)();\n', '            // Transfer Weth to pair to pay for premium.\n', '            IERC20(address(_weth)).safeTransfer(address(pair), premium);\n', '            // Return remaining Ether to caller.\n', '            _withdrawETH();\n', '        }\n', '        // Pay pair in redeem.\n', '        if (redeemPremium > 0) {\n', '            IERC20(redeem).safeTransfer(address(pair), redeemPremium);\n', '        }\n', '        // Return tokens to `getCaller()`.\n', '        _transferToCaller(redeem);\n', '        _transferToCaller(optionAddress);\n', '        emit Buy(getCaller(), optionAddress, quantity, premium);\n', '        return (quantity, premium);\n', '    }\n', '\n', '    /**\n', '     * @dev     Sends shortOptionTokens to _msgSender(), and pays back the UniswapV2Pair in underlyingTokens.\n', '     * @notice  IMPORTANT: If minPayout is 0, the `to` address is liable for negative payouts *if* that occurs.\n', '     * @param   optionAddress The address of the longOptionTokes to close.\n', '     * @param   flashLoanQuantity The quantity of shortOptionTokens borrowed to use to close longOptionTokens.\n', '     * @param   minPayout The minimum payout of underlyingTokens sent to the `to` address.\n', '     */\n', '    function flashCloseLongOptionsThenSwap(\n', '        address optionAddress,\n', '        uint256 flashLoanQuantity,\n', '        uint256 minPayout\n', '    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {\n', '        IOption optionToken = IOption(optionAddress);\n', '        (IUniswapV2Pair pair, address underlying, address redeem) =\n', '            getOptionPair(optionToken);\n', '        // Close the options, releasing underlying tokens to this contract.\n', '        uint256 outputUnderlyings = _closeOptions(optionToken);\n', '        // Get repay amounts.\n', '        (uint256 payout, uint256 cost, uint256 outstanding) =\n', '            SwapsLib.repayClose(_router, optionToken, flashLoanQuantity);\n', '        if (payout > 0) {\n', '            cost = outputUnderlyings.sub(payout);\n', '        }\n', '        // Pay back the pair in underlyingTokens.\n', '        if (cost > 0) {\n', '            IERC20(underlying).safeTransfer(address(pair), cost);\n', '        }\n', '        if (outstanding > 0) {\n', '            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\n', '            // Revert if the minPayout is less than or equal to the underlyingPayment of 0.\n', '            // There is 0 underlyingPayment in the case that outstanding > 0.\n', '            // This code branch can be successful by setting `minPayout` to 0.\n', '            // This means the user is willing to pay to close the position.\n', '            require(minPayout <= payout, "PrimitiveSwaps: NEGATIVE_PAYOUT");\n', '            _transferFromCallerToReceiver(underlying, outstanding, address(pair));\n', '        }\n', '        // If payout is non-zero and non-negative, send it to the `getCaller()` address.\n', '        if (payout > 0) {\n', '            // Revert if minPayout is greater than the actual payout.\n', '            require(payout >= minPayout, "PrimitiveSwaps: MIN_PREMIUM");\n', '            _transferToCaller(underlying);\n', '        }\n', '        emit Sell(getCaller(), optionAddress, flashLoanQuantity, payout);\n', '        return (payout, cost);\n', '    }\n', '\n', '    /**\n', '     * @dev     Sends shortOptionTokens to _msgSender(), and pays back the UniswapV2Pair in underlyingTokens.\n', '     * @notice  IMPORTANT: If minPayout is 0, the `getCaller()` address is liable for negative payouts *if* that occurs.\n', '     * @param   optionAddress The address of the longOptionTokes to close.\n', '     * @param   flashLoanQuantity The quantity of shortOptionTokens borrowed to use to close longOptionTokens.\n', '     * @param   minPayout The minimum payout of underlyingTokens sent to the `to` address.\n', '     */\n', '    function flashCloseLongOptionsThenSwapForETH(\n', '        address optionAddress,\n', '        uint256 flashLoanQuantity,\n', '        uint256 minPayout\n', '    ) public onlySelf onlyRegistered(IOption(optionAddress)) returns (uint256, uint256) {\n', '        IOption optionToken = IOption(optionAddress);\n', '        (IUniswapV2Pair pair, address underlying, address redeem) =\n', '            getOptionPair(optionToken);\n', '        require(underlying == address(_weth), "PrimitiveSwaps: NOT_WETH");\n', '        // Close the options, releasing underlying tokens to this contract.\n', '        _closeOptions(optionToken);\n', '        // Get repay amounts.\n', '        (uint256 payout, uint256 cost, uint256 outstanding) =\n', '            SwapsLib.repayClose(_router, optionToken, flashLoanQuantity);\n', '        // Pay back the pair in underlyingTokens.\n', '        if (cost > 0) {\n', '            IERC20(underlying).safeTransfer(address(pair), cost);\n', '        }\n', '        if (outstanding > 0) {\n', '            // Pull underlyingTokens from the `getCaller()` to pay the remainder of the flash swap.\n', '            // Revert if the minPayout is less than or equal to the underlyingPayment of 0.\n', '            // There is 0 underlyingPayment in the case that outstanding > 0.\n', '            // This code branch can be successful by setting `minPayout` to 0.\n', '            // This means the user is willing to pay to close the position.\n', '            require(minPayout <= payout, "PrimitiveSwaps: NEGATIVE_PAYOUT");\n', '            _transferFromCallerToReceiver(underlying, outstanding, address(pair));\n', '        }\n', '        // If payout is non-zero and non-negative, send it to the `getCaller()` address.\n', '        if (payout > 0) {\n', '            // Revert if minPayout is greater than the actual payout.\n', '            require(payout >= minPayout, "PrimitiveSwaps: MIN_PREMIUM");\n', "            _withdrawETH(); // Unwrap's this contract's balance of Weth and sends Ether to `getCaller()`.\n", '        }\n', '        emit Sell(getCaller(), optionAddress, flashLoanQuantity, payout);\n', '        return (payout, cost);\n', '    }\n', '\n', '    // ===== Flash Loans =====\n', '\n', '    /**\n', '     * @dev     The callback function triggered in a UniswapV2Pair.swap() call when the `data` parameter has data.\n', '     * @param   sender The original _msgSender() of the UniswapV2Pair.swap() call.\n', '     * @param   amount0 The quantity of token0 received to the `to` address in the swap() call.\n', '     * @param   amount1 The quantity of token1 received to the `to` address in the swap() call.\n', '     * @param   data The payload passed in the `data` parameter of the swap() call.\n', '     */\n', '    function uniswapV2Call(\n', '        address sender,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        bytes calldata data\n', '    ) external override(IPrimitiveSwaps, IUniswapV2Callee) {\n', '        assert(\n', '            _msgSender() ==\n', '                _factory.getPair(\n', '                    IUniswapV2Pair(_msgSender()).token0(),\n', '                    IUniswapV2Pair(_msgSender()).token1()\n', '                )\n', '        ); // Ensure that _msgSender() is actually a V2 pair.\n', '        require(sender == address(this), "PrimitiveSwaps: NOT_SENDER"); // Ensure called by this contract.\n', '        (bool success, bytes memory returnData) = address(this).call(data); // Execute the callback.\n', '        (uint256 amountA, uint256 amountB) = abi.decode(returnData, (uint256, uint256));\n', '        require(\n', '            success && (returnData.length == 0 || amountA > 0 || amountB > 0),\n', '            "PrimitiveSwaps: CALLBACK"\n', '        );\n', '    }\n', '\n', '    // ===== View =====\n', '\n', '    /**\n', '     * @notice  Gets the UniswapV2Router02 contract address.\n', '     */\n', '    function getRouter() public view override returns (IUniswapV2Router02) {\n', '        return _router;\n', '    }\n', '\n', '    /**\n', '     * @notice  Gets the UniswapV2Factory contract address.\n', '     */\n', '    function getFactory() public view override returns (IUniswapV2Factory) {\n', '        return _factory;\n', '    }\n', '\n', '    /**\n', "     * @notice  Fetchs the Uniswap Pair for an option's redeemToken and underlyingToken params.\n", '     * @param   option The option token to get the corresponding UniswapV2Pair market.\n', '     * @return  The pair address, as well as the tokens of the pair.\n', '     */\n', '    function getOptionPair(IOption option)\n', '        public\n', '        view\n', '        override\n', '        returns (\n', '            IUniswapV2Pair,\n', '            address,\n', '            address\n', '        )\n', '    {\n', '        address redeem = option.redeemToken();\n', '        address underlying = option.getUnderlyingTokenAddress();\n', '        IUniswapV2Pair pair = IUniswapV2Pair(_factory.getPair(redeem, underlying));\n', '        return (pair, underlying, redeem);\n', '    }\n', '\n', '    /**\n', '     * @dev     Calculates the effective premium, denominated in underlyingTokens, to buy `quantity` of `optionToken`s.\n', '     * @notice  UniswapV2 adds a 0.3009027% fee which is applied to the premium as 0.301%.\n', "     *          IMPORTANT: If the pair's reserve ratio is incorrect, there could be a 'negative' premium.\n", '     *          Buying negative premium options will pay out redeemTokens.\n', "     *          An 'incorrect' ratio occurs when the (reserves of redeemTokens / strike ratio) >= reserves of underlyingTokens.\n", "     *          Implicitly uses the `optionToken`'s underlying and redeem tokens for the pair.\n", '     * @param   optionToken The optionToken to get the premium cost of purchasing.\n', '     * @param   quantity The quantity of long option tokens that will be purchased.\n', '     * @return  (uint, uint) Returns the `premium` to buy `quantity` of `optionToken` and the `negativePremium`.\n', '     */\n', '    function getOpenPremium(IOption optionToken, uint256 quantity)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256, uint256)\n', '    {\n', '        return SwapsLib.getOpenPremium(_router, optionToken, quantity);\n', '    }\n', '\n', '    /**\n', '     * @dev     Calculates the effective premium, denominated in underlyingTokens, to sell `optionToken`s.\n', '     * @param   optionToken The optionToken to get the premium cost of purchasing.\n', '     * @param   quantity The quantity of short option tokens that will be closed.\n', '     * @return  (uint, uint) Returns the `premium` to sell `quantity` of `optionToken` and the `negativePremium`.\n', '     */\n', '    function getClosePremium(IOption optionToken, uint256 quantity)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256, uint256)\n', '    {\n', '        return SwapsLib.getClosePremium(_router, optionToken, quantity);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Callee {\n', '    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', 'import {\n', '    IUniswapV2Router02\n', '} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";\n', 'import {\n', '    IUniswapV2Factory\n', '} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";\n', 'import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";\n', 'import {IOption} from "@primitivefi/contracts/contracts/option/interfaces/IOption.sol";\n', 'import {IERC20Permit} from "./IERC20Permit.sol";\n', '\n', 'interface IPrimitiveSwaps {\n', '    // ==== External Functions ====\n', '\n', '    function openFlashLong(\n', '        IOption optionToken,\n', '        uint256 amountOptions,\n', '        uint256 maxPremium\n', '    ) external returns (bool);\n', '\n', '    function openFlashLongWithPermit(\n', '        IOption optionToken,\n', '        uint256 amountOptions,\n', '        uint256 maxPremium,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (bool);\n', '\n', '    function openFlashLongWithDAIPermit(\n', '        IOption optionToken,\n', '        uint256 amountOptions,\n', '        uint256 maxPremium,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (bool);\n', '\n', '    function openFlashLongWithETH(IOption optionToken, uint256 amountOptions)\n', '        external\n', '        payable\n', '        returns (bool);\n', '\n', '    function closeFlashLong(\n', '        IOption optionToken,\n', '        uint256 amountRedeems,\n', '        uint256 minPayout\n', '    ) external returns (bool);\n', '\n', '    function closeFlashLongForETH(\n', '        IOption optionToken,\n', '        uint256 amountRedeems,\n', '        uint256 minPayout\n', '    ) external returns (bool);\n', '\n', '    // ===== Callback =====\n', '\n', '    function uniswapV2Call(\n', '        address sender,\n', '        uint256 amount0,\n', '        uint256 amount1,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    // ==== View ====\n', '\n', '    function getRouter() external view returns (IUniswapV2Router02);\n', '\n', '    function getFactory() external view returns (IUniswapV2Factory);\n', '\n', '    function getOptionPair(IOption option)\n', '        external\n', '        view\n', '        returns (\n', '            IUniswapV2Pair,\n', '            address,\n', '            address\n', '        );\n', '\n', '    function getOpenPremium(IOption optionToken, uint256 quantity)\n', '        external\n', '        view\n', '        returns (uint256, uint256);\n', '\n', '    function getClosePremium(IOption optionToken, uint256 quantity)\n', '        external\n', '        view\n', '        returns (uint256, uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   Primitive Swaps Lib\n', ' * @author  Primitive\n', ' * @notice  Library for Swap Logic for Uniswap AMM.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', 'import {\n', '    IUniswapV2Router02\n', '} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";\n', 'import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";\n', 'import {CoreLib, IOption, SafeMath} from "./CoreLib.sol";\n', '\n', 'library SwapsLib {\n', '    using SafeMath for uint256; // Reverts on math underflows/overflows\n', '\n', '    /**\n', '     * @notice  Passes in `params` to the UniswapV2Pair.swap() function to trigger the callback.\n', '     * @param   pair The Uniswap Pair to call.\n', '     * @param   token The token in the Pair to swap to, and thus optimistically receive.\n', '     * @param   amount The quantity of `token`s to optimistically receive first.\n', '     * @param   params  The data to call from this contract, using the `uniswapV2Callee` callback.\n', '     * @return  Whether or not the swap() call suceeded.\n', '     */\n', '    function _flashSwap(\n', '        IUniswapV2Pair pair,\n', '        address token,\n', '        uint256 amount,\n', '        bytes memory params\n', '    ) internal returns (bool) {\n', '        // Receives `amount` of `token` to this contract address.\n', '        uint256 amount0Out = pair.token0() == token ? amount : 0;\n', '        uint256 amount1Out = pair.token0() == token ? 0 : amount;\n', '        // Execute the callback function in params.\n', '        pair.swap(amount0Out, amount1Out, address(this), params);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice  Gets the amounts to pay out, pay back, and outstanding cost.\n', '     * @param   router The UniswapV2Router02 to use for calculating `amountsOut`.\n', '     * @param   optionToken The option token to use for fetching its corresponding Uniswap Pair.\n', '     * @param   redeemAmount The quantity of REDEEM tokens, with `quoteValue` units, needed to close the options.\n', '     */\n', '    function repayClose(\n', '        IUniswapV2Router02 router,\n', '        IOption optionToken,\n', '        uint256 redeemAmount\n', '    )\n', '        internal\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        // Outstanding is the cost remaining, should be 0 in most cases.\n', '        // Payout is the `premium` that the original caller receives in underlyingTokens.\n', '        (uint256 payout, uint256 outstanding) =\n', '            getClosePremium(router, optionToken, redeemAmount);\n', '\n', '        // In most cases there will be an underlying payout, which is subtracted from the redeemAmount.\n', '        uint256 cost = CoreLib.getProportionalLongOptions(optionToken, redeemAmount);\n', '        if (payout > 0) {\n', '            cost = cost.sub(payout);\n', '        }\n', '        return (payout, cost, outstanding);\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns the swap amounts required to return to repay the flash loan used to open a long position.\n', '     * @param   router The UniswapV2Router02 to use for calculating `amountsOut`.\n', '     * @param   optionToken The option token to use for fetching its corresponding Uniswap Pair.\n', '     * @param   underlyingAmount The quantity of UNDERLYING tokens, with `baseValue` units, needed to open the options.\n', '     */\n', '    function repayOpen(\n', '        IUniswapV2Router02 router,\n', '        IOption optionToken,\n', '        uint256 underlyingAmount\n', '    ) internal view returns (uint256, uint256) {\n', '        // Premium is the `underlyingTokens` required to buy the `optionToken`.\n', '        // ExtraRedeems is the `redeemTokens` that are remaining.\n', '        // If `premium` is not 0, `extraRedeems` should be 0, else `extraRedeems` is the payout (a negative premium).\n', '        (uint256 premium, uint256 extraRedeems) =\n', '            getOpenPremium(router, optionToken, underlyingAmount);\n', '\n', '        uint256 redeemPremium =\n', '            CoreLib.getProportionalShortOptions(optionToken, underlyingAmount);\n', '\n', '        if (extraRedeems > 0) {\n', '            redeemPremium = redeemPremium.sub(extraRedeems);\n', '        }\n', '        return (premium, redeemPremium);\n', '    }\n', '\n', '    /**\n', '     * @dev    Calculates the effective premium, denominated in underlyingTokens, to buy `quantity` of `optionToken`s.\n', '     * @notice UniswapV2 adds a 0.3009027% fee which is applied to the premium as 0.301%.\n', "     *         IMPORTANT: If the pair's reserve ratio is incorrect, there could be a 'negative' premium.\n", '     *         Buying negative premium options will pay out redeemTokens.\n', "     *         An 'incorrect' ratio occurs when the (reserves of redeemTokens / strike ratio) >= reserves of underlyingTokens.\n", "     *         Implicitly uses the `optionToken`'s underlying and redeem tokens for the pair.\n", '     * @param  router The UniswapV2Router02 contract.\n', '     * @param  optionToken The optionToken to get the premium cost of purchasing.\n', '     * @param  quantity The quantity of long option tokens that will be purchased.\n', '     */\n', '    function getOpenPremium(\n', '        IUniswapV2Router02 router,\n', '        IOption optionToken,\n', '        uint256 quantity\n', '    )\n', '        internal\n', '        view\n', '        returns (\n', '            /* override */\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        // longOptionTokens are opened by doing a swap from redeemTokens to underlyingTokens effectively.\n', '        address[] memory path = new address[](2);\n', '        path[0] = optionToken.redeemToken();\n', '        path[1] = optionToken.getUnderlyingTokenAddress();\n', '\n', '        // `quantity` of underlyingTokens are output from the swap.\n', '        // They are used to mint options, which will mint `quantity` * quoteValue / baseValue amount of redeemTokens.\n', '        uint256 redeemsMinted =\n', '            CoreLib.getProportionalShortOptions(optionToken, quantity);\n', '\n', '        // The loanRemainderInUnderlyings will be the amount of underlyingTokens that are needed from the original\n', '        // transaction caller in order to pay the flash swap.\n', '        // IMPORTANT: THIS IS EFFECTIVELY THE PREMIUM PAID IN UNDERLYINGTOKENS TO PURCHASE THE OPTIONTOKEN.\n', '        uint256 loanRemainderInUnderlyings;\n', '\n', '        // Economically, negativePremiumPaymentInRedeems value should always be 0.\n', '        // In the case that we minted more redeemTokens than are needed to pay back the flash swap,\n', '        // (short -> underlying is a positive trade), there is an effective negative premium.\n', '        // In that case, this function will send out `negativePremiumAmount` of redeemTokens to the original caller.\n', '        // This means the user gets to keep the extra redeemTokens for free.\n', '        // Negative premium amount is the opposite difference of the loan remainder: (paid - flash loan amount)\n', '        uint256 negativePremiumPaymentInRedeems;\n', '\n', '        // Since the borrowed amount is underlyingTokens, and we are paying back in redeemTokens,\n', '        // we need to see how much redeemTokens must be returned for the borrowed amount.\n', '        // We can find that value by doing the normal swap math, getAmountsIn will give us the amount\n', '        // of redeemTokens are needed for the output amount of the flash loan.\n', '        // IMPORTANT: amountsIn[0] is how many short tokens we need to pay back.\n', '        // This value is most likely greater than the amount of redeemTokens minted.\n', '        uint256[] memory amountsIn = router.getAmountsIn(quantity, path);\n', '        uint256 redeemsRequired = amountsIn[0]; // the amountIn of redeemTokens based on the amountOut of `quantity`.\n', '        // If redeemsMinted is greater than redeems required, there is a cost of 0, implying a negative premium.\n', '        uint256 redeemCostRemaining =\n', '            redeemsRequired > redeemsMinted ? redeemsRequired.sub(redeemsMinted) : 0;\n', '        // If there is a negative premium, calculate the quantity of remaining redeemTokens after the `redeemsMinted` is spent.\n', '        negativePremiumPaymentInRedeems = redeemsMinted > redeemsRequired\n', '            ? redeemsMinted.sub(redeemsRequired)\n', '            : 0;\n', '\n', '        // In most cases, there will be an outstanding cost (assuming we minted less redeemTokens than the\n', '        // required amountIn of redeemTokens for the swap).\n', '        if (redeemCostRemaining > 0) {\n', "            // The user won't want to pay back the remaining cost in redeemTokens,\n", '            // because they borrowed underlyingTokens to mint them in the first place.\n', '            // So instead, we get the quantity of underlyingTokens that could be paid instead.\n', '            // We can calculate this using normal swap math.\n', '            // getAmountsOut will return the quantity of underlyingTokens that are output,\n', '            // based on some input of redeemTokens.\n', '            // The input redeemTokens is the remaining redeemToken cost, and the output\n', '            // underlyingTokens is the proportional amount of underlyingTokens.\n', '            // amountsOut[1] is then the outstanding flash loan value denominated in underlyingTokens.\n', '            uint256[] memory amountsOut = router.getAmountsOut(redeemCostRemaining, path);\n', '\n', '            // Returning withdrawn tokens to the pair has a fee of .003 / .997 = 0.3009027% which must be applied.\n', '            loanRemainderInUnderlyings = (\n', '                amountsOut[1].mul(100000).add(amountsOut[1].mul(301))\n', '            )\n', '                .div(100000);\n', '        }\n', '        return (loanRemainderInUnderlyings, negativePremiumPaymentInRedeems);\n', '    }\n', '\n', '    /**\n', '     * @dev    Calculates the effective premium, denominated in underlyingTokens, to sell `optionToken`s.\n', '     * @param  router The UniswapV2Router02 contract.\n', '     * @param  optionToken The optionToken to get the premium cost of purchasing.\n', '     * @param  quantity The quantity of short option tokens that will be closed.\n', '     */\n', '    function getClosePremium(\n', '        IUniswapV2Router02 router,\n', '        IOption optionToken,\n', '        uint256 quantity\n', '    )\n', '        internal\n', '        view\n', '        returns (\n', '            /* override */\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        // longOptionTokens are closed by doing a swap from underlyingTokens to redeemTokens.\n', '        address[] memory path = new address[](2);\n', '        path[0] = optionToken.getUnderlyingTokenAddress();\n', '        path[1] = optionToken.redeemToken();\n', '        uint256 outputUnderlyings =\n', '            CoreLib.getProportionalLongOptions(optionToken, quantity);\n', '        // The loanRemainder will be the amount of underlyingTokens that are needed from the original\n', '        // transaction caller in order to pay the flash swap.\n', '        uint256 loanRemainder;\n', '\n', "        // Economically, underlyingPayout value should always be greater than 0, or this trade shouldn't be made.\n", '        // If an underlyingPayout is greater than 0, it means that the redeemTokens borrowed are worth less than the\n', '        // underlyingTokens received from closing the redeemToken<>optionTokens.\n', '        // If the redeemTokens are worth more than the underlyingTokens they are entitled to,\n', '        // then closing the redeemTokens will cost additional underlyingTokens. In this case,\n', '        // the transaction should be reverted. Or else, the user is paying extra at the expense of\n', '        // rebalancing the pool.\n', '        uint256 underlyingPayout;\n', '\n', '        // Since the borrowed amount is redeemTokens, and we are paying back in underlyingTokens,\n', '        // we need to see how much underlyingTokens must be returned for the borrowed amount.\n', '        // We can find that value by doing the normal swap math, getAmountsIn will give us the amount\n', '        // of underlyingTokens are needed for the output amount of the flash loan.\n', '        // IMPORTANT: amountsIn 0 is how many underlyingTokens we need to pay back.\n', '        // This value is most likely greater than the amount of underlyingTokens received from closing.\n', '        uint256[] memory amountsIn = router.getAmountsIn(quantity, path);\n', '\n', '        uint256 underlyingsRequired = amountsIn[0]; // the amountIn required of underlyingTokens based on the amountOut of flashloanQuantity\n', '        // If outputUnderlyings (received from closing) is greater than underlyings required,\n', '        // there is a positive payout.\n', '        underlyingPayout = outputUnderlyings > underlyingsRequired\n', '            ? outputUnderlyings.sub(underlyingsRequired)\n', '            : 0;\n', '\n', '        // If there is a negative payout, calculate the remaining cost of underlyingTokens.\n', '        uint256 underlyingCostRemaining =\n', '            underlyingsRequired > outputUnderlyings\n', '                ? underlyingsRequired.sub(outputUnderlyings)\n', '                : 0;\n', '\n', '        // In the case that there is a negative payout (additional underlyingTokens are required),\n', '        // get the remaining cost into the `loanRemainder` variable and also check to see\n', '        // if a user is willing to pay the negative cost. There is no rational economic incentive for this.\n', '        if (underlyingCostRemaining > 0) {\n', '            loanRemainder = underlyingCostRemaining;\n', '        }\n', '        return (underlyingPayout, loanRemainder);\n', '    }\n', '}\n', '\n', 'pragma solidity >=0.6.2;\n', '\n', "import './IUniswapV2Router01.sol';\n", '\n', 'interface IUniswapV2Router02 is IUniswapV2Router01 {\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountETH);\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountETH);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable;\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external;\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IERC20Permit {\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '}\n', '\n', 'pragma solidity >=0.6.2;\n', '\n', 'interface IUniswapV2Router01 {\n', '    function factory() external pure returns (address);\n', '    function WETH() external pure returns (address);\n', '\n', '    function addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint amountADesired,\n', '        uint amountBDesired,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB, uint liquidity);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETH(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function removeLiquidityWithPermit(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountA, uint amountB);\n', '    function removeLiquidityETHWithPermit(\n', '        address token,\n', '        uint liquidity,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline,\n', '        bool approveMax, uint8 v, bytes32 r, bytes32 s\n', '    ) external returns (uint amountToken, uint amountETH);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapTokensForExactTokens(\n', '        uint amountOut,\n', '        uint amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n', '        external\n', '        returns (uint[] memory amounts);\n', '    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n', '        external\n', '        payable\n', '        returns (uint[] memory amounts);\n', '\n', '    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   Primitive Liquidity\n', ' * @author  Primitive\n', ' * @notice  Manage liquidity on Uniswap & Sushiswap Venues.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', '// Open Zeppelin\n', 'import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', 'import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n', '// Interfaces\n', 'import {\n', '    IPrimitiveLiquidity,\n', '    IUniswapV2Router02,\n', '    IUniswapV2Factory,\n', '    IUniswapV2Pair,\n', '    IERC20Permit,\n', '    IOption\n', '} from "../interfaces/IPrimitiveLiquidity.sol";\n', '// Primitive\n', 'import {PrimitiveConnector} from "./PrimitiveConnector.sol";\n', 'import {CoreLib, SafeMath} from "../libraries/CoreLib.sol";\n', '\n', 'interface DaiPermit {\n', '    function permit(\n', '        address holder,\n', '        address spender,\n', '        uint256 nonce,\n', '        uint256 expiry,\n', '        bool allowed,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', 'contract PrimitiveLiquidity is PrimitiveConnector, IPrimitiveLiquidity, ReentrancyGuard {\n', "    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\n", '    using SafeMath for uint256; // Reverts on math underflows/overflows\n', '\n', '    event Initialized(address indexed from); // Emitted on deployment.\n', '    event AddLiquidity(address indexed from, address indexed option, uint256 sum);\n', '    event RemoveLiquidity(address indexed from, address indexed option, uint256 sum);\n', '\n', '    IUniswapV2Factory private _factory; // The Uniswap V2 factory contract to get pair addresses from.\n', '    IUniswapV2Router02 private _router; // The Uniswap Router contract used to interact with the protocol.\n', '\n', '    // ===== Constructor =====\n', '    constructor(\n', '        address weth_,\n', '        address primitiveRouter_,\n', '        address factory_,\n', '        address router_\n', '    ) public PrimitiveConnector(weth_, primitiveRouter_) {\n', '        _factory = IUniswapV2Factory(factory_);\n', '        _router = IUniswapV2Router02(router_);\n', '        emit Initialized(_msgSender());\n', '    }\n', '\n', '    // ===== Liquidity Operations =====\n', '\n', '    /**\n', '     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting redeemTokens with underlyingTokens.\n', '     * @notice  Pulls underlying tokens from `getCaller()` and pushes UNI-V2 liquidity tokens to the "getCaller()" address.\n', '     *          underlyingToken -> redeemToken -> UNI-V2.\n', '     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\n', '     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\n', '     * @param   amountBMax The quantity of underlyingTokens to add with redeemTokens to the Uniswap V2 Pair.\n', '     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\n', '     * @param   deadline The timestamp to expire a pending transaction.\n', '     * @return  Returns (amountA, amountB, liquidity) amounts.\n', '     */\n', '    function addShortLiquidityWithUnderlying(\n', '        address optionAddress,\n', '        uint256 quantityOptions,\n', '        uint256 amountBMax,\n', '        uint256 amountBMin,\n', '        uint256 deadline\n', '    )\n', '        public\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(IOption(optionAddress))\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        uint256 amountA;\n', '        uint256 amountB;\n', '        uint256 liquidity;\n', '        address underlying = IOption(optionAddress).getUnderlyingTokenAddress();\n', '        // Pulls total = (quantityOptions + amountBMax) of underlyingTokens from `getCaller()` to this contract.\n', '        {\n', '            uint256 sum = quantityOptions.add(amountBMax);\n', '            _transferFromCaller(underlying, sum);\n', '        }\n', '        // Pushes underlyingTokens to option contract and mints option + redeem tokens to this contract.\n', '        IERC20(underlying).safeTransfer(optionAddress, quantityOptions);\n', '        (, uint256 outputRedeems) = IOption(optionAddress).mintOptions(address(this));\n', '\n', '        {\n', '            // scope for adding exact liquidity, avoids stack too deep errors\n', '            IOption optionToken = IOption(optionAddress);\n', '            address redeem = optionToken.redeemToken();\n', '            AddAmounts memory params;\n', '            params.amountAMax = outputRedeems;\n', '            params.amountBMax = amountBMax;\n', '            params.amountAMin = outputRedeems;\n', '            params.amountBMin = amountBMin;\n', '            params.deadline = deadline;\n', '            // Approves Uniswap V2 Pair pull tokens from this contract.\n', '            checkApproval(redeem, address(_router));\n', '            checkApproval(underlying, address(_router));\n', '            // Adds liquidity to Uniswap V2 Pair and returns liquidity shares to the "getCaller()" address.\n', '            (amountA, amountB, liquidity) = _addLiquidity(redeem, underlying, params);\n', '            // Check for exact liquidity provided.\n', '            assert(amountA == outputRedeems);\n', '            // Return remaining tokens\n', '            _transferToCaller(underlying);\n', '            _transferToCaller(redeem);\n', '            _transferToCaller(address(optionToken));\n', '        }\n', '        {\n', '            // scope for event, avoids stack too deep errors\n', '            address a0 = optionAddress;\n', '            uint256 q0 = quantityOptions;\n', '            uint256 q1 = amountBMax;\n', '            emit AddLiquidity(getCaller(), a0, q0.add(q1));\n', '        }\n', '        return (amountA, amountB, liquidity);\n', '    }\n', '\n', '    /**\n', '     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting shortOptionTokens with underlyingTokens.\n', "     *          Doesn't check for registered optionAddress because the returned function does.\n", '     * @notice  Pulls underlying tokens from `getCaller()` and pushes UNI-V2 liquidity tokens to the "getCaller()" address.\n', '     *          underlyingToken -> redeemToken -> UNI-V2. Uses permit so user does not need to `approve()` our contracts.\n', '     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\n', '     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\n', '     * @param   amountBMax The quantity of underlyingTokens to add with shortOptionTokens to the Uniswap V2 Pair.\n', '     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\n', '     * @param   deadline The timestamp to expire a pending transaction.\n', '     * @return  Returns (amountA, amountB, liquidity) amounts.\n', '     */\n', '    function addShortLiquidityWithUnderlyingWithPermit(\n', '        address optionAddress,\n', '        uint256 quantityOptions,\n', '        uint256 amountBMax,\n', '        uint256 amountBMin,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '        override\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        IERC20Permit underlying =\n', '            IERC20Permit(IOption(optionAddress).getUnderlyingTokenAddress());\n', '        uint256 sum = quantityOptions.add(amountBMax);\n', '        underlying.permit(getCaller(), address(_primitiveRouter), sum, deadline, v, r, s);\n', '        return\n', '            addShortLiquidityWithUnderlying(\n', '                optionAddress,\n', '                quantityOptions,\n', '                amountBMax,\n', '                amountBMin,\n', '                deadline\n', '            );\n', '    }\n', '\n', '    /**\n', "     * @dev     Doesn't check for registered optionAddress because the returned function does.\n", '     * @notice  Specialized function for `permit` calling on Put options (DAI).\n', '     */\n', '    function addShortLiquidityDAIWithPermit(\n', '        address optionAddress,\n', '        uint256 quantityOptions,\n', '        uint256 amountBMax,\n', '        uint256 amountBMin,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '        override\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        DaiPermit dai = DaiPermit(IOption(optionAddress).getUnderlyingTokenAddress());\n', '        address caller = getCaller();\n', '        dai.permit(\n', '            caller,\n', '            address(_primitiveRouter),\n', '            IERC20Permit(address(dai)).nonces(caller),\n', '            deadline,\n', '            true,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        return\n', '            addShortLiquidityWithUnderlying(\n', '                optionAddress,\n', '                quantityOptions,\n', '                amountBMax,\n', '                amountBMin,\n', '                deadline\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev     Adds redeemToken liquidity to a redeem<>underlyingToken pair by minting shortOptionTokens with underlyingTokens.\n', '     * @notice  Pulls underlying tokens from `getCaller()` and pushes UNI-V2 liquidity tokens to the `getCaller()` address.\n', '     *          underlyingToken -> redeemToken -> UNI-V2.\n', '     * @param   optionAddress The address of the optionToken to get the redeemToken to mint then provide liquidity for.\n', '     * @param   quantityOptions The quantity of underlyingTokens to use to mint option + redeem tokens.\n', '     * @param   amountBMax The quantity of underlyingTokens to add with shortOptionTokens to the Uniswap V2 Pair.\n', '     * @param   amountBMin The minimum quantity of underlyingTokens expected to provide liquidity with.\n', '     * @param   deadline The timestamp to expire a pending transaction.\n', '     * @return  Returns (amountA, amountB, liquidity) amounts.\n', '     */\n', '    function addShortLiquidityWithETH(\n', '        address optionAddress,\n', '        uint256 quantityOptions,\n', '        uint256 amountBMax,\n', '        uint256 amountBMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(IOption(optionAddress))\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        require(\n', '            msg.value >= quantityOptions.add(amountBMax),\n', '            "PrimitiveLiquidity: INSUFFICIENT"\n', '        );\n', '\n', '        uint256 amountA;\n', '        uint256 amountB;\n', '        uint256 liquidity;\n', '        address underlying = IOption(optionAddress).getUnderlyingTokenAddress();\n', '        require(underlying == address(_weth), "PrimitiveLiquidity: NOT_WETH");\n', '\n', '        _depositETH(); // Wraps `msg.value` to Weth.\n', '        // Pushes Weth to option contract and mints option + redeem tokens to this contract.\n', '        IERC20(underlying).safeTransfer(optionAddress, quantityOptions);\n', '        (, uint256 outputRedeems) = IOption(optionAddress).mintOptions(address(this));\n', '\n', '        {\n', '            // scope for adding exact liquidity, avoids stack too deep errors\n', '            IOption optionToken = IOption(optionAddress);\n', '            address redeem = optionToken.redeemToken();\n', '            AddAmounts memory params;\n', '            params.amountAMax = outputRedeems;\n', '            params.amountBMax = amountBMax;\n', '            params.amountAMin = outputRedeems;\n', '            params.amountBMin = amountBMin;\n', '            params.deadline = deadline;\n', '\n', '            // Approves Uniswap V2 Pair pull tokens from this contract.\n', '            checkApproval(redeem, address(_router));\n', '            checkApproval(underlying, address(_router));\n', '            // Adds liquidity to Uniswap V2 Pair.\n', '            (amountA, amountB, liquidity) = _addLiquidity(redeem, underlying, params);\n', '            assert(amountA == outputRedeems); // Check for exact liquidity provided.\n', '            // Return remaining tokens and ether.\n', '            _withdrawETH();\n', '            _transferToCaller(redeem);\n', '            _transferToCaller(address(optionToken));\n', '        }\n', '        {\n', '            // scope for event, avoids stack too deep errors\n', '            address a0 = optionAddress;\n', '            uint256 q0 = quantityOptions;\n', '            uint256 q1 = amountBMax;\n', '            emit AddLiquidity(getCaller(), a0, q0.add(q1));\n', '        }\n', '        return (amountA, amountB, liquidity);\n', '    }\n', '\n', '    struct AddAmounts {\n', '        uint256 amountAMax;\n', '        uint256 amountBMax;\n', '        uint256 amountAMin;\n', '        uint256 amountBMin;\n', '        uint256 deadline;\n', '    }\n', '\n', '    /**\n', "     * @notice  Calls UniswapV2Router02.addLiquidity() function using this contract's tokens.\n", '     * @param   tokenA The first token of the Uniswap Pair to add as liquidity.\n', '     * @param   tokenB The second token of the Uniswap Pair to add as liquidity.\n', '     * @param   params The amounts specified to be added as liquidity. Adds exact short options.\n', '     * @return  Returns (amountTokenA, amountTokenB, liquidity) amounts.\n', '     */\n', '    function _addLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        AddAmounts memory params\n', '    )\n', '        internal\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        return\n', '            _router.addLiquidity(\n', '                tokenA,\n', '                tokenB,\n', '                params.amountAMax,\n', '                params.amountBMax,\n', '                params.amountAMin,\n', '                params.amountBMin,\n', '                getCaller(),\n', '                params.deadline\n', '            );\n', '    }\n', '\n', '    /**\n', '     * @dev     Combines Uniswap V2 Router "removeLiquidity" function with Primitive "closeOptions" function.\n', '     * @notice  Pulls UNI-V2 liquidity shares with shortOption<>underlying token, and optionTokens from `getCaller()`.\n', '     *          Then closes the longOptionTokens and withdraws underlyingTokens to the `getCaller()` address.\n', '     *          Sends underlyingTokens from the burned UNI-V2 liquidity shares to the `getCaller()` address.\n', '     *          UNI-V2 -> optionToken -> underlyingToken.\n', '     * @param   optionAddress The address of the option that will be closed from burned UNI-V2 liquidity shares.\n', '     * @param   liquidity The quantity of liquidity tokens to pull from `getCaller()` and burn.\n', '     * @param   amountAMin The minimum quantity of shortOptionTokens to receive from removing liquidity.\n', '     * @param   amountBMin The minimum quantity of underlyingTokens to receive from removing liquidity.\n', '     * @return  Returns the sum of the removed underlying tokens.\n', '     */\n', '    function removeShortLiquidityThenCloseOptions(\n', '        address optionAddress,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin\n', '    )\n', '        public\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(IOption(optionAddress))\n', '        returns (uint256)\n', '    {\n', '        IOption optionToken = IOption(optionAddress);\n', '        (IUniswapV2Pair pair, address underlying, address redeem) =\n', '            getOptionPair(optionToken);\n', '        // Gets amounts struct.\n', '        RemoveAmounts memory params;\n', '        params.liquidity = liquidity;\n', '        params.amountAMin = amountAMin;\n', '        params.amountBMin = amountBMin;\n', '        // Pulls lp tokens from `getCaller()` and pushes them to the pair in preparation to invoke `burn()`.\n', '        _transferFromCallerToReceiver(address(pair), liquidity, address(pair));\n', '        // Calls `burn` on the `pair`, returning amounts to this contract.\n', '        (, uint256 underlyingAmount) = _removeLiquidity(pair, redeem, underlying, params);\n', '        uint256 underlyingProceeds = _closeOptions(optionToken); // Returns amount of underlying tokens released.\n', '        // Return remaining tokens/ether.\n', '        _withdrawETH(); // Unwraps Weth and sends ether to `getCaller()`.\n', '        _transferToCaller(redeem); // Push any remaining redeemTokens from removing liquidity (dust).\n', '        _transferToCaller(underlying); // Pushes underlying token to `getCaller()`.\n', '        uint256 sum = underlyingProceeds.add(underlyingAmount); // Total underlyings sent to `getCaller()`.\n', '        emit RemoveLiquidity(getCaller(), address(optionToken), sum);\n', '        return sum;\n', '    }\n', '\n', '    /**\n', '     * @notice  Pulls LP tokens, burns them, removes liquidity, pull option token, burns then, pushes all underlying tokens.\n', '     * @dev     Uses permit to pull LP tokens.\n', '     * @param   optionAddress The address of the option that will be closed from burned UNI-V2 liquidity shares.\n', '     * @param   liquidity The quantity of liquidity tokens to pull from _msgSender() and burn.\n', '     * @param   amountAMin The minimum quantity of shortOptionTokens to receive from removing liquidity.\n', '     * @param   amountBMin The minimum quantity of underlyingTokens to receive from removing liquidity.\n', '     * @param   deadline The timestamp to expire a pending transaction and `permit` call.\n', '     * @return  Returns the sum of the removed underlying tokens.\n', '     */\n', '    function removeShortLiquidityThenCloseOptionsWithPermit(\n', '        address optionAddress,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external override returns (uint256) {\n', '        IOption optionToken = IOption(optionAddress);\n', '        (IUniswapV2Pair pair, , ) = getOptionPair(optionToken);\n', '        pair.permit(getCaller(), address(_primitiveRouter), liquidity, deadline, v, r, s);\n', '        return\n', '            removeShortLiquidityThenCloseOptions(\n', '                address(optionToken),\n', '                liquidity,\n', '                amountAMin,\n', '                amountBMin\n', '            );\n', '    }\n', '\n', '    struct RemoveAmounts {\n', '        uint256 liquidity;\n', '        uint256 amountAMin;\n', '        uint256 amountBMin;\n', '    }\n', '\n', '    /**\n', '     * @notice  Calls `UniswapV2Pair.burn(address(this))` to burn LP tokens for pair tokens.\n', '     * @param   pair The UniswapV2Pair contract to burn LP tokens of.\n', '     * @param   tokenA The first token of the pair.\n', '     * @param   tokenB The second token of the pair.\n', '     * @param   params The amounts to specify the amount to remove and minAmounts to withdraw.\n', '     * @return  Returns (amountTokenA, amountTokenB) which is (redeem, underlying) amounts.\n', '     */\n', '    function _removeLiquidity(\n', '        IUniswapV2Pair pair,\n', '        address tokenA,\n', '        address tokenB,\n', '        RemoveAmounts memory params\n', '    ) internal returns (uint256, uint256) {\n', '        (uint256 amount0, uint256 amount1) = pair.burn(address(this));\n', '        (address token0, ) = CoreLib.sortTokens(tokenA, tokenB);\n', '        (uint256 amountA, uint256 amountB) =\n', '            tokenA == token0 ? (amount0, amount1) : (amount1, amount0);\n', '        require(amountA >= params.amountAMin, "PrimitiveLiquidity: INSUFFICIENT_A");\n', '        require(amountB >= params.amountBMin, "PrimitiveLiquidity: INSUFFICIENT_B");\n', '        return (amountA, amountB);\n', '    }\n', '\n', '    // ===== View =====\n', '\n', '    /**\n', '     * @notice  Gets the UniswapV2Router02 contract address.\n', '     */\n', '    function getRouter() public view override returns (IUniswapV2Router02) {\n', '        return _router;\n', '    }\n', '\n', '    /**\n', '     * @notice  Gets the UniswapV2Factory contract address.\n', '     */\n', '    function getFactory() public view override returns (IUniswapV2Factory) {\n', '        return _factory;\n', '    }\n', '\n', '    /**\n', "     * @notice  Fetchs the Uniswap Pair for an option's redeemToken and underlyingToken params.\n", '     * @param   option The option token to get the corresponding UniswapV2Pair market.\n', '     * @return  The pair address, as well as the tokens of the pair.\n', '     */\n', '    function getOptionPair(IOption option)\n', '        public\n', '        view\n', '        override\n', '        returns (\n', '            IUniswapV2Pair,\n', '            address,\n', '            address\n', '        )\n', '    {\n', '        address redeem = option.redeemToken();\n', '        address underlying = option.getUnderlyingTokenAddress();\n', '        IUniswapV2Pair pair = IUniswapV2Pair(_factory.getPair(redeem, underlying));\n', '        return (pair, underlying, redeem);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', 'import {\n', '    IUniswapV2Router02\n', '} from "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol";\n', 'import {\n', '    IUniswapV2Factory\n', '} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol";\n', 'import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";\n', 'import {IOption} from "@primitivefi/contracts/contracts/option/interfaces/IOption.sol";\n', 'import {IERC20Permit} from "./IERC20Permit.sol";\n', '\n', 'interface IPrimitiveLiquidity {\n', '    // ==== External ====\n', '\n', '    function addShortLiquidityWithUnderlying(\n', '        address optionAddress,\n', '        uint256 quantityOptions,\n', '        uint256 amountBMax,\n', '        uint256 amountBMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function addShortLiquidityWithETH(\n', '        address optionAddress,\n', '        uint256 quantityOptions,\n', '        uint256 amountBMax,\n', '        uint256 amountBMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function addShortLiquidityWithUnderlyingWithPermit(\n', '        address optionAddress,\n', '        uint256 quantityOptions,\n', '        uint256 amountBMax,\n', '        uint256 amountBMin,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function addShortLiquidityDAIWithPermit(\n', '        address optionAddress,\n', '        uint256 quantityOptions,\n', '        uint256 amountBMax,\n', '        uint256 amountBMin,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '\n', '    function removeShortLiquidityThenCloseOptions(\n', '        address optionAddress,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin\n', '    ) external returns (uint256);\n', '\n', '    function removeShortLiquidityThenCloseOptionsWithPermit(\n', '        address optionAddress,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256);\n', '\n', '    // ==== View ====\n', '\n', '    function getRouter() external view returns (IUniswapV2Router02);\n', '\n', '    function getFactory() external view returns (IUniswapV2Factory);\n', '\n', '    function getOptionPair(IOption option)\n', '        external\n', '        view\n', '        returns (\n', '            IUniswapV2Pair,\n', '            address,\n', '            address\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   TestERC20\n', ' * @author  Primitive\n', ' * @notice  An opinionated ERC20 with `permit` to use ONLY for testing.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', 'import {IERC20Permit} from "../interfaces/IERC20Permit.sol";\n', 'import {SafeMath} from "@openzeppelin/contracts/math/SafeMath.sol";\n', '\n', 'contract TestERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    string public name = "Test Token";\n', '    string public symbol;\n', '    uint8 public constant decimals = 18;\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => uint256) public nonces;\n', '\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH =\n', '        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    constructor(\n', '        string memory name_,\n', '        string memory symbol_,\n', '        uint256 initialSupply\n', '    ) public {\n', '        name = name_;\n', '        symbol = symbol_;\n', '        _mint(msg.sender, initialSupply);\n', '        uint256 chainId;\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256(\n', '                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '                ),\n', '                keccak256(bytes(name_)),\n', '                keccak256(bytes("1")),\n', '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param to The address that will receive the minted tokens.\n', '     * @param value The amount of tokens to mint.\n', '     * @return A boolean that indicates if the operation was successful.\n', '     */\n', '    function mint(address to, uint256 value) public returns (bool) {\n', '        _mint(to, value);\n', '        return true;\n', '    }\n', '\n', '    function _mint(address to, uint256 value) internal {\n', '        totalSupply = totalSupply.add(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint256 value) internal {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 value\n', '    ) private {\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) private {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint256 value) external returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint256 value) external returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool) {\n', '        if (allowance[from][msg.sender] != uint256(-1)) {\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        }\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external {\n', '        require(deadline >= block.timestamp, "Primitive: EXPIRED");\n', '        bytes32 digest =\n', '            keccak256(\n', '                abi.encodePacked(\n', '                    "\\x19\\x01",\n', '                    DOMAIN_SEPARATOR,\n', '                    keccak256(\n', '                        abi.encode(\n', '                            PERMIT_TYPEHASH,\n', '                            owner,\n', '                            spender,\n', '                            value,\n', '                            nonces[owner]++,\n', '                            deadline\n', '                        )\n', '                    )\n', '                )\n', '            );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', '        require(\n', '            recoveredAddress != address(0) && recoveredAddress == owner,\n', '            "Primitive: INVALID_SIGNATURE"\n', '        );\n', '        _approve(owner, spender, value);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   Primitive Router\n', ' * @author  Primitive\n', ' * @notice  Contract to execute Primitive Connector functions.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', '// Open Zeppelin\n', 'import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";\n', 'import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";\n', 'import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n', 'import {SafeMath} from "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', 'import {\n', '    IPrimitiveRouter,\n', '    IRegistry,\n', '    IOption,\n', '    IERC20,\n', '    IWETH\n', '} from "./interfaces/IPrimitiveRouter.sol";\n', '\n', '/**\n', ' * @notice  Used to execute calls on behalf of the Router contract.\n', ' * @dev     Changes `msg.sender` context so the Router is not `msg.sender`.\n', ' */\n', 'contract Route {\n', '    function executeCall(address target, bytes calldata params) external payable {\n', '        (bool success, bytes memory returnData) = target.call.value(msg.value)(params);\n', '        require(success, "Route: EXECUTION_FAIL");\n', '    }\n', '}\n', '\n', 'contract PrimitiveRouter is IPrimitiveRouter, Ownable, Pausable, ReentrancyGuard {\n', "    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data.\n", '    using SafeMath for uint256; // Reverts on math underflows/overflows.\n', '\n', '    // Constants\n', '    address private constant _NO_CALLER = address(0x0); // Default state for `_CALLER`.\n', '\n', '    // Events\n', '    event Initialized(address indexed from); // Emmitted on deployment\n', '    event Executed(address indexed from, address indexed to, bytes params);\n', '    event RegisteredOptions(address[] indexed options);\n', '    event RegisteredConnectors(address[] indexed connectors, bool[] registered);\n', '\n', '    // State variables\n', '    IRegistry private _registry; // The Primitive Registry which deploys Option clones.\n', '    IWETH private _weth; // Canonical WETH9\n', '    Route private _route; // Intermediary to do connector.call() from.\n', '    address private _CONNECTOR = _NO_CALLER; // If _EXECUTING, the `connector` of the execute call param.\n', '    address private _CALLER = _NO_CALLER; // If _EXECUTING, the orginal `_msgSender()` of the execute call.\n', '    bool private _EXECUTING; // True if the `executeCall` function was called.\n', '\n', '    // Whitelisted mappings\n', '    mapping(address => bool) private _registeredConnectors;\n', '    mapping(address => bool) private _registeredOptions;\n', '\n', '    /**\n', '     * @notice  A mutex to use during an `execute` call.\n', '     * @dev     Checks to make sure the `_CONNECTOR` in state is the `msg.sender`.\n', '     *          Checks to make sure a `_CALLER` was set.\n', '     *          Fails if this modifier is triggered by an external call.\n', '     *          Fails if this modifier is triggered by calling a function without going through `executeCall`.\n', '     */\n', '    modifier isExec() {\n', '        require(_CONNECTOR == _msgSender(), "Router: NOT_CONNECTOR");\n', '        require(_CALLER != _NO_CALLER, "Router: NO_CALLER");\n', '        require(!_EXECUTING, "Router: IN_EXECUTION");\n', '        _EXECUTING = true;\n', '        _;\n', '        _EXECUTING = false;\n', '    }\n', '\n', '    // ===== Constructor =====\n', '\n', '    constructor(address weth_, address registry_) public {\n', '        require(address(_weth) == address(0x0), "Router: INITIALIZED");\n', '        _route = new Route();\n', '        _weth = IWETH(weth_);\n', '        _registry = IRegistry(registry_);\n', '        emit Initialized(_msgSender());\n', '    }\n', '\n', '    // ===== Pausability =====\n', '\n', '    /**\n', '     * @notice  Halts use of `executeCall`, and other functions that change state.\n', '     */\n', '    function halt() external override onlyOwner {\n', '        if (paused()) {\n', '            _unpause();\n', '        } else {\n', '            _pause();\n', '        }\n', '    }\n', '\n', '    // ===== Registration =====\n', '\n', '    /**\n', '     * @notice  Checks option against Primitive Registry. If from Registry, registers as true.\n', '     *          NOTE: Purposefully does not have `onlyOwner` modifier.\n', '     * @dev     Sets `optionAddresses` to true in the whitelisted options mapping, if from Registry.\n', '     * @param   optionAddresses The array of option addresses to update.\n', '     */\n', '    function setRegisteredOptions(address[] calldata optionAddresses)\n', '        external\n', '        override\n', '        returns (bool)\n', '    {\n', '        uint256 len = optionAddresses.length;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address option = optionAddresses[i];\n', '            require(isFromPrimitiveRegistry(IOption(option)), "Router: EVIL_OPTION");\n', '            _registeredOptions[option] = true;\n', '        }\n', '        emit RegisteredOptions(optionAddresses);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice  Allows the `owner` to set whitelisted connector contracts.\n', '     * @dev     Sets `connectors` to `isValid` in the whitelisted connectors mapping.\n', '     * @param   connectors The array of option addresses to update.\n', '     * @param   isValid Whether or not the optionAddress is registered.\n', '     */\n', '    function setRegisteredConnectors(address[] memory connectors, bool[] memory isValid)\n', '        public\n', '        override\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        uint256 len = connectors.length;\n', '        require(len == isValid.length, "Router: LENGTHS");\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address connector = connectors[i];\n', '            bool status = isValid[i];\n', '            _registeredConnectors[connector] = status;\n', '        }\n', '        emit RegisteredConnectors(connectors, isValid);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice  Checks an option against the Primitive Registry.\n', '     * @param   option The IOption token to check.\n', '     * @return  Whether or not the option was deployed from the Primitive Registry.\n', '     */\n', '    function isFromPrimitiveRegistry(IOption option) internal view returns (bool) {\n', '        return (address(option) ==\n', '            _registry.getOptionAddress(\n', '                option.getUnderlyingTokenAddress(),\n', '                option.getStrikeTokenAddress(),\n', '                option.getBaseValue(),\n', '                option.getQuoteValue(),\n', '                option.getExpiryTime()\n', '            ) &&\n', '            address(option) != address(0));\n', '    }\n', '\n', '    // ===== Operations =====\n', '\n', '    /**\n', '     * @notice  Transfers ERC20 tokens from the executing `_CALLER` to the executing `_CONNECTOR`.\n', '     * @param   token The address of the ERC20.\n', '     * @param   amount The amount of ERC20 to transfer.\n', '     * @return  Whether or not the transfer succeeded.\n', '     */\n', '    function transferFromCaller(address token, uint256 amount)\n', '        public\n', '        override\n', '        isExec\n', '        whenNotPaused\n', '        returns (bool)\n', '    {\n', '        IERC20(token).safeTransferFrom(\n', '            getCaller(), // Account to pull from\n', '            _msgSender(), // The connector\n', '            amount\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice  Transfers ERC20 tokens from the executing `_CALLER` to an arbitrary address.\n', '     * @param   token The address of the ERC20.\n', '     * @param   amount The amount of ERC20 to transfer.\n', '     * @return  Whether or not the transfer succeeded.\n', '     */\n', '    function transferFromCallerToReceiver(\n', '        address token,\n', '        uint256 amount,\n', '        address receiver\n', '    ) public override isExec whenNotPaused returns (bool) {\n', '        IERC20(token).safeTransferFrom(\n', '            getCaller(), // Account to pull from\n', '            receiver,\n', '            amount\n', '        );\n', '        return true;\n', '    }\n', '\n', '    // ===== Execute =====\n', '\n', '    /**\n', '     * @notice  Executes a call with `params` to the target `connector` contract from `_route`.\n', '     * @param   connector The Primitive Connector module to call.\n', '     * @param   params The encoded function data to use.\n', '     */\n', '    function executeCall(address connector, bytes calldata params)\n', '        external\n', '        payable\n', '        override\n', '        whenNotPaused\n', '    {\n', '        require(_registeredConnectors[connector], "Router: INVALID_CONNECTOR");\n', '        _CALLER = _msgSender();\n', '        _CONNECTOR = connector;\n', '        _route.executeCall.value(msg.value)(connector, params);\n', '        _CALLER = _NO_CALLER;\n', '        _CONNECTOR = _NO_CALLER;\n', '        emit Executed(_msgSender(), connector, params);\n', '    }\n', '\n', '    // ===== Fallback =====\n', '\n', '    receive() external payable whenNotPaused {\n', '        assert(_msgSender() == address(_weth)); // only accept ETH via fallback from the WETH contract\n', '    }\n', '\n', '    // ===== View =====\n', '\n', '    /**\n', '     * @notice  Returns the IWETH contract address.\n', '     */\n', '    function getWeth() public view override returns (IWETH) {\n', '        return _weth;\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns the Route contract which executes functions on behalf of this contract.\n', '     */\n', '    function getRoute() public view override returns (address) {\n', '        return address(_route);\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns the `_CALLER` which is set to `_msgSender()` during an `executeCall` invocation.\n', '     */\n', '    function getCaller() public view override returns (address) {\n', '        return _CALLER;\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns the Primitive Registry contract address.\n', '     */\n', '    function getRegistry() public view override returns (IRegistry) {\n', '        return _registry;\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns a bool if `option` is registered or not.\n', '     * @param   option The address of the Option to check if registered.\n', '     */\n', '    function getRegisteredOption(address option) external view override returns (bool) {\n', '        return _registeredOptions[option];\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns a bool if `connector` is registered or not.\n', '     * @param   connector The address of the Connector contract to check if registered.\n', '     */\n', '    function getRegisteredConnector(address connector)\n', '        external\n', '        view\n', '        override\n', '        returns (bool)\n', '    {\n', '        return _registeredConnectors[connector];\n', '    }\n', '\n', '    /**\n', '     * @notice  Returns the NPM package version and github version of this contract.\n', '     * @dev     For the npm package: @primitivefi/v1-connectors\n', '     *          For the repository: github.com/primitivefinance/primitive-v1-connectors\n', '     * @return  The apiVersion string.\n', '     */\n', '    function apiVersion() public pure override returns (string memory) {\n', '        return "2.0.0";\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "../GSN/Context.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "../GSN/Context.sol";\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'contract Pausable is Context {\n', '    /**\n', '     * @dev Emitted when the pause is triggered by `account`.\n', '     */\n', '    event Paused(address account);\n', '\n', '    /**\n', '     * @dev Emitted when the pause is lifted by `account`.\n', '     */\n', '    event Unpaused(address account);\n', '\n', '    bool private _paused;\n', '\n', '    /**\n', '     * @dev Initializes the contract in unpaused state.\n', '     */\n', '    constructor () internal {\n', '        _paused = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the contract is paused, and false otherwise.\n', '     */\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Pausable: paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Pausable: not paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(_msgSender());\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(_msgSender());\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', 'import {IOption} from "@primitivefi/contracts/contracts/option/interfaces/IOption.sol";\n', 'import {IERC20Permit} from "./IERC20Permit.sol";\n', '\n', 'interface IPrimitiveCore {\n', '    // ===== External =====\n', '\n', '    function safeMintWithETH(IOption optionToken)\n', '        external\n', '        payable\n', '        returns (uint256, uint256);\n', '\n', '    function safeMintWithPermit(\n', '        IOption optionToken,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256, uint256);\n', '\n', '    function safeExerciseWithETH(IOption optionToken)\n', '        external\n', '        payable\n', '        returns (uint256, uint256);\n', '\n', '    function safeExerciseForETH(IOption optionToken, uint256 exerciseQuantity)\n', '        external\n', '        returns (uint256, uint256);\n', '\n', '    function safeRedeemForETH(IOption optionToken, uint256 redeemQuantity)\n', '        external\n', '        returns (uint256);\n', '\n', '    function safeCloseForETH(IOption optionToken, uint256 closeQuantity)\n', '        external\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        );\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '// Copyright 2021 Primitive Finance\n', '//\n', '// Permission is hereby granted, free of charge, to any person obtaining a copy of\n', '// this software and associated documentation files (the "Software"), to deal in\n', '// the Software without restriction, including without limitation the rights to\n', '// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n', '// of the Software, and to permit persons to whom the Software is furnished to do\n', '// so, subject to the following conditions:\n', '//\n', '// The above copyright notice and this permission notice shall be included in all\n', '// copies or substantial portions of the Software.\n', '//\n', '// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '// SOFTWARE.\n', '\n', 'pragma solidity 0.6.2;\n', '\n', '/**\n', ' * @title   Primitive Core\n', ' * @author  Primitive\n', ' * @notice  A Connector with Ether abstractions for Primitive Option tokens.\n', ' * @dev     @primitivefi/[email\xa0protected]\n', ' */\n', '\n', '// Open Zeppelin\n', 'import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";\n', 'import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/SafeERC20.sol";\n', 'import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";\n', '// Primitive\n', 'import {CoreLib, SafeMath} from "../libraries/CoreLib.sol";\n', 'import {IPrimitiveCore, IERC20Permit, IOption} from "../interfaces/IPrimitiveCore.sol";\n', 'import {PrimitiveConnector} from "./PrimitiveConnector.sol";\n', '\n', 'contract PrimitiveCore is PrimitiveConnector, IPrimitiveCore, ReentrancyGuard {\n', "    using SafeERC20 for IERC20; // Reverts when `transfer` or `transferFrom` erc20 calls don't return proper data\n", '    using SafeMath for uint256; // Reverts on math underflows/overflows\n', '\n', '    event Initialized(address indexed from); // Emmitted on deployment\n', '    event Minted(\n', '        address indexed from,\n', '        address indexed option,\n', '        uint256 longQuantity,\n', '        uint256 shortQuantity\n', '    );\n', '    event Exercised(address indexed from, address indexed option, uint256 quantity);\n', '    event Redeemed(address indexed from, address indexed option, uint256 quantity);\n', '    event Closed(address indexed from, address indexed option, uint256 quantity);\n', '\n', '    // ===== Constructor =====\n', '\n', '    constructor(address weth_, address primitiveRouter_)\n', '        public\n', '        PrimitiveConnector(weth_, primitiveRouter_)\n', '    {\n', '        emit Initialized(_msgSender());\n', '    }\n', '\n', '    // ===== Weth Abstraction =====\n', '\n', '    /**\n', '     * @dev     Mints msg.value quantity of options and "quote" (option parameter) quantity of redeem tokens.\n', '     * @notice  This function is for options that have WETH as the underlying asset.\n', '     * @param   optionToken The address of the option token to mint.\n', '     * @return  (uint, uint) Returns the (long, short) option tokens minted\n', '     */\n', '    function safeMintWithETH(IOption optionToken)\n', '        external\n', '        payable\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(optionToken)\n', '        returns (uint256, uint256)\n', '    {\n', '        require(msg.value > 0, "PrimitiveCore: ERR_ZERO");\n', '        address caller = getCaller();\n', '        _depositETH(); // Deposits `msg.value` to Weth contract.\n', '        (uint256 long, uint256 short) = _mintOptionsToReceiver(optionToken, caller);\n', '        emit Minted(caller, address(optionToken), long, short);\n', '        return (long, short);\n', '    }\n', '\n', '    /**\n', '     * @dev     Mints "amount" quantity of options and "quote" (option parameter) quantity of redeem tokens.\n', '     * @notice  This function is for options that have an EIP2612 (permit) enabled token as the underlying asset.\n', '     * @param   optionToken The address of the option token to mint.\n', '     * @param   amount The quantity of options to mint.\n', '     * @param   deadline The timestamp which expires the `permit` call.\n', '     * @return  (uint, uint) Returns the (long, short) option tokens minted\n', '     */\n', '    function safeMintWithPermit(\n', '        IOption optionToken,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    )\n', '        external\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(optionToken)\n', '        returns (uint256, uint256)\n', '    {\n', "        // Permit minting using the caller's underlying tokens.\n", '        IERC20Permit(optionToken.getUnderlyingTokenAddress()).permit(\n', '            getCaller(),\n', '            address(_primitiveRouter),\n', '            amount,\n', '            deadline,\n', '            v,\n', '            r,\n', '            s\n', '        );\n', '        (uint256 long, uint256 short) = _mintOptionsFromCaller(optionToken, amount);\n', '        emit Minted(getCaller(), address(optionToken), long, short);\n', '        return (long, short);\n', '    }\n', '\n', '    /**\n', '     * @dev     Swaps msg.value of strikeTokens (ethers) to underlyingTokens.\n', '     *          Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\n', '     *          Msg.value (quote units) * base / quote = base units (underlyingTokens) to withdraw.\n', '     * @notice  This function is for options with WETH as the strike asset.\n', '     *          Burns option tokens, accepts ethers, and pushes out underlyingTokens.\n', '     * @param   optionToken The address of the option contract.\n', '     */\n', '    function safeExerciseWithETH(IOption optionToken)\n', '        public\n', '        payable\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(optionToken)\n', '        returns (uint256, uint256)\n', '    {\n', '        require(msg.value > 0, "PrimitiveCore: ZERO");\n', '\n', '        _depositETH(); // Deposits `msg.value` to Weth contract.\n', '\n', '        uint256 long = CoreLib.getProportionalLongOptions(optionToken, msg.value);\n', '        _transferFromCaller(address(optionToken), long); // Pull option tokens.\n', '\n', '        // Pushes option tokens and weth (strike asset), receives underlying tokens.\n', '        emit Exercised(getCaller(), address(optionToken), long);\n', '        return _exerciseOptions(optionToken, long);\n', '    }\n', '\n', '    /**\n', '     * @dev     Swaps strikeTokens to underlyingTokens, WETH, which is converted to ethers before withdrawn.\n', '     *          Uses the strike ratio as the exchange rate. Strike ratio = base / quote.\n', '     * @notice  This function is for options with WETH as the underlying asset.\n', '     *          Burns option tokens, pulls strikeTokens, and pushes out ethers.\n', '     * @param   optionToken The address of the option contract.\n', '     * @param   exerciseQuantity Quantity of optionTokens to exercise.\n', '     */\n', '    function safeExerciseForETH(IOption optionToken, uint256 exerciseQuantity)\n', '        public\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(optionToken)\n', '        returns (uint256, uint256)\n', '    {\n', '        address underlying = optionToken.getUnderlyingTokenAddress();\n', '        address strike = optionToken.getStrikeTokenAddress();\n', '        uint256 strikeQuantity =\n', '            CoreLib.getProportionalShortOptions(optionToken, exerciseQuantity);\n', '        // Pull options and strike assets from `getCaller()` and send to option contract.\n', '        _transferFromCallerToReceiver(\n', '            address(optionToken),\n', '            exerciseQuantity,\n', '            address(optionToken)\n', '        );\n', '        _transferFromCallerToReceiver(strike, strikeQuantity, address(optionToken));\n', '\n', '        // Release underlying tokens by invoking `exerciseOptions()`\n', '        (uint256 strikesPaid, uint256 options) =\n', '            optionToken.exerciseOptions(address(this), exerciseQuantity, new bytes(0));\n', "        _withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\n", '        emit Exercised(getCaller(), address(optionToken), exerciseQuantity);\n', '        return (strikesPaid, options);\n', '    }\n', '\n', '    /**\n', '     * @dev     Burns redeem tokens to withdraw strike tokens (ethers) at a 1:1 ratio.\n', '     * @notice  This function is for options that have WETH as the strike asset.\n', '     *          Converts WETH to ethers, and withdraws ethers to the receiver address.\n', '     * @param   optionToken The address of the option contract.\n', '     * @param   redeemQuantity The quantity of redeemTokens to burn.\n', '     */\n', '    function safeRedeemForETH(IOption optionToken, uint256 redeemQuantity)\n', '        public\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(optionToken)\n', '        returns (uint256)\n', '    {\n', '        // Require the strike token to be Weth.\n', '        address redeem = optionToken.redeemToken();\n', '        // Pull redeem tokens from `getCaller()` and send to option contract.\n', '        _transferFromCallerToReceiver(redeem, redeemQuantity, address(optionToken));\n', '        uint256 short = optionToken.redeemStrikeTokens(address(this));\n', "        _withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\n", '        emit Redeemed(getCaller(), address(optionToken), redeemQuantity);\n', '        return short;\n', '    }\n', '\n', '    /**\n', '     * @dev Burn optionTokens and redeemTokens to withdraw underlyingTokens (ethers).\n', '     * @notice This function is for options with WETH as the underlying asset.\n', '     * WETH underlyingTokens are converted to ethers before being sent to receiver.\n', '     * The redeemTokens to burn is equal to the optionTokens * strike ratio.\n', '     * inputOptions = inputRedeems / strike ratio = outUnderlyings\n', '     * @param optionToken The address of the option contract.\n', '     * @param closeQuantity Quantity of optionTokens to burn and an input to calculate how many redeems to burn.\n', '     */\n', '    function safeCloseForETH(IOption optionToken, uint256 closeQuantity)\n', '        public\n', '        override\n', '        nonReentrant\n', '        onlyRegistered(optionToken)\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        address redeem = optionToken.redeemToken();\n', '        uint256 short = CoreLib.getProportionalShortOptions(optionToken, closeQuantity);\n', '        // Pull redeem tokens from `getCaller()` and send to option contract.\n', '        _transferFromCallerToReceiver(redeem, short, address(optionToken));\n', '        // Pull options if not expired, and send to option contract.\n', '        if (optionToken.getExpiryTime() >= now) {\n', '            _transferFromCallerToReceiver(\n', '                address(optionToken),\n', '                closeQuantity,\n', '                address(optionToken)\n', '            );\n', '        }\n', '        // Release underlyingTokens by invoking `closeOptions()`\n', '        (uint256 inputRedeems, uint256 inputOptions, uint256 outUnderlyings) =\n', '            optionToken.closeOptions(address(this));\n', '\n', "        _withdrawETH(); // Unwraps this contract's balance of Weth and sends to `getCaller()`.\n", '        emit Closed(getCaller(), address(optionToken), closeQuantity);\n', '        return (inputRedeems, inputOptions, outUnderlyings);\n', '    }\n', '}']