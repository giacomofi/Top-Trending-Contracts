['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-22\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-20\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IOwnable {\n', '\n', '  function owner() external view returns (address);\n', '\n', '  function renounceOwnership() external;\n', '  \n', '  function transferOwnership( address newOwner_ ) external;\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '}\n', '\n', 'library SafeMathInt {\n', '\n', '    function sub(int256 a, int256 b)\n', '        internal\n', '        pure\n', '        returns (int256)\n', '    {\n', '        int256 c = a - b;\n', '        require((b >= 0 && c <= a) || (b < 0 && c > a));\n', '        return c;\n', '    }\n', '\n', '    function add(int256 a, int256 b)\n', '        internal\n', '        pure\n', '        returns (int256)\n', '    {\n', '        int256 c = a + b;\n', '        require((b >= 0 && c >= a) || (b < 0 && c < a));\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface IBondingCalculator {\n', '\n', '  function calcDebtRatio( uint pendingDebtDue_, uint managedTokenTotalSupply_ ) external pure returns ( uint debtRatio_ );\n', '\n', '  function calcBondPremium( uint debtRatio_, uint bondScalingFactor ) external pure returns ( uint premium_ );\n', '\n', '  function calcPrincipleValuation( uint k_, uint amountDeposited_, uint totalSupplyOfTokenDeposited_ ) external pure returns ( uint principleValuation_ );\n', '\n', '  function principleValuation( address principleTokenAddress_, uint amountDeposited_ ) external view returns ( uint principleValuation_ );\n', '\n', '  function calculateBondInterest( address treasury_, address principleTokenAddress_, uint amountDeposited_, uint bondScalingFactor ) external returns ( uint interestDue_ );\n', '}\n', '/**\n', 'interface IPrincipleDepository {\n', '\n', '  function getCurrentBondTerm() external returns ( uint, uint );\n', '\n', '  function treasury() external returns ( address );\n', '\n', '  function getBondCalculator() external returns ( address );\n', '\n', '  function isPrincipleToken( address ) external returns ( bool );\n', '\n', '  function getDepositorInfoForDepositor( address ) external returns ( uint, uint, uint );\n', '\n', '  function addPrincipleToken( address newPrincipleToken_ ) external returns ( bool );\n', '\n', '  function setTreasury( address newTreasury_ ) external returns ( bool );\n', '\n', '  function addBondTerm( address bondPrincipleToken_, uint256 bondScalingFactor_, uint256 bondingPeriodInBlocks_ ) external returns ( bool );\n', '\n', '  function getDepositorInfo( address depositorAddress_) external view returns ( uint principleAmount_, uint interestDue_, uint bondMaturationBlock_);\n', '\n', '  function depositBondPrinciple( address bondPrincipleTokenToDeposit_, uint256 amountToDeposit_ ) external returns ( bool );\n', '\n', '  function depositBondPrincipleWithPermit( address bondPrincipleTokenToDeposit_, uint256 amountToDeposit_, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external returns ( bool );\n', '\n', '  function withdrawPrincipleAndForfeitInterest( address bondPrincipleToWithdraw_ ) external returns ( bool );\n', '\n', '  function redeemBond(address bondPrincipleToRedeem_ ) external returns ( bool );\n', '}\n', '*/\n', 'interface ITreasury {\n', '  function getBondingCalculator() external returns ( address );\n', '  // function payDebt( address depositor_ ) external returns ( bool );\n', '  function getTimelockEndBlock() external returns ( uint );\n', '  function getManagedToken() external returns ( address );\n', '  // function getDebtAmountDue() external returns ( uint );\n', '  // function incurDebt( uint principieTokenAmountDeposited_, uint bondScalingValue_ ) external returns ( bool );\n', '}\n', '\n', 'library Address {\n', '\n', '  function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract Ownable is IOwnable {\n', '\n', '  address internal _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor () {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred( address(0), _owner );\n', '  }\n', '\n', '  function owner() public view override returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  modifier onlyOwner() {\n', '    require( _owner == msg.sender, "Ownable: caller is not the owner" );\n', '    _;\n', '  }\n', '\n', '  function renounceOwnership() public virtual override onlyOwner() {\n', '    emit OwnershipTransferred( _owner, address(0) );\n', '    _owner = address(0);\n', '  }\n', '\n', '  function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {\n', '    require( newOwner_ != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred( _owner, newOwner_ );\n', '    _owner = newOwner_;\n', '  }\n', '}\n', '\n', 'interface IERC20 {\n', '\n', '  function decimals() external view returns (uint8);\n', '  /**\n', '   * @dev Returns the amount of tokens in existence.\n', '   */\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the amount of tokens owned by `account`.\n', '   */\n', '  function balanceOf(address account) external view returns (uint256);\n', '\n', '  /**\n', "   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   */\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Returns the remaining number of tokens that `spender` will be\n', '   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '   * zero by default.\n', '   *\n', '   * This value changes when {approve} or {transferFrom} are called.\n', '   */\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '  /**\n', "   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '   * that someone may use both the old and the new allowance by unfortunate\n', '   * transaction ordering. One possible solution to mitigate this race\n', "   * condition is to first reduce the spender's allowance to 0 and set the\n", '   * desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   *\n', '   * Emits an {Approval} event.\n', '   */\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "   * allowance mechanism. `amount` is then deducted from the caller's\n", '   * allowance.\n', '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   */\n', '  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '   * another (`to`).\n', '   *\n', '   * Note that `value` may be zero.\n', '   */\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  /**\n', '   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '   * a call to {approve}. `value` is the new allowance.\n', '   */\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', 'interface IERC20Mintable {\n', '\n', '  function mint( uint256 amount_ ) external;\n', '\n', '  function mint( address account_, uint256 ammount_ ) external;\n', '}\n', '\n', 'contract Vault is ITreasury, Ownable {\n', '\n', '  using SafeMath for uint;\n', '  using SafeMathInt for int;\n', '  using SafeERC20 for IERC20;\n', '\n', '  event TimelockStarted( uint timelockEndBlock );\n', '\n', '  bool public isInitialized;\n', '\n', '  uint public timelockDurationInBlocks;\n', '  bool public isTimelockSet;\n', '  uint public override getTimelockEndBlock;\n', '\n', '  address public daoWallet;\n', '  address public LPRewardsContract;\n', '  address public stakingContract;\n', '\n', '  uint public LPProfitShare;\n', '\n', '  uint public getPrincipleTokenBalance;\n', '\n', '  address public override getManagedToken;\n', '  address public getReserveToken;\n', '  address public getPrincipleToken;\n', '\n', '  address public override getBondingCalculator;\n', '\n', '  mapping( address => bool ) public isReserveToken;\n', '\n', '  mapping( address => bool ) public isPrincipleToken;\n', '  \n', '  mapping( address => bool ) public isPrincipleDepositor;\n', '  \n', '  mapping( address => bool ) public isReserveDepositor;\n', '\n', '  modifier notInitialized() {\n', '    require( !isInitialized );\n', '    _;\n', '  }\n', '\n', '  modifier onlyReserveToken( address reserveTokenChallenge_ ) {\n', '    require( isReserveToken[reserveTokenChallenge_] == true, "Vault: reserveTokenChallenge_ is not a reserve Token." );\n', '    _;\n', '  }\n', '\n', '  modifier onlyPrincipleToken( address PrincipleTokenChallenge_ ) {\n', '    require( isPrincipleToken[PrincipleTokenChallenge_] == true, "Vault: PrincipleTokenChallenge_ is not a Principle token." );\n', '    _;\n', '  }\n', '  \n', '  modifier notTimelockSet() {\n', '    require( !isTimelockSet );\n', '    _;\n', '  }\n', '\n', '  modifier isTimelockExpired() {\n', '    require( getTimelockEndBlock != 0 );\n', '    require( isTimelockSet );\n', '    require( block.number >= getTimelockEndBlock );\n', '    _;\n', '  }\n', '\n', '  modifier isTimelockStarted() {\n', '    if( getTimelockEndBlock != 0 ) {\n', '      emit TimelockStarted( getTimelockEndBlock );\n', '    }\n', '    _;\n', '  }\n', '\n', '  function setDAOWallet( address newDAOWallet_ ) external onlyOwner() returns ( bool ) {\n', '    daoWallet = newDAOWallet_;\n', '    return true;\n', '  }\n', '\n', '  function setStakingContract( address newStakingContract_ ) external onlyOwner() returns ( bool ) {\n', '    stakingContract = newStakingContract_;\n', '    return true;\n', '  }\n', '\n', '  function setLPRewardsContract( address newLPRewardsContract_ ) external onlyOwner() returns ( bool ) {\n', '    LPRewardsContract = newLPRewardsContract_;\n', '    return true;\n', '  }\n', '\n', '  function setLPProfitShare( uint newDAOProfitShare_ ) external onlyOwner() returns ( bool ) {\n', '    LPProfitShare = newDAOProfitShare_;\n', '    return true;\n', '  }\n', '\n', '  function initialize(\n', '    address newManagedToken_,\n', '    address newReserveToken_,\n', '    address newBondingCalculator_,\n', '    address newLPRewardsContract_\n', '  ) external onlyOwner() notInitialized() returns ( bool ) {\n', '    getManagedToken = newManagedToken_;\n', '    getReserveToken = newReserveToken_;\n', '    isReserveToken[newReserveToken_] = true;\n', '    getBondingCalculator = newBondingCalculator_;\n', '    LPRewardsContract = newLPRewardsContract_;\n', '    isInitialized = true;\n', '    return true;\n', '  }\n', '\n', '  function setPrincipleToken( address newPrincipleToken_ ) external onlyOwner() returns ( bool ) {\n', '    getPrincipleToken = newPrincipleToken_;\n', '    isPrincipleToken[newPrincipleToken_] = true;\n', '    return true;\n', '  }\n', '  \n', '  function setPrincipleDepositor( address newDepositor_ ) external onlyOwner() returns ( bool ) {\n', '    isPrincipleDepositor[newDepositor_] = true;\n', '    return true;\n', '  }\n', '  \n', '  function setReserveDepositor( address newDepositor_ ) external onlyOwner() returns ( bool ) {\n', '    isReserveDepositor[newDepositor_] = true;\n', '    return true;\n', '  }\n', '  \n', '  function removePrincipleDepositor( address depositor_ ) external onlyOwner() returns ( bool ) {\n', '    isPrincipleDepositor[depositor_] = false;\n', '    return true;\n', '  }\n', '  \n', '  function removeReserveDepositor( address depositor_ ) external onlyOwner() returns ( bool ) {\n', '    isReserveDepositor[depositor_] = false;\n', '    return true;\n', '  }\n', '\n', '  function rewardsDepositPrinciple( uint depositAmount_ ) external returns ( bool ) {\n', '    require(isReserveDepositor[msg.sender] == true, "Not allowed to deposit");\n', '    address principleToken = getPrincipleToken;\n', '    IERC20( principleToken ).safeTransferFrom( msg.sender, address(this), depositAmount_ );\n', '    uint value = IBondingCalculator( getBondingCalculator ).principleValuation( principleToken, depositAmount_ ).div( 1e9 );\n', '    uint forLP = value.div( LPProfitShare );\n', '    IERC20Mintable( getManagedToken ).mint( stakingContract, value.sub( forLP ) );\n', '    IERC20Mintable( getManagedToken ).mint( LPRewardsContract, forLP );\n', '    return true;\n', '  }\n', '\n', ' function depositReserves( uint amount_ ) external returns ( bool ) {\n', '    require(isReserveDepositor[msg.sender] == true, "Not allowed to deposit");\n', '    IERC20( getReserveToken ).safeTransferFrom( msg.sender, address(this), amount_ );\n', '    address managedToken_ = getManagedToken;\n', '    IERC20Mintable( managedToken_ ).mint( msg.sender, amount_.div( 10 ** IERC20( managedToken_ ).decimals() ) );\n', '    return true;\n', '  }\n', '\n', '  function depositPrinciple( uint depositAmount_ ) external returns ( bool ) {\n', '    require(isPrincipleDepositor[msg.sender] == true, "Not allowed to deposit");\n', '    address principleToken = getPrincipleToken;\n', '    IERC20( principleToken ).safeTransferFrom( msg.sender, address(this), depositAmount_ );\n', '    uint value = IBondingCalculator( getBondingCalculator ).principleValuation( principleToken, depositAmount_ ).div( 1e9 );\n', '    IERC20Mintable( getManagedToken ).mint( msg.sender, value );\n', '    return true;\n', '  }\n', '  \n', '  function migrateReserveAndPrinciple() external onlyOwner() isTimelockExpired() returns ( bool saveGas_ ) {\n', '    IERC20( getReserveToken ).safeTransfer( daoWallet, IERC20( getReserveToken ).balanceOf( address( this ) ) );\n', '    IERC20( getPrincipleToken ).safeTransfer( daoWallet, IERC20( getPrincipleToken ).balanceOf( address( this ) ) );\n', '    return true;\n', '  }\n', '\n', '  function setTimelock( uint newTimelockDurationInBlocks_ ) external onlyOwner() notTimelockSet() returns ( bool ) {\n', '    timelockDurationInBlocks = newTimelockDurationInBlocks_;\n', '    return true;\n', '  }\n', '\n', '  function startTimelock() external onlyOwner() returns ( bool ) {\n', '    getTimelockEndBlock = block.number.add( timelockDurationInBlocks );\n', '    isTimelockSet = true;\n', '    emit TimelockStarted( getTimelockEndBlock );\n', '    return true;\n', '  }\n', '}']