['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import {SafeMath} from "./SafeMath.sol";\n', 'import {IERC20} from "./IERC20.sol";\n', 'import {SafeERC20} from "./SafeERC20.sol";\n', 'import {Address} from "./Address.sol";\n', 'import {IMarginPoolAddressesProvider} from "./IMarginPoolAddressesProvider.sol";\n', 'import {IXToken} from "./IXToken.sol";\n', 'import {IVariableDebtToken} from "./IVariableDebtToken.sol";\n', 'import {IPriceOracleGetter} from "./IPriceOracleGetter.sol";\n', 'import {IMarginPool} from "./IMarginPool.sol";\n', 'import {VersionedInitializable} from "./VersionedInitializable.sol";\n', 'import {Helpers} from "./Helpers.sol";\n', 'import {Errors} from "./Errors.sol";\n', 'import {WadRayMath} from "./WadRayMath.sol";\n', 'import {PercentageMath} from "./PercentageMath.sol";\n', 'import {ReserveLogic} from "./ReserveLogic.sol";\n', 'import {GenericLogic} from "./GenericLogic.sol";\n', 'import {ValidationLogic} from "./ValidationLogic.sol";\n', 'import {ReserveConfiguration} from "./ReserveConfiguration.sol";\n', 'import {UserConfiguration} from "./UserConfiguration.sol";\n', 'import {DataTypes} from "./DataTypes.sol";\n', 'import {MarginPoolStorage} from "./MarginPoolStorage.sol";\n', 'import {IUniswapV2Router02} from "./IUniswapV2Router02.sol";\n', '\n', 'interface ISwapMining {\n', '    function swapMint(\n', '        address account,\n', '        address input,\n', '        address output,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}\n', '\n', '/**\n', ' * @title MarginPool contract\n', " * @dev Main point of interaction with an Lever protocol's market\n", ' * - Users can:\n', ' *   # Deposit\n', ' *   # Withdraw\n', ' *   # Borrow\n', ' *   # Repay\n', ' *   # Liquidate positions\n', ' * - To be covered by a proxy contract, owned by the MarginPoolAddressesProvider of the specific market\n', ' * - All admin functions are callable by the MarginPoolConfigurator contract defined also in the\n', ' *   MarginPoolAddressesProvider\n', ' * @author Lever\n', ' **/\n', 'contract MarginPool is VersionedInitializable, IMarginPool, MarginPoolStorage {\n', '    using SafeMath for uint256;\n', '    using WadRayMath for uint256;\n', '    using PercentageMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    //main configuration parameters\n', '    uint256 public constant MAX_NUMBER_RESERVES = 128;\n', '    uint256 public constant MARGINPOOL_REVISION = 0x1;\n', '    IUniswapV2Router02 public uniswaper;\n', '    IUniswapV2Router02 public sushiSwaper;\n', '    address public wethAddress;\n', '    address public constant inchor = 0x11111112542D85B3EF69AE05771c2dCCff4fAa26;\n', '\n', '    modifier whenNotPaused() {\n', '        _whenNotPaused();\n', '        _;\n', '    }\n', '\n', '    modifier onlyMarginPoolConfigurator() {\n', '        _onlyMarginPoolConfigurator();\n', '        _;\n', '    }\n', '\n', '    function _whenNotPaused() internal view {\n', '        require(!_paused, Errors.MP_IS_PAUSED);\n', '    }\n', '\n', '    function _onlyMarginPoolConfigurator() internal view {\n', '        require(\n', '            _addressesProvider.getMarginPoolConfigurator() == msg.sender,\n', '            Errors.MP_CALLER_NOT_MARGIN_POOL_CONFIGURATOR\n', '        );\n', '    }\n', '\n', '    function getRevision() internal pure override returns (uint256) {\n', '        return MARGINPOOL_REVISION;\n', '    }\n', '\n', '    /**\n', '     * @dev Function is invoked by the proxy contract when the MarginPool contract is added to the\n', '     * MarginPoolAddressesProvider of the market.\n', '     * - Caching the address of the MarginPoolAddressesProvider in order to reduce gas consumption\n', '     *   on subsequent operations\n', '     * @param provider The address of the MarginPoolAddressesProvider\n', '     **/\n', '    function initialize(\n', '        IMarginPoolAddressesProvider provider,\n', '        IUniswapV2Router02 _uniswaper,\n', '        IUniswapV2Router02 _sushiSwaper,\n', '        address _weth\n', '    ) public initializer {\n', '        _addressesProvider = provider;\n', '        uniswaper = _uniswaper;\n', '        sushiSwaper = _sushiSwaper;\n', '        wethAddress = _weth;\n', '    }\n', '\n', '    /**\n', '     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying xTokens.\n', '     * - E.g. User deposits 100 USDC and gets in return 100 xUSDC\n', '     * @param asset The address of the underlying asset to deposit\n', '     * @param amount The amount to be deposited\n', '     * @param onBehalfOf The address that will receive the xTokens, same as msg.sender if the user\n', '     *   wants to receive them on his own wallet, or a different address if the beneficiary of xTokens\n', '     *   is a different wallet\n', '     **/\n', '    function deposit(\n', '        address asset,\n', '        uint256 amount,\n', '        address onBehalfOf\n', '    ) external override whenNotPaused {\n', '        DataTypes.ReserveData storage reserve = _reserves[asset];\n', '\n', '        ValidationLogic.validateDeposit(reserve, amount);\n', '\n', '        address xToken = reserve.xTokenAddress;\n', '\n', '        reserve.updateState();\n', '        reserve.updateInterestRates(asset, xToken, amount, 0);\n', '\n', '        IERC20(asset).safeTransferFrom(msg.sender, xToken, amount);\n', '        _depositLogic(asset, amount, onBehalfOf, xToken, reserve);\n', '    }\n', '\n', '    function reDeposit(\n', '        address asset,\n', '        uint256 amount,\n', '        address onBehalfOf\n', '    ) internal whenNotPaused {\n', '        DataTypes.ReserveData storage reserve = _reserves[asset];\n', '\n', '        ValidationLogic.validateDeposit(reserve, amount);\n', '\n', '        address xToken = reserve.xTokenAddress;\n', '\n', '        reserve.updateState();\n', '        reserve.updateInterestRates(asset, xToken, amount, 0);\n', '\n', '        IERC20(asset).safeTransfer(xToken, amount);\n', '        _depositLogic(asset, amount, onBehalfOf, xToken, reserve);\n', '    }\n', '\n', '    function _depositLogic(\n', '        address asset,\n', '        uint256 amount,\n', '        address onBehalfOf,\n', '        address xToken,\n', '        DataTypes.ReserveData storage reserve\n', '    ) internal {\n', '        uint256 variableDebt = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\n', '        if (variableDebt > 0) {\n', '            uint256 paybackAmount = variableDebt;\n', '\n', '            if (amount < paybackAmount) {\n', '                paybackAmount = amount;\n', '            }\n', '\n', '            IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n', '                onBehalfOf,\n', '                paybackAmount,\n', '                reserve.variableBorrowIndex\n', '            );\n', '\n', '            emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\n', '\n', '            if (variableDebt == paybackAmount) {\n', '                _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\n', '            }\n', '\n', '            if (amount > paybackAmount) {\n', '                bool isFirstDeposit =\n', '                    IXToken(xToken).mint(\n', '                        onBehalfOf,\n', '                        amount.sub(paybackAmount),\n', '                        reserve.liquidityIndex\n', '                    );\n', '\n', '                if (isFirstDeposit) {\n', '                    _usersConfig[onBehalfOf].setUsingAsCollateral(\n', '                        reserve.id,\n', '                        true\n', '                    );\n', '                    emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n', '                }\n', '\n', '                emit Deposit(\n', '                    asset,\n', '                    msg.sender,\n', '                    onBehalfOf,\n', '                    amount.sub(paybackAmount)\n', '                );\n', '            }\n', '        } else {\n', '            bool isFirstDeposit =\n', '                IXToken(xToken).mint(\n', '                    onBehalfOf,\n', '                    amount,\n', '                    reserve.liquidityIndex\n', '                );\n', '\n', '            if (isFirstDeposit) {\n', '                _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n', '                emit ReserveUsedAsCollateralEnabled(asset, onBehalfOf);\n', '            }\n', '\n', '            emit Deposit(asset, msg.sender, onBehalfOf, amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent xTokens owned\n', '     * E.g. User has 100 xUSDC, calls withdraw() and receives 100 USDC, burning the 100 xUSDC\n', '     * @param asset The address of the underlying asset to withdraw\n', '     * @param amount The underlying amount to be withdrawn\n', '     *   - Send the value type(uint256).max in order to withdraw the whole xToken balance\n', '     * @param to Address that will receive the underlying, same as msg.sender if the user\n', '     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n', '     *   different wallet\n', '     * @return The final amount withdrawn\n', '     **/\n', '    function withdraw(\n', '        address asset,\n', '        uint256 amount,\n', '        address to\n', '    ) external override whenNotPaused returns (uint256) {\n', '        DataTypes.ReserveData storage reserve = _reserves[asset];\n', '\n', '        address xToken = reserve.xTokenAddress;\n', '\n', '        uint256 userBalance = IXToken(xToken).balanceOf(msg.sender);\n', '\n', '        uint256 amountToWithdraw = amount;\n', '\n', '        if (amount == type(uint256).max) {\n', '            amountToWithdraw = userBalance;\n', '        }\n', '\n', '        ValidationLogic.validateWithdraw(\n', '            asset,\n', '            amountToWithdraw,\n', '            userBalance,\n', '            _reserves,\n', '            _usersConfig[msg.sender],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        reserve.updateState();\n', '\n', '        reserve.updateInterestRates(asset, xToken, 0, amountToWithdraw);\n', '\n', '        if (amountToWithdraw == userBalance) {\n', '            _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n', '            emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n', '        }\n', '\n', '        IXToken(xToken).burn(\n', '            msg.sender,\n', '            to,\n', '            amountToWithdraw,\n', '            reserve.liquidityIndex\n', '        );\n', '\n', '        emit Withdraw(asset, msg.sender, to, amountToWithdraw);\n', '\n', '        return amountToWithdraw;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n', '     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n', '     * corresponding debt token ( VariableDebtToken)\n', '     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n', '     *   and 100 variable debt tokens\n', '     * @param asset The address of the underlying asset to borrow\n', '     * @param amount The amount to be borrowed\n', '     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n', '     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n', '     * if he has been given credit delegation allowance\n', '     **/\n', '    function borrow(\n', '        address asset,\n', '        uint256 amount,\n', '        address onBehalfOf\n', '    ) external override whenNotPaused {\n', '        DataTypes.ReserveData storage reserve = _reserves[asset];\n', '\n', '        _executeBorrow(\n', '            ExecuteBorrowParams(\n', '                asset,\n', '                msg.sender,\n', '                onBehalfOf,\n', '                amount,\n', '                reserve.xTokenAddress,\n', '                true\n', '            )\n', '        );\n', '    }\n', '\n', '    function swapTokensForTokens(\n', '        uint256 amountIn,\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        bool isExactIn,\n', '        bool isUni\n', '    ) external override whenNotPaused {\n', '        _beforeSwap(path[0], amountIn);\n', '\n', '        IUniswapV2Router02 swaper = isUni ? uniswaper : sushiSwaper;\n', '        // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\n', '        IERC20(path[0]).safeApprove(address(swaper), 0);\n', '        IERC20(path[0]).safeApprove(address(swaper), amountIn);\n', '\n', '        uint256[] memory awards;\n', '        if (isExactIn) {\n', '            awards = swaper.swapExactTokensForTokens(\n', '                amountIn,\n', '                amountOut,\n', '                path,\n', '                address(this),\n', '                block.timestamp\n', '            );\n', '        } else {\n', '            awards = swaper.swapTokensForExactTokens(\n', '                amountOut,\n', '                amountIn,\n', '                path,\n', '                address(this),\n', '                block.timestamp\n', '            );\n', '        }\n', '\n', '        reDeposit(path[path.length - 1], awards[awards.length - 1], msg.sender);\n', '\n', '        if (amountIn > awards[0]) {\n', '            reDeposit(path[0], amountIn.sub(awards[0]), msg.sender);\n', '        }\n', '\n', '        ValidationLogic.validateSwap(\n', '            msg.sender,\n', '            _reserves,\n', '            _usersConfig[msg.sender],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '        ISwapMining(_addressesProvider.getSwapMiner()).swapMint(\n', '            msg.sender,\n', '            path[0],\n', '            path[path.length - 1],\n', '            awards[awards.length - 1]\n', '        );\n', '        \n', '        emit Swap(\n', '            msg.sender,\n', '            path[0],\n', '            path[path.length - 1],\n', '            awards[0],\n', '            awards[awards.length - 1]\n', '        );\n', '    }\n', '\n', '    function swapTokensForClosePosition(\n', '        uint256 amountIn,\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        bool isExactIn,\n', '        bool isUni\n', '    ) external override whenNotPaused {\n', '        _beforeClose(path[0], amountIn);\n', '\n', '        IUniswapV2Router02 swaper = isUni ? uniswaper : sushiSwaper;\n', '\n', '        // Approves the transfer for the swap. Approves for 0 first to comply with tokens that implement the anti frontrunning approval fix.\n', '        IERC20(path[0]).safeApprove(address(swaper), 0);\n', '        IERC20(path[0]).safeApprove(address(swaper), amountIn);\n', '\n', '        uint256[] memory awards;\n', '        if (isExactIn) {\n', '            awards = swaper.swapExactTokensForTokens(\n', '                amountIn,\n', '                amountOut,\n', '                path,\n', '                address(this),\n', '                block.timestamp\n', '            );\n', '        } else {\n', '            awards = swaper.swapTokensForExactTokens(\n', '                amountOut,\n', '                amountIn,\n', '                path,\n', '                address(this),\n', '                block.timestamp\n', '            );\n', '        }\n', '\n', '        reDeposit(path[path.length - 1], awards[awards.length - 1], msg.sender);\n', '\n', '        if (amountIn > awards[0]) {\n', '            reDeposit(path[0], amountIn.sub(awards[0]), msg.sender);\n', '        }\n', '\n', '        ValidationLogic.validateSwap(\n', '            msg.sender,\n', '            _reserves,\n', '            _usersConfig[msg.sender],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        ISwapMining(_addressesProvider.getSwapMiner()).swapMint(\n', '            msg.sender,\n', '            path[0],\n', '            path[path.length - 1],\n', '            awards[awards.length - 1]\n', '        );\n', '        emit Swap(\n', '            msg.sender,\n', '            path[0],\n', '            path[path.length - 1],\n', '            awards[0],\n', '            awards[awards.length - 1]\n', '        );\n', '    }\n', '\n', '    function swapWithAggregation(\n', '        address _reserve,\n', '        uint256 amount,\n', '        address _reserveTo,\n', '        bytes memory codes,\n', '        uint256 gas,\n', '        uint8 swapType\n', '    ) external {\n', '        _beforeSwap(_reserve, amount);\n', '\n', '        IERC20(_reserve).safeApprove(inchor, 0);\n', '        IERC20(_reserve).safeApprove(inchor, amount);\n', '\n', '        (bool success, bytes memory result) = inchor.call{gas: gas}(codes);\n', '\n', '        require(success, "swap failed");\n', '\n', '        uint256 award;\n', '\n', '        if (swapType == 1) {\n', '            award = abi.decode(result, (uint256));\n', '        }\n', '\n', '        if (swapType == 2) {\n', '            (award, ) = abi.decode(result, (uint256, uint256));\n', '        }\n', '\n', '        if (swapType == 3) {\n', '            (award, , ) = abi.decode(result, (uint256, uint256, uint256));\n', '        }\n', '\n', '        reDeposit(_reserveTo, award, msg.sender);\n', '\n', '        ValidationLogic.validateSwap(\n', '            msg.sender,\n', '            _reserves,\n', '            _usersConfig[msg.sender],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        ISwapMining(_addressesProvider.getSwapMiner()).swapMint(\n', '            msg.sender,\n', '            _reserve,\n', '            _reserveTo,\n', '            award\n', '        );\n', '        emit Swap(msg.sender, _reserve, _reserveTo, amount, award);\n', '    }\n', '\n', '    function closeWithAggregation(\n', '        address _reserve,\n', '        uint256 amountIn,\n', '        address _reserveTo,\n', '        bytes memory codes,\n', '        uint256 gas,\n', '        uint8 swapType\n', '    ) external {\n', '        _beforeClose(_reserve, amountIn);\n', '\n', '        IERC20(_reserve).safeApprove(inchor, 0);\n', '        IERC20(_reserve).safeApprove(inchor, amountIn);\n', '\n', '        (bool success, bytes memory result) = inchor.call{gas: gas}(codes);\n', '\n', '        require(success, "swap failed");\n', '\n', '        uint256 award;\n', '\n', '        if (swapType == 1) {\n', '            award = abi.decode(result, (uint256));\n', '        }\n', '\n', '        if (swapType == 2) {\n', '            (award, ) = abi.decode(result, (uint256, uint256));\n', '        }\n', '\n', '        if (swapType == 3) {\n', '            (award, , ) = abi.decode(result, (uint256, uint256, uint256));\n', '        }\n', '\n', '        reDeposit(_reserveTo, award, msg.sender);\n', '\n', '        ValidationLogic.validateSwap(\n', '            msg.sender,\n', '            _reserves,\n', '            _usersConfig[msg.sender],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        ISwapMining(_addressesProvider.getSwapMiner()).swapMint(\n', '            msg.sender,\n', '            _reserve,\n', '            _reserveTo,\n', '            award\n', '        );\n', '        emit Swap(msg.sender, _reserve, _reserveTo, amountIn, award);\n', '    }\n', '\n', '    function _beforeClose(address _reserve, uint256 amountIn) private {\n', '        DataTypes.ReserveData storage reserve = _reserves[_reserve];\n', '        ValidationLogic.validateDeposit(reserve, amountIn);\n', '        reserve.updateState();\n', '\n', '        uint256 userBalance =\n', '            IXToken(reserve.xTokenAddress).balanceOf(msg.sender);\n', '\n', '        reserve.updateInterestRates(\n', '            _reserve,\n', '            reserve.xTokenAddress,\n', '            0,\n', '            amountIn\n', '        );\n', '\n', '        IXToken(reserve.xTokenAddress).burn(\n', '            msg.sender,\n', '            address(this),\n', '            amountIn,\n', '            reserve.liquidityIndex\n', '        );\n', '\n', '        if (amountIn == userBalance) {\n', '            _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n', '            emit ReserveUsedAsCollateralDisabled(_reserve, msg.sender);\n', '        }\n', '    }\n', '\n', '    function _beforeSwap(address _reserve, uint256 amountIn) private {\n', '        DataTypes.ReserveData storage reserve = _reserves[_reserve];\n', '        ValidationLogic.validateDeposit(reserve, amountIn);\n', '\n', '        DataTypes.UserConfigurationMap storage userConfig =\n', '            _usersConfig[msg.sender];\n', '\n', '        reserve.updateState();\n', '        bool isFirstBorrowing = false;\n', '        isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress)\n', '            .mint(\n', '            msg.sender,\n', '            msg.sender,\n', '            amountIn,\n', '            reserve.variableBorrowIndex\n', '        );\n', '        emit Borrow(\n', '            _reserve,\n', '            msg.sender,\n', '            msg.sender,\n', '            amountIn,\n', '            reserve.currentVariableBorrowRate\n', '        );\n', '\n', '        if (isFirstBorrowing) {\n', '            userConfig.setBorrowing(reserve.id, true);\n', '        }\n', '\n', '        reserve.updateInterestRates(\n', '            _reserve,\n', '            reserve.xTokenAddress,\n', '            0,\n', '            amountIn\n', '        );\n', '\n', '        IXToken(reserve.xTokenAddress).transferUnderlyingTo(\n', '            address(this),\n', '            amountIn\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n', '     * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the `onBehalfOf` address\n', '     * @param asset The address of the borrowed underlying asset previously borrowed\n', '     * @param amount The amount to repay\n', '     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n', '     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n', '     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n', '     * other borrower whose debt should be removed\n', '     * @return The final amount repaid\n', '     **/\n', '    function repay(\n', '        address asset,\n', '        uint256 amount,\n', '        address onBehalfOf\n', '    ) external override whenNotPaused returns (uint256) {\n', '        DataTypes.ReserveData storage reserve = _reserves[asset];\n', '\n', '        uint256 variableDebt = Helpers.getUserCurrentDebt(onBehalfOf, reserve);\n', '        address xToken = reserve.xTokenAddress;\n', '        uint256 userBalance = IERC20(xToken).balanceOf(msg.sender);\n', '\n', '        ValidationLogic.validateRepay(\n', '            reserve,\n', '            amount,\n', '            onBehalfOf,\n', '            variableDebt,\n', '            userBalance\n', '        );\n', '\n', '        uint256 paybackAmount = variableDebt;\n', '\n', '        if (amount < paybackAmount) {\n', '            paybackAmount = amount;\n', '        }\n', '\n', '        reserve.updateState();\n', '\n', '        IVariableDebtToken(reserve.variableDebtTokenAddress).burn(\n', '            onBehalfOf,\n', '            paybackAmount,\n', '            reserve.variableBorrowIndex\n', '        );\n', '\n', '        reserve.updateInterestRates(asset, xToken, 0, 0);\n', '\n', '        if (variableDebt.sub(paybackAmount) == 0) {\n', '            _usersConfig[onBehalfOf].setBorrowing(reserve.id, false);\n', '        }\n', '\n', '        if (paybackAmount == userBalance) {\n', '            _usersConfig[msg.sender].setUsingAsCollateral(reserve.id, false);\n', '            emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n', '        }\n', '\n', '        IXToken(xToken).burn(\n', '            msg.sender,\n', '            xToken,\n', '            paybackAmount,\n', '            reserve.liquidityIndex\n', '        );\n', '\n', '        emit Repay(asset, onBehalfOf, msg.sender, paybackAmount);\n', '\n', '        return paybackAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n', '     * @param asset The address of the underlying asset deposited\n', '     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n', '     **/\n', '    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n', '        external\n', '        override\n', '        whenNotPaused\n', '    {\n', '        DataTypes.ReserveData storage reserve = _reserves[asset];\n', '\n', '        ValidationLogic.validateSetUseReserveAsCollateral(\n', '            reserve,\n', '            asset,\n', '            useAsCollateral,\n', '            _reserves,\n', '            _usersConfig[msg.sender],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        _usersConfig[msg.sender].setUsingAsCollateral(\n', '            reserve.id,\n', '            useAsCollateral\n', '        );\n', '\n', '        if (useAsCollateral) {\n', '            emit ReserveUsedAsCollateralEnabled(asset, msg.sender);\n', '        } else {\n', '            emit ReserveUsedAsCollateralDisabled(asset, msg.sender);\n', '        }\n', '    }\n', '\n', '    struct LiquidationCallLocalVars {\n', '        uint256 variableDebt;\n', '        uint256 userBalance;\n', '        uint256 healthFactor;\n', '        uint256 maxCollateralToLiquidate;\n', '        uint256 collateralToSell;\n', '        uint256 liquidatorPreviousXTokenBalance;\n', '    }\n', '\n', '       /**\n', '     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n', '     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n', '     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n', '     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n', '     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n', '     * @param user The address of the borrower getting liquidated\n', '     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n', '     **/\n', '    function liquidationCall(\n', '        address collateralAsset,\n', '        address debtAsset,\n', '        address user,\n', '        uint256 debtToCover\n', '    ) external override whenNotPaused {\n', '        LiquidationCallLocalVars memory vars;\n', '        DataTypes.ReserveData storage collateralReserve =\n', '            _reserves[collateralAsset];\n', '        DataTypes.ReserveData storage debtReserve = _reserves[debtAsset];\n', '        DataTypes.UserConfigurationMap storage userConfig = _usersConfig[user];\n', '\n', '        vars.variableDebt = Helpers.getUserCurrentDebt(user, debtReserve).div(\n', '            2\n', '        );\n', '\n', '        (, , , , vars.healthFactor) = GenericLogic.calculateUserAccountData(\n', '            user,\n', '            _reserves,\n', '            _usersConfig[user],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        ValidationLogic.validateLiquidation(\n', '            collateralReserve,\n', '            debtReserve,\n', '            userConfig,\n', '            vars.healthFactor,\n', '            vars.variableDebt\n', '        );\n', '\n', '        vars.variableDebt = vars.variableDebt > debtToCover\n', '            ? debtToCover\n', '            : vars.variableDebt;\n', '\n', '        vars.userBalance = IERC20(collateralReserve.xTokenAddress).balanceOf(\n', '            user\n', '        );\n', '\n', '        (vars.maxCollateralToLiquidate, vars.collateralToSell) = GenericLogic\n', '            .calculateAvailableCollateralToLiquidate(\n', '            collateralReserve,\n', '            debtReserve,\n', '            collateralAsset,\n', '            debtAsset,\n', '            vars.variableDebt,\n', '            vars.userBalance,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        collateralReserve.updateState();\n', '\n', '        vars.liquidatorPreviousXTokenBalance = IERC20(\n', '            collateralReserve\n', '                .xTokenAddress\n', '        )\n', '            .balanceOf(msg.sender);\n', '\n', '        IXToken(collateralReserve.xTokenAddress).transferOnLiquidation(\n', '            user,\n', '            msg.sender,\n', '            (vars.maxCollateralToLiquidate.sub(vars.collateralToSell))\n', '        );\n', '\n', '        if (vars.liquidatorPreviousXTokenBalance == 0) {\n', '            DataTypes.UserConfigurationMap storage liquidatorConfig =\n', '                _usersConfig[msg.sender];\n', '            liquidatorConfig.setUsingAsCollateral(collateralReserve.id, true);\n', '            emit ReserveUsedAsCollateralEnabled(collateralAsset, msg.sender);\n', '        }\n', '\n', '        if (vars.maxCollateralToLiquidate == vars.userBalance) {\n', '              userConfig.setUsingAsCollateral(collateralReserve.id, false);\n', '              emit ReserveUsedAsCollateralDisabled(collateralAsset, user);\n', '        }\n', '\n', '        if(collateralAsset == debtAsset) {\n', '          IVariableDebtToken(collateralReserve.variableDebtTokenAddress).burn(\n', '              user,\n', '              vars.collateralToSell,\n', '              collateralReserve.variableBorrowIndex\n', '          );\n', '\n', '          collateralReserve.updateInterestRates(collateralAsset, collateralReserve.xTokenAddress, 0, 0);\n', '\n', '          IXToken(collateralReserve.xTokenAddress).burn(\n', '              user,\n', '              collateralReserve.xTokenAddress,\n', '              vars.collateralToSell,\n', '              collateralReserve.liquidityIndex\n', '          );\n', '          \n', '          emit LiquidationCall(\n', '              collateralAsset,\n', '              debtAsset,\n', '              user,\n', '              vars.collateralToSell,\n', '              vars.collateralToSell,\n', '              msg.sender\n', '          );\n', '          return;\n', '        }\n', '\n', '        collateralReserve.updateInterestRates(\n', '            collateralAsset,\n', '            collateralReserve.xTokenAddress,\n', '            0,\n', '            vars.collateralToSell\n', '        );\n', '\n', '        IXToken(collateralReserve.xTokenAddress).burn(\n', '            user,\n', '            address(this),\n', '            vars.collateralToSell,\n', '            collateralReserve.liquidityIndex\n', '        );\n', '\n', '        IERC20(collateralAsset).safeApprove(address(uniswaper), 0);\n', '        IERC20(collateralAsset).safeApprove(\n', '            address(uniswaper),\n', '            vars.collateralToSell\n', '        );\n', '\n', '        address[] memory path;\n', '        if (collateralAsset != wethAddress && debtAsset != wethAddress) {\n', '            path = new address[](3);\n', '            path[0] = collateralAsset;\n', '            path[1] = wethAddress;\n', '            path[2] = debtAsset;\n', '        } else {\n', '            path = new address[](2);\n', '            path[0] = collateralAsset;\n', '            path[1] = debtAsset;\n', '        }\n', '\n', '        uint256[] memory awards =\n', '            uniswaper.swapExactTokensForTokens(\n', '                vars.collateralToSell,\n', '                vars.variableDebt.mul(97).div(100),\n', '                path,\n', '                address(this),\n', '                block.timestamp\n', '            );\n', '\n', '        reDeposit(debtAsset, awards[awards.length - 1], user);\n', '\n', '        emit LiquidationCall(\n', '            collateralAsset,\n', '            debtAsset,\n', '            user,\n', '            awards[awards.length - 1],\n', '            vars.collateralToSell,\n', '            msg.sender\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the state and configuration of the reserve\n', '     * @param asset The address of the underlying asset of the reserve\n', '     * @return The state of the reserve\n', '     **/\n', '    function getReserveData(address asset)\n', '        external\n', '        view\n', '        override\n', '        returns (DataTypes.ReserveData memory)\n', '    {\n', '        return _reserves[asset];\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the user account data across all the reserves\n', '     * @param user The address of the user\n', '     * @return totalCollateralETH the total collateral in ETH of the user\n', '     * @return totalDebtETH the total debt in ETH of the user\n', '     * @return availableBorrowsETH the borrowing power left of the user\n', '     * @return currentLiquidationThreshold the liquidation threshold of the user\n', '     * @return ltv the loan to value of the user\n', '     * @return healthFactor the current health factor of the user\n', '     **/\n', '    function getUserAccountData(address user)\n', '        external\n', '        view\n', '        override\n', '        returns (\n', '            uint256 totalCollateralETH,\n', '            uint256 totalDebtETH,\n', '            uint256 availableBorrowsETH,\n', '            uint256 currentLiquidationThreshold,\n', '            uint256 ltv,\n', '            uint256 healthFactor\n', '        )\n', '    {\n', '        (\n', '            totalCollateralETH,\n', '            totalDebtETH,\n', '            ltv,\n', '            currentLiquidationThreshold,\n', '            healthFactor\n', '        ) = GenericLogic.calculateUserAccountData(\n', '            user,\n', '            _reserves,\n', '            _usersConfig[user],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        availableBorrowsETH = GenericLogic.calculateAvailableBorrowsETH(\n', '            totalCollateralETH,\n', '            totalDebtETH,\n', '            ltv\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the configuration of the reserve\n', '     * @param asset The address of the underlying asset of the reserve\n', '     * @return The configuration of the reserve\n', '     **/\n', '    function getConfiguration(address asset)\n', '        external\n', '        view\n', '        override\n', '        returns (DataTypes.ReserveConfigurationMap memory)\n', '    {\n', '        return _reserves[asset].configuration;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the configuration of the user across all the reserves\n', '     * @param user The user address\n', '     * @return The configuration of the user\n', '     **/\n', '    function getUserConfiguration(address user)\n', '        external\n', '        view\n', '        override\n', '        returns (DataTypes.UserConfigurationMap memory)\n', '    {\n', '        return _usersConfig[user];\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the normalized income per unit of asset\n', '     * @param asset The address of the underlying asset of the reserve\n', "     * @return The reserve's normalized income\n", '     */\n', '    function getReserveNormalizedIncome(address asset)\n', '        external\n', '        view\n', '        virtual\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return _reserves[asset].getNormalizedIncome();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the normalized variable debt per unit of asset\n', '     * @param asset The address of the underlying asset of the reserve\n', '     * @return The reserve normalized variable debt\n', '     */\n', '    function getReserveNormalizedVariableDebt(address asset)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return _reserves[asset].getNormalizedDebt();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns if the MarginPool is paused\n', '     */\n', '    function paused() external view override returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the list of the initialized reserves\n', '     **/\n', '    function getReservesList()\n', '        external\n', '        view\n', '        override\n', '        returns (address[] memory)\n', '    {\n', '        address[] memory _activeReserves = new address[](_reservesCount);\n', '\n', '        for (uint256 i = 0; i < _reservesCount; i++) {\n', '            _activeReserves[i] = _reservesList[i];\n', '        }\n', '        return _activeReserves;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the cached MarginPoolAddressesProvider connected to this contract\n', '     **/\n', '    function getAddressesProvider()\n', '        external\n', '        view\n', '        override\n', '        returns (IMarginPoolAddressesProvider)\n', '    {\n', '        return _addressesProvider;\n', '    }\n', '\n', '    /**\n', '     * @dev Validates and finalizes an xToken transfer\n', '     * - Only callable by the overlying xToken of the `asset`\n', '     * @param asset The address of the underlying asset of the xToken\n', '     * @param from The user from which the xTokens are transferred\n', '     * @param to The user receiving the xTokens\n', '     * @param amount The amount being transferred/withdrawn\n', '     * @param balanceFromBefore The xToken balance of the `from` user before the transfer\n', '     * @param balanceToBefore The xToken balance of the `to` user before the transfer\n', '     */\n', '    function finalizeTransfer(\n', '        address asset,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 balanceFromBefore,\n', '        uint256 balanceToBefore\n', '    ) external override whenNotPaused {\n', '        require(\n', '            msg.sender == _reserves[asset].xTokenAddress,\n', '            Errors.MP_CALLER_MUST_BE_AN_XTOKEN\n', '        );\n', '\n', '        ValidationLogic.validateTransfer(\n', '            from,\n', '            _reserves,\n', '            _usersConfig[from],\n', '            _reservesList,\n', '            _reservesCount,\n', '            _addressesProvider.getPriceOracle()\n', '        );\n', '\n', '        uint256 reserveId = _reserves[asset].id;\n', '\n', '        if (from != to) {\n', '            if (balanceFromBefore.sub(amount) == 0) {\n', '                DataTypes.UserConfigurationMap storage fromConfig =\n', '                    _usersConfig[from];\n', '                fromConfig.setUsingAsCollateral(reserveId, false);\n', '                emit ReserveUsedAsCollateralDisabled(asset, from);\n', '            }\n', '\n', '            if (balanceToBefore == 0 && amount != 0) {\n', '                DataTypes.UserConfigurationMap storage toConfig =\n', '                    _usersConfig[to];\n', '                toConfig.setUsingAsCollateral(reserveId, true);\n', '                emit ReserveUsedAsCollateralEnabled(asset, to);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Initializes a reserve, activating it, assigning an xToken and debt tokens and an\n', '     * interest rate strategy\n', '     * - Only callable by the MarginPoolConfigurator contract\n', '     * @param asset The address of the underlying asset of the reserve\n', '     * @param xTokenAddress The address of the xToken that will be assigned to the reserve\n', '     * @param xTokenAddress The address of the VariableDebtToken that will be assigned to the reserve\n', '     * @param interestRateStrategyAddress The address of the interest rate strategy contract\n', '     **/\n', '    function initReserve(\n', '        address asset,\n', '        address xTokenAddress,\n', '        address variableDebtAddress,\n', '        address interestRateStrategyAddress\n', '    ) external override onlyMarginPoolConfigurator {\n', '        require(Address.isContract(asset), Errors.MP_NOT_CONTRACT);\n', '        _reserves[asset].init(\n', '            xTokenAddress,\n', '            variableDebtAddress,\n', '            interestRateStrategyAddress\n', '        );\n', '        _addReserveToList(asset);\n', '    }\n', '\n', '    /**\n', '     * @dev Updates the address of the interest rate strategy contract\n', '     * - Only callable by the MarginPoolConfigurator contract\n', '     * @param asset The address of the underlying asset of the reserve\n', '     * @param rateStrategyAddress The address of the interest rate strategy contract\n', '     **/\n', '    function setReserveInterestRateStrategyAddress(\n', '        address asset,\n', '        address rateStrategyAddress\n', '    ) external override onlyMarginPoolConfigurator {\n', '        _reserves[asset].interestRateStrategyAddress = rateStrategyAddress;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the configuration bitmap of the reserve as a whole\n', '     * - Only callable by the MarginPoolConfigurator contract\n', '     * @param asset The address of the underlying asset of the reserve\n', '     * @param configuration The new configuration bitmap\n', '     **/\n', '    function setConfiguration(address asset, uint256 configuration)\n', '        external\n', '        override\n', '        onlyMarginPoolConfigurator\n', '    {\n', '        _reserves[asset].configuration.data = configuration;\n', '    }\n', '\n', '    /**\n', '     * @dev Set the _pause state of a reserve\n', '     * - Only callable by the MarginPoolConfigurator contract\n', '     * @param val `true` to pause the reserve, `false` to un-pause it\n', '     */\n', '    function setPause(bool val) external override onlyMarginPoolConfigurator {\n', '        _paused = val;\n', '        if (_paused) {\n', '            emit Paused();\n', '        } else {\n', '            emit Unpaused();\n', '        }\n', '    }\n', '\n', '    struct ExecuteBorrowParams {\n', '        address asset;\n', '        address user;\n', '        address onBehalfOf;\n', '        uint256 amount;\n', '        address xTokenAddress;\n', '        bool releaseUnderlying;\n', '    }\n', '\n', '    function _executeBorrow(ExecuteBorrowParams memory vars) internal {\n', '        DataTypes.ReserveData storage reserve = _reserves[vars.asset];\n', '        DataTypes.UserConfigurationMap storage userConfig =\n', '            _usersConfig[vars.onBehalfOf];\n', '\n', '        address oracle = _addressesProvider.getPriceOracle();\n', '\n', '        uint256 amountInETH =\n', '            IPriceOracleGetter(oracle)\n', '                .getAssetPrice(vars.asset)\n', '                .mul(vars.amount)\n', '                .div(10**reserve.configuration.getDecimals());\n', '\n', '        ValidationLogic.validateBorrow(\n', '            reserve,\n', '            vars.onBehalfOf,\n', '            vars.amount,\n', '            amountInETH,\n', '            _reserves,\n', '            userConfig,\n', '            _reservesList,\n', '            _reservesCount,\n', '            oracle\n', '        );\n', '\n', '        reserve.updateState();\n', '\n', '        bool isFirstBorrowing = false;\n', '        isFirstBorrowing = IVariableDebtToken(reserve.variableDebtTokenAddress)\n', '            .mint(\n', '            vars.user,\n', '            vars.onBehalfOf,\n', '            vars.amount,\n', '            reserve.variableBorrowIndex\n', '        );\n', '\n', '        if (isFirstBorrowing) {\n', '            userConfig.setBorrowing(reserve.id, true);\n', '        }\n', '\n', '        reserve.updateInterestRates(\n', '            vars.asset,\n', '            vars.xTokenAddress,\n', '            0,\n', '            vars.releaseUnderlying ? vars.amount : 0\n', '        );\n', '\n', '        if (vars.releaseUnderlying) {\n', '            IXToken(vars.xTokenAddress).transferUnderlyingTo(\n', '                vars.user,\n', '                vars.amount\n', '            );\n', '        }\n', '\n', '        emit Borrow(\n', '            vars.asset,\n', '            vars.user,\n', '            vars.onBehalfOf,\n', '            vars.amount,\n', '            reserve.currentVariableBorrowRate\n', '        );\n', '    }\n', '\n', '    function _addReserveToList(address asset) internal {\n', '        uint256 reservesCount = _reservesCount;\n', '\n', '        require(\n', '            reservesCount < MAX_NUMBER_RESERVES,\n', '            Errors.MP_NO_MORE_RESERVES_ALLOWED\n', '        );\n', '\n', '        bool reserveAlreadyAdded =\n', '            _reserves[asset].id != 0 || _reservesList[0] == asset;\n', '\n', '        if (!reserveAlreadyAdded) {\n', '            _reserves[asset].id = uint8(reservesCount);\n', '            _reservesList[reservesCount] = asset;\n', '\n', '            _reservesCount = reservesCount + 1;\n', '        }\n', '    }\n', '}']