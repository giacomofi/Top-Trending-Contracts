['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-31\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', 'pragma solidity 0.8.2;\n', '\n', '\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IBoostedVaultWithLockup {\n', '    /**\n', '     * @dev Stakes a given amount of the StakingToken for the sender\n', '     * @param _amount Units of StakingToken\n', '     */\n', '    function stake(uint256 _amount) external;\n', '\n', '    /**\n', '     * @dev Stakes a given amount of the StakingToken for a given beneficiary\n', '     * @param _beneficiary Staked tokens are credited to this address\n', '     * @param _amount      Units of StakingToken\n', '     */\n', '    function stake(address _beneficiary, uint256 _amount) external;\n', '\n', '    /**\n', '     * @dev Withdraws stake from pool and claims any unlocked rewards.\n', '     * Note, this function is costly - the args for _claimRewards\n', '     * should be determined off chain and then passed to other fn\n', '     */\n', '    function exit() external;\n', '\n', '    /**\n', '     * @dev Withdraws stake from pool and claims any unlocked rewards.\n', '     * @param _first    Index of the first array element to claim\n', '     * @param _last     Index of the last array element to claim\n', '     */\n', '    function exit(uint256 _first, uint256 _last) external;\n', '\n', '    /**\n', '     * @dev Withdraws given stake amount from the pool\n', '     * @param _amount Units of the staked token to withdraw\n', '     */\n', '    function withdraw(uint256 _amount) external;\n', '\n', '    /**\n', '     * @dev Claims only the tokens that have been immediately unlocked, not including\n', '     * those that are in the lockers.\n', '     */\n', '    function claimReward() external;\n', '\n', '    /**\n', '     * @dev Claims all unlocked rewards for sender.\n', '     * Note, this function is costly - the args for _claimRewards\n', '     * should be determined off chain and then passed to other fn\n', '     */\n', '    function claimRewards() external;\n', '\n', '    /**\n', '     * @dev Claims all unlocked rewards for sender. Both immediately unlocked\n', '     * rewards and also locked rewards past their time lock.\n', '     * @param _first    Index of the first array element to claim\n', '     * @param _last     Index of the last array element to claim\n', '     */\n', '    function claimRewards(uint256 _first, uint256 _last) external;\n', '\n', '    /**\n', '     * @dev Pokes a given account to reset the boost\n', '     */\n', '    function pokeBoost(address _account) external;\n', '\n', '    /**\n', '     * @dev Gets the last applicable timestamp for this reward period\n', '     */\n', '    function lastTimeRewardApplicable() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Calculates the amount of unclaimed rewards per token since last update,\n', '     * and sums with stored to give the new cumulative reward per token\n', "     * @return 'Reward' per staked token\n", '     */\n', '    function rewardPerToken() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returned the units of IMMEDIATELY claimable rewards a user has to receive. Note - this\n', '     * does NOT include the majority of rewards which will be locked up.\n', '     * @param _account User address\n', '     * @return Total reward amount earned\n', '     */\n', '    function earned(address _account) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Calculates all unclaimed reward data, finding both immediately unlocked rewards\n', '     * and those that have passed their time lock.\n', '     * @param _account User address\n', '     * @return amount Total units of unclaimed rewards\n', '     * @return first Index of the first userReward that has unlocked\n', '     * @return last Index of the last userReward that has unlocked\n', '     */\n', '    function unclaimedRewards(address _account)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 amount,\n', '            uint256 first,\n', '            uint256 last\n', '        );\n', '}\n', '\n', 'contract ModuleKeys {\n', '    // Governance\n', '    // ===========\n', '    // keccak256("Governance");\n', '    bytes32 internal constant KEY_GOVERNANCE =\n', '        0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\n', '    //keccak256("Staking");\n', '    bytes32 internal constant KEY_STAKING =\n', '        0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\n', '    //keccak256("ProxyAdmin");\n', '    bytes32 internal constant KEY_PROXY_ADMIN =\n', '        0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\n', '\n', '    // mStable\n', '    // =======\n', '    // keccak256("OracleHub");\n', '    bytes32 internal constant KEY_ORACLE_HUB =\n', '        0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\n', '    // keccak256("Manager");\n', '    bytes32 internal constant KEY_MANAGER =\n', '        0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\n', '    //keccak256("Recollateraliser");\n', '    bytes32 internal constant KEY_RECOLLATERALISER =\n', '        0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\n', '    //keccak256("MetaToken");\n', '    bytes32 internal constant KEY_META_TOKEN =\n', '        0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\n', '    // keccak256("SavingsManager");\n', '    bytes32 internal constant KEY_SAVINGS_MANAGER =\n', '        0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\n', '    // keccak256("Liquidator");\n', '    bytes32 internal constant KEY_LIQUIDATOR =\n', '        0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\n', '    // keccak256("InterestValidator");\n', '    bytes32 internal constant KEY_INTEREST_VALIDATOR =\n', '        0xc10a28f028c7f7282a03c90608e38a4a646e136e614e4b07d119280c5f7f839f;\n', '}\n', '\n', 'interface INexus {\n', '    function governor() external view returns (address);\n', '\n', '    function getModule(bytes32 key) external view returns (address);\n', '\n', '    function proposeModule(bytes32 _key, address _addr) external;\n', '\n', '    function cancelProposedModule(bytes32 _key) external;\n', '\n', '    function acceptProposedModule(bytes32 _key) external;\n', '\n', '    function acceptProposedModules(bytes32[] calldata _keys) external;\n', '\n', '    function requestLockModule(bytes32 _key) external;\n', '\n', '    function cancelLockModule(bytes32 _key) external;\n', '\n', '    function lockModule(bytes32 _key) external;\n', '}\n', '\n', 'abstract contract ImmutableModule is ModuleKeys {\n', '    INexus public immutable nexus;\n', '\n', '    /**\n', '     * @dev Initialization function for upgradable proxy contracts\n', '     * @param _nexus Nexus contract address\n', '     */\n', '    constructor(address _nexus) {\n', '        require(_nexus != address(0), "Nexus address is zero");\n', '        nexus = INexus(_nexus);\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to allow function calls only from the Governor.\n', '     */\n', '    modifier onlyGovernor() {\n', '        _onlyGovernor();\n', '        _;\n', '    }\n', '\n', '    function _onlyGovernor() internal view {\n', '        require(msg.sender == _governor(), "Only governor can execute");\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to allow function calls only from the Governance.\n', '     *      Governance is either Governor address or Governance address.\n', '     */\n', '    modifier onlyGovernance() {\n', '        require(\n', '            msg.sender == _governor() || msg.sender == _governance(),\n', '            "Only governance can execute"\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to allow function calls only from the ProxyAdmin.\n', '     */\n', '    modifier onlyProxyAdmin() {\n', '        require(msg.sender == _proxyAdmin(), "Only ProxyAdmin can execute");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to allow function calls only from the Manager.\n', '     */\n', '    modifier onlyManager() {\n', '        require(msg.sender == _manager(), "Only manager can execute");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns Governor address from the Nexus\n', '     * @return Address of Governor Contract\n', '     */\n', '    function _governor() internal view returns (address) {\n', '        return nexus.governor();\n', '    }\n', '\n', '    /**\n', '     * @dev Returns Governance Module address from the Nexus\n', '     * @return Address of the Governance (Phase 2)\n', '     */\n', '    function _governance() internal view returns (address) {\n', '        return nexus.getModule(KEY_GOVERNANCE);\n', '    }\n', '\n', '    /**\n', '     * @dev Return Staking Module address from the Nexus\n', '     * @return Address of the Staking Module contract\n', '     */\n', '    function _staking() internal view returns (address) {\n', '        return nexus.getModule(KEY_STAKING);\n', '    }\n', '\n', '    /**\n', '     * @dev Return ProxyAdmin Module address from the Nexus\n', '     * @return Address of the ProxyAdmin Module contract\n', '     */\n', '    function _proxyAdmin() internal view returns (address) {\n', '        return nexus.getModule(KEY_PROXY_ADMIN);\n', '    }\n', '\n', '    /**\n', '     * @dev Return MetaToken Module address from the Nexus\n', '     * @return Address of the MetaToken Module contract\n', '     */\n', '    function _metaToken() internal view returns (address) {\n', '        return nexus.getModule(KEY_META_TOKEN);\n', '    }\n', '\n', '    /**\n', '     * @dev Return OracleHub Module address from the Nexus\n', '     * @return Address of the OracleHub Module contract\n', '     */\n', '    function _oracleHub() internal view returns (address) {\n', '        return nexus.getModule(KEY_ORACLE_HUB);\n', '    }\n', '\n', '    /**\n', '     * @dev Return Manager Module address from the Nexus\n', '     * @return Address of the Manager Module contract\n', '     */\n', '    function _manager() internal view returns (address) {\n', '        return nexus.getModule(KEY_MANAGER);\n', '    }\n', '\n', '    /**\n', '     * @dev Return SavingsManager Module address from the Nexus\n', '     * @return Address of the SavingsManager Module contract\n', '     */\n', '    function _savingsManager() internal view returns (address) {\n', '        return nexus.getModule(KEY_SAVINGS_MANAGER);\n', '    }\n', '\n', '    /**\n', '     * @dev Return Recollateraliser Module address from the Nexus\n', '     * @return  Address of the Recollateraliser Module contract (Phase 2)\n', '     */\n', '    function _recollateraliser() internal view returns (address) {\n', '        return nexus.getModule(KEY_RECOLLATERALISER);\n', '    }\n', '}\n', '\n', 'interface IRewardsDistributionRecipient {\n', '    function notifyRewardAmount(uint256 reward) external;\n', '\n', '    function getRewardToken() external view returns (IERC20);\n', '}\n', '\n', 'abstract contract InitializableRewardsDistributionRecipient is\n', '    IRewardsDistributionRecipient,\n', '    ImmutableModule\n', '{\n', '    // This address has the ability to distribute the rewards\n', '    address public rewardsDistributor;\n', '\n', '    constructor(address _nexus) ImmutableModule(_nexus) {}\n', '\n', '    /** @dev Recipient is a module, governed by mStable governance */\n', '    function _initialize(address _rewardsDistributor) internal {\n', '        rewardsDistributor = _rewardsDistributor;\n', '    }\n', '\n', '    /**\n', '     * @dev Only the rewards distributor can notify about rewards\n', '     */\n', '    modifier onlyRewardsDistributor() {\n', '        require(msg.sender == rewardsDistributor, "Caller is not reward distributor");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Change the rewardsDistributor - only called by mStable governor\n', '     * @param _rewardsDistributor   Address of the new distributor\n', '     */\n', '    function setRewardsDistribution(address _rewardsDistributor) external onlyGovernor {\n', '        rewardsDistributor = _rewardsDistributor;\n', '    }\n', '}\n', '\n', 'interface IBoostDirector {\n', '    function getBalance(address _user) external returns (uint256);\n', '\n', '    function setDirection(\n', '        address _old,\n', '        address _new,\n', '        bool _pokeNew\n', '    ) external;\n', '\n', '    function whitelistVaults(address[] calldata _vaults) external;\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender) + value;\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        unchecked {\n', '            uint256 oldAllowance = token.allowance(address(this), spender);\n', '            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n', '            uint256 newAllowance = oldAllowance - value;\n', '            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract InitializableReentrancyGuard {\n', '    bool private _notEntered;\n', '\n', '    function _initializeReentrancyGuard() internal {\n', '        // Storing an initial non-zero value makes deployment a bit more\n', '        // expensive, but in exchange the refund on every call to nonReentrant\n', '        // will be lower in amount. Since refunds are capped to a percetange of\n', "        // the total transaction's gas, it is best to keep them low in cases\n", '        // like this one, to increase the likelihood of the full refund coming\n', '        // into effect.\n', '        _notEntered = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '}\n', '\n', 'library StableMath {\n', '    /**\n', '     * @dev Scaling unit for use in specific calculations,\n', "     * where 1 * 10**18, or 1e18 represents a unit '1'\n", '     */\n', '    uint256 private constant FULL_SCALE = 1e18;\n', '\n', '    /**\n', '     * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\n', '     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\n', '     * bAsset ratio unit for use in exact calculations,\n', '     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\n', '     */\n', '    uint256 private constant RATIO_SCALE = 1e8;\n', '\n', '    /**\n', '     * @dev Provides an interface to the scaling unit\n', '     * @return Scaling unit (1e18 or 1 * 10**18)\n', '     */\n', '    function getFullScale() internal pure returns (uint256) {\n', '        return FULL_SCALE;\n', '    }\n', '\n', '    /**\n', '     * @dev Provides an interface to the ratio unit\n', '     * @return Ratio scale unit (1e8 or 1 * 10**8)\n', '     */\n', '    function getRatioScale() internal pure returns (uint256) {\n', '        return RATIO_SCALE;\n', '    }\n', '\n', '    /**\n', '     * @dev Scales a given integer to the power of the full scale.\n', '     * @param x   Simple uint256 to scale\n', '     * @return    Scaled value a to an exact number\n', '     */\n', '    function scaleInteger(uint256 x) internal pure returns (uint256) {\n', '        return x * FULL_SCALE;\n', '    }\n', '\n', '    /***************************************\n', '              PRECISE ARITHMETIC\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Multiplies two precise units, and then truncates by the full scale\n', '     * @param x     Left hand input to multiplication\n', '     * @param y     Right hand input to multiplication\n', '     * @return      Result after multiplying the two inputs and then dividing by the shared\n', '     *              scale unit\n', '     */\n', '    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        return mulTruncateScale(x, y, FULL_SCALE);\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\n', '     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\n', '     * @param x     Left hand input to multiplication\n', '     * @param y     Right hand input to multiplication\n', '     * @param scale Scale unit\n', '     * @return      Result after multiplying the two inputs and then dividing by the shared\n', '     *              scale unit\n', '     */\n', '    function mulTruncateScale(\n', '        uint256 x,\n', '        uint256 y,\n', '        uint256 scale\n', '    ) internal pure returns (uint256) {\n', '        // e.g. assume scale = fullScale\n', '        // z = 10e18 * 9e17 = 9e36\n', '        // return 9e38 / 1e18 = 9e18\n', '        return (x * y) / scale;\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\n', '     * @param x     Left hand input to multiplication\n', '     * @param y     Right hand input to multiplication\n', '     * @return      Result after multiplying the two inputs and then dividing by the shared\n', '     *              scale unit, rounded up to the closest base unit.\n', '     */\n', '    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        // e.g. 8e17 * 17268172638 = 138145381104e17\n', '        uint256 scaled = x * y;\n', '        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\n', '        uint256 ceil = scaled + FULL_SCALE - 1;\n', '        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\n', '        return ceil / FULL_SCALE;\n', '    }\n', '\n', '    /**\n', '     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\n', '     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\n', '     * @param x     Left hand input to division\n', '     * @param y     Right hand input to division\n', '     * @return      Result after multiplying the left operand by the scale, and\n', '     *              executing the division on the right hand input.\n', '     */\n', '    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        // e.g. 8e18 * 1e18 = 8e36\n', '        // e.g. 8e36 / 10e18 = 8e17\n', '        return (x * FULL_SCALE) / y;\n', '    }\n', '\n', '    /***************************************\n', '                  RATIO FUNCS\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Multiplies and truncates a token ratio, essentially flooring the result\n', '     *      i.e. How much mAsset is this bAsset worth?\n', '     * @param x     Left hand operand to multiplication (i.e Exact quantity)\n', '     * @param ratio bAsset ratio\n', '     * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\n', '     */\n', '    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\n', '        return mulTruncateScale(x, ratio, RATIO_SCALE);\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies and truncates a token ratio, rounding up the result\n', '     *      i.e. How much mAsset is this bAsset worth?\n', '     * @param x     Left hand input to multiplication (i.e Exact quantity)\n', '     * @param ratio bAsset ratio\n', '     * @return      Result after multiplying the two inputs and then dividing by the shared\n', '     *              ratio scale, rounded up to the closest base unit.\n', '     */\n', '    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\n', '        // e.g. How much mAsset should I burn for this bAsset (x)?\n', '        // 1e18 * 1e8 = 1e26\n', '        uint256 scaled = x * ratio;\n', '        // 1e26 + 9.99e7 = 100..00.999e8\n', '        uint256 ceil = scaled + RATIO_SCALE - 1;\n', '        // return 100..00.999e8 / 1e8 = 1e18\n', '        return ceil / RATIO_SCALE;\n', '    }\n', '\n', '    /**\n', '     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\n', '     *      i.e. How much bAsset is this mAsset worth?\n', '     * @param x     Left hand operand in division\n', '     * @param ratio bAsset ratio\n', '     * @return c    Result after multiplying the left operand by the scale, and\n', '     *              executing the division on the right hand input.\n', '     */\n', '    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\n', '        // e.g. 1e14 * 1e8 = 1e22\n', '        // return 1e22 / 1e12 = 1e10\n', '        return (x * RATIO_SCALE) / ratio;\n', '    }\n', '\n', '    /***************************************\n', '                    HELPERS\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Calculates minimum of two numbers\n', '     * @param x     Left hand input\n', '     * @param y     Right hand input\n', '     * @return      Minimum of the two inputs\n', '     */\n', '    function min(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        return x > y ? y : x;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculated maximum of two numbers\n', '     * @param x     Left hand input\n', '     * @param y     Right hand input\n', '     * @return      Maximum of the two inputs\n', '     */\n', '    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n', '        return x > y ? x : y;\n', '    }\n', '\n', '    /**\n', '     * @dev Clamps a value to an upper bound\n', '     * @param x           Left hand input\n', '     * @param upperBound  Maximum possible value to return\n', '     * @return            Input x clamped to a maximum value, upperBound\n', '     */\n', '    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\n', '        return x > upperBound ? upperBound : x;\n', '    }\n', '}\n', '\n', 'library Root {\n', '    /**\n', '     * @dev Returns the square root of a given number\n', '     * @param x Input\n', '     * @return y Square root of Input\n', '     */\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        if (x == 0) return 0;\n', '        else {\n', '            uint256 xx = x;\n', '            uint256 r = 1;\n', '            if (xx >= 0x100000000000000000000000000000000) {\n', '                xx >>= 128;\n', '                r <<= 64;\n', '            }\n', '            if (xx >= 0x10000000000000000) {\n', '                xx >>= 64;\n', '                r <<= 32;\n', '            }\n', '            if (xx >= 0x100000000) {\n', '                xx >>= 32;\n', '                r <<= 16;\n', '            }\n', '            if (xx >= 0x10000) {\n', '                xx >>= 16;\n', '                r <<= 8;\n', '            }\n', '            if (xx >= 0x100) {\n', '                xx >>= 8;\n', '                r <<= 4;\n', '            }\n', '            if (xx >= 0x10) {\n', '                xx >>= 4;\n', '                r <<= 2;\n', '            }\n', '            if (xx >= 0x8) {\n', '                r <<= 1;\n', '            }\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1; // Seven iterations should be enough\n', '            uint256 r1 = x / r;\n', '            return uint256(r < r1 ? r : r1);\n', '        }\n', '    }\n', '}\n', '\n', 'contract BoostedTokenWrapper is InitializableReentrancyGuard {\n', '    using StableMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '\n', '    IERC20 public immutable stakingToken;\n', '    IBoostDirector public immutable boostDirector;\n', '\n', '    uint256 private _totalBoostedSupply;\n', '    mapping(address => uint256) private _boostedBalances;\n', '    mapping(address => uint256) private _rawBalances;\n', '\n', '    // Vars for use in the boost calculations\n', '    uint256 private constant MIN_DEPOSIT = 1e18;\n', '    uint256 private constant MAX_VMTA = 400000e18;\n', '    uint256 private constant MAX_BOOST = 3e18;\n', '    uint256 private constant MIN_BOOST = 1e18;\n', '    uint256 private constant FLOOR = 95e16;\n', '    uint256 public immutable boostCoeff; // scaled by 10\n', '    uint256 public immutable priceCoeff;\n', '\n', '    /**\n', '     * @dev TokenWrapper constructor\n', '     * @param _stakingToken Wrapped token to be staked\n', '     * @param _boostDirector vMTA boost director\n', '     * @param _priceCoeff Rough price of a given LP token, to be used in boost calculations, where $1 = 1e18\n', '     */\n', '    constructor(\n', '        address _stakingToken,\n', '        address _boostDirector,\n', '        uint256 _priceCoeff,\n', '        uint256 _boostCoeff\n', '    ) {\n', '        stakingToken = IERC20(_stakingToken);\n', '        boostDirector = IBoostDirector(_boostDirector);\n', '        priceCoeff = _priceCoeff;\n', '        boostCoeff = _boostCoeff;\n', '    }\n', '\n', '    function _initialize(string memory _nameArg, string memory _symbolArg) internal {\n', '        _initializeReentrancyGuard();\n', '        _name = _nameArg;\n', '        _symbol = _symbolArg;\n', '    }\n', '\n', '    function name() public view virtual returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view virtual returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view virtual returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the total boosted amount\n', '     * @return uint256 total supply\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalBoostedSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Get the boosted balance of a given account\n', '     * @param _account User for which to retrieve balance\n', '     */\n', '    function balanceOf(address _account) public view returns (uint256) {\n', '        return _boostedBalances[_account];\n', '    }\n', '\n', '    /**\n', '     * @dev Get the RAW balance of a given account\n', '     * @param _account User for which to retrieve balance\n', '     */\n', '    function rawBalanceOf(address _account) public view returns (uint256) {\n', '        return _rawBalances[_account];\n', '    }\n', '\n', '    /**\n', '     * @dev Read the boost for the given address\n', '     * @param _account User for which to return the boost\n', '     * @return boost where 1x == 1e18\n', '     */\n', '    function getBoost(address _account) public view returns (uint256) {\n', '        return balanceOf(_account).divPrecisely(rawBalanceOf(_account));\n', '    }\n', '\n', '    /**\n', '     * @dev Deposits a given amount of StakingToken from sender\n', '     * @param _amount Units of StakingToken\n', '     */\n', '    function _stakeRaw(address _beneficiary, uint256 _amount) internal nonReentrant {\n', '        _rawBalances[_beneficiary] += _amount;\n', '        stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraws a given stake from sender\n', '     * @param _amount Units of StakingToken\n', '     */\n', '    function _withdrawRaw(uint256 _amount) internal nonReentrant {\n', '        _rawBalances[msg.sender] -= _amount;\n', '        stakingToken.safeTransfer(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Updates the boost for the given address according to the formula\n', '     * boost = min(0.5 + c * vMTA_balance / imUSD_locked^(7/8), 1.5)\n', '     * If rawBalance <= MIN_DEPOSIT, boost is 0\n', '     * @param _account User for which to update the boost\n', '     */\n', '    function _setBoost(address _account) internal {\n', '        uint256 rawBalance = _rawBalances[_account];\n', '        uint256 boostedBalance = _boostedBalances[_account];\n', '        uint256 boost = MIN_BOOST;\n', '\n', '        // Check whether balance is sufficient\n', '        // is_boosted is used to minimize gas usage\n', '        uint256 scaledBalance = (rawBalance * priceCoeff) / 1e18;\n', '        if (scaledBalance >= MIN_DEPOSIT) {\n', '            uint256 votingWeight = boostDirector.getBalance(_account);\n', '            boost = _computeBoost(scaledBalance, votingWeight);\n', '        }\n', '\n', '        uint256 newBoostedBalance = rawBalance.mulTruncate(boost);\n', '\n', '        if (newBoostedBalance != boostedBalance) {\n', '            _totalBoostedSupply = _totalBoostedSupply - boostedBalance + newBoostedBalance;\n', '            _boostedBalances[_account] = newBoostedBalance;\n', '\n', '            if(newBoostedBalance > boostedBalance) {\n', '                emit Transfer(address(0), _account, newBoostedBalance - boostedBalance);\n', '            } else {\n', '                emit Transfer(_account, address(0), boostedBalance - newBoostedBalance);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the boost for\n', '     * boost = min(m, max(1, 0.95 + c * min(voting_weight, f) / deposit^(7/8)))\n', '     * @param _scaledDeposit deposit amount in terms of USD\n', '     */\n', '    function _computeBoost(uint256 _scaledDeposit, uint256 _votingWeight)\n', '        private\n', '        view\n', '        returns (uint256 boost)\n', '    {\n', '        if (_votingWeight == 0) return MIN_BOOST;\n', '\n', '        // Compute balance to the power 7/8\n', '        // if price is     $0.10, do sqrt(_deposit * 1e5)\n', '        // if price is     $1.00, do sqrt(_deposit * 1e6)\n', '        // if price is $10000.00, do sqrt(_deposit * 1e9)\n', '        uint256 denominator = Root.sqrt(Root.sqrt(Root.sqrt(_scaledDeposit * 1e6)));\n', '        denominator =\n', '            denominator *\n', '            denominator *\n', '            denominator *\n', '            denominator *\n', '            denominator *\n', '            denominator *\n', '            denominator;\n', '        denominator /= 1e3;\n', '        boost = (((StableMath.min(_votingWeight, MAX_VMTA) * boostCoeff) / 10) * 1e18) / denominator;\n', '        boost = StableMath.min(MAX_BOOST, StableMath.max(MIN_BOOST, FLOOR + boost));\n', '    }\n', '}\n', '\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', 'library SafeCast {\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '// Internal\n', '// Libs\n', '/**\n', ' * @title  BoostedSavingsVault\n', ' * @author mStable\n', ' * @notice Accrues rewards second by second, based on a users boosted balance\n', ' * @dev    Forked from rewards/staking/StakingRewards.sol\n', ' *         Changes:\n', ' *          - Lockup implemented in `updateReward` hook (20% unlock immediately, 80% locked for 6 months)\n', ' *          - `updateBoost` hook called after every external action to reset a users boost\n', ' *          - Struct packing of common data\n', ' *          - Searching for and claiming of unlocked rewards\n', ' */\n', 'contract BoostedSavingsVault is\n', '    IBoostedVaultWithLockup,\n', '    Initializable,\n', '    InitializableRewardsDistributionRecipient,\n', '    BoostedTokenWrapper\n', '{\n', '    using SafeERC20 for IERC20;\n', '    using StableMath for uint256;\n', '    using SafeCast for uint256;\n', '\n', '    event RewardAdded(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount, address payer);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event Poked(address indexed user);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '\n', '    IERC20 public immutable rewardsToken;\n', '\n', '    uint64 public constant DURATION = 7 days;\n', '    // Length of token lockup, after rewards are earned\n', '    uint256 public constant LOCKUP = 26 weeks;\n', '    // Percentage of earned tokens unlocked immediately\n', '    uint64 public constant UNLOCK = 33e16;\n', '\n', '    // Timestamp for current period finish\n', '    uint256 public periodFinish;\n', '    // RewardRate for the rest of the PERIOD\n', '    uint256 public rewardRate;\n', '    // Last time any user took action\n', '    uint256 public lastUpdateTime;\n', '    // Ever increasing rewardPerToken rate, based on % of total supply\n', '    uint256 public rewardPerTokenStored;\n', '    mapping(address => UserData) public userData;\n', '    // Locked reward tracking\n', '    mapping(address => Reward[]) public userRewards;\n', '    mapping(address => uint64) public userClaim;\n', '\n', '    struct UserData {\n', '        uint128 rewardPerTokenPaid;\n', '        uint128 rewards;\n', '        uint64 lastAction;\n', '        uint64 rewardCount;\n', '    }\n', '\n', '    struct Reward {\n', '        uint64 start;\n', '        uint64 finish;\n', '        uint128 rate;\n', '    }\n', '\n', '    constructor(\n', '        address _nexus,\n', '        address _stakingToken,\n', '        address _boostDirector,\n', '        uint256 _priceCoeff,\n', '        uint256 _coeff,\n', '        address _rewardsToken\n', '    )\n', '        InitializableRewardsDistributionRecipient(_nexus)\n', '        BoostedTokenWrapper(_stakingToken, _boostDirector, _priceCoeff, _coeff)\n', '    {\n', '        rewardsToken = IERC20(_rewardsToken);\n', '    }\n', '\n', '    /**\n', '     * @dev StakingRewards is a TokenWrapper and RewardRecipient\n', '     * Constants added to bytecode at deployTime to reduce SLOAD cost\n', '     */\n', '    function initialize(address _rewardsDistributor, string calldata _nameArg, string calldata _symbolArg) external initializer {\n', '        InitializableRewardsDistributionRecipient._initialize(_rewardsDistributor);\n', '        BoostedTokenWrapper._initialize(_nameArg, _symbolArg);\n', '    }\n', '\n', '    /**\n', '     * @dev Updates the reward for a given address, before executing function.\n', '     * Locks 80% of new rewards up for 6 months, vesting linearly from (time of last action + 6 months) to\n', '     * (now + 6 months). This allows rewards to be distributed close to how they were accrued, as opposed\n', '     * to locking up for a flat 6 months from the time of this fn call (allowing more passive accrual).\n', '     */\n', '    modifier updateReward(address _account) {\n', '        uint256 currentTime = block.timestamp;\n', '        uint64 currentTime64 = SafeCast.toUint64(currentTime);\n', '\n', '        // Setting of global vars\n', '        (uint256 newRewardPerToken, uint256 lastApplicableTime) = _rewardPerToken();\n', '        // If statement protects against loss in initialisation case\n', '        if (newRewardPerToken > 0) {\n', '            rewardPerTokenStored = newRewardPerToken;\n', '            lastUpdateTime = lastApplicableTime;\n', '\n', '            // Setting of personal vars based on new globals\n', '            if (_account != address(0)) {\n', '                UserData memory data = userData[_account];\n', '                uint256 earned_ = _earned(_account, data.rewardPerTokenPaid, newRewardPerToken);\n', '\n', '                // If earned == 0, then it must either be the initial stake, or an action in the\n', '                // same block, since new rewards unlock after each block.\n', '                if (earned_ > 0) {\n', '                    uint256 unlocked = earned_.mulTruncate(UNLOCK);\n', '                    uint256 locked = earned_ - unlocked;\n', '\n', '                    userRewards[_account].push(\n', '                        Reward({\n', '                            start: SafeCast.toUint64(LOCKUP + data.lastAction),\n', '                            finish: SafeCast.toUint64(LOCKUP + currentTime),\n', '                            rate: SafeCast.toUint128(locked / (currentTime - data.lastAction))\n', '                        })\n', '                    );\n', '\n', '                    userData[_account] = UserData({\n', '                        rewardPerTokenPaid: SafeCast.toUint128(newRewardPerToken),\n', '                        rewards: SafeCast.toUint128(unlocked + data.rewards),\n', '                        lastAction: currentTime64,\n', '                        rewardCount: data.rewardCount + 1\n', '                    });\n', '                } else {\n', '                    userData[_account] = UserData({\n', '                        rewardPerTokenPaid: SafeCast.toUint128(newRewardPerToken),\n', '                        rewards: data.rewards,\n', '                        lastAction: currentTime64,\n', '                        rewardCount: data.rewardCount\n', '                    });\n', '                }\n', '            }\n', '        } else if (_account != address(0)) {\n', '            // This should only be hit once, for first staker in initialisation case\n', '            userData[_account].lastAction = currentTime64;\n', '        }\n', '        _;\n', '    }\n', '\n', '    /** @dev Updates the boost for a given address, after the rest of the function has executed */\n', '    modifier updateBoost(address _account) {\n', '        _;\n', '        _setBoost(_account);\n', '    }\n', '\n', '    /***************************************\n', '                ACTIONS - EXTERNAL\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Stakes a given amount of the StakingToken for the sender\n', '     * @param _amount Units of StakingToken\n', '     */\n', '    function stake(uint256 _amount)\n', '        external\n', '        override\n', '        updateReward(msg.sender)\n', '        updateBoost(msg.sender)\n', '    {\n', '        _stake(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Stakes a given amount of the StakingToken for a given beneficiary\n', '     * @param _beneficiary Staked tokens are credited to this address\n', '     * @param _amount      Units of StakingToken\n', '     */\n', '    function stake(address _beneficiary, uint256 _amount)\n', '        external\n', '        override\n', '        updateReward(_beneficiary)\n', '        updateBoost(_beneficiary)\n', '    {\n', '        _stake(_beneficiary, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraws stake from pool and claims any unlocked rewards.\n', '     * Note, this function is costly - the args for _claimRewards\n', '     * should be determined off chain and then passed to other fn\n', '     */\n', '    function exit() external override updateReward(msg.sender) updateBoost(msg.sender) {\n', '        _withdraw(rawBalanceOf(msg.sender));\n', '        (uint256 first, uint256 last) = _unclaimedEpochs(msg.sender);\n', '        _claimRewards(first, last);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraws stake from pool and claims any unlocked rewards.\n', '     * @param _first    Index of the first array element to claim\n', '     * @param _last     Index of the last array element to claim\n', '     */\n', '    function exit(uint256 _first, uint256 _last)\n', '        external\n', '        override\n', '        updateReward(msg.sender)\n', '        updateBoost(msg.sender)\n', '    {\n', '        _withdraw(rawBalanceOf(msg.sender));\n', '        _claimRewards(_first, _last);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraws given stake amount from the pool\n', '     * @param _amount Units of the staked token to withdraw\n', '     */\n', '    function withdraw(uint256 _amount)\n', '        external\n', '        override\n', '        updateReward(msg.sender)\n', '        updateBoost(msg.sender)\n', '    {\n', '        _withdraw(_amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Claims only the tokens that have been immediately unlocked, not including\n', '     * those that are in the lockers.\n', '     */\n', '    function claimReward() external override updateReward(msg.sender) updateBoost(msg.sender) {\n', '        uint256 unlocked = userData[msg.sender].rewards;\n', '        userData[msg.sender].rewards = 0;\n', '\n', '        if (unlocked > 0) {\n', '            rewardsToken.safeTransfer(msg.sender, unlocked);\n', '            emit RewardPaid(msg.sender, unlocked);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Claims all unlocked rewards for sender.\n', '     * Note, this function is costly - the args for _claimRewards\n', '     * should be determined off chain and then passed to other fn\n', '     */\n', '    function claimRewards() external override updateReward(msg.sender) updateBoost(msg.sender) {\n', '        (uint256 first, uint256 last) = _unclaimedEpochs(msg.sender);\n', '\n', '        _claimRewards(first, last);\n', '    }\n', '\n', '    /**\n', '     * @dev Claims all unlocked rewards for sender. Both immediately unlocked\n', '     * rewards and also locked rewards past their time lock.\n', '     * @param _first    Index of the first array element to claim\n', '     * @param _last     Index of the last array element to claim\n', '     */\n', '    function claimRewards(uint256 _first, uint256 _last)\n', '        external\n', '        override\n', '        updateReward(msg.sender)\n', '        updateBoost(msg.sender)\n', '    {\n', '        _claimRewards(_first, _last);\n', '    }\n', '\n', '    /**\n', '     * @dev Pokes a given account to reset the boost\n', '     */\n', '    function pokeBoost(address _account)\n', '        external\n', '        override\n', '        updateReward(_account)\n', '        updateBoost(_account)\n', '    {\n', '        emit Poked(_account);\n', '    }\n', '\n', '    /***************************************\n', '                ACTIONS - INTERNAL\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Claims all unlocked rewards for sender. Both immediately unlocked\n', '     * rewards and also locked rewards past their time lock.\n', '     * @param _first    Index of the first array element to claim\n', '     * @param _last     Index of the last array element to claim\n', '     */\n', '    function _claimRewards(uint256 _first, uint256 _last) internal {\n', '        (uint256 unclaimed, uint256 lastTimestamp) = _unclaimedRewards(msg.sender, _first, _last);\n', '        userClaim[msg.sender] = uint64(lastTimestamp);\n', '\n', '        uint256 unlocked = userData[msg.sender].rewards;\n', '        userData[msg.sender].rewards = 0;\n', '\n', '        uint256 total = unclaimed + unlocked;\n', '\n', '        if (total > 0) {\n', '            rewardsToken.safeTransfer(msg.sender, total);\n', '\n', '            emit RewardPaid(msg.sender, total);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Internally stakes an amount by depositing from sender,\n', '     * and crediting to the specified beneficiary\n', '     * @param _beneficiary Staked tokens are credited to this address\n', '     * @param _amount      Units of StakingToken\n', '     */\n', '    function _stake(address _beneficiary, uint256 _amount) internal {\n', '        require(_amount > 0, "Cannot stake 0");\n', '        require(_beneficiary != address(0), "Invalid beneficiary address");\n', '\n', '        _stakeRaw(_beneficiary, _amount);\n', '        emit Staked(_beneficiary, _amount, msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Withdraws raw units from the sender\n', '     * @param _amount      Units of StakingToken\n', '     */\n', '    function _withdraw(uint256 _amount) internal {\n', '        require(_amount > 0, "Cannot withdraw 0");\n', '        _withdrawRaw(_amount);\n', '        emit Withdrawn(msg.sender, _amount);\n', '    }\n', '\n', '    /***************************************\n', '                    GETTERS\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Gets the RewardsToken\n', '     */\n', '    function getRewardToken() external view override returns (IERC20) {\n', '        return rewardsToken;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the last applicable timestamp for this reward period\n', '     */\n', '    function lastTimeRewardApplicable() public view override returns (uint256) {\n', '        return StableMath.min(block.timestamp, periodFinish);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the amount of unclaimed rewards per token since last update,\n', '     * and sums with stored to give the new cumulative reward per token\n', "     * @return 'Reward' per staked token\n", '     */\n', '    function rewardPerToken() public view override returns (uint256) {\n', '        (uint256 rewardPerToken_, ) = _rewardPerToken();\n', '        return rewardPerToken_;\n', '    }\n', '\n', '    function _rewardPerToken()\n', '        internal\n', '        view\n', '        returns (uint256 rewardPerToken_, uint256 lastTimeRewardApplicable_)\n', '    {\n', '        uint256 lastApplicableTime = lastTimeRewardApplicable(); // + 1 SLOAD\n', '        uint256 timeDelta = lastApplicableTime - lastUpdateTime; // + 1 SLOAD\n', '        // If this has been called twice in the same block, shortcircuit to reduce gas\n', '        if (timeDelta == 0) {\n', '            return (rewardPerTokenStored, lastApplicableTime);\n', '        }\n', '        // new reward units to distribute = rewardRate * timeSinceLastUpdate\n', '        uint256 rewardUnitsToDistribute = rewardRate * timeDelta; // + 1 SLOAD\n', '        uint256 supply = totalSupply(); // + 1 SLOAD\n', '        // If there is no StakingToken liquidity, avoid div(0)\n', '        // If there is nothing to distribute, short circuit\n', '        if (supply == 0 || rewardUnitsToDistribute == 0) {\n', '            return (rewardPerTokenStored, lastApplicableTime);\n', '        }\n', '        // new reward units per token = (rewardUnitsToDistribute * 1e18) / totalTokens\n', '        uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(supply);\n', '        // return summed rate\n', '        return (rewardPerTokenStored + unitsToDistributePerToken, lastApplicableTime); // + 1 SLOAD\n', '    }\n', '\n', '    /**\n', '     * @dev Returned the units of IMMEDIATELY claimable rewards a user has to receive. Note - this\n', '     * does NOT include the majority of rewards which will be locked up.\n', '     * @param _account User address\n', '     * @return Total reward amount earned\n', '     */\n', '    function earned(address _account) public view override returns (uint256) {\n', '        uint256 newEarned =\n', '            _earned(_account, userData[_account].rewardPerTokenPaid, rewardPerToken());\n', '        uint256 immediatelyUnlocked = newEarned.mulTruncate(UNLOCK);\n', '        return immediatelyUnlocked + userData[_account].rewards;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates all unclaimed reward data, finding both immediately unlocked rewards\n', '     * and those that have passed their time lock.\n', '     * @param _account User address\n', '     * @return amount Total units of unclaimed rewards\n', '     * @return first Index of the first userReward that has unlocked\n', '     * @return last Index of the last userReward that has unlocked\n', '     */\n', '    function unclaimedRewards(address _account)\n', '        external\n', '        view\n', '        override\n', '        returns (\n', '            uint256 amount,\n', '            uint256 first,\n', '            uint256 last\n', '        )\n', '    {\n', '        (first, last) = _unclaimedEpochs(_account);\n', '        (uint256 unlocked, ) = _unclaimedRewards(_account, first, last);\n', '        amount = unlocked + earned(_account);\n', '    }\n', '\n', '    /** @dev Returns only the most recently earned rewards */\n', '    function _earned(\n', '        address _account,\n', '        uint256 _userRewardPerTokenPaid,\n', '        uint256 _currentRewardPerToken\n', '    ) internal view returns (uint256) {\n', '        // current rate per token - rate user previously received\n', '        uint256 userRewardDelta = _currentRewardPerToken - _userRewardPerTokenPaid; // + 1 SLOAD\n', '        // Short circuit if there is nothing new to distribute\n', '        if (userRewardDelta == 0) {\n', '            return 0;\n', '        }\n', '        // new reward = staked tokens * difference in rate\n', '        uint256 userNewReward = balanceOf(_account).mulTruncate(userRewardDelta); // + 1 SLOAD\n', '        // add to previous rewards\n', '        return userNewReward;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the first and last indexes of array elements containing unclaimed rewards\n', '     */\n', '    function _unclaimedEpochs(address _account)\n', '        internal\n', '        view\n', '        returns (uint256 first, uint256 last)\n', '    {\n', '        uint64 lastClaim = userClaim[_account];\n', '\n', '        uint256 firstUnclaimed = _findFirstUnclaimed(lastClaim, _account);\n', '        uint256 lastUnclaimed = _findLastUnclaimed(_account);\n', '\n', '        return (firstUnclaimed, lastUnclaimed);\n', '    }\n', '\n', '    /**\n', '     * @dev Sums the cumulative rewards from a valid range\n', '     */\n', '    function _unclaimedRewards(\n', '        address _account,\n', '        uint256 _first,\n', '        uint256 _last\n', '    ) internal view returns (uint256 amount, uint256 latestTimestamp) {\n', '        uint256 currentTime = block.timestamp;\n', '        uint64 lastClaim = userClaim[_account];\n', '\n', '        // Check for no rewards unlocked\n', '        uint256 totalLen = userRewards[_account].length;\n', '        if (_first == 0 && _last == 0) {\n', '            if (totalLen == 0 || currentTime <= userRewards[_account][0].start) {\n', '                return (0, currentTime);\n', '            }\n', '        }\n', '        // If there are previous unlocks, check for claims that would leave them untouchable\n', '        if (_first > 0) {\n', '            require(\n', '                lastClaim >= userRewards[_account][_first - 1].finish,\n', '                "Invalid _first arg: Must claim earlier entries"\n', '            );\n', '        }\n', '\n', '        uint256 count = _last - _first + 1;\n', '        for (uint256 i = 0; i < count; i++) {\n', '            uint256 id = _first + i;\n', '            Reward memory rwd = userRewards[_account][id];\n', '\n', '            require(currentTime >= rwd.start && lastClaim <= rwd.finish, "Invalid epoch");\n', '\n', '            uint256 endTime = StableMath.min(rwd.finish, currentTime);\n', '            uint256 startTime = StableMath.max(rwd.start, lastClaim);\n', '            uint256 unclaimed = (endTime - startTime) * rwd.rate;\n', '\n', '            amount += unclaimed;\n', '        }\n', '\n', '        // Calculate last relevant timestamp here to allow users to avoid issue of OOG errors\n', '        // by claiming rewards in batches.\n', '        latestTimestamp = StableMath.min(currentTime, userRewards[_account][_last].finish);\n', '    }\n', '\n', '    /**\n', '     * @dev Uses binarysearch to find the unclaimed lockups for a given account\n', '     */\n', '    function _findFirstUnclaimed(uint64 _lastClaim, address _account)\n', '        internal\n', '        view\n', '        returns (uint256 first)\n', '    {\n', '        uint256 len = userRewards[_account].length;\n', '        if (len == 0) return 0;\n', '        // Binary search\n', '        uint256 min = 0;\n', '        uint256 max = len - 1;\n', '        // Will be always enough for 128-bit numbers\n', '        for (uint256 i = 0; i < 128; i++) {\n', '            if (min >= max) break;\n', '            uint256 mid = (min + max + 1) / 2;\n', '            if (_lastClaim > userRewards[_account][mid].start) {\n', '                min = mid;\n', '            } else {\n', '                max = mid - 1;\n', '            }\n', '        }\n', '        return min;\n', '    }\n', '\n', '    /**\n', '     * @dev Uses binarysearch to find the unclaimed lockups for a given account\n', '     */\n', '    function _findLastUnclaimed(address _account) internal view returns (uint256 first) {\n', '        uint256 len = userRewards[_account].length;\n', '        if (len == 0) return 0;\n', '        // Binary search\n', '        uint256 min = 0;\n', '        uint256 max = len - 1;\n', '        // Will be always enough for 128-bit numbers\n', '        for (uint256 i = 0; i < 128; i++) {\n', '            if (min >= max) break;\n', '            uint256 mid = (min + max + 1) / 2;\n', '            if (block.timestamp > userRewards[_account][mid].start) {\n', '                min = mid;\n', '            } else {\n', '                max = mid - 1;\n', '            }\n', '        }\n', '        return min;\n', '    }\n', '\n', '    /***************************************\n', '                    ADMIN\n', '    ****************************************/\n', '\n', '    /**\n', '     * @dev Notifies the contract that new rewards have been added.\n', '     * Calculates an updated rewardRate based on the rewards in period.\n', '     * @param _reward Units of RewardToken that have been added to the pool\n', '     */\n', '    function notifyRewardAmount(uint256 _reward)\n', '        external\n', '        override\n', '        onlyRewardsDistributor\n', '        updateReward(address(0))\n', '    {\n', '        require(_reward < 1e24, "Cannot notify with more than a million units");\n', '\n', '        uint256 currentTime = block.timestamp;\n', '        // If previous period over, reset rewardRate\n', '        if (currentTime >= periodFinish) {\n', '            rewardRate = _reward / DURATION;\n', '        }\n', '        // If additional reward to existing period, calc sum\n', '        else {\n', '            uint256 remaining = periodFinish - currentTime;\n', '            uint256 leftover = remaining * rewardRate;\n', '            rewardRate = (_reward + leftover) / DURATION;\n', '        }\n', '\n', '        lastUpdateTime = currentTime;\n', '        periodFinish = currentTime + DURATION;\n', '\n', '        emit RewardAdded(_reward);\n', '    }\n', '}']