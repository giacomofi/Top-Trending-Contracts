['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-15\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', '\n', '/// ClipperMom.sol -- governance interface for the Clipper\n', '\n', '// Copyright (C) 2021 Maker Ecosystem Growth Holdings, INC.\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity >=0.6.12;\n', '\n', 'interface ClipLike {\n', '    function file(bytes32, uint256) external;\n', '    function ilk() external view returns (bytes32);\n', '    function stopped() external view returns (uint256);\n', '}\n', '\n', 'interface AuthorityLike {\n', '    function canCall(address src, address dst, bytes4 sig) external view returns (bool);\n', '}\n', '\n', 'interface OsmLike {\n', '    function peek() external view returns (uint256, bool);\n', '    function peep() external view returns (uint256, bool);\n', '}\n', '\n', 'interface SpotterLike {\n', '    function ilks(bytes32) external view returns (OsmLike, uint256);\n', '}\n', '\n', 'contract ClipperMom {\n', '    address public owner;\n', '    address public authority;\n', '    mapping (address => uint256) public locked;    // timestamp when becomes unlocked (per clipper)\n', '    mapping (address => uint256) public tolerance; // clipper -> ray\n', '\n', '    SpotterLike public immutable spotter;\n', '\n', '    event SetOwner(address indexed oldOwner, address indexed newOwner);\n', '    event SetAuthority(address indexed oldAuthority, address indexed newAuthority);\n', '    event SetBreaker(address indexed clip, uint256 level);\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "ClipperMom/only-owner");\n', '        _;\n', '    }\n', '\n', '    modifier auth {\n', '        require(isAuthorized(msg.sender, msg.sig), "ClipperMom/not-authorized");\n', '        _;\n', '    }\n', '\n', '    constructor(address spotter_) public {\n', '        owner = msg.sender;\n', '        spotter = SpotterLike(spotter_);\n', '        emit SetOwner(address(0), msg.sender);\n', '    }\n', '\n', '    // --- Math ---\n', '    uint256 constant WAD = 10 ** 18;\n', '    uint256 constant RAY = 10 ** 27;\n', '\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x);\n', '    }\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        z = mul(x, y) / RAY;\n', '    }\n', '\n', '    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n', '        if (src == address(this)) {\n', '            return true;\n', '        } else if (src == owner) {\n', '            return true;\n', '        } else if (authority == address(0)) {\n', '            return false;\n', '        } else {\n', '            return AuthorityLike(authority).canCall(src, address(this), sig);\n', '        }\n', '    }\n', '\n', '    function getPrices(address clip) internal view returns (uint256 cur, uint256 nxt) {\n', '        (OsmLike osm, ) = spotter.ilks(ClipLike(clip).ilk());\n', '        bool has;\n', '        (cur, has) = osm.peek();\n', '        require(has, "ClipperMom/invalid-cur-price");\n', '        (nxt, has) = osm.peep();\n', '        require(has, "ClipperMom/invalid-nxt-price");\n', '    }\n', '\n', '    // Governance actions with delay\n', '    function setOwner(address owner_) external onlyOwner {\n', '        emit SetOwner(owner, owner_);\n', '        owner = owner_;\n', '    }\n', '\n', '    function setAuthority(address authority_) external onlyOwner {\n', '        emit SetAuthority(authority, authority_);\n', '        authority = authority_;\n', '    }\n', '\n', '    // Set the price tolerance for a specific ilk.\n', '    // The price tolerance is the minimum acceptable value a new price can have relative to the previous price\n', "    // For instance, a tolerance of 0.6 means that a new price can't be lower than 60% of the previous price\n", '    // 0.6 * RAY = 600000000000000000000000000 => means acceptable drop from previous price is up to 40%\n', '    function setPriceTolerance(address clip, uint256 value) external onlyOwner {\n', '        require(value <= 1 * RAY, "ClipperMom/tolerance-out-of-bounds");\n', '        tolerance[clip] = value;\n', '    }\n', '\n', '    // Governance action without delay\n', '    function setBreaker(address clip, uint256 level, uint256 delay) external auth {\n', '        require(level <= 3, "ClipperMom/nonexistent-level");\n', '        ClipLike(clip).file("stopped", level);\n', '        // If governance changes the status of the breaker we want to lock for one hour\n', '        // the permissionless function so the osm can pull new nxt price to compare\n', '        locked[clip] = add(block.timestamp, delay);\n', '        emit SetBreaker(clip, level);\n', '    }\n', '\n', '    /**\n', '        The following implements a permissionless circuit breaker in case the price reported by an oracle\n', '        for a particular collateral type will drop below than a governance-defined % from 1 hour to the next.\n', '\n', '        The setPriceTolerance function sets that % (as a value between 0 and RAY) for a specific collateral type.\n', '        \n', "        tripBreaker takes the address of some ilk's Clipper.\n", '        It then gets the current and next price and checks whether the next price is less than the minimum\n', '        acceptable next price based on the tolerance. If the next price is unacceptable (lower than rmul(current_price, tolerance)),\n', "        it stops creation of new auctions and resets of current auctions for the Clipper's ilk. Currently, governance\n", '        must reset the breaker manually.\n', '    */\n', '    function tripBreaker(address clip) external {\n', '        require(ClipLike(clip).stopped() < 2, "ClipperMom/clipper-already-stopped");\n', '        require(block.timestamp > locked[clip], "ClipperMom/temporary-locked");\n', '      \n', '        (uint256 cur, uint256 nxt) = getPrices(clip);\n', '\n', '        // tolerance[clip] == 0 will always make the following require to revert\n', '        require(nxt < rmul(cur, tolerance[clip]), "ClipperMom/price-within-bounds");\n', '        ClipLike(clip).file("stopped", 2);\n', '        emit SetBreaker(clip, 2);\n', '    }\n', '}']