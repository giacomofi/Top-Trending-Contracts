['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.10;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./UniswapConfig.sol";\n', 'import "./UniswapLib.sol";\n', '\n', 'struct Observation {\n', '    uint timestamp;\n', '    uint acc;\n', '}\n', '\n', 'contract UniswapAnchoredView is UniswapConfig {\n', '    using FixedPoint for *;\n', '\n', '    /// @notice The number of wei in 1 ETH\n', '    uint public constant ethBaseUnit = 1e18;\n', '\n', '    /// @notice A common scaling factor to maintain precision\n', '    uint public constant expScale = 1e18;\n', '\n', '    /// @notice The minimum amount of time in seconds required for the old uniswap price accumulator to be replaced\n', '    uint public immutable anchorPeriod;\n', '\n', '    /// @notice Official prices by symbol hash\n', '    mapping(bytes32 => uint) public prices;\n', '\n', '    /// @notice The old observation for each symbolHash\n', '    mapping(bytes32 => Observation) public oldObservations;\n', '\n', '    /// @notice The new observation for each symbolHash\n', '    mapping(bytes32 => Observation) public newObservations;\n', '\n', '    /// @notice The event emitted when the stored price is updated\n', '    event PriceUpdated(string symbol, uint price);\n', '\n', '    /// @notice The event emitted when anchor price is updated\n', '    event AnchorPriceUpdated(address cToken, uint anchorPrice, uint oldTimestamp, uint newTimestamp);\n', '\n', '    /// @notice The event emitted when the uniswap window changes\n', '    event UniswapWindowUpdated(bytes32 indexed symbolHash, uint oldTimestamp, uint newTimestamp, uint oldPrice, uint newPrice);\n', '\n', '    bytes32 constant ethHash = keccak256(abi.encodePacked("ETH"));\n', '    bytes32 constant rotateHash = keccak256(abi.encodePacked("rotate"));\n', '\n', '    /**\n', '     * @notice Construct a uniswap anchored view for a set of token configurations\n', '     * @dev Note that to avoid immature TWAPs, the system must run for at least a single anchorPeriod before using.\n', '     * @param anchorPeriod_ The minimum amount of time required for the old uniswap price accumulator to be replaced\n', '     */\n', '    constructor(uint anchorPeriod_) public {\n', '        anchorPeriod = anchorPeriod_;\n', '    }\n', '\n', '    function addTokens(TokenConfig[] memory configs) public onlyOwner {\n', '        for (uint i = 0; i < configs.length; i++) {\n', '            TokenConfig memory config = configs[i];\n', '            bytes32 symbolHash = config.symbolHash;\n', '            require(config.baseUnit > 0, "baseUnit must be greater than zero");\n', '            require(newObservations[symbolHash].timestamp == uint(0), "cannot change current token");\n', '            address uniswapMarket = config.uniswapMarket;\n', '            if (config.priceSource == PriceSource.REPORTER) {\n', '                require(uniswapMarket != address(0), "reported prices must have an anchor");\n', '                uint cumulativePrice = currentCumulativePrice(config);\n', '                oldObservations[symbolHash].timestamp = block.timestamp;\n', '                newObservations[symbolHash].timestamp = block.timestamp;\n', '                oldObservations[symbolHash].acc = cumulativePrice;\n', '                newObservations[symbolHash].acc = cumulativePrice;\n', '                emit UniswapWindowUpdated(symbolHash, block.timestamp, block.timestamp, cumulativePrice, cumulativePrice);\n', '            } else {\n', '                require(uniswapMarket == address(0), "only reported prices utilize an anchor");\n', '            }\n', '        }\n', '\n', '        _addTokensInternal(configs);\n', '    }\n', '\n', '    /**\n', '     * @notice Get the official price for a symbol\n', '     * @param symbol The symbol to fetch the price of\n', '     * @return Price denominated in USD, with 6 decimals\n', '     */\n', '    function price(string memory symbol) external view returns (uint) {\n', '        TokenConfig memory config = getTokenConfigBySymbol(symbol);\n', '        if (config.priceSource == PriceSource.REPORTER) return prices[config.symbolHash];\n', '        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\n', '        if (config.priceSource == PriceSource.FIXED_ETH) {\n', '            uint usdPerEth = prices[ethHash];\n', '            require(usdPerEth > 0, "ETH price not set, cannot convert to dollars");\n', '            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\n', '        }\n', '        return 0;\n', '    }\n', '\n', '    function priceInternal(TokenConfig memory config) internal returns (uint) {\n', '        if (config.priceSource == PriceSource.REPORTER) {\n', '            Observation memory newObservation = newObservations[config.symbolHash];\n', '            // Update new and old observations if elapsed time is greater than or equal to anchor period\n', '            uint timeElapsed = block.timestamp - newObservation.timestamp;\n', '            if (timeElapsed >= anchorPeriod || prices[config.symbolHash] == 0) {\n', '                postPriceInternal(config);\n', '            }\n', '            return prices[config.symbolHash];\n', '        }\n', '        if (config.priceSource == PriceSource.FIXED_USD) return config.fixedPrice;\n', '        if (config.priceSource == PriceSource.FIXED_ETH) {\n', '            uint usdPerEth = prices[ethHash];\n', '            require(usdPerEth > 0, "ETH price not set, cannot convert to dollars");\n', '            return mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Get the underlying price of a cToken\n', '     * @dev Implements the PriceOracle interface for Compound v2.\n', '     * @param cToken The cToken address for price retrieval\n', '     * @return Price denominated in USD, with 18 decimals, for the given cToken address\n', '     */\n', '    function getUnderlyingPriceView(address cToken) external view returns (uint) {\n', '        TokenConfig memory config = getTokenConfigByCToken(cToken);\n', '        uint price;\n', '        if (config.priceSource == PriceSource.REPORTER) price = prices[config.symbolHash];\n', '        if (config.priceSource == PriceSource.FIXED_USD) price = config.fixedPrice;\n', '        if (config.priceSource == PriceSource.FIXED_ETH) {\n', '            uint usdPerEth = prices[ethHash];\n', '            require(usdPerEth > 0, "ETH price not set, cannot convert to dollars");\n', '            price = mul(usdPerEth, config.fixedPrice) / ethBaseUnit;\n', '        }\n', '         // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\n', '         // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\n', '        return mul(1e30, price) / config.baseUnit;\n', '    }\n', '\n', '    /**\n', '     * @notice Get the underlying price of a cToken\n', '     * @dev Implements the PriceOracle interface for Compound v2.\n', '     * @param cToken The cToken address for price retrieval\n', '     * @return Price denominated in USD, with 18 decimals, for the given cToken address\n', '     */\n', '    function getUnderlyingPrice(address cToken) external returns (uint) {\n', '        TokenConfig memory config = getTokenConfigByCToken(cToken);\n', '         // Comptroller needs prices in the format: ${raw price} * 1e(36 - baseUnit)\n', '         // Since the prices in this view have 6 decimals, we must scale them by 1e(36 - 6 - baseUnit)\n', '        return mul(1e30, priceInternal(config)) / config.baseUnit;\n', '    }\n', '\n', '    function postPriceInternal(TokenConfig memory config) internal {\n', '        uint ethPrice = fetchEthPrice();\n', '\n', '        uint anchorPrice;\n', '        if (config.symbolHash == ethHash) {\n', '            anchorPrice = ethPrice;\n', '        } else {\n', '            anchorPrice = fetchAnchorPrice(config, ethPrice);\n', '        }\n', '\n', '        prices[config.symbolHash] = anchorPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current token/eth price accumulator from uniswap.\n', '     */\n', '    function currentCumulativePrice(TokenConfig memory config) internal view returns (uint) {\n', '        (uint cumulativePrice0, uint cumulativePrice1,) = UniswapV2OracleLibrary.currentCumulativePrices(config.uniswapMarket);\n', '        if (config.isUniswapReversed) {\n', '            return cumulativePrice1;\n', '        } else {\n', '            return cumulativePrice0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current eth/usd price from uniswap, with 6 decimals of precision.\n', '     *  Conversion factor is 1e18 for eth/usdc market, since we decode uniswap price statically with 18 decimals.\n', '     */\n', '    function fetchEthPrice() internal returns (uint) {\n', '        return fetchAnchorPrice(getTokenConfigBySymbolHash(ethHash), ethBaseUnit);\n', '    }\n', '\n', '    /**\n', '     * @dev Fetches the current token/usd price from uniswap, with 6 decimals of precision.\n', '     * @param conversionFactor 1e18 if seeking the ETH price, and a 6 decimal ETH-USDC price in the case of other assets\n', '     */\n', '    function fetchAnchorPrice(TokenConfig memory config, uint conversionFactor) internal virtual returns (uint) {\n', '        (uint nowCumulativePrice, uint oldCumulativePrice, uint oldTimestamp) = pokeWindowValues(config);\n', '\n', '        // This should be impossible, but better safe than sorry\n', '        require(block.timestamp > oldTimestamp, "now must come after before");\n', '        uint timeElapsed = block.timestamp - oldTimestamp;\n', '\n', '        // Calculate uniswap time-weighted average price\n', '        // Underflow is a property of the accumulators: https://uniswap.org/audit.html#orgc9b3190\n', '        FixedPoint.uq112x112 memory priceAverage = FixedPoint.uq112x112(uint224((nowCumulativePrice - oldCumulativePrice) / timeElapsed));\n', '        uint rawUniswapPriceMantissa = priceAverage.decode112with18();\n', '        uint unscaledPriceMantissa = mul(rawUniswapPriceMantissa, conversionFactor);\n', '        uint anchorPrice;\n', '\n', '        // Adjust rawUniswapPrice according to the units of the non-ETH asset\n', '        // In the case of ETH, we would have to scale by 1e6 / USDC_UNITS, but since baseUnit2 is 1e6 (USDC), it cancels\n', '        anchorPrice = mul(unscaledPriceMantissa, config.baseUnit) / ethBaseUnit / expScale;\n', '\n', '        emit AnchorPriceUpdated(config.cToken, anchorPrice, oldTimestamp, block.timestamp);\n', '\n', '        return anchorPrice;\n', '    }\n', '\n', '    /**\n', '     * @dev Get time-weighted average prices for a token at the current timestamp.\n', '     *  Update new and old observations of lagging window if period elapsed.\n', '     */\n', '    function pokeWindowValues(TokenConfig memory config) internal returns (uint, uint, uint) {\n', '        bytes32 symbolHash = config.symbolHash;\n', '        uint cumulativePrice = currentCumulativePrice(config);\n', '\n', '        Observation memory newObservation = newObservations[symbolHash];\n', '\n', '        // Update new and old observations if elapsed time is greater than or equal to anchor period\n', '        uint timeElapsed = block.timestamp - newObservation.timestamp;\n', '        if (timeElapsed >= anchorPeriod) {\n', '            oldObservations[symbolHash].timestamp = newObservation.timestamp;\n', '            oldObservations[symbolHash].acc = newObservation.acc;\n', '\n', '            newObservations[symbolHash].timestamp = block.timestamp;\n', '            newObservations[symbolHash].acc = cumulativePrice;\n', '            emit UniswapWindowUpdated(config.symbolHash, newObservation.timestamp, block.timestamp, newObservation.acc, cumulativePrice);\n', '        }\n', '        return (cumulativePrice, oldObservations[symbolHash].acc, oldObservations[symbolHash].timestamp);\n', '    }\n', '\n', '    /// @dev Overflow proof multiplication\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) return 0;\n', '        uint c = a * b;\n', '        require(c / a == b, "multiplication overflow");\n', '        return c;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.10;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "openzeppelin-solidity/contracts/access/Ownable.sol";\n', '\n', 'interface CErc20 {\n', '    function underlying() external view returns (address);\n', '}\n', '\n', 'contract UniswapConfig is Ownable {\n', '    /// @dev Describe how to interpret the fixedPrice in the TokenConfig.\n', '    enum PriceSource {\n', '        FIXED_ETH, /// implies the fixedPrice is a constant multiple of the ETH price (which varies)\n', '        FIXED_USD, /// implies the fixedPrice is a constant multiple of the USD price (which is 1)\n', '        REPORTER   /// implies the price is set by the reporter\n', '    }\n', '\n', '    /// @dev Describe how the USD price should be determined for an asset.\n', '    ///  There should be 1 TokenConfig object for each supported asset, passed in the constructor.\n', '    struct TokenConfig {\n', '        address cToken;\n', '        address underlying;\n', '        bytes32 symbolHash;\n', '        uint256 baseUnit;\n', '        PriceSource priceSource;\n', '        uint256 fixedPrice;\n', '        address uniswapMarket;\n', '        bool isUniswapReversed;\n', '    }\n', '\n', '    mapping(uint => TokenConfig) public tokens;\n', '    mapping(address => uint) public cTokenIndex;\n', '    mapping(address => uint) public underlyingIndex;\n', '    mapping(bytes32 => uint) public symbolHashIndex;\n', '\n', '    /// @notice The number of tokens this contract actually supports\n', '    uint public numTokens;\n', '\n', '    function _addTokensInternal(TokenConfig[] memory configs) internal {\n', '        for (uint i = 0; i < configs.length; i++) {\n', '            uint index = i + numTokens;\n', '            tokens[index] = configs[i];\n', '            cTokenIndex[configs[i].cToken] = index;\n', '            underlyingIndex[configs[i].underlying] = index;\n', '            symbolHashIndex[configs[i].symbolHash] = index;\n', '        }\n', '\n', '        numTokens = numTokens + configs.length;\n', '    }\n', '\n', '    function getCTokenIndex(address cToken) internal view returns (uint) {\n', '        return cTokenIndex[cToken];\n', '    }\n', '\n', '    function getUnderlyingIndex(address underlying) internal view returns (uint) {\n', '        return underlyingIndex[underlying];\n', '    }\n', '\n', '    function getSymbolHashIndex(bytes32 symbolHash) internal view returns (uint) {\n', '        return symbolHashIndex[symbolHash];\n', '    }\n', '\n', '    /**\n', '     * @notice Get the i-th config, according to the order they were passed in originally\n', '     * @param i The index of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfig(uint i) public view returns (TokenConfig memory) {\n', '        require(i < numTokens, "token config not found");\n', '\n', '        return tokens[i];\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for symbol\n', '     * @param symbol The symbol of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigBySymbol(string memory symbol) public view returns (TokenConfig memory) {\n', '        return getTokenConfigBySymbolHash(keccak256(abi.encodePacked(symbol)));\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for the symbolHash\n', '     * @param symbolHash The keccack256 of the symbol of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigBySymbolHash(bytes32 symbolHash) public view returns (TokenConfig memory) {\n', '        uint index = getSymbolHashIndex(symbolHash);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '        revert("token config not found");\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for the cToken\n', '     * @dev If a config for the cToken is not found, falls back to searching for the underlying.\n', '     * @param cToken The address of the cToken of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigByCToken(address cToken) public view returns (TokenConfig memory) {\n', '        uint index = getCTokenIndex(cToken);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '        return getTokenConfigByUnderlying(CErc20(cToken).underlying());\n', '    }\n', '\n', '    /**\n', '     * @notice Get the config for an underlying asset\n', '     * @param underlying The address of the underlying asset of the config to get\n', '     * @return The config object\n', '     */\n', '    function getTokenConfigByUnderlying(address underlying) public view returns (TokenConfig memory) {\n', '        uint index = getUnderlyingIndex(underlying);\n', '        if (index != uint(-1)) {\n', '            return getTokenConfig(index);\n', '        }\n', '\n', '        revert("token config not found");\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.10;\n', '// Based on code from https://github.com/Uniswap/uniswap-v2-periphery\n', '\n', '// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n', 'library FixedPoint {\n', '    // range: [0, 2**112 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    // returns a uq112x112 which represents the ratio of the numerator to the denominator\n', '    // equivalent to encode(numerator).div(denominator)\n', '    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n', '        require(denominator > 0, "FixedPoint: DIV_BY_ZERO");\n', '        return uq112x112((uint224(numerator) << 112) / denominator);\n', '    }\n', '\n', '    // decode a uq112x112 into a uint with 18 decimals of precision\n', '    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n', '        // we only have 256 - 224 = 32 bits to spare, so scaling up by ~60 bits is dangerous\n', '        // instead, get close to:\n', '        //  (x * 1e18) >> 112\n', '        // without risk of overflowing, e.g.:\n', '        //  (x) / 2 ** (112 - lg(1e18))\n', '        return uint(self._x) / 5192296858534827;\n', '    }\n', '}\n', '\n', '// library with helper methods for oracles that are concerned with computing average prices\n', 'library UniswapV2OracleLibrary {\n', '    using FixedPoint for *;\n', '\n', '    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n', '    function currentBlockTimestamp() internal view returns (uint32) {\n', '        return uint32(block.timestamp % 2 ** 32);\n', '    }\n', '\n', '    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n', '    function currentCumulativePrices(\n', '        address pair\n', '    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n', '        blockTimestamp = currentBlockTimestamp();\n', '        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n', '        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n', '\n', '        // if time has elapsed since the last update on the pair, mock the accumulated price values\n', '        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n', '        if (blockTimestampLast != blockTimestamp) {\n', '            // subtraction overflow is desired\n', '            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n', '            // addition overflow is desired\n', '            // counterfactual\n', '            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\n', '            // counterfactual\n', '            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\n', '        }\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "../utils/Context.sol";\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '{\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "metadata": {\n', '    "bytecodeHash": "ipfs",\n', '    "useLiteralContent": true\n', '  },\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "remappings": [],\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']