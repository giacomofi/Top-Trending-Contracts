['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-25\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.2;\n', '\n', '/*******************************************************\n', ' *                       Interfaces\n', ' *******************************************************/\n', 'interface IV2Vault {\n', '    function token() external view returns (address);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function pricePerShare() external view returns (uint256);\n', '\n', '    function totalAssets() external view returns (uint256);\n', '\n', '    function apiVersion() external view returns (string memory);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function emergencyShutdown() external view returns (bool);\n', '\n', '    function depositLimit() external view returns (uint256);\n', '}\n', '\n', 'interface IV2Registry {\n', '    function numTokens() external view returns (uint256);\n', '\n', '    function numVaults(address token) external view returns (uint256);\n', '\n', '    function tokens(uint256 tokenIdx) external view returns (address);\n', '\n', '    function latestVault(address token) external view returns (address);\n', '\n', '    function vaults(address token, uint256 tokenIdx)\n', '        external\n', '        view\n', '        returns (address);\n', '}\n', '\n', 'interface IAddressesGenerator {\n', '    function assetsAddresses() external view returns (address[] memory);\n', '\n', '    function assetsLength() external view returns (uint256);\n', '\n', '    function registry() external view returns (address);\n', '\n', '    function getPositionSpenderAddresses()\n', '        external\n', '        view\n', '        returns (address[] memory);\n', '}\n', '\n', 'interface IOracle {\n', '    function getNormalizedValueUsdc(address tokenAddress, uint256 amount)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getPriceUsdcRecommended(address tokenAddress)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address spender, address owner)\n', '        external\n', '        view\n', '        returns (uint256);\n', '}\n', '\n', 'interface IHelper {\n', '    // Strategies helper\n', '    function assetStrategiesDelegatedBalance(address)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    // Allowances helper\n', '    struct Allowance {\n', '        address owner;\n', '        address spender;\n', '        uint256 amount;\n', '        address token;\n', '    }\n', '\n', '    function allowances(\n', '        address ownerAddress,\n', '        address[] memory tokensAddresses,\n', '        address[] memory spenderAddresses\n', '    ) external view returns (Allowance[] memory);\n', '}\n', '\n', '/*******************************************************\n', ' *                     Ownable\n', ' *******************************************************/\n', 'contract Ownable {\n', '    address public owner;\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', '\n', '/*******************************************************\n', ' *                     Adapter Logic\n', ' *******************************************************/\n', 'contract RegisteryAdapterV2Vault is Ownable {\n', '    /*******************************************************\n', '     *           Common code shared by all adapters\n', '     *******************************************************/\n', '\n', '    IOracle public oracle; // The oracle is used to fetch USDC normalized pricing data\n', '    IHelper public helper; // A helper utility is used for batch allowance fetching and address array merging\n', '    IAddressesGenerator public addressesGenerator; // A utility for fetching assets addresses and length\n', '    address public fallbackContractAddress; // Optional fallback proxy\n', '\n', '    /**\n', '     * High level static information about an asset\n', '     */\n', '    struct AssetStatic {\n', '        address id; // Asset address\n', '        string typeId; // Asset typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        string name; // Asset Name\n', '        string version; // Asset version\n', '        Token token; // Static asset underlying token information\n', '    }\n', '\n', '    /**\n', '     * High level dynamic information about an asset\n', '     */\n', '    struct AssetDynamic {\n', '        address id; // Asset address\n', '        string typeId; // Asset typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        address tokenId; // Underlying token address;\n', '        TokenAmount underlyingTokenBalance; // Underlying token balances\n', '        AssetMetadata metadata; // Metadata specific to the asset type of this adapter\n', '    }\n', '\n', '    /**\n', '     * Static token data\n', '     */\n', '    struct Token {\n', '        address id; // Token address\n', '        string name; // Token name\n', '        string symbol; // Token symbol\n', '        uint8 decimals; // Token decimals\n', '    }\n', '\n', '    /**\n', "     * Information about a user's position relative to an asset\n", '     */\n', '    struct Position {\n', '        address assetId; // Asset address\n', '        address tokenId; // Underlying asset token address\n', '        string typeId; // Position typeId (for example "DEPOSIT," "BORROW," "LEND")\n', '        uint256 balance; // asset.balanceOf(account)\n', "        TokenAmount underlyingTokenBalance; // Represents a user's asset position in underlying tokens\n", '        Allowance[] tokenAllowances; // Underlying token allowances\n', '        Allowance[] assetAllowances; // Asset allowances\n', '    }\n', '\n', '    /**\n', '     * Token amount representation\n', '     */\n', '    struct TokenAmount {\n', '        uint256 amount; // Amount in underlying token decimals\n', '        uint256 amountUsdc; // Amount in USDC (6 decimals)\n', '    }\n', '\n', '    /**\n', '     * Allowance information\n', '     */\n', '    struct Allowance {\n', '        address owner; // Allowance owner\n', '        address spender; // Allowance spender\n', '        uint256 amount; // Allowance amount (in underlying token)\n', '    }\n', '\n', '    /**\n', '     * Information about the adapter\n', '     */\n', '    struct AdapterInfo {\n', '        address id; // Adapter address\n', '        string typeId; // Adapter typeId (for example "VAULT_V2" or "IRON_BANK_MARKET")\n', '        string categoryId; // Adapter categoryId (for example "VAULT")\n', '    }\n', '\n', '    /**\n', '     * Fetch static information about an array of assets. This method can be used for off-chain pagination.\n', '     */\n', '    function assetsStatic(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (AssetStatic[] memory)\n', '    {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        AssetStatic[] memory _assets = new AssetStatic[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            AssetStatic memory _asset = assetStatic(assetAddress);\n', '            _assets[assetIdx] = _asset;\n', '        }\n', '        return _assets;\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information about an array of assets. This method can be used for off-chain pagination.\n', '     */\n', '    function assetsDynamic(address[] memory _assetsAddresses)\n', '        public\n', '        view\n', '        returns (AssetDynamic[] memory)\n', '    {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        AssetDynamic[] memory _assets = new AssetDynamic[](numberOfAssets);\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            AssetDynamic memory _asset = assetDynamic(assetAddress);\n', '            _assets[assetIdx] = _asset;\n', '        }\n', '        return _assets;\n', '    }\n', '\n', '    /**\n', '     * Fetch static information for all assets\n', '     */\n', '    function assetsStatic() external view returns (AssetStatic[] memory) {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return assetsStatic(_assetsAddresses);\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information for all assets\n', '     */\n', '    function assetsDynamic() external view returns (AssetDynamic[] memory) {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return assetsDynamic(_assetsAddresses);\n', '    }\n', '\n', '    /**\n', '     * Fetch underlying token allowances relative to an asset.\n', '     * This is useful for determining whether or not a user has token approvals\n', '     * to allow depositing into an asset\n', '     */\n', '    function tokenAllowances(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (Allowance[] memory)\n', '    {\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        address[] memory tokenAddresses = new address[](1);\n', '        address[] memory assetAddresses = new address[](1);\n', '        tokenAddresses[0] = tokenAddress;\n', '        assetAddresses[0] = assetAddress;\n', '        bytes memory allowances =\n', '            abi.encode(\n', '                helper.allowances(\n', '                    accountAddress,\n', '                    tokenAddresses,\n', '                    assetAddresses\n', '                )\n', '            );\n', '        return abi.decode(allowances, (Allowance[]));\n', '    }\n', '\n', '    /**\n', '     * Fetch asset allowances based on positionSpenderAddresses (configurable).\n', '     * This is useful to determine if a particular zap contract is approved for the asset (zap out use case)\n', '     */\n', '    function assetAllowances(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (Allowance[] memory)\n', '    {\n', '        address[] memory assetAddresses = new address[](1);\n', '        assetAddresses[0] = assetAddress;\n', '        bytes memory allowances =\n', '            abi.encode(\n', '                helper.allowances(\n', '                    accountAddress,\n', '                    assetAddresses,\n', '                    addressesGenerator.getPositionSpenderAddresses()\n', '                )\n', '            );\n', '        return abi.decode(allowances, (Allowance[]));\n', '    }\n', '\n', '    /**\n', '     * Fetch basic static token metadata\n', '     */\n', '    function tokenMetadata(address tokenAddress)\n', '        internal\n', '        view\n', '        returns (Token memory)\n', '    {\n', '        IERC20 _token = IERC20(tokenAddress);\n', '        return\n', '            Token({\n', '                id: tokenAddress,\n', '                name: _token.name(),\n', '                symbol: _token.symbol(),\n', '                decimals: _token.decimals()\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Internal method for constructing a TokenAmount struct given a token balance and address\n', '     */\n', '    function tokenAmount(uint256 amount, address tokenAddress)\n', '        internal\n', '        view\n', '        returns (TokenAmount memory)\n', '    {\n', '        return\n', '            TokenAmount({\n', '                amount: amount,\n', '                amountUsdc: oracle.getNormalizedValueUsdc(tokenAddress, amount)\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch the total number of assets for this adapter\n', '     */\n', '    function assetsLength() public view returns (uint256) {\n', '        return addressesGenerator.assetsLength();\n', '    }\n', '\n', '    /**\n', '     * Fetch all asset addresses for this adapter\n', '     */\n', '    function assetsAddresses() public view returns (address[] memory) {\n', '        return addressesGenerator.assetsAddresses();\n', '    }\n', '\n', '    /**\n', '     * Fetch registry address from addresses generator\n', '     */\n', '    function registry() public view returns (address) {\n', '        return addressesGenerator.registry();\n', '    }\n', '\n', '    /**\n', '     * Allow storage slots to be manually updated\n', '     */\n', '    function updateSlot(bytes32 slot, bytes32 value) external onlyOwner {\n', '        assembly {\n', '            sstore(slot, value)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Configure adapter\n', '     */\n', '    constructor(\n', '        address _oracleAddress,\n', '        address _helperAddress,\n', '        address _addressesGeneratorAddress,\n', '        address _fallbackContractAddress\n', '    ) {\n', '        require(_oracleAddress != address(0), "Missing oracle address");\n', '        oracle = IOracle(_oracleAddress);\n', '        helper = IHelper(_helperAddress);\n', '        fallbackContractAddress = _fallbackContractAddress;\n', '        addressesGenerator = IAddressesGenerator(_addressesGeneratorAddress);\n', '    }\n', '\n', '    /*******************************************************\n', '     * Common code shared by v1 vaults, v2 vaults and earn\n', '     *******************************************************/\n', '\n', '    /**\n', '     * Fetch asset positions of an account given an array of assets. This method can be used for off-chain pagination.\n', '     */\n', '    function assetsPositionsOf(\n', '        address accountAddress,\n', '        address[] memory _assetsAddresses\n', '    ) public view returns (Position[] memory) {\n', '        uint256 numberOfAssets = _assetsAddresses.length;\n', '        Position[] memory positions = new Position[](numberOfAssets);\n', '        uint256 currentPositionIdx;\n', '        for (uint256 assetIdx = 0; assetIdx < numberOfAssets; assetIdx++) {\n', '            address assetAddress = _assetsAddresses[assetIdx];\n', '            Position memory position =\n', '                assetPositionsOf(accountAddress, assetAddress)[0];\n', '            if (position.balance > 0) {\n', '                positions[currentPositionIdx] = position;\n', '                currentPositionIdx++;\n', '            }\n', '        }\n', '        bytes memory encodedData = abi.encode(positions);\n', '        assembly {\n', '            // Manually truncate positions\n', '            mstore(add(encodedData, 0x40), currentPositionIdx)\n', '        }\n', '        positions = abi.decode(encodedData, (Position[]));\n', '        return positions;\n', '    }\n', '\n', '    /**\n', '     * Fetch asset positions for an account for all assets\n', '     */\n', '    function assetsPositionsOf(address accountAddress)\n', '        external\n', '        view\n', '        returns (Position[] memory)\n', '    {\n', '        address[] memory _assetsAddresses = assetsAddresses();\n', '        return assetsPositionsOf(accountAddress, _assetsAddresses);\n', '    }\n', '\n', '    /*******************************************************\n', '     *                 V2 Adapter (unique logic)\n', '     *******************************************************/\n', '\n', '    /**\n', '     * Return information about the adapter\n', '     */\n', '    function adapterInfo() public view returns (AdapterInfo memory) {\n', '        return\n', '            AdapterInfo({\n', '                id: address(this),\n', '                typeId: "VAULT_V2",\n', '                categoryId: "VAULT"\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Metadata specific to this asset type\n', '     */\n', '    struct AssetMetadata {\n', '        string symbol; // Vault symbol\n', '        uint256 pricePerShare; // Vault pricePerShare\n', '        bool migrationAvailable; // True if a migration is available for this vault\n', '        address latestVaultAddress; // Latest vault migration address\n', '        uint256 depositLimit; // Deposit limit of asset\n', '        bool emergencyShutdown; // Vault is in emergency shutdown mode\n', '    }\n', '\n', '    /**\n', '     * Metadata specific to an asset type scoped to a user.\n', '     * Not used in this adapter.\n', '     */\n', '    struct AssetUserMetadata {\n', '        address assetId;\n', '    }\n', '\n', '    /**\n', '     * Fetch asset metadata scoped to a user\n', '     */\n', '    function assetUserMetadata(address assetAddress)\n', '        public\n', '        view\n', '        returns (AssetUserMetadata memory)\n', '    {}\n', '\n', '    /**\n', '     * Fetch the underlying token address of an asset\n', '     */\n', '    function underlyingTokenAddress(address assetAddress)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        address tokenAddress = vault.token();\n', '        return tokenAddress;\n', '    }\n', '\n', '    /**\n', '     * Fetch static information about an asset\n', '     */\n', '    function assetStatic(address assetAddress)\n', '        public\n', '        view\n', '        returns (AssetStatic memory)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        return\n', '            AssetStatic({\n', '                id: assetAddress,\n', '                typeId: adapterInfo().typeId,\n', '                name: vault.name(),\n', '                version: vault.apiVersion(),\n', '                token: tokenMetadata(tokenAddress)\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch dynamic information about an asset\n', '     */\n', '    function assetDynamic(address assetAddress)\n', '        public\n', '        view\n', '        returns (AssetDynamic memory)\n', '    {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        uint256 totalSupply = vault.totalSupply();\n', '        uint256 pricePerShare = 0;\n', '        bool vaultHasShares = totalSupply != 0;\n', '        if (vaultHasShares) {\n', '            pricePerShare = vault.pricePerShare();\n', '        }\n', '\n', '        address latestVaultAddress =\n', '            IV2Registry(registry()).latestVault(tokenAddress);\n', '        bool migrationAvailable = latestVaultAddress != assetAddress;\n', '\n', '        AssetMetadata memory metadata =\n', '            AssetMetadata({\n', '                symbol: vault.symbol(),\n', '                pricePerShare: pricePerShare,\n', '                migrationAvailable: migrationAvailable,\n', '                latestVaultAddress: latestVaultAddress,\n', '                depositLimit: vault.depositLimit(),\n', '                emergencyShutdown: vault.emergencyShutdown()\n', '            });\n', '\n', '        uint256 balance = assetBalance(assetAddress);\n', '        TokenAmount memory underlyingTokenBalance =\n', '            tokenAmount(balance, tokenAddress);\n', '\n', '        return\n', '            AssetDynamic({\n', '                id: assetAddress,\n', '                typeId: adapterInfo().typeId,\n', '                tokenId: tokenAddress,\n', '                underlyingTokenBalance: underlyingTokenBalance,\n', '                metadata: metadata\n', '            });\n', '    }\n', '\n', '    /**\n', '     * Fetch asset positions of an account given an asset address\n', '     */\n', '    function assetPositionsOf(address accountAddress, address assetAddress)\n', '        public\n', '        view\n', '        returns (Position[] memory)\n', '    {\n', '        IV2Vault _asset = IV2Vault(assetAddress);\n', '        uint8 assetDecimals = _asset.decimals();\n', '        address tokenAddress = underlyingTokenAddress(assetAddress);\n', '        uint256 balance = _asset.balanceOf(accountAddress);\n', '        uint256 _underlyingTokenBalance =\n', '            (balance * _asset.pricePerShare()) / 10**assetDecimals;\n', '        Position[] memory positions = new Position[](1);\n', '        positions[0] = Position({\n', '            assetId: assetAddress,\n', '            tokenId: tokenAddress,\n', '            typeId: "DEPOSIT",\n', '            balance: balance,\n', '            underlyingTokenBalance: tokenAmount(\n', '                _underlyingTokenBalance,\n', '                tokenAddress\n', '            ),\n', '            tokenAllowances: tokenAllowances(accountAddress, assetAddress),\n', '            assetAllowances: assetAllowances(accountAddress, assetAddress)\n', '        });\n', '        return positions;\n', '    }\n', '\n', '    /**\n', '     * Fetch asset balance in underlying tokens\n', '     */\n', '    function assetBalance(address assetAddress) public view returns (uint256) {\n', '        IV2Vault vault = IV2Vault(assetAddress);\n', '        return vault.totalAssets();\n', '    }\n', '\n', '    /**\n', '     * Returns unique list of tokens associated with this adapter\n', '     */\n', '    function tokens() public view returns (Token[] memory) {\n', '        IV2Registry _registry = IV2Registry(registry());\n', '        uint256 numTokens = _registry.numTokens();\n', '        Token[] memory _tokens = new Token[](numTokens);\n', '        for (uint256 tokenIdx = 0; tokenIdx < numTokens; tokenIdx++) {\n', '            address tokenAddress = _registry.tokens(tokenIdx);\n', '            Token memory _token = tokenMetadata(tokenAddress);\n', '            _tokens[tokenIdx] = _token;\n', '        }\n', '        return _tokens;\n', '    }\n', '\n', '    /**\n', '     * Fallback proxy. Primary use case is to give registry adapters access to TVL adapter logic\n', '     */\n', '    fallback() external {\n', '        assembly {\n', '            let addr := sload(fallbackContractAddress.slot)\n', '            calldatacopy(0, 0, calldatasize())\n', '            let success := staticcall(gas(), addr, 0, calldatasize(), 0, 0)\n', '            returndatacopy(0, 0, returndatasize())\n', '            if success {\n', '                return(0, returndatasize())\n', '            }\n', '        }\n', '    }\n', '}']