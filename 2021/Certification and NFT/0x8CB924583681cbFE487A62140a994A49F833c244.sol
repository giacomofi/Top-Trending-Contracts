['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-20\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity =0.7.6;\n', '\n', 'contract Context {\n', '    /**\n', '     * @dev returns address executing the method\n', '     */\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev returns data passed into the method\n', '     */\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this;\n', '        return msg.data;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract ERC20 is Context {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '\n', '    uint256 private _totalSupply = 0.404 ether;\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    constructor (string memory tokenName, string memory tokenSymbol) {\n', '        _name = tokenName;\n', '        _symbol = tokenSymbol;\n', '        _decimals = 18;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the decimals of the token.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the total supply of the token.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the token balance of specific address.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount );\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns approved balance to be spent by another address\n', '     * by using transferFrom method\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the token allowance to another spender\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows to transfer tokens on senders behalf\n', '     * based on allowance approved for the executer\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount));\n', '        _transfer(sender, recipient, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0x0));\n', '        require(recipient != address(0x0));\n', '\n', '        _balances[sender] = _balances[sender].sub(amount);\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0x0));\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '\n', '        emit Transfer(address(0x0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows to burn tokens if token sender\n', '     * wants to reduce totalSupply() of the token\n', '     */\n', '    function burn(uint256 amount) external {\n', '        _burn(msg.sender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0x0));\n', '\n', '        _balances[account] = _balances[account].sub(amount);\n', '        _totalSupply = _totalSupply.sub(amount);\n', '\n', '        emit Transfer(account, address(0x0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0x0));\n', '        require(spender != address(0x0));\n', '\n', '        _allowances[owner][spender] = amount;\n', '\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '}\n', '\n', 'contract Events {\n', '    event StakeStart(\n', '        bytes16 indexed stakeID,\n', '        address indexed stakerAddress,\n', '        address indexed referralAddress,\n', '        uint256 stakedAmount,\n', '        uint256 stakesShares,\n', '        uint256 referralShares,\n', '        uint256 startDay,\n', '        uint256 lockDays,\n', '        uint256 daiEquivalent\n', '    );\n', '\n', '    event StakeEnd(\n', '        bytes16 indexed stakeID,\n', '        address indexed stakerAddress,\n', '        address indexed referralAddress,\n', '        uint256 stakedAmount,\n', '        uint256 stakesShares,\n', '        uint256 referralShares,\n', '        uint256 rewardAmount,\n', '        uint256 closeDay,\n', '        uint256 penaltyAmount\n', '    );\n', '\n', '    event InterestScraped(\n', '        bytes16 indexed stakeID,\n', '        address indexed stakerAddress,\n', '        uint256 scrapeAmount,\n', '        uint256 scrapeDay,\n', '        uint256 stakersPenalty,\n', '        uint256 referrerPenalty,\n', '        uint256 currentSwappDay\n', '    );\n', '\n', '    event ReferralCollected(\n', '        address indexed staker,\n', '        bytes16 indexed stakeID,\n', '        address indexed referrer,\n', '        bytes16 referrerID,\n', '        uint256 rewardAmount\n', '    );\n', '\n', '    event NewGlobals(\n', '        uint256 totalShares,\n', '        uint256 totalStaked,\n', '        uint256 shareRate,\n', '        uint256 referrerShares,\n', '        uint256 indexed currentSwappDay\n', '    );\n', '\n', '    event NewSharePrice(\n', '        uint256 newSharePrice,\n', '        uint256 oldSharePrice,\n', '        uint64 currentSwappDay\n', '    );\n', '\n', '    event LiquidityGuardStatus(\n', '        bool isActive\n', '    );\n', '}\n', '\n', 'abstract contract Global is ERC20, Events {\n', '    using SafeMath for uint256;\n', '\n', '    struct Globals {\n', '        uint256 totalStaked;\n', '        uint256 totalShares;\n', '        uint256 sharePrice;\n', '        uint256 currentSwappDay;\n', '        uint256 referralShares;\n', '        uint256 liquidityShares;\n', '    }\n', '\n', '    Globals public globals;\n', '\n', '    constructor() {\n', '        globals.sharePrice = 100E15;\n', '    }\n', '\n', '    function _increaseGlobals(\n', '        uint256 _staked,\n', '        uint256 _shares,\n', '        uint256 _rshares\n', '    ) internal {\n', '        globals.totalStaked = globals.totalStaked.add(_staked);\n', '        globals.totalShares = globals.totalShares.add(_shares);\n', '\n', '        if (_rshares > 0) {\n', '            globals.referralShares = globals.referralShares.add(_rshares);\n', '        }\n', '\n', '        _logGlobals();\n', '    }\n', '\n', '    function _decreaseGlobals(\n', '        uint256 _staked,\n', '        uint256 _shares,\n', '        uint256 _rshares\n', '    ) internal {\n', '        globals.totalStaked = globals.totalStaked > _staked ? globals.totalStaked - _staked : 0;\n', '        globals.totalShares = globals.totalShares > _shares ? globals.totalShares - _shares : 0;\n', '\n', '        if (_rshares > 0) {\n', '            globals.referralShares = globals.referralShares > _rshares ? globals.referralShares - _rshares : 0;\n', '        }\n', '\n', '        _logGlobals();\n', '    }\n', '\n', '    function _logGlobals() private {\n', '        emit NewGlobals(\n', '            globals.totalShares,\n', '            globals.totalStaked,\n', '            globals.sharePrice,\n', '            globals.referralShares,\n', '            globals.currentSwappDay\n', '        );\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    function createPair(\n', '        address tokenA,\n', '        address tokenB\n', '    ) external returns (\n', '        address pair\n', '    );\n', '}\n', '\n', 'interface IUniswapRouterV2 {\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function swapExactETHForTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint[] memory amounts);\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function token1() external view returns (address);\n', '}\n', '\n', 'interface ILiquidityGuard {\n', '    function getInflation(uint32 _amount) external view returns (uint256);\n', '}\n', '\n', 'interface TokenInterface {\n', '    function transferFrom(address _from, address _to, uint256 _value)  external returns (bool success);\n', '    function approve(address _spender, uint256 _value)  external returns (bool success);\n', '}\n', '\n', 'abstract contract Declaration is Global {\n', '\n', '    uint256 constant _decimals = 18;\n', '    uint256 constant TESLAS_PER_SWAPP = 10 ** _decimals;\n', '\n', '    uint32 constant SECONDS_IN_DAY = 86400 seconds;\n', '    uint16 constant MIN_LOCK_DAYS = 1;\n', '    uint16 constant FORMULA_DAY = 65;\n', '    uint16 constant MAX_LOCK_DAYS = 15330;\n', '    uint16 constant MAX_BONUS_DAYS_A = 1825;\n', '    uint16 constant MAX_BONUS_DAYS_B = 13505;\n', '    uint16 constant MIN_REFERRAL_DAYS = 365;\n', '\n', '    uint32 constant MIN_STAKE_AMOUNT = 1000000; // TESLA\n', '    uint32 constant REFERRALS_RATE = 366816973; // 1.000% (direct value, can be used right away)\n', '\n', '    uint32 public INFLATION_RATE = 103000; // 3.000% (indirect -> checks throgh LiquidityGuard)\n', '\n', '    uint64 constant PRECISION_RATE = 1E18;\n', '\n', '    uint96 constant THRESHOLD_LIMIT = 10000E18; // $10,000 DAI\n', '\n', '    uint96 constant DAILY_BONUS_A = 13698630136986302; // 25%:1825 = 0.01369863013 per day;\n', '    uint96 constant DAILY_BONUS_B = 370233246945575;   // 5%:13505 = 0.00037023324 per day;\n', '\n', '    uint256 public LAUNCH_TIME;\n', '\n', '    address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '\n', '    IUniswapRouterV2 public constant UNISWAP_ROUTER = IUniswapRouterV2(\n', '        0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n', '    );\n', '\n', '    IUniswapV2Factory public constant UNISWAP_FACTORY = IUniswapV2Factory(\n', '        0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f\n', '    );\n', '\n', '    ILiquidityGuard public LIQUIDITY_GUARD = ILiquidityGuard(\n', '        0xECd13A6c13A97483deA1e31101e63718FcBd6b73\n', '    );\n', '\n', '    IUniswapV2Pair public UNISWAP_PAIR;\n', '    bool public isLiquidityGuardActive;\n', '\n', '    uint256 public latestDaiEquivalent;\n', '    address[] internal _path = [address(this), WETH, DAI];\n', '\n', '    constructor() {\n', '        LAUNCH_TIME = 1620518400; // 2021.05.09 GMT\n', '    }\n', '\n', '    function createPair() external {\n', '        UNISWAP_PAIR = IUniswapV2Pair(\n', '            UNISWAP_FACTORY.createPair(\n', '                WETH, address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    struct Stake {\n', '        uint256 stakesShares;\n', '        uint256 stakedAmount;\n', '        uint256 rewardAmount;\n', '        uint64 startDay;\n', '        uint64 lockDays;\n', '        uint64 finalDay;\n', '        uint64 closeDay;\n', '        uint256 scrapeDay;\n', '        uint256 daiEquivalent;\n', '        uint256 referrerShares;\n', '        address referrer;\n', '        bool isActive;\n', '    }\n', '\n', '    struct ReferrerLink {\n', '        address staker;\n', '        bytes16 stakeID;\n', '        uint256 rewardAmount;\n', '        uint256 processedDays;\n', '        bool isActive;\n', '    }\n', '\n', '    struct CriticalMass {\n', '        uint256 totalAmount;\n', '        uint256 activationDay;\n', '    }\n', '\n', '    mapping(address => uint256) public stakeCount;\n', '    mapping(address => uint256) public referralCount;\n', '\n', '    mapping(address => CriticalMass) public criticalMass;\n', '    mapping(address => mapping(bytes16 => uint256)) public scrapes;\n', '    mapping(address => mapping(bytes16 => Stake)) public stakes;\n', '    mapping(address => mapping(bytes16 => ReferrerLink)) public referrerLinks;\n', '\n', '    mapping(uint256 => uint256) public scheduledToEnd;\n', '    mapping(uint256 => uint256) public referralSharesToEnd;\n', '    mapping(uint256 => uint256) public totalPenalties;\n', '\n', '    mapping(address => uint256) public userStakedAmount;\n', '}\n', '\n', 'abstract contract Helper is Declaration {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    function currentSwappDay() public view returns (uint64) {\n', '        return getNow() >= LAUNCH_TIME ? _currentSwappDay() : 0;\n', '    }\n', '\n', '    function _currentSwappDay() internal view returns (uint64) {\n', '        return swappDayFromStamp(getNow());\n', '    }\n', '\n', '    function nextSwappDay() public view returns (uint64) {\n', '        return _currentSwappDay() + 1;\n', '    }\n', '\n', '    function previousSwappDay() public view returns (uint64) {\n', '        return _currentSwappDay() - 1;\n', '    }\n', '\n', '    function swappDayFromStamp(uint256 _timestamp) public view returns (uint64) {\n', '        return uint64((_timestamp - LAUNCH_TIME) / SECONDS_IN_DAY);\n', '    }\n', '\n', '    function getNow() public view returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '\n', '    function notContract(address _addr) internal view returns (bool) {\n', '        uint32 size;\n', '        assembly { size := extcodesize(_addr) }\n', '        return (size == 0);\n', '    }\n', '\n', '    function toBytes16(uint256 x) internal pure returns (bytes16 b) {\n', '       return bytes16(bytes32(x));\n', '    }\n', '\n', '    function generateID(address x, uint256 y, bytes1 z) public pure returns (bytes16 b) {\n', '        b = toBytes16(uint256(keccak256(abi.encodePacked(x, y, z))));\n', '    }\n', '\n', '    function generateStakeID(address _staker) internal view returns (bytes16 stakeID) {\n', '        return generateID(_staker, stakeCount[_staker], 0x01);\n', '    }\n', '\n', '    function generateReferralID(address _referrer) internal view returns (bytes16 referralID) {\n', '        return generateID(_referrer, referralCount[_referrer], 0x02);\n', '    }\n', '\n', '    function stakesPagination(\n', '        address _staker,\n', '        uint256 _offset,\n', '        uint256 _length\n', '    ) external view returns (bytes16[] memory _stakes) {\n', '        uint256 start = _offset > 0 &&\n', '            stakeCount[_staker] > _offset ?\n', '            stakeCount[_staker] - _offset : stakeCount[_staker];\n', '\n', '        uint256 finish = _length > 0 &&\n', '            start > _length ?\n', '            start - _length : 0;\n', '\n', '        uint256 i;\n', '\n', '        _stakes = new bytes16[](start - finish);\n', '\n', '        for (uint256 _stakeIndex = start; _stakeIndex > finish; _stakeIndex--) {\n', '            bytes16 _stakeID = generateID(_staker, _stakeIndex - 1, 0x01);\n', '            if (stakes[_staker][_stakeID].stakedAmount > 0) {\n', '                _stakes[i] = _stakeID; i++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function referralsPagination(\n', '        address _referrer,\n', '        uint256 _offset,\n', '        uint256 _length\n', '    ) external view returns (bytes16[] memory _referrals) {\n', '        uint256 start = _offset > 0 &&\n', '            referralCount[_referrer] > _offset ?\n', '            referralCount[_referrer] - _offset : referralCount[_referrer];\n', '\n', '        uint256 finish = _length > 0 &&\n', '            start > _length ?\n', '            start - _length : 0;\n', '\n', '        uint256 i;\n', '\n', '        _referrals = new bytes16[](start - finish);\n', '\n', '        for (uint256 _rIndex = start; _rIndex > finish; _rIndex--) {\n', '            bytes16 _rID = generateID(_referrer, _rIndex - 1, 0x02);\n', '            if (_nonZeroAddress(referrerLinks[_referrer][_rID].staker)) {\n', '                _referrals[i] = _rID; i++;\n', '            }\n', '        }\n', '    }\n', '\n', '    function latestStakeID(address _staker) external view returns (bytes16) {\n', '        return stakeCount[_staker] == 0 ? bytes16(0) : generateID(_staker, stakeCount[_staker].sub(1), 0x01);\n', '    }\n', '\n', '    function latestReferralID(address _referrer) external view returns (bytes16) {\n', '        return referralCount[_referrer] == 0 ? bytes16(0) : generateID(_referrer, referralCount[_referrer].sub(1), 0x02);\n', '    }\n', '\n', '    function _increaseStakeCount(address _staker) internal {\n', '        stakeCount[_staker] = stakeCount[_staker] + 1;\n', '    }\n', '\n', '    function _increaseReferralCount(address _referrer) internal {\n', '        referralCount[_referrer] = referralCount[_referrer] + 1;\n', '    }\n', '\n', '    function _isMatureStake(Stake memory _stake) internal view returns (bool) {\n', '        return _stake.closeDay > 0\n', '            ? _stake.finalDay <= _stake.closeDay\n', '            : _stake.finalDay <= _currentSwappDay();\n', '    }\n', '\n', '    function _notCriticalMassReferrer(address _referrer) internal view returns (bool) {\n', '        return criticalMass[_referrer].activationDay == 0;\n', '    }\n', '\n', '    function _stakeNotStarted(Stake memory _stake) internal view returns (bool) {\n', '        return _stake.closeDay > 0\n', '            ? _stake.startDay > _stake.closeDay\n', '            : _stake.startDay > _currentSwappDay();\n', '    }\n', '\n', '    function _stakeEnded(Stake memory _stake) internal view returns (bool) {\n', '        return _stake.isActive == false || _isMatureStake(_stake);\n', '    }\n', '\n', '    function _daysLeft(Stake memory _stake) internal view returns (uint256) {\n', '        return _stake.isActive == false\n', '            ? _daysDiff(_stake.closeDay, _stake.finalDay)\n', '            : _daysDiff(_currentSwappDay(), _stake.finalDay);\n', '    }\n', '\n', '    function _daysDiff(uint256 _startDate, uint256 _endDate) internal pure returns (uint256) {\n', '        return _startDate > _endDate ? 0 : _endDate.sub(_startDate);\n', '    }\n', '\n', '    function _calculationDay(Stake memory _stake) internal view returns (uint256) {\n', '        return _stake.finalDay > globals.currentSwappDay ? globals.currentSwappDay : _stake.finalDay;\n', '    }\n', '\n', '    function _startingDay(Stake memory _stake) internal pure returns (uint256) {\n', '        return _stake.scrapeDay == 0 ? _stake.startDay : _stake.scrapeDay;\n', '    }\n', '\n', '    function _notFuture(uint256 _day) internal view returns (bool) {\n', '        return _day <= _currentSwappDay();\n', '    }\n', '\n', '    function _notPast(uint256 _day) internal view returns (bool) {\n', '        return _day >= _currentSwappDay();\n', '    }\n', '\n', '    function _nonZeroAddress(address _address) internal pure returns (bool) {\n', '        return _address != address(0x0);\n', '    }\n', '\n', '    function _getLockDays(Stake memory _stake) internal pure returns (uint256) {\n', '        return\n', '            _stake.lockDays > 1 ?\n', '            _stake.lockDays - 1 : 1;\n', '    }\n', '\n', '    function _preparePath(\n', '        address _tokenAddress,\n', '        address _swappAddress\n', '    ) internal pure returns (address[] memory _path) {\n', '        _path = new address[](3);\n', '        _path[0] = _tokenAddress;\n', '        _path[1] = WETH;\n', '        _path[2] = _swappAddress;\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint value\n', '    ) internal {\n', '        (bool success, bytes memory data) = token.call(\n', '            abi.encodeWithSelector(0x23b872dd, from, to, value)\n', '        );\n', '\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))));\n', '    }\n', '}\n', '\n', 'abstract contract Snapshot is Helper {\n', '    using SafeMath for uint;\n', '\n', '    // regular shares\n', '    struct SnapShot {\n', '        uint256 totalShares;\n', '        uint256 inflationAmount;\n', '        uint256 scheduledToEnd;\n', '    }\n', '\n', '    // referral shares\n', '    struct rSnapShot {\n', '        uint256 totalShares;\n', '        uint256 inflationAmount;\n', '        uint256 scheduledToEnd;\n', '    }\n', '\n', '    mapping(uint256 => SnapShot) public snapshots;\n', '    mapping(uint256 => rSnapShot) public rsnapshots;\n', '    \n', '    modifier snapshotTrigger() {\n', '        _dailySnapshotPoint(_currentSwappDay());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice allows to activate/deactivate\n', '     * liquidity guard manually based on the\n', '     * liquidity in UNISWAP pair contract\n', '     */\n', '    function liquidityGuardTrigger() public {\n', '        (\n', '            uint112 reserveA,\n', '            uint112 reserveB,\n', '        ) = UNISWAP_PAIR.getReserves();\n', '\n', '        uint256 onUniswap = UNISWAP_PAIR.token1() == WETH\n', '            ? reserveA\n', '            : reserveB;\n', '\n', '        uint256 ratio = totalSupply() == 0\n', '            ? 0\n', '            : onUniswap\n', '                .mul(200)\n', '                .div(totalSupply());\n', '\n', '        if (ratio < 40 && isLiquidityGuardActive == false) enableLiquidityGuard();\n', '        if (ratio > 60 && isLiquidityGuardActive == true) disableLiquidityGuard();\n', '\n', '        emit LiquidityGuardStatus(isLiquidityGuardActive);\n', '    }\n', '\n', '    function enableLiquidityGuard() private {\n', '        isLiquidityGuardActive = true;\n', '    }\n', '\n', '    function disableLiquidityGuard() private {\n', '        isLiquidityGuardActive = false;\n', '    }\n', '\n', '    /**\n', '     * @notice allows volunteer to offload snapshots\n', '     * to save on gas during next start/end stake\n', '     */\n', '    function manualDailySnapshot() external {\n', '        _dailySnapshotPoint(_currentSwappDay());\n', '    }\n', '\n', '    /**\n', '     * @notice allows volunteer to offload snapshots\n', '     * to save on gas during next start/end stake\n', '     * in case manualDailySnapshot reach block limit\n', '     */\n', '    function manualDailySnapshotPoint(uint64 _updateDay) external {\n', '        require(_updateDay > 0 && _updateDay < _currentSwappDay());\n', '        require(_updateDay > globals.currentSwappDay);\n', '\n', '        _dailySnapshotPoint(_updateDay);\n', '    }\n', '\n', '    /**\n', '     * @notice internal function that offloads\n', '     * global values to daily snapshots\n', '     * updates globals.currentSwappDay\n', '     */\n', '    function _dailySnapshotPoint(uint64 _updateDay) private {\n', '        liquidityGuardTrigger();\n', '\n', '        uint256 scheduledToEndToday;\n', '        uint256 totalStakedToday = globals.totalStaked;\n', '\n', '        for (uint256 _day = globals.currentSwappDay; _day < _updateDay; _day++) {\n', '\n', '            // ------------------------------------\n', '            // prepare snapshot for regular shares\n', '            // reusing scheduledToEndToday variable\n', '\n', '            scheduledToEndToday = scheduledToEnd[_day] + snapshots[_day - 1].scheduledToEnd;\n', '\n', '            SnapShot memory snapshot = snapshots[_day];\n', '            snapshot.scheduledToEnd = scheduledToEndToday;\n', '\n', '            snapshot.totalShares =\n', '                globals.totalShares > scheduledToEndToday ?\n', '                globals.totalShares - scheduledToEndToday : 0;\n', '\n', '            snapshot.inflationAmount =  snapshot.totalShares\n', '                .mul(PRECISION_RATE)\n', '                .div(\n', '                    _inflationAmount(\n', '                        totalStakedToday,\n', '                        totalSupply(),\n', '                        totalPenalties[_day],\n', '                        LIQUIDITY_GUARD.getInflation(\n', '                            INFLATION_RATE\n', '                        )\n', '                    )\n', '                );\n', '\n', '            // store regular snapshot\n', '            snapshots[_day] = snapshot;\n', '\n', '            // ------------------------------------\n', '            // prepare snapshot for referrer shares\n', '            // reusing scheduledToEndToday variable\n', '\n', '            scheduledToEndToday = referralSharesToEnd[_day] + rsnapshots[_day - 1].scheduledToEnd;\n', '\n', '            rSnapShot memory rsnapshot = rsnapshots[_day];\n', '            rsnapshot.scheduledToEnd = scheduledToEndToday;\n', '\n', '            rsnapshot.totalShares =\n', '                globals.referralShares > scheduledToEndToday ?\n', '                globals.referralShares - scheduledToEndToday : 0;\n', '\n', '            rsnapshot.inflationAmount = rsnapshot.totalShares\n', '                .mul(PRECISION_RATE)\n', '                .div(\n', '                    _referralInflation(\n', '                        totalStakedToday,\n', '                        totalSupply()\n', '                    )\n', '                );\n', '\n', '            // store referral snapshot\n', '            rsnapshots[_day] = rsnapshot;\n', '\n', '            adjustLiquidityRates();\n', '            globals.currentSwappDay++;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice moves inflation up and down by 0.006%\n', '     * from regular shares to liquidity shares\n', '     * if the liquidityGuard is active (visa-versa)\n', '     */\n', '    function adjustLiquidityRates() private {\n', '        if (isLiquidityGuardActive ==  true) {\n', '            INFLATION_RATE = INFLATION_RATE - 6;\n', '            return;\n', '        }\n', '        if (isLiquidityGuardActive == false) {\n', '            INFLATION_RATE = INFLATION_RATE + 6;\n', '            return;\n', '        }\n', '    }\n', '\n', '    function _inflationAmount(\n', '        uint256 _totalStaked,\n', '        uint256 _totalSupply,\n', '        uint256 _totalPenalties,\n', '        uint256 _INFLATION_RATE\n', '    ) private pure returns (uint256) {\n', '        return (_totalStaked + _totalSupply) * 10000 / _INFLATION_RATE + _totalPenalties;\n', '    }\n', '\n', '    function _referralInflation(\n', '        uint256 _totalStaked,\n', '        uint256 _totalSupply\n', '    ) private pure returns (uint256) {\n', '        return (_totalStaked + _totalSupply) * 10000 / REFERRALS_RATE;\n', '    }\n', '}\n', '\n', 'abstract contract ReferralToken is Snapshot {\n', '    using SafeMath for uint256;\n', '\n', '    function _addReferrerSharesToEnd(uint256 _finalDay, uint256 _shares) internal {\n', '        referralSharesToEnd[_finalDay] =\n', '        referralSharesToEnd[_finalDay].add(_shares);\n', '    }\n', '\n', '    function _removeReferrerSharesToEnd(uint256 _finalDay, uint256 _shares) internal {\n', '        if (_notPast(_finalDay)) {\n', '            referralSharesToEnd[_finalDay] =\n', '            referralSharesToEnd[_finalDay] > _shares ?\n', '            referralSharesToEnd[_finalDay] - _shares : 0;\n', '        } else {\n', '            uint256 _day = previousSwappDay();\n', '            rsnapshots[_day].scheduledToEnd =\n', '            rsnapshots[_day].scheduledToEnd > _shares ?\n', '            rsnapshots[_day].scheduledToEnd - _shares : 0;\n', '        }\n', '    }\n', '\n', '    function _belowThresholdLevel(address _referrer) private view returns (bool) {\n', '        return criticalMass[_referrer].totalAmount < THRESHOLD_LIMIT;\n', '    }\n', '\n', '    function _addCriticalMass(address _referrer, uint256 _daiEquivalent) internal {\n', '        criticalMass[_referrer].totalAmount =\n', '        criticalMass[_referrer].totalAmount.add(_daiEquivalent);\n', '        criticalMass[_referrer].activationDay = _determineActivationDay(_referrer);\n', '    }\n', '\n', '    function _removeCriticalMass(\n', '        address _referrer,\n', '        uint256 _daiEquivalent,\n', '        uint256 _startDay\n', '    ) internal {\n', '        if (\n', '            _notFuture(_startDay) == false &&\n', '            _nonZeroAddress(_referrer)\n', '        ) {\n', '            criticalMass[_referrer].totalAmount =\n', '            criticalMass[_referrer].totalAmount > _daiEquivalent ?\n', '            criticalMass[_referrer].totalAmount - _daiEquivalent : 0;\n', '            criticalMass[_referrer].activationDay = _determineActivationDay(_referrer);\n', '        }\n', '    }\n', '\n', '    function _determineActivationDay(address _referrer) private view returns (uint256) {\n', '        return _belowThresholdLevel(_referrer) ? 0 : _activationDay(_referrer);\n', '    }\n', '\n', '    function _activationDay(address _referrer) private view returns (uint256) {\n', '        return\n', '            criticalMass[_referrer].activationDay > 0 ?\n', '            criticalMass[_referrer].activationDay : _currentSwappDay();\n', '    }\n', '\n', '    function _updateDaiEquivalent() internal returns (uint256) {\n', '        try UNISWAP_ROUTER.getAmountsOut(\n', '            TESLAS_PER_SWAPP, _path\n', '        ) returns (uint256[] memory results) {\n', '            latestDaiEquivalent = results[2];\n', '            return latestDaiEquivalent;\n', '        } catch Error(string memory) {\n', '            return latestDaiEquivalent;\n', '        } catch (bytes memory) {\n', '            return latestDaiEquivalent;\n', '        }\n', '    }\n', '\n', '    function referrerInterest(\n', '        bytes16 _referralID,\n', '        uint256 _scrapeDays\n', '    ) external snapshotTrigger {\n', '        _referrerInterest(\n', '            msg.sender,\n', '            _referralID,\n', '            _scrapeDays\n', '        );\n', '    }\n', '\n', '    function referrerInterestBulk(\n', '        bytes16[] memory _referralIDs,\n', '        uint256[] memory _scrapeDays\n', '    ) external snapshotTrigger {\n', '        for(uint256 i = 0; i < _referralIDs.length; i++) {\n', '            _referrerInterest(\n', '                msg.sender,\n', '                _referralIDs[i],\n', '                _scrapeDays[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    function _referrerInterest(\n', '        address _referrer,\n', '        bytes16 _referralID,\n', '        uint256 _processDays\n', '    ) internal {\n', '        ReferrerLink memory link =\n', '        referrerLinks[_referrer][_referralID];\n', '\n', '        require(link.isActive == true);\n', '\n', '        address staker = link.staker;\n', '        bytes16 stakeID = link.stakeID;\n', '\n', '        Stake memory stake = stakes[staker][stakeID];\n', '\n', '        uint256 startDay = _determineStartDay(stake, link);\n', '        uint256 finalDay = _determineFinalDay(stake);\n', '\n', '        if (_stakeEnded(stake)) {\n', '            if (\n', '                _processDays > 0 &&\n', '                _processDays < _daysDiff(startDay, finalDay)\n', '                )\n', '            {\n', '                link.processedDays =\n', '                link.processedDays.add(_processDays);\n', '\n', '                finalDay =\n', '                startDay.add(_processDays);\n', '            } else {\n', '                link.isActive = false;\n', '            }\n', '        } else {\n', '            _processDays = _daysDiff(startDay, _currentSwappDay());\n', '\n', '            link.processedDays =\n', '            link.processedDays.add(_processDays);\n', '\n', '            finalDay =\n', '            startDay.add(_processDays);\n', '        }\n', '\n', '        uint256 referralInterest = _checkReferralInterest(\n', '            stake,\n', '            startDay,\n', '            finalDay\n', '        );\n', '\n', '        link.rewardAmount = link.rewardAmount.add(referralInterest);\n', '\n', '        referrerLinks[_referrer][_referralID] = link;\n', '\n', '        _mint(_referrer, referralInterest);\n', '\n', '        emit ReferralCollected(\n', '            staker,\n', '            stakeID,\n', '            _referrer,\n', '            _referralID,\n', '            referralInterest\n', '        );\n', '    }\n', '\n', '    function checkReferralsByID(\n', '        address _referrer,\n', '        bytes16 _referralID\n', '    ) external view returns (\n', '        address staker,\n', '        bytes16 stakeID,\n', '        uint256 referrerShares,\n', '        uint256 referralInterest,\n', '        bool isActiveReferral,\n', '        bool isActiveStake,\n', '        bool isMatureStake,\n', '        bool isEndedStake\n', '    ) {\n', '        ReferrerLink memory link = referrerLinks[_referrer][_referralID];\n', '\n', '        staker = link.staker;\n', '        stakeID = link.stakeID;\n', '        isActiveReferral = link.isActive;\n', '\n', '        Stake memory stake = stakes[staker][stakeID];\n', '        referrerShares = stake.referrerShares;\n', '\n', '        referralInterest = _checkReferralInterest(\n', '            stake,\n', '            _determineStartDay(stake, link),\n', '            _determineFinalDay(stake)\n', '        );\n', '\n', '        isActiveStake = stake.isActive;\n', '        isEndedStake = _stakeEnded(stake);\n', '        isMatureStake = _isMatureStake(stake);\n', '    }\n', '\n', '    function _checkReferralInterest(\n', '        Stake memory _stake,\n', '        uint256 _startDay,\n', '        uint256 _finalDay\n', '    ) internal view returns (uint256 _referralInterest) {\n', '        return _notCriticalMassReferrer(_stake.referrer) ? 0 : _getReferralInterest(_stake, _startDay, _finalDay);\n', '    }\n', '\n', '    function _getReferralInterest(\n', '        Stake memory _stake,\n', '        uint256 _startDay,\n', '        uint256 _finalDay\n', '    ) private view returns (uint256 _referralInterest) {\n', '        for (uint256 _day = _startDay; _day < _finalDay; _day++) {\n', '            _referralInterest += _stake.stakesShares * PRECISION_RATE / rsnapshots[_day].inflationAmount;\n', '        }\n', '    }\n', '\n', '    function _determineStartDay(\n', '        Stake memory _stake,\n', '        ReferrerLink memory _link\n', '    ) internal view returns (uint256) {\n', '        return (\n', '            criticalMass[_stake.referrer].activationDay > _stake.startDay ?\n', '            criticalMass[_stake.referrer].activationDay : _stake.startDay\n', '        ).add(_link.processedDays);\n', '    }\n', '\n', '    function _determineFinalDay(\n', '        Stake memory _stake\n', '    ) internal view returns (uint256) {\n', '        return\n', '            _stake.closeDay > 0 ?\n', '            _stake.closeDay : _calculationDay(_stake);\n', '    }\n', '}\n', '\n', 'abstract contract StakingToken is ReferralToken {\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * @notice A method for a staker to create multiple stakes\n', '     * @param _stakedAmount amount of SWAPP staked.\n', '     * @param _lockDays amount of days it is locked for.\n', '     * @param _referrer address of the referrer\n', '     */\n', '    function createStakeBulk(\n', '        uint256[] memory _stakedAmount,\n', '        uint64[] memory _lockDays,\n', '        address[] memory _referrer\n', '    ) external {\n', '        for(uint256 i = 0; i < _stakedAmount.length; i++) {\n', '            createStake(_stakedAmount[i], _lockDays[i], _referrer[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice A method for a staker to create a stake\n', '     * @param _stakedAmount amount of SWAPP staked.\n', '     * @param _lockDays amount of days it is locked for.\n', '     * @param _referrer address of the referrer\n', '     */\n', '    function createStake(\n', '        uint256 _stakedAmount,\n', '        uint64 _lockDays,\n', '        address _referrer\n', '    )  public returns (bytes16, uint256, bytes16 referralID) {\n', '        require(msg.sender != _referrer && notContract(_referrer));\n', '        require(_lockDays >= MIN_LOCK_DAYS && _lockDays <= MAX_LOCK_DAYS);\n', '        require(_stakedAmount >= MIN_STAKE_AMOUNT);\n', '\n', '        (\n', '            Stake memory newStake,\n', '            bytes16 stakeID,\n', '            uint256 _startDay\n', '        ) = _createStake(msg.sender, _stakedAmount, _lockDays, _referrer);\n', '\n', '        if (newStake.referrerShares > 0) {\n', '\n', '            ReferrerLink memory referrerLink;\n', '\n', '            referrerLink.staker = msg.sender;\n', '            referrerLink.stakeID = stakeID;\n', '            referrerLink.isActive = true;\n', '\n', '            referralID = generateReferralID(_referrer);\n', '            referrerLinks[_referrer][referralID] = referrerLink;\n', '\n', '            _increaseReferralCount(_referrer);\n', '            _addReferrerSharesToEnd(newStake.finalDay, newStake.referrerShares);\n', '        }\n', '\n', '        stakes[msg.sender][stakeID] = newStake;\n', '\n', '        _increaseStakeCount(msg.sender);\n', '\n', '        _increaseGlobals(\n', '            newStake.stakedAmount,\n', '            newStake.stakesShares,\n', '            newStake.referrerShares\n', '        );\n', '\n', '        _addScheduledShares(newStake.finalDay, newStake.stakesShares);\n', '\n', '        emit StakeStart(\n', '            stakeID,\n', '            msg.sender,\n', '            _referrer,\n', '            newStake.stakedAmount,\n', '            newStake.stakesShares,\n', '            newStake.referrerShares,\n', '            newStake.startDay,\n', '            newStake.lockDays,\n', '            newStake.daiEquivalent\n', '        );\n', '\n', '        return (stakeID, _startDay, referralID);\n', '    }\n', '\n', '    function getStakingShare(\n', '        uint256 _stakedAmount,\n', '        uint64 _lockDays,\n', '        address _referrer\n', '    ) external view returns (uint256 stakingShare) {\n', '        return _stakesShares(\n', '            _stakedAmount,\n', '            _lockDays,\n', '            _referrer,\n', '            globals.sharePrice\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @notice A method for a staker to start a stake\n', '    * @param _staker ...\n', '    * @param _stakedAmount ...\n', '    * @param _lockDays ...\n', '    */\n', '    function _createStake(\n', '        address _staker,\n', '        uint256 _stakedAmount,\n', '        uint64 _lockDays,\n', '        address _referrer\n', '    ) private returns (Stake memory _newStake, bytes16 _stakeID, uint64 _startDay) {\n', '        _burn(_staker, _stakedAmount);\n', '\n', '        userStakedAmount[_staker] = userStakedAmount[_staker].add(_stakedAmount);\n', '\n', '        _startDay = nextSwappDay();\n', '        _stakeID = generateStakeID(_staker);\n', '\n', '        _newStake.lockDays = _lockDays;\n', '        _newStake.startDay = _startDay;\n', '        _newStake.finalDay = _startDay + _lockDays;\n', '        _newStake.isActive = true;\n', '\n', '        _newStake.stakedAmount = _stakedAmount;\n', '        _newStake.stakesShares = _stakesShares(\n', '            _stakedAmount,\n', '            _lockDays,\n', '            _referrer,\n', '            globals.sharePrice\n', '        );\n', '\n', '        _updateDaiEquivalent();\n', '\n', '        _newStake.daiEquivalent = latestDaiEquivalent\n', '            .mul(_newStake.stakedAmount)\n', '            .div(TESLAS_PER_SWAPP);\n', '\n', '        if (_nonZeroAddress(_referrer)) {\n', '            _newStake.referrer = _referrer;\n', '            _addCriticalMass(_newStake.referrer, _newStake.daiEquivalent);\n', '            _newStake.referrerShares = _referrerShares(\n', '                _stakedAmount,\n', '                _lockDays,\n', '                _referrer\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice A method for a staker to remove a stake\n', '    * belonging to his address by providing ID of a stake.\n', '    * @param _stakeID unique bytes sequence reference to the stake\n', '    */\n', '    function endStake(bytes16 _stakeID) snapshotTrigger external returns (uint256) {\n', '        (\n', '            Stake memory endedStake,\n', '            uint256 penaltyAmount\n', '        ) = _endStake(msg.sender, _stakeID);\n', '\n', '        _decreaseGlobals(\n', '            endedStake.stakedAmount,\n', '            endedStake.stakesShares,\n', '            endedStake.referrerShares\n', '        );\n', '\n', '        _removeScheduledShares(endedStake.finalDay, endedStake.stakesShares);\n', '        _removeReferrerSharesToEnd(endedStake.finalDay, endedStake.referrerShares);\n', '\n', '        _removeCriticalMass(\n', '            endedStake.referrer,\n', '            endedStake.daiEquivalent,\n', '            endedStake.startDay\n', '        );\n', '\n', '        _storePenalty(endedStake.closeDay, penaltyAmount);\n', '\n', '        _sharePriceUpdate(\n', '            endedStake.stakedAmount > penaltyAmount ?\n', '            endedStake.stakedAmount - penaltyAmount : 0,\n', '            endedStake.rewardAmount + scrapes[msg.sender][_stakeID],\n', '            endedStake.referrer,\n', '            endedStake.lockDays,\n', '            endedStake.stakesShares\n', '        );\n', '\n', '        emit StakeEnd(\n', '            _stakeID,\n', '            msg.sender,\n', '            endedStake.referrer,\n', '            endedStake.stakedAmount,\n', '            endedStake.stakesShares,\n', '            endedStake.referrerShares,\n', '            endedStake.rewardAmount,\n', '            endedStake.closeDay,\n', '            penaltyAmount\n', '        );\n', '\n', '        return endedStake.rewardAmount;\n', '    }\n', '\n', '    function _endStake(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    ) private returns (Stake storage _stake, uint256 _penalty) {\n', '        require(stakes[_staker][_stakeID].isActive);\n', '\n', '        _stake = stakes[_staker][_stakeID];\n', '        _stake.closeDay = _currentSwappDay();\n', '        _stake.rewardAmount = _calculateRewardAmount(_stake);\n', '        _penalty = _calculatePenaltyAmount(_stake);\n', '\n', '        _stake.isActive = false;\n', '\n', '        userStakedAmount[_staker] = userStakedAmount[_staker].sub(_stake.stakedAmount);\n', '\n', '        _mint(\n', '            _staker,\n', '            _stake.stakedAmount > _penalty ?\n', '            _stake.stakedAmount - _penalty : 0\n', '        );\n', '\n', '        _mint(_staker, _stake.rewardAmount);\n', '    }\n', '\n', '    /**\n', '    * @notice alloes to scrape interest from active stake\n', '    * @param _stakeID unique bytes sequence reference to the stake\n', '    * @param _scrapeDays amount of days to proccess, 0 = all\n', '    */\n', '    function scrapeInterest(\n', '        bytes16 _stakeID,\n', '        uint64 _scrapeDays\n', '    ) external snapshotTrigger returns (\n', '        uint256 scrapeDay,\n', '        uint256 scrapeAmount,\n', '        uint256 remainingDays,\n', '        uint256 stakersPenalty,\n', '        uint256 referrerPenalty\n', '    ) {\n', '        require(stakes[msg.sender][_stakeID].isActive);\n', '\n', '        Stake memory stake = stakes[msg.sender][_stakeID];\n', '\n', '        scrapeDay = _scrapeDays > 0\n', '            ? _startingDay(stake).add(_scrapeDays)\n', '            : _calculationDay(stake);\n', '\n', '        scrapeDay = scrapeDay > stake.finalDay\n', '            ? _calculationDay(stake)\n', '            : scrapeDay;\n', '\n', '        scrapeAmount = _loopRewardAmount(\n', '            stake.stakesShares,\n', '            _startingDay(stake),\n', '            scrapeDay\n', '        );\n', '\n', '        if (_isMatureStake(stake) == false) {\n', '\n', '            remainingDays = _daysLeft(stake);\n', '\n', '            stakersPenalty = _stakesShares(\n', '                scrapeAmount,\n', '                remainingDays,\n', '                msg.sender,\n', '                globals.sharePrice\n', '            );\n', '\n', '            stake.stakesShares = stake.stakesShares.sub(stakersPenalty);\n', '\n', '            _removeScheduledShares(stake.finalDay, stakersPenalty);\n', '\n', '            if (stake.referrerShares > 0) {\n', '                referrerPenalty = _stakesShares(\n', '                    scrapeAmount,\n', '                    remainingDays,\n', '                    address(0x0),\n', '                    globals.sharePrice\n', '                );\n', '\n', '                stake.referrerShares = stake.referrerShares.sub(referrerPenalty);\n', '                _removeReferrerSharesToEnd(stake.finalDay, referrerPenalty);\n', '            }\n', '\n', '            _decreaseGlobals(0, stakersPenalty, referrerPenalty);\n', '\n', '            _sharePriceUpdate(\n', '                stake.stakedAmount,\n', '                scrapeAmount,\n', '                stake.referrer,\n', '                stake.lockDays,\n', '                stake.stakesShares\n', '            );\n', '        }\n', '        else {\n', '            scrapes[msg.sender][_stakeID] = scrapes[msg.sender][_stakeID].add(scrapeAmount);\n', '            _sharePriceUpdate(\n', '                stake.stakedAmount,\n', '                scrapes[msg.sender][_stakeID],\n', '                stake.referrer,\n', '                stake.lockDays,\n', '                stake.stakesShares\n', '            );\n', '        }\n', '\n', '        stake.scrapeDay = scrapeDay;\n', '        stakes[msg.sender][_stakeID] = stake;\n', '\n', '        _mint(msg.sender, scrapeAmount);\n', '\n', '        emit InterestScraped(\n', '            _stakeID,\n', '            msg.sender,\n', '            scrapeAmount,\n', '            scrapeDay,\n', '            stakersPenalty,\n', '            referrerPenalty,\n', '            _currentSwappDay()\n', '        );\n', '    }\n', '\n', '    function _addScheduledShares(uint256 _finalDay, uint256 _shares) internal {\n', '        scheduledToEnd[_finalDay] = scheduledToEnd[_finalDay].add(_shares);\n', '    }\n', '\n', '    function _removeScheduledShares(uint256 _finalDay, uint256 _shares) internal {\n', '        if (_notPast(_finalDay)) {\n', '            scheduledToEnd[_finalDay] =\n', '            scheduledToEnd[_finalDay] > _shares ?\n', '            scheduledToEnd[_finalDay] - _shares : 0;\n', '        } else {\n', '            uint256 _day = previousSwappDay();\n', '            snapshots[_day].scheduledToEnd =\n', '            snapshots[_day].scheduledToEnd > _shares ?\n', '            snapshots[_day].scheduledToEnd - _shares : 0;\n', '        }\n', '    }\n', '\n', '    function _sharePriceUpdate(\n', '        uint256 _stakedAmount,\n', '        uint256 _rewardAmount,\n', '        address _referrer,\n', '        uint256 _lockDays,\n', '        uint256 _stakeShares\n', '    ) private {\n', '        if (_stakeShares > 0 && _currentSwappDay() > FORMULA_DAY) {\n', '            uint256 newSharePrice = _getNewSharePrice(\n', '                _stakedAmount,\n', '                _rewardAmount,\n', '                _stakeShares,\n', '                _lockDays,\n', '                _referrer\n', '            );\n', '\n', '            if (newSharePrice > globals.sharePrice) {\n', '                newSharePrice = newSharePrice < globals.sharePrice.mul(110).div(100) ?\n', '                    newSharePrice : globals.sharePrice.mul(110).div(100);\n', '\n', '                emit NewSharePrice(\n', '                    newSharePrice,\n', '                    globals.sharePrice,\n', '                    _currentSwappDay()\n', '                );\n', '\n', '                globals.sharePrice = newSharePrice;\n', '            }\n', '\n', '            return;\n', '        }\n', '\n', '        if (_currentSwappDay() == FORMULA_DAY) {\n', '            globals.sharePrice = 110E15;\n', '        }\n', '    }\n', '\n', '    function _getNewSharePrice(\n', '        uint256 _stakedAmount,\n', '        uint256 _rewardAmount,\n', '        uint256 _stakeShares,\n', '        uint256 _lockDays,\n', '        address _referrer\n', '    ) private pure returns (uint256) {\n', '        uint256 _bonusAmount = _getBonus(\n', '            _lockDays, _nonZeroAddress(_referrer) ? 11E9 : 10E9\n', '        );\n', '\n', '        return \n', '            _stakedAmount\n', '                .add(_rewardAmount)\n', '                .mul(_bonusAmount)\n', '                .mul(1E8)\n', '                .div(_stakeShares);\n', '    }\n', '\n', '    function checkMatureStake(\n', '        address _staker,\n', '        bytes16 _stakeID\n', '    ) external view returns (bool isMature) {\n', '        Stake memory stake = stakes[_staker][_stakeID];\n', '        isMature = _isMatureStake(stake);\n', '    }\n', '\n', '    function checkStakeByID(address _staker, bytes16 _stakeID) external view\n', '        returns (\n', '            uint256 startDay,\n', '            uint256 lockDays,\n', '            uint256 finalDay,\n', '            uint256 closeDay,\n', '            uint256 scrapeDay,\n', '            uint256 stakedAmount,\n', '            uint256 stakesShares,\n', '            uint256 rewardAmount,\n', '            uint256 penaltyAmount,\n', '            bool isActive,\n', '            bool isMature\n', '        )\n', '    {\n', '        Stake memory stake = stakes[_staker][_stakeID];\n', '        startDay = stake.startDay;\n', '        lockDays = stake.lockDays;\n', '        finalDay = stake.finalDay;\n', '        closeDay = stake.closeDay;\n', '        scrapeDay = stake.scrapeDay;\n', '        stakedAmount = stake.stakedAmount;\n', '        stakesShares = stake.stakesShares;\n', '        rewardAmount = _checkRewardAmount(stake);\n', '        penaltyAmount = _calculatePenaltyAmount(stake);\n', '        isActive = stake.isActive;\n', '        isMature = _isMatureStake(stake);\n', '    }\n', '\n', '    function _stakesShares(\n', '        uint256 _stakedAmount,\n', '        uint256 _lockDays,\n', '        address _referrer,\n', '        uint256 _sharePrice\n', '    ) private pure returns (uint256) {\n', '        return _nonZeroAddress(_referrer)\n', '            ? _sharesAmount(_stakedAmount, _lockDays, _sharePrice, 11E9)\n', '            : _sharesAmount(_stakedAmount, _lockDays, _sharePrice, 10E9);\n', '    }\n', '\n', '    function _sharesAmount(\n', '        uint256 _stakedAmount,\n', '        uint256 _lockDays,\n', '        uint256 _sharePrice,\n', '        uint256 _extraBonus\n', '    ) private pure returns (uint256) {\n', '        return _baseAmount(_stakedAmount, _sharePrice)\n', '            .mul(_getBonus(_lockDays, _extraBonus))\n', '            .div(10E9);\n', '    }\n', '\n', '    function _getBonus(\n', '        uint256 _lockDays,\n', '        uint256 _extraBonus\n', '    ) private pure returns (uint256) {\n', '        return\n', '            _regularBonus(_lockDays, DAILY_BONUS_A, MAX_BONUS_DAYS_A) +\n', '            _regularBonus(\n', '                _lockDays > MAX_BONUS_DAYS_A ?\n', '                _lockDays - MAX_BONUS_DAYS_A : 0, DAILY_BONUS_B, MAX_BONUS_DAYS_B\n', '            ) + _extraBonus;\n', '    }\n', '\n', '    function _regularBonus(\n', '        uint256 _lockDays,\n', '        uint256 _daily,\n', '        uint256 _maxDays\n', '    ) private pure returns (uint256) {\n', '        return (\n', '            _lockDays > _maxDays\n', '                ? _maxDays.mul(_daily)\n', '                : _lockDays.mul(_daily)\n', '            ).div(10E9);\n', '    }\n', '\n', '    function _baseAmount(\n', '        uint256 _stakedAmount,\n', '        uint256 _sharePrice\n', '    ) private pure returns (uint256) {\n', '        return _stakedAmount.mul(PRECISION_RATE).div(_sharePrice);\n', '    }\n', '\n', '    function _referrerShares(\n', '        uint256 _stakedAmount,\n', '        uint256 _lockDays,\n', '        address _referrer\n', '    ) private view returns (uint256) {\n', '        return\n', '            _notCriticalMassReferrer(_referrer) ||\n', '            _lockDays < MIN_REFERRAL_DAYS\n', '                ? 0\n', '                : _sharesAmount(\n', '                    _stakedAmount,\n', '                    _lockDays,\n', '                    globals.sharePrice,\n', '                    10E9\n', '                );\n', '    }\n', '\n', '    function _checkRewardAmount(Stake memory _stake) private view returns (uint256) {\n', '        return _stake.isActive ? _detectReward(_stake) : _stake.rewardAmount;\n', '    }\n', '\n', '    function _detectReward(Stake memory _stake) private view returns (uint256) {\n', '        return _stakeNotStarted(_stake) ? 0 : _calculateRewardAmount(_stake);\n', '    }\n', '\n', '    function _storePenalty(uint64 _storeDay, uint256 _penalty) private {\n', '        if (_penalty > 0) {\n', '            totalPenalties[_storeDay] =\n', '            totalPenalties[_storeDay].add(_penalty);\n', '        }\n', '    }\n', '\n', '    function _calculatePenaltyAmount(Stake memory _stake) private view returns (uint256) {\n', '        return _stakeNotStarted(_stake) || _isMatureStake(_stake) ? 0 : _getPenalties(_stake);\n', '    }\n', '\n', '    function _getPenalties(Stake memory _stake) private view returns (uint256) {\n', '        return _stake.stakedAmount * (100 + (800 * (_daysLeft(_stake) - 1) / (_getLockDays(_stake)))) / 1000;\n', '    }\n', '\n', '    function _calculateRewardAmount(Stake memory _stake) private view returns (uint256) {\n', '        return _loopRewardAmount(\n', '            _stake.stakesShares,\n', '            _startingDay(_stake),\n', '            _calculationDay(_stake)\n', '        );\n', '    }\n', '\n', '    function _loopRewardAmount(\n', '        uint256 _stakeShares,\n', '        uint256 _startDay,\n', '        uint256 _finalDay\n', '    ) private view returns (uint256 _rewardAmount) {\n', '        for (uint256 _day = _startDay; _day < _finalDay; _day++) {\n', '            _rewardAmount += _stakeShares * PRECISION_RATE / snapshots[_day].inflationAmount;\n', '        }\n', '    }\n', '}\n', '\n', 'contract SwappToken is StakingToken {\n', '    address public LIQUIDITY_TRANSFORMER;\n', '    address public YIELD_FARM_STABLE;\n', '    address public YIELD_FARM_LP;\n', '    address public tokenMinterDefiner;\n', '\n', '    modifier onlyMinter() {\n', '        require(\n', '            msg.sender == LIQUIDITY_TRANSFORMER ||\n', '            msg.sender == YIELD_FARM_STABLE ||\n', '            msg.sender == YIELD_FARM_LP,\n', "            'SWAPP: Invalid token minter'\n", '        );\n', '        _;\n', '    }\n', '\n', '    constructor() ERC20("Swapp Token", "SWAPP") {\n', '        tokenMinterDefiner = msg.sender;\n', '\n', '        _mint(0x0d970a04d46c73B6d20d9a0B2B07C35F2495ca9c, 162500000E18); // SWAPP FOUNDATION - Contract Owner Wallet\n', '        _mint(0x915D99375Ba8EDbbee46bE1AD045718a05A6655b, 3307862E18);   // MM-PRESALE Investors Wallet\n', '        _mint(0x7Db4456a73a9C94a381d244E9dfC76E83C05913E, 58364082E18);  // Employee Pool Including Founders MM Wallet\n', '        _mint(0x62F16a5bA06693B1E96a656d46e66A8CdaE17C69, 13328056E18);  // Swapp Previous Investors MM Wallet\n', '        _mint(0x94dc2f1823AbfdC2fb9BB8Ae10162b65D2Cf1c65, 250000000E18); // Rewards Wallet\n', '        _mint(0x2a8eA8a4842DA268FA4180b1a99B7876f820ECC1, 35000000E18);  // Future Development Wallet\n', '        _mint(0x000baFB91ED6436ad2888C2418197aFDB85785C5, 5000000E18);   // Reserved Funding Wallet\n', '        _mint(0xd4041e1c24A54134Fb9657e8DA85e75001D7Ea44, 5000000E18);   // Bounty, Advisors, Partnership Wallet\n', '    }\n', '\n', '    receive() external payable {\n', '        revert();\n', '    }\n', '\n', '    function setMinters(\n', '        address _transformer,\n', '        address _yieldFarmStable,\n', '        address _yieldFarmLP\n', '    ) external {\n', '        require(tokenMinterDefiner == msg.sender);\n', '        LIQUIDITY_TRANSFORMER = _transformer;\n', '        YIELD_FARM_STABLE = _yieldFarmStable;\n', '        YIELD_FARM_LP = _yieldFarmLP;\n', '    }\n', '\n', '    function burnMinterDefiner() external {\n', '        require(tokenMinterDefiner == msg.sender);\n', '        tokenMinterDefiner = address(0x0);\n', '    }\n', '\n', '    /**\n', '     * @notice allows liquidityTransformer to mint supply\n', '     * @dev executed from liquidityTransformer upon UNISWAP transfer\n', '     * and during reservation payout to contributors and referrers\n', '     * @param _investorAddress address for minting SWAPP tokens\n', '     * @param _amount of tokens to mint for _investorAddress\n', '     */\n', '    function mintSupply(address _investorAddress, uint256 _amount) external onlyMinter {\n', '        _mint(_investorAddress, _amount);\n', '    }\n', '\n', '    /**\n', '     * @notice allows to grant permission to CM referrer status\n', '     * @dev called from liquidityTransformer if user referred 50 ETH\n', '     * @param _referrer - address that becomes a CM reffer\n', '     */\n', '    function giveStatus(address _referrer) external onlyMinter {\n', '        criticalMass[_referrer].totalAmount = THRESHOLD_LIMIT;\n', '        criticalMass[_referrer].activationDay = nextSwappDay();\n', '    }\n', '\n', '    /**\n', '     * @notice allows to create stake directly with ETH\n', "     * if you don't have SWAPP tokens method will convert\n", '     * and use amount returned from UNISWAP to open a stake\n', '     * @param _lockDays amount of days it is locked for.\n', '     * @param _referrer referrer address for +10% bonus\n', '     */\n', '    function createStakeWithETH(\n', '        uint64 _lockDays,\n', '        address _referrer\n', '    ) external payable returns (bytes16, uint256, bytes16 referralID) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = WETH;\n', '        path[1] = address(this);\n', '\n', '        uint256[] memory amounts = UNISWAP_ROUTER.swapExactETHForTokens{value: msg.value}(\n', '            1,\n', '            path,\n', '            msg.sender,\n', '            block.timestamp\n', '        );\n', '\n', '        return createStake(amounts[1], _lockDays, _referrer);\n', '    }\n', '\n', '    /**\n', '     * @notice allows to create stake with another token\n', "     * if you don't have SWAPP tokens method will convert\n", '     * and use amount returned from UNISWAP to open a stake\n', '     * @dev the token must have WETH pair on UNISWAP\n', '     * @param _tokenAddress any ERC20 token address\n', '     * @param _tokenAmount amount to be converted to SWAPP\n', '     * @param _lockDays amount of days it is locked for.\n', '     * @param _referrer referrer address for +10% bonus\n', '     */\n', '    function createStakeWithToken(\n', '        address _tokenAddress,\n', '        uint256 _tokenAmount,\n', '        uint64 _lockDays,\n', '        address _referrer\n', '    ) external returns (bytes16, uint256, bytes16 referralID) {\n', '        TokenInterface token = TokenInterface(_tokenAddress);\n', '\n', '        token.transferFrom(msg.sender, address(this), _tokenAmount);\n', '        token.approve(address(UNISWAP_ROUTER), _tokenAmount);\n', '\n', '        address[] memory path = _preparePath(_tokenAddress, address(this));\n', '\n', '        uint256[] memory amounts = UNISWAP_ROUTER.swapExactTokensForTokens(\n', '            _tokenAmount,\n', '            1,\n', '            path,\n', '            msg.sender,\n', '            block.timestamp\n', '        );\n', '\n', '        return createStake(amounts[2], _lockDays, _referrer);\n', '    }\n', '}']