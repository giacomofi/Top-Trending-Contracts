['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-04\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address account) external view returns (uint);\n', '    function transfer(address recipient, uint amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function approve(address spender, uint amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '}\n', '\n', 'contract Ownable {\n', '    \n', '    /// @notice The owner of the contract\n', '    address public owner;\n', '    \n', '    /// @notice Event to notify when the ownership of this contract changed\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @notice Set the owner of this contract to its creator\n', '    constructor () {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '    \n', '    modifier onlyOwner() {\n', '        require(owner == msg.sender, "caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer ownership to `newOwner`\n', '     * @param newOwner The address to transfer the ownership to\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        require(newOwner != address(0), "new owner is the zero address");\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '}\n', '\n', 'contract TokenMigrator is Ownable {\n', '    \n', '    /// @notice Token to migrate from\n', '    IERC20 public fromToken;\n', '    \n', '    /// @notice Token to migrate to\n', '    IERC20 public toToken;\n', '    \n', '    /// @notice The address where fromToken should be burned\n', '    address public constant BURN_ADDRESS = 0x0000000000000000000000000000000000000008;\n', '    \n', '    /// @notice Notice period before migration can be closed\n', '    uint256 public constant endMigrationNoticePeriod = 2 weeks;\n', '\n', '    /// @notice Flag that indicates whether migration is possible\n', '    bool public migrationEnabled = false;\n', '    \n', '    /// @notice The migration end date\n', '    uint256 public endMigrationDate = type(uint256).max;\n', '    \n', '    /// @notice Event to notify when the endMigrationDate is set\n', '    event CloseMigrationNotice(uint256 epochTime);\n', '    \n', '    /**\n', '     * @notice Construct a Migration contract\n', '     * @param migrateFromToken The token to migrate from\n', '     * @param migrateToToken The token to migrate into\n', '     */\n', '    constructor(address migrateFromToken, address migrateToToken) {\n', '        fromToken = IERC20(migrateFromToken);\n', '        toToken = IERC20(migrateToToken);\n', '    }\n', '    \n', '    modifier whenMigrationEnabled() {\n', '        require(migrationEnabled, "migration not enabled");\n', '        _;\n', '    }\n', '    \n', '    /**\n', '     * @notice Start the migration. Can only be called if this contract has enough balance of toToken\n', '     */\n', '    function startMigration() public {\n', '        uint256 requiredToTokenBalance = fromToken.totalSupply() - fromToken.balanceOf(BURN_ADDRESS);\n', '        \n', '        require(toToken.balanceOf(address(this)) >= requiredToTokenBalance, "not enough toToken balance");\n', '        \n', '        migrationEnabled = true;\n', '    }\n', '    \n', '    /**\n', '     * @notice Migrate `amount` of tokens\n', '     * @param amount How many tokens to migrate\n', '     */\n', '    function migrate(uint256 amount) public whenMigrationEnabled returns (bool success) {\n', '        require(fromToken.transferFrom(msg.sender, BURN_ADDRESS, amount), "burning fromToken failed");\n', '        require(toToken.transfer(msg.sender, amount), "sending toToken failed");\n', '        \n', '        return true;\n', '    }\n', '    \n', '    /**\n', '     * @notice Announce the migration can be closed after `endMigrationNoticePeriod` \n', '     */\n', '    function announceMigrationEnd() public onlyOwner whenMigrationEnabled {\n', '        endMigrationDate = block.timestamp + endMigrationNoticePeriod;\n', '        emit CloseMigrationNotice(endMigrationDate);\n', '    }\n', '    \n', '    /**\n', '     * @notice End the migration period. Can only be called after `endMigrationDate`\n', '     *  This also transfers the remainingBalance of toToken back to the owner\n', '     */\n', '    function closeMigration() public onlyOwner whenMigrationEnabled {\n', '        require(block.timestamp > endMigrationDate, "migration cannot be closed yet");\n', '        migrationEnabled = false;\n', '        uint256 remainingBalance = toToken.balanceOf(address(this));\n', '        require(toToken.transfer(owner, remainingBalance), "recovering toToken failed");\n', '    }\n', '}']