['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-05\n', '*/\n', '\n', '//SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.6.8;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IMirrorWriteToken {\n', '    function register(string calldata label, address owner) external;\n', '\n', '    function registrationCost() external view returns (uint256);\n', '\n', '    // ============ ERC20 Interface ============\n', '\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '}\n', '\n', '/**\n', ' * @title MirrorWriteToken\n', ' * @author MirrorXYZ\n', ' *\n', ' *  An ERC20 that grants access to the ENS namespace through a\n', ' *  burn-and-register model.\n', ' */\n', 'contract MirrorWriteToken is IMirrorWriteToken {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Immutable ERC20 Attributes ============\n', '\n', '    string public constant override symbol = "WRITE";\n', '    string public constant override name = "Mirror Write Token";\n', '    uint8 public constant override decimals = 18;\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH =\n', '        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '    bytes32 public immutable override DOMAIN_SEPARATOR;\n', '\n', '    // ============ Immutable Registration Configuration ============\n', '\n', '    uint256 internal constant REGISTRATION_COST = 1e18;\n', '\n', '    // ============ Mutable Ownership Configuration ============\n', '\n', '    address private _owner;\n', '    /**\n', '     * @dev Allows for two-step ownership transfer, whereby the next owner\n', '     * needs to accept the ownership transfer explicitly.\n', '     */\n', '    address private _nextOwner;\n', '\n', '    // ============ Mutable Registration Configuration ============\n', '\n', '    bool public registrable = true;\n', '    address public ensRegistrar;\n', '\n', '    // ============ Mutable ERC20 Attributes ============\n', '\n', '    uint256 public override totalSupply;\n', '    mapping(address => uint256) public override balanceOf;\n', '    mapping(address => mapping(address => uint256)) public override allowance;\n', '    mapping(address => uint256) public override nonces;\n', '\n', '    // ============ Events ============\n', '\n', '    event Registered(string label, address owner);\n', '    event Mint(address indexed to, uint256 amount);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event OwnershipTransferred(\n', '        address indexed previousOwner,\n', '        address indexed newOwner\n', '    );\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier canRegister() {\n', '        require(registrable, "MirrorWriteToken: registration is closed.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "MirrorWriteToken: caller is not the owner.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyNextOwner() {\n', '        require(\n', '            isNextOwner(),\n', '            "MirrorWriteToken: current owner must set caller as next owner."\n', '        );\n', '        _;\n', '    }\n', '\n', '    // ============ Constructor ============\n', '\n', '    constructor() public {\n', '        uint256 chainId = _getChainId();\n', '\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256(\n', '                    "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"\n', '                ),\n', '                keccak256(bytes(name)),\n', '                keccak256(bytes("1")),\n', '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '\n', '        _owner = tx.origin;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    // ============ Minting ============\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param to The address that will receive the minted tokens.\n', '     * @param amount The amount of tokens to mint.\n', '     */\n', '    function mint(address to, uint256 amount) external onlyOwner {\n', '        _mint(to, amount);\n', '\n', '        emit Mint(to, amount);\n', '    }\n', '\n', '    // ============ Registration ============\n', '\n', '    /**\n', '     * @dev Returns the cost of registration in tokens with full decimals.\n', '     */\n', '    function registrationCost() external view override returns (uint256) {\n', '        return REGISTRATION_COST;\n', '    }\n', '\n', '    /**\n', "     * Burns the sender's invite tokens and registers an ENS given label to a given address.\n", '     * @param label The user\'s ENS label, e.g. "dev" for dev.mirror.xyz.\n', '     * @param owner The address that should own the label.\n', '     */\n', '    function register(string calldata label, address owner)\n', '        external\n', '        override\n', '        canRegister\n', '    {\n', '        _burn(msg.sender, REGISTRATION_COST);\n', '\n', '        emit Registered(label, owner);\n', '\n', '        IMirrorENSRegistrar(ensRegistrar).register(label, owner);\n', '    }\n', '\n', '    // ============ Ownership ============\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the next owner.\n', '     */\n', '    function isNextOwner() public view returns (bool) {\n', '        return msg.sender == _nextOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows a new account (`newOwner`) to accept ownership.\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address nextOwner_) external onlyOwner {\n', '        require(\n', '            nextOwner_ != address(0),\n', '            "MirrorWriteToken: next owner is the zero address."\n', '        );\n', '\n', '        _nextOwner = nextOwner_;\n', '    }\n', '\n', '    /**\n', '     * @dev Cancel a transfer of ownership to a new account.\n', '     * Can only be called by the current owner.\n', '     */\n', '    function cancelOwnershipTransfer() external onlyOwner {\n', '        delete _nextOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to the caller.\n', '     * Can only be called by a new potential owner set by the current owner.\n', '     */\n', '    function acceptOwnership() external onlyNextOwner {\n', '        delete _nextOwner;\n', '\n', '        emit OwnershipTransferred(_owner, msg.sender);\n', '\n', '        _owner = msg.sender;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() external onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    // ============ Configuration Management ============\n', '\n', '    /**\n', '     * Allows the owner to change the ENS Registrar address.\n', '     */\n', '    function setENSRegistrar(address ensRegistrar_) external onlyOwner {\n', '        ensRegistrar = ensRegistrar_;\n', '    }\n', '\n', '    /**\n', '     * Allows the owner to pause registration.\n', '     */\n', '    function setRegistrable(bool registrable_) external onlyOwner {\n', '        registrable = registrable_;\n', '    }\n', '\n', '    // ============ ERC20 Spec ============\n', '\n', '    function _mint(address to, uint256 value) internal {\n', '        totalSupply = totalSupply.add(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint256 value) internal {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 value\n', '    ) private {\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) private {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint256 value)\n', '        external\n', '        override\n', '        returns (bool)\n', '    {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint256 value)\n', '        external\n', '        override\n', '        returns (bool)\n', '    {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external override returns (bool) {\n', '        if (allowance[from][msg.sender] != uint256(-1)) {\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(\n', '                value\n', '            );\n', '        }\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external override {\n', '        require(deadline >= block.timestamp, "MirrorWriteToken: EXPIRED");\n', '        bytes32 digest =\n', '            keccak256(\n', '                abi.encodePacked(\n', '                    "\\x19\\x01",\n', '                    DOMAIN_SEPARATOR,\n', '                    keccak256(\n', '                        abi.encode(\n', '                            PERMIT_TYPEHASH,\n', '                            owner,\n', '                            spender,\n', '                            value,\n', '                            nonces[owner]++,\n', '                            deadline\n', '                        )\n', '                    )\n', '                )\n', '            );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', '        require(\n', '            recoveredAddress != address(0) && recoveredAddress == owner,\n', '            "MirrorWriteToken: INVALID_SIGNATURE"\n', '        );\n', '        _approve(owner, spender, value);\n', '    }\n', '\n', '    function _getChainId() private pure returns (uint256 chainId) {\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '    }\n', '}\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', '\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '}\n', '\n', 'interface IENSReverseRegistrar {\n', '    function claim(address _owner) external returns (bytes32);\n', '\n', '    function claimWithResolver(address _owner, address _resolver)\n', '        external\n', '        returns (bytes32);\n', '\n', '    function setName(string calldata _name) external returns (bytes32);\n', '\n', '    function node(address _addr) external pure returns (bytes32);\n', '}\n', '\n', 'interface IMirrorENSRegistrar {\n', '    function changeRootNodeOwner(address newOwner_) external;\n', '\n', '    function register(string calldata label_, address owner_) external;\n', '\n', '    function updateENSReverseRegistrar() external;\n', '}']