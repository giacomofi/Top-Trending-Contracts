['// ------------------------------------------------------------------------\n', '// MorpherBridge\n', '// Handles deposit to and withdraws from the side chain, writing of the merkle\n', '// root to the main chain by the side chain operator, and enforces a rolling 24 hours\n', '// token withdraw limit from side chain to main chain.\n', "// If side chain operator doesn't write a merkle root hash to main chain for more than\n", '// 72 hours positions and balaces from side chain can be transferred to main chain.\n', '// ------------------------------------------------------------------------\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IMorpherState.sol";\n', 'import "./MerkleProof.sol";\n', '\n', 'contract MorpherBridge is Ownable {\n', '\n', '    IMorpherState state;\n', '    using SafeMath for uint256;\n', '\n', '    mapping(address => mapping(uint256 => uint256)) withdrawalPerDay; //[address][day] = withdrawalAmount\n', '    mapping(address => mapping(uint256 => uint256)) withdrawalPerMonth; //[address][month] = withdrawalAmount\n', '\n', '    uint256 public withdrawalLimitDaily = 200000 * (10**18); //200k MPH per day\n', '    uint256 public withdrawalLimitMonthly = 1000000 * (10 ** 18); //1M MPH per month\n', '\n', '    event TransferToLinkedChain(\n', '        address indexed from,\n', '        uint256 tokens,\n', '        uint256 totalTokenSent,\n', '        uint256 timeStamp,\n', '        uint256 transferNonce,\n', '        bytes32 indexed transferHash\n', '    );\n', '    event TrustlessWithdrawFromSideChain(address indexed from, uint256 tokens);\n', '    event OperatorChainTransfer(address indexed from, uint256 tokens, bytes32 sidechainTransactionHash);\n', '    event ClaimFailedTransferToSidechain(address indexed from, uint256 tokens);\n', '    event PositionRecoveryFromSideChain(address indexed from, bytes32 positionHash);\n', '    event TokenRecoveryFromSideChain(address indexed from, bytes32 positionHash);\n', '    event SideChainMerkleRootUpdated(bytes32 _rootHash);\n', '    event WithdrawLimitReset();\n', '    event WithdrawLimitChanged(uint256 _withdrawLimit);\n', '    event WithdrawLimitDailyChanged(uint256 _oldLimit, uint256 _newLimit);\n', '    event WithdrawLimitMonthlyChanged(uint256 _oldLimit, uint256 _newLimit);\n', '    event LinkState(address _address);\n', '\n', '    constructor(address _stateAddress, address _coldStorageOwnerAddress) public {\n', '        setMorpherState(_stateAddress);\n', '        transferOwnership(_coldStorageOwnerAddress);\n', '    }\n', '\n', '    modifier onlySideChainOperator {\n', '        require(msg.sender == state.getSideChainOperator(), "MorpherBridge: Function can only be called by Sidechain Operator.");\n', '        _;\n', '    }\n', '\n', '    modifier sideChainInactive {\n', '        require(now - state.inactivityPeriod() > state.getSideChainMerkleRootWrittenAtTime(), "MorpherBridge: Function can only be called if sidechain is inactive.");\n', '        _;\n', '    }\n', '    \n', '    modifier fastTransfers {\n', '        require(state.fastTransfersEnabled() == true, "MorpherBridge: Fast transfers have been disabled permanently.");\n', '        _;\n', '    }\n', '\n', '    modifier onlyMainchain {\n', '        require(state.mainChain() == true, "MorpherBridge: Function can only be executed on Ethereum." );\n', '        _;\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Links Token Contract with State\n', '    // ------------------------------------------------------------------------\n', '    function setMorpherState(address _stateAddress) public onlyOwner {\n', '        state = IMorpherState(_stateAddress);\n', '        emit LinkState(_stateAddress);\n', '    }\n', '\n', '    function setInactivityPeriod(uint256 _periodInSeconds) private {\n', '        state.setInactivityPeriod(_periodInSeconds);\n', '    }\n', '\n', '    function disableFastTransfers() public onlyOwner  {\n', '        state.disableFastWithdraws();\n', '    }\n', '\n', '    function updateSideChainMerkleRoot(bytes32 _rootHash) public onlySideChainOperator {\n', '        state.setSideChainMerkleRoot(_rootHash);\n', '        emit SideChainMerkleRootUpdated(_rootHash);\n', '    }\n', '\n', '    function resetLast24HoursAmountWithdrawn() public onlySideChainOperator {\n', '        state.resetLast24HoursAmountWithdrawn();\n', '        emit WithdrawLimitReset();\n', '    }\n', '\n', '    function set24HourWithdrawLimit(uint256 _withdrawLimit) public onlySideChainOperator {\n', '        state.set24HourWithdrawLimit(_withdrawLimit);\n', '        emit WithdrawLimitChanged(_withdrawLimit);\n', '    }\n', '\n', '    function updateWithdrawLimitDaily(uint256 _withdrawLimit) public onlySideChainOperator {\n', '        emit WithdrawLimitDailyChanged(withdrawalLimitDaily, _withdrawLimit);\n', '        withdrawalLimitDaily = _withdrawLimit;\n', '    }\n', '\n', '    function updateWithdrawLimitMonthly(uint256 _withdrawLimit) public onlySideChainOperator {\n', '        emit WithdrawLimitMonthlyChanged(withdrawalLimitMonthly, _withdrawLimit);\n', '        withdrawalLimitMonthly = _withdrawLimit;\n', '    }\n', '\n', '    function getTokenSentToLinkedChain(address _address) public view returns (uint256 _token) {\n', '        return state.getTokenSentToLinkedChain(_address);\n', '    }\n', '\n', '    function getTokenClaimedOnThisChain(address _address) public view returns (uint256 _token)  {\n', '        return state.getTokenClaimedOnThisChain(_address);\n', '    }\n', '\n', '    function getTokenSentToLinkedChainTime(address _address) public view returns (uint256 _time)  {\n', '        return state.getTokenSentToLinkedChainTime(_address);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // verifyWithdrawOk(uint256 _amount)\n', '    // Checks if creating _amount token on main chain does not violate the 24 hour transfer limit\n', '    // ------------------------------------------------------------------------\n', '    function verifyWithdrawOk(uint256 _amount) public returns (bool _authorized) {\n', '        uint256 _lastWithdrawLimitReductionTime = state.lastWithdrawLimitReductionTime();\n', '        uint256 _withdrawLimit24Hours = state.withdrawLimit24Hours();\n', '        \n', '        if (now > _lastWithdrawLimitReductionTime) {\n', '            uint256 _timePassed = now.sub(_lastWithdrawLimitReductionTime);\n', '            state.update24HoursWithdrawLimit(_timePassed.mul(_withdrawLimit24Hours).div(1 days));\n', '        }\n', '        \n', '        if (state.last24HoursAmountWithdrawn().add(_amount) <= _withdrawLimit24Hours) {\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function isNotDailyLimitExceeding(uint256 _amount) public view returns(bool) {\n', '        return (withdrawalPerDay[msg.sender][block.timestamp / 1 days].add(_amount) <= withdrawalLimitDaily);\n', '    }\n', '    function isNotMonthlyLimitExceeding(uint256 _amount) public view returns(bool) {\n', '        return (withdrawalPerMonth[msg.sender][block.timestamp / 30 days].add(_amount) <= withdrawalLimitMonthly);\n', '    }\n', '\n', '    function verifyUpdateDailyLimit(uint256 _amount) public {\n', '        require(isNotDailyLimitExceeding(_amount), "MorpherBridge: Withdrawal Amount exceeds daily limit");\n', '        withdrawalPerDay[msg.sender][block.timestamp / 1 days] = withdrawalPerDay[msg.sender][block.timestamp / 1 days].add(_amount);\n', '    }\n', '\n', '    function verifyUpdateMonthlyLimit(uint256 _amount) public {\n', '        require(isNotMonthlyLimitExceeding(_amount), "MorpherBridge: Withdrawal Amount exceeds monthly limit");\n', '        withdrawalPerMonth[msg.sender][block.timestamp / 30 days] = withdrawalPerMonth[msg.sender][block.timestamp / 30 days].add(_amount);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // transferToSideChain(uint256 _tokens)\n', "    // Transfer token to Morpher's side chain to trade without fees and near instant\n", '    // settlement.\n', "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are not supported\n', '    // Token are burned on the main chain and are created and credited to msg.sender\n', '    //  on the side chain\n', '    // ------------------------------------------------------------------------\n', '    function transferToSideChain(uint256 _tokens) public {\n', '        require(_tokens >= 0, "MorpherBridge: Amount of tokens must be positive.");\n', '        require(state.balanceOf(msg.sender) >= _tokens, "MorpherBridge: Insufficient balance.");\n', '        state.burn(msg.sender, _tokens);\n', '        uint256 _newTokenSentToLinkedChain = getTokenSentToLinkedChain(msg.sender).add(_tokens);\n', '        uint256 _transferNonce = state.getBridgeNonce();\n', '        uint256 _timeStamp = now;\n', '        bytes32 _transferHash = keccak256(\n', '            abi.encodePacked(\n', '                msg.sender,\n', '                _tokens,\n', '                _newTokenSentToLinkedChain,\n', '                _timeStamp,\n', '                _transferNonce\n', '            )\n', '        );\n', '        state.setTokenSentToLinkedChain(msg.sender, _newTokenSentToLinkedChain);\n', '        emit TransferToLinkedChain(msg.sender, _tokens, _newTokenSentToLinkedChain, _timeStamp, _transferNonce, _transferHash);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // fastTransferFromSideChain(uint256 _numOfToken, uint256 _tokenBurnedOnLinkedChain, bytes32[] memory _proof)\n', '    // The sidechain operator can credit users with token they burend on the sidechain. Transfers\n', '    // happen immediately. To be removed after Beta.\n', '    // ------------------------------------------------------------------------\n', '    function fastTransferFromSideChain(address _address, uint256 _numOfToken, uint256 _tokenBurnedOnLinkedChain, bytes32 _sidechainTransactionHash) public onlySideChainOperator fastTransfers {\n', '        uint256 _tokenClaimed = state.getTokenClaimedOnThisChain(_address);\n', '        require(verifyWithdrawOk(_numOfToken), "MorpherBridge: Withdraw amount exceeds permitted 24 hour limit. Please try again in a few hours.");\n', '        require(_tokenClaimed.add(_numOfToken) <= _tokenBurnedOnLinkedChain, "MorpherBridge: Token amount exceeds token deleted on linked chain.");\n', '        _chainTransfer(_address, _tokenClaimed, _numOfToken);\n', '        emit OperatorChainTransfer(_address, _numOfToken, _sidechainTransactionHash);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // trustlessTransferFromSideChain(uint256 _numOfToken, uint256 _claimLimit, bytes32[] memory _proof)\n', '    // Performs a merkle proof on the number of token that have been burned by the user on the side chain.\n', '    // If the number of token claimed on the main chain is less than the number of burned token on the side chain\n', '    // the difference (or less) can be claimed on the main chain.\n', '    // ------------------------------------------------------------------------\n', '    function trustlessTransferFromLinkedChain(uint256 _numOfToken, uint256 _claimLimit, bytes32[] memory _proof) public {\n', '        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _claimLimit));\n', '        uint256 _tokenClaimed = state.getTokenClaimedOnThisChain(msg.sender);        \n', '        require(mProof(_proof, leaf), "MorpherBridge: Merkle Proof failed. Please make sure you entered the correct claim limit.");\n', '        require(verifyWithdrawOk(_numOfToken), "MorpherBridge: Withdraw amount exceeds permitted 24 hour limit. Please try again in a few hours.");\n', '        verifyUpdateDailyLimit(_numOfToken);\n', '        verifyUpdateMonthlyLimit(_numOfToken);\n', '        require(_tokenClaimed.add(_numOfToken) <= _claimLimit, "MorpherBridge: Token amount exceeds token deleted on linked chain.");     \n', '        _chainTransfer(msg.sender, _tokenClaimed, _numOfToken);   \n', '        emit TrustlessWithdrawFromSideChain(msg.sender, _numOfToken);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // _chainTransfer(address _address, uint256 _tokenClaimed, uint256 _numOfToken)\n', '    // Creates token on the chain for the user after proving their distruction on the \n', '    // linked chain has been proven before \n', '    // ------------------------------------------------------------------------\n', '    function _chainTransfer(address _address, uint256 _tokenClaimed, uint256 _numOfToken) private {\n', '        state.setTokenClaimedOnThisChain(_address, _tokenClaimed.add(_numOfToken));\n', '        state.add24HoursWithdrawn(_numOfToken);\n', '        state.mint(_address, _numOfToken);\n', '    }\n', '        \n', '    // ------------------------------------------------------------------------\n', '    // claimFailedTransferToSidechain(uint256 _wrongSideChainBalance, bytes32[] memory _proof)\n', '    // If token sent to side chain were not credited to the user on the side chain within inactivityPeriod\n', '    // they can reclaim the token on the main chain by submitting the proof that their\n', '    // side chain balance is less than the number of token sent from main chain.\n', '    // ------------------------------------------------------------------------\n', '    function claimFailedTransferToSidechain(uint256 _wrongSideChainBalance, bytes32[] memory _proof) public {\n', '        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, _wrongSideChainBalance));\n', '        uint256 _tokenSentToLinkedChain = getTokenSentToLinkedChain(msg.sender);\n', '        uint256 _tokenSentToLinkedChainTime = getTokenSentToLinkedChainTime(msg.sender);\n', '        uint256 _inactivityPeriod = state.inactivityPeriod();\n', '        \n', '        require(now > _tokenSentToLinkedChainTime.add(_inactivityPeriod), "MorpherBridge: Failed deposits can only be claimed after inactivity period.");\n', '        require(_wrongSideChainBalance < _tokenSentToLinkedChain, "MorpherBridge: Other chain credit is greater equal to wrongSideChainBalance.");\n', '        require(verifyWithdrawOk(_tokenSentToLinkedChain.sub(_wrongSideChainBalance)), "MorpherBridge: Claim amount exceeds permitted 24 hour limit.");\n', '        require(mProof(_proof, leaf), "MorpherBridge: Merkle Proof failed. Enter total amount of deposits on side chain.");\n', '        \n', '        uint256 _claimAmount = _tokenSentToLinkedChain.sub(_wrongSideChainBalance);\n', '        state.setTokenSentToLinkedChain(msg.sender, _tokenSentToLinkedChain.sub(_claimAmount));\n', '        state.add24HoursWithdrawn(_claimAmount);\n', '        state.mint(msg.sender, _claimAmount);\n', '        emit ClaimFailedTransferToSidechain(msg.sender, _claimAmount);\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // recoverPositionFromSideChain(bytes32[] memory _proof, bytes32 _leaf, bytes32 _marketId, uint256 _timeStamp, uint256 _longShares, uint256 _shortShares, uint256 _meanEntryPrice, uint256 _meanEntrySpread, uint256 _meanEntryLeverage)\n', '    // Failsafe against side chain operator becoming inactive or withholding Times (Time withhold attack).\n', '    // After 72 hours of no update of the side chain merkle root users can withdraw their last recorded\n', '    // positions from side chain to main chain. Overwrites eventually existing position on main chain.\n', '    // ------------------------------------------------------------------------\n', '    function recoverPositionFromSideChain(\n', '        bytes32[] memory _proof,\n', '        bytes32 _leaf,\n', '        bytes32 _marketId,\n', '        uint256 _timeStamp,\n', '        uint256 _longShares,\n', '        uint256 _shortShares,\n', '        uint256 _meanEntryPrice,\n', '        uint256 _meanEntrySpread,\n', '        uint256 _meanEntryLeverage,\n', '        uint256 _liquidationPrice\n', '        ) public sideChainInactive onlyMainchain {\n', '        require(_leaf == state.getPositionHash(msg.sender, _marketId, _timeStamp, _longShares, _shortShares, _meanEntryPrice, _meanEntrySpread, _meanEntryLeverage, _liquidationPrice), "MorpherBridge: leaf does not equal position hash.");\n', '        require(state.getPositionClaimedOnMainChain(_leaf) == false, "MorpherBridge: Position already transferred.");\n', '        require(mProof(_proof,_leaf) == true, "MorpherBridge: Merkle proof failed.");\n', '        state.setPositionClaimedOnMainChain(_leaf);\n', '        state.setPosition(msg.sender, _marketId, _timeStamp, _longShares, _shortShares, _meanEntryPrice, _meanEntrySpread, _meanEntryLeverage, _liquidationPrice);\n', '        emit PositionRecoveryFromSideChain(msg.sender, _leaf);\n', '        // Remark: After resuming operations side chain operator has 72 hours to sync and eliminate transferred positions on side chain to avoid double spend\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // recoverTokenFromSideChain(bytes32[] memory _proof, bytes32 _leaf, bytes32 _marketId, uint256 _timeStamp, uint256 _longShares, uint256 _shortShares, uint256 _meanEntryPrice, uint256 _meanEntrySpread, uint256 _meanEntryLeverage)\n', '    // Failsafe against side chain operator becoming inactive or withholding times (time withhold attack).\n', '    // After 72 hours of no update of the side chain merkle root users can withdraw their last recorded\n', '    // token balance from side chain to main chain.\n', '    // ------------------------------------------------------------------------\n', '    function recoverTokenFromSideChain(bytes32[] memory _proof, bytes32 _leaf, uint256 _balance) public sideChainInactive onlyMainchain {\n', '        // Require side chain root hash not set on Mainchain for more than 72 hours (=3 days)\n', '        require(_leaf == state.getBalanceHash(msg.sender, _balance), "MorpherBridge: Wrong balance.");\n', '        require(state.getPositionClaimedOnMainChain(_leaf) == false, "MorpherBridge: Token already transferred.");\n', '        require(mProof(_proof,_leaf) == true, "MorpherBridge: Merkle proof failed.");\n', '        require(verifyWithdrawOk(_balance), "MorpherBridge: Withdraw amount exceeds permitted 24 hour limit.");\n', '        state.setPositionClaimedOnMainChain(_leaf);\n', '        _chainTransfer(msg.sender, state.getTokenClaimedOnThisChain(msg.sender), _balance);\n', '        emit TokenRecoveryFromSideChain(msg.sender, _leaf);\n', '        // Remark: Side chain operator must adjust side chain balances for token recoveries before restarting operations to avoid double spend\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // mProof(bytes32[] memory _proof, bytes32 _leaf)\n', '    // Computes merkle proof against the root hash of the sidechain stored in Morpher state\n', '    // ------------------------------------------------------------------------\n', '    function mProof(bytes32[] memory _proof, bytes32 _leaf) public view returns(bool _isTrue) {\n', '        return MerkleProof.verify(_proof, state.getSideChainMerkleRoot(), _leaf);\n', '    }\n', '}']