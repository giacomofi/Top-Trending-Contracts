['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-30\n', '*/\n', '\n', '// Sources flattened with hardhat v2.1.1 https://hardhat.org\n', '\n', '// File contracts/interfaces/IWETH.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '    function balanceOf(address) external view returns (uint256);\n', '    function approve(address, uint256) external;\n', '}\n', '\n', '\n', '// File contracts/v076/You_Dont_Blacklist_DELTA.sol\n', '\n', 'pragma abicoder v2;\n', '\n', 'interface IVGT {\n', '    function initialize(string memory) external;\n', '    function generateVolume() external;\n', '    function flashBorrowCaller(uint256, address) external;\n', '    function adjustBalance(address account, uint256 amount, bool isAddition) external;\n', '}\n', '\n', 'interface IFLASH_LOANER {\n', '    function initiateFlashLoan(address) external;\n', '}\n', '\n', '// A factory that creates volume generating tokens\n', 'contract You_Dont_Blacklist_DELTAV1 {\n', '\n', '    address public immutable MASTER_COPY;\n', '    IFLASH_LOANER public immutable FLASH_LOANDER_DYDX;\n', '    IWETH constant public WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '    address payable private immutable OWNER;\n', '    Token[] public allTokens;\n', '    address immutable private TRADE_GENERATOR;\n', '\n', '    struct Token {\n', '        string ticker;\n', '        address tokenAddress;\n', '    }\n', '\n', '    function numTokensGenerated() public view returns (uint256) {\n', '        return allTokens.length;\n', '    }\n', '\n', '    constructor(address flasher, address generator, address masterCopy) public {\n', '        OWNER = msg.sender;\n', '        TRADE_GENERATOR = generator;\n', '        MASTER_COPY = masterCopy;\n', '        FLASH_LOANDER_DYDX = IFLASH_LOANER(flasher);\n', '    }\n', '\n', '\n', '\n', '    function createToken(string memory symbol) public {\n', '        address newToken = address(new TokenProxy(MASTER_COPY));\n', '\n', '        IVGT(newToken).initialize(symbol);\n', '        // We flash borrow everything in dydx\n', '\n', '        FLASH_LOANDER_DYDX.initiateFlashLoan(newToken); \n', '\n', '\n', '        allTokens.push(Token({\n', '            ticker : symbol,\n', '            tokenAddress : newToken\n', '        }));\n', '\n', '    }\n', '\n', '\n', '\n', '    function destroy() public {\n', '        require(msg.sender == OWNER, "!owner");\n', '        selfdestruct(OWNER);\n', '    }\n', '\n', '}\n', '\n', '\n', '\n', '\n', '\n', 'contract TokenProxy {\n', '\n', '    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n', '    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n', '    address internal immutable MASTER_COPY;\n', '\n', '    /// @dev Constructor function sets address of master copy contract.\n', '    /// @param _masterCopy Master copy address.\n', '    constructor(address _masterCopy)\n', '        public\n', '    {\n', '        require(_masterCopy != address(0), "Invalid master copy address provided");\n', '        MASTER_COPY = _masterCopy;\n', '    }\n', '\n', '    receive () external payable virtual {\n', '        _fallback();\n', '    }\n', '\n', '    fallback () external payable virtual {\n', '        _fallback();\n', '    }\n', '\n', '    function _fallback() internal virtual {\n', '        _delegate(MASTER_COPY);\n', '    }\n', '\n', '    function _delegate(address implementation) internal virtual {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            // Copy msg.data. We take full control of memory in this inline assembly\n', '            // block because it will not return to Solidity code. We overwrite the\n', '            // Solidity scratch pad at memory position 0.\n', '            calldatacopy(0, 0, calldatasize())\n', '\n', '            // Call the implementation.\n', "            // out and outsize are 0 because we don't know the size yet.\n", '            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n', '\n', '            // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize())\n', '\n', '            switch result\n', '            // delegatecall returns 0 on error.\n', '            case 0 { revert(0, returndatasize()) }\n', '            default { return(0, returndatasize()) }\n', '        }\n', '    }\n', '}']