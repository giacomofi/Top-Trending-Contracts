['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', 'import "../interface/IERC721.sol";\n', 'import "../interface/IPToken.sol";\n', 'import "./ERC721.sol";\n', 'import "../math/UnsignedSafeMath.sol";\n', '\n', '/**\n', ' * @title Deri Protocol non-fungible position token implementation\n', ' */\n', 'contract PToken is IERC721, IPToken, ERC721 {\n', '\n', '    using UnsignedSafeMath for uint256;\n', '\n', '    // Pool address this PToken associated with\n', '    address private _pool;\n', '\n', '    // Token name\n', '    string private _name;\n', '\n', '    // Token symbol\n', '    string private _symbol;\n', '\n', '    // Total ever minted PToken\n', '    uint256 private _totalMinted;\n', '\n', '    // Total existent PToken\n', '    uint256 private _totalSupply;\n', '\n', '    // Mapping from tokenId to Position\n', '    mapping (uint256 => Position) private _tokenIdPosition;\n', '\n', '    modifier _pool_() {\n', '        require(msg.sender == _pool, "PToken: called by non-associative pool, probably the original pool has been migrated");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection\n', '     */\n', '    constructor (string memory name_, string memory symbol_, address pool_) {\n', '        require(pool_ != address(0), "PToken: construct with 0 address pool");\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '        _pool = pool_;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{setPool}\n', '     */\n', '    function setPool(address newPool) public override {\n', '        require(newPool != address(0), "PToken: setPool to 0 address");\n', '        require(msg.sender == _pool, "PToken: setPool caller is not current pool");\n', '        _pool = newPool;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{pool}\n', '     */\n', '    function pool() public view override returns (address) {\n', '        return _pool;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{name}\n', '     */\n', '    function name() public view override returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{symbol}\n', '     */\n', '    function symbol() public view override returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{totalMinted}\n', '     */\n', '    function totalMinted() public view override returns (uint256) {\n', '        return _totalMinted;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{totalSupply}\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{exists}\n', '     */\n', '    function exists(address owner) public view override returns (bool) {\n', '        return _exists(owner);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{exists}\n', '     */\n', '    function exists(uint256 tokenId) public view override returns (bool) {\n', '        return _exists(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{getPosition}\n', '     */\n', '    function getPosition(address owner) public view override returns (\n', '        int256 volume,\n', '        int256 cost,\n', '        int256 lastCumuFundingRate,\n', '        uint256 margin,\n', '        uint256 lastUpdateTimestamp\n', '    ) {\n', '        require(_exists(owner), "PToken: getPosition for nonexistent owner");\n', '        Position storage p = _tokenIdPosition[_ownerTokenId[owner]];\n', '        return (\n', '            p.volume,\n', '            p.cost,\n', '            p.lastCumuFundingRate,\n', '            p.margin,\n', '            p.lastUpdateTimestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{getPosition}\n', '     */\n', '    function getPosition(uint256 tokenId) public view override returns (\n', '        int256 volume,\n', '        int256 cost,\n', '        int256 lastCumuFundingRate,\n', '        uint256 margin,\n', '        uint256 lastUpdateTimestamp\n', '    ) {\n', '        require(_exists(tokenId), "PToken: getPosition for nonexistent tokenId");\n', '        Position storage p = _tokenIdPosition[tokenId];\n', '        return (\n', '            p.volume,\n', '            p.cost,\n', '            p.lastCumuFundingRate,\n', '            p.margin,\n', '            p.lastUpdateTimestamp\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{mint}\n', '     */\n', '    function mint(address owner, uint256 margin) public override _pool_ {\n', '        require(owner != address(0), "PToken: mint to 0 address");\n', '        require(!_exists(owner), "PToken: mint to existent owner");\n', '\n', '        _totalMinted = _totalMinted.add(1);\n', '        _totalSupply = _totalSupply.add(1);\n', '        uint256 tokenId = _totalMinted;\n', '        require(!_exists(tokenId), "PToken: mint to existent tokenId");\n', '\n', '        _ownerTokenId[owner] = tokenId;\n', '        _tokenIdOwner[tokenId] = owner;\n', '        Position storage p = _tokenIdPosition[tokenId];\n', '        p.margin = margin;\n', '\n', '        emit Transfer(address(0), owner, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{update}\n', '     */\n', '    function update(\n', '        address owner,\n', '        int256 volume,\n', '        int256 cost,\n', '        int256 lastCumuFundingRate,\n', '        uint256 margin,\n', '        uint256 lastUpdateTimestamp\n', '    ) public override _pool_\n', '    {\n', '        require(_exists(owner), "PToken: update to nonexistent owner");\n', '        Position storage p = _tokenIdPosition[_ownerTokenId[owner]];\n', '        p.volume = volume;\n', '        p.cost = cost;\n', '        p.lastCumuFundingRate = lastCumuFundingRate;\n', '        p.margin = margin;\n', '        p.lastUpdateTimestamp = lastUpdateTimestamp;\n', '\n', '        emit Update(owner, volume, cost, lastCumuFundingRate, margin, lastUpdateTimestamp);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IPToken}.{burn}\n', '     */\n', '    function burn(address owner) public override _pool_ {\n', '        require(_exists(owner), "PToken: burn nonexistent owner");\n', '        uint256 tokenId = _ownerTokenId[owner];\n', '        Position storage p = _tokenIdPosition[tokenId];\n', '        require(p.volume == 0, "PToken: burn non empty token");\n', '\n', '        _totalSupply = _totalSupply.sub(1);\n', '\n', '        // clear ownership and approvals\n', '        delete _ownerTokenId[owner];\n', '        delete _tokenIdOwner[tokenId];\n', '        delete _tokenIdPosition[tokenId];\n', '        delete _tokenIdOperator[tokenId];\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', 'import "./IERC165.sol";\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'interface IERC721 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables `operator` to manage the `tokenId` token.\n', '     */\n', '    event Approval(address indexed owner, address indexed operator, uint256 indexed tokenId);\n', '\n', '    /**\n', '     * @dev Emitted when `owner` enables or disables `operator` to manage all of its assets.\n', '     */\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of tokens in `owner`'s account.\n", '     */\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the owner of the `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the account approved for `tokenId` token.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n', '     *\n', '     * See {setApprovalForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Gives permission to `operator` to transfer `tokenId` token to another account.\n', '     * The approval is cleared when the token is transferred.\n', '     *\n', '     * Only a single account can be approved at a time, so approving the zero address\n', '     * clears previous approvals.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The caller must own the token or be an approved operator.\n', '     * - `tokenId` must exist.\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address operator, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Approve or remove `operator` as an operator for the caller.\n', '     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The `operator` cannot be the caller.\n', '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token\n', '     *   by either {approve} or {setApprovalForAll}.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first\n', '     * that contract recipients are aware of the ERC721 protocol to prevent\n', '     * tokens from being forever locked.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this token\n', '     *   by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement\n', '     *   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If the caller is not `from`, it must be approved to move this token\n', '     *   by either {approve} or {setApprovalForAll}.\n', '     * - If `to` refers to a smart contract, it must implement\n', '     *   {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', 'import "./IERC721.sol";\n', '\n', '/**\n', ' * @title Deri Protocol non-fungible position token interface\n', ' */\n', 'interface IPToken is IERC721 {\n', '\n', '    /**\n', "     * @dev Emitted when `owner`'s position is updated\n", '     */\n', '    event Update(\n', '        address indexed owner,\n', '        int256 volume,\n', '        int256 cost,\n', '        int256 lastCumuFundingRate,\n', '        uint256 margin,\n', '        uint256 lastUpdateTimestamp\n', '    );\n', '\n', '    /**\n', '     * @dev Position struct\n', '     */\n', '    struct Position {\n', '        // Position volume, long is positive and short is negative\n', '        int256 volume;\n', '        // Position cost, long position cost is positive, short position cost is negative\n', '        int256 cost;\n', '        // The last cumuFundingRate since last funding settlement for this position\n', '        // The overflow for this value is intended\n', '        int256 lastCumuFundingRate;\n', '        // Margin associated with this position\n', '        uint256 margin;\n', '        // Last timestamp this position updated\n', '        uint256 lastUpdateTimestamp;\n', '    }\n', '\n', '    /**\n', '     * @dev Set pool address of position token\n', '     * pool is the only controller of this contract\n', '     * can only be called by current pool\n', '     */\n', '    function setPool(address newPool) external;\n', '\n', '    /**\n', '     * @dev Returns address of current pool\n', '     */\n', '    function pool() external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the token collection name\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the token collection symbol\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the total number of ever minted position tokens, including those burned\n', '     */\n', '    function totalMinted() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the total number of existent position tokens\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns if `owner` owns a position token in this contract\n', '     */\n', '    function exists(address owner) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Returns if position token of `tokenId` exists\n', '     */\n', '    function exists(uint256 tokenId) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the position of owner `owner`\n', '     *\n', '     * `owner` must exist\n', '     */\n', '    function getPosition(address owner) external view returns (\n', '        int256 volume,\n', '        int256 cost,\n', '        int256 lastCumuFundingRate,\n', '        uint256 margin,\n', '        uint256 lastUpdateTimestamp\n', '    );\n', '\n', '    /**\n', '     * @dev Returns the position of token `tokenId`\n', '     *\n', '     * `tokenId` must exist\n', '     */\n', '    function getPosition(uint256 tokenId) external view returns (\n', '        int256 volume,\n', '        int256 cost,\n', '        int256 lastCumuFundingRate,\n', '        uint256 margin,\n', '        uint256 lastUpdateTimestamp\n', '    );\n', '\n', '    /**\n', '     * @dev Mint a position token for `owner` with intial margin of `margin`\n', '     *\n', '     * Can only be called by pool\n', '     * `owner` cannot be zero address\n', '     * `owner` must not exist before calling\n', '     */\n', '    function mint(address owner, uint256 margin) external;\n', '\n', '    /**\n', '     * @dev Update the position token for `owner`\n', '     *\n', '     * Can only be called by pool\n', '     * `owner` must exist\n', '     */\n', '    function update(\n', '        address owner,\n', '        int256 volume,\n', '        int256 cost,\n', '        int256 lastCumuFundingRate,\n', '        uint256 margin,\n', '        uint256 lastUpdateTimestamp\n', '    ) external;\n', '\n', '    /**\n', '     * @dev Burn the position token owned of `owner`\n', '     *\n', '     * Can only be called by pool\n', '     * `owner` must exist\n', '     */\n', '    function burn(address owner) external;\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', 'import "../interface/IERC721.sol";\n', 'import "../interface/IERC721Receiver.sol";\n', 'import "../utils/Address.sol";\n', 'import "./ERC165.sol";\n', '\n', '/**\n', ' * @dev ERC721 Non-Fungible Token Implementation\n', ' *\n', ' * Exert uniqueness of owner: one owner can only have one token\n', ' */\n', 'contract ERC721 is IERC721, ERC165 {\n', '\n', '    using Address for address;\n', '\n', '    /*\n', '     * Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     * which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '     */\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    /*\n', "     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\n", "     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\n", "     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\n", "     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\n", '     *\n', '     *     => 0x70a08231 ^ 0x6352211e ^ 0x081812fc ^ 0xe985e9c5 ^\n', '     *        0x095ea7b3 ^ 0xa22cb465 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\n', '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '\n', '    // Mapping from owner address to tokenId\n', '    // tokenId starts from 1, 0 is reserved for nonexistent token\n', '    // One owner can only own one token in this contract\n', '    mapping (address => uint256) _ownerTokenId;\n', '\n', '    // Mapping from tokenId to owner\n', '    mapping (uint256 => address) _tokenIdOwner;\n', '\n', '    // Mapping from tokenId to approved operator\n', '    mapping (uint256 => address) _tokenIdOperator;\n', '\n', '    // Mapping from owner to operator for all approval\n', '    mapping (address => mapping (address => bool)) _ownerOperator;\n', '\n', '\n', '    constructor () {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{balanceOf}\n', '     */\n', '    function balanceOf(address owner) public view override returns (uint256) {\n', '        if (_exists(owner)) {\n', '            return 1;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{ownerOf}\n', '     */\n', '    function ownerOf(uint256 tokenId) public view override returns (address) {\n', '        require(_exists(tokenId), "ERC721: ownerOf for nonexistent tokenId");\n', '        return _tokenIdOwner[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{getApproved}\n', '     */\n', '    function getApproved(uint256 tokenId) public view override returns (address) {\n', '        require(_exists(tokenId), "ERC721: getApproved for nonexistent tokenId");\n', '        return _tokenIdOperator[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{isApprovedForAll}\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n', '        require(_exists(owner), "ERC721: isApprovedForAll for nonexistent owner");\n', '        return _ownerOperator[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{approve}\n', '     */\n', '    function approve(address operator, uint256 tokenId) public override {\n', '        require(msg.sender == ownerOf(tokenId), "ERC721: approve caller is not owner");\n', '        _approve(msg.sender, operator, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{setApprovalForAll}\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) public override {\n', '        require(_exists(msg.sender), "ERC721: setApprovalForAll caller is not existent owner");\n', '        _ownerOperator[msg.sender][operator] = approved;\n', '        emit ApprovalForAll(msg.sender, operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{transferFrom}\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public override {\n', '        _validateTransfer(msg.sender, from, to, tokenId);\n', '        _transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{safeTransferFrom}\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721}.{safeTransferFrom}\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data)\n', '        public override\n', '    {\n', '        _validateTransfer(msg.sender, from, to, tokenId);\n', '        _safeTransfer(from, to, tokenId, data);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Returns if owner exists.\n', '     */\n', '    function _exists(address owner) internal view returns (bool) {\n', '        return _ownerTokenId[owner] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns if tokenId exists.\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        return _tokenIdOwner[tokenId] != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve `operator` to manage `tokenId`, owned by `owner`\n', '     *\n', '     * Validation check on parameters should be carried out before calling this function.\n', '     */\n', '    function _approve(address owner, address operator, uint256 tokenId) internal {\n', '        _tokenIdOperator[tokenId] = operator;\n', '        emit Approval(owner, operator, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Validate transferFrom parameters\n', '     */\n', '    function _validateTransfer(address operator, address from, address to, uint256 tokenId)\n', '        internal view\n', '    {\n', '        require(from == ownerOf(tokenId), "ERC721: transfer not owned token");\n', '        require(to != address(0), "ERC721: transfer to 0 address");\n', '        require(!_exists(to), "ERC721: transfer to already existent owner");\n', '        require(\n', '            operator == from || _tokenIdOperator[tokenId] == operator || _ownerOperator[from][operator],\n', '            "ERC721: transfer caller is not owner nor approved"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` from `from` to `to`.\n', '     *\n', '     * Validation check on parameters should be carried out before calling this function.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _transfer(address from, address to, uint256 tokenId) internal {\n', '        // clear previous ownership and approvals\n', '        delete _ownerTokenId[from];\n', '        delete _tokenIdOperator[tokenId];\n', '\n', '        // set up new owner\n', '        _ownerTokenId[to] = tokenId;\n', '        _tokenIdOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract\n', '     * recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * Validation check on parameters should be carried out before calling this function.\n', '     *\n', '     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n', '     *\n', '     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n', '     * implement alternative mechanisms to perform token transfer, such as signature-based.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal {\n', '        _transfer(from, to, tokenId);\n', '        require(\n', '            _checkOnERC721Received(from, to, tokenId, data),\n', '            "ERC721: transfer to non ERC721Receiver implementer"\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n', '     *      The call is not executed if the target address is not a contract.\n', '     *\n', '     * @param from address representing the previous owner of the given token ID.\n', '     * @param to target address that will receive the tokens.\n', '     * @param tokenId uint256 ID of the token to be transferred.\n', '     * @param data bytes optional data to send along with the call.\n', '     * @return bool whether the call correctly returned the expected magic value.\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\n', '            IERC721Receiver(to).onERC721Received.selector,\n', '            msg.sender,\n', '            from,\n', '            tokenId,\n', '            data\n', '        ), "ERC721: transfer to non ERC721Receiver implementer");\n', '        bytes4 retval = abi.decode(returndata, (bytes4));\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @title Unsigned safe math\n', ' */\n', 'library UnsignedSafeMath {\n', '\n', '    /**\n', '     * @dev Addition of unsigned integers, counterpart to `+`\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "UnsignedSafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtraction of unsigned integers, counterpart to `-`\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(a >= b, "UnsignedSafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplication of unsigned integers, counterpart to `*`\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero,\n", "        // but the benefit is lost if 'b' is also tested\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "UnsignedSafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Division of unsigned integers, counterpart to `/`\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "UnsignedSafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Modulo of unsigned integers, counterpart to `%`\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "UnsignedSafeMath: modulo by zero");\n', '        uint256 c = a % b;\n', '        return c;\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via\n', '     * {IERC721-safeTransferFrom} by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient,\n', '     * the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data)\n', '        external returns (bytes4);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "../interface/IERC165.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts may inherit from this and call {_registerInterface} to declare\n', ' * their support of an interface.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /*\n', "     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n", '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    /**\n', "     * @dev Mapping of interface ids to whether or not it's supported.\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () {\n', '        // Derived contracts need only register support for their own interfaces,\n', '        // we register support for ERC165 itself here\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     *\n', '     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev Registers the contract as an implementer of the interface defined by\n', '     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n', '     * registering its interface id is not required.\n', '     *\n', '     * See {IERC165-supportsInterface}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal virtual {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}']