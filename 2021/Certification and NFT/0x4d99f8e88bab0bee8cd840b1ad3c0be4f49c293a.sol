['/**\n', '* SPDX-License-Identifier: LicenseRef-Aktionariat\n', '*\n', '* MIT License with Automated License Fee Payments\n', '*\n', '* Copyright (c) 2020 Aktionariat AG (aktionariat.com)\n', '*\n', '* Permission is hereby granted to any person obtaining a copy of this software\n', '* and associated documentation files (the "Software"), to deal in the Software\n', '* without restriction, including without limitation the rights to use, copy,\n', '* modify, merge, publish, distribute, sublicense, and/or sell copies of the\n', '* Software, and to permit persons to whom the Software is furnished to do so,\n', '* subject to the following conditions:\n', '*\n', '* - The above copyright notice and this permission notice shall be included in\n', '*   all copies or substantial portions of the Software.\n', '* - All automated license fee payments integrated into this and related Software\n', '*   are preserved.\n', '*\n', '* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n', '* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n', '* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n', '* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n', '* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n', '* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n', '* SOFTWARE.\n', '*/\n', 'pragma solidity >=0.8;\n', '\n', 'import "./Address.sol";\n', 'import "./IERC20.sol";\n', 'import "./IUniswapV2.sol";\n', 'import "./ITokenReceiver.sol";\n', 'import "./Ownable.sol";\n', '\n', '/**\n', ' * A hub for payments. This allows tokens that do not support ERC 677 to enjoy similar functionality,\n', ' * namely interacting with a token-handling smart contract in one transaction, without having to set an allowance first.\n', ' * Instead, an allowance needs to be set only once, namely for this contract.\n', ' * Further, it supports automatic conversion from Ether to the payment currency through Uniswap.\n', ' */\n', 'contract PaymentHub {\n', '\n', '    // immutable variables get integrated into the bytecode at deployment time, constants at compile time\n', '    // Unlike normal variables, changing their values changes the codehash of a contract!\n', '    IUniswapV2 constant uniswap = IUniswapV2(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '    IERC20 public immutable weth; \n', '    address public immutable currency;\n', '\n', '    constructor(address currency_) {\n', '        currency = currency_;\n', '        weth = IERC20(uniswap.WETH());\n', '    }\n', '\n', '    function getPath() private view returns (address[] memory) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(weth);\n', '        path[1] = address(currency);\n', '        return path;\n', '    }\n', '\n', '    function getPriceInEther(uint256 amountOfXCHF) public view returns (uint256) {\n', '        return uniswap.getAmountsIn(amountOfXCHF, getPath())[0];\n', '    }\n', '\n', '    /**\n', '     * Convenience method to swap ether into currency and pay a target address\n', '     */\n', '    function payFromEther(address recipient, uint256 xchfamount) payable public {\n', '        uniswap.swapETHForExactTokens{value: msg.value}(xchfamount, getPath(), recipient, block.timestamp);\n', '        if (address(this).balance > 0){\n', '            payable(msg.sender).transfer(address(this).balance); // return change\n', '        }\n', '    }\n', '\n', '    function multiPay(address[] calldata recipients, uint256[] calldata amounts) public {\n', '        multiPay(currency, recipients, amounts);\n', '    }\n', '\n', '    function multiPay(address token, address[] calldata recipients, uint256[] calldata amounts) public {\n', '        for (uint i=0; i<recipients.length; i++) {\n', '            IERC20(token).transferFrom(msg.sender, recipients[i], amounts[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Can (at least in theory) save some gas as the sender balance only is touched in one transaction.\n', '     */\n', '    function multiPayAndNotify(address token, address[] calldata recipients, uint256[] calldata amounts, bytes calldata ref) public {\n', '        for (uint i=0; i<recipients.length; i++) {\n', '            payAndNotify(token, recipients[i], amounts[i], ref);\n', '        }\n', '    }\n', '\n', '/*     function approveAndCall(address token, uint256 amount, address target, bytes calldata data, uint256 weiValue) public returns (bytes memory) {\n', '        require((IERC20(token)).transferFrom(msg.sender, address(this), amount));\n', '        require((IERC20(token)).approve(target, amount));\n', '        return Address.functionCallWithValue(target, data, weiValue);\n', '    } */\n', '\n', '    // Allows to make a payment from the sender to an address given an allowance to this contract\n', '    // Equivalent to xchf.transferAndCall(recipient, xchfamount)\n', '    function payAndNotify(address recipient, uint256 xchfamount, bytes calldata ref) public {\n', '        payAndNotify(currency, recipient, xchfamount, ref);\n', '    }\n', '\n', '    function payAndNotify(address token, address recipient, uint256 amount, bytes calldata ref) public {\n', '        IERC20(token).transferFrom(msg.sender, recipient, amount);\n', '        ITokenReceiver(recipient).onTokenTransfer(token, msg.sender, amount, ref);\n', '    }\n', '\n', '    function payFromEtherAndNotify(address recipient, uint256 xchfamount, bytes calldata ref) payable public {\n', '        payFromEther(recipient, xchfamount);\n', '        ITokenReceiver(recipient).onTokenTransfer(address(currency), msg.sender, xchfamount, ref);\n', '    }\n', '\n', '    /**\n', '     * In case tokens have been accidentally sent directly to this contract.\n', '     * Make sure to be fast as anyone can call this!\n', '     */\n', '    function recover(address ercAddress, address to, uint256 amount) public {\n', '        IERC20(ercAddress).transfer(to, amount);\n', '    }\n', '\n', '}']