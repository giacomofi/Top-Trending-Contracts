['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-12\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.8.5;\n', '\n', '/**\n', ' * @title TieredCrowdfundStorage\n', ' * @author MirrorXYZ\n', ' */\n', 'contract TieredCrowdfundStorage {\n', '    // The two states that this contract can exist in. "FUNDING" allows\n', '    // contributors to add funds.\n', '    enum Status {FUNDING, TRADING}\n', '\n', '    // ============ Constants ============\n', '\n', '    // The factor by which ETH contributions will multiply into crowdfund tokens.\n', '    uint16 internal constant TOKEN_SCALE = 1000;\n', '    uint256 internal constant REENTRANCY_NOT_ENTERED = 1;\n', '    uint256 internal constant REENTRANCY_ENTERED = 2;\n', '    uint8 public constant decimals = 18;\n', '\n', '    // ============ Immutable Storage ============\n', '\n', '    // The operator has a special role to change contract status.\n', '    address payable public operator;\n', '    address payable public fundingRecipient;\n', '    // We add a hard cap to prevent raising more funds than deemed reasonable.\n', '    uint256 public fundingCap;\n', '    // The operator takes some equity in the tokens, represented by this percent.\n', '    uint256 public operatorPercent;\n', '    string public symbol;\n', '    string public name;\n', '\n', '    // ============ Mutable Storage ============\n', '\n', '    // Represents the current state of the campaign.\n', '    Status public status;\n', '    uint256 internal reentrancy_status;\n', '\n', '    // ============ Mutable ERC20 Attributes ============\n', '\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) public balanceOf;\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    mapping(address => uint256) public nonces;\n', '\n', '    // ============ Delegation logic ============\n', '    address public logic;\n', '\n', '    // ============ Tiered Campaigns ============\n', '    // Address of the editions contract to purchase from.\n', '    address public editions;\n', '}\n', '\n', '\n', '// File contracts/interface/ICrowdfundEditions.sol\n', '\n', '\n', 'interface ICrowdfundEditions {\n', '    struct Edition {\n', '        // The maximum number of tokens that can be sold.\n', '        uint256 quantity;\n', '        // The price at which each token will be sold, in ETH.\n', '        uint256 price;\n', '        // The account that will receive sales revenue.\n', '        address payable fundingRecipient;\n', '        // The number of tokens sold so far.\n', '        uint256 numSold;\n', '        bytes32 contentHash;\n', '    }\n', '\n', '    struct EditionTier {\n', '        // The maximum number of tokens that can be sold.\n', '        uint256 quantity;\n', '        // The price at which each token will be sold, in ETH.\n', '        uint256 price;\n', '        bytes32 contentHash;\n', '    }\n', '\n', '    function buyEdition(uint256 editionId, address recipient)\n', '        external\n', '        payable\n', '        returns (uint256 tokenId);\n', '\n', '    function editionPrice(uint256 editionId) external view returns (uint256);\n', '\n', '    function createEditions(\n', '        EditionTier[] memory tier,\n', '        // The account that should receive the revenue.\n', '        address payable fundingRecipient,\n', '        address minter\n', '    ) external;\n', '\n', '    function contractURI() external view returns (string memory);\n', '}\n', '\n', '\n', '// File contracts/TieredCrowdfundLogic.sol\n', '\n', '\n', '\n', '/**\n', ' * @title TieredCrowdfundLogic\n', ' * @author MirrorXYZ\n', ' *\n', ' * Crowdfund the creation of NFTs by issuing ERC20 tokens that\n', ' * can be redeemed for the underlying value of the NFT once sold.\n', ' */\n', 'contract TieredCrowdfundLogic is TieredCrowdfundStorage {\n', '    // ============ Events ============\n', '\n', '    event ReceivedERC721(uint256 tokenId, address sender);\n', '    event Contribution(address contributor, uint256 amount);\n', '    event ContributionForEdition(\n', '        address contributor,\n', '        uint256 amount,\n', '        uint256 editionId,\n', '        uint256 tokenId\n', '    );\n', '\n', '    event FundingClosed(uint256 amountRaised, uint256 creatorAllocation);\n', '    event BidAccepted(uint256 amount);\n', '    event Redeemed(address contributor, uint256 amount);\n', '    // ERC20 Events\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(\n', '        address indexed owner,\n', '        address indexed spender,\n', '        uint256 value\n', '    );\n', '\n', '    // ============ Modifiers ============\n', '\n', '    /**\n', '     * @dev Modifier to check whether the `msg.sender` is the operator.\n', '     * If it is, it will run the function. Otherwise, it will revert.\n', '     */\n', '    modifier onlyOperator() {\n', '        require(msg.sender == operator);\n', '        _;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(reentrancy_status != REENTRANCY_ENTERED, "Reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        reentrancy_status = REENTRANCY_ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        reentrancy_status = REENTRANCY_NOT_ENTERED;\n', '    }\n', '\n', '    // ============ Crowdfunding Methods ============\n', '\n', '    /**\n', '     * @notice Mints tokens for the sender propotional to the\n', '     *  amount of ETH sent in the transaction.\n', '     * @dev Emits the Contribution event.\n', '     */\n', '    function contribute(\n', '        address payable backer,\n', '        uint256 editionId,\n', '        uint256 amount\n', '    ) external payable nonReentrant {\n', '        require(status == Status.FUNDING, "Crowdfund: Funding must be open");\n', '        require(amount == msg.value, "Crowdfund: Amount is not value sent");\n', '        // This first case is the happy path, so we will keep it efficient.\n', '        // The balance, which includes the current contribution, is less than or equal to cap.\n', '        if (address(this).balance <= fundingCap) {\n', '            // Mint equity for the contributor.\n', '            _mint(backer, valueToTokens(amount));\n', '\n', '            // Editions start at 1, so a "0" edition means the user wants to contribute without\n', '            // purchasing a token.\n', '            if (editionId > 0) {\n', '                emit ContributionForEdition(\n', '                    backer,\n', '                    amount,\n', '                    editionId,\n', '                    buyEdition(amount, editionId, backer)\n', '                );\n', '            } else {\n', '                emit Contribution(backer, amount);\n', '            }\n', '        } else {\n', '            // Compute the balance of the crowdfund before the contribution was made.\n', '            uint256 startAmount = address(this).balance - amount;\n', '            // If that amount was already greater than the funding cap, then we should revert immediately.\n', '            require(\n', '                startAmount < fundingCap,\n', '                "Crowdfund: Funding cap already reached"\n', '            );\n', '            // Otherwise, the contribution helped us reach the funding cap. We should\n', '            // take what we can until the funding cap is reached, and refund the rest.\n', '            uint256 eligibleAmount = fundingCap - startAmount;\n', '            // Otherwise, we process the contribution as if it were the minimal amount.\n', '            _mint(backer, valueToTokens(eligibleAmount));\n', '\n', '            if (editionId > 0) {\n', '                emit ContributionForEdition(\n', '                    backer,\n', '                    eligibleAmount,\n', '                    editionId,\n', '                    // Attempt to purchase edition with eligible amount.\n', '                    buyEdition(eligibleAmount, editionId, backer)\n', '                );\n', '            } else {\n', '                emit Contribution(backer, eligibleAmount);\n', '            }\n', '            // Refund the sender with their contribution (e.g. 2.5 minus the diff - e.g. 1.5 = 1 ETH)\n', '            sendValue(backer, amount - eligibleAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @notice Burns the sender's tokens and redeems underlying ETH.\n", '     * @dev Emits the Redeemed event.\n', '     */\n', '    function redeem(uint256 tokenAmount) external nonReentrant {\n', '        // Prevent backers from accidently redeeming when balance is 0.\n', '        require(\n', '            address(this).balance > 0,\n', '            "Crowdfund: No ETH available to redeem"\n', '        );\n', '        // Check\n', '        require(\n', '            balanceOf[msg.sender] >= tokenAmount,\n', '            "Crowdfund: Insufficient balance"\n', '        );\n', '        require(status == Status.TRADING, "Crowdfund: Funding must be trading");\n', '        // Effect\n', '        uint256 redeemable = redeemableFromTokens(tokenAmount);\n', '        _burn(msg.sender, tokenAmount);\n', '        // Safe version of transfer.\n', '        sendValue(payable(msg.sender), redeemable);\n', '        emit Redeemed(msg.sender, redeemable);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the amount of ETH that is redeemable for tokenAmount.\n', '     */\n', '    function redeemableFromTokens(uint256 tokenAmount)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return (tokenAmount * address(this).balance) / totalSupply;\n', '    }\n', '\n', '    function valueToTokens(uint256 value) public pure returns (uint256 tokens) {\n', '        tokens = value * TOKEN_SCALE;\n', '    }\n', '\n', '    function tokensToValue(uint256 tokenAmount)\n', '        internal\n', '        pure\n', '        returns (uint256 value)\n', '    {\n', '        value = tokenAmount / TOKEN_SCALE;\n', '    }\n', '\n', '    // ============ Operator Methods ============\n', '\n', '    /**\n', '     * @notice Transfers all funds to operator, and mints tokens for the operator.\n', '     *  Updates status to TRADING.\n', '     * @dev Emits the FundingClosed event.\n', '     */\n', '    function closeFunding() external onlyOperator nonReentrant {\n', '        require(status == Status.FUNDING, "Crowdfund: Funding must be open");\n', '        // Close funding status, move to tradable.\n', '        status = Status.TRADING;\n', '        // Mint the operator a percent of the total supply.\n', '        uint256 operatorTokens =\n', '            (operatorPercent * totalSupply) / (100 - operatorPercent);\n', '        _mint(operator, operatorTokens);\n', '        // Announce that funding has been closed.\n', '        emit FundingClosed(address(this).balance, operatorTokens);\n', '        // Transfer all funds to the fundingRecipient.\n', '        sendValue(fundingRecipient, address(this).balance);\n', '    }\n', '\n', '    // ============ Utility Methods ============\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(\n', '            address(this).balance >= amount,\n', '            "Address: insufficient balance"\n', '        );\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{value: amount}("");\n', '        require(\n', '            success,\n', '            "Address: unable to send value, recipient may have reverted"\n', '        );\n', '    }\n', '\n', '    // ============ ERC20 Spec ============\n', '\n', '    function _mint(address to, uint256 value) internal {\n', '        totalSupply = totalSupply + value;\n', '        balanceOf[to] = balanceOf[to] + value;\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint256 value) internal {\n', '        balanceOf[from] = balanceOf[from] - value;\n', '        totalSupply = totalSupply - value;\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 value\n', '    ) private {\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) private {\n', '        balanceOf[from] = balanceOf[from] - value;\n', '        balanceOf[to] = balanceOf[to] + value;\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint256 value) external returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint256 value) external returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool) {\n', '        allowance[from][msg.sender] = allowance[from][msg.sender] - value;\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    // ============ Tiered Campaigns ============\n', '\n', '    function buyEdition(\n', '        uint256 amount,\n', '        uint256 editionId,\n', '        address recipient\n', '    ) internal returns (uint256) {\n', '        // Check that the sender is paying the correct amount.\n', '        require(\n', '            amount >= ICrowdfundEditions(editions).editionPrice(editionId),\n', '            "Unable purchase edition with available amount"\n', '        );\n', "        // We don't need to transfer the value to the NFT contract here,\n", '        // since that contract trusts this one to check before minting.\n', '        // I.E. this contract has minting privileges.\n', '        return ICrowdfundEditions(editions).buyEdition(editionId, recipient);\n', '    }\n', '}']