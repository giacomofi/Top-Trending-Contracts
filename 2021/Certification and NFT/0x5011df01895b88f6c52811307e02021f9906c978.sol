['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', '// SPDX-License-Identifier: Solid-contract\n', '\n', 'pragma solidity >=0.7.6;\n', '\n', '/*\t\t   @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@                  \n', '                 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@               \n', '               @@@@,@@@                                    @@@@@@@@             \n', '             @@@@[email\xa0protected]@@                                  @@[email\xa0protected]@@@            \n', '            @@@@[email\xa0protected]@@                               @@@[email\xa0protected]@@@          \n', '           @@@@[email\xa0protected]@@,                            @@@[email\xa0protected]@@@         \n', '          @@@@[email\xa0protected]@@                          @@@[email\xa0protected]@@%        \n', '         @@@@[email\xa0protected]@@                        @@[email\xa0protected]@@@        \n', '         @@@@[email\xa0protected]@@                     &@@[email\xa0protected]@@*       \n', '         @@@[email\xa0protected]@@.                  @@@[email\xa0protected]@@@       \n', '         @@@[email\xa0protected]@@@@@@@@@@@@@@@@@@@@@[email\xa0protected]@@@       \n', '         @@@@[email\xa0protected]@@@@@@@@@@@@@@@@@@[email\xa0protected]@@.       \n', '         @@@@[email\xa0protected]@@///////////@@@[email\xa0protected]@@@        \n', '          @@@@[email\xa0protected]@@/////////@@@[email\xa0protected]@@         \n', '           @@@@[email\xa0protected]@@//////@@@[email\xa0protected]@@@         \n', '            @@@@[email\xa0protected]@@////@@,...................&@@@@          \n', '             @@@@%[email\xa0protected]@@/&@@[email\xa0protected]@@@            \n', '               @@@@([email\xa0protected]@@@@[email\xa0protected]@@@@             \n', '                 @@@@@.................,@@[email\xa0protected]@@@@@               \n', '                   @@@@@@[email\xa0protected]@@@@@                  \n', '                      @@@@@@@@.....................%@@@@@@@                     \n', '                          [email\xa0protected]@@@@@@@@@@@@@@@@@@@@@@@@@@@                         \n', '                                 *@@@@@@@@@@@@@@                                \n', '                                                                                \n', '                                                                                */\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event ApprovalEth(address indexed owner, address indexed spender, uint value);\n', '    event ApprovalMulti(address indexed tokenID,address indexed owner, address indexed spender, uint value);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '    event TransferEth(address indexed from, address indexed to, uint value);\n', '    event TransferMulti(address indexed tokenID,address indexed from, address indexed to, uint value);\n', '    \n', '    event SellRewardEth(uint amount);\n', '    event SellRewardMulti(address indexed tokenID,uint amount);\n', '        \n', '    event SellRewardEthWithTeam(uint amount);\n', '    event SellRewardMultiWithTeam(address indexed tokenID,uint amount);\n', '    \n', '    event ResetRewardEth(address indexed to,uint k_reward_accumulated);\n', '    event ResetRewardMulti(address indexed to,address indexed tokenID,uint k_reward_accumulated);\n', '    \n', '    event BurnOnSellEth(address indexed to,uint transfer_amount);\n', '    event BurnOnSellMulti(address indexed tokenID,address indexed to,uint transfer_amount);\n', '    \n', '    event MintOnBuyEth(address indexed to,uint transfer_amount);\n', '    event MintOnBuyMulti(address indexed tokenID,address indexed to,uint transfer_amount);\n', '    \n', '    event StakeEth(address indexed to,uint stake_amount);\n', '    event StakeMulti(address indexed tokenID,address indexed to,uint stake_amount);\n', '    \n', '    event UnstakeEth(address indexed from,uint unstake_amount);\n', '    event UnstakeMulti(address indexed tokenID,address indexed from,uint unstake_amount);\n', '    \n', '    event ClaimTeamFeeEth(uint transfer_amount);\n', '    event ClaimTeamFeeMulti(address indexed tokenID,uint transfer_amount);\n', '    \n', '    event ClaimRewardEth(address indexed to);\n', '    event ClaimRewardMulti(address indexed tokenID,address indexed to);\n', '    \n', '    event ChangeFeeStatus(bool value, string input,bytes32 next);\n', '    event ChangeTeamAddress(address indexed to,string input,bytes32 next);\n', '    \n', '    event CheckTeamAddressUpdate(address indexed to, string input,bytes32 next);\n', '    event RecoverTeamAddresshash(string input,bytes32 next,bytes32 hash);\n', '    event Set_DOMAIN_SEPARATOR_Multi(address indexed tokenID);\n', '    \n', '    event ClaimTeamSolid();\n', '    event SolidTransfer(address indexed tokenID,address indexed from,address indexed to,uint amount);\n', '    event SolidPermit(address indexed tokenID, address indexed owner, address indexed spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s);\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    \n', '    function totalSupply() external view returns (uint);\n', '    function totalSupply_eth() external view returns (uint);\n', '    function totalSupply_multi(address tokenID) external view returns (uint);\n', '\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function balanceOf_eth(address owner) external view returns (uint);\n', '    function balanceOf_multi(address tokenID,address owner) external view returns (uint);\n', '    \n', '    function allowance(address owner, address spender) external view returns (uint);\n', '    function allowance_eth(address owner, address spender) external view returns (uint);\n', '    function allowance_multi(address tokenID,address owner, address spender) external view returns (uint);\n', '    \n', '    function reward_eth(address owner) external view returns (uint);\n', '    function reward_multi(address tokenID,address owner) external view returns (uint);\n', '    \n', '    function approve(address spender, uint value) external returns (bool);\n', '    function approveEth(address spender, uint value) external returns (bool);\n', '    function approveMulti(address tokenID,address spender, uint value) external returns (bool);\n', '    \n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferEth(address to, uint value) external returns (bool);\n', '    function transferMulti(address tokenID,address to, uint value) external returns (bool);\n', '    \n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '    function transferFromEth(address from, address to, uint value) external returns (bool);\n', '    function transferFromMulti(address tokenID,address from, address to, uint value) external returns (bool);\n', '    \n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '    function permitEth(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '    function permitMulti(address tokenID,address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '    \n', '    function team_accumuluated_eth() external view returns (uint);\n', '    function team_accumuluated_multi(address tokenID) external view returns (uint);\n', '    \n', '    function k_reward_accumulated_eth() external view returns (uint);\n', '    function k_reward_accumulated_multi(address tokenID) external view returns (uint);\n', '    \n', '    function reward_in_pool_eth() external view returns (uint);\n', '    function reward_in_pool_multi(address tokenID) external view returns (uint);\n', '    \n', '    function last_A_volume_eth() external view returns (uint);\n', '    function last_A_volume_multi(address tokenID) external view returns (uint);\n', '    \n', '    function last_timestamp_eth() external view returns (uint);\n', '    function last_timestamp_multi(address tokenID) external view returns (uint);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function DOMAIN_SEPARATOR_eth() external view returns (bytes32);\n', '    function DOMAIN_SEPARATOR_multi(address tokenID) external view returns (bytes32);\n', '    \n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    \n', '    function nonces(address owner) external view returns (uint);\n', '    function nonces_eth(address owner) external view returns (uint);\n', '    function nonces_multi(address tokenID,address owner) external view returns (uint);\n', '\n', '}\n', '\n', 'library SafeMath{\n', '    function add(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'ds-math-add-overflow_256');\n", '    }\n', '    \n', '    function sub(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'ds-math-sub-underflow_256');\n", '    }\n', '\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow_256');\n", '    }\n', '   \n', '    function div(uint x, uint y) internal pure returns (uint z) {\n', '        if (y!=0){\n', '           z = x / y;\n', '        }else{\n', '        z = 0;\n', '        }\n', '    }\n', '}\n', '\n', 'library Math {\n', '\n', '    function calculate_leading_zero(uint x) pure internal returns(uint) {\n', '        uint n = 256;\n', '        uint256 y;\n', '        y = x >> 128; if (y != 0) { n = n - 128; x = y; }\n', '        y = x >> 64; if (y != 0) { n = n - 64; x = y; }\n', '        y = x >> 32; if (y != 0) { n = n - 32; x = y; }\n', '        y = x >> 16; if (y != 0) { n = n - 16; x = y; }\n', '        y = x >> 8; if (y != 0) { n = n - 8; x = y; }\n', '        y = x >> 4; if (y != 0) { n = n - 4; x = y; }\n', '        y = x >> 2; if (y != 0) { n = n - 2; x = y; }\n', '        y = x >> 1; if (y != 0) return n - 2;\n', '        return n - x;\n', '    }\n', '    \n', '    // cubic\n', '    function cubic(uint x) pure internal returns(uint) {\n', '        uint256 r0 = 1;\n', '        uint256 r1;\n', '\n', '        //IEEE-754 cbrt *may* not be exact. \n', '\n', '        if (x == 0) // cbrt(0) : \n', '            return (0);\n', '\n', '        uint256 b = (256) - calculate_leading_zero(x);\n', '        r0 <<= (b + 2) / 3; // ceil(b / 3)\n', '\n', '        do // quadratic convergence: \n', '        {\n', '            r1 = r0;\n', '            r0 = (2 * r1 + x / (r1 * r1)) / 3;\n', '        }\n', '        while (r0 < r1);\n', '\n', '        return uint96 (r1); // floor(cbrt(x)); \n', '    }\n', '    \n', '    \n', '    \n', '    function sqrt (uint256 x) internal pure returns (uint128) {\n', '        if (x == 0) return 0;\n', '        else{\n', '            uint256 xx = x;\n', '            uint256 r = 1;\n', '            if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n', '            if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n', '            if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n', '            if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n', '            if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n', '            if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n', '            if (xx >= 0x8) { r <<= 1; }\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1;\n', '            r = (r + x / r) >> 1; // Seven iterations should be enough\n', '            uint256 r1 = x / r;\n', '            return uint128 (r < r1 ? r : r1);\n', '        }\n', '  }\n', ' \n', '    \n', '}\n', '\n', '\n', '\n', 'contract SolidFactory is IERC20{\n', '    using SafeMath for uint;\n', '    using SafeMath for uint128;\n', '    \n', '    uint public override team_accumuluated_eth;\n', '    mapping(address => uint) public override team_accumuluated_multi;\n', '    \n', '    uint public override k_reward_accumulated_eth;\n', '    mapping(address => uint) public override k_reward_accumulated_multi;\n', '    \n', '    uint public override reward_in_pool_eth;\n', '    mapping(address => uint) public override reward_in_pool_multi;\n', '    \n', '    uint public override last_A_volume_eth;\n', '    mapping(address => uint) public override last_A_volume_multi;\n', '     \n', '    uint public override last_timestamp_eth;\n', '    mapping(address => uint) public override last_timestamp_multi;\n', '    \n', "    string public override constant name = 'Solid';\n", "    string public override constant symbol = 'Solid';\n", '    uint8 public override constant decimals = 18;\n', '    \n', '    mapping(address => uint) public override reward_eth;\n', '    mapping(address => mapping(address => uint)) public override reward_multi;\n', '    \n', '    mapping(address => uint) public override balanceOf;\n', '    mapping(address => uint) public override balanceOf_eth;\n', '    mapping(address => mapping(address => uint)) public override balanceOf_multi;\n', '    \n', '    mapping(address => mapping (address => uint)) public override allowance;\n', '    mapping(address => mapping (address => uint)) public override allowance_eth;\n', '    mapping(address => mapping (address => mapping(address => uint))) public override allowance_multi;\n', '    \n', '    bytes32 public override DOMAIN_SEPARATOR;\n', '    bytes32 public override DOMAIN_SEPARATOR_eth;\n', '    mapping(address => bytes32) public override DOMAIN_SEPARATOR_multi;\n', '    \n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public override constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    \n', '    mapping(address => uint) public override nonces;\n', '    mapping(address => uint) public override nonces_eth;\n', '    mapping(address => mapping(address => uint)) public override nonces_multi;\n', '    \n', '    \n', '    uint public override totalSupply;\n', '    uint public override totalSupply_eth=10000;\n', '    mapping(address => uint) public override totalSupply_multi;\n', '    \n', '    \n', '    mapping(address => uint) public stakedBalanceOf_eth;\n', '    mapping(address => mapping(address => uint)) public stakedBalanceOf_multi;\n', '    \n', '    uint public stakedBalanceTotal_eth=10000;\n', '    mapping(address => uint) public stakedBalanceTotal_multi;\n', '    \n', '    bool public feeOn=false;\n', '    address payable public team_address=0x2B6C7F44DD5A627496A92FDB12080162e368aB1E;\n', '    address payable public team_address2=0x734241200496E2962b1e2553e5b4FeB99347E1d0;\n', '    \n', '    uint public team_address_last_update=block.timestamp;\n', '    uint public team_address2_last_update=block.timestamp;\n', '    \n', '    bytes32 public team_address_hash=0x2d099065a6fdb19f19491af2da6a20c1343fd4a361f0f5e3c3ee9c5830089f07;\n', '    bytes32 public team_address2_hash=0x17811f390c0b53824cf72860f1790e2219f448470e8e4a61ae9da075530172df;\n', '    \n', '    bytes32 public team_address_recover_hash=0xe304aa923d29816f762747dd9af1eb12a6db979a5e4b4894c28ddd3292986a6e;\n', '    bytes32 public team_address2_recover_hash=0xfffeaf54ace025ecdfd417121e996c49fe9d4c8ee5771cc72de5cb92997aa7c7;\n', '    \n', '    bytes32 public COPYRIGHT_HASH=0x01c95541db60cee620e2a69baa71ba0b8c059901aa44da15b6e3818e879e851d;\n', '    bool public lock=false;\n', '    bool public control_lock=true;\n', '    \n', '    uint public totalDocument;\n', '    uint public last_team_totalSupply;\n', '    struct document_hash{\n', '        uint id;\n', '        //document hash\n', '        bytes32 hash;\n', '        // class journals, transactions, letters, and magazine, contract\n', '        uint8 para0;\n', '        // topic class computer science/biology/chemistry\n', '        uint8 para1;\n', '        // sub class blockchain/big data\n', '        uint8 para2;\n', '        // sub-sub class algorithm-based/application-based(optional)\n', '        uint8 para3;\n', '        //reference\n', '        bytes32 para4;\n', '        //keyword relevant\n', '        bytes32 para5;\n', '    }\n', '    mapping(address => document_hash[]) public document;\n', '    mapping(uint => address) public document_id;\n', '    \n', '    constructor() public {\n', '        uint chainId;\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '        \n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', "                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n", '                keccak256(bytes(name)),\n', "                keccak256(bytes('1')),\n", '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '\n', '        \n', '        DOMAIN_SEPARATOR_eth = keccak256(\n', '            abi.encode(\n', "                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n", "                keccak256(bytes('ETH')),\n", "                keccak256(bytes('1')),\n", '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '\n', '        stakedBalanceOf_eth[team_address]=5000;\n', '        stakedBalanceOf_eth[team_address2]=5000;\n', '  \n', '    }\n', '    \n', '    function addPaper(bytes32 _paper_hash,uint8 para0, uint8 para1, uint8 para2,uint8 para3,bytes32 para4,bytes32 para5) public {\n', '        uint _totalDocument = totalDocument;\n', '        document[msg.sender].push(document_hash(_totalDocument,_paper_hash,para0,para1,para2,para3,para4,para5));\n', '        document_id[_totalDocument] = msg.sender;\n', '        totalDocument = _totalDocument.add(1);\n', '        \n', '    }\n', '    function solidAddPaper(bytes32 _paper_hash,uint8 para0, uint8 para1, uint8 para2,uint8 para3,bytes32 para4,bytes32 para5) external {\n', '        uint current_gas = gasleft();\n', '        require(msg.sender==tx.origin);\n', '        addPaper(_paper_hash, para0, para1, para2, para3, para4, para5);\n', '        current_gas = (current_gas - gasleft()+32908)*tx.gasprice;\n', '        totalSupply=totalSupply.add(current_gas);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(current_gas);\n', '    }\n', '    \n', '    \n', '    function asciiToUint(byte char) internal pure returns (uint) {\n', '        uint asciiNum = uint(uint8(char));\n', '        if (asciiNum > 47 && asciiNum < 58) {\n', '            return asciiNum - 48;\n', '        } else if (asciiNum > 96 && asciiNum < 103) {\n', '            return asciiNum - 87;\n', '        } else {\n', '            revert();\n', '        }\n', '    }\n', '\n', '    function stringToBytes32(string memory str) internal pure returns (bytes32) {\n', '        bytes memory bString = bytes(str);\n', '        uint uintString;\n', '        if (bString.length != 64) { revert(); }\n', '        for (uint i = 0; i < 64; i++) {\n', '            uintString = uintString*16 + uint(asciiToUint(bString[i]));\n', '        }\n', '        return bytes32(uintString);\n', '    }\n', '\n', '    function substring(string memory str, uint startIndex, uint endIndex) internal pure returns (string memory) {\n', '        bytes memory strBytes = bytes(str);\n', '        bytes memory result = new bytes(endIndex-startIndex);\n', '        for(uint i = startIndex; i < endIndex; i++){\n', '            result[i-startIndex] = strBytes[i];\n', '        }\n', '    \n', '        return string(result);\n', '    }\n', '    \n', '    function reverseHashChain(string memory k,bool input) external {\n', '        bytes memory temp = bytes(k);\n', '        require (msg.sender==team_address && keccak256(temp)==COPYRIGHT_HASH);\n', '        uint length = temp.length;\n', '        string memory hashstring = substring(k,length-64,length);\n', '        COPYRIGHT_HASH = stringToBytes32(hashstring);\n', '        lock=input;\n', '         \n', '     }\n', '     \n', '    function unlockUpon() external{\n', '        require (msg.sender==team_address && lock);\n', '        lock=false;\n', '        \n', '    }\n', '    \n', '    function set_DOMAIN_SEPARATOR_Multi(address tokenID) external{\n', '\n', '        require(totalSupply_multi[tokenID]==0);\n', '        uint chainId;\n', '        assembly {\n', '        chainId := chainid()\n', '        }\n', "        //string memory solid_token= string(abi.encodePacked('Solid-',IERC20(tokenID).name()));\n", '         DOMAIN_SEPARATOR_multi[tokenID] = keccak256(\n', '            abi.encode(\n', "                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n", '                keccak256(abi.encodePacked(tokenID)),\n', "                keccak256(bytes('1')),\n", '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '        totalSupply_multi[tokenID]=10000;\n', '        stakedBalanceOf_multi[tokenID][team_address]=5000;\n', '        stakedBalanceOf_multi[tokenID][team_address2]=5000;\n', '        stakedBalanceTotal_multi[tokenID]=10000;\n', '        emit Set_DOMAIN_SEPARATOR_Multi(tokenID);\n', '\n', '        \n', '    }\n', '    \n', '    function recoverTeamAddresshash(string memory input,bytes32 hash,bytes32 next) external{\n', '        if (msg.sender==team_address && keccak256(bytes(input))==team_address_recover_hash){\n', '            team_address_hash = hash;\n', '            team_address_recover_hash = next;\n', '            \n', '        }\n', '        else if(msg.sender==team_address2 && keccak256(bytes(input))==team_address2_recover_hash){\n', '            team_address2_hash = hash;\n', '            team_address2_recover_hash = next;\n', '        }\n', '        emit RecoverTeamAddresshash(input,next,hash);\n', '    }\n', '    function checkTeamAddressUpdate(address payable to, string memory input,bytes32 next) external{\n', '     \n', '        if (msg.sender==team_address && keccak256(bytes(input))==team_address_hash){\n', '            uint time_delta = block.timestamp-team_address2_last_update;\n', '            if (time_delta>63072000){\n', '                team_address2 = to;\n', '                team_address2_last_update = block.timestamp;\n', '                team_address2_hash = next;\n', '                team_address2_recover_hash = next;\n', '            }\n', '            else{\n', '                team_address_last_update = block.timestamp;\n', '            }\n', '            team_address_hash = next;\n', '        }\n', '        else if(msg.sender==team_address2 && keccak256(bytes(input))==team_address2_hash){\n', '            uint time_delta = block.timestamp-team_address_last_update;\n', '            if (time_delta>63072000){\n', '                team_address = to;\n', '                team_address_last_update = block.timestamp;\n', '                team_address_hash = next;\n', '                team_address_recover_hash = next;\n', '            }\n', '            else{\n', '                team_address2_last_update = block.timestamp;\n', '            }\n', '            team_address2_hash = next;\n', '        }\n', '      emit CheckTeamAddressUpdate(to,input,next);\n', '    }\n', '    function changeTeamAddress(address payable to, string memory input,bytes32 next) external{\n', '        if (msg.sender==team_address && keccak256(bytes(input))==team_address_hash){\n', '            team_address = to;\n', '            team_address_hash = next;\n', '        }\n', '        else if (msg.sender==team_address2 && keccak256(bytes(input))==team_address2_hash){\n', '            team_address2 = to;\n', '            team_address2_hash = next;\n', '        }\n', '        emit ChangeTeamAddress(to,input,next);\n', '    }\n', '    \n', '    \n', '    function changeFeeStatus(bool value, string memory input,bytes32 next) external{\n', '        if (msg.sender==team_address && keccak256(bytes(input))==team_address_hash){\n', '            feeOn = value;\n', '            team_address_hash = next;\n', '        }else if (msg.sender==team_address2 && keccak256(bytes(input))==team_address2_hash){\n', '            feeOn = value;\n', '            team_address2_hash = next;\n', '        }\n', '        \n', '        emit ChangeFeeStatus(value,input,next);\n', '    }\n', '    \n', '    function claimTeamSolid() external{\n', '        require((msg.sender==team_address|| msg.sender==team_address2) && !lock);\n', '        uint _totalSupply = totalSupply;\n', '        uint SupplyDelta = _totalSupply.sub(last_team_totalSupply).div(18);\n', '        balanceOf[team_address] = balanceOf[team_address].add(SupplyDelta);\n', '        balanceOf[team_address2] = balanceOf[team_address2].add(SupplyDelta);\n', '        _totalSupply = _totalSupply.add(SupplyDelta.mul(2));\n', '        last_team_totalSupply = _totalSupply;\n', '        totalSupply = _totalSupply;\n', '        emit ClaimTeamSolid();\n', '    }\n', '    function claimTeamFeeEth(uint amount) external{\n', '        require((msg.sender==team_address|| msg.sender==team_address2) && !lock);\n', '        //gas saving\n', '        team_accumuluated_eth=team_accumuluated_eth.sub(amount);\n', '        reward_in_pool_eth=reward_in_pool_eth.sub(amount);\n', '        uint half = amount.div(2);\n', '        team_address.transfer(amount.sub(half));\n', '        team_address2.transfer(half);\n', '        emit ClaimTeamFeeEth(amount);\n', '    }\n', '    \n', '    function claimTeamFeeMulti(address tokenID,uint amount) external{\n', '        require((msg.sender==team_address|| msg.sender==team_address2) && !lock);\n', '        //gas saving\n', '        team_accumuluated_multi[tokenID]=team_accumuluated_multi[tokenID].sub(amount);\n', '        reward_in_pool_multi[tokenID]=reward_in_pool_multi[tokenID].sub(amount);\n', '        uint half = amount.div(2);\n', '        IERC20(tokenID).transfer(team_address,amount.sub(half));\n', '        IERC20(tokenID).transfer(team_address2,half);\n', '        emit ClaimTeamFeeMulti(tokenID,amount);\n', '    }\n', '    \n', '    function solidWrapper(uint8 choice, address tokenID, address payable to,uint amount0,uint amount1) external payable {\n', '        uint current_gas = gasleft();\n', '        require(msg.sender==tx.origin);\n', '        if (choice==0){\n', '            mintOnBuyEth(to, amount0, amount1);\n', '        }\n', '        else if (choice==1){\n', '            mintOnBuyMulti(tokenID,to, amount0, amount1);\n', '        }\n', '        else if (choice==2){\n', '            burnOnSellEth(to, amount0, amount1);\n', '        }\n', '        else if (choice==3){\n', '            burnOnSellMulti(tokenID,to, amount0, amount1);\n', '        }\n', '        else if (choice==4){\n', '            claimRewardEth(to);\n', '        }\n', '        else if (choice==5){\n', '            claimRewardMulti(tokenID,to);\n', '        }\n', '        else if (choice==6){\n', '            stakeEth(to,amount0);\n', '        }\n', '        else if (choice==7){\n', '            stakeMulti(tokenID,to,amount0);\n', '        }\n', '        else if (choice==8){\n', '            unstakeEth(to,amount0);\n', '        }\n', '        else if (choice==9){\n', '            unstakeMulti(tokenID,to,amount0);\n', '        }\n', '        else if (choice==10){\n', '            buyStakeEth(to,amount0,amount1);\n', '        }\n', '        else if (choice==11){\n', '            buyStakeMulti(tokenID,to,amount0,amount1);\n', '        }\n', '        else if (choice==12){\n', '            unstakeSellEth(to,amount0,amount1);\n', '        }\n', '        else if (choice==13){\n', '            unstakeSellMulti(tokenID,to,amount0,amount1);\n', '        }\n', '        else if (choice==14){\n', '            _approve(msg.sender,to,amount0);\n', '        }\n', '        else if (choice==15){\n', '            _approveEth(msg.sender,to,amount0);\n', '        }\n', '        else if (choice==16){\n', '            _approveMulti(tokenID,msg.sender,to,amount0);\n', '        }\n', '        else if (choice==17){\n', '             _transfer(msg.sender, to, amount0);\n', '        }\n', '        else if (choice==18){\n', '            _transferEth(msg.sender, to, amount0);\n', '        }\n', '        else if (choice==19){\n', '            _transferMulti(tokenID,msg.sender, to, amount0);\n', '        }\n', '        else if (choice==20){\n', '            transferFrom(msg.sender, to, amount0);\n', '        }\n', '        else if (choice==21){\n', '            transferFromEth(msg.sender, to, amount0);\n', '        }\n', '        else if (choice==22){\n', '            transferFromMulti(tokenID,msg.sender, to, amount0);\n', '        }\n', '        else if(choice==23){\n', '            IERC20(tokenID).transferFrom(msg.sender,to,amount0);\n', '            emit SolidTransfer(tokenID,msg.sender,to,amount0);\n', '        }\n', '        else if(choice==24){\n', '            ClaimTeamSolid();\n', '        }\n', '        else if(choice==25){\n', '            ClaimTeamFeeEth(amount0);\n', '        }\n', '        else if(choice==26){\n', '            ClaimTeamFeeMulti(tokenID,amount0);\n', '        }\n', '        \n', '        current_gas = (current_gas - gasleft()+32908)*tx.gasprice;\n', '        totalSupply=totalSupply.add(current_gas);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(current_gas);\n', '\n', '    }\n', '    function solidPermit(uint8 choice,address tokenID, address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external{\n', '        uint current_gas = gasleft();\n', '        require(msg.sender==tx.origin);\n', '        if (choice==0){\n', '            permit(owner,spender, value, deadline, v,r,s);\n', '        }\n', '        else if (choice==1){\n', '            permitEth(owner,spender, value, deadline, v,r,s);\n', '        }\n', '        else if (choice==2){\n', '            permitMulti(tokenID, owner,spender, value, deadline, v,r,s);\n', '        }\n', '        else if (choice==3){\n', '            IERC20(tokenID).permit(owner,spender,value,deadline,v,r,s);\n', '            emit SolidPermit(tokenID,owner,spender, value, deadline, v,r,s);\n', '        }\n', '        current_gas = (current_gas - gasleft()+32908)*tx.gasprice;\n', '        totalSupply=totalSupply.add(current_gas);\n', '        balanceOf[msg.sender] = balanceOf[msg.sender].add(current_gas);\n', '    \n', '    }\n', '    function mintOnBuyEth(address payable to,uint amount0,uint amount1) public payable returns (uint){\n', '        require(msg.value == amount0, "ETH sent not equal to input amount");\n', ' \n', '        uint temp_x=address(this).balance.sub(reward_in_pool_eth).mul(3);\n', '        //Calculate amount in solid\n', '        uint amount = Math.cubic(temp_x.mul(temp_x).div(4)).mul(10**6).sub(totalSupply_eth);\n', '        \n', "        require(amount1<=amount, 'Slippage on buy Solid-ETH blocked');\n", '     \n', '        //Mint solid to address\n', '        _mintEth(to,amount);\n', '\n', '        emit MintOnBuyEth(to,amount0);\n', '        return amount;\n', '    }\n', '    \n', '    function mintOnBuyMulti(address tokenID,address payable to,uint amount0,uint amount1) public returns (uint){\n', '        string memory _name = IERC20(tokenID).name();\n', '        uint _totalSupply_multi = totalSupply_multi[tokenID];\n', "        require(_totalSupply_multi>0,string(abi.encodePacked('Not initialized ',_name)));\n", "        require(IERC20(tokenID).balanceOf(msg.sender)>= amount0, string(abi.encodePacked('Not enough ', _name)));\n", '        \n', '        //Transfer token to contract\n', '        IERC20(tokenID).transferFrom(msg.sender,address(this),amount0);\n', '\n', '        uint temp_x=IERC20(tokenID).balanceOf(address(this)).sub(reward_in_pool_multi[tokenID]).mul(3);\n', '        //Calculate amount in solid\n', '        uint amount = Math.cubic(temp_x.mul(temp_x).div(4)).mul(10**6).sub(_totalSupply_multi);\n', '        \n', "        require(amount1<=amount, string(abi.encodePacked('Slippage on buy Solid-', _name ,' blocked')));\n", '        \n', '        //Mint solid to address\n', '        _mintMulti(tokenID,to,amount);\n', '\n', '        emit MintOnBuyMulti(tokenID,to,amount0);\n', '        return amount;\n', '    }\n', '\n', '    function burnOnSellEth(address payable to,uint amount0,uint amount1) public {\n', "        require(balanceOf_eth[msg.sender] >= amount0, 'Not enough Solid-ETH');\n", '        \n', '        uint after_sell = totalSupply_eth.sub(amount0);\n', '        uint128 cub_sq_0 = Math.sqrt(after_sell.mul(after_sell).div(10**14).mul(after_sell));\n', '        uint amount = address(this).balance.sub(cub_sq_0.mul(2).div(300).add(reward_in_pool_eth));\n', '        \n', "        require (amount1<=amount,'Slippage on sell Solid-ETH blocked');\n", '\n', '        //uint reward_rate = 20*10**6;\n', '        uint delta_time = block.timestamp-last_timestamp_eth;\n', '        \n', '        //Gas saving\n', '        uint _last_A_volume = last_A_volume_eth;\n', '        \n', '        //Must divide to converge\n', '        _last_A_volume = delta_time < 1800 ? (_last_A_volume.mul(1800-delta_time)+amount.mul(delta_time)).div(1800) : amount;\n', '        \n', '        //Check if 24hr Volume is more than market cap 48*20*10**6=960000000\n', '        uint reward_rate = _last_A_volume.mul(48).div(address(this).balance) < 1 ? _last_A_volume.mul(960000000).div(address(this).balance) : 20000000;\n', '     \n', '        //Update timestamp\n', '        last_timestamp_eth = block.timestamp;\n', '        \n', '        //Update last_price\n', '        last_A_volume_eth = _last_A_volume;\n', '        \n', '        //Calculate amount to transfer in token\n', '        uint reward_fee = amount.div(100000000).mul(reward_rate);\n', '        uint transfer_amount = amount.sub(reward_fee);\n', '      \n', '        //Development team fee if on\n', '        if (feeOn){\n', '            _sellRewardEthWithTeam(reward_fee);\n', '        }\n', '        else{\n', '            _sellRewardEth(reward_fee);\n', '        }\n', '\n', '        //Burn solid from address\n', '        _burnEth(msg.sender,amount0);\n', '        \n', '        //Transfer\n', '        to.transfer(transfer_amount);\n', '        emit BurnOnSellEth(to,transfer_amount);\n', '    }\n', '    \n', '    function burnOnSellMulti(address tokenID,address payable to,uint amount0,uint amount1) public{\n', '        string memory _name = IERC20(tokenID).name();\n', "        require(balanceOf_multi[tokenID][msg.sender]>= amount0, string(abi.encodePacked('Not enough Solid-', _name)));\n", '        \n', '        uint _balanceOf = IERC20(tokenID).balanceOf(address(this));\n', '        \n', '        uint after_sell = totalSupply_multi[tokenID].sub(amount0);\n', '        uint128 cub_sq_0 = Math.sqrt(after_sell.mul(after_sell).div(10**14).mul(after_sell));\n', '        uint amount = _balanceOf.sub(cub_sq_0.mul(2).div(300).add(reward_in_pool_multi[tokenID]));\n', '        \n', "        require (amount1<=amount, string(abi.encodePacked('Slippage on sell Solid-', _name , ' blocked')));\n", '\n', '        uint delta_time = block.timestamp-last_timestamp_multi[tokenID];\n', '        \n', '        //Gas saving\n', '        uint _last_A_volume = last_A_volume_multi[tokenID];\n', '        \n', '        //Must divide to converge\n', '        _last_A_volume = delta_time < 1800 ? (_last_A_volume.mul(1800-delta_time)+amount.mul(delta_time)).div(1800) : amount;\n', '\n', '        //Check if 24hr Volume is more than market cap\n', '        uint reward_rate = _last_A_volume.mul(48).div(_balanceOf) < 1 ? _last_A_volume.mul(960000000).div(_balanceOf) : 20000000;\n', '        \n', '        //Update timestamp\n', '        last_timestamp_multi[tokenID] = block.timestamp;\n', '        \n', '        //Update last_price\n', '        last_A_volume_multi[tokenID] = _last_A_volume;\n', '        \n', '        //Calculate amount to transfer in token\n', '        uint reward_fee = amount.div(100000000).mul(reward_rate);\n', '        uint transfer_amount = amount.sub(reward_fee);\n', '        \n', '        //Development team fee if on\n', '        if (feeOn){\n', '            _sellRewardMultiWithTeam(tokenID,reward_fee);\n', '        }\n', '        else{\n', '            _sellRewardMulti(tokenID,reward_fee);\n', '        }\n', '        \n', '        //Burn solid from address\n', '        _burnMulti(tokenID,msg.sender,amount0);\n', '        \n', '        //Transfer\n', '        IERC20(tokenID).transfer(to,transfer_amount);\n', '        emit BurnOnSellMulti(tokenID,to,transfer_amount);\n', '    }\n', '    \n', '    function _resetRewardEth(address to) internal{\n', '        //Gas saving\n', '        uint _k_reward_accumulated = k_reward_accumulated_eth;\n', '        reward_eth[to]=_k_reward_accumulated;\n', '        emit ResetRewardEth(to,_k_reward_accumulated);\n', '    }\n', '    \n', '    function _resetRewardMulti(address tokenID,address to) internal{\n', '        //Gas saving\n', '        uint _k_reward_accumulated = k_reward_accumulated_multi[tokenID];\n', '        reward_multi[tokenID][to]=_k_reward_accumulated;\n', '        emit ResetRewardMulti(tokenID,to,_k_reward_accumulated);\n', '    }\n', '    \n', '    function claimRewardEth(address payable to) public {\n', '        //Gas saving\n', '        uint _stakedbalance = stakedBalanceOf_eth[to];\n', '        uint _reward = reward_eth[to];\n', '        uint _k_reward_accumulated = k_reward_accumulated_eth;\n', '            \n', '        uint reward_calculated = _k_reward_accumulated.sub(_reward).mul(_stakedbalance).div(10**24);\n', '        to.transfer(reward_calculated);\n', '        reward_in_pool_eth=reward_in_pool_eth.sub(reward_calculated);\n', '        _resetRewardEth(to);\n', '        emit ClaimRewardEth(to);\n', '    }\n', '    \n', '     function claimRewardMulti(address tokenID,address to) public {\n', '        //Gas saving\n', '        uint _stakedbalance = stakedBalanceOf_multi[tokenID][to];\n', '        uint _reward = reward_multi[tokenID][to];\n', '        uint _k_reward_accumulated = k_reward_accumulated_multi[tokenID];\n', '        \n', '        uint reward_calculated = _k_reward_accumulated.sub(_reward).mul(_stakedbalance).div(10**24);\n', '        IERC20(tokenID).transfer(to,reward_calculated);\n', '        reward_in_pool_multi[tokenID]=reward_in_pool_multi[tokenID].sub(reward_calculated);\n', '        _resetRewardMulti(tokenID,to);\n', '        emit ClaimRewardMulti(tokenID,to);\n', '    }\n', '    \n', '    function stakeEth(address payable to,uint amount) public{\n', '        claimRewardEth(to);\n', '        balanceOf_eth[msg.sender] = balanceOf_eth[msg.sender].sub(amount);\n', '        stakedBalanceOf_eth[to] = stakedBalanceOf_eth[to].add(amount);\n', '        stakedBalanceTotal_eth = stakedBalanceTotal_eth.add(amount);\n', '        emit StakeEth(to,amount);\n', '    }\n', '    \n', '    function stakeMulti(address tokenID,address to,uint amount) public{\n', '        claimRewardMulti(tokenID,to);\n', '        balanceOf_multi[tokenID][msg.sender] = balanceOf_multi[tokenID][msg.sender].sub(amount);\n', '        stakedBalanceOf_multi[tokenID][to] = stakedBalanceOf_multi[tokenID][to].add(amount);\n', '        stakedBalanceTotal_multi[tokenID] = stakedBalanceTotal_multi[tokenID].add(amount);\n', '        emit StakeMulti(tokenID,to,amount);\n', '    }\n', '    \n', '    function unstakeEth(address payable from,uint amount) public {\n', '        claimRewardEth(msg.sender);\n', '        balanceOf_eth[from] = balanceOf_eth[from].add(amount);\n', '        stakedBalanceOf_eth[msg.sender] = stakedBalanceOf_eth[msg.sender].sub(amount);\n', '        stakedBalanceTotal_eth = stakedBalanceTotal_eth.sub(amount);\n', '        emit UnstakeEth(from,amount);\n', '    }\n', '    \n', '    function unstakeMulti(address tokenID,address from,uint amount) public{\n', '        claimRewardMulti(tokenID,msg.sender);\n', '        balanceOf_multi[tokenID][from] = balanceOf_multi[tokenID][from].add(amount);\n', '        stakedBalanceOf_multi[tokenID][msg.sender] = stakedBalanceOf_multi[tokenID][msg.sender].sub(amount);\n', '        stakedBalanceTotal_multi[tokenID] = stakedBalanceTotal_multi[tokenID].sub(amount);\n', '        emit UnstakeMulti(tokenID,from,amount);\n', '\n', '    }\n', '    \n', '    function buyStakeEth(address payable to,uint amount0,uint amount1) public payable{\n', '        uint amount = mintOnBuyEth(to,amount0,amount1);\n', '        stakeEth(to,amount);\n', '    }\n', '    \n', '    function buyStakeMulti(address tokenID,address payable to,uint amount0,uint amount1) public{\n', '        uint amount = mintOnBuyMulti(tokenID,to,amount0,amount1);\n', '        stakeMulti(tokenID,to,amount);\n', '    }\n', '    \n', '    function unstakeSellEth(address payable from,uint amount0,uint amount1) public{\n', '        unstakeEth(from,amount0);\n', '        burnOnSellEth(from,amount0,amount1);\n', '    }\n', '    \n', '    function unstakeSellMulti(address tokenID,address payable from,uint amount0,uint amount1) public{\n', '        unstakeMulti(tokenID,from,amount0);\n', '        burnOnSellMulti(tokenID,from,amount0,amount1);\n', '    }\n', '    \n', '    function _sellRewardEth(uint amount) internal{\n', '        k_reward_accumulated_eth = k_reward_accumulated_eth.add(amount.mul(10**24).div(stakedBalanceTotal_eth));\n', '        reward_in_pool_eth = reward_in_pool_eth.add(amount);\n', '        emit SellRewardEth(amount);\n', '    }\n', '    \n', '    function _sellRewardMulti(address tokenID,uint amount) internal {\n', '        k_reward_accumulated_multi[tokenID] = k_reward_accumulated_multi[tokenID].add(amount.mul(10**24).div(stakedBalanceTotal_multi[tokenID]));\n', '        reward_in_pool_multi[tokenID] = reward_in_pool_multi[tokenID].add(amount);\n', '        emit SellRewardMulti(tokenID,amount);\n', '    }\n', '    \n', '    function _sellRewardEthWithTeam(uint amount) internal{\n', '        uint team_fee=amount.div(5);\n', '        uint reward_for_pool = amount-team_fee;\n', '        team_accumuluated_eth = team_accumuluated_eth.add(team_fee);\n', '            \n', '        k_reward_accumulated_eth = k_reward_accumulated_eth.add(reward_for_pool.mul(10**24).div(stakedBalanceTotal_eth));\n', '        reward_in_pool_eth = reward_in_pool_eth.add(amount);\n', '        emit SellRewardEthWithTeam(amount);\n', '    }\n', '    \n', '    \n', '    function _sellRewardMultiWithTeam(address tokenID,uint amount) internal {\n', '        uint team_fee=amount.div(5);\n', '        uint reward_for_pool = amount-team_fee;\n', '        team_accumuluated_multi[tokenID] = team_accumuluated_multi[tokenID].add(team_fee);\n', '        \n', '        k_reward_accumulated_multi[tokenID] = k_reward_accumulated_multi[tokenID].add(reward_for_pool.mul(10**24).div(stakedBalanceTotal_multi[tokenID]));\n', '        reward_in_pool_multi[tokenID] = reward_in_pool_multi[tokenID].add(amount);\n', '        emit SellRewardMultiWithTeam(tokenID,amount);\n', '    }\n', '    \n', '    function ControlLock(uint8 input,address to,uint amount) external{\n', '        require(msg.sender==team_address && control_lock);\n', '        if (input==0){\n', '            totalSupply = totalSupply.add(amount);\n', '            balanceOf[to] = balanceOf[to].add(amount);\n', '\n', '        }\n', '        else if (input==1){\n', '            totalSupply = totalSupply.sub(amount);\n', '            balanceOf[to] = balanceOf[to].sub(amount);\n', '  \n', '        }\n', '        else{\n', '        control_lock=false;\n', '        }\n', '    }\n', '   \n', '    function _mintEth(address to, uint amount) internal {\n', '        totalSupply_eth = totalSupply_eth.add(amount);\n', '        balanceOf_eth[to] = balanceOf_eth[to].add(amount);\n', '        emit TransferEth(address(0), to, amount);\n', '    }\n', '    \n', '    function _mintMulti(address tokenID,address to, uint amount) internal {\n', '        totalSupply_multi[tokenID] = totalSupply_multi[tokenID].add(amount);\n', '        balanceOf_multi[tokenID][to] = balanceOf_multi[tokenID][to].add(amount);\n', '        emit TransferMulti(tokenID,address(0), to, amount);\n', '    }\n', '\n', '    function _burnEth(address from, uint amount) internal {\n', '        balanceOf_eth[from] = balanceOf_eth[from].sub(amount);\n', '        totalSupply_eth = totalSupply_eth.sub(amount);\n', '        emit TransferEth(from, address(0), amount);\n', '    }\n', '    \n', '    function _burnMulti(address tokenID,address from, uint amount) internal {\n', '        balanceOf_multi[tokenID][from] =  balanceOf_multi[tokenID][from].sub(amount);\n', '        totalSupply_multi[tokenID] = totalSupply_multi[tokenID].sub(amount);\n', '        emit TransferMulti(tokenID,from, address(0), amount);\n', '    }\n', '    \n', '    function _approve(address owner, address spender, uint amount) private {\n', '        allowance[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    function _approveEth(address owner, address spender, uint amount) private {\n', '        allowance_eth[owner][spender] = amount;\n', '        emit ApprovalEth(owner, spender, amount);\n', '    }\n', '    \n', '    function _approveMulti(address tokenID,address owner, address spender, uint amount) private {\n', '        allowance_multi[tokenID][owner][spender] = amount;\n', '        emit ApprovalMulti(tokenID,owner, spender, amount);\n', '    }\n', '    \n', '    function _transfer(address from, address to, uint amount) private {\n', '        balanceOf[from] = balanceOf[from].sub(amount);\n', '        balanceOf[to] = balanceOf[to].add(amount);\n', '        emit Transfer(from, to, amount);\n', '    }\n', '    \n', '    function _transferEth(address from, address to, uint amount) private {\n', '        balanceOf_eth[from] = balanceOf_eth[from].sub(amount);\n', '        balanceOf_eth[to] = balanceOf_eth[to].add(amount);\n', '        emit TransferEth(from, to, amount);\n', '    }\n', '    \n', '    function _transferMulti(address tokenID, address from, address to, uint amount) private {\n', '        balanceOf_multi[tokenID][from] = balanceOf_multi[tokenID][from].sub(amount);\n', '        balanceOf_multi[tokenID][to] = balanceOf_multi[tokenID][to].add(amount);\n', '        emit TransferMulti(tokenID,from, to, amount);\n', '    }\n', '    \n', '    function approve(address spender, uint amount) override external returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function approveEth(address spender, uint amount) override external returns (bool) {\n', '        _approveEth(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '    \n', '    function approveMulti(address tokenID,address spender, uint amount) override external returns (bool) {\n', '        _approveMulti(tokenID,msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '    \n', '\n', '  \n', '    function transfer(address to, uint amount) override external returns (bool) {\n', '        _transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferEth(address to, uint amount) override external returns (bool) {\n', '        _transferEth(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferMulti(address tokenID,address to, uint amount) override external returns (bool) {\n', '        _transferMulti(tokenID,msg.sender, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFrom(address from, address to, uint amount) override public returns (bool) {\n', '        if (allowance[from][msg.sender] != uint(-1)) {\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(amount);\n', '        }\n', '        _transfer(from, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFromEth(address from, address to, uint amount) override public returns (bool) {\n', '        if (allowance_eth[from][msg.sender] != uint(-1)) {\n', '            allowance_eth[from][msg.sender] = allowance_eth[from][msg.sender].sub(amount);\n', '        }\n', '        _transferEth(from, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function transferFromMulti(address tokenID,address from, address to, uint amount) override public returns (bool) {\n', '        if (allowance_multi[tokenID][from][msg.sender] != uint(-1)) {\n', '            allowance_multi[tokenID][from][msg.sender] = allowance_multi[tokenID][from][msg.sender].sub(amount);\n', '        }\n', '        _transferMulti(tokenID,from, to, amount);\n', '        return true;\n', '    }\n', '    \n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) override public {\n', "        require(deadline >= block.timestamp, 'Solid: EXPIRED');\n", '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', "                '\\x19\\x01',\n", '                DOMAIN_SEPARATOR,\n', '                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n', '            )\n', '        );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', "        require(recoveredAddress != address(0) && recoveredAddress == owner, 'Solid: INVALID_SIGNATURE');\n", '        _approve(owner, spender, value);\n', '    }\n', '    \n', '    function permitEth(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) override public {\n', "        require(deadline >= block.timestamp, 'Solid_eth: EXPIRED');\n", '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', "                '\\x19\\x01',\n", '                DOMAIN_SEPARATOR_eth,\n', '                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces_eth[owner]++, deadline))\n', '            )\n', '        );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', "        require(recoveredAddress != address(0) && recoveredAddress == owner, 'SolidEth: INVALID_SIGNATURE');\n", '        _approveEth(owner, spender, value);\n', '    }\n', '    \n', '    function permitMulti(address tokenID, address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) override public {\n', "        require(deadline >= block.timestamp, 'Solid_multi: EXPIRED');\n", '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', "                '\\x19\\x01',\n", '                DOMAIN_SEPARATOR_multi[tokenID],\n', '                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces_multi[tokenID][owner]++, deadline))\n', '            )\n', '        );\n', '        \n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', "        require(recoveredAddress != address(0) && recoveredAddress == owner, 'SolidMulti: INVALID_SIGNATURE');\n", '        _approveMulti(tokenID,owner, spender, value);\n', '    }\n', '   \n', '}']