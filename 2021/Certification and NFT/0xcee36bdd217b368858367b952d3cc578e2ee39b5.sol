['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '// copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC721/ERC721.sol\n', '// and merged with: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.1.0/contracts/token/ERC721/extensions/ERC721Enumerable.sol\n', '\n', 'import "./IERC721.sol";\n', 'import "./IERC721Receiver.sol";\n', 'import "./IERC721Metadata.sol";\n', 'import "./IERC721Enumerable.sol";\n', 'import "./Address.sol";\n', 'import "./Context.sol";\n', 'import "./Strings.sol";\n', 'import "./ERC165.sol";\n', 'import "./Pausable.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./Proxy.sol";\n', '\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2309.md\n', 'interface IERC2309 {\n', '    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n', '}\n', '\n', '/**\n', ' * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n', ' * the Metadata extension, but not including the Enumerable extension, which is available separately as\n', ' * {ERC721Enumerable}.\n', ' */\n', 'contract EvaverseNFT is ProxyTarget, Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable, IERC2309, Pausable, ReentrancyGuard {\n', '    using Address for address;\n', '    using Strings for uint256;\n', '    \n', '    string private _tokenName;\n', '    string private _tokenSymbol;\n', '    string private _baseURI;\n', '    \n', '    // Mapping from token ID to owner address\n', '    mapping (uint256 => address) private _owners;\n', '\n', '    // Mapping owner address to token count\n', '    mapping (address => uint256) private _balances;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '    \n', '    // Mapping from owner to list of owned token IDs\n', '    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n', '\n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '    \n', '    uint256         private _tokenCount;\n', '    uint256         private _giveawayTokens;\n', '    uint256         private _maxTokens;\n', '    uint256         private _tokenPrice;\n', '    address payable private _bankAddress;\n', '    bool            private _bankIsContract;\n', '    bool            private _initialized;\n', '    \n', "    // can't depend on a constructor because we have an upgradable proxy, have to initialize instead.\n", '    function Initialize() onlyOwner external {\n', '        require(!_initialized, "Contract instance has already been initialized");\n', '\n', '        _tokenName      = "Evaverse";\n', '        _tokenSymbol    = "EVA";\n', '        _baseURI        = "https://evaverse.com/api/creatures.php?id=";\n', '        \n', '        _giveawayTokens = 500;\n', '        _maxTokens      = 10000;\n', '        _tokenPrice     = 100000000000000000; //0.1 ETH\n', '        _initialized    = true;\n', '        _batchMint(Ownable.owner(), _giveawayTokens);\n', '    }\n', '\n', '    function IsInitialized() external view returns (bool) {\n', '        return _initialized;\n', '    }\n', '\n', '    // Hopefully never need this. Leaving it as an option if we have unsold tokens, if we want to do another giveaway or something.\n', '    function DevMint(address to, uint count) external onlyOwner {\n', '        require(_tokenCount + count < _maxTokens, "EvaNFT: Not enough tokens remaining.");\n', '        _batchMint(to, count);\n', '    }\n', '\n', '    function MintNFT(uint count) payable external whenNotPaused nonReentrant {\n', '        require(_initialized, "EvaNFT: Contract is not initialized.");\n', '        require(count > 0, "EvaNFT: Count must be greater than 0.");\n', '        require(count <= 400, "EvaNFT: Count can\'t be that large, sorry.");\n', '        require(_tokenCount < _maxTokens, "EvaNFT: No tokens left to purchase.");\n', '        require(msg.value == count * _tokenPrice, "EvaNFT: Amount of ETH is not right.");\n', '\n', '        // pro-rate any purchase that would have put us over the cap of total NFTs\n', '        uint refundCount = 0;\n', '        if (_tokenCount + count > _maxTokens) {\n', '            refundCount = count - (_maxTokens - _tokenCount);\n', '            count = _maxTokens - _tokenCount;\n', '        }\n', '        \n', '        // Mint all our NFTs!\n', '        _batchMint(_msgSender(), count);\n', '        \n', "        // Refund any Ether for NFTs that couldn't be minted.\n", '        if (refundCount > 0) {\n', '            address payable receiver = payable(_msgSender());\n', '            receiver.transfer(refundCount * _tokenPrice);\n', '        }\n', '        \n', '        // Store funds in a wallet or other smart contract.\n', '        if (_bankAddress != address(0)) {\n', '            if (_bankIsContract) {\n', '                // This is the only way I could get funds to receive in Gnosis Safe.\n', '                (bool sent, ) = _bankAddress.call{value: msg.value}("");\n', '                require(sent, "Failed to send Ether");\n', '            }\n', '            else {\n', '                _bankAddress.transfer(msg.value);\n', '            }\n', '        }\n', '    }\n', '    \n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n', '        return interfaceId == type(IERC721).interfaceId\n', '            || interfaceId == type(IERC721Metadata).interfaceId\n', '            || interfaceId == type(IERC721Enumerable).interfaceId\n', '            || super.supportsInterface(interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-balanceOf}.\n', '     */\n', '    function balanceOf(address owner) public view virtual override returns (uint256) {\n', '        require(owner != address(0), "EvaNFT: balance query for the zero address");\n', '        return owner == Ownable.owner() ? 0 : _balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-ownerOf}.\n', '     */\n', '    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n', '        require(_exists(tokenId), "EvaNFT: owner query for nonexistent token");\n', '        address owner = _owners[tokenId];\n', '        return owner != address(0) ? owner : Ownable.owner();\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-name}.\n', '     */\n', '    function name() public view virtual override returns (string memory) {\n', '        return _tokenName;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-symbol}.\n', '     */\n', '    function symbol() public view virtual override returns (string memory) {\n', '        return _tokenSymbol;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Metadata-tokenURI}.\n', '     */\n', '    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n', '        require(_exists(tokenId), "EvaNFT: URI query for nonexistent token");\n', '        return string(abi.encodePacked(_baseURI, tokenId.toString()));\n', '    }\n', '    \n', '    function baseURI() public view returns (string memory) {\n', '        return _baseURI;\n', '    }\n', '\n', '    function setBaseURI(string memory uri) external onlyOwner {\n', '        _baseURI = uri;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-approve}.\n', '     */\n', '    function approve(address to, uint256 tokenId) public virtual override whenNotPaused {\n', '        address owner = EvaverseNFT.ownerOf(tokenId);\n', '        require(to != owner, "EvaNFT: approval to current owner");\n', '\n', '        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n', '            "EvaNFT: approve caller is not owner nor approved for all"\n', '        );\n', '\n', '        _approve(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-getApproved}.\n', '     */\n', '    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n', '        require(_exists(tokenId), "EvaNFT: approved query for nonexistent token");\n', '\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-setApprovalForAll}.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) public virtual override whenNotPaused {\n', '        require(operator != _msgSender(), "EvaNFT: approve to caller");\n', '\n', '        _operatorApprovals[_msgSender()][operator] = approved;\n', '        emit ApprovalForAll(_msgSender(), operator, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-isApprovedForAll}.\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-transferFrom}.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public virtual override whenNotPaused {\n', '        //solhint-disable-next-line max-line-length\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "EvaNFT: transfer caller is not owner nor approved");\n', '\n', '        _transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721-safeTransferFrom}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override whenNotPaused {\n', '        require(_isApprovedOrOwner(_msgSender(), tokenId), "EvaNFT: transfer caller is not owner nor approved");\n', '        _safeTransfer(from, to, tokenId, _data);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n', '     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n', '     *\n', '     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n', '     *\n', '     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n', '     * implement alternative mechanisms to perform token transfer, such as signature-based.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must exist and be owned by `from`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\n', '        _transfer(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data), "EvaNFT: transfer to non ERC721Receiver implementer");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `tokenId` exists.\n', '     *\n', '     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n', '     *\n', '     * Tokens start existing when they are minted (`_mint`),\n', '     * and stop existing when they are burned (`_burn`).\n', '     */\n', '    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n', '        return tokenId > 0 && tokenId <= _tokenCount;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `tokenId` must exist.\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n', '        require(_exists(tokenId), "EvaNFT: operator query for nonexistent token");\n', '        address owner = EvaverseNFT.ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    function _batchMint(address to, uint count) internal {\n', '        require(to != address(0), "EvaNFT: mint to the zero address");\n', '        \n', '        uint256 tokenId = _tokenCount + 1;\n', '        uint256 startToken = tokenId;\n', '        uint256 endToken = tokenId + count;\n', '\n', "        // Don't need to run this code on the owner, those tokens are... virtual?\n", '        if (to != Ownable.owner()) {\n', '            for(; tokenId < endToken; tokenId++) {\n', '                _owners[tokenId] = to;\n', '            }\n', '        }\n', '        \n', '        _balances[to] += count;\n', '        _tokenCount += count;\n', '        \n', '        emit ConsecutiveTransfer(startToken, endToken, address(0), to);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers `tokenId` from `from` to `to`.\n', '     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     * - `tokenId` token must be owned by `from`.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n', '        require(EvaverseNFT.ownerOf(tokenId) == from, "EvaNFT: transfer of token that is not own");\n', '        require(to != address(0), "EvaNFT: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(from, to, tokenId);\n', '\n', '        // Clear approvals from the previous owner\n', '        _approve(address(0), tokenId);\n', '\n', '        _balances[from] -= 1;\n', '        _balances[to] += 1;\n', '        _owners[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Approve `to` to operate on `tokenId`\n', '     *\n', '     * Emits a {Approval} event.\n', '     */\n', '    function _approve(address to, uint256 tokenId) internal virtual whenNotPaused {\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(EvaverseNFT.ownerOf(tokenId), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n', '     * The call is not executed if the target address is not a contract.\n', '     *\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return bool whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data) private returns (bool)\n', '    {\n', '        if (to.isContract()) {\n', '            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n', '                return retval == IERC721Receiver(to).onERC721Received.selector;\n', '            } catch (bytes memory reason) {\n', '                if (reason.length == 0) {\n', '                    revert("EvaNFT: transfer to non ERC721Receiver implementer");\n', '                } else {\n', '                    // solhint-disable-next-line no-inline-assembly\n', '                    assembly {\n', '                        revert(add(32, reason), mload(reason))\n', '                    }\n', '                }\n', '            }\n', '        } else {\n', '            return true;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n', '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n', '        require(index < EvaverseNFT.balanceOf(owner), "EvaNFT: owner index out of bounds");\n', '        require(owner != Ownable.owner(), "EvaNFT: contract owner tokenOfOwnerByIndex not supported");\n', '        return _ownedTokens[owner][index];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _tokenCount;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC721Enumerable-tokenByIndex}.\n', '     */\n', '    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n', '        require(index < EvaverseNFT.totalSupply(), "EvaNFT: global index out of bounds");\n', '        return index + 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any token transfer.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n", '     * transferred to `to`.\n', '     * - When `from` is zero, `tokenId` will be minted for `to`.\n', "     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n", '     * - `from` cannot be the zero address.\n', '     * - `to` cannot be the zero address.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 tokenId) private {\n', '        if (from == address(0)) {\n', "            // this would only ever be called single single minting, which we don't care about\n", '            //_addTokenToAllTokensEnumeration(tokenId);\n', '        } else if (from != to) {\n', '            _removeTokenFromOwnerEnumeration(from, tokenId);\n', '        }\n', '        if (to == address(0)) {\n', "            // this is only ever used in burning, which we don't care about.\n", '            //_removeTokenFromAllTokensEnumeration(tokenId);\n', '        } else if (to != from) {\n', '            _addTokenToOwnerEnumeration(to, tokenId);\n', '        }\n', '    }\n', '    \n', '    /**\n', "     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n", '     * @param to address representing the new owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '     */\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        if (to == Ownable.owner())\n', '            return;\n', '\n', '        uint256 length = EvaverseNFT.balanceOf(to);\n', '        _ownedTokens[to][length] = tokenId;\n', '        _ownedTokensIndex[tokenId] = length;\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n", '     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n', '     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n', '     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '     */\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', "        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n", '        // then delete the last slot (swap and pop).\n', '        if (from == Ownable.owner())\n', '            return;\n', '            \n', '        uint256 lastTokenIndex = EvaverseNFT.balanceOf(from) - 1;\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '\n', '        // This also deletes the contents at the last position of the array\n', '        delete _ownedTokensIndex[tokenId];\n', '        delete _ownedTokens[from][lastTokenIndex];\n', '    }\n', '    \n', '    function SetPause(bool pause) external onlyOwner {\n', '        if (pause)\n', '            _pause();\n', '        else\n', '            _unpause();\n', '    }\n', '    \n', '    function WithdrawBalance(address payTo, uint256 amount) external onlyOwner {\n', '        address thisAddr = address(this);\n', '        require(thisAddr.balance > 0);\n', '        address payable receiver = payable(payTo);\n', '        receiver.transfer(amount);\n', '    }\n', '\n', '    function SendGiftToWinners(uint256 startTokenId, address[] memory winners) external onlyOwner {\n', '        for(uint ii = 0; ii < winners.length; ii++) {\n', '            uint256 tokenId = startTokenId + ii;\n', '            require(tokenId <= _giveawayTokens, "We can\'t give away that many."); // we must also be the owner, but that require check is already inside safeTransferFrom\n', '            safeTransferFrom(Ownable.owner(), winners[ii], tokenId);\n', '        }\n', '    }\n', '    \n', '    function GetBalance() external view onlyOwner returns (uint256) {\n', '        return address(this).balance;\n', '    }\n', '    \n', '    function GetMaxTokenCount() external view returns (uint256) {\n', '        return _maxTokens;\n', '    }\n', '    \n', '    function SetBank(address bank, bool isContract) external onlyOwner {\n', '        _bankAddress = payable(bank);\n', '        _bankIsContract = isContract;\n', '    }\n', '    \n', '    function GetBank() external view onlyOwner returns (address) {\n', '        return _bankAddress;\n', '    }\n', '    \n', '    function SetPrice(uint256 newPrice) external onlyOwner {\n', '        _tokenPrice = newPrice;\n', '    }\n', '    \n', '    function GetPrice() external view returns (uint) {\n', '        return _tokenPrice;\n', '    }\n', '}']