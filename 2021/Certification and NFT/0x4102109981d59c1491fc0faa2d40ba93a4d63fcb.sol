['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-08\n', '*/\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/external/Decimal.sol\n', '\n', '/*\n', '    Copyright 2019 dYdX Trading Inc.\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.7;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '/**\n', ' * @title Decimal\n', ' * @author dYdX\n', ' *\n', ' * Library that defines a fixed-point number with 18 decimal places.\n', ' */\n', 'library Decimal {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Constants ============\n', '\n', '    uint256 constant BASE = 10**18;\n', '\n', '    // ============ Structs ============\n', '\n', '\n', '    struct D256 {\n', '        uint256 value;\n', '    }\n', '\n', '    // ============ Static Functions ============\n', '\n', '    function zero()\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: 0 });\n', '    }\n', '\n', '    function one()\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: BASE });\n', '    }\n', '\n', '    function from(\n', '        uint256 a\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: a.mul(BASE) });\n', '    }\n', '\n', '    function ratio(\n', '        uint256 a,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(a, BASE, b) });\n', '    }\n', '\n', '    // ============ Self Functions ============\n', '\n', '    function add(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.add(b.mul(BASE)) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.mul(BASE)) });\n', '    }\n', '\n', '    function mul(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.mul(b) });\n', '    }\n', '\n', '    function div(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.div(b) });\n', '    }\n', '\n', '    function pow(\n', '        D256 memory self,\n', '        uint256 b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        if (b == 0) {\n', '            return from(1);\n', '        }\n', '\n', '        D256 memory temp = D256({ value: self.value });\n', '        for (uint256 i = 1; i < b; i++) {\n', '            temp = mul(temp, self);\n', '        }\n', '\n', '        return temp;\n', '    }\n', '\n', '    function add(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.add(b.value) });\n', '    }\n', '\n', '    function sub(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: self.value.sub(b.value) });\n', '    }\n', '\n', '    function mul(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(self.value, b.value, BASE) });\n', '    }\n', '\n', '    function div(\n', '        D256 memory self,\n', '        D256 memory b\n', '    )\n', '    internal\n', '    pure\n', '    returns (D256 memory)\n', '    {\n', '        return D256({ value: getPartial(self.value, BASE, b.value) });\n', '    }\n', '\n', '    function equals(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return self.value == b.value;\n', '    }\n', '\n', '    function greaterThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) == 2;\n', '    }\n', '\n', '    function lessThan(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) == 0;\n', '    }\n', '\n', '    function greaterThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) > 0;\n', '    }\n', '\n', '    function lessThanOrEqualTo(D256 memory self, D256 memory b) internal pure returns (bool) {\n', '        return compareTo(self, b) < 2;\n', '    }\n', '\n', '    function isZero(D256 memory self) internal pure returns (bool) {\n', '        return self.value == 0;\n', '    }\n', '\n', '    function asUint256(D256 memory self) internal pure returns (uint256) {\n', '        return self.value.div(BASE);\n', '    }\n', '\n', '    // ============ Core Methods ============\n', '\n', '    function getPartial(\n', '        uint256 target,\n', '        uint256 numerator,\n', '        uint256 denominator\n', '    )\n', '    private\n', '    pure\n', '    returns (uint256)\n', '    {\n', '        return target.mul(numerator).div(denominator);\n', '    }\n', '\n', '    function compareTo(\n', '        D256 memory a,\n', '        D256 memory b\n', '    )\n', '    private\n', '    pure\n', '    returns (uint256)\n', '    {\n', '        if (a.value == b.value) {\n', '            return 1;\n', '        }\n', '        return a.value > b.value ? 2 : 0;\n', '    }\n', '}\n', '\n', '// File: contracts/Constants.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', 'library Constants {\n', '    /* Chain */\n', '    uint256 private constant CHAIN_ID = 1; // Mainnet\n', '\n', '    /* Bootstrapping */\n', '    uint256 private constant BOOTSTRAPPING_PERIOD = 84;\n', '\n', '    /* Oracle */\n', '    address private constant USDC = address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n', '    uint256 private constant ORACLE_RESERVE_MINIMUM = 1e22; // 10,000 VSD\n', '    address private constant DAI = address(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n', '\n', '    /* Epoch */\n', '    struct EpochStrategy {\n', '        uint256 offset;\n', '        uint256 start;\n', '        uint256 period;\n', '    }\n', '\n', '    uint256 private constant CURRENT_EPOCH_OFFSET = 0;\n', '    uint256 private constant CURRENT_EPOCH_START = 1612324800;\n', '    uint256 private constant CURRENT_EPOCH_PERIOD = 28800;\n', '\n', '    /* Governance */\n', '    uint256 private constant GOVERNANCE_PERIOD = 9; // 9 epochs\n', '    uint256 private constant GOVERNANCE_EXPIRATION = 2; // 2 + 1 epochs\n', '    uint256 private constant GOVERNANCE_QUORUM = 10e16; // 10%\n', '    uint256 private constant GOVERNANCE_PROPOSAL_THRESHOLD = 5e15; // 0.5%\n', '    uint256 private constant GOVERNANCE_SUPER_MAJORITY = 66e16; // 66%\n', '    uint256 private constant GOVERNANCE_EMERGENCY_DELAY = 6; // 6 epochs\n', '\n', '    /* DAO */\n', '    uint256 private constant ADVANCE_INCENTIVE = 1e20; // 100 VSD\n', '    uint256 private constant DAO_EXIT_LOCKUP_EPOCHS = 15; // 15 epochs fluid\n', '\n', '    /* Market */\n', '    uint256 private constant COUPON_EXPIRATION = 30; // 10 days\n', '    uint256 private constant DEBT_RATIO_CAP = 15e16; // 15%\n', '\n', '    /* Regulator */\n', '    uint256 private constant COUPON_SUPPLY_CHANGE_LIMIT = 6e16; // 6%\n', '    uint256 private constant SUPPLY_INCREASE_FUND_RATIO = 1500; // 15%\n', '    uint256 private constant SUPPLY_INCREASE_PRICE_THRESHOLD = 105e16; // 1.05\n', '    uint256 private constant SUPPLY_INCREASE_PRICE_TARGET = 105e16; // 1.05\n', '    uint256 private constant SUPPLY_DECREASE_PRICE_THRESHOLD = 95e16; // 0.95\n', '    uint256 private constant SUPPLY_DECREASE_PRICE_TARGET = 95e16; // 0.95\n', '\n', '    /* Collateral */\n', '    uint256 private constant REDEMPTION_RATE = 9500; // 95%\n', '    uint256 private constant FUND_DEV_PCT = 70; // 70%\n', '    uint256 private constant COLLATERAL_RATIO = 9000; // 90%\n', '\n', '    /* Deployed */\n', '    address private constant TREASURY_ADDRESS = address(0x3a640b96405eCB10782C130022e1E5a560EBcf11);\n', '    address private constant DEV_ADDRESS = address(0x5bC47D40F69962d1a9Db65aC88f4b83537AF5Dc2);\n', '    address private constant MINTER_ADDRESS = address(0x6Ff1DbcF2996D8960E24F16C193EA42853995d32);\n', '    address private constant GOVERNOR = address(0xB64A5630283CCBe0C3cbF887a9f7B9154aEf38c3);\n', '\n', '    /**\n', '     * Getters\n', '     */\n', '\n', '    function getUsdcAddress() internal pure returns (address) {\n', '        return USDC;\n', '    }\n', '\n', '    function getDaiAddress() internal pure returns (address) {\n', '        return DAI;\n', '    }\n', '\n', '    function getOracleReserveMinimum() internal pure returns (uint256) {\n', '        return ORACLE_RESERVE_MINIMUM;\n', '    }\n', '\n', '    function getCurrentEpochStrategy() internal pure returns (EpochStrategy memory) {\n', '        return EpochStrategy({\n', '            offset: CURRENT_EPOCH_OFFSET,\n', '            start: CURRENT_EPOCH_START,\n', '            period: CURRENT_EPOCH_PERIOD\n', '        });\n', '    }\n', '\n', '    function getBootstrappingPeriod() internal pure returns (uint256) {\n', '        return BOOTSTRAPPING_PERIOD;\n', '    }\n', '\n', '    function getGovernancePeriod() internal pure returns (uint256) {\n', '        return GOVERNANCE_PERIOD;\n', '    }\n', '\n', '    function getGovernanceExpiration() internal pure returns (uint256) {\n', '        return GOVERNANCE_EXPIRATION;\n', '    }\n', '\n', '    function getGovernanceQuorum() internal pure returns (Decimal.D256 memory) {\n', '        return Decimal.D256({value: GOVERNANCE_QUORUM});\n', '    }\n', '\n', '    function getGovernanceProposalThreshold() internal pure returns (Decimal.D256 memory) {\n', '        return Decimal.D256({value: GOVERNANCE_PROPOSAL_THRESHOLD});\n', '    }\n', '\n', '    function getGovernanceSuperMajority() internal pure returns (Decimal.D256 memory) {\n', '        return Decimal.D256({value: GOVERNANCE_SUPER_MAJORITY});\n', '    }\n', '\n', '    function getGovernanceEmergencyDelay() internal pure returns (uint256) {\n', '        return GOVERNANCE_EMERGENCY_DELAY;\n', '    }\n', '\n', '    function getAdvanceIncentive() internal pure returns (uint256) {\n', '        return ADVANCE_INCENTIVE;\n', '    }\n', '\n', '    function getDAOExitLockupEpochs() internal pure returns (uint256) {\n', '        return DAO_EXIT_LOCKUP_EPOCHS;\n', '    }\n', '\n', '    function getCouponExpiration() internal pure returns (uint256) {\n', '        return COUPON_EXPIRATION;\n', '    }\n', '\n', '    function getDebtRatioCap() internal pure returns (Decimal.D256 memory) {\n', '        return Decimal.D256({value: DEBT_RATIO_CAP});\n', '    }\n', '\n', '    function getCouponSupplyChangeLimit() internal pure returns (Decimal.D256 memory) {\n', '        return Decimal.D256({value: COUPON_SUPPLY_CHANGE_LIMIT});\n', '    }\n', '\n', '    function getSupplyIncreaseFundRatio() internal pure returns (uint256) {\n', '        return SUPPLY_INCREASE_FUND_RATIO;\n', '    }\n', '\n', '    function getSupplyIncreasePriceThreshold() internal pure returns (uint256) {\n', '        return SUPPLY_INCREASE_PRICE_THRESHOLD;\n', '    }\n', '\n', '    function getSupplyIncreasePriceTarget() internal pure returns (uint256) {\n', '        return SUPPLY_INCREASE_PRICE_TARGET;\n', '    }\n', '\n', '    function getSupplyDecreasePriceThreshold() internal pure returns (uint256) {\n', '        return SUPPLY_DECREASE_PRICE_THRESHOLD;\n', '    }\n', '\n', '    function getSupplyDecreasePriceTarget() internal pure returns (uint256) {\n', '        return SUPPLY_DECREASE_PRICE_TARGET;\n', '    }\n', '\n', '    function getChainId() internal pure returns (uint256) {\n', '        return CHAIN_ID;\n', '    }\n', '\n', '    function getTreasuryAddress() internal pure returns (address) {\n', '        return TREASURY_ADDRESS;\n', '    }\n', '\n', '    function getDevAddress() internal pure returns (address) {\n', '        return DEV_ADDRESS;\n', '    }\n', '\n', '    function getMinterAddress() internal pure returns (address) {\n', '        return MINTER_ADDRESS;\n', '    }\n', '\n', '    function getFundDevPct() internal pure returns (uint256) {\n', '        return FUND_DEV_PCT;\n', '    }\n', '\n', '    function getRedemptionRate() internal pure returns (uint256) {\n', '        return REDEMPTION_RATE;\n', '    }\n', '\n', '    function getGovernor() internal pure returns (address) {\n', '        return GOVERNOR;\n', '    }\n', '\n', '    function getCollateralRatio() internal pure returns (uint256) {\n', '        return COLLATERAL_RATIO;\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Curve.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', 'contract Curve {\n', '    using SafeMath for uint256;\n', '    using Decimal for Decimal.D256;\n', '\n', '    function calculateCouponPremium(\n', '        uint256 totalSupply,\n', '        uint256 totalDebt,\n', '        uint256 amount\n', '    ) internal pure returns (uint256) {\n', '        return effectivePremium(totalSupply, totalDebt, amount).mul(amount).asUint256();\n', '    }\n', '\n', '    function effectivePremium(\n', '        uint256 totalSupply,\n', '        uint256 totalDebt,\n', '        uint256 amount\n', '    ) private pure returns (Decimal.D256 memory) {\n', '        Decimal.D256 memory debtRatio = Decimal.ratio(totalDebt, totalSupply);\n', '        Decimal.D256 memory debtRatioUpperBound = Constants.getDebtRatioCap();\n', '\n', '        uint256 totalSupplyEnd = totalSupply.sub(amount);\n', '        uint256 totalDebtEnd = totalDebt.sub(amount);\n', '        Decimal.D256 memory debtRatioEnd = Decimal.ratio(totalDebtEnd, totalSupplyEnd);\n', '\n', '        if (debtRatio.greaterThan(debtRatioUpperBound)) {\n', '            if (debtRatioEnd.greaterThan(debtRatioUpperBound)) {\n', '                return curve(debtRatioUpperBound);\n', '            }\n', '\n', '            Decimal.D256 memory premiumCurve = curveMean(debtRatioEnd, debtRatioUpperBound);\n', '            Decimal.D256 memory premiumCurveDelta = debtRatioUpperBound.sub(debtRatioEnd);\n', '            Decimal.D256 memory premiumFlat = curve(debtRatioUpperBound);\n', '            Decimal.D256 memory premiumFlatDelta = debtRatio.sub(debtRatioUpperBound);\n', '            return (premiumCurve.mul(premiumCurveDelta)).add(premiumFlat.mul(premiumFlatDelta))\n', '                .div(premiumCurveDelta.add(premiumFlatDelta));\n', '        }\n', '\n', '        return curveMean(debtRatioEnd, debtRatio);\n', '    }\n', '\n', '    // 1/((1-R)^2)-1\n', '    function curve(Decimal.D256 memory debtRatio) private pure returns (Decimal.D256 memory) {\n', '        return Decimal.one().div(\n', '            (Decimal.one().sub(debtRatio)).pow(2)\n', '        ).sub(Decimal.one());\n', '    }\n', '\n', "    // 1/((1-R)(1-R'))-1\n", '    function curveMean(\n', '        Decimal.D256 memory lower,\n', '        Decimal.D256 memory upper\n', '    ) private pure returns (Decimal.D256 memory) {\n', '        if (lower.equals(upper)) {\n', '            return curve(lower);\n', '        }\n', '\n', '        return Decimal.one().div(\n', '            (Decimal.one().sub(upper)).mul(Decimal.one().sub(lower))\n', '        ).sub(Decimal.one());\n', '    }\n', '}\n', '\n', '// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/token/IDollar.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', 'contract IDollar is IERC20 {\n', '    function burn(uint256 amount) public;\n', '    function burnFrom(address account, uint256 amount) public;\n', '    function mint(address account, uint256 amount) public returns (bool);\n', '}\n', '\n', '// File: contracts/oracle/IOracle.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', 'contract IOracle {\n', '    function capture() public returns (Decimal.D256 memory, bool);\n', '}\n', '\n', '// File: contracts/dao/State.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Account {\n', '    enum Status {\n', '        Frozen,\n', '        Fluid,\n', '        Locked\n', '    }\n', '\n', '    struct State {\n', '        uint256 lockedUntil;\n', '\n', '        mapping(uint256 => uint256) coupons;\n', '        mapping(address => uint256) couponAllowances;\n', '    }\n', '\n', '    struct PoolState {\n', '        uint256 staged;\n', '        uint256 bonded;\n', '        uint256 fluidUntil;\n', '        uint256 rewardDebt;\n', '        uint256 shareDebt;\n', '    }\n', '}\n', '\n', 'contract Epoch {\n', '    struct Global {\n', '        uint256 start;\n', '        uint256 period;\n', '        uint256 current;\n', '    }\n', '\n', '    struct Coupons {\n', '        uint256 outstanding;\n', '        uint256 couponRedeemed;\n', '        uint256 vsdRedeemable;\n', '    }\n', '\n', '    struct State {\n', '        uint256 totalDollarSupply;\n', '        Coupons coupons;\n', '    }\n', '}\n', '\n', 'contract Candidate {\n', '    enum Vote {\n', '        UNDECIDED,\n', '        APPROVE,\n', '        REJECT\n', '    }\n', '\n', '    struct VoteInfo {\n', '        Vote vote;\n', '        uint256 bondedVotes;\n', '    }\n', '\n', '    struct State {\n', '        uint256 start;\n', '        uint256 period;\n', '        uint256 approve;\n', '        uint256 reject;\n', '        mapping(address => VoteInfo) votes;\n', '        bool initialized;\n', '    }\n', '}\n', '\n', 'contract Storage {\n', '    struct Provider {\n', '        IDollar dollar;\n', '        IOracle oracle;\n', '    }\n', '\n', '    struct Balance {\n', '        uint256 redeemable;\n', '        uint256 clippable;\n', '        uint256 debt;\n', '        uint256 coupons;\n', '    }\n', '\n', '    struct PoolInfo {\n', '        uint256 bonded;\n', '        uint256 staged;\n', '        mapping (address => Account.PoolState) accounts;\n', '        uint256 accDollarPerLP; // Accumulated dollar per LP token, times 1e18.\n', '        uint256 accSharePerLP; // Accumulated share per LP token, times 1e18.\n', '        uint256 allocPoint;\n', '        uint256 flags;\n', '    }\n', '\n', '    struct State {\n', '        Epoch.Global epoch;\n', '        Balance balance;\n', '        Provider provider;\n', '\n', '        /*\n', '         * Global state variable\n', '         */\n', '        uint256 totalAllocPoint;\n', '        uint256 collateralRatio;\n', '\n', '        mapping(uint256 => Epoch.State) epochs;\n', '        mapping(uint256 => Candidate.State) candidates;\n', '        mapping(address => Account.State) accounts;\n', '\n', '        mapping(address => PoolInfo) pools;\n', '        address[] poolList;\n', '\n', '        address[] collateralAssetList;\n', '    }\n', '}\n', '\n', 'contract State {\n', '    Storage.State _state;\n', '}\n', '\n', '// File: @uniswap/lib/contracts/libraries/Babylonian.sol\n', '\n', 'pragma solidity >=0.4.0;\n', '\n', '// computes square roots using the babylonian method\n', '// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n', 'library Babylonian {\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '        // else z = 0\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Getters.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Getters is State {\n', '    using SafeMath for uint256;\n', '    using Decimal for Decimal.D256;\n', '\n', '    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    /**\n', '     * ERC20 (only for snapshot voting)\n', '     */\n', '\n', '    function name() public view returns (string memory) {\n', '        return "Value Set Dollar Stake";\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return "VSDS";\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return balanceOfBondedDollar(account);\n', '    }\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalBondedDollar();\n', '    }\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256) {\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '     * Global\n', '     */\n', '\n', '    function dollar() public view returns (IDollar) {\n', '        return _state.provider.dollar;\n', '    }\n', '\n', '    function oracle() public view returns (IOracle) {\n', '        return _state.provider.oracle;\n', '    }\n', '\n', '    function usdc() public view returns (address) {\n', '        return Constants.getUsdcAddress();\n', '    }\n', '\n', '    function dai() public view returns (address) {\n', '        return Constants.getDaiAddress();\n', '    }\n', '\n', '    function totalBonded(address pool) public view returns (uint256) {\n', '        return _state.pools[pool].bonded;\n', '    }\n', '\n', '    function totalStaged(address pool) public view returns (uint256) {\n', '        return _state.pools[pool].staged;\n', '    }\n', '\n', '    function totalDebt() public view returns (uint256) {\n', '        return _state.balance.debt;\n', '    }\n', '\n', '    function totalRedeemable() public view returns (uint256) {\n', '        return _state.balance.redeemable;\n', '    }\n', '\n', '    function totalClippable() public view returns (uint256) {\n', '        return _state.balance.clippable;\n', '    }\n', '\n', '    function totalCoupons() public view returns (uint256) {\n', '        return _state.balance.coupons;\n', '    }\n', '\n', '    function totalNet() public view returns (uint256) {\n', '        return dollar().totalSupply().sub(totalDebt());\n', '    }\n', '\n', '    function totalBondedDollar() public view returns (uint256) {\n', '        uint256 len = _state.poolList.length;\n', '        uint256 bondedDollar = 0;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address pool = _state.poolList[i];\n', '            uint256 bondedLP = totalBonded(pool);\n', '            if (bondedLP == 0) {\n', '                continue;\n', '            }\n', '\n', '            (uint256 poolBonded, ) = _getDollarReserve(pool, bondedLP);\n', '\n', '            bondedDollar = bondedDollar.add(poolBonded);\n', '        }\n', '        return bondedDollar;\n', '    }\n', '\n', '    /**\n', '     * Account\n', '     */\n', '\n', '    function balanceOfStaged(address pool, address account) public view returns (uint256) {\n', '        return _state.pools[pool].accounts[account].staged;\n', '    }\n', '\n', '    function balanceOfBonded(address pool, address account) public view returns (uint256) {\n', '        return _state.pools[pool].accounts[account].bonded;\n', '    }\n', '\n', '    function balanceOfBondedDollar(address account) public view returns (uint256) {\n', '        uint256 len = _state.poolList.length;\n', '        uint256 bondedDollar = 0;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address pool = _state.poolList[i];\n', '            uint256 bondedLP = balanceOfBonded(pool, account);\n', '            if (bondedLP == 0) {\n', '                continue;\n', '            }\n', '\n', '            (uint256 reserve, ) = _getDollarReserve(pool, bondedLP);\n', '\n', '            bondedDollar = bondedDollar.add(reserve);\n', '        }\n', '        return bondedDollar;\n', '    }\n', '\n', '    function balanceOfCoupons(address account, uint256 epoch) public view returns (uint256) {\n', '        if (outstandingCoupons(epoch) == 0) {\n', '            return 0;\n', '        }\n', '        return _state.accounts[account].coupons[epoch];\n', '    }\n', '\n', '    function balanceOfClippable(address account, uint256 epoch) public view returns (uint256) {\n', '        if (redeemableVSDs(epoch) == 0) {\n', '            return 0;\n', '        }\n', '        return _state.accounts[account].coupons[epoch].mul(redeemableVSDs(epoch)).div(redeemedCoupons(epoch));\n', '    }\n', '\n', '    function statusOf(address pool, address account) public view returns (Account.Status) {\n', '        if (_state.accounts[account].lockedUntil > epoch()) {\n', '            return Account.Status.Locked;\n', '        }\n', '\n', '        return epoch() >= _state.pools[pool].accounts[account].fluidUntil ? Account.Status.Frozen : Account.Status.Fluid;\n', '    }\n', '\n', '    function fluidUntil(address pool, address account) public view returns (uint256) {\n', '        return _state.pools[pool].accounts[account].fluidUntil;\n', '    }\n', '\n', '    function lockedUntil(address account) public view returns (uint256) {\n', '        return _state.accounts[account].lockedUntil;\n', '    }\n', '\n', '    function allowanceCoupons(address owner, address spender) public view returns (uint256) {\n', '        return _state.accounts[owner].couponAllowances[spender];\n', '    }\n', '\n', '    function pendingReward(address pool) public view returns (uint256 pending) {\n', '        Storage.PoolInfo storage poolInfo = _state.pools[pool];\n', '        Account.PoolState storage user = poolInfo.accounts[msg.sender];\n', '\n', '        if (user.bonded > 0) {\n', '            pending = user.bonded.mul(poolInfo.accDollarPerLP).div(1e18).sub(user.rewardDebt);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Epoch\n', '     */\n', '\n', '    function epoch() public view returns (uint256) {\n', '        return _state.epoch.current;\n', '    }\n', '\n', '    function epochTime() public view returns (uint256) {\n', '        Constants.EpochStrategy memory current = Constants.getCurrentEpochStrategy();\n', '\n', '        return epochTimeWithStrategy(current);\n', '    }\n', '\n', '    function epochTimeWithStrategy(Constants.EpochStrategy memory strategy) private view returns (uint256) {\n', '        return blockTimestamp()\n', '            .sub(strategy.start)\n', '            .div(strategy.period)\n', '            .add(strategy.offset);\n', '    }\n', '\n', '    // Overridable for testing\n', '    function blockTimestamp() internal view returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '\n', '    function outstandingCoupons(uint256 epoch) public view returns (uint256) {\n', '        return _state.epochs[epoch].coupons.outstanding;\n', '    }\n', '\n', '    function redeemedCoupons(uint256 epoch) public view returns (uint256) {\n', '        return _state.epochs[epoch].coupons.couponRedeemed;\n', '    }\n', '\n', '    function redeemableVSDs(uint256 epoch) public view returns (uint256) {\n', '        return _state.epochs[epoch].coupons.vsdRedeemable;\n', '    }\n', '\n', '    function bootstrappingAt(uint256 epoch) public view returns (bool) {\n', '        return epoch <= Constants.getBootstrappingPeriod();\n', '    }\n', '\n', '    function totalDollarSupplyAt(uint256 epoch) public view returns (uint256) {\n', '        return _state.epochs[epoch].totalDollarSupply;\n', '    }\n', '\n', '    /**\n', '     * Governance\n', '     */\n', '\n', '    function recordedVoteInfo(address account, uint256 candidate) public view returns (Candidate.VoteInfo memory) {\n', '        return _state.candidates[candidate].votes[account];\n', '    }\n', '\n', '    function startFor(uint256 candidate) public view returns (uint256) {\n', '        return _state.candidates[candidate].start;\n', '    }\n', '\n', '    function periodFor(uint256 candidate) public view returns (uint256) {\n', '        return _state.candidates[candidate].period;\n', '    }\n', '\n', '    function approveFor(uint256 candidate) public view returns (uint256) {\n', '        return _state.candidates[candidate].approve;\n', '    }\n', '\n', '    function rejectFor(uint256 candidate) public view returns (uint256) {\n', '        return _state.candidates[candidate].reject;\n', '    }\n', '\n', '    function votesFor(uint256 candidate) public view returns (uint256) {\n', '        return approveFor(candidate).add(rejectFor(candidate));\n', '    }\n', '\n', '    function isNominated(uint256 candidate) public view returns (bool) {\n', '        return _state.candidates[candidate].start > 0;\n', '    }\n', '\n', '    function isInitialized(uint256 candidate) public view returns (bool) {\n', '        return _state.candidates[candidate].initialized;\n', '    }\n', '\n', '    function implementation() public view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Collateral\n', '     */\n', '\n', '    function _getDollarReserve(address pool, uint256 bonded) internal view returns (uint256 reserve, uint256 totalReserve) {\n', '        (uint256 reserve0, uint256 reserve1,) = IUniswapV2Pair(pool).getReserves();\n', '        if (IUniswapV2Pair(pool).token0() == address(dollar())) {\n', '            totalReserve = reserve0;\n', '        } else {\n', '            require(IUniswapV2Pair(pool).token1() == address(dollar()), "the pool does not contain dollar");\n', '            totalReserve = reserve1;\n', '        }\n', '\n', '        if (bonded == 0) {\n', '            return (0, totalReserve);\n', '        }\n', '\n', '        reserve = totalReserve.mul(bonded).div(IUniswapV2Pair(pool).totalSupply());\n', '    }\n', '\n', '    function _getSellAndReturnAmount(\n', '        uint256 price,\n', '        uint256 targetPrice,\n', '        uint256 reserve\n', '    ) internal pure returns (uint256 sellAmount, uint256 returnAmount) {\n', '        // price in resolution 1e18\n', '        sellAmount = 0;\n', '        returnAmount = 0;\n', '\n', '        uint256 rootPoT = Babylonian.sqrt(price.mul(1e36).div(targetPrice));\n', '        if (rootPoT > 1e18) { // res error\n', '            sellAmount = (rootPoT - 1e18).mul(reserve).div(1e18);\n', '        }\n', '\n', '        uint256 rootPT = Babylonian.sqrt(price.mul(targetPrice));\n', '        if (price > rootPT) { // res error\n', '            returnAmount = (price - rootPT).mul(reserve).div(1e18);\n', '        }\n', '        if (sellAmount > returnAmount) { // res error\n', '            sellAmount = returnAmount;\n', '        }\n', '    }\n', '\n', '    function _getBuyAmount(uint256 price, uint256 targetPrice, uint256 reserve) internal pure returns (uint256 shouldBuy) {\n', '        shouldBuy = 0;\n', '\n', '        uint256 root = Babylonian.sqrt(price.mul(1e36).div(targetPrice));\n', '        if (root < 1e18) { // res error\n', '            shouldBuy = (1e18 - root).mul(reserve).div(1e18);\n', '        }\n', '    }\n', '\n', '    function getCollateralRatio() internal view returns (uint256) {\n', '        return _state.collateralRatio;\n', '    }\n', '}\n', '\n', '// File: contracts/external/UniswapV2Library.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', '\n', '\n', 'library UniswapV2Library {\n', '    using SafeMath for uint;\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // calculates the CREATE2 address for a pair without making any external calls\n', '    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        pair = address(uint(keccak256(abi.encodePacked(\n', "                hex'ff',\n", '                factory,\n', '                keccak256(abi.encodePacked(token0, token1)),\n', "                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\n", '            ))));\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = amountA.mul(reserveB) / reserveA;\n', '    }\n', '\n', '    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = amountIn.mul(997);\n', '        uint numerator = amountInWithFee.mul(reserveOut);\n', '        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following \n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Setters.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <emptysetsqu[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Setters is State, Getters {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    event Claim(address indexed pool, address indexed account, uint256 value);\n', '\n', '    /**\n', '     * Global\n', '     */\n', '\n', '    function incrementTotalDebt(uint256 amount) internal {\n', '        _state.balance.debt = _state.balance.debt.add(amount);\n', '    }\n', '\n', '    function decrementTotalDebt(uint256 amount) internal {\n', '        _state.balance.debt = _state.balance.debt.sub(amount);\n', '    }\n', '\n', '    function incrementTotalRedeemable(uint256 amount) internal {\n', '        _state.balance.redeemable = _state.balance.redeemable.add(amount);\n', '    }\n', '\n', '    function decrementTotalRedeemable(uint256 amount) internal {\n', '        _state.balance.redeemable = _state.balance.redeemable.sub(amount);\n', '    }\n', '\n', '    function decrementTotalClippable(uint256 amount) internal {\n', '        _state.balance.clippable = _state.balance.clippable.sub(amount);\n', '    }\n', '\n', '    function incrementTotalClippable(uint256 amount) internal {\n', '        _state.balance.clippable = _state.balance.clippable.add(amount);\n', '    }\n', '\n', '    /**\n', '     * Account\n', '     */\n', '\n', '    function incrementBalanceOfBonded(address pool, address account, uint256 amount) internal {\n', '        _state.pools[pool].accounts[account].bonded = _state.pools[pool].accounts[account].bonded.add(amount);\n', '        _state.pools[pool].bonded = _state.pools[pool].bonded.add(amount);\n', '    }\n', '\n', '    function decrementBalanceOfBonded(address pool, address account, uint256 amount) internal {\n', '        _state.pools[pool].accounts[account].bonded = _state.pools[pool].accounts[account].bonded.sub(amount);\n', '        _state.pools[pool].bonded = _state.pools[pool].bonded.sub(amount);\n', '    }\n', '\n', '    function incrementBalanceOfStaged(address pool, address account, uint256 amount) internal {\n', '        _state.pools[pool].accounts[account].staged = _state.pools[pool].accounts[account].staged.add(amount);\n', '        _state.pools[pool].staged = _state.pools[pool].staged.add(amount);\n', '    }\n', '\n', '    function decrementBalanceOfStaged(address pool, address account, uint256 amount) internal {\n', '        _state.pools[pool].accounts[account].staged = _state.pools[pool].accounts[account].staged.sub(amount);\n', '        _state.pools[pool].staged = _state.pools[pool].staged.sub(amount);\n', '    }\n', '\n', '    function incrementBalanceOfCoupons(address account, uint256 epoch, uint256 amount) internal {\n', '        _state.accounts[account].coupons[epoch] = _state.accounts[account].coupons[epoch].add(amount);\n', '        _state.epochs[epoch].coupons.outstanding = _state.epochs[epoch].coupons.outstanding.add(amount);\n', '        _state.balance.coupons = _state.balance.coupons.add(amount);\n', '    }\n', '\n', '    function decrementBalanceOfCoupons(address account, uint256 epoch, uint256 amount) internal {\n', '        _state.accounts[account].coupons[epoch] = _state.accounts[account].coupons[epoch].sub(amount);\n', '        _state.epochs[epoch].coupons.outstanding = _state.epochs[epoch].coupons.outstanding.sub(amount);\n', '        _state.balance.coupons = _state.balance.coupons.sub(amount);\n', '    }\n', '\n', '    function clipRedeemedCoupon(address account, uint256 epoch) internal returns (uint256 vsdRedeemable) {\n', '        uint256 couponRedeemed = _state.accounts[account].coupons[epoch];\n', '        _state.accounts[account].coupons[epoch] = 0;\n', '        // require(_state.epochs[epoch].coupons.outstanding == 0);\n', '        vsdRedeemable = _state.epochs[epoch].coupons.vsdRedeemable.mul(couponRedeemed).div(_state.epochs[epoch].coupons.couponRedeemed);\n', '    }\n', '\n', '    function unfreeze(address pool, address account) internal {\n', '        _state.pools[pool].accounts[account].fluidUntil = epoch().add(Constants.getDAOExitLockupEpochs());\n', '    }\n', '\n', '    function updateAllowanceCoupons(address owner, address spender, uint256 amount) internal {\n', '        _state.accounts[owner].couponAllowances[spender] = amount;\n', '    }\n', '\n', '    function decrementAllowanceCoupons(address owner, address spender, uint256 amount) internal {\n', '        _state.accounts[owner].couponAllowances[spender] =\n', '            _state.accounts[owner].couponAllowances[spender].sub(amount);\n', '    }\n', '\n', '    /**\n', '     * Epoch\n', '     */\n', '\n', '    function incrementEpoch() internal {\n', '        _state.epoch.current = _state.epoch.current.add(1);\n', '    }\n', '\n', '    function snapshotDollarTotalSupply() internal {\n', '        _state.epochs[epoch()].totalDollarSupply = dollar().totalSupply();\n', '    }\n', '\n', '    function redeemOutstandingCoupons(uint256 epoch) internal returns (uint256 couponRedeemed, uint256 vsdRedeemable) {\n', '        uint256 outstandingCouponsForEpoch = outstandingCoupons(epoch);\n', '        if(outstandingCouponsForEpoch == 0) {\n', '            return (0, 0);\n', '        }\n', '        _state.balance.coupons = _state.balance.coupons.sub(outstandingCouponsForEpoch);\n', '\n', '        uint256 totalRedeemable = totalRedeemable();\n', '        vsdRedeemable = outstandingCouponsForEpoch;\n', '        couponRedeemed = outstandingCouponsForEpoch;\n', '        if (totalRedeemable < vsdRedeemable) {\n', '            // Partial redemption\n', '            vsdRedeemable = totalRedeemable;\n', '        }\n', '\n', '        _state.epochs[epoch].coupons.couponRedeemed = outstandingCouponsForEpoch;\n', '        _state.epochs[epoch].coupons.vsdRedeemable = vsdRedeemable;\n', '        _state.epochs[epoch].coupons.outstanding = 0;\n', '    }\n', '\n', '    /**\n', '     * Governance\n', '     */\n', '\n', '    function createCandidate(uint256 candidate, uint256 period) internal {\n', '        _state.candidates[candidate].start = epoch();\n', '        _state.candidates[candidate].period = period;\n', '    }\n', '\n', '    function recordVoteInfo(address account, uint256 candidate, Candidate.VoteInfo memory voteInfo) internal {\n', '        _state.candidates[candidate].votes[account] = voteInfo;\n', '    }\n', '\n', '    function incrementApproveFor(uint256 candidate, uint256 amount) internal {\n', '        _state.candidates[candidate].approve = _state.candidates[candidate].approve.add(amount);\n', '    }\n', '\n', '    function decrementApproveFor(uint256 candidate, uint256 amount) internal {\n', '        _state.candidates[candidate].approve = _state.candidates[candidate].approve.sub(amount);\n', '    }\n', '\n', '    function incrementRejectFor(uint256 candidate, uint256 amount) internal {\n', '        _state.candidates[candidate].reject = _state.candidates[candidate].reject.add(amount);\n', '    }\n', '\n', '    function decrementRejectFor(uint256 candidate, uint256 amount) internal {\n', '        _state.candidates[candidate].reject = _state.candidates[candidate].reject.sub(amount);\n', '    }\n', '\n', '    function placeLock(address account, uint256 candidate) internal {\n', '        uint256 currentLock = _state.accounts[account].lockedUntil;\n', '        uint256 newLock = startFor(candidate).add(periodFor(candidate));\n', '        if (newLock > currentLock) {\n', '            _state.accounts[account].lockedUntil = newLock;\n', '        }\n', '    }\n', '\n', '    function initialized(uint256 candidate) internal {\n', '        _state.candidates[candidate].initialized = true;\n', '    }\n', '\n', '    /**\n', '     * Pool\n', '     */\n', '\n', '    function _addPool(address pool) internal {\n', '        uint256 len = _state.poolList.length;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            require(pool != _state.poolList[i], "Must not be added");\n', '        }\n', '\n', '        _state.pools[pool].flags = 0x1; // enable flag\n', '        _state.poolList.push(pool);\n', '    }\n', '\n', '    function preClaimDollar(address pool) internal {\n', '        Storage.PoolInfo storage poolInfo = _state.pools[pool];\n', '        Account.PoolState storage user = poolInfo.accounts[msg.sender];\n', '        require((poolInfo.flags & 0x1) == 0x1, "pool is disabled");\n', '\n', '        if (user.bonded > 0) {\n', '            uint256 pending = user.bonded.mul(poolInfo.accDollarPerLP).div(1e18).sub(user.rewardDebt);\n', '            if (pending > 0) {\n', '                // Safe transfer to avoid resolution error.\n', '                uint256 balance = dollar().balanceOf(address(this));\n', '                if (pending > balance) {\n', '                    pending = balance;\n', '                }\n', '                dollar().transfer(msg.sender, pending);\n', '\n', '                emit Claim(msg.sender, pool, pending);\n', '            }\n', '        }\n', '    }\n', '\n', '    function postClaimDollar(address pool) internal {\n', '        Storage.PoolInfo storage poolInfo = _state.pools[pool];\n', '        Account.PoolState storage user = poolInfo.accounts[msg.sender];\n', '\n', '        user.rewardDebt = user.bonded.mul(poolInfo.accDollarPerLP).div(1e18);\n', '    }\n', '\n', '    function _addLiquidity(address pool, address token, address anotherToken, uint256 amount) internal returns (uint256) {\n', '        address token0 = IUniswapV2Pair(pool).token0();\n', '        address token1 = IUniswapV2Pair(pool).token1();\n', '        require(token == token0 || token == token1, "token must in pool");\n', '        require(anotherToken == token0 || anotherToken == token1, "atoken must in pool");\n', '\n', '        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pool).getReserves();\n', '        (uint256 reserveToken, uint256 reserveAnother) = token == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '\n', '        uint256 anotherAmount = UniswapV2Library.quote(amount, reserveToken, reserveAnother); // throw if reserve is zero\n', '\n', '        IERC20(token).safeTransferFrom(msg.sender, pool, amount);\n', '        IERC20(anotherToken).safeTransferFrom(msg.sender, pool, anotherAmount);\n', '        return IUniswapV2Pair(pool).mint(address(this));\n', '    }\n', '\n', '    function _sellAndDepositCollateral(uint256 totalSellAmount, uint256 allReserve) internal {\n', '        if (totalSellAmount == 0 || allReserve == 0) {\n', '            return;\n', '        }\n', '\n', '        dollar().mint(address(this), totalSellAmount);\n', '        uint256 len = _state.poolList.length;\n', '        uint256 actualSold = 0;\n', '        // Sell to pools according to their reserves\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address pool = _state.poolList[i];\n', '            address token0 = IUniswapV2Pair(pool).token0();\n', '            (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pool).getReserves();\n', '\n', '            uint256 reserveA = token0 == address(dollar()) ? reserve0 : reserve1;\n', '            uint256 reserveB = token0 == address(dollar()) ? reserve1 : reserve0;\n', '\n', '            uint256 sellAmount = totalSellAmount\n', '                .mul(reserveA)\n', '                .div(allReserve);\n', '            actualSold = actualSold.add(sellAmount);\n', '\n', '            if (reserveA == 0 || sellAmount == 0) {\n', '                // The pool is not ready yet or insufficient lp in pool.\n', '                continue;\n', '            }\n', '\n', '            uint256 assetAmount = UniswapV2Library.getAmountOut(\n', '                sellAmount,\n', '                reserveA,\n', '                reserveB\n', '            );\n', '\n', '            dollar().transfer(pool, sellAmount);\n', '\n', '            // Non-Reentrancy?\n', '            IUniswapV2Pair(pool).swap(\n', '                token0 == address(dollar()) ? 0 : assetAmount,\n', '                token0 == address(dollar()) ? assetAmount : 0,\n', '                address(this),\n', '                new bytes(0)\n', '            );\n', '        }\n', '\n', "        // Make sure we don't sell extra\n", '        assert(actualSold <= totalSellAmount);\n', '    }\n', '\n', '    /**\n', '     * Collateral\n', '     */\n', '\n', '    function _addCollateral(address asset) internal {\n', '        uint256 len = _state.collateralAssetList.length;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            require(asset != _state.collateralAssetList[i], "Must not be added");\n', '        }\n', '\n', '        _state.collateralAssetList.push(asset);\n', '    }\n', '}\n', '\n', '// File: contracts/external/Require.sol\n', '\n', '/*\n', '    Copyright 2019 dYdX Trading Inc.\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.7;\n', '\n', '/**\n', ' * @title Require\n', ' * @author dYdX\n', ' *\n', ' * Stringifies parameters to pretty-print revert messages. Costs more gas than regular require()\n', ' */\n', 'library Require {\n', '\n', '    // ============ Constants ============\n', '\n', "    uint256 constant ASCII_ZERO = 48; // '0'\n", "    uint256 constant ASCII_RELATIVE_ZERO = 87; // 'a' - 10\n", "    uint256 constant ASCII_LOWER_EX = 120; // 'x'\n", "    bytes2 constant COLON = 0x3a20; // ': '\n", "    bytes2 constant COMMA = 0x2c20; // ', '\n", "    bytes2 constant LPAREN = 0x203c; // ' <'\n", "    byte constant RPAREN = 0x3e; // '>'\n", '    uint256 constant FOUR_BIT_MASK = 0xf;\n', '\n', '    // ============ Library Functions ============\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringifyTruncated(file),\n', '                        COLON,\n', '                        stringifyTruncated(reason)\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        uint256 payloadA\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringifyTruncated(file),\n', '                        COLON,\n', '                        stringifyTruncated(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        uint256 payloadA,\n', '        uint256 payloadB\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringifyTruncated(file),\n', '                        COLON,\n', '                        stringifyTruncated(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        COMMA,\n', '                        stringify(payloadB),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        address payloadA\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringifyTruncated(file),\n', '                        COLON,\n', '                        stringifyTruncated(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        address payloadA,\n', '        uint256 payloadB\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringifyTruncated(file),\n', '                        COLON,\n', '                        stringifyTruncated(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        COMMA,\n', '                        stringify(payloadB),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        address payloadA,\n', '        uint256 payloadB,\n', '        uint256 payloadC\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringifyTruncated(file),\n', '                        COLON,\n', '                        stringifyTruncated(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        COMMA,\n', '                        stringify(payloadB),\n', '                        COMMA,\n', '                        stringify(payloadC),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        bytes32 payloadA\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringifyTruncated(file),\n', '                        COLON,\n', '                        stringifyTruncated(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    function that(\n', '        bool must,\n', '        bytes32 file,\n', '        bytes32 reason,\n', '        bytes32 payloadA,\n', '        uint256 payloadB,\n', '        uint256 payloadC\n', '    )\n', '    internal\n', '    pure\n', '    {\n', '        if (!must) {\n', '            revert(\n', '                string(\n', '                    abi.encodePacked(\n', '                        stringifyTruncated(file),\n', '                        COLON,\n', '                        stringifyTruncated(reason),\n', '                        LPAREN,\n', '                        stringify(payloadA),\n', '                        COMMA,\n', '                        stringify(payloadB),\n', '                        COMMA,\n', '                        stringify(payloadC),\n', '                        RPAREN\n', '                    )\n', '                )\n', '            );\n', '        }\n', '    }\n', '\n', '    // ============ Private Functions ============\n', '\n', '    function stringifyTruncated(\n', '        bytes32 input\n', '    )\n', '    private\n', '    pure\n', '    returns (bytes memory)\n', '    {\n', '        // put the input bytes into the result\n', '        bytes memory result = abi.encodePacked(input);\n', '\n', '        // determine the length of the input by finding the location of the last non-zero byte\n', '        for (uint256 i = 32; i > 0; ) {\n', '            // reverse-for-loops with unsigned integer\n', '            /* solium-disable-next-line security/no-modify-for-iter-var */\n', '            i--;\n', '\n', '            // find the last non-zero byte in order to determine the length\n', '            if (result[i] != 0) {\n', '                uint256 length = i + 1;\n', '\n', '                /* solium-disable-next-line security/no-inline-assembly */\n', '                assembly {\n', '                    mstore(result, length) // r.length = length;\n', '                }\n', '\n', '                return result;\n', '            }\n', '        }\n', '\n', '        // all bytes are zero\n', '        return new bytes(0);\n', '    }\n', '\n', '    function stringify(\n', '        uint256 input\n', '    )\n', '    private\n', '    pure\n', '    returns (bytes memory)\n', '    {\n', '        if (input == 0) {\n', '            return "0";\n', '        }\n', '\n', '        // get the final string length\n', '        uint256 j = input;\n', '        uint256 length;\n', '        while (j != 0) {\n', '            length++;\n', '            j /= 10;\n', '        }\n', '\n', '        // allocate the string\n', '        bytes memory bstr = new bytes(length);\n', '\n', '        // populate the string starting with the least-significant character\n', '        j = input;\n', '        for (uint256 i = length; i > 0; ) {\n', '            // reverse-for-loops with unsigned integer\n', '            /* solium-disable-next-line security/no-modify-for-iter-var */\n', '            i--;\n', '\n', '            // take last decimal digit\n', '            bstr[i] = byte(uint8(ASCII_ZERO + (j % 10)));\n', '\n', '            // remove the last decimal digit\n', '            j /= 10;\n', '        }\n', '\n', '        return bstr;\n', '    }\n', '\n', '    function stringify(\n', '        address input\n', '    )\n', '    private\n', '    pure\n', '    returns (bytes memory)\n', '    {\n', '        uint256 z = uint256(input);\n', '\n', '        // addresses are "0x" followed by 20 bytes of data which take up 2 characters each\n', '        bytes memory result = new bytes(42);\n', '\n', '        // populate the result with "0x"\n', '        result[0] = byte(uint8(ASCII_ZERO));\n', '        result[1] = byte(uint8(ASCII_LOWER_EX));\n', '\n', '        // for each byte (starting from the lowest byte), populate the result with two characters\n', '        for (uint256 i = 0; i < 20; i++) {\n', '            // each byte takes two characters\n', '            uint256 shift = i * 2;\n', '\n', '            // populate the least-significant character\n', '            result[41 - shift] = char(z & FOUR_BIT_MASK);\n', '            z = z >> 4;\n', '\n', '            // populate the most-significant character\n', '            result[40 - shift] = char(z & FOUR_BIT_MASK);\n', '            z = z >> 4;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function stringify(\n', '        bytes32 input\n', '    )\n', '    private\n', '    pure\n', '    returns (bytes memory)\n', '    {\n', '        uint256 z = uint256(input);\n', '\n', '        // bytes32 are "0x" followed by 32 bytes of data which take up 2 characters each\n', '        bytes memory result = new bytes(66);\n', '\n', '        // populate the result with "0x"\n', '        result[0] = byte(uint8(ASCII_ZERO));\n', '        result[1] = byte(uint8(ASCII_LOWER_EX));\n', '\n', '        // for each byte (starting from the lowest byte), populate the result with two characters\n', '        for (uint256 i = 0; i < 32; i++) {\n', '            // each byte takes two characters\n', '            uint256 shift = i * 2;\n', '\n', '            // populate the least-significant character\n', '            result[65 - shift] = char(z & FOUR_BIT_MASK);\n', '            z = z >> 4;\n', '\n', '            // populate the most-significant character\n', '            result[64 - shift] = char(z & FOUR_BIT_MASK);\n', '            z = z >> 4;\n', '        }\n', '\n', '        return result;\n', '    }\n', '\n', '    function char(\n', '        uint256 input\n', '    )\n', '    private\n', '    pure\n', '    returns (byte)\n', '    {\n', '        // return ASCII digit (0-9)\n', '        if (input < 10) {\n', '            return byte(uint8(input + ASCII_ZERO));\n', '        }\n', '\n', '        // return ASCII letter (a-f)\n', '        return byte(uint8(input + ASCII_RELATIVE_ZERO));\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Comptroller.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', 'contract Comptroller is Setters {\n', '    using SafeMath for uint256;\n', '\n', '    bytes32 private constant FILE = "Comptroller";\n', '\n', '    function mintToAccount(address account, uint256 amount) internal {\n', '        dollar().mint(account, amount);\n', '        increaseDebt(amount);\n', '\n', '        balanceCheck();\n', '    }\n', '\n', '    function burnFromAccount(address account, uint256 amount) internal {\n', '        burnFromAccountForDebt(account, amount, amount);\n', '    }\n', '\n', '    function burnFromAccountForDebt(address account, uint256 amount, uint256 debtAmount) internal {\n', '        dollar().transferFrom(account, address(this), amount);\n', '        dollar().burn(amount);\n', '        decrementTotalDebt(debtAmount);\n', '\n', '        balanceCheck();\n', '    }\n', '    \n', '    function clipToAccount(address account, uint256 amount) internal {\n', '        dollar().transfer(account, amount);\n', '        decrementTotalClippable(amount);\n', '\n', '        balanceCheck();\n', '    }\n', '\n', '    function redeemToClippable(uint256 amount) internal {\n', '        decrementTotalRedeemable(amount);\n', '        incrementTotalClippable(amount);\n', '\n', '        balanceCheck();\n', '    }\n', '\n', '    function setDebt(uint256 amount) internal returns (uint256) {\n', '        _state.balance.debt = amount;\n', '        uint256 lessDebt = resetDebt(Constants.getDebtRatioCap());\n', '\n', '        balanceCheck();\n', '\n', '        return lessDebt > amount ? 0 : amount.sub(lessDebt);\n', '    }\n', '\n', '    function increaseDebt(uint256 amount) internal returns (uint256) {\n', '        incrementTotalDebt(amount);\n', '        uint256 lessDebt = resetDebt(Constants.getDebtRatioCap());\n', '\n', '        balanceCheck();\n', '\n', '        return lessDebt > amount ? 0 : amount.sub(lessDebt);\n', '    }\n', '\n', '    function decreaseDebt(uint256 amount) internal {\n', '        decrementTotalDebt(amount);\n', '\n', '        balanceCheck();\n', '    }\n', '\n', '    function _updateReserve() internal returns (uint256 allReserve) {\n', '        uint256 totalAllocPoint = 0;\n', '        uint256 len = _state.poolList.length;\n', '        allReserve = 0;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address pool = _state.poolList[i];\n', '            Storage.PoolInfo storage poolInfo = _state.pools[pool];\n', '\n', '            uint256 poolReserve;\n', '            (poolInfo.allocPoint, poolReserve) = _getDollarReserve(pool, _state.pools[pool].bonded);\n', '            totalAllocPoint = totalAllocPoint.add(poolInfo.allocPoint);\n', '            allReserve = allReserve.add(poolReserve);\n', '        }\n', '        _state.totalAllocPoint = totalAllocPoint;\n', '    }\n', '\n', '    function increaseSupply(uint256 newSupply) internal returns (uint256, uint256, uint256) {\n', '        // 0. Pay out to Fund\n', '        uint256 rewards = newSupply.mul(getSupplyIncreaseFundRatio()).div(10000);\n', '        uint256 devReward = rewards.mul(Constants.getFundDevPct()).div(100);\n', '        uint256 treasuryReward = rewards.sub(devReward);\n', '        if (devReward != 0) {\n', '            dollar().mint(Constants.getDevAddress(), devReward);\n', '        }\n', '        if (treasuryReward != 0) {\n', '            dollar().mint(Constants.getTreasuryAddress(), treasuryReward);\n', '        }\n', '\n', '        newSupply = newSupply > rewards ? newSupply.sub(rewards) : 0;\n', '\n', '        // 1. True up redeemable pool\n', '        uint256 newRedeemable = 0;\n', '        uint256 totalRedeemable = totalRedeemable();\n', '        uint256 totalCoupons = totalCoupons();\n', '        if (totalRedeemable < totalCoupons) {\n', '            newRedeemable = totalCoupons.sub(totalRedeemable);\n', '            newRedeemable = newRedeemable > newSupply ? newSupply : newRedeemable;\n', '            mintToRedeemable(newRedeemable);\n', '            newSupply = newSupply.sub(newRedeemable);\n', '        }\n', '\n', '        // 2. Payout to LPs\n', '        if (!mintToLPs(newSupply)) {\n', '            newSupply = 0;\n', '        }\n', '\n', '        balanceCheck();\n', '\n', '        return (newRedeemable, newSupply.add(rewards), newSupply);\n', '    }\n', '\n', '    function resetDebt(Decimal.D256 memory targetDebtRatio) internal returns (uint256) {\n', '        uint256 targetDebt = targetDebtRatio.mul(dollar().totalSupply()).asUint256();\n', '        uint256 currentDebt = totalDebt();\n', '\n', '        if (currentDebt > targetDebt) {\n', '            uint256 lessDebt = currentDebt.sub(targetDebt);\n', '            decreaseDebt(lessDebt);\n', '\n', '            return lessDebt;\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    function balanceCheck() private {\n', '        // Require.that(\n', '        //     dollar().balanceOf(address(this)) >= totalBonded().add(totalStaged()).add(totalRedeemable()).add(totalClippable()),\n', '        //     FILE,\n', '        //     "Inconsistent balances"\n', '        // );\n', '    }\n', '\n', '    function mintToLPs(uint256 amount) private returns (bool) {\n', '        if (amount == 0) {\n', '            return false;\n', '        }\n', '\n', '        if (_state.totalAllocPoint == 0) {\n', '            return false;\n', '        }\n', '\n', '        dollar().mint(address(this), amount);\n', '        uint256 len = _state.poolList.length;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address pool = _state.poolList[i];\n', '            Storage.PoolInfo storage poolInfo = _state.pools[pool];\n', '\n', '            if (poolInfo.bonded == 0) {\n', '                continue;\n', '            }\n', '            uint256 poolAmount = amount.mul(poolInfo.allocPoint).div(_state.totalAllocPoint);\n', '            poolInfo.accDollarPerLP = poolInfo.accDollarPerLP.add(poolAmount.mul(1e18).div(poolInfo.bonded));\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function mintToRedeemable(uint256 amount) private {\n', '        dollar().mint(address(this), amount);\n', '        incrementTotalRedeemable(amount);\n', '\n', '        balanceCheck();\n', '    }\n', '\n', '    /* for testing purpose */\n', '    function getSupplyIncreaseFundRatio() internal view returns (uint256) {\n', '        return Constants.getSupplyIncreaseFundRatio();\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Market.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Market is Comptroller, Curve {\n', '    using SafeMath for uint256;\n', '\n', '    bytes32 private constant FILE = "Market";\n', '\n', '    event CouponRedemption(uint256 indexed epoch, uint256 couponRedeemed, uint256 vsdRedeemable);\n', '    event CouponPurchase(address indexed account, uint256 indexed epochExpire, uint256 dollarAmount, uint256 couponAmount);\n', '    event CouponClip(address indexed account, uint256 indexed epoch, uint256 couponAmount);\n', '    event CouponTransfer(address indexed from, address indexed to, uint256 indexed epoch, uint256 value);\n', '    event CouponApproval(address indexed owner, address indexed spender, uint256 value);\n', '    event CouponExtended(address indexed owner, uint256 indexed epoch, uint256 couponAmount, uint256 newCouponAmount, uint256 newExpiration);\n', '\n', '    function step() internal {\n', '        // Automatically redeem prior coupons\n', '        redeemCouponsForEpoch(epoch());\n', '    }\n', '\n', '    function redeemCouponsForEpoch(uint256 epoch) private {\n', '        (uint256 couponRedeemed, uint256 vsdRedeemable) = redeemOutstandingCoupons(epoch);\n', '\n', '        redeemToClippable(vsdRedeemable);\n', '\n', '        emit CouponRedemption(epoch, couponRedeemed, vsdRedeemable);\n', '    }\n', '\n', '    function couponPremium(uint256 amount) public view returns (uint256) {\n', '        return calculateCouponPremium(dollar().totalSupply(), totalDebt(), amount);\n', '    }\n', '\n', '    function purchaseCoupons(uint256 dollarAmount) external returns (uint256) {\n', '        Require.that(\n', '            dollarAmount > 0,\n', '            FILE,\n', '            "Must purchase non-zero amount"\n', '        );\n', '\n', '        Require.that(\n', '            totalDebt() >= dollarAmount,\n', '            FILE,\n', '            "Not enough debt"\n', '        );\n', '\n', '        uint256 epoch = epoch();\n', '        uint256 couponAmount = dollarAmount.add(couponPremium(dollarAmount));\n', '        burnFromAccount(msg.sender, dollarAmount);\n', '        incrementBalanceOfCoupons(msg.sender, epoch.add(Constants.getCouponExpiration()), couponAmount);\n', '\n', '        emit CouponPurchase(msg.sender, epoch.add(Constants.getCouponExpiration()), dollarAmount, couponAmount);\n', '\n', '        return couponAmount;\n', '    }\n', '\n', '    /*\n', '     * @dev Extend the expiration of a coupon by VSDs.\n', '     */\n', '    function extendCoupon(uint256 couponExpireEpoch, uint256 couponAmount, uint256 dollarAmount) external {\n', '        Require.that(\n', '            dollarAmount > 0,\n', '            FILE,\n', '            "Must purchase non-zero amount"\n', '        );\n', '\n', '        uint256 epoch = epoch();\n', '\n', '        decrementBalanceOfCoupons(msg.sender, couponExpireEpoch, couponAmount);\n', '        uint256 liveness = couponAmount.mul(couponExpireEpoch.sub(epoch));\n', '\n', '        uint256 debtAmount = totalDebt();\n', '        if (debtAmount > dollarAmount) {\n', '            debtAmount = dollarAmount;\n', '        }\n', '        burnFromAccountForDebt(msg.sender, dollarAmount, debtAmount);\n', '\n', '        liveness = liveness.add(dollarAmount.mul(Constants.getCouponExpiration()));\n', '\n', '        uint256 newExpiration = liveness.div(couponAmount).add(epoch);\n', '        Require.that(\n', '            newExpiration > epoch,\n', '            FILE,\n', '            "Must new exp. > current epoch"\n', '        );\n', '\n', '        incrementBalanceOfCoupons(msg.sender, newExpiration, couponAmount);\n', '        emit CouponExtended(msg.sender, couponExpireEpoch, couponAmount, couponAmount, newExpiration);\n', '    }\n', '\n', '    function clipCoupons(uint256 couponExpireEpoch) external {\n', '        Require.that(\n', '            outstandingCoupons(couponExpireEpoch) == 0,\n', '            FILE,\n', '            "Coupon is not redeemed"\n', '        );\n', '        uint256 vsdAmount = clipRedeemedCoupon(msg.sender, couponExpireEpoch);\n', '        clipToAccount(msg.sender, vsdAmount);\n', '\n', '        emit CouponClip(msg.sender, couponExpireEpoch, vsdAmount);\n', '    }\n', '\n', '    function approveCoupons(address spender, uint256 amount) external {\n', '        Require.that(\n', '            spender != address(0),\n', '            FILE,\n', '            "Coupon approve to 0x0"\n', '        );\n', '\n', '        updateAllowanceCoupons(msg.sender, spender, amount);\n', '\n', '        emit CouponApproval(msg.sender, spender, amount);\n', '    }\n', '\n', '    function transferCoupons(address sender, address recipient, uint256 epoch, uint256 amount) external {\n', '        Require.that(\n', '            sender != address(0),\n', '            FILE,\n', '            "Coupon transfer from 0x0"\n', '        );\n', '        Require.that(\n', '            recipient != address(0),\n', '            FILE,\n', '            "Coupon transfer to 0x0"\n', '        );\n', '\n', '        decrementBalanceOfCoupons(sender, epoch, amount);\n', '        incrementBalanceOfCoupons(recipient, epoch, amount);\n', '\n', '        if (msg.sender != sender && allowanceCoupons(sender, msg.sender) != uint256(-1)) {\n', '            decrementAllowanceCoupons(sender, msg.sender, amount);\n', '        }\n', '\n', '        emit CouponTransfer(sender, recipient, epoch, amount);\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Regulator.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Regulator is Comptroller {\n', '    using SafeMath for uint256;\n', '    using Decimal for Decimal.D256;\n', '\n', '    event SupplyIncrease(uint256 indexed epoch, uint256 price, uint256 newSell, uint256 newRedeemable, uint256 lessDebt, uint256 newSupply, uint256 newReward);\n', '    event SupplyDecrease(uint256 indexed epoch, uint256 price, uint256 newDebt);\n', '    event SupplyNeutral(uint256 indexed epoch);\n', '\n', '    function step() internal {\n', '        Decimal.D256 memory price = oracleCapture();\n', '\n', '        uint256 allReserve = _updateReserve();\n', '\n', '        if (price.greaterThan(Decimal.D256({value: getSupplyIncreasePriceThreshold()}))) {\n', '            growSupply(price, allReserve);\n', '            return;\n', '        }\n', '\n', '        if (price.lessThan(Decimal.D256({value: getSupplyDecreasePriceThreshold()}))) {\n', '            shrinkSupply(price, allReserve);\n', '            return;\n', '        }\n', '\n', '        emit SupplyNeutral(epoch());\n', '    }\n', '\n', '    function shrinkSupply(Decimal.D256 memory price, uint256 allReserve) private {\n', '        uint256 newDebt = _getBuyAmount(price.value, getSupplyDecreasePriceTarget(), allReserve);\n', '        uint256 cappedNewDebt = setDebt(newDebt);\n', '\n', '        emit SupplyDecrease(epoch(), price.value, cappedNewDebt);\n', '        return;\n', '    }\n', '\n', '    function growSupply(Decimal.D256 memory price, uint256 allReserve) private {\n', '        uint256 lessDebt = resetDebt(Decimal.zero());\n', '\n', '        (uint256 sellAmount, uint256 returnAmount) = _getSellAndReturnAmount(\n', '            price.value,\n', '            getSupplyIncreasePriceTarget(),\n', '            allReserve\n', '        );\n', '        _sellAndDepositCollateral(sellAmount, allReserve);\n', '        uint256 mintAmount = returnAmount.mul(10000).div(getCollateralRatio());\n', '        (uint256 newRedeemable, uint256 newSupply, uint256 newReward) = increaseSupply(mintAmount.sub(sellAmount));\n', '        emit SupplyIncrease(epoch(), price.value, sellAmount, newRedeemable, lessDebt, newSupply, newReward);\n', '    }\n', '\n', '    function oracleCapture() private returns (Decimal.D256 memory) {\n', '        (Decimal.D256 memory price, bool valid) = oracle().capture();\n', '\n', '        if (!valid) {\n', '            return Decimal.one();\n', '        }\n', '\n', '        return price;\n', '    }\n', '\n', '    /* for testing purpose */\n', '    function getSupplyIncreasePriceThreshold() internal view returns (uint256) {\n', '        return Constants.getSupplyIncreasePriceThreshold();\n', '    }\n', '\n', '    function getSupplyIncreasePriceTarget() internal view returns (uint256) {\n', '        return Constants.getSupplyIncreasePriceTarget();\n', '    }\n', '\n', '    function getSupplyDecreasePriceThreshold() internal view returns (uint256) {\n', '        return Constants.getSupplyDecreasePriceThreshold();\n', '    }\n', '\n', '    function getSupplyDecreasePriceTarget() internal view returns (uint256) {\n', '        return Constants.getSupplyDecreasePriceTarget();\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Permission.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', 'contract Permission is Setters {\n', '\n', '    bytes32 private constant FILE = "Permission";\n', '\n', '    // Can modify account state\n', '    modifier onlyFrozenOrFluid(address pool, address account) {\n', '        Require.that(\n', '            statusOf(pool, account) != Account.Status.Locked,\n', '            FILE,\n', '            "Not frozen or fluid"\n', '        );\n', '\n', '        _;\n', '    }\n', '\n', '    // Can participate in balance-dependant activities\n', '    modifier onlyFrozen(address pool, address account) {\n', '        Require.that(\n', '            statusOf(pool, account) == Account.Status.Frozen,\n', '            FILE,\n', '            "Not frozen"\n', '        );\n', '\n', '        _;\n', '    }\n', '\n', '    modifier initializer() {\n', '        Require.that(\n', '            !isInitialized(uint256(implementation())),\n', '            FILE,\n', '            "Already initialized"\n', '        );\n', '\n', '        initialized(uint256(implementation()));\n', '\n', '        _;\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Bonding.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Bonding is Setters, Permission {\n', '    using SafeMath for uint256;\n', '\n', '    bytes32 private constant FILE = "Bonding";\n', '\n', '    event Deposit(address indexed pool, address indexed account, uint256 value);\n', '    event Withdraw(address indexed pool, address indexed account, uint256 value);\n', '    event Bond(address indexed pool, address indexed account, uint256 start, uint256 value);\n', '    event Unbond(address indexed pool, address indexed account, uint256 start, uint256 value);\n', '\n', '    function step() internal {\n', '        Require.that(\n', '            epochTime() > epoch(),\n', '            FILE,\n', '            "Still current epoch"\n', '        );\n', '\n', '        snapshotDollarTotalSupply();\n', '        incrementEpoch();\n', '    }\n', '\n', '    function addPool(address pool) external {\n', '        Require.that(\n', '            msg.sender == address(this),\n', '            FILE,\n', '            "Must from governance"\n', '        );\n', '\n', '        _addPool(pool);\n', '    }\n', '\n', '    function claim(address pool) external {\n', '        preClaimDollar(pool);\n', '        postClaimDollar(pool);\n', '    }\n', '\n', '    function deposit(address pool, uint256 value) external {\n', '        IERC20(pool).transferFrom(msg.sender, address(this), value);\n', '        incrementBalanceOfStaged(pool, msg.sender, value);\n', '\n', '        emit Deposit(pool, msg.sender, value);\n', '    }\n', '\n', '    function withdraw(address pool, uint256 value) external onlyFrozen(pool, msg.sender) {\n', '        IERC20(pool).transfer(msg.sender, value);\n', '        decrementBalanceOfStaged(pool, msg.sender, value);\n', '\n', '        emit Withdraw(pool, msg.sender, value);\n', '    }\n', '\n', '    function bond(address pool, uint256 value) external {\n', '        preClaimDollar(pool);\n', '        unfreeze(pool, msg.sender);\n', '\n', '        incrementBalanceOfBonded(pool, msg.sender, value);\n', '        decrementBalanceOfStaged(pool, msg.sender, value);\n', '\n', '        emit Bond(pool, msg.sender, epoch().add(1), value);\n', '        postClaimDollar(pool);\n', '    }\n', '\n', '    function unbond(address pool, uint256 value) external onlyFrozenOrFluid(pool, msg.sender) {\n', '        preClaimDollar(pool);\n', '        unfreeze(pool, msg.sender);\n', '\n', '        incrementBalanceOfStaged(pool, msg.sender, value);\n', '        decrementBalanceOfBonded(pool, msg.sender, value);\n', '\n', '        emit Unbond(pool, msg.sender, epoch().add(1), value);\n', '        postClaimDollar(pool);\n', '    }\n', '\n', '    function provide(address pool, address token, address another, uint256 amount) external {\n', '        preClaimDollar(pool);\n', '\n', '        unfreeze(pool, msg.sender);\n', '\n', '        uint256 bondedLP = _addLiquidity(pool, token, another, amount);\n', '        incrementBalanceOfBonded(pool, msg.sender, bondedLP);\n', '\n', '        emit Bond(pool, msg.sender, epoch().add(1), bondedLP);\n', '        postClaimDollar(pool);\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/upgrades/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' *\n', ' * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n', ' * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n', ' * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n', ' * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n', ' */\n', 'library OpenZeppelinUpgradesAddress {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Upgradeable.sol\n', '\n', '/*\n', '    Copyright 2018-2019 zOS Global Limited\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '/**\n', ' * Based off of, and designed to interface with, openzeppelin/upgrades package\n', ' */\n', 'contract Upgradeable is State {\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     * @param implementation Address of the new implementation.\n', '     */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    function initialize() public;\n', '\n', '    /**\n', '     * @dev Upgrades the proxy to a new implementation.\n', '     * @param newImplementation Address of the new implementation.\n', '     */\n', '    function upgradeTo(address newImplementation) internal {\n', '        setImplementation(newImplementation);\n', '\n', '        (bool success, bytes memory reason) = newImplementation.delegatecall(abi.encodeWithSignature("initialize()"));\n', '        require(success, string(reason));\n', '\n', '        emit Upgraded(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the implementation address of the proxy.\n', '     * @param newImplementation Address of the new implementation.\n', '     */\n', '    function setImplementation(address newImplementation) private {\n', '        require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '        assembly {\n', '            sstore(slot, newImplementation)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Govern.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Govern is Setters, Permission, Upgradeable {\n', '    using SafeMath for uint256;\n', '    using Decimal for Decimal.D256;\n', '\n', '    bytes32 private constant FILE = "Govern";\n', '\n', '    event Proposal(uint256 indexed candidate, address indexed account, uint256 indexed start, uint256 period);\n', '    event Vote(address indexed account, uint256 indexed candidate, Candidate.Vote vote, uint256 bondedVotes);\n', '    event Commit(address indexed account, uint256 indexed candidate, bool upgrade);\n', '\n', '    /*\n', '     * We allow voting as long as the token is bonded.\n', '     */\n', '    function vote(uint256 candidate, Candidate.Vote vote) external {\n', '        Require.that(\n', '            msg.sender == tx.origin,\n', '            FILE,\n', '            "Must be a user tx"\n', '        );\n', '\n', '        if (!isNominated(candidate)) {\n', '            Require.that(\n', '                canPropose(msg.sender),\n', '                FILE,\n', '                "Not enough stake to propose"\n', '            );\n', '\n', '            createCandidate(candidate, Constants.getGovernancePeriod());\n', '            emit Proposal(candidate, msg.sender, epoch(), Constants.getGovernancePeriod());\n', '        }\n', '\n', '        Require.that(\n', '            epoch() < startFor(candidate).add(periodFor(candidate)),\n', '            FILE,\n', '            "Ended"\n', '        );\n', '\n', '        uint256 bondedVotes = balanceOfBondedDollar(msg.sender);\n', '        Candidate.VoteInfo memory recordedVoteInfo = recordedVoteInfo(msg.sender, candidate);\n', '        Candidate.VoteInfo memory newVoteInfo = Candidate.VoteInfo({vote: vote, bondedVotes: bondedVotes});\n', '\n', '        if (newVoteInfo.vote == recordedVoteInfo.vote && newVoteInfo.bondedVotes == recordedVoteInfo.bondedVotes) {\n', '            return;\n', '        }\n', '\n', '        if (recordedVoteInfo.vote == Candidate.Vote.REJECT) {\n', '            decrementRejectFor(candidate, recordedVoteInfo.bondedVotes);\n', '        }\n', '        if (recordedVoteInfo.vote == Candidate.Vote.APPROVE) {\n', '            decrementApproveFor(candidate, recordedVoteInfo.bondedVotes);\n', '        }\n', '        if (vote == Candidate.Vote.REJECT) {\n', '            incrementRejectFor(candidate, newVoteInfo.bondedVotes);\n', '        }\n', '        if (vote == Candidate.Vote.APPROVE) {\n', '            incrementApproveFor(candidate, newVoteInfo.bondedVotes);\n', '        }\n', '\n', '        recordVoteInfo(msg.sender, candidate, newVoteInfo);\n', '        placeLock(msg.sender, candidate);\n', '\n', '        emit Vote(msg.sender, candidate, vote, bondedVotes);\n', '    }\n', '\n', '    function commit(uint256 candidate) external {\n', '        Require.that(\n', '            isNominated(candidate),\n', '            FILE,\n', '            "Not nominated"\n', '        );\n', '\n', '        uint256 endsAfter = startFor(candidate).add(periodFor(candidate)).sub(1);\n', '\n', '        Require.that(\n', '            epoch() > endsAfter,\n', '            FILE,\n', '            "Not ended"\n', '        );\n', '\n', '        Require.that(\n', '            epoch() <= endsAfter.add(1).add(Constants.getGovernanceExpiration()),\n', '            FILE,\n', '            "Expired"\n', '        );\n', '\n', '        Require.that(\n', '            Decimal.ratio(votesFor(candidate), dollar().totalSupply()).greaterThan(Constants.getGovernanceQuorum()),\n', '            FILE,\n', '            "Must have quorom"\n', '        );\n', '\n', '        Require.that(\n', '            approveFor(candidate) > rejectFor(candidate),\n', '            FILE,\n', '            "Not approved"\n', '        );\n', '\n', '        Require.that(\n', '            msg.sender == getGovernor(),\n', '            FILE,\n', '            "Must from governor"\n', '        );\n', '\n', '        upgradeTo(address(candidate));\n', '\n', '        emit Commit(msg.sender, candidate, true);\n', '    }\n', '\n', '    function emergencyCommit(uint256 candidate) external {\n', '        Require.that(\n', '            isNominated(candidate),\n', '            FILE,\n', '            "Not nominated"\n', '        );\n', '\n', '        Require.that(\n', '            Decimal.ratio(approveFor(candidate), dollar().totalSupply()).greaterThan(Constants.getGovernanceSuperMajority()),\n', '            FILE,\n', '            "Must have super majority"\n', '        );\n', '\n', '        Require.that(\n', '            approveFor(candidate) > rejectFor(candidate),\n', '            FILE,\n', '            "Not approved"\n', '        );\n', '\n', '        Require.that(\n', '            msg.sender == getGovernor(),\n', '            FILE,\n', '            "Must from governor"\n', '        );\n', '\n', '        upgradeTo(address(candidate));\n', '\n', '        emit Commit(msg.sender, candidate, true);\n', '    }\n', '\n', '    function canPropose(address account) private view returns (bool) {\n', '        Decimal.D256 memory stake = Decimal.ratio(\n', '            balanceOfBondedDollar(account),\n', '            dollar().totalSupply()\n', '        );\n', '        return stake.greaterThan(Constants.getGovernanceProposalThreshold());\n', '    }\n', '\n', '    function getGovernor() internal view returns (address) {\n', '        return Constants.getGovernor();\n', '    }\n', '}\n', '\n', '// File: contracts/dao/ReentrancyGuard.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.5.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Collateral.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Collateral is Comptroller, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    bytes32 private constant FILE = "Collateral";\n', '\n', '    function redeem(uint256 value) external nonReentrant {\n', '        uint256 actual = value;\n', '        uint256 debt = totalDebt();\n', '        if (debt > value) {\n', '            // if there is debt, redeem at no cost\n', '            debt = value;\n', '        } else {\n', '            // redeem with cost\n', '            actual = value.sub((10000 - Constants.getRedemptionRate()).mul(value.sub(debt)).div(10000));\n', '            uint256 fundReward = value.sub(actual);\n', '            uint256 devReward = fundReward.mul(Constants.getFundDevPct()).div(100);\n', '            uint256 treasuryReward = fundReward.sub(devReward);\n', '            dollar().transferFrom(msg.sender, Constants.getDevAddress(), devReward);\n', '            dollar().transferFrom(msg.sender, Constants.getTreasuryAddress(), treasuryReward);\n', '        }\n', '\n', '        uint256 len = _state.collateralAssetList.length;\n', '        uint256 dollarTotalSupply = dollar().totalSupply();\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address addr = _state.collateralAssetList[i];\n', '            IERC20(addr).safeTransfer(\n', '                msg.sender,\n', '                actual.mul(IERC20(addr).balanceOf(address(this))).div(dollarTotalSupply)\n', '            );\n', '        }\n', '\n', '        burnFromAccountForDebt(msg.sender, actual, debt);\n', '    }\n', '\n', '    function addCollateral(address asset) external {\n', '        Require.that(\n', '            msg.sender == address(this),\n', '            FILE,\n', '            "Must from governance"\n', '        );\n', '\n', '        _addCollateral(asset);\n', '    }\n', '\n', '    function _getMinterAddress() internal view returns (address) {\n', '        return Constants.getMinterAddress();\n', '    }\n', '}\n', '\n', '// File: contracts/dao/Implementation.sol\n', '\n', '/*\n', '    Copyright 2020 Empty Set Squad <[email\xa0protected]>\n', '    Copyright 2021 vsdcrew <[email\xa0protected]>\n', '\n', '    Licensed under the Apache License, Version 2.0 (the "License");\n', '    you may not use this file except in compliance with the License.\n', '    You may obtain a copy of the License at\n', '\n', '    http://www.apache.org/licenses/LICENSE-2.0\n', '\n', '    Unless required by applicable law or agreed to in writing, software\n', '    distributed under the License is distributed on an "AS IS" BASIS,\n', '    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n', '    See the License for the specific language governing permissions and\n', '    limitations under the License.\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract Implementation is State, Bonding, Market, Regulator, Govern, Collateral {\n', '    using SafeMath for uint256;\n', '\n', '    event Advance(uint256 indexed epoch, uint256 block, uint256 timestamp);\n', '    event Incentivization(address indexed account, uint256 amount);\n', '\n', '    function initialize() initializer public {\n', '        uint256 len = _state.poolList.length;\n', '        for (uint256 i = 0; i < len; i++) {\n', '            address pool = _state.poolList[i];\n', '            Storage.PoolInfo storage poolInfo = _state.pools[pool];\n', '            poolInfo.flags = 0x1;\n', '        }\n', '    }\n', '\n', '    function advance() nonReentrant external {\n', '        require (msg.sender == tx.origin, "Must from user");\n', '        incentivize(msg.sender, Constants.getAdvanceIncentive());\n', '\n', '        Bonding.step();\n', '        Regulator.step();\n', '        Market.step();\n', '\n', '        emit Advance(epoch(), block.number, block.timestamp);\n', '    }\n', '\n', '    function incentivize(address account, uint256 amount) private {\n', '        mintToAccount(account, amount);\n', '        emit Incentivization(account, amount);\n', '    }\n', '}']