['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-25\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.7.6;\n', '\n', '// ----------------------------------------------------------------------------\n', "// 'HAPPYHOUR' Staking smart contract\n", '//\n', '// Enter our universe : cocktailbar.finance\n', '//\n', '// Come join the disscussion: https://t.me/cocktailbar_discussion\n', '//\n', '//                                          Sincerely, Mr. Martini\n', '// ----------------------------------------------------------------------------\n', '// ----------------------------------------------------------------------------\n', '// SafeMath library\n', '// ----------------------------------------------------------------------------\n', '\n', '/**\n', "* @dev Wrappers over Solidity's arithmetic operations with added overflow\n", '* checks.\n', '*\n', '* Arithmetic operations in Solidity wrap on overflow. This can easily result\n', '* in bugs, because programmers usually assume that an overflow raises an\n', '* error, which is the standard behavior in high level programming languages.\n', '* `SafeMath` restores this intuition by reverting the transaction when an\n', '* operation overflows.\n', '*\n', '* Using this library instead of the unchecked operations eliminates an entire\n', "* class of bugs, so it's recommended to use it always.\n", '*/\n', 'library SafeMath {\n', '   /**\n', '    * @dev Returns the addition of two unsigned integers, reverting on\n', '    * overflow.\n', '    *\n', "    * Counterpart to Solidity's `+` operator.\n", '    *\n', '    * Requirements:\n', '    *\n', '    * - Addition cannot overflow.\n', '    */\n', '   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '       uint256 c = a + b;\n', '       require(c >= a, "SafeMath: addition overflow");\n', '\n', '       return c;\n', '   }\n', '\n', '   /**\n', '    * @dev Returns the subtraction of two unsigned integers, reverting on\n', '    * overflow (when the result is negative).\n', '    *\n', "    * Counterpart to Solidity's `-` operator.\n", '    *\n', '    * Requirements:\n', '    *\n', '    * - Subtraction cannot overflow.\n', '    */\n', '   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '       return sub(a, b, "SafeMath: subtraction overflow");\n', '   }\n', '\n', '   /**\n', '    * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '    * overflow (when the result is negative).\n', '    *\n', "    * Counterpart to Solidity's `-` operator.\n", '    *\n', '    * Requirements:\n', '    *\n', '    * - Subtraction cannot overflow.\n', '    */\n', '   function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '       require(b <= a, errorMessage);\n', '       uint256 c = a - b;\n', '\n', '       return c;\n', '   }\n', '\n', '   /**\n', '    * @dev Returns the multiplication of two unsigned integers, reverting on\n', '    * overflow.\n', '    *\n', "    * Counterpart to Solidity's `*` operator.\n", '    *\n', '    * Requirements:\n', '    *\n', '    * - Multiplication cannot overflow.\n', '    */\n', '   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "       // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "       // benefit is lost if 'b' is also tested.\n", '       // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '       if (a == 0) {\n', '           return 0;\n', '       }\n', '\n', '       uint256 c = a * b;\n', '       require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '       return c;\n', '   }\n', '\n', '\n', '   /**\n', '    * @dev Returns the integer division of two unsigned integers. Reverts on\n', '    * division by zero. The result is rounded towards zero.\n', '    *\n', "    * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '    * uses an invalid opcode to revert (consuming all remaining gas).\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - The divisor cannot be zero.\n', '    */\n', '   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '       return div(a, b, "SafeMath: division by zero");\n', '   }\n', '\n', '   /**\n', '    * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '    * division by zero. The result is rounded towards zero.\n', '    *\n', "    * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '    * uses an invalid opcode to revert (consuming all remaining gas).\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - The divisor cannot be zero.\n', '    */\n', '   function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '       require(b > 0, errorMessage);\n', '       uint256 c = a / b;\n', "       // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '       return c;\n', '   }\n', '\n', '   /**\n', '    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '    * Reverts when dividing by zero.\n', '    *\n', "    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '    * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '    * invalid opcode to revert (consuming all remaining gas).\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - The divisor cannot be zero.\n', '    */\n', '   function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '       return mod(a, b, "SafeMath: modulo by zero");\n', '   }\n', '\n', '   /**\n', '    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '    * Reverts with custom message when dividing by zero.\n', '    *\n', "    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '    * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '    * invalid opcode to revert (consuming all remaining gas).\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - The divisor cannot be zero.\n', '    */\n', '   function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '       require(b != 0, errorMessage);\n', '       return a % b;\n', '   }\n', '\n', '   function ceil(uint a, uint m) internal pure returns (uint r) {\n', '       return (a + m - 1) / m * m;\n', '   }\n', '\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '   bool private _notEntered;\n', '\n', '   constructor () {\n', '       // Storing an initial non-zero value makes deployment a bit more\n', '       // expensive, but in exchange the refund on every call to nonReentrant\n', '       // will be lower in amount. Since refunds are capped to a percetange of\n', "       // the total transaction's gas, it is best to keep them low in cases\n", '       // like this one, to increase the likelihood of the full refund coming\n', '       // into effect.\n', '       _notEntered = true;\n', '   }\n', '\n', '   /**\n', '    * @dev Prevents a contract from calling itself, directly or indirectly.\n', '    * Calling a `nonReentrant` function from another `nonReentrant`\n', '    * function is not supported. It is possible to prevent this from happening\n', '    * by making the `nonReentrant` function external, and make it call a\n', '    * `private` function that does the actual work.\n', '    */\n', '   modifier nonReentrant() {\n', '       // On the first call to nonReentrant, _notEntered will be true\n', '       require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '       // Any calls to nonReentrant after this point will fail\n', '       _notEntered = false;\n', '\n', '       _;\n', '\n', '       // By storing the original value once again, a refund is triggered (see\n', '       // https://eips.ethereum.org/EIPS/eip-2200)\n', '       _notEntered = true;\n', '   }\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '// Owned contract\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '   modifier onlyOwner() virtual{\n', '       require(msg.sender==owner);\n', '       _;\n', '   }\n', '   address payable owner;\n', '   address payable newOwner;\n', '   function changeOwner(address payable _newOwner) external onlyOwner {\n', '       require(_newOwner!=address(0));\n', '       newOwner = _newOwner;\n', '   }\n', '   function acceptOwnership() external {\n', '       if (msg.sender==newOwner) {\n', '           owner = newOwner;\n', '       }\n', '   }\n', '}\n', '\n', 'interface ERC20 {\n', '   function balanceOf(address _owner) view external  returns (uint256 balance);\n', '   function transfer(address _to, uint256 _value) external  returns (bool success);\n', '   function transferFrom(address _from, address _to, uint256 _value) external  returns (bool success);\n', '   function approve(address _spender, uint256 _value) external returns (bool success);\n', '   function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\n', '   event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// ----------------------------------------------------------------------------\n', 'contract Token is Owned, ERC20 {\n', '   using SafeMath for uint256;\n', '   uint256 public totalSupply;\n', '   string public symbol;\n', '   string public name;\n', '   uint8 public decimals;\n', '   mapping (address=>uint256) balances;\n', '   mapping (address=>mapping (address=>uint256)) allowed;\n', '   uint256 public rewardfee;\n', '\n', '   event TransferFee(address indexed _from, address indexed _to, uint256 _value);\n', '\n', '   function balanceOf(address _owner) view public override   returns (uint256 balance) {return balances[_owner];}\n', '\n', '   function transfer(address _to, uint256 _amount) public override  returns (bool success) {\n', '       require (balances[msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\n', '       balances[msg.sender]-=_amount;\n', '\n', '\n', '       uint256 fee = onehalfPercent(_amount);\n', '       uint256 amountto = _amount.sub(fee);\n', '       rewardfee = rewardfee.add(fee);\n', '\n', '       balances[address(this)]+=fee;\n', '       balances[_to]+=amountto;\n', '\n', '\n', '       emit Transfer(msg.sender,_to,amountto);\n', '       emit TransferFee(msg.sender,address(this),fee);\n', '       return true;\n', '   }\n', '\n', '\n', '\n', '   function transferFrom(address _from,address _to,uint256 _amount) public override  returns (bool success) {\n', '       require (balances[_from]>=_amount&&allowed[_from][msg.sender]>=_amount&&_amount>0&&balances[_to]+_amount>balances[_to]);\n', '       balances[_from]-=_amount;\n', '       allowed[_from][msg.sender]-=_amount;\n', '\n', '       uint256 fee = onehalfPercent(_amount);\n', '       uint256 amountto = _amount.sub(fee);\n', '\n', '\n', '       rewardfee = rewardfee.add(fee);\n', '       balances[address(this)]+=fee;\n', '       balances[_to]+=amountto;\n', '\n', '\n', '       emit Transfer(msg.sender,_to,amountto);\n', '       emit TransferFee(msg.sender,address(this),fee);\n', '       return true;\n', '   }\n', '\n', '   function approve(address _spender, uint256 _amount) public override  returns (bool success) {\n', '       allowed[msg.sender][_spender]=_amount;\n', '       emit Approval(msg.sender, _spender, _amount);\n', '       return true;\n', '   }\n', '\n', '   function allowance(address _owner, address _spender) view public override  returns (uint256 remaining) {\n', '     return allowed[_owner][_spender];\n', '   }\n', '\n', '       function onehalfPercent(uint256 _tokens) private pure returns (uint256){\n', '       uint256 roundValue = _tokens.ceil(100);\n', '       uint onehalfofTokens = roundValue.mul(100).div(100 * 10**uint(2));\n', '       return onehalfofTokens;\n', '   }\n', '\n', '}\n', '\n', '\n', 'contract Mojito is Token{\n', '   using SafeMath for uint256;\n', '   constructor() {\n', '       symbol = "MOJITO";\n', '       name = "Mojito";\n', '       decimals = 18;\n', '       totalSupply = 5000000000000000000000;\n', '       owner = msg.sender;\n', '       balances[owner] = totalSupply;\n', '\n', '   }\n', '\n', '   receive () payable external {\n', '       require(msg.value>0);\n', '       owner.transfer(msg.value);\n', '   }\n', '\n', '}\n', '\n', 'interface REWARDTOKEN {\n', '   function balanceOf(address _owner) view external  returns (uint256 balance);\n', '   function allowance(address _owner, address _spender) view external  returns (uint256 remaining);\n', '   event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '   event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '   function transfer(address _to, uint256 _amount) external  returns (bool success);\n', '   function transferFrom(address _from,address _to,uint256 _amount) external  returns (bool success);\n', '   function approve(address _to, uint256 _amount) external  returns (bool success);\n', '   function _mint(address account, uint256 amount) external ;\n', '\n', '}\n', '\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and assisted\n', '// token transfers\n', '// ----------------------------------------------------------------------------\n', 'contract Stake is Mojito, ReentrancyGuard {\n', '   using SafeMath for uint256;\n', '   address public rewtkn= 0x39FB7AF42ef12D92A0d577ca44cd54a0f24c4915;\n', '   uint256 public totalStakes = 0;\n', '   uint256 stakingFee = 10; // 1%\n', '   uint256 unstakingFee = 30; // 3%\n', '   uint256 public prevreward = 0;\n', '   REWARD  public reward;\n', '\n', '\n', '   struct REWARD\n', '   {\n', '       uint256 rewardstart;\n', '       uint256 rewardend;\n', '       uint256 totalreward;\n', '   }\n', '\n', '   struct USER{\n', '       uint256 stakedTokens;\n', '       uint256 remainder;\n', '       uint256 creationTime;\n', '       uint256 lastClaim;\n', '       uint256 totalEarned;\n', '   }\n', '\n', '   mapping(address => USER) public stakers;\n', '\n', '\n', '   event STAKED(address staker, uint256 tokens, uint256 stakingFee);\n', '   event UNSTAKED(address staker, uint256 tokens, uint256 unstakingFee);\n', '\n', '   event CLAIMEDREWARD(address staker, uint256 reward);\n', '\n', '     constructor() {\n', '       owner=msg.sender;\n', '       reward = REWARD(block.timestamp,block.timestamp + 24 hours,0);\n', '\n', '   }\n', '      modifier onlyOwner() override{\n', '       require(msg.sender==owner,"only owner can run this");\n', '       _;\n', '   }\n', '\n', '\n', '   // ------------------------------------------------------------------------\n', '   // Token holders can stake their tokens using this function\n', '   // @param tokens number of tokens to stake\n', '   // ------------------------------------------------------------------------\n', '   function STAKE(uint256 tokens) external nonReentrant {\n', '       require(REWARDTOKEN(rewtkn).transferFrom(msg.sender, address(this), tokens), "Tokens cannot be transferred from user account");\n', '       uint256 _stakingFee = (onePercent(tokens).mul(stakingFee)).div(10);\n', '       reward.totalreward = (reward.totalreward).add(stakingFee);\n', '       stakers[msg.sender].stakedTokens = (tokens.sub(_stakingFee)).add(stakers[msg.sender].stakedTokens);\n', '       stakers[msg.sender].creationTime = block.timestamp;\n', '       totalStakes = totalStakes.add(tokens.sub(_stakingFee));\n', '       emit STAKED(msg.sender, tokens.sub(_stakingFee), _stakingFee);\n', '   }\n', '\n', '\n', '   // ------------------------------------------------------------------------\n', '   // Stakers can claim their pending rewards using this function\n', '   // ------------------------------------------------------------------------\n', '   // ------------------------------------------------------------------------\n', '   // Stakers can unstake the staked tokens using this function\n', '   // @param tokens the number of tokens to withdraw\n', '   // ------------------------------------------------------------------------\n', '   function WITHDRAW(uint256 tokens) external nonReentrant {\n', '\n', '       require(stakers[msg.sender].stakedTokens >= tokens && tokens > 0, "Invalid token amount to withdraw");\n', '\n', '       uint256 _unstakingFee = (onePercent(tokens).mul(unstakingFee)).div(10);\n', '\n', '       // add pending rewards to remainder to be claimed by user later, if there is any existing stake\n', '\n', '\n', '       reward.totalreward = (reward.totalreward).add(_unstakingFee);\n', '       require(REWARDTOKEN(rewtkn).transfer(msg.sender, tokens.sub(_unstakingFee)), "Error in un-staking tokens");\n', '\n', '       stakers[msg.sender].stakedTokens = stakers[msg.sender].stakedTokens.sub(tokens);\n', '\n', '       if (stakers[msg.sender].stakedTokens == 0)\n', '       {\n', '           stakers[msg.sender].creationTime = block.timestamp ;\n', '       }\n', '       totalStakes = totalStakes.sub(tokens);\n', '       emit UNSTAKED(msg.sender, tokens.sub(_unstakingFee), _unstakingFee);\n', '\n', '\n', '   }\n', '\n', '   // ------------------------------------------------------------------------\n', '   // Private function to calculate 1% percentage\n', '   // ------------------------------------------------------------------------\n', '   function onePercent(uint256 _tokens) private pure returns (uint256){\n', '       uint256 roundValue = _tokens.ceil(100);\n', '       uint onePercentofTokens = roundValue.mul(100).div(100 * 10**uint(2));\n', '       return onePercentofTokens;\n', '   }\n', '\n', '   // ------------------------------------------------------------------------\n', '   // Get the number of tokens staked by a staker\n', '   // @param _staker the address of the staker\n', '   // ------------------------------------------------------------------------\n', '   function yourStakedREWARDTOKEN(address staker) external view returns(uint256 stakedTOKEN){\n', '       return stakers[staker].stakedTokens;\n', '   }\n', '\n', '   // ------------------------------------------------------------------------\n', '   // Get the TOKEN balance of the token holder\n', '   // @param user the address of the token holder\n', '   // ------------------------------------------------------------------------\n', '   function yourREWARDTOKENBalance(address user) external view returns(uint256 TOKENBalance){\n', '       return REWARDTOKEN(rewtkn).balanceOf(user);\n', '   }\n', '\n', '   function CurrEsstematedRew(address user) external view returns (uint256 MojitoReward)\n', '   {\n', '\n', '       if(stakers[user].stakedTokens >0)\n', '       {\n', '\n', '          uint256 time = block.timestamp - reward.rewardstart;\n', '          uint256 hour=time.div(3600);\n', '          uint256 newrewardstarttime=reward.rewardstart;\n', '\n', '       while(hour >= 24) //alligning days with outer clock\n', '       {\n', '           newrewardstarttime = newrewardstarttime.add(24 hours) ;\n', '           time = block.timestamp - newrewardstarttime;\n', '           hour=time.div(3600);\n', '\n', '       }\n', '\n', '         if(stakers[user].lastClaim == newrewardstarttime)\n', '         {\n', '             return 0;\n', '         }else{\n', '\n', '           uint256 prevrewards=0;\n', '            if(prevreward == 0 )\n', '           {\n', '               prevrewards = rewardfee;\n', '           }\n', '\n', '           uint256 Cstaked = (stakers[user].stakedTokens).mul(10000000000);\n', '           uint256 CTS = totalStakes.mul(10000000000);\n', '           uint256 percent = (Cstaked.mul(prevrewards));\n', '           uint256 rewardcal =  percent.div(CTS);\n', '\n', '\n', '            if(newrewardstarttime < stakers[user].creationTime) //how mch difference\n', '            {\n', '\n', '           time =  stakers[user].creationTime - newrewardstarttime;\n', '           uint256 stketime = time.div(3600);\n', '\n', '            if(stketime < 20)\n', '           {\n', '            uint256 a = (stketime.mul(10**uint(2))).div(20);\n', '            uint256 finalreward =  (a.mul(rewardcal)).div(10**uint(2));\n', '\n', '            if(rewardfee >= rewardcal)\n', '            {\n', '\n', '                return finalreward;\n', '            }else{\n', '                return 0;\n', '            }\n', '\n', '\n', '           }else\n', '           {\n', '               if(rewardfee >= rewardcal )\n', '               {\n', '                    return rewardcal;\n', '               }\n', '               else\n', '               {\n', '                   return 0;\n', '               }\n', '\n', '           }\n', '\n', '\n', '            }else{\n', '                  if(rewardfee >= rewardcal )\n', '               {\n', '                    return rewardcal;\n', '               }else\n', '               {\n', '                   return 0;\n', '               }\n', '\n', '            }\n', '\n', '\n', '\n', '\n', '         }\n', '\n', '\n', '\n', '\n', '\n', '\n', '       }else\n', '       {\n', '           return 0;\n', '       }\n', '\n', '   }\n', '\n', '\n', '\n', '   function CLAIMREWARD() external  {\n', '\n', '\n', '       uint256 time = block.timestamp - reward.rewardstart;\n', '       uint256 hour=time.div(3600);\n', '\n', '\n', '\n', '       if(hour >= 24)\n', '       {\n', '           prevreward = 0;\n', '       }\n', '       while(hour >= 24) //alligning days with outer clock\n', '       {\n', '           reward.rewardstart = reward.rewardstart.add(24 hours) ;\n', '           time = block.timestamp - reward.rewardstart;\n', '           hour=time.div(3600);\n', '\n', '       }\n', '\n', '       require(stakers[msg.sender].lastClaim != reward.rewardstart,"You have Already Claimed");\n', '       {\n', '\n', '       //this line is basically  checking which hour is currently user trying to claim (can only claim at hour 20 - 24 )\n', '       time  = (block.timestamp).sub(reward.rewardstart) ;  //now can be greater than rewardend\n', '       uint256 rewhour = time.div(3600);\n', '       if((rewhour < 24) && (rewhour >= 20))  // checking if person is illigebal for reward\n', '       {\n', '\n', '           if(prevreward == 0 )\n', '           {\n', '               prevreward = rewardfee;\n', '           }\n', '\n', '\n', '           //calculating percent of staked tokens user has in the total pool\n', '           uint256 Cstaked = (stakers[msg.sender].stakedTokens).mul(10000000000);\n', '           uint256 CTS = totalStakes.mul(10000000000);\n', '           uint256 percent = (Cstaked.mul(prevreward));\n', '           uint256 rewardcal =  percent.div(CTS);\n', '\n', '\n', '            if(reward.rewardstart < stakers[msg.sender].creationTime) //how mch difference\n', '            {\n', '\n', '           time =  stakers[msg.sender].creationTime - reward.rewardstart;\n', '           uint256 stketime = time.div(3600);\n', '\n', '           //checking what was the stake time of the user. User should not get all amount if his stake time is less than 20 hours\n', '           //will change wif we go with starttime\n', '\n', '           //checktime\n', '           if(stketime < 20)\n', '           {\n', '            uint256 a = (stketime.mul(10**uint(2))).div(20);\n', '            uint256 finalreward =  (a.mul(rewardcal)).div(10**uint(2));\n', '\n', '            if(rewardfee >= rewardcal)\n', '            {\n', '              Mojito(address(this)).transfer(msg.sender,finalreward);\n', '             rewardfee = rewardfee.sub(finalreward);\n', '             stakers[msg.sender].lastClaim = reward.rewardstart;\n', '             stakers[msg.sender].totalEarned = (stakers[msg.sender].totalEarned).add(finalreward);\n', '             emit CLAIMEDREWARD(msg.sender,finalreward);\n', '            }\n', '\n', '\n', '           }else\n', '           {\n', '               if(rewardfee >= rewardcal )\n', '               {\n', '                    Mojito(address(this)).transfer(msg.sender,rewardcal);\n', '                      rewardfee = rewardfee.sub(rewardcal);\n', '                       stakers[msg.sender].lastClaim = reward.rewardstart;\n', '                        stakers[msg.sender].totalEarned = (stakers[msg.sender].totalEarned).add(rewardcal);\n', '                      emit CLAIMEDREWARD(msg.sender,rewardcal);\n', '\n', '               }\n', '\n', '           }\n', '\n', '\n', '            }else{\n', '                  if(rewardfee >= rewardcal )\n', '               {\n', '                    Mojito(address(this)).transfer(msg.sender,rewardcal);\n', '                      rewardfee = rewardfee.sub(rewardcal);\n', '                        stakers[msg.sender].lastClaim = reward.rewardstart ;\n', '                           stakers[msg.sender].totalEarned = (stakers[msg.sender].totalEarned).add(rewardcal);\n', '                     emit CLAIMEDREWARD(msg.sender,rewardcal);\n', '\n', '               }\n', '\n', '            }\n', '\n', '\n', '\n', '       }\n', '\n', '       }\n', '\n', '       reward.rewardend = reward.rewardstart + 24 hours;\n', '\n', '   }\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '   function WatchClaimTime() public  view  returns (uint ClaimTimeHours)\n', '   {\n', '\n', '\n', '\n', '       uint256 time  = block.timestamp - reward.rewardstart;\n', '       uint rewhour = time.div(3600);\n', '       return rewhour;\n', '\n', '\n', '   }\n', '\n', '\n', '\n', '    function WatchClaimTimeMins() public view returns (uint ClaimTimeHours)\n', '   {\n', '\n', '           uint256 time  = block.timestamp - reward.rewardstart;\n', '           uint rewhour = time.div(1);\n', '           return rewhour;\n', '\n', '\n', '   }\n', '\n', '\n', '}']