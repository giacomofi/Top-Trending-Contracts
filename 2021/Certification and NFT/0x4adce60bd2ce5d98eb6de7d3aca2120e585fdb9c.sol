['/* \n', '   SPDX-License-Identifier: MIT\n', '   https://riseprotocol.io\n', '   Copyright 2021\n', '*/\n', '\n', 'pragma solidity 0.6.6;\n', '\n', 'import "./RiseSafeMath.sol";\n', '        \n', 'interface UniswapPairContract {\n', '  \n', '  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '  }\n', '        \n', '\n', 'interface RiseTokenInterface {\n', '   \n', '    //Public functions\n', '    function maxScalingFactor() external view returns (uint256);\n', '    function RiseScalingFactor() external view returns (uint256);\n', '    //rebase permissioned\n', '    function rebase(uint256 epoch, uint256 indexDelta, bool positive) external returns (uint256);\n', '}\n', '\n', 'contract RiseRebaser {\n', '\n', '    using RiseSafeMath for uint256;\n', '\n', '    modifier onlyGov() {\n', '        require(msg.sender == gov);\n', '        _;\n', '    }\n', '\n', ' \n', '    /// @notice an event emitted when deviationThreshold is changed\n', '    event NewDeviationThreshold(uint256 oldDeviationThreshold, uint256 newDeviationThreshold);\n', '\n', '    /// @notice Governance address\n', '    address public gov;\n', '\n', '  \n', '    /// @notice Spreads out getting to the target price\n', '    uint256 public rebaseLag;\n', '\n', '    /// @notice Peg target\n', '    uint256 public targetRate;\n', '    \n', '    // If the current exchange rate is within this fractional percentage from the target, no supply\n', '    // adjustment is performed.\n', '    uint256 public deviationThreshold;\n', '\n', '    /// @notice More than this much time must pass between rebase operations.\n', '    uint256 public minRebaseTimeIntervalSec;\n', '\n', '    /// @notice Block timestamp of last rebase operation\n', '    uint256 public lastRebaseTimestampSec;\n', '\n', '    /// @notice The rebase window begins this many seconds into the minRebaseTimeInterval period.\n', '    // For example if minRebaseTimeInterval is 24hrs, it represents the time of day in seconds.\n', '    uint256 public rebaseWindowOffsetSec;\n', '\n', '    /// @notice The length of the time window where a rebase operation is allowed to execute, in seconds.\n', '    uint256 public rebaseWindowLengthSec;\n', '\n', '    /// @notice The number of rebase cycles since inception\n', '    uint256 public epoch;\n', '\t\n', '\t/// @notice The number of consecutive days where price is under 5% of peg\n', '\tuint256 public nepoch;\n', '\t\n', '\tuint256 public indexDelta;\n', '\n', '    address public RiseAddress;\n', '   \n', '    address public uniswap_Rise_eth_pair;\n', '    \n', '    mapping(address => bool) public whitelistFrom;\n', '    \n', '   \n', '\n', '    constructor(\n', '        address RiseAddress_,\n', '        address RiseETHPair_\n', '    )\n', '        public\n', '    {\n', '          minRebaseTimeIntervalSec = 23 hours;\n', '          rebaseWindowOffsetSec = 0;\n', '       \n', '          // Default target rate of 0.01 ETH\n', '          targetRate = 10**7;\n', '\n', '          // Default lag of 5\n', '          rebaseLag = 5;\n', '\n', '          // 5%\n', '          deviationThreshold = 5;\n', '\n', '          // 24 hours\n', '          rebaseWindowLengthSec = 24 hours;\n', '          \n', '          epoch = 5;\n', '          \n', '          uniswap_Rise_eth_pair = RiseETHPair_;\n', '          RiseAddress = RiseAddress_;\n', '\n', '          gov = msg.sender;\n', '    }\n', '\n', '  \n', '  \n', '    function checkIndexDelta() public view returns (uint256) {\n', '\t\t uint256 _exchangeRate = getPrice();\n', '\n', '        (uint256 _offPegPerc, bool _positive) = computeOffPegPerc(_exchangeRate);\n', '\n', '        uint256 _indexDelta = _offPegPerc;\n', '\t\t\n', '\t\tif(_positive){\n', '        _indexDelta = _indexDelta.div(rebaseLag);\n', '\t\t}\n', '\t\treturn _indexDelta;\n', '\t}\n', '    \n', '     function setWhitelistedFrom(address _addr, bool _whitelisted) external onlyGov {\n', '        whitelistFrom[_addr] = _whitelisted;\n', '    }\n', '    \n', '    \n', '     function _isWhitelisted(address _from) internal view returns (bool) {\n', '        return whitelistFrom[_from];\n', '    }\n', '    \n', '    /**\n', '     * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\n', '     *\n', '     * @dev The supply adjustment equals (_totalSupply * DeviationFromTargetRate) / rebaseLag\n', '     *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\n', '     *      and targetRate is 1e18\n', '     */\n', '    function rebase()\n', '        public\n', '    {\n', '        // EOA only\n', '        require(msg.sender == tx.origin);\n', '        require(_isWhitelisted(msg.sender));\n', '        // ensure rebasing at correct time\n', '        _inRebaseWindow();\n', '        \n', '\n', '        require(lastRebaseTimestampSec.add(minRebaseTimeIntervalSec) < now);\n', '\n', '        // Snap the rebase time to the start of this window.\n', '        lastRebaseTimestampSec = now;\n', '\n', '        // get price from uniswap v2;\n', '        uint256 exchangeRate = getPrice();\n', '\n', '        // calculates % change to supply\n', '        (uint256 offPegPerc, bool positive) = computeOffPegPerc(exchangeRate);\n', '\n', '        indexDelta = offPegPerc;\n', '\n', '        // Apply the Dampening factor for positive rebases\n', '\t\tif(positive) {\n', '        indexDelta = indexDelta.div(rebaseLag);\n', '\t\t}\n', '\t\t// Increase epoch if positive or neutral rebase. Snap nepoch back to 0.\n', '\t\tif (positive || indexDelta == 0) {\n', '\t\tepoch = epoch.add(1);\n', '\t\tnepoch = 0;\n', '\t\t}\n', '\t\t\n', '\t\t// Increase nepoch if price below 5% of peg\n', '\t\tif (!positive) {\n', '\t\t\tepoch = epoch.add(1);\n', '\t\t\tnepoch = nepoch.add(1);\n', '\t\t}\n', '\t\t\n', '        RiseTokenInterface Rise = RiseTokenInterface(RiseAddress);\n', '\n', '        if (positive) {\n', '            require(Rise.RiseScalingFactor().mul(uint256(10**9).add(indexDelta)).div(10**9) < Rise.maxScalingFactor(), "new scaling factor will be too big");\n', '        }\n', '\t\t\n', '        // Positive rebase.\n', '\t\tif (positive) {\n', '        Rise.rebase(epoch, indexDelta, positive);\n', '        assert(Rise.RiseScalingFactor() <= Rise.maxScalingFactor());\n', '\t\t}\n', '\t\t\n', '\t\t//Supply adjustment only if nepoch = 3. After adjustment, snap nepoch back to 0.\n', '\t\tif (!positive && nepoch == 3) {\n', '\t\t\t\tRise.rebase(epoch, indexDelta, positive);\n', '\t\t\t\tnepoch = 0;\n', '\t\t\t}\n', '  }\n', '  \n', ' \n', '      function getPrice() public view returns (uint256) {\n', '        (uint RiseReserve, uint ethReserve, ) = UniswapPairContract(uniswap_Rise_eth_pair).getReserves();\n', '        uint RisePrice = ethReserve.div(RiseReserve);\n', '        return RisePrice;\n', '    }\n', '\n', '    function setDeviationThreshold(uint256 deviationThreshold_)\n', '        external\n', '        onlyGov\n', '    {\n', '        require(deviationThreshold > 0);\n', '        uint256 oldDeviationThreshold = deviationThreshold;\n', '        deviationThreshold = deviationThreshold_;\n', '        emit NewDeviationThreshold(oldDeviationThreshold, deviationThreshold_);\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Sets the rebase lag parameter.\n', '               It is used to dampen the applied supply adjustment by 1 / rebaseLag\n', '               If the rebase lag R, equals 1, the smallest value for R, then the full supply\n', '               correction is applied on each rebase cycle.\n', '               If it is greater than 1, then a correction of 1/R of is applied on each rebase.\n', '     * @param rebaseLag_ The new rebase lag parameter.\n', '     */\n', '     \n', '     \n', '    function setRebaseLag(uint256 rebaseLag_)\n', '        external\n', '        onlyGov\n', '    {\n', '        require(rebaseLag_ > 0);\n', '        rebaseLag = rebaseLag_;\n', '    }\n', '    \n', '    \n', '    \n', '    /**\n', '     * @notice Sets the targetRate parameter.\n', '     * @param targetRate_ The new target rate parameter.\n', '     */\n', '     \n', '     \n', '    function setTargetRate(uint256 targetRate_)\n', '        external\n', '        onlyGov\n', '    {\n', '        require(targetRate_ > 0);\n', '        targetRate = targetRate_;\n', '    }\n', '    \n', '    \n', '\n', '    /**\n', '     * @notice Sets the parameters which control the timing and frequency of\n', '     *         rebase operations.\n', '     *         a) the minimum time period that must elapse between rebase cycles.\n', '     *         b) the rebase window offset parameter.\n', '     *         c) the rebase window length parameter.\n', '     * @param minRebaseTimeIntervalSec_ More than this much time must pass between rebase\n', '     *        operations, in seconds.\n', '     * @param rebaseWindowOffsetSec_ The number of seconds from the beginning of\n', '              the rebase interval, where the rebase window begins.\n', '     * @param rebaseWindowLengthSec_ The length of the rebase window in seconds.\n', '     */\n', '    function setRebaseTimingParameters(\n', '        uint256 minRebaseTimeIntervalSec_,\n', '        uint256 rebaseWindowOffsetSec_,\n', '        uint256 rebaseWindowLengthSec_)\n', '        external\n', '        onlyGov\n', '    {\n', '        require(minRebaseTimeIntervalSec_ > 0);\n', '        require(rebaseWindowOffsetSec_ < minRebaseTimeIntervalSec_);\n', '\n', '        minRebaseTimeIntervalSec = minRebaseTimeIntervalSec_;\n', '        rebaseWindowOffsetSec = rebaseWindowOffsetSec_;\n', '        rebaseWindowLengthSec = rebaseWindowLengthSec_;\n', '    }\n', '\n', '    /**\n', '     * @return If the latest block timestamp is within the rebase time window it, returns true.\n', '     *         Otherwise, returns false.\n', '     */\n', '    function inRebaseWindow() public view returns (bool) {\n', '\n', '        // rebasing is delayed until there is a liquid market\n', '        _inRebaseWindow();\n', '        return true;\n', '    }\n', '\n', '    function _inRebaseWindow() internal view {\n', '        require(now.mod(minRebaseTimeIntervalSec) >= rebaseWindowOffsetSec, "too early");\n', '        require(now.mod(minRebaseTimeIntervalSec) < (rebaseWindowOffsetSec.add(rebaseWindowLengthSec)), "too late");\n', '    }\n', '\n', '    /**\n', '     * @return Computes in % how far off market is from peg\n', '     */\n', '    function computeOffPegPerc(uint256 rate)\n', '        private\n', '        view\n', '        returns (uint256, bool)\n', '    {\n', '        if (withinDeviationThreshold(rate)) {\n', '            return (0, false);\n', '        }\n', '\n', '        // indexDelta =  (rate - targetRate) / targetRate\n', '        if (rate > targetRate) {\n', '            return (rate.sub(targetRate).mul(10**9).div(targetRate), true);\n', '        } else {\n', '            return (targetRate.sub(rate).mul(10**9).div(targetRate), false);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @param rate The current exchange rate, an 18 decimal fixed point number.\n', '     * @return If the rate is within the deviation threshold from the target rate, returns true.\n', '     *         Otherwise, returns false.\n', '     */\n', '    function withinDeviationThreshold(uint256 rate)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        uint256 absoluteDeviationThreshold = targetRate.mul(deviationThreshold)\n', '            .div(100);\n', '\n', '        return (rate < targetRate && targetRate.sub(rate) < absoluteDeviationThreshold);\n', '    }\n', '}']