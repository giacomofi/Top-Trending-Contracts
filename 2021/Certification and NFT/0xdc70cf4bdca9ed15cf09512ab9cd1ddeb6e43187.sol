['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-29\n', '*/\n', '\n', 'pragma solidity =0.6.6;\n', '/**\n', ' * Four super nodes contracts of galaxy\n', ' */\n', '/**\n', ' * Math operations with safety checks\n', ' */\n', 'library SafeMath {\n', '    function add(uint a, uint b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    function sub(uint a, uint b) internal pure returns (uint) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        require(b <= a, errorMessage);\n', '        uint c = a - b;\n', '\n', '        return c;\n', '    }\n', '    function mul(uint a, uint b) internal pure returns (uint) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '    function div(uint a, uint b) internal pure returns (uint) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint c = a / b;\n', '\n', '        return c;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function transferFrom(address from, address to, uint256 value) external;\n', '    function balanceOf(address who) external view returns (uint256);\n', '    function transfer(address to, uint256 value) external;\n', '}\n', '\n', '\n', 'contract SuperNodes {\n', '    using SafeMath for uint;\n', '\n', '    ERC20 public bcoin;\n', '    mapping(address => uint) public accountLevelMap;\n', '    mapping(address => uint) public accountDateMap;\n', '    mapping(address => uint) public accountWithdrawMap;\n', '\n', '    uint[] public incomes = [0,50000 ether,100000 ether,200000 ether,1000000 ether];\n', '\n', '    event BuyNode(address indexed addr, uint level);\n', '    event Withdraw(address indexed to, uint256 value);\n', '\n', '    constructor(address _bcoin)public {\n', '        bcoin = ERC20(_bcoin);\n', '    }\n', '\n', '    function buyNode( uint level) public {\n', '        require(level != 0, "!0 level");\n', '        require(level < 5, "!level");\n', '        require(accountLevelMap[msg.sender] == 0 );\n', '        uint cost = incomes[level];\n', '        uint allowed = bcoin.allowance(msg.sender,address(this));\n', '        uint balanced = bcoin.balanceOf(msg.sender);\n', '        require(allowed >= cost, "!allowed");\n', '        require(balanced >= cost, "!balanced");\n', '        bcoin.transferFrom( msg.sender,address(this), cost);\n', '\n', '        accountLevelMap[msg.sender] = level;\n', '        accountDateMap[msg.sender] = block.timestamp;\n', '\n', '        emit BuyNode(msg.sender,level);\n', '    }\n', '\n', '    function withdraw(uint value) public {\n', '        uint max = withdrawAble(msg.sender);\n', '        require(value <= max);\n', '        accountWithdrawMap[msg.sender] = accountWithdrawMap[msg.sender].add(value);\n', '        bcoin.transfer( msg.sender, value);\n', '        emit Withdraw(msg.sender, value);\n', '    }\n', '\n', '    function withdrawAble(address addr) public view returns (uint){\n', '        uint round = getCurrentRound(addr);\n', '        if(round == 0){\n', '            return 0;\n', '        }\n', '        round = round -1;\n', '        uint level = accountLevelMap[addr];\n', '        uint income = incomes[level];\n', '        uint released = income.div(10).mul(round);\n', '        return released.sub(accountWithdrawMap[addr]);\n', '    }\n', '\n', '    // 获取当前所处的轮数\n', '    function getCurrentRound(address addr) public view returns (uint){\n', '        uint inDate = accountDateMap[addr];\n', '        if(inDate == 0){\n', '            return 0;\n', '        }\n', '        uint begin =  inDate + 90 days;\n', '        if(begin >= block.timestamp){\n', '            return 1;\n', '        }\n', '        for(uint i = 1;i<=10;i++){\n', '            uint next = begin + (30 days)*i;\n', '            if(next >= block.timestamp){\n', '                return i+1;\n', '            }\n', '        }\n', '        return 12;\n', '    }\n', '\n', '    function nextTime(address addr) public view returns (uint){\n', '        uint inDate = accountDateMap[addr];\n', '        if(inDate == 0){\n', '            return 0;\n', '        }\n', '        uint begin =  inDate + 90 days;\n', '        if(begin >= block.timestamp){\n', '            return begin;\n', '        }\n', '        for(uint i = 1;i<=10;i++){\n', '            uint next = begin + (30 days)*i;\n', '            if(next >= block.timestamp){\n', '                return next;\n', '            }\n', '        }\n', '        return 0;\n', '    }\n', '\n', '}']