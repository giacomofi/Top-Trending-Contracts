['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-25\n', '*/\n', '\n', '/**\n', '\n', '  Source code of Opium Protocol\n', '  Web https://opium.network\n', '  Telegram https://t.me/opium_network\n', '  Twitter https://twitter.com/opium_network\n', '\n', ' */\n', '\n', '// File: LICENSE\n', '\n', '/**\n', '\n', 'The software and documentation available in this repository (the "Software") is protected by copyright law and accessible pursuant to the license set forth below. Copyright © 2020 Blockeys BV. All rights reserved.\n', '\n', 'Permission is hereby granted, free of charge, to any person or organization obtaining the Software (the “Licensee”) to privately study, review, and analyze the Software. Licensee shall not use the Software for any other purpose. Licensee shall not modify, transfer, assign, share, or sub-license the Software or any derivative works of the Software.\n', '\n', 'THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n', '*/\n', '\n', '// File: contracts/Lib/LibDerivative.sol\n', '\n', 'pragma solidity 0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/// @title Opium.Lib.LibDerivative contract should be inherited by contracts that use Derivative structure and calculate derivativeHash\n', 'contract LibDerivative {\n', '    // Opium derivative structure (ticker) definition\n', '    struct Derivative {\n', '        // Margin parameter for syntheticId\n', '        uint256 margin;\n', '        // Maturity of derivative\n', '        uint256 endTime;\n', '        // Additional parameters for syntheticId\n', '        uint256[] params;\n', '        // oracleId of derivative\n', '        address oracleId;\n', '        // Margin token address of derivative\n', '        address token;\n', '        // syntheticId of derivative\n', '        address syntheticId;\n', '    }\n', '\n', '    /// @notice Calculates hash of provided Derivative\n', '    /// @param _derivative Derivative Instance of derivative to hash\n', '    /// @return derivativeHash bytes32 Derivative hash\n', '    function getDerivativeHash(Derivative memory _derivative) public pure returns (bytes32 derivativeHash) {\n', '        derivativeHash = keccak256(abi.encodePacked(\n', '            _derivative.margin,\n', '            _derivative.endTime,\n', '            _derivative.params,\n', '            _derivative.oracleId,\n', '            _derivative.token,\n', '            _derivative.syntheticId\n', '        ));\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', "     * execution of a contract's constructor, its address will be reported as\n", '     * not containing a contract.\n', '     *\n', '     * IMPORTANT: It is unsafe to assume that an address for which this\n', '     * function returns false is an externally-owned account (EOA) and not a\n', '     * contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != 0x0 && codehash != accountHash);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' */\n', 'contract ReentrancyGuard {\n', '    // counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '}\n', '\n', '// File: erc721o/contracts/Libs/LibPosition.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', 'library LibPosition {\n', '  function getLongTokenId(bytes32 _hash) public pure returns (uint256 tokenId) {\n', '    tokenId = uint256(keccak256(abi.encodePacked(_hash, "LONG")));\n', '  }\n', '\n', '  function getShortTokenId(bytes32 _hash) public pure returns (uint256 tokenId) {\n', '    tokenId = uint256(keccak256(abi.encodePacked(_hash, "SHORT")));\n', '  }\n', '}\n', '\n', '// File: contracts/Interface/IDerivativeLogic.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '/// @title Opium.Interface.IDerivativeLogic contract is an interface that every syntheticId should implement\n', 'contract IDerivativeLogic is LibDerivative {\n', '    /// @notice Validates ticker\n', '    /// @param _derivative Derivative Instance of derivative to validate\n', '    /// @return Returns boolean whether ticker is valid\n', '    function validateInput(Derivative memory _derivative) public view returns (bool);\n', '\n', '    /// @notice Calculates margin required for derivative creation\n', '    /// @param _derivative Derivative Instance of derivative\n', '    /// @return buyerMargin uint256 Margin needed from buyer (LONG position)\n', '    /// @return sellerMargin uint256 Margin needed from seller (SHORT position)\n', '    function getMargin(Derivative memory _derivative) public view returns (uint256 buyerMargin, uint256 sellerMargin);\n', '\n', '    /// @notice Calculates payout for derivative execution\n', '    /// @param _derivative Derivative Instance of derivative\n', '    /// @param _result uint256 Data retrieved from oracleId on the maturity\n', '    /// @return buyerPayout uint256 Payout in ratio for buyer (LONG position holder)\n', '    /// @return sellerPayout uint256 Payout in ratio for seller (SHORT position holder)\n', '    function getExecutionPayout(Derivative memory _derivative, uint256 _result)\tpublic view returns (uint256 buyerPayout, uint256 sellerPayout);\n', '\n', '    /// @notice Returns syntheticId author address for Opium commissions\n', '    /// @return authorAddress address The address of syntheticId address\n', '    function getAuthorAddress() public view returns (address authorAddress);\n', '\n', '    /// @notice Returns syntheticId author commission in base of COMMISSION_BASE\n', '    /// @return commission uint256 Author commission\n', '    function getAuthorCommission() public view returns (uint256 commission);\n', '\n', "    /// @notice Returns whether thirdparty could execute on derivative's owner's behalf\n", '    /// @param _derivativeOwner address Derivative owner address\n', '    /// @return Returns boolean whether _derivativeOwner allowed third party execution\n', '    function thirdpartyExecutionAllowed(address _derivativeOwner) public view returns (bool);\n', '\n', '    /// @notice Returns whether syntheticId implements pool logic\n', '    /// @return Returns whether syntheticId implements pool logic\n', '    function isPool() public view returns (bool);\n', '\n', "    /// @notice Sets whether thirds parties are allowed or not to execute derivative's on msg.sender's behalf\n", '    /// @param _allow bool Flag for execution allowance\n', '    function allowThirdpartyExecution(bool _allow) public;\n', '\n', '    // Event with syntheticId metadata JSON string (for DIB.ONE derivative explorer)\n', '    event MetadataSet(string metadata);\n', '}\n', '\n', '// File: contracts/Errors/CoreErrors.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract CoreErrors {\n', '    string constant internal ERROR_CORE_NOT_POOL = "CORE:NOT_POOL";\n', '    string constant internal ERROR_CORE_CANT_BE_POOL = "CORE:CANT_BE_POOL";\n', '\n', '    string constant internal ERROR_CORE_TICKER_WAS_CANCELLED = "CORE:TICKER_WAS_CANCELLED";\n', '    string constant internal ERROR_CORE_SYNTHETIC_VALIDATION_ERROR = "CORE:SYNTHETIC_VALIDATION_ERROR";\n', '    string constant internal ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE = "CORE:NOT_ENOUGH_TOKEN_ALLOWANCE";\n', '\n', '    string constant internal ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH = "CORE:TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH";\n', '    string constant internal ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH = "CORE:TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH";\n', '\n', '    string constant internal ERROR_CORE_EXECUTION_BEFORE_MATURITY_NOT_ALLOWED = "CORE:EXECUTION_BEFORE_MATURITY_NOT_ALLOWED";\n', '    string constant internal ERROR_CORE_SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED = "CORE:SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED";\n', '    string constant internal ERROR_CORE_INSUFFICIENT_POOL_BALANCE = "CORE:INSUFFICIENT_POOL_BALANCE";\n', '\n', '    string constant internal ERROR_CORE_CANT_CANCEL_DUMMY_ORACLE_ID = "CORE:CANT_CANCEL_DUMMY_ORACLE_ID";\n', '    string constant internal ERROR_CORE_CANCELLATION_IS_NOT_ALLOWED = "CORE:CANCELLATION_IS_NOT_ALLOWED";\n', '\n', '    string constant internal ERROR_CORE_UNKNOWN_POSITION_TYPE = "CORE:UNKNOWN_POSITION_TYPE";\n', '}\n', '\n', '// File: contracts/Errors/RegistryErrors.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract RegistryErrors {\n', '    string constant internal ERROR_REGISTRY_ONLY_INITIALIZER = "REGISTRY:ONLY_INITIALIZER";\n', '    string constant internal ERROR_REGISTRY_ONLY_OPIUM_ADDRESS_ALLOWED = "REGISTRY:ONLY_OPIUM_ADDRESS_ALLOWED";\n', '    \n', '    string constant internal ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS = "REGISTRY:CANT_BE_ZERO_ADDRESS";\n', '\n', '    string constant internal ERROR_REGISTRY_ALREADY_SET = "REGISTRY:ALREADY_SET";\n', '}\n', '\n', '// File: contracts/Registry.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '/// @title Opium.Registry contract keeps addresses of deployed Opium contracts set to allow them route and communicate to each other\n', 'contract Registry is RegistryErrors {\n', '\n', '    // Address of Opium.TokenMinter contract\n', '    address private minter;\n', '\n', '    // Address of Opium.Core contract\n', '    address private core;\n', '\n', '    // Address of Opium.OracleAggregator contract\n', '    address private oracleAggregator;\n', '\n', '    // Address of Opium.SyntheticAggregator contract\n', '    address private syntheticAggregator;\n', '\n', '    // Address of Opium.TokenSpender contract\n', '    address private tokenSpender;\n', '\n', '    // Address of Opium commission receiver\n', '    address private opiumAddress;\n', '\n', '    // Address of Opium contract set deployer\n', '    address public initializer;\n', '\n', '    /// @notice This modifier restricts access to functions, which could be called only by initializer\n', '    modifier onlyInitializer() {\n', '        require(msg.sender == initializer, ERROR_REGISTRY_ONLY_INITIALIZER);\n', '        _;\n', '    }\n', '\n', '    /// @notice Sets initializer\n', '    constructor() public {\n', '        initializer = msg.sender;\n', '    }\n', '\n', '    // SETTERS\n', '\n', '    /// @notice Sets Opium.TokenMinter, Opium.Core, Opium.OracleAggregator, Opium.SyntheticAggregator, Opium.TokenSpender, Opium commission receiver addresses and allows to do it only once\n', '    /// @param _minter address Address of Opium.TokenMinter\n', '    /// @param _core address Address of Opium.Core\n', '    /// @param _oracleAggregator address Address of Opium.OracleAggregator\n', '    /// @param _syntheticAggregator address Address of Opium.SyntheticAggregator\n', '    /// @param _tokenSpender address Address of Opium.TokenSpender\n', '    /// @param _opiumAddress address Address of Opium commission receiver\n', '    function init(\n', '        address _minter,\n', '        address _core,\n', '        address _oracleAggregator,\n', '        address _syntheticAggregator,\n', '        address _tokenSpender,\n', '        address _opiumAddress\n', '    ) external onlyInitializer {\n', '        require(\n', '            minter == address(0) &&\n', '            core == address(0) &&\n', '            oracleAggregator == address(0) &&\n', '            syntheticAggregator == address(0) &&\n', '            tokenSpender == address(0) &&\n', '            opiumAddress == address(0),\n', '            ERROR_REGISTRY_ALREADY_SET\n', '        );\n', '\n', '        require(\n', '            _minter != address(0) &&\n', '            _core != address(0) &&\n', '            _oracleAggregator != address(0) &&\n', '            _syntheticAggregator != address(0) &&\n', '            _tokenSpender != address(0) &&\n', '            _opiumAddress != address(0),\n', '            ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS\n', '        );\n', '\n', '        minter = _minter;\n', '        core = _core;\n', '        oracleAggregator = _oracleAggregator;\n', '        syntheticAggregator = _syntheticAggregator;\n', '        tokenSpender = _tokenSpender;\n', '        opiumAddress = _opiumAddress;\n', '    }\n', '\n', '    /// @notice Allows opium commission receiver address to change itself\n', '    /// @param _opiumAddress address New opium commission receiver address\n', '    function changeOpiumAddress(address _opiumAddress) external {\n', '        require(opiumAddress == msg.sender, ERROR_REGISTRY_ONLY_OPIUM_ADDRESS_ALLOWED);\n', '        require(_opiumAddress != address(0), ERROR_REGISTRY_CANT_BE_ZERO_ADDRESS);\n', '        opiumAddress = _opiumAddress;\n', '    }\n', '\n', '    // GETTERS\n', '\n', '    /// @notice Returns address of Opium.TokenMinter\n', '    /// @param result address Address of Opium.TokenMinter\n', '    function getMinter() external view returns (address result) {\n', '        return minter;\n', '    }\n', '\n', '    /// @notice Returns address of Opium.Core\n', '    /// @param result address Address of Opium.Core\n', '    function getCore() external view returns (address result) {\n', '        return core;\n', '    }\n', '\n', '    /// @notice Returns address of Opium.OracleAggregator\n', '    /// @param result address Address of Opium.OracleAggregator\n', '    function getOracleAggregator() external view returns (address result) {\n', '        return oracleAggregator;\n', '    }\n', '\n', '    /// @notice Returns address of Opium.SyntheticAggregator\n', '    /// @param result address Address of Opium.SyntheticAggregator\n', '    function getSyntheticAggregator() external view returns (address result) {\n', '        return syntheticAggregator;\n', '    }\n', '\n', '    /// @notice Returns address of Opium.TokenSpender\n', '    /// @param result address Address of Opium.TokenSpender\n', '    function getTokenSpender() external view returns (address result) {\n', '        return tokenSpender;\n', '    }\n', '\n', '    /// @notice Returns address of Opium commission receiver\n', '    /// @param result address Address of Opium commission receiver\n', '    function getOpiumAddress() external view returns (address result) {\n', '        return opiumAddress;\n', '    }\n', '}\n', '\n', '// File: contracts/Errors/UsingRegistryErrors.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract UsingRegistryErrors {\n', '    string constant internal ERROR_USING_REGISTRY_ONLY_CORE_ALLOWED = "USING_REGISTRY:ONLY_CORE_ALLOWED";\n', '}\n', '\n', '// File: contracts/Lib/UsingRegistry.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '/// @title Opium.Lib.UsingRegistry contract should be inherited by contracts, that are going to use Opium.Registry\n', 'contract UsingRegistry is UsingRegistryErrors {\n', '    // Emitted when registry instance is set\n', '    event RegistrySet(address registry);\n', '\n', '    // Instance of Opium.Registry contract\n', '    Registry internal registry;\n', '\n', '    /// @notice This modifier restricts access to functions, which could be called only by Opium.Core\n', '    modifier onlyCore() {\n', '        require(msg.sender == registry.getCore(), ERROR_USING_REGISTRY_ONLY_CORE_ALLOWED);\n', '        _;\n', '    }\n', '\n', '    /// @notice Defines registry instance and emits appropriate event\n', '    constructor(address _registry) public {\n', '        registry = Registry(_registry);\n', '        emit RegistrySet(_registry);\n', '    }\n', '\n', '    /// @notice Getter for registry variable\n', '    /// @return address Address of registry set in current contract\n', '    function getRegistry() external view returns (address) {\n', '        return address(registry);\n', '    }\n', '}\n', '\n', '// File: contracts/Lib/LibCommission.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '/// @title Opium.Lib.LibCommission contract defines constants for Opium commissions\n', 'contract LibCommission {\n', '    // Represents 100% base for commissions calculation\n', '    uint256 constant public COMMISSION_BASE = 10000;\n', '\n', '    // Represents 100% base for Opium commission\n', '    uint256 constant public OPIUM_COMMISSION_BASE = 10;\n', '\n', '    // Represents which part of `syntheticId` author commissions goes to opium\n', '    uint256 constant public OPIUM_COMMISSION_PART = 1;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', '// File: erc721o/contracts/Libs/UintArray.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', 'library UintArray {\n', '  function indexOf(uint256[] memory A, uint256 a) internal pure returns (uint256, bool) {\n', '    uint256 length = A.length;\n', '    for (uint256 i = 0; i < length; i++) {\n', '      if (A[i] == a) {\n', '        return (i, true);\n', '      }\n', '    }\n', '    return (0, false);\n', '  }\n', '\n', '  function contains(uint256[] memory A, uint256 a) internal pure returns (bool) {\n', '    (, bool isIn) = indexOf(A, a);\n', '    return isIn;\n', '  }\n', '\n', '  function difference(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory, uint256[] memory) {\n', '    uint256 length = A.length;\n', '    bool[] memory includeMap = new bool[](length);\n', '    uint256 count = 0;\n', "    // First count the new length because can't push for in-memory arrays\n", '    for (uint256 i = 0; i < length; i++) {\n', '      uint256 e = A[i];\n', '      if (!contains(B, e)) {\n', '        includeMap[i] = true;\n', '        count++;\n', '      }\n', '    }\n', '    uint256[] memory newUints = new uint256[](count);\n', '    uint256[] memory newUintsIdxs = new uint256[](count);\n', '    uint256 j = 0;\n', '    for (uint256 i = 0; i < length; i++) {\n', '      if (includeMap[i]) {\n', '        newUints[j] = A[i];\n', '        newUintsIdxs[j] = i;\n', '        j++;\n', '      }\n', '    }\n', '    return (newUints, newUintsIdxs);\n', '  }\n', '\n', '  function intersect(uint256[] memory A, uint256[] memory B) internal pure returns (uint256[] memory, uint256[] memory, uint256[] memory) {\n', '    uint256 length = A.length;\n', '    bool[] memory includeMap = new bool[](length);\n', '    uint256 newLength = 0;\n', '    for (uint256 i = 0; i < length; i++) {\n', '      if (contains(B, A[i])) {\n', '        includeMap[i] = true;\n', '        newLength++;\n', '      }\n', '    }\n', '    uint256[] memory newUints = new uint256[](newLength);\n', '    uint256[] memory newUintsAIdxs = new uint256[](newLength);\n', '    uint256[] memory newUintsBIdxs = new uint256[](newLength);\n', '    uint256 j = 0;\n', '    for (uint256 i = 0; i < length; i++) {\n', '      if (includeMap[i]) {\n', '        newUints[j] = A[i];\n', '        newUintsAIdxs[j] = i;\n', '        (newUintsBIdxs[j], ) = indexOf(B, A[i]);\n', '        j++;\n', '      }\n', '    }\n', '    return (newUints, newUintsAIdxs, newUintsBIdxs);\n', '  }\n', '\n', '  function isUnique(uint256[] memory A) internal pure returns (bool) {\n', '    uint256 length = A.length;\n', '\n', '    for (uint256 i = 0; i < length; i++) {\n', '      (uint256 idx, bool isIn) = indexOf(A, A[i]);\n', '\n', '      if (isIn && idx < i) {\n', '        return false;\n', '      }\n', '    }\n', '\n', '    return true;\n', '  }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts may inherit from this and call {_registerInterface} to declare\n', ' * their support of an interface.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    /*\n', "     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n", '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    /**\n', "     * @dev Mapping of interface ids to whether or not it's supported.\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () internal {\n', '        // Derived contracts need only register support for their own interfaces,\n', '        // we register support for ERC165 itself here\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     *\n', '     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev Registers the contract as an implementer of the interface defined by\n', '     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n', '     * registering its interface id is not required.\n', '     *\n', '     * See {IERC165-supportsInterface}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC721 compliant contract.\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    /**\n', "     * @dev Returns the number of NFTs in `owner`'s account.\n", '     */\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '\n', '    /**\n', '     * @dev Returns the owner of the NFT specified by `tokenId`.\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    /**\n', '     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     *\n', '     *\n', '     * Requirements:\n', '     * - `from`, `to` cannot be zero.\n', '     * - `tokenId` must be owned by `from`.\n', '     * - If the caller is not `from`, it must be have been allowed to move this\n', '     * NFT by either {approve} or {setApprovalForAll}.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '    /**\n', '     * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Requirements:\n', '     * - If the caller is not `from`, it must be approved to move this NFT by\n', '     * either {approve} or {setApprovalForAll}.\n', '     */\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: erc721o/contracts/Interfaces/IERC721O.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', 'contract IERC721O {\n', '  // Token description\n', '  function name() external view returns (string memory);\n', '  function symbol() external view returns (string memory);\n', '  function totalSupply() public view returns (uint256);\n', '  function exists(uint256 _tokenId) public view returns (bool);\n', '\n', '  function implementsERC721() public pure returns (bool);\n', '  function tokenByIndex(uint256 _index) public view returns (uint256);\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n', '  function tokenURI(uint256 _tokenId) public view returns (string memory tokenUri);\n', '  function getApproved(uint256 _tokenId) public view returns (address);\n', '  \n', '  function implementsERC721O() public pure returns (bool);\n', '  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n', '  function balanceOf(address owner) public view returns (uint256);\n', '  function balanceOf(address _owner, uint256 _tokenId) public view returns (uint256);\n', '  function tokensOwned(address _owner) public view returns (uint256[] memory, uint256[] memory);\n', '\n', '  // Non-Fungible Safe Transfer From\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public;\n', '\n', '  // Non-Fungible Unsafe Transfer From\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n', '\n', '  // Fungible Unsafe Transfer\n', '  function transfer(address _to, uint256 _tokenId, uint256 _quantity) public;\n', '\n', '  // Fungible Unsafe Transfer From\n', '  function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _quantity) public;\n', '\n', '  // Fungible Safe Transfer From\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public;\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes memory _data) public;\n', '\n', '  // Fungible Safe Batch Transfer From\n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public;\n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts, bytes memory _data) public;\n', '\n', '  // Fungible Unsafe Batch Transfer From\n', '  function batchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public;\n', '\n', '  // Approvals\n', '  function setApprovalForAll(address _operator, bool _approved) public;\n', '  function approve(address _to, uint256 _tokenId) public;\n', '  function getApproved(uint256 _tokenId, address _tokenOwner) public view returns (address);\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool isOperator);\n', '  function isApprovedOrOwner(address _spender, address _owner, uint256 _tokenId) public view returns (bool);\n', '  function permit(address _holder, address _spender, uint256 _nonce, uint256 _expiry, bool _allowed, bytes calldata _signature) external;\n', '\n', '  // Composable\n', '  function compose(uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public;\n', '  function decompose(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public;\n', '  function recompose(uint256 _portfolioId, uint256[] memory _initialTokenIds, uint256[] memory _initialTokenRatio, uint256[] memory _finalTokenIds, uint256[] memory _finalTokenRatio, uint256 _quantity) public;\n', '\n', '  // Required Events\n', '  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '  event TransferWithQuantity(address indexed from, address indexed to, uint256 indexed tokenId, uint256 quantity);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '  event BatchTransfer(address indexed from, address indexed to, uint256[] tokenTypes, uint256[] amounts);\n', '  event Composition(uint256 portfolioId, uint256[] tokenIds, uint256[] tokenRatio);\n', '}\n', '\n', '// File: erc721o/contracts/Interfaces/IERC721OReceiver.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', '/**\n', ' * @title ERC721O token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' *  from ERC721O contracts.\n', ' */\n', 'contract IERC721OReceiver {\n', '  /**\n', '    * @dev Magic value to be returned upon successful reception of an amount of ERC721O tokens\n', '    *  ERC721O_RECEIVED = `bytes4(keccak256("onERC721OReceived(address,address,uint256,uint256,bytes)"))` = 0xf891ffe0\n', '    *  ERC721O_BATCH_RECEIVED = `bytes4(keccak256("onERC721OBatchReceived(address,address,uint256[],uint256[],bytes)"))` = 0xd0e17c0b\n', '    */\n', '  bytes4 constant internal ERC721O_RECEIVED = 0xf891ffe0;\n', '  bytes4 constant internal ERC721O_BATCH_RECEIVED = 0xd0e17c0b;\n', '\n', '  function onERC721OReceived(\n', '    address _operator,\n', '    address _from,\n', '    uint256 tokenId,\n', '    uint256 amount,\n', '    bytes memory data\n', '  ) public returns(bytes4);\n', '\n', '  function onERC721OBatchReceived(\n', '    address _operator,\n', '    address _from,\n', '    uint256[] memory _types,\n', '    uint256[] memory _amounts,\n', '    bytes memory _data\n', '  ) public returns (bytes4);\n', '}\n', '\n', '// File: erc721o/contracts/Libs/ObjectsLib.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', '\n', 'library ObjectLib {\n', '  // Libraries\n', '  using SafeMath for uint256;\n', '\n', '  enum Operations { ADD, SUB, REPLACE }\n', '\n', '  // Constants regarding bin or chunk sizes for balance packing\n', '  uint256 constant TYPES_BITS_SIZE   = 32;                     // Max size of each object\n', '  uint256 constant TYPES_PER_UINT256 = 256 / TYPES_BITS_SIZE; // Number of types per uint256\n', '\n', '  //\n', '  // Objects and Tokens Functions\n', '  //\n', '\n', '  /**\n', '  * @dev Return the bin number and index within that bin where ID is\n', '  * @param _tokenId Object type\n', "  * @return (Bin number, ID's index within that bin)\n", '  */\n', '  function getTokenBinIndex(uint256 _tokenId) internal pure returns (uint256 bin, uint256 index) {\n', '    bin = _tokenId * TYPES_BITS_SIZE / 256;\n', '    index = _tokenId % TYPES_PER_UINT256;\n', '    return (bin, index);\n', '  }\n', '\n', '\n', '  /**\n', '  * @dev update the balance of a type provided in _binBalances\n', '  * @param _binBalances Uint256 containing the balances of objects\n', '  * @param _index Index of the object in the provided bin\n', '  * @param _amount Value to update the type balance\n', '  * @param _operation Which operation to conduct :\n', '  *     Operations.REPLACE : Replace type balance with _amount\n', '  *     Operations.ADD     : ADD _amount to type balance\n', '  *     Operations.SUB     : Substract _amount from type balance\n', '  */\n', '  function updateTokenBalance(\n', '    uint256 _binBalances,\n', '    uint256 _index,\n', '    uint256 _amount,\n', '    Operations _operation) internal pure returns (uint256 newBinBalance)\n', '  {\n', '    uint256 objectBalance;\n', '    if (_operation == Operations.ADD) {\n', '      objectBalance = getValueInBin(_binBalances, _index);\n', '      newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.add(_amount));\n', '    } else if (_operation == Operations.SUB) {\n', '      objectBalance = getValueInBin(_binBalances, _index);\n', '      newBinBalance = writeValueInBin(_binBalances, _index, objectBalance.sub(_amount));\n', '    } else if (_operation == Operations.REPLACE) {\n', '      newBinBalance = writeValueInBin(_binBalances, _index, _amount);\n', '    } else {\n', '      revert("Invalid operation"); // Bad operation\n', '    }\n', '\n', '    return newBinBalance;\n', '  }\n', '  \n', '  /*\n', '  * @dev return value in _binValue at position _index\n', '  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n', '  * @param _index index at which to retrieve value\n', '  * @return Value at given _index in _bin\n', '  */\n', '  function getValueInBin(uint256 _binValue, uint256 _index) internal pure returns (uint256) {\n', '\n', '    // Mask to retrieve data for a given binData\n', '    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n', '\n', '    // Shift amount\n', '    uint256 rightShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n', '    return (_binValue >> rightShift) & mask;\n', '  }\n', '\n', '  /**\n', '  * @dev return the updated _binValue after writing _amount at _index\n', '  * @param _binValue uint256 containing the balances of TYPES_PER_UINT256 types\n', '  * @param _index Index at which to retrieve value\n', '  * @param _amount Value to store at _index in _bin\n', '  * @return Value at given _index in _bin\n', '  */\n', '  function writeValueInBin(uint256 _binValue, uint256 _index, uint256 _amount) internal pure returns (uint256) {\n', '    require(_amount < 2**TYPES_BITS_SIZE, "Amount to write in bin is too large");\n', '\n', '    // Mask to retrieve data for a given binData\n', '    uint256 mask = (uint256(1) << TYPES_BITS_SIZE) - 1;\n', '\n', '    // Shift amount\n', '    uint256 leftShift = 256 - TYPES_BITS_SIZE * (_index + 1);\n', '    return (_binValue & ~(mask << leftShift) ) | (_amount << leftShift);\n', '  }\n', '\n', '}\n', '\n', '// File: erc721o/contracts/ERC721OBase.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC721OBase is IERC721O, ERC165, IERC721 {\n', '  // Libraries\n', '  using ObjectLib for ObjectLib.Operations;\n', '  using ObjectLib for uint256;\n', '\n', '  // Array with all tokenIds\n', '  uint256[] internal allTokens;\n', '\n', '  // Packed balances\n', '  mapping(address => mapping(uint256 => uint256)) internal packedTokenBalance;\n', '\n', '  // Operators\n', '  mapping(address => mapping(address => bool)) internal operators;\n', '\n', '  // Keeps aprovals for tokens from owner to approved address\n', '  // tokenApprovals[tokenId][owner] = approved\n', '  mapping (uint256 => mapping (address => address)) internal tokenApprovals;\n', '\n', '  // Token Id state\n', '  mapping(uint256 => uint256) internal tokenTypes;\n', '\n', '  uint256 constant internal INVALID = 0;\n', '  uint256 constant internal POSITION = 1;\n', '  uint256 constant internal PORTFOLIO = 2;\n', '\n', '  // Interface constants\n', '  bytes4 internal constant INTERFACE_ID_ERC721O = 0x12345678;\n', '\n', '  // EIP712 constants\n', '  bytes32 public DOMAIN_SEPARATOR;\n', '  bytes32 public PERMIT_TYPEHASH;\n', '\n', '  // mapping holds nonces for approval permissions\n', '  // nonces[holder] => nonce\n', '  mapping (address => uint) public nonces;\n', '\n', '  modifier isOperatorOrOwner(address _from) {\n', '    require((msg.sender == _from) || operators[_from][msg.sender], "msg.sender is neither _from nor operator");\n', '    _;\n', '  }\n', '\n', '  constructor() public {\n', '    _registerInterface(INTERFACE_ID_ERC721O);\n', '    \n', '    // Calculate EIP712 constants\n', '    DOMAIN_SEPARATOR = keccak256(abi.encode(\n', '      keccak256("EIP712Domain(string name,string version,address verifyingContract)"),\n', '      keccak256(bytes("ERC721o")),\n', '      keccak256(bytes("1")),\n', '      address(this)\n', '    ));\n', '    PERMIT_TYPEHASH = keccak256("Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)");\n', '  }\n', '\n', '  function implementsERC721O() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns whether the specified token exists\n', '   * @param _tokenId uint256 ID of the token to query the existence of\n', '   * @return whether the token exists\n', '   */\n', '  function exists(uint256 _tokenId) public view returns (bool) {\n', '    return tokenTypes[_tokenId] != INVALID;\n', '  }\n', '\n', '  /**\n', "   * @dev return the _tokenId type' balance of _address\n", '   * @param _address Address to query balance of\n', '   * @param _tokenId type to query balance of\n', '   * @return Amount of objects of a given type ID\n', '   */\n', '  function balanceOf(address _address, uint256 _tokenId) public view returns (uint256) {\n', '    (uint256 bin, uint256 index) = _tokenId.getTokenBinIndex();\n', '    return packedTokenBalance[_address][bin].getValueInBin(index);\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the total amount of tokens stored by the contract\n', '   * @return uint256 representing the total amount of tokens\n', '   */\n', '  function totalSupply() public view returns (uint256) {\n', '    return allTokens.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Gets Iterate through the list of existing tokens and return the indexes\n', '   *        and balances of the tokens owner by the user\n', '   * @param _owner The adddress we are checking\n', '   * @return indexes The tokenIds\n', '   * @return balances The balances of each token\n', '   */\n', '  function tokensOwned(address _owner) public view returns (uint256[] memory indexes, uint256[] memory balances) {\n', '    uint256 numTokens = totalSupply();\n', '    uint256[] memory tokenIndexes = new uint256[](numTokens);\n', '    uint256[] memory tempTokens = new uint256[](numTokens);\n', '\n', '    uint256 count;\n', '    for (uint256 i = 0; i < numTokens; i++) {\n', '      uint256 tokenId = allTokens[i];\n', '      if (balanceOf(_owner, tokenId) > 0) {\n', '        tempTokens[count] = balanceOf(_owner, tokenId);\n', '        tokenIndexes[count] = tokenId;\n', '        count++;\n', '      }\n', '    }\n', '\n', '    // copy over the data to a correct size array\n', '    uint256[] memory _ownedTokens = new uint256[](count);\n', '    uint256[] memory _ownedTokensIndexes = new uint256[](count);\n', '\n', '    for (uint256 i = 0; i < count; i++) {\n', '      _ownedTokens[i] = tempTokens[i];\n', '      _ownedTokensIndexes[i] = tokenIndexes[i];\n', '    }\n', '\n', '    return (_ownedTokensIndexes, _ownedTokens);\n', '  }\n', '\n', '  /**\n', '   * @dev Will set _operator operator status to true or false\n', '   * @param _operator Address to changes operator status.\n', "   * @param _approved  _operator's new operator status (true or false)\n", '   */\n', '  function setApprovalForAll(address _operator, bool _approved) public {\n', '    // Update operator status\n', '    operators[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /// @notice Approve for all by signature\n', '  function permit(address _holder, address _spender, uint256 _nonce, uint256 _expiry, bool _allowed, bytes calldata _signature) external {\n', '    // Calculate hash\n', '    bytes32 digest =\n', '      keccak256(abi.encodePacked(\n', '        "\\x19\\x01",\n', '        DOMAIN_SEPARATOR,\n', '        keccak256(abi.encode(\n', '          PERMIT_TYPEHASH,\n', '          _holder,\n', '          _spender,\n', '          _nonce,\n', '          _expiry,\n', '          _allowed\n', '        ))\n', '    ));\n', '\n', '    // Divide the signature in r, s and v variables\n', '    // ecrecover takes the signature parameters, and the only way to get them\n', '    // currently is to use assembly.\n', '    // solium-disable-next-line security/no-inline-assembly\n', '    bytes32 r;\n', '    bytes32 s;\n', '    uint8 v;\n', '\n', '    bytes memory signature = _signature;\n', '\n', '    assembly {\n', '      r := mload(add(signature, 32))\n', '      s := mload(add(signature, 64))\n', '      v := byte(0, mload(add(signature, 96)))\n', '    }\n', '\n', '    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '    if (v < 27) {\n', '      v += 27;\n', '    }\n', '\n', '    address recoveredAddress;\n', '\n', '    // If the version is correct return the signer address\n', '    if (v != 27 && v != 28) {\n', '      recoveredAddress = address(0);\n', '    } else {\n', '      // solium-disable-next-line arg-overflow\n', '      recoveredAddress = ecrecover(digest, v, r, s);\n', '    }\n', '\n', '    require(_holder != address(0), "Holder can\'t be zero address");\n', '    require(_holder == recoveredAddress, "Signer address is invalid");\n', '    require(_expiry == 0 || now <= _expiry, "Permission expired");\n', '    require(_nonce == nonces[_holder]++, "Nonce is invalid");\n', '    \n', '    // Update operator status\n', '    operators[_holder][_spender] = _allowed;\n', '    emit ApprovalForAll(_holder, _spender, _allowed);\n', '  }\n', '\n', '  /**\n', '   * @dev Approves another address to transfer the given token ID\n', '   * The zero address indicates there is no approved address.\n', '   * There can only be one approved address per token at a given time.\n', '   * Can only be called by the token owner or an approved operator.\n', '   * @param _to address to be approved for the given token ID\n', '   * @param _tokenId uint256 ID of the token to be approved\n', '   */\n', '  function approve(address _to, uint256 _tokenId) public {\n', '    require(_to != msg.sender, "Can\'t approve to yourself");\n', '    tokenApprovals[_tokenId][msg.sender] = _to;\n', '    emit Approval(msg.sender, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address for a token ID, or zero if no address set\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved for the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId, address _tokenOwner) public view returns (address) {\n', '    return tokenApprovals[_tokenId][_tokenOwner];\n', '  }\n', '\n', '  /**\n', '   * @dev Function that verifies whether _operator is an authorized operator of _tokenHolder.\n', '   * @param _operator The address of the operator to query status of\n', '   * @param _owner Address of the tokenHolder\n', '   * @return A uint256 specifying the amount of tokens still available for the spender.\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) public view returns (bool isOperator) {\n', '    return operators[_owner][_operator];\n', '  }\n', '\n', '  function isApprovedOrOwner(\n', '    address _spender,\n', '    address _owner,\n', '    uint256 _tokenId\n', '  ) public view returns (bool) {\n', '    return (\n', '      _spender == _owner ||\n', '      getApproved(_tokenId, _owner) == _spender ||\n', '      isApprovedForAll(_owner, _spender)\n', '    );\n', '  }\n', '\n', '  function _updateTokenBalance(\n', '    address _from,\n', '    uint256 _tokenId,\n', '    uint256 _amount,\n', '    ObjectLib.Operations op\n', '  ) internal {\n', '    (uint256 bin, uint256 index) = _tokenId.getTokenBinIndex();\n', '    packedTokenBalance[_from][bin] = packedTokenBalance[_from][bin].updateTokenBalance(\n', '      index, _amount, op\n', '    );\n', '  }\n', '}\n', '\n', '// File: erc721o/contracts/ERC721OTransferable.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', '\n', '\n', '\n', 'contract ERC721OTransferable is ERC721OBase, ReentrancyGuard {\n', '  // Libraries\n', '  using Address for address;\n', '\n', '  // safeTransfer constants\n', '  bytes4 internal constant ERC721O_RECEIVED = 0xf891ffe0;\n', '  bytes4 internal constant ERC721O_BATCH_RECEIVED = 0xd0e17c0b;\n', '\n', '  function batchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public {\n', '    // Batch Transfering\n', '    _batchTransferFrom(_from, _to, _tokenIds, _amounts);\n', '  }\n', '\n', '  /**\n', '    * @dev transfer objects from different tokenIds to specified address\n', '    * @param _from The address to BatchTransfer objects from.\n', '    * @param _to The address to batchTransfer objects to.\n', '    * @param _tokenIds Array of tokenIds to update balance of\n', '    * @param _amounts Array of amount of object per type to be transferred.\n', '    * @param _data Data to pass to onERC721OReceived() function if recipient is contract\n', '    * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).\n', '    */\n', '  function safeBatchTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256[] memory _tokenIds,\n', '    uint256[] memory _amounts,\n', '    bytes memory _data\n', '  ) public nonReentrant {\n', '    // Batch Transfering\n', '    _batchTransferFrom(_from, _to, _tokenIds, _amounts);\n', '\n', '    // Pass data if recipient is contract\n', '    if (_to.isContract()) {\n', '      bytes4 retval = IERC721OReceiver(_to).onERC721OBatchReceived(\n', '        msg.sender, _from, _tokenIds, _amounts, _data\n', '      );\n', '      require(retval == ERC721O_BATCH_RECEIVED);\n', '    }\n', '  }\n', '\n', '  function safeBatchTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256[] memory _tokenIds,\n', '    uint256[] memory _amounts\n', '  ) public {\n', '    safeBatchTransferFrom(_from, _to, _tokenIds, _amounts, "");\n', '  }\n', '\n', '  function transfer(address _to, uint256 _tokenId, uint256 _amount) public {\n', '    _transferFrom(msg.sender, _to, _tokenId, _amount);\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {\n', '    _transferFrom(_from, _to, _tokenId, _amount);\n', '  }\n', '\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) public {\n', '    safeTransferFrom(_from, _to, _tokenId, _amount, "");\n', '  }\n', '\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes memory _data) public nonReentrant {\n', '    _transferFrom(_from, _to, _tokenId, _amount);\n', '    require(\n', '      _checkAndCallSafeTransfer(_from, _to, _tokenId, _amount, _data),\n', '      "Sent to a contract which is not an ERC721O receiver"\n', '    );\n', '  }\n', '\n', '  /**\n', '    * @dev transfer objects from different tokenIds to specified address\n', '    * @param _from The address to BatchTransfer objects from.\n', '    * @param _to The address to batchTransfer objects to.\n', '    * @param _tokenIds Array of tokenIds to update balance of\n', '    * @param _amounts Array of amount of object per type to be transferred.\n', '    * Note:  Arrays should be sorted so that all tokenIds in a same bin are adjacent (more efficient).\n', '    */\n', '  function _batchTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256[] memory _tokenIds,\n', '    uint256[] memory _amounts\n', '  ) internal isOperatorOrOwner(_from) {\n', '    // Requirements\n', '    require(_tokenIds.length == _amounts.length, "Inconsistent array length between args");\n', '    require(_to != address(0), "Invalid to address");\n', '\n', '    // Number of transfers to execute\n', '    uint256 nTransfer = _tokenIds.length;\n', '\n', "    // Don't do useless calculations\n", '    if (_from == _to) {\n', '      for (uint256 i = 0; i < nTransfer; i++) {\n', '        emit Transfer(_from, _to, _tokenIds[i]);\n', '        emit TransferWithQuantity(_from, _to, _tokenIds[i], _amounts[i]);\n', '      }\n', '      return;\n', '    }\n', '\n', '    for (uint256 i = 0; i < nTransfer; i++) {\n', '      require(_amounts[i] <= balanceOf(_from, _tokenIds[i]), "Quantity greater than from balance");\n', '      _updateTokenBalance(_from, _tokenIds[i], _amounts[i], ObjectLib.Operations.SUB);\n', '      _updateTokenBalance(_to, _tokenIds[i], _amounts[i], ObjectLib.Operations.ADD);\n', '\n', '      emit Transfer(_from, _to, _tokenIds[i]);\n', '      emit TransferWithQuantity(_from, _to, _tokenIds[i], _amounts[i]);\n', '    }\n', '\n', '    // Emit batchTransfer event\n', '    emit BatchTransfer(_from, _to, _tokenIds, _amounts);\n', '  }\n', '\n', '  function _transferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount) internal {\n', '    require(isApprovedOrOwner(msg.sender, _from, _tokenId), "Not approved");\n', '    require(_amount <= balanceOf(_from, _tokenId), "Quantity greater than from balance");\n', '    require(_to != address(0), "Invalid to address");\n', '\n', '    _updateTokenBalance(_from, _tokenId, _amount, ObjectLib.Operations.SUB);\n', '    _updateTokenBalance(_to, _tokenId, _amount, ObjectLib.Operations.ADD);\n', '    emit Transfer(_from, _to, _tokenId);\n', '    emit TransferWithQuantity(_from, _to, _tokenId, _amount);\n', '  }\n', '\n', '  function _checkAndCallSafeTransfer(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    uint256 _amount,\n', '    bytes memory _data\n', '  ) internal returns (bool) {\n', '    if (!_to.isContract()) {\n', '      return true;\n', '    }\n', '\n', '    bytes4 retval = IERC721OReceiver(_to).onERC721OReceived(msg.sender, _from, _tokenId, _amount, _data);\n', '    return(retval == ERC721O_RECEIVED);\n', '  }\n', '}\n', '\n', '// File: erc721o/contracts/ERC721OMintable.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', '\n', '\n', 'contract ERC721OMintable is ERC721OTransferable {\n', '  // Libraries\n', '  using LibPosition for bytes32;\n', '\n', '  // Internal functions\n', '  function _mint(uint256 _tokenId, address _to, uint256 _supply) internal {\n', "    // If the token doesn't exist, add it to the tokens array\n", '    if (!exists(_tokenId)) {\n', '      tokenTypes[_tokenId] = POSITION;\n', '      allTokens.push(_tokenId);\n', '    }\n', '\n', '    _updateTokenBalance(_to, _tokenId, _supply, ObjectLib.Operations.ADD);\n', '    emit Transfer(address(0), _to, _tokenId);\n', '    emit TransferWithQuantity(address(0), _to, _tokenId, _supply);\n', '  }\n', '\n', '  function _burn(address _tokenOwner, uint256 _tokenId, uint256 _quantity) internal {\n', '    uint256 ownerBalance = balanceOf(_tokenOwner, _tokenId);\n', '    require(ownerBalance >= _quantity, "TOKEN_MINTER:NOT_ENOUGH_POSITIONS");\n', '\n', '    _updateTokenBalance(_tokenOwner, _tokenId, _quantity, ObjectLib.Operations.SUB);\n', '    emit Transfer(_tokenOwner, address(0), _tokenId);\n', '    emit TransferWithQuantity(_tokenOwner, address(0), _tokenId, _quantity);\n', '  }\n', '\n', '  function _mint(address _buyer, address _seller, bytes32 _derivativeHash, uint256 _quantity) internal {\n', '    _mintLong(_buyer, _derivativeHash, _quantity);\n', '    _mintShort(_seller, _derivativeHash, _quantity);\n', '  }\n', '  \n', '  function _mintLong(address _buyer, bytes32 _derivativeHash, uint256 _quantity) internal {\n', '    uint256 longTokenId = _derivativeHash.getLongTokenId();\n', '    _mint(longTokenId, _buyer, _quantity);\n', '  }\n', '  \n', '  function _mintShort(address _seller, bytes32 _derivativeHash, uint256 _quantity) internal {\n', '    uint256 shortTokenId = _derivativeHash.getShortTokenId();\n', '    _mint(shortTokenId, _seller, _quantity);\n', '  }\n', '\n', '  function _registerPortfolio(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio) internal {\n', '    if (!exists(_portfolioId)) {\n', '      tokenTypes[_portfolioId] = PORTFOLIO;\n', '      emit Composition(_portfolioId, _tokenIds, _tokenRatio);\n', '    }\n', '  }\n', '}\n', '\n', '// File: erc721o/contracts/ERC721OComposable.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', '\n', '\n', '\n', 'contract ERC721OComposable is ERC721OMintable {\n', '  // Libraries\n', '  using UintArray for uint256[];\n', '  using SafeMath for uint256;\n', '\n', '  function compose(uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {\n', '    require(_tokenIds.length == _tokenRatio.length, "TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH");\n', '    require(_quantity > 0, "TOKEN_MINTER:WRONG_QUANTITY");\n', '    require(_tokenIds.length > 0, "TOKEN_MINTER:WRONG_QUANTITY");\n', '    require(_tokenIds.isUnique(), "TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE");\n', '\n', '    for (uint256 i = 0; i < _tokenIds.length; i++) {\n', '      _burn(msg.sender, _tokenIds[i], _tokenRatio[i].mul(_quantity));\n', '    }\n', '\n', '    uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n', '      _tokenIds,\n', '      _tokenRatio\n', '    )));\n', '\n', '    _registerPortfolio(portfolioId, _tokenIds, _tokenRatio);\n', '    _mint(portfolioId, msg.sender, _quantity);\n', '  }\n', '\n', '  function decompose(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {\n', '    require(_tokenIds.length == _tokenRatio.length, "TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH");\n', '    require(_quantity > 0, "TOKEN_MINTER:WRONG_QUANTITY");\n', '    require(_tokenIds.length > 0, "TOKEN_MINTER:WRONG_QUANTITY");\n', '    require(_tokenIds.isUnique(), "TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE");\n', '\n', '    uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n', '      _tokenIds,\n', '      _tokenRatio\n', '    )));\n', '\n', '    require(portfolioId == _portfolioId, "TOKEN_MINTER:WRONG_PORTFOLIO_ID");\n', '    _burn(msg.sender, _portfolioId, _quantity);\n', '\n', '    for (uint256 i = 0; i < _tokenIds.length; i++) {\n', '      _mint(_tokenIds[i], msg.sender, _tokenRatio[i].mul(_quantity));\n', '    }\n', '  }\n', '\n', '  function recompose(\n', '    uint256 _portfolioId,\n', '    uint256[] memory _initialTokenIds,\n', '    uint256[] memory _initialTokenRatio,\n', '    uint256[] memory _finalTokenIds,\n', '    uint256[] memory _finalTokenRatio,\n', '    uint256 _quantity\n', '  ) public {\n', '    require(_initialTokenIds.length == _initialTokenRatio.length, "TOKEN_MINTER:INITIAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH");\n', '    require(_finalTokenIds.length == _finalTokenRatio.length, "TOKEN_MINTER:FINAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH");\n', '    require(_quantity > 0, "TOKEN_MINTER:WRONG_QUANTITY");\n', '    require(_initialTokenIds.length > 0, "TOKEN_MINTER:WRONG_QUANTITY");\n', '    require(_finalTokenIds.length > 0, "TOKEN_MINTER:WRONG_QUANTITY");\n', '    require(_initialTokenIds.isUnique(), "TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE");\n', '    require(_finalTokenIds.isUnique(), "TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE");\n', '\n', '    uint256 oldPortfolioId = uint256(keccak256(abi.encodePacked(\n', '      _initialTokenIds,\n', '      _initialTokenRatio\n', '    )));\n', '\n', '    require(oldPortfolioId == _portfolioId, "TOKEN_MINTER:WRONG_PORTFOLIO_ID");\n', '    _burn(msg.sender, _portfolioId, _quantity);\n', '    \n', '    _removedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n', '    _addedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n', '    _keptIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n', '\n', '    uint256 newPortfolioId = uint256(keccak256(abi.encodePacked(\n', '      _finalTokenIds,\n', '      _finalTokenRatio\n', '    )));\n', '\n', '    _registerPortfolio(newPortfolioId, _finalTokenIds, _finalTokenRatio);\n', '    _mint(newPortfolioId, msg.sender, _quantity);\n', '  }\n', '\n', '  function _removedIds(\n', '    uint256[] memory _initialTokenIds,\n', '    uint256[] memory _initialTokenRatio,\n', '    uint256[] memory _finalTokenIds,\n', '    uint256[] memory _finalTokenRatio,\n', '    uint256 _quantity\n', '  ) private {\n', '    (uint256[] memory removedIds, uint256[] memory removedIdsIdxs) = _initialTokenIds.difference(_finalTokenIds);\n', '\n', '    for (uint256 i = 0; i < removedIds.length; i++) {\n', '      uint256 index = removedIdsIdxs[i];\n', '      _mint(_initialTokenIds[index], msg.sender, _initialTokenRatio[index].mul(_quantity));\n', '    }\n', '\n', '    _finalTokenRatio;\n', '  }\n', '\n', '  function _addedIds(\n', '      uint256[] memory _initialTokenIds,\n', '      uint256[] memory _initialTokenRatio,\n', '      uint256[] memory _finalTokenIds,\n', '      uint256[] memory _finalTokenRatio,\n', '      uint256 _quantity\n', '  ) private {\n', '    (uint256[] memory addedIds, uint256[] memory addedIdsIdxs) = _finalTokenIds.difference(_initialTokenIds);\n', '\n', '    for (uint256 i = 0; i < addedIds.length; i++) {\n', '      uint256 index = addedIdsIdxs[i];\n', '      _burn(msg.sender, _finalTokenIds[index], _finalTokenRatio[index].mul(_quantity));\n', '    }\n', '\n', '    _initialTokenRatio;\n', '  }\n', '\n', '  function _keptIds(\n', '      uint256[] memory _initialTokenIds,\n', '      uint256[] memory _initialTokenRatio,\n', '      uint256[] memory _finalTokenIds,\n', '      uint256[] memory _finalTokenRatio,\n', '      uint256 _quantity\n', '  ) private {\n', '    (uint256[] memory keptIds, uint256[] memory keptInitialIdxs, uint256[] memory keptFinalIdxs) = _initialTokenIds.intersect(_finalTokenIds);\n', '\n', '    for (uint256 i = 0; i < keptIds.length; i++) {\n', '      uint256 initialIndex = keptInitialIdxs[i];\n', '      uint256 finalIndex = keptFinalIdxs[i];\n', '\n', '      if (_initialTokenRatio[initialIndex] > _finalTokenRatio[finalIndex]) {\n', '        uint256 diff = _initialTokenRatio[initialIndex] - _finalTokenRatio[finalIndex];\n', '        _mint(_initialTokenIds[initialIndex], msg.sender, diff.mul(_quantity));\n', '      } else if (_initialTokenRatio[initialIndex] < _finalTokenRatio[finalIndex]) {\n', '        uint256 diff = _finalTokenRatio[finalIndex] - _initialTokenRatio[initialIndex];\n', '        _burn(msg.sender, _initialTokenIds[initialIndex], diff.mul(_quantity));\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', '// File: erc721o/contracts/Libs/UintsLib.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', 'library UintsLib {\n', '  function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n', '    if (_i == 0) {\n', '      return "0";\n', '    }\n', '\n', '    uint j = _i;\n', '    uint len;\n', '    while (j != 0) {\n', '      len++;\n', '      j /= 10;\n', '    }\n', '\n', '    bytes memory bstr = new bytes(len);\n', '    uint k = len - 1;\n', '    while (_i != 0) {\n', '      bstr[k--] = byte(uint8(48 + _i % 10));\n', '      _i /= 10;\n', '    }\n', '\n', '    return string(bstr);\n', '  }\n', '}\n', '\n', '// File: erc721o/contracts/ERC721OBackwardCompatible.sol\n', '\n', 'pragma solidity ^0.5.4;\n', '\n', '\n', '\n', '\n', 'contract ERC721OBackwardCompatible is ERC721OComposable {\n', '  using UintsLib for uint256;\n', '\n', '  // Interface constants\n', '  bytes4 internal constant INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '  bytes4 internal constant INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '  bytes4 internal constant INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '\n', '  // Reciever constants\n', '  bytes4 internal constant ERC721_RECEIVED = 0x150b7a02;\n', '\n', '  // Metadata URI\n', '  string internal baseTokenURI;\n', '\n', '  constructor(string memory _baseTokenURI) public ERC721OBase() {\n', '    baseTokenURI = _baseTokenURI;\n', '    _registerInterface(INTERFACE_ID_ERC721);\n', '    _registerInterface(INTERFACE_ID_ERC721_ENUMERABLE);\n', '    _registerInterface(INTERFACE_ID_ERC721_METADATA);\n', '  }\n', '\n', '  // ERC721 compatibility\n', '  function implementsERC721() public pure returns (bool) {\n', '    return true;\n', '  }\n', '\n', '  /**\n', '    * @dev Gets the owner of a given NFT\n', '    * @param _tokenId uint256 representing the unique token identifier\n', '    * @return address the owner of the token\n', '    */\n', '  function ownerOf(uint256 _tokenId) public view returns (address) {\n', '    if (exists(_tokenId)) {\n', '      return address(this);\n', '    }\n', '\n', '    return address(0);\n', '  }\n', '\n', '  /**\n', '   *  @dev Gets the number of tokens owned by the address we are checking\n', '   *  @param _owner The adddress we are checking\n', '   *  @return balance The unique amount of tokens owned\n', '   */\n', '  function balanceOf(address _owner) public view returns (uint256 balance) {\n', '    (, uint256[] memory tokens) = tokensOwned(_owner);\n', '    return tokens.length;\n', '  }\n', '\n', '  // ERC721 - Enumerable compatibility\n', '  /**\n', '   * @dev Gets the token ID at a given index of all the tokens in this contract\n', '   * Reverts if the index is greater or equal to the total number of tokens\n', '   * @param _index uint256 representing the index to be accessed of the tokens list\n', '   * @return uint256 token ID at the given index of the tokens list\n', '   */\n', '  function tokenByIndex(uint256 _index) public view returns (uint256) {\n', '    require(_index < totalSupply());\n', '    return allTokens[_index];\n', '  }\n', '\n', '  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId) {\n', '    (, uint256[] memory tokens) = tokensOwned(_owner);\n', '    require(_index < tokens.length);\n', '    return tokens[_index];\n', '  }\n', '\n', '  // ERC721 - Metadata compatibility\n', '  function tokenURI(uint256 _tokenId) public view returns (string memory tokenUri) {\n', '    require(exists(_tokenId), "Token doesn\'t exist");\n', '    return string(abi.encodePacked(\n', '      baseTokenURI, \n', '      _tokenId.uint2str(),\n', '      ".json"\n', '    ));\n', '  }\n', '\n', '  /**\n', '   * @dev Gets the approved address for a token ID, or zero if no address set\n', '   * @param _tokenId uint256 ID of the token to query the approval of\n', '   * @return address currently approved for the given token ID\n', '   */\n', '  function getApproved(uint256 _tokenId) public view returns (address) {\n', '    if (exists(_tokenId)) {\n', '      return address(this);\n', '    }\n', '\n', '    return address(0);\n', '  }\n', '\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public {\n', '    safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public nonReentrant {\n', '    _transferFrom(_from, _to, _tokenId, 1);\n', '    require(\n', '      _checkAndCallSafeTransfer(_from, _to, _tokenId, _data),\n', '      "Sent to a contract which is not an ERC721 receiver"\n', '    );\n', '  }\n', '\n', '  function transferFrom(address _from, address _to, uint256 _tokenId) public {\n', '    _transferFrom(_from, _to, _tokenId, 1);\n', '  }\n', '\n', '  /**\n', '   * @dev Internal function to invoke `onERC721Received` on a target address\n', '   * The call is not executed if the target address is not a contract\n', '   * @param _from address representing the previous owner of the given token ID\n', '   * @param _to target address that will receive the tokens\n', '   * @param _tokenId uint256 ID of the token to be transferred\n', '   * @param _data bytes optional data to send along with the call\n', '   * @return whether the call correctly returned the expected magic value\n', '   */\n', '  function _checkAndCallSafeTransfer(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes memory _data\n', '  ) internal returns (bool) {\n', '    if (!_to.isContract()) {\n', '      return true;\n', '    }\n', '    bytes4 retval = IERC721Receiver(_to).onERC721Received(\n', '        msg.sender, _from, _tokenId, _data\n', '    );\n', '    return (retval == ERC721_RECEIVED);\n', '  }\n', '}\n', '\n', '// File: contracts/TokenMinter.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '/// @title Opium.TokenMinter contract implements ERC721O token standard for minting, burning and transferring position tokens\n', 'contract TokenMinter is ERC721OBackwardCompatible, UsingRegistry {\n', '    /// @notice Calls constructors of super-contracts\n', '    /// @param _baseTokenURI string URI for token explorers\n', '    /// @param _registry address Address of Opium.registry\n', '    constructor(string memory _baseTokenURI, address _registry) public ERC721OBackwardCompatible(_baseTokenURI) UsingRegistry(_registry) {}\n', '\n', '    /// @notice Mints LONG and SHORT position tokens\n', '    /// @param _buyer address Address of LONG position receiver\n', '    /// @param _seller address Address of SHORT position receiver\n', '    /// @param _derivativeHash bytes32 Hash of derivative (ticker) of position\n', '    /// @param _quantity uint256 Quantity of positions to mint\n', '    function mint(address _buyer, address _seller, bytes32 _derivativeHash, uint256 _quantity) external onlyCore {\n', '        _mint(_buyer, _seller, _derivativeHash, _quantity);\n', '    }\n', '\n', '    /// @notice Mints only LONG position tokens for "pooled" derivatives\n', '    /// @param _buyer address Address of LONG position receiver\n', '    /// @param _derivativeHash bytes32 Hash of derivative (ticker) of position\n', '    /// @param _quantity uint256 Quantity of positions to mint\n', '    function mint(address _buyer, bytes32 _derivativeHash, uint256 _quantity) external onlyCore {\n', '        _mintLong(_buyer, _derivativeHash, _quantity);\n', '    }\n', '\n', '    /// @notice Burns position tokens\n', '    /// @param _tokenOwner address Address of tokens owner\n', '    /// @param _tokenId uint256 tokenId of positions to burn\n', '    /// @param _quantity uint256 Quantity of positions to burn\n', '    function burn(address _tokenOwner, uint256 _tokenId, uint256 _quantity) external onlyCore {\n', '        _burn(_tokenOwner, _tokenId, _quantity);\n', '    }\n', '\n', '    /// @notice ERC721 interface compatible function for position token name retrieving\n', '    /// @return Returns name of token\n', '    function name() external view returns (string memory) {\n', '        return "Opium Network Position Token";\n', '    }\n', '\n', '    /// @notice ERC721 interface compatible function for position token symbol retrieving\n', '    /// @return Returns symbol of token\n', '    function symbol() external view returns (string memory) {\n', '        return "ONP";\n', '    }\n', '\n', '    /// VIEW FUNCTIONS\n', '\n', '    /// @notice Checks whether _spender is approved to spend tokens on _owners behalf or owner itself\n', '    /// @param _spender address Address of spender\n', '    /// @param _owner address Address of owner\n', '    /// @param _tokenId address tokenId of interest\n', '    /// @return Returns whether _spender is approved to spend tokens\n', '    function isApprovedOrOwner(\n', '        address _spender,\n', '        address _owner,\n', '        uint256 _tokenId\n', '    ) public view returns (bool) {\n', '        return (\n', '        _spender == _owner ||\n', '        getApproved(_tokenId, _owner) == _spender ||\n', '        isApprovedForAll(_owner, _spender) ||\n', '        isOpiumSpender(_spender)\n', '        );\n', '    }\n', '\n', '    /// @notice Checks whether _spender is Opium.TokenSpender\n', '    /// @return Returns whether _spender is Opium.TokenSpender\n', '    function isOpiumSpender(address _spender) public view returns (bool) {\n', '        return _spender == registry.getTokenSpender();\n', '    }\n', '}\n', '\n', '// File: contracts/Errors/OracleAggregatorErrors.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract OracleAggregatorErrors {\n', '    string constant internal ERROR_ORACLE_AGGREGATOR_NOT_ENOUGH_ETHER = "ORACLE_AGGREGATOR:NOT_ENOUGH_ETHER";\n', '\n', '    string constant internal ERROR_ORACLE_AGGREGATOR_QUERY_WAS_ALREADY_MADE = "ORACLE_AGGREGATOR:QUERY_WAS_ALREADY_MADE";\n', '\n', '    string constant internal ERROR_ORACLE_AGGREGATOR_DATA_DOESNT_EXIST = "ORACLE_AGGREGATOR:DATA_DOESNT_EXIST";\n', '\n', '    string constant internal ERROR_ORACLE_AGGREGATOR_DATA_ALREADY_EXIST = "ORACLE_AGGREGATOR:DATA_ALREADY_EXIST";\n', '}\n', '\n', '// File: contracts/Interface/IOracleId.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '/// @title Opium.Interface.IOracleId contract is an interface that every oracleId should implement\n', 'interface IOracleId {\n', '    /// @notice Requests data from `oracleId` one time\n', '    /// @param timestamp uint256 Timestamp at which data are needed\n', '    function fetchData(uint256 timestamp) external payable;\n', '\n', '    /// @notice Requests data from `oracleId` multiple times\n', '    /// @param timestamp uint256 Timestamp at which data are needed for the first time\n', '    /// @param period uint256 Period in seconds between multiple timestamps\n', '    /// @param times uint256 How many timestamps are requested\n', '    function recursivelyFetchData(uint256 timestamp, uint256 period, uint256 times) external payable;\n', '\n', '    /// @notice Requests and returns price in ETH for one request. This function could be called as `view` function. Oraclize API for price calculations restricts making this function as view.\n', '    /// @return fetchPrice uint256 Price of one data request in ETH\n', '    function calculateFetchPrice() external returns (uint256 fetchPrice);\n', '\n', '    // Event with oracleId metadata JSON string (for DIB.ONE derivative explorer)\n', '    event MetadataSet(string metadata);\n', '}\n', '\n', '// File: contracts/OracleAggregator.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '/// @title Opium.OracleAggregator contract requests and caches the data from `oracleId`s and provides them to the Core for positions execution\n', 'contract OracleAggregator is OracleAggregatorErrors, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    // Storage for the `oracleId` results\n', '    // dataCache[oracleId][timestamp] => data\n', '    mapping (address => mapping(uint256 => uint256)) public dataCache;\n', '\n', '    // Flags whether data were provided\n', '    // dataExist[oracleId][timestamp] => bool\n', '    mapping (address => mapping(uint256 => bool)) public dataExist;\n', '\n', '    // Flags whether data were requested\n', '    // dataRequested[oracleId][timestamp] => bool\n', '    mapping (address => mapping(uint256 => bool)) public dataRequested;\n', '\n', '    // MODIFIERS\n', '\n', '    /// @notice Checks whether enough ETH were provided withing data request to proceed\n', '    /// @param oracleId address Address of the `oracleId` smart contract\n', '    /// @param times uint256 How many times the `oracleId` is being requested\n', '    modifier enoughEtherProvided(address oracleId, uint256 times) {\n', '        // Calling Opium.IOracleId function to get the data fetch price per one request\n', '        uint256 oneTimePrice = calculateFetchPrice(oracleId);\n', '\n', '        // Checking if enough ether was provided for `times` amount of requests\n', '        require(msg.value >= oneTimePrice.mul(times), ERROR_ORACLE_AGGREGATOR_NOT_ENOUGH_ETHER);\n', '        _;\n', '    }\n', '\n', '    // PUBLIC FUNCTIONS\n', '\n', '    /// @notice Requests data from `oracleId` one time\n', '    /// @param oracleId address Address of the `oracleId` smart contract\n', '    /// @param timestamp uint256 Timestamp at which data are needed\n', '    function fetchData(address oracleId, uint256 timestamp) public payable nonReentrant enoughEtherProvided(oracleId, 1) {\n', '        // Check if was not requested before and mark as requested\n', '        _registerQuery(oracleId, timestamp);\n', '\n', '        // Call the `oracleId` contract and transfer ETH\n', '        IOracleId(oracleId).fetchData.value(msg.value)(timestamp);\n', '    }\n', '\n', '    /// @notice Requests data from `oracleId` multiple times\n', '    /// @param oracleId address Address of the `oracleId` smart contract\n', '    /// @param timestamp uint256 Timestamp at which data are needed for the first time\n', '    /// @param period uint256 Period in seconds between multiple timestamps\n', '    /// @param times uint256 How many timestamps are requested\n', '    function recursivelyFetchData(address oracleId, uint256 timestamp, uint256 period, uint256 times) public payable nonReentrant enoughEtherProvided(oracleId, times) {\n', '        // Check if was not requested before and mark as requested in loop for each timestamp\n', '        for (uint256 i = 0; i < times; i++) {\t\n', '            _registerQuery(oracleId, timestamp + period * i);\n', '        }\n', '\n', '        // Call the `oracleId` contract and transfer ETH\n', '        IOracleId(oracleId).recursivelyFetchData.value(msg.value)(timestamp, period, times);\n', '    }\n', '\n', '    /// @notice Receives and caches data from `msg.sender`\n', '    /// @param timestamp uint256 Timestamp of data\n', '    /// @param data uint256 Data itself\n', '    function __callback(uint256 timestamp, uint256 data) public {\n', "        // Don't allow to push data twice\n", '        require(!dataExist[msg.sender][timestamp], ERROR_ORACLE_AGGREGATOR_DATA_ALREADY_EXIST);\n', '\n', '        // Saving data\n', '        dataCache[msg.sender][timestamp] = data;\n', '\n', '        // Flagging that data were received\n', '        dataExist[msg.sender][timestamp] = true;\n', '    }\n', '\n', '    /// @notice Requests and returns price in ETH for one request. This function could be called as `view` function. Oraclize API for price calculations restricts making this function as view.\n', '    /// @param oracleId address Address of the `oracleId` smart contract\n', '    /// @return fetchPrice uint256 Price of one data request in ETH\n', '    function calculateFetchPrice(address oracleId) public returns(uint256 fetchPrice) {\n', '        fetchPrice = IOracleId(oracleId).calculateFetchPrice();\n', '    }\n', '\n', '    // PRIVATE FUNCTIONS\n', '\n', '    /// @notice Checks if data was not requested and provided before and marks as requested\n', '    /// @param oracleId address Address of the `oracleId` smart contract\n', '    /// @param timestamp uint256 Timestamp at which data are requested\n', '    function _registerQuery(address oracleId, uint256 timestamp) private {\n', '        // Check if data was not requested and provided yet\n', '        require(!dataRequested[oracleId][timestamp] && !dataExist[oracleId][timestamp], ERROR_ORACLE_AGGREGATOR_QUERY_WAS_ALREADY_MADE);\n', '\n', '        // Mark as requested\n', '        dataRequested[oracleId][timestamp] = true;\t\n', '    }\n', '\n', '    // VIEW FUNCTIONS\n', '\n', '    /// @notice Returns cached data if they exist, or reverts with an error\n', '    /// @param oracleId address Address of the `oracleId` smart contract\n', '    /// @param timestamp uint256 Timestamp at which data were requested\n', '    /// @return dataResult uint256 Cached data provided by `oracleId`\n', '    function getData(address oracleId, uint256 timestamp) public view returns(uint256 dataResult) {\n', '        // Check if Opium.OracleAggregator has data\n', '        require(hasData(oracleId, timestamp), ERROR_ORACLE_AGGREGATOR_DATA_DOESNT_EXIST);\n', '\n', '        // Return cached data\n', '        dataResult = dataCache[oracleId][timestamp];\n', '    }\n', '\n', '    /// @notice Getter for dataExist mapping\n', '    /// @param oracleId address Address of the `oracleId` smart contract\n', '    /// @param timestamp uint256 Timestamp at which data were requested\n', '    /// @param result bool Returns whether data were provided already\n', '    function hasData(address oracleId, uint256 timestamp) public view returns(bool result) {\n', '        return dataExist[oracleId][timestamp];\n', '    }\n', '}\n', '\n', '// File: contracts/Errors/SyntheticAggregatorErrors.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract SyntheticAggregatorErrors {\n', '    string constant internal ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH = "SYNTHETIC_AGGREGATOR:DERIVATIVE_HASH_NOT_MATCH";\n', '    string constant internal ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN = "SYNTHETIC_AGGREGATOR:WRONG_MARGIN";\n', '    string constant internal ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG = "SYNTHETIC_AGGREGATOR:COMMISSION_TOO_BIG";\n', '}\n', '\n', '// File: contracts/SyntheticAggregator.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @notice Opium.SyntheticAggregator contract initialized, identifies and caches syntheticId sensitive data\n', 'contract SyntheticAggregator is SyntheticAggregatorErrors, LibDerivative, LibCommission, ReentrancyGuard {\n', '    // Emitted when new ticker is initialized\n', '    event Create(Derivative derivative, bytes32 derivativeHash);\n', '\n', '    // Enum for types of syntheticId\n', '    // Invalid - syntheticId is not initialized yet\n', '    // NotPool - syntheticId with p2p logic\n', '    // Pool - syntheticId with pooled logic\n', '    enum SyntheticTypes { Invalid, NotPool, Pool }\n', '\n', '    // Cache of buyer margin by ticker\n', '    // buyerMarginByHash[derivativeHash] = buyerMargin\n', '    mapping (bytes32 => uint256) public buyerMarginByHash;\n', '\n', '    // Cache of seller margin by ticker\n', '    // sellerMarginByHash[derivativeHash] = sellerMargin\n', '    mapping (bytes32 => uint256) public sellerMarginByHash;\n', '\n', '    // Cache of type by ticker\n', '    // typeByHash[derivativeHash] = type\n', '    mapping (bytes32 => SyntheticTypes) public typeByHash;\n', '\n', '    // Cache of commission by ticker\n', '    // commissionByHash[derivativeHash] = commission\n', '    mapping (bytes32 => uint256) public commissionByHash;\n', '\n', '    // Cache of author addresses by ticker\n', '    // authorAddressByHash[derivativeHash] = authorAddress\n', '    mapping (bytes32 => address) public authorAddressByHash;\n', '\n', '    // PUBLIC FUNCTIONS\n', '\n', '    /// @notice Initializes ticker, if was not initialized and returns `syntheticId` author commission from cache\n', '    /// @param _derivativeHash bytes32 Hash of derivative\n', '    /// @param _derivative Derivative Derivative itself\n', '    /// @return commission uint256 Synthetic author commission\n', '    function getAuthorCommission(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 commission) {\n', "        // Initialize derivative if wasn't initialized before\n", '        _initDerivative(_derivativeHash, _derivative);\n', '        commission = commissionByHash[_derivativeHash];\n', '    }\n', '\n', '    /// @notice Initializes ticker, if was not initialized and returns `syntheticId` author address from cache\n', '    /// @param _derivativeHash bytes32 Hash of derivative\n', '    /// @param _derivative Derivative Derivative itself\n', '    /// @return authorAddress address Synthetic author address\n', '    function getAuthorAddress(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (address authorAddress) {\n', "        // Initialize derivative if wasn't initialized before\n", '        _initDerivative(_derivativeHash, _derivative);\n', '        authorAddress = authorAddressByHash[_derivativeHash];\n', '    }\n', '\n', '    /// @notice Initializes ticker, if was not initialized and returns buyer and seller margin from cache\n', '    /// @param _derivativeHash bytes32 Hash of derivative\n', '    /// @param _derivative Derivative Derivative itself\n', '    /// @return buyerMargin uint256 Margin of buyer\n', '    /// @return sellerMargin uint256 Margin of seller\n', '    function getMargin(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 buyerMargin, uint256 sellerMargin) {\n', "        // If it's a pool, just return margin from syntheticId contract\n", '        if (_isPool(_derivativeHash, _derivative)) {\n', '            return IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative); \n', '        }\n', '\n', "        // Initialize derivative if wasn't initialized before\n", '        _initDerivative(_derivativeHash, _derivative);\n', '\n', '        // Check if margins for _derivativeHash were already cached\n', '        buyerMargin = buyerMarginByHash[_derivativeHash];\n', '        sellerMargin = sellerMarginByHash[_derivativeHash];\n', '    }\n', '\n', '    /// @notice Checks whether `syntheticId` implements pooled logic\n', '    /// @param _derivativeHash bytes32 Hash of derivative\n', '    /// @param _derivative Derivative Derivative itself\n', '    /// @return result bool Returns whether synthetic implements pooled logic\n', '    function isPool(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (bool result) {\n', '        result = _isPool(_derivativeHash, _derivative);\n', '    }\n', '\n', '    // PRIVATE FUNCTIONS\n', '\n', '    /// @notice Initializes ticker, if was not initialized and returns whether `syntheticId` implements pooled logic\n', '    /// @param _derivativeHash bytes32 Hash of derivative\n', '    /// @param _derivative Derivative Derivative itself\n', '    /// @return result bool Returns whether synthetic implements pooled logic\n', '    function _isPool(bytes32 _derivativeHash, Derivative memory _derivative) private returns (bool result) {\n', "        // Initialize derivative if wasn't initialized before\n", '        _initDerivative(_derivativeHash, _derivative);\n', '        result = typeByHash[_derivativeHash] == SyntheticTypes.Pool;\n', '    }\n', '\n', '    /// @notice Initializes ticker: caches syntheticId type, margin, author address and commission\n', '    /// @param _derivativeHash bytes32 Hash of derivative\n', '    /// @param _derivative Derivative Derivative itself\n', '    function _initDerivative(bytes32 _derivativeHash, Derivative memory _derivative) private {\n', '        // Check if type for _derivativeHash was already cached\n', '        SyntheticTypes syntheticType = typeByHash[_derivativeHash];\n', '\n', '        // Type could not be Invalid, thus this condition says us that type was not cached before\n', '        if (syntheticType != SyntheticTypes.Invalid) {\n', '            return;\n', '        }\n', '\n', '        // For security reasons we calculate hash of provided _derivative\n', '        bytes32 derivativeHash = getDerivativeHash(_derivative);\n', '        require(derivativeHash == _derivativeHash, ERROR_SYNTHETIC_AGGREGATOR_DERIVATIVE_HASH_NOT_MATCH);\n', '\n', '        // POOL\n', '        // Get isPool from SyntheticId\n', '        bool result = IDerivativeLogic(_derivative.syntheticId).isPool();\n', '        // Cache type returned from synthetic\n', '        typeByHash[derivativeHash] = result ? SyntheticTypes.Pool : SyntheticTypes.NotPool;\n', '\n', '        // MARGIN\n', '        // Get margin from SyntheticId\n', '        (uint256 buyerMargin, uint256 sellerMargin) = IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);\n', '        // We are not allowing both margins to be equal to 0\n', '        require(buyerMargin != 0 || sellerMargin != 0, ERROR_SYNTHETIC_AGGREGATOR_WRONG_MARGIN);\n', '        // Cache margins returned from synthetic\n', '        buyerMarginByHash[derivativeHash] = buyerMargin;\n', '        sellerMarginByHash[derivativeHash] = sellerMargin;\n', '\n', '        // AUTHOR ADDRESS\n', '        // Cache author address returned from synthetic\n', '        authorAddressByHash[derivativeHash] = IDerivativeLogic(_derivative.syntheticId).getAuthorAddress();\n', '\n', '        // AUTHOR COMMISSION\n', '        // Get commission from syntheticId\n', '        uint256 commission = IDerivativeLogic(_derivative.syntheticId).getAuthorCommission();\n', '        // Check if commission is not set > 100%\n', '        require(commission <= COMMISSION_BASE, ERROR_SYNTHETIC_AGGREGATOR_COMMISSION_TOO_BIG);\n', '        // Cache commission\n', '        commissionByHash[derivativeHash] = commission;\n', '\n', "        // If we are here, this basically means this ticker was not used before, so we emit an event for Dapps developers about new ticker (derivative) and it's hash\n", '        emit Create(_derivative, derivativeHash);\n', '    }\n', '}\n', '\n', '// File: contracts/Lib/Whitelisted.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '/// @title Opium.Lib.Whitelisted contract implements whitelist with modifier to restrict access to only whitelisted addresses\n', 'contract Whitelisted {\n', '    // Whitelist array\n', '    address[] internal whitelist;\n', '\n', '    /// @notice This modifier restricts access to functions, which could be called only by whitelisted addresses\n', '    modifier onlyWhitelisted() {\n', '        // Allowance flag\n', '        bool allowed = false;\n', '\n', '        // Going through whitelisted addresses array\n', '        uint256 whitelistLength = whitelist.length;\n', '        for (uint256 i = 0; i < whitelistLength; i++) {\n', '            // If `msg.sender` is met within whitelisted addresses, raise the flag and exit the loop\n', '            if (whitelist[i] == msg.sender) {\n', '                allowed = true;\n', '                break;\n', '            }\n', '        }\n', '\n', '        // Check if flag was raised\n', '        require(allowed, "Only whitelisted allowed");\n', '        _;\n', '    }\n', '\n', '    /// @notice Getter for whitelisted addresses array\n', '    /// @return Array of whitelisted addresses\n', '    function getWhitelist() public view returns (address[] memory) {\n', '        return whitelist;\n', '    }\n', '}\n', '\n', '// File: contracts/Lib/WhitelistedWithGovernance.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '/// @title Opium.Lib.WhitelistedWithGovernance contract implements Opium.Lib.Whitelisted and adds governance for whitelist controlling\n', 'contract WhitelistedWithGovernance is Whitelisted {\n', '    // Emitted when new governor is set\n', '    event GovernorSet(address governor);\n', '\n', '    // Emitted when new whitelist is proposed\n', '    event Proposed(address[] whitelist);\n', '    // Emitted when proposed whitelist is committed (set)\n', '    event Committed(address[] whitelist);\n', '\n', '    // Proposal life timelock interval\n', '    uint256 public timeLockInterval;\n', '\n', '    // Governor address\n', '    address public governor;\n', '\n', '    // Timestamp of last proposal\n', '    uint256 public proposalTime;\n', '\n', '    // Proposed whitelist\n', '    address[] public proposedWhitelist;\n', '\n', '    /// @notice This modifier restricts access to functions, which could be called only by governor\n', '    modifier onlyGovernor() {\n', '        require(msg.sender == governor, "Only governor allowed");\n', '        _;\n', '    }\n', '\n', '    /// @notice Contract constructor\n', '    /// @param _timeLockInterval uint256 Initial value for timelock interval\n', '    /// @param _governor address Initial value for governor\n', '    constructor(uint256 _timeLockInterval, address _governor) public {\n', '        timeLockInterval = _timeLockInterval;\n', '        governor = _governor;\n', '        emit GovernorSet(governor);\n', '    }\n', '\n', '    /// @notice Calling this function governor could propose new whitelist addresses array. Also it allows to initialize first whitelist if it was not initialized yet.\n', '    function proposeWhitelist(address[] memory _whitelist) public onlyGovernor {\n', '        // Restrict empty proposals\n', '        require(_whitelist.length != 0, "Can\'t be empty");\n', '\n', '        // Consider empty whitelist as not initialized, as proposing of empty whitelists is not allowed\n', '        // If whitelist has never been initialized, we set whitelist right away without proposal\n', '        if (whitelist.length == 0) {\n', '            whitelist = _whitelist;\n', '            emit Committed(_whitelist);\n', '\n', '        // Otherwise save current time as timestamp of proposal, save proposed whitelist and emit event\n', '        } else {\n', '            proposalTime = now;\n', '            proposedWhitelist = _whitelist;\n', '            emit Proposed(_whitelist);\n', '        }\n', '    }\n', '\n', '    /// @notice Calling this function governor commits proposed whitelist if timelock interval of proposal was passed\n', '    function commitWhitelist() public onlyGovernor {\n', '        // Check if proposal was made\n', '        require(proposalTime != 0, "Didn\'t proposed yet");\n', '\n', '        // Check if timelock interval was passed\n', '        require((proposalTime + timeLockInterval) < now, "Can\'t commit yet");\n', '        \n', '        // Set new whitelist and emit event\n', '        whitelist = proposedWhitelist;\n', '        emit Committed(whitelist);\n', '\n', '        // Reset proposal time lock\n', '        proposalTime = 0;\n', '    }\n', '\n', '    /// @notice This function allows governor to transfer governance to a new governor and emits event\n', '    /// @param _governor address Address of new governor\n', '    function setGovernor(address _governor) public onlyGovernor {\n', '        require(_governor != address(0), "Can\'t set zero address");\n', '        governor = _governor;\n', '        emit GovernorSet(governor);\n', '    }\n', '}\n', '\n', '// File: contracts/Lib/WhitelistedWithGovernanceAndChangableTimelock.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '/// @notice Opium.Lib.WhitelistedWithGovernanceAndChangableTimelock contract implements Opium.Lib.WhitelistedWithGovernance and adds possibility for governor to change timelock interval within timelock interval\n', 'contract WhitelistedWithGovernanceAndChangableTimelock is WhitelistedWithGovernance {\n', '    // Emitted when new timelock is proposed\n', '    event Proposed(uint256 timelock);\n', '    // Emitted when new timelock is committed (set)\n', '    event Committed(uint256 timelock);\n', '\n', '    // Timestamp of last timelock proposal\n', '    uint256 public timeLockProposalTime;\n', '    // Proposed timelock\n', '    uint256 public proposedTimeLock;\n', '\n', '    /// @notice Calling this function governor could propose new timelock\n', '    /// @param _timelock uint256 New timelock value\n', '    function proposeTimelock(uint256 _timelock) public onlyGovernor {\n', '        timeLockProposalTime = now;\n', '        proposedTimeLock = _timelock;\n', '        emit Proposed(_timelock);\n', '    }\n', '\n', '    /// @notice Calling this function governor could commit previously proposed new timelock if timelock interval of proposal was passed\n', '    function commitTimelock() public onlyGovernor {\n', '        // Check if proposal was made\n', '        require(timeLockProposalTime != 0, "Didn\'t proposed yet");\n', '        // Check if timelock interval was passed\n', '        require((timeLockProposalTime + timeLockInterval) < now, "Can\'t commit yet");\n', '        \n', '        // Set new timelock and emit event\n', '        timeLockInterval = proposedTimeLock;\n', '        emit Committed(proposedTimeLock);\n', '\n', '        // Reset timelock time lock\n', '        timeLockProposalTime = 0;\n', '    }\n', '}\n', '\n', '// File: contracts/TokenSpender.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '/// @title Opium.TokenSpender contract holds users ERC20 approvals and allows whitelisted contracts to use tokens\n', 'contract TokenSpender is WhitelistedWithGovernanceAndChangableTimelock {\n', '    using SafeERC20 for IERC20;\n', '\n', '    // Initial timelock period\n', '    uint256 public constant WHITELIST_TIMELOCK = 1 hours;\n', '\n', '    /// @notice Calls constructors of super-contracts\n', '    /// @param _governor address Address of governor, who is allowed to adjust whitelist\n', '    constructor(address _governor) public WhitelistedWithGovernance(WHITELIST_TIMELOCK, _governor) {}\n', '\n', '    /// @notice Using this function whitelisted contracts could call ERC20 transfers\n', '    /// @param token IERC20 Instance of token\n', '    /// @param from address Address from which tokens are transferred\n', '    /// @param to address Address of tokens receiver\n', '    /// @param amount uint256 Amount of tokens to be transferred\n', '    function claimTokens(IERC20 token, address from, address to, uint256 amount) external onlyWhitelisted {\n', '        token.safeTransferFrom(from, to, amount);\n', '    }\n', '\n', '    /// @notice Using this function whitelisted contracts could call ERC721O transfers\n', '    /// @param token IERC721O Instance of token\n', '    /// @param from address Address from which tokens are transferred\n', '    /// @param to address Address of tokens receiver\n', '    /// @param tokenId uint256 Token ID to be transferred\n', '    /// @param amount uint256 Amount of tokens to be transferred\n', '    function claimPositions(IERC721O token, address from, address to, uint256 tokenId, uint256 amount) external onlyWhitelisted {\n', '        token.safeTransferFrom(from, to, tokenId, amount);\n', '    }\n', '}\n', '\n', '// File: contracts/Core.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Opium.Core contract creates positions, holds and distributes margin at the maturity\n', 'contract Core is LibDerivative, LibCommission, UsingRegistry, CoreErrors, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '    using LibPosition for bytes32;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // Emitted when Core creates new position\n', '    event Created(address buyer, address seller, bytes32 derivativeHash, uint256 quantity);\n', '    // Emitted when Core executes positions\n', '    event Executed(address tokenOwner, uint256 tokenId, uint256 quantity);\n', '    // Emitted when Core cancels ticker for the first time\n', '    event Canceled(bytes32 derivativeHash);\n', '\n', '    // Period of time after which ticker could be canceled if no data was provided to the `oracleId`\n', '    uint256 public constant NO_DATA_CANCELLATION_PERIOD = 2 weeks;\n', '\n', '    // Vaults for pools\n', '    // This mapping holds balances of pooled positions\n', '    // poolVaults[syntheticAddress][tokenAddress] => availableBalance\n', '    mapping (address => mapping(address => uint256)) public poolVaults;\n', '\n', '    // Vaults for fees\n', '    // This mapping holds balances of fee recipients\n', '    // feesVaults[feeRecipientAddress][tokenAddress] => availableBalance\n', '    mapping (address => mapping(address => uint256)) public feesVaults;\n', '\n', '    // Hashes of cancelled tickers\n', '    mapping (bytes32 => bool) public cancelled;\n', '\n', '    /// @notice Calls Core.Lib.UsingRegistry constructor\n', '    constructor(address _registry) public UsingRegistry(_registry) {}\n', '\n', '    // PUBLIC FUNCTIONS\n', '\n', '    /// @notice This function allows fee recipients to withdraw their fees\n', '    /// @param _tokenAddress address Address of an ERC20 token to withdraw\n', '    function withdrawFee(address _tokenAddress) public nonReentrant {\n', '        uint256 balance = feesVaults[msg.sender][_tokenAddress];\n', '        feesVaults[msg.sender][_tokenAddress] = 0;\n', '        IERC20(_tokenAddress).safeTransfer(msg.sender, balance);\n', '    }\n', '\n', '    /// @notice Creates derivative contracts (positions)\n', '    /// @param _derivative Derivative Derivative definition\n', '    /// @param _quantity uint256 Quantity of derivatives to be created\n', '    /// @param _addresses address[2] Addresses of buyer and seller\n', '    /// [0] - buyer address\n', '    /// [1] - seller address - if seller is set to `address(0)`, consider as pooled position\n', '    function create(Derivative memory _derivative, uint256 _quantity, address[2] memory _addresses) public nonReentrant {\n', '        if (_addresses[1] == address(0)) {\n', '            _createPooled(_derivative, _quantity, _addresses[0]);\n', '        } else {\n', '            _create(_derivative, _quantity, _addresses);\n', '        }\n', '    }\n', '\n', '    /// @notice Executes several positions of `msg.sender` with same `tokenId`\n', '    /// @param _tokenId uint256 `tokenId` of positions that needs to be executed\n', '    /// @param _quantity uint256 Quantity of positions to execute\n', '    /// @param _derivative Derivative Derivative definition\n', '    function execute(uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\n', '        uint256[] memory tokenIds = new uint256[](1);\n', '        uint256[] memory quantities = new uint256[](1);\n', '        Derivative[] memory derivatives = new Derivative[](1);\n', '\n', '        tokenIds[0] = _tokenId;\n', '        quantities[0] = _quantity;\n', '        derivatives[0] = _derivative;\n', '\n', '        _execute(msg.sender, tokenIds, quantities, derivatives);\n', '    }\n', '\n', '    /// @notice Executes several positions of `_tokenOwner` with same `tokenId`\n', '    /// @param _tokenOwner address Address of the owner of positions\n', '    /// @param _tokenId uint256 `tokenId` of positions that needs to be executed\n', '    /// @param _quantity uint256 Quantity of positions to execute\n', '    /// @param _derivative Derivative Derivative definition\n', '    function execute(address _tokenOwner, uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\n', '        uint256[] memory tokenIds = new uint256[](1);\n', '        uint256[] memory quantities = new uint256[](1);\n', '        Derivative[] memory derivatives = new Derivative[](1);\n', '\n', '        tokenIds[0] = _tokenId;\n', '        quantities[0] = _quantity;\n', '        derivatives[0] = _derivative;\n', '\n', '        _execute(_tokenOwner, tokenIds, quantities, derivatives);\n', '    }\n', '\n', '    /// @notice Executes several positions of `msg.sender` with different `tokenId`s\n', '    /// @param _tokenIds uint256[] `tokenId`s of positions that needs to be executed\n', '    /// @param _quantities uint256[] Quantity of positions to execute for each `tokenId`\n', '    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\n', '    function execute(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\n', '        _execute(msg.sender, _tokenIds, _quantities, _derivatives);\n', '    }\n', '\n', '    /// @notice Executes several positions of `_tokenOwner` with different `tokenId`s\n', '    /// @param _tokenOwner address Address of the owner of positions\n', '    /// @param _tokenIds uint256[] `tokenId`s of positions that needs to be executed\n', '    /// @param _quantities uint256[] Quantity of positions to execute for each `tokenId`\n', '    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\n', '    function execute(address _tokenOwner, uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\n', '        _execute(_tokenOwner, _tokenIds, _quantities, _derivatives);\n', '    }\n', '\n', '    /// @notice Cancels tickers, burns positions and returns margins to positions owners in case no data were provided within `NO_DATA_CANCELLATION_PERIOD`\n', '    /// @param _tokenId uint256 `tokenId` of positions that needs to be canceled\n', '    /// @param _quantity uint256 Quantity of positions to cancel\n', '    /// @param _derivative Derivative Derivative definition\n', '    function cancel(uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\n', '        uint256[] memory tokenIds = new uint256[](1);\n', '        uint256[] memory quantities = new uint256[](1);\n', '        Derivative[] memory derivatives = new Derivative[](1);\n', '\n', '        tokenIds[0] = _tokenId;\n', '        quantities[0] = _quantity;\n', '        derivatives[0] = _derivative;\n', '\n', '        _cancel(tokenIds, quantities, derivatives);\n', '    }\n', '\n', '    /// @notice Cancels tickers, burns positions and returns margins to positions owners in case no data were provided within `NO_DATA_CANCELLATION_PERIOD`\n', '    /// @param _tokenIds uint256[] `tokenId` of positions that needs to be canceled\n', '    /// @param _quantities uint256[] Quantity of positions to cancel for each `tokenId`\n', '    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\n', '    function cancel(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\n', '        _cancel(_tokenIds, _quantities, _derivatives);\n', '    }\n', '\n', '    // PRIVATE FUNCTIONS\n', '\n', '    struct CreatePooledLocalVars {\n', '        SyntheticAggregator syntheticAggregator;\n', '        IDerivativeLogic derivativeLogic;\n', '        IERC20 marginToken;\n', '        TokenSpender tokenSpender;\n', '        TokenMinter tokenMinter;\n', '    }\n', '\n', '    /// @notice This function creates pooled positions\n', '    /// @param _derivative Derivative Derivative definition\n', '    /// @param _quantity uint256 Quantity of positions to create\n', '    /// @param _address address Address of position receiver\n', '    function _createPooled(Derivative memory _derivative, uint256 _quantity, address _address) private {\n', '        // Local variables\n', '        CreatePooledLocalVars memory vars;\n', '\n', '        // Create instance of Opium.SyntheticAggregator\n', '        // Create instance of Opium.IDerivativeLogic\n', '        // Create instance of margin token\n', '        // Create instance of Opium.TokenSpender\n', '        // Create instance of Opium.TokenMinter\n', '        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());\n', '        vars.derivativeLogic = IDerivativeLogic(_derivative.syntheticId);\n', '        vars.marginToken = IERC20(_derivative.token);\n', '        vars.tokenSpender = TokenSpender(registry.getTokenSpender());\n', '        vars.tokenMinter = TokenMinter(registry.getMinter());\n', '\n', '        // Generate hash for derivative\n', '        bytes32 derivativeHash = getDerivativeHash(_derivative);\n', '\n', '        // Check with Opium.SyntheticAggregator if syntheticId is a pool\n', '        require(vars.syntheticAggregator.isPool(derivativeHash, _derivative), ERROR_CORE_NOT_POOL);\n', '\n', '        // Check if ticker was canceled\n', '        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);\n', '\n', '        // Validate input data against Derivative logic (`syntheticId`)\n', '        require(vars.derivativeLogic.validateInput(_derivative), ERROR_CORE_SYNTHETIC_VALIDATION_ERROR);\n', '\n', '        // Get cached margin required according to logic from Opium.SyntheticAggregator\n', '        (uint256 margin, ) = vars.syntheticAggregator.getMargin(derivativeHash, _derivative);\n', '\n', '        // Check ERC20 tokens allowance: margin * quantity\n', '        // `msg.sender` must provide margin for position creation\n', '        require(vars.marginToken.allowance(msg.sender, address(vars.tokenSpender)) >= margin.mul(_quantity), ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE);\n', '\n', '    \t// Take ERC20 tokens from msg.sender, should never revert in correct ERC20 implementation\n', '        vars.tokenSpender.claimTokens(vars.marginToken, msg.sender, address(this), margin.mul(_quantity));\n', '\n', "        // Since it's a pooled position, we add transferred margin to pool balance\n", '        poolVaults[_derivative.syntheticId][_derivative.token] = poolVaults[_derivative.syntheticId][_derivative.token].add(margin.mul(_quantity));\n', '\n', '        // Mint LONG position tokens\n', '        vars.tokenMinter.mint(_address, derivativeHash, _quantity);\n', '\n', '        emit Created(_address, address(0), derivativeHash, _quantity);\n', '    }\n', '\n', '    struct CreateLocalVars {\n', '        SyntheticAggregator syntheticAggregator;\n', '        IDerivativeLogic derivativeLogic;\n', '        IERC20 marginToken;\n', '        TokenSpender tokenSpender;\n', '        TokenMinter tokenMinter;\n', '    }\n', '\n', '    /// @notice This function creates p2p positions\n', '    /// @param _derivative Derivative Derivative definition\n', '    /// @param _quantity uint256 Quantity of positions to create\n', '    /// @param _addresses address[2] Addresses of buyer and seller\n', '    /// [0] - buyer address\n', '    /// [1] - seller address\n', '    function _create(Derivative memory _derivative, uint256 _quantity, address[2] memory _addresses) private {\n', '        // Local variables\n', '        CreateLocalVars memory vars;\n', '\n', '        // Create instance of Opium.SyntheticAggregator\n', '        // Create instance of Opium.IDerivativeLogic\n', '        // Create instance of margin token\n', '        // Create instance of Opium.TokenSpender\n', '        // Create instance of Opium.TokenMinter\n', '        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());\n', '        vars.derivativeLogic = IDerivativeLogic(_derivative.syntheticId);\n', '        vars.marginToken = IERC20(_derivative.token);\n', '        vars.tokenSpender = TokenSpender(registry.getTokenSpender());\n', '        vars.tokenMinter = TokenMinter(registry.getMinter());\n', '\n', '        // Generate hash for derivative\n', '        bytes32 derivativeHash = getDerivativeHash(_derivative);\n', '\n', '        // Check with Opium.SyntheticAggregator if syntheticId is not a pool\n', '        require(!vars.syntheticAggregator.isPool(derivativeHash, _derivative), ERROR_CORE_CANT_BE_POOL);\n', '\n', '        // Check if ticker was canceled\n', '        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);\n', '\n', '        // Validate input data against Derivative logic (`syntheticId`)\n', '        require(vars.derivativeLogic.validateInput(_derivative), ERROR_CORE_SYNTHETIC_VALIDATION_ERROR);\n', '\n', '        uint256[2] memory margins;\n', '        // Get cached margin required according to logic from Opium.SyntheticAggregator\n', '        // margins[0] - buyerMargin\n', '        // margins[1] - sellerMargin\n', '        (margins[0], margins[1]) = vars.syntheticAggregator.getMargin(derivativeHash, _derivative);\n', '\n', '        // Check ERC20 tokens allowance: (margins[0] + margins[1]) * quantity\n', '        // `msg.sender` must provide margin for position creation\n', '        require(vars.marginToken.allowance(msg.sender, address(vars.tokenSpender)) >= margins[0].add(margins[1]).mul(_quantity), ERROR_CORE_NOT_ENOUGH_TOKEN_ALLOWANCE);\n', '\n', '    \t// Take ERC20 tokens from msg.sender, should never revert in correct ERC20 implementation\n', '        vars.tokenSpender.claimTokens(vars.marginToken, msg.sender, address(this), margins[0].add(margins[1]).mul(_quantity));\n', '\n', '        // Mint LONG and SHORT positions tokens\n', '        vars.tokenMinter.mint(_addresses[0], _addresses[1], derivativeHash, _quantity);\n', '\n', '        emit Created(_addresses[0], _addresses[1], derivativeHash, _quantity);\n', '    }\n', '\n', '    struct ExecuteAndCancelLocalVars {\n', '        TokenMinter tokenMinter;\n', '        OracleAggregator oracleAggregator;\n', '        SyntheticAggregator syntheticAggregator;\n', '    }\n', '\n', '    /// @notice Executes several positions of `_tokenOwner` with different `tokenId`s\n', '    /// @param _tokenOwner address Address of the owner of positions\n', '    /// @param _tokenIds uint256[] `tokenId`s of positions that needs to be executed\n', '    /// @param _quantities uint256[] Quantity of positions to execute for each `tokenId`\n', '    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\n', '    function _execute(address _tokenOwner, uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) private {\n', '        require(_tokenIds.length == _quantities.length, ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH);\n', '        require(_tokenIds.length == _derivatives.length, ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH);\n', '\n', '        // Local variables\n', '        ExecuteAndCancelLocalVars memory vars;\n', '\n', '        // Create instance of Opium.TokenMinter\n', '        // Create instance of Opium.OracleAggregator\n', '        // Create instance of Opium.SyntheticAggregator\n', '        vars.tokenMinter = TokenMinter(registry.getMinter());\n', '        vars.oracleAggregator = OracleAggregator(registry.getOracleAggregator());\n', '        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());\n', '\n', '        for (uint256 i; i < _tokenIds.length; i++) {\n', '            // Check if execution is performed after endTime\n', '            require(now > _derivatives[i].endTime, ERROR_CORE_EXECUTION_BEFORE_MATURITY_NOT_ALLOWED);\n', '\n', "            // Checking whether execution is performed by `_tokenOwner` or `_tokenOwner` allowed third party executions on it's behalf\n", '            require(\n', '                _tokenOwner == msg.sender ||\n', '                IDerivativeLogic(_derivatives[i].syntheticId).thirdpartyExecutionAllowed(_tokenOwner),\n', '                ERROR_CORE_SYNTHETIC_EXECUTION_WAS_NOT_ALLOWED\n', '            );\n', '\n', '            // Returns payout for all positions\n', '            uint256 payout = _getPayout(_derivatives[i], _tokenIds[i], _quantities[i], vars);\n', '\n', '            // Transfer payout\n', '            if (payout > 0) {\n', '                IERC20(_derivatives[i].token).safeTransfer(_tokenOwner, payout);\n', '            }\n', '\n', '            // Burn executed position tokens\n', '            vars.tokenMinter.burn(_tokenOwner, _tokenIds[i], _quantities[i]);\n', '\n', '            emit Executed(_tokenOwner, _tokenIds[i], _quantities[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Cancels tickers, burns positions and returns margins to positions owners in case no data were provided within `NO_DATA_CANCELLATION_PERIOD`\n', '    /// @param _tokenIds uint256[] `tokenId` of positions that needs to be canceled\n', '    /// @param _quantities uint256[] Quantity of positions to cancel for each `tokenId`\n', '    /// @param _derivatives Derivative[] Derivative definitions for each `tokenId`\n', '    function _cancel(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) private {\n', '        require(_tokenIds.length == _quantities.length, ERROR_CORE_TOKEN_IDS_AND_QUANTITIES_LENGTH_DOES_NOT_MATCH);\n', '        require(_tokenIds.length == _derivatives.length, ERROR_CORE_TOKEN_IDS_AND_DERIVATIVES_LENGTH_DOES_NOT_MATCH);\n', '\n', '        // Local variables\n', '        ExecuteAndCancelLocalVars memory vars;\n', '\n', '        // Create instance of Opium.TokenMinter\n', '        // Create instance of Opium.OracleAggregator\n', '        // Create instance of Opium.SyntheticAggregator\n', '        vars.tokenMinter = TokenMinter(registry.getMinter());\n', '        vars.oracleAggregator = OracleAggregator(registry.getOracleAggregator());\n', '        vars.syntheticAggregator = SyntheticAggregator(registry.getSyntheticAggregator());\n', '\n', '        for (uint256 i; i < _tokenIds.length; i++) {\n', '            // Don\'t allow to cancel tickers with "dummy" oracleIds\n', '            require(_derivatives[i].oracleId != address(0), ERROR_CORE_CANT_CANCEL_DUMMY_ORACLE_ID);\n', '\n', "            // Check if cancellation is called after `NO_DATA_CANCELLATION_PERIOD` and `oracleId` didn't provided data\n", '            require(\n', '                _derivatives[i].endTime + NO_DATA_CANCELLATION_PERIOD <= now &&\n', '                !vars.oracleAggregator.hasData(_derivatives[i].oracleId, _derivatives[i].endTime),\n', '                ERROR_CORE_CANCELLATION_IS_NOT_ALLOWED\n', '            );\n', '\n', '            // Generate hash for derivative\n', '            bytes32 derivativeHash = getDerivativeHash(_derivatives[i]);\n', '\n', '            // Emit `Canceled` event only once and mark ticker as canceled\n', '            if (!cancelled[derivativeHash]) {\n', '                cancelled[derivativeHash] = true;\n', '                emit Canceled(derivativeHash);\n', '            }\n', '\n', '            uint256[2] memory margins;\n', '            // Get cached margin required according to logic from Opium.SyntheticAggregator\n', '            // margins[0] - buyerMargin\n', '            // margins[1] - sellerMargin\n', '            (margins[0], margins[1]) = vars.syntheticAggregator.getMargin(derivativeHash, _derivatives[i]);\n', '\n', '            uint256 payout;\n', '            // Check if `_tokenId` is an ID of LONG position\n', '            if (derivativeHash.getLongTokenId() == _tokenIds[i]) {\n', '                // Set payout to buyerPayout\n', '                payout = margins[0];\n', '\n', '            // Check if `_tokenId` is an ID of SHORT position\n', '            } else if (derivativeHash.getShortTokenId() == _tokenIds[i]) {\n', '                // Set payout to sellerPayout\n', '                payout = margins[1];\n', '            } else {\n', '                // Either portfolioId, hack or bug\n', '                revert(ERROR_CORE_UNKNOWN_POSITION_TYPE);\n', '            }\n', '            \n', '            // Transfer payout * _quantities[i]\n', '            if (payout > 0) {\n', '                IERC20(_derivatives[i].token).safeTransfer(msg.sender, payout.mul(_quantities[i]));\n', '            }\n', '\n', '            // Burn canceled position tokens\n', '            vars.tokenMinter.burn(msg.sender, _tokenIds[i], _quantities[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice Calculates payout for position and gets fees\n', '    /// @param _derivative Derivative Derivative definition\n', '    /// @param _tokenId uint256 `tokenId` of positions\n', '    /// @param _quantity uint256 Quantity of positions\n', '    /// @param _vars ExecuteAndCancelLocalVars Helping local variables\n', '    /// @return payout uint256 Payout for all tokens\n', '    function _getPayout(Derivative memory _derivative, uint256 _tokenId, uint256 _quantity, ExecuteAndCancelLocalVars memory _vars) private returns (uint256 payout) {\n', '        // Trying to getData from Opium.OracleAggregator, could be reverted\n', '        // Opium allows to use "dummy" oracleIds, in this case data is set to `0`\n', '        uint256 data;\n', '        if (_derivative.oracleId != address(0)) {\n', '            data = _vars.oracleAggregator.getData(_derivative.oracleId, _derivative.endTime);\n', '        } else {\n', '            data = 0;\n', '        }\n', '\n', '        uint256[2] memory payoutRatio;\n', '        // Get payout ratio from Derivative logic\n', '        // payoutRatio[0] - buyerPayout\n', '        // payoutRatio[1] - sellerPayout\n', '        (payoutRatio[0], payoutRatio[1]) = IDerivativeLogic(_derivative.syntheticId).getExecutionPayout(_derivative, data);\n', '\n', '        // Generate hash for derivative\n', '        bytes32 derivativeHash = getDerivativeHash(_derivative);\n', '\n', '        // Check if ticker was canceled\n', '        require(!cancelled[derivativeHash], ERROR_CORE_TICKER_WAS_CANCELLED);\n', '\n', '        uint256[2] memory margins;\n', '        // Get cached total margin required from Opium.SyntheticAggregator\n', '        // margins[0] - buyerMargin\n', '        // margins[1] - sellerMargin\n', '        (margins[0], margins[1]) = _vars.syntheticAggregator.getMargin(derivativeHash, _derivative);\n', '\n', '        uint256[2] memory payouts;\n', '        // Calculate payouts from ratio\n', '        // payouts[0] -> buyerPayout = (buyerMargin + sellerMargin) * buyerPayoutRatio / (buyerPayoutRatio + sellerPayoutRatio)\n', '        // payouts[1] -> sellerPayout = (buyerMargin + sellerMargin) * sellerPayoutRatio / (buyerPayoutRatio + sellerPayoutRatio)\n', '        payouts[0] = margins[0].add(margins[1]).mul(payoutRatio[0]).div(payoutRatio[0].add(payoutRatio[1]));\n', '        payouts[1] = margins[0].add(margins[1]).mul(payoutRatio[1]).div(payoutRatio[0].add(payoutRatio[1]));\n', '        \n', '        // Check if `_tokenId` is an ID of LONG position\n', '        if (derivativeHash.getLongTokenId() == _tokenId) {\n', "            // Check if it's a pooled position\n", '            if (_vars.syntheticAggregator.isPool(derivativeHash, _derivative)) {\n', '                // Pooled position payoutRatio is considered as full payout, not as payoutRatio\n', '                payout = payoutRatio[0];\n', '\n', '                // Multiply payout by quantity\n', '                payout = payout.mul(_quantity);\n', '\n', '                // Check sufficiency of syntheticId balance in poolVaults\n', '                require(\n', '                    poolVaults[_derivative.syntheticId][_derivative.token] >= payout\n', '                    ,\n', '                    ERROR_CORE_INSUFFICIENT_POOL_BALANCE\n', '                );\n', '\n', '                // Subtract paid out margin from poolVault\n', '                poolVaults[_derivative.syntheticId][_derivative.token] = poolVaults[_derivative.syntheticId][_derivative.token].sub(payout);\n', '            } else {\n', '                // Set payout to buyerPayout\n', '                payout = payouts[0];\n', '\n', '                // Multiply payout by quantity\n', '                payout = payout.mul(_quantity);\n', '            }\n', '\n', '            // Take fees only from profit makers\n', '            // Check: payout > buyerMargin * quantity\n', '            if (payout > margins[0].mul(_quantity)) {\n', '                // Get Opium and `syntheticId` author fees and subtract it from payout\n', '                payout = payout.sub(_getFees(_vars.syntheticAggregator, derivativeHash, _derivative, payout - margins[0].mul(_quantity)));\n', '            }\n', '\n', '        // Check if `_tokenId` is an ID of SHORT position\n', '        } else if (derivativeHash.getShortTokenId() == _tokenId) {\n', '            // Set payout to sellerPayout\n', '            payout = payouts[1];\n', '\n', '            // Multiply payout by quantity\n', '            payout = payout.mul(_quantity);\n', '\n', '            // Take fees only from profit makers\n', '            // Check: payout > sellerMargin * quantity\n', '            if (payout > margins[1].mul(_quantity)) {\n', '                // Get Opium fees and subtract it from payout\n', '                payout = payout.sub(_getFees(_vars.syntheticAggregator, derivativeHash, _derivative, payout - margins[1].mul(_quantity)));\n', '            }\n', '        } else {\n', '            // Either portfolioId, hack or bug\n', '            revert(ERROR_CORE_UNKNOWN_POSITION_TYPE);\n', '        }\n', '    }\n', '\n', '    /// @notice Calculates `syntheticId` author and opium fees from profit makers\n', '    /// @param _syntheticAggregator SyntheticAggregator Instance of Opium.SyntheticAggregator\n', '    /// @param _derivativeHash bytes32 Derivative hash\n', '    /// @param _derivative Derivative Derivative definition\n', '    /// @param _profit uint256 payout of one position\n', '    /// @return fee uint256 Opium and `syntheticId` author fee\n', '    function _getFees(SyntheticAggregator _syntheticAggregator, bytes32 _derivativeHash, Derivative memory _derivative, uint256 _profit) private returns (uint256 fee) {\n', '        // Get cached `syntheticId` author address from Opium.SyntheticAggregator\n', '        address authorAddress = _syntheticAggregator.getAuthorAddress(_derivativeHash, _derivative);\n', '        // Get cached `syntheticId` fee percentage from Opium.SyntheticAggregator\n', '        uint256 commission = _syntheticAggregator.getAuthorCommission(_derivativeHash, _derivative);\n', '\n', '        // Calculate fee\n', '        // fee = profit * commission / COMMISSION_BASE\n', '        fee = _profit.mul(commission).div(COMMISSION_BASE);\n', '\n', '        // If commission is zero, finish\n', '        if (fee == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // Calculate opium fee\n', '        // opiumFee = fee * OPIUM_COMMISSION_PART / OPIUM_COMMISSION_BASE\n', '        uint256 opiumFee = fee.mul(OPIUM_COMMISSION_PART).div(OPIUM_COMMISSION_BASE);\n', '\n', '        // Calculate author fee\n', '        // authorFee = fee - opiumFee\n', '        uint256 authorFee = fee.sub(opiumFee);\n', '\n', '        // Get opium address\n', '        address opiumAddress = registry.getOpiumAddress();\n', '\n', '        // Update feeVault for Opium team\n', '        // feesVault[opium][token] += opiumFee\n', '        feesVaults[opiumAddress][_derivative.token] = feesVaults[opiumAddress][_derivative.token].add(opiumFee);\n', '\n', '        // Update feeVault for `syntheticId` author\n', '        // feeVault[author][token] += authorFee\n', '        feesVaults[authorAddress][_derivative.token] = feesVaults[authorAddress][_derivative.token].add(authorFee);\n', '    }\n', '}\n', '\n', '// File: contracts/Errors/MatchingErrors.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'contract MatchingErrors {\n', '    string constant internal ERROR_MATCH_CANCELLATION_NOT_ALLOWED = "MATCH:CANCELLATION_NOT_ALLOWED";\n', '    string constant internal ERROR_MATCH_ALREADY_CANCELED = "MATCH:ALREADY_CANCELED";\n', '    string constant internal ERROR_MATCH_ORDER_WAS_CANCELED = "MATCH:ORDER_WAS_CANCELED";\n', '\n', '    string constant internal ERROR_MATCH_TAKER_ADDRESS_WRONG = "MATCH:TAKER_ADDRESS_WRONG";\n', '    string constant internal ERROR_MATCH_ORDER_IS_EXPIRED = "MATCH:ORDER_IS_EXPIRED";\n', '    string constant internal ERROR_MATCH_SENDER_ADDRESS_WRONG = "MATCH:SENDER_ADDRESS_WRONG";\n', '    string constant internal ERROR_MATCH_SIGNATURE_NOT_VERIFIED = "MATCH:SIGNATURE_NOT_VERIFIED";\n', '    string constant internal ERROR_MATCH_NOT_ENOUGH_ALLOWED_FEES = "MATCH:NOT_ENOUGH_ALLOWED_FEES";\n', '}\n', '\n', '// File: contracts/Lib/LibEIP712.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '/// @title Opium.Lib.LibEIP712 contract implements the domain of EIP712 for meta transactions\n', 'contract LibEIP712 {\n', '    // EIP712Domain structure\n', '    // name - protocol name\n', '    // version - protocol version\n', '    // verifyingContract - signed message verifying contract\n', '    struct EIP712Domain {\n', '        string  name;\n', '        string  version;\n', '        address verifyingContract;\n', '    }\n', '\n', '    // Calculate typehash of ERC712Domain\n', '    bytes32 constant internal EIP712DOMAIN_TYPEHASH = keccak256(abi.encodePacked(\n', '        "EIP712Domain(",\n', '        "string name,",\n', '        "string version,",\n', '        "address verifyingContract",\n', '        ")"\n', '    ));\n', '\n', '    // solhint-disable-next-line var-name-mixedcase\n', '    bytes32 internal DOMAIN_SEPARATOR;\n', '\n', '    // Calculate domain separator at creation\n', '    constructor () public {\n', '        DOMAIN_SEPARATOR = keccak256(abi.encode(\n', '            EIP712DOMAIN_TYPEHASH,\n', '            keccak256("Opium Network"),\n', '            keccak256("1"),\n', '            address(this)\n', '        ));\n', '    }\n', '\n', '    /// @notice Hashes EIP712Message\n', '    /// @param hashStruct bytes32 Hash of structured message\n', '    /// @return result bytes32 Hash of EIP712Message\n', '    function hashEIP712Message(bytes32 hashStruct) internal view returns (bytes32 result) {\n', '        bytes32 domainSeparator = DOMAIN_SEPARATOR;\n', '\n', '        assembly {\n', '            // Load free memory pointer\n', '            let memPtr := mload(64)\n', '\n', '            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\n', '            mstore(add(memPtr, 2), domainSeparator)                                            // EIP712 domain hash\n', '            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\n', '\n', '            // Compute hash\n', '            result := keccak256(memPtr, 66)\n', '        }\n', '        return result;\n', '    }\n', '}\n', '\n', '// File: contracts/Matching/Match/LibOrder.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '/// @title Opium.Matching.Match.LibOrder contract implements EIP712 signed Order for Opium.Matching.Match\n', 'contract LibOrder is LibEIP712 {\n', '    /**\n', '        Structure of order\n', '        Description should be considered from the order signer (maker) perspective\n', '\n', '        makerMarginAddress - address of token that maker is willing to pay with\n', '        takerMarginAddress - address of token that maker is willing to receive\n', '\n', '        makerAddress - address of maker\n', '        takerAddress - address of counterparty (taker). If zero address, then taker could be anyone\n', '\n', '        senderAddress - address which is allowed to settle the order on-chain. If zero address, then anyone could settle\n', '\n', '        relayerAddress - address of the relayer fee recipient\n', '        affiliateAddress - address of the affiliate fee recipient\n', '\n', '        feeTokenAddress - address of token which is used for fees\n', '\n', '        makerTokenId - tokenId of position, that maker is willing to pay\n', '        makerTokenAmount - amount of position tokens that maker is willing to pay\n', '        makerMarginAmount - amount of margin token that maker is willing to pay\n', '        takerTokenId - tokenId of position, that maker wants to receive. Create new derivative with this tokenId in case of calling Match.create(). Swap to this tokenId in case Match.swap() is called.\n', '        takerTokenAmount - amount of tokens that maker wants to receive\n', '        takerMarginAmount - amount of margin that maker wants to receive\n', '\n', '        relayerFee - amount of fee in feeToken that should be paid to relayer\n', '        affiliateFee - amount of fee in feeToken that should be paid to affiliate\n', '\n', '        nonce - unique order ID\n', '        expiresAt - UNIX timestamp of order expiration. Zero for Good-Till-Cancel order\n', '\n', '        signature - Signature of EIP712 message. Not used in hash, but then set for order processing purposes\n', '\n', '     */\n', '    struct Order {\n', '        address makerMarginAddress;\n', '        address takerMarginAddress;\n', '\n', '        address makerAddress;\n', '        address takerAddress;\n', '\n', '        address senderAddress;\n', '\n', '        address relayerAddress;\n', '        address affiliateAddress;\n', '\n', '        address feeTokenAddress;\n', '\n', '        uint256 makerTokenId;\n', '        uint256 makerTokenAmount;\n', '        uint256 makerMarginAmount;\n', '        uint256 takerTokenId;\n', '        uint256 takerTokenAmount;\n', '        uint256 takerMarginAmount;\n', '\n', '        uint256 relayerFee;\n', '        uint256 affiliateFee;\n', '\n', '        uint256 nonce;\n', '        uint256 expiresAt;\n', '\n', '        // Not used in hash\n', '        bytes signature;\n', '    }\n', '\n', '    // Calculate typehash of Order\n', '    bytes32 constant internal EIP712_ORDER_TYPEHASH = keccak256(abi.encodePacked(\n', '        "Order(",\n', '        "address makerMarginAddress,",\n', '        "address takerMarginAddress,",\n', '\n', '        "address makerAddress,",\n', '        "address takerAddress,",\n', '\n', '        "address senderAddress,",\n', '\n', '        "address relayerAddress,",\n', '        "address affiliateAddress,",\n', '\n', '        "address feeTokenAddress,",\n', '\n', '        "uint256 makerTokenId,",\n', '        "uint256 makerTokenAmount,",\n', '        "uint256 makerMarginAmount,",\n', '        "uint256 takerTokenId,",\n', '        "uint256 takerTokenAmount,",\n', '        "uint256 takerMarginAmount,",\n', '        \n', '        "uint256 relayerFee,",\n', '        "uint256 affiliateFee,",\n', '\n', '        "uint256 nonce,",\n', '        "uint256 expiresAt",\n', '        ")"\n', '    ));\n', '\n', '    /// @notice Hashes the order\n', '    /// @param _order Order Order to hash\n', '    /// @return hash bytes32 Order hash\n', '    function hashOrder(Order memory _order) public pure returns (bytes32 hash) {\n', '        hash = keccak256(\n', '            abi.encodePacked(\n', '                abi.encodePacked(\n', '                    EIP712_ORDER_TYPEHASH,\n', '                    uint256(_order.makerMarginAddress),\n', '                    uint256(_order.takerMarginAddress),\n', '\n', '                    uint256(_order.makerAddress),\n', '                    uint256(_order.takerAddress),\n', '\n', '                    uint256(_order.senderAddress),\n', '\n', '                    uint256(_order.relayerAddress),\n', '                    uint256(_order.affiliateAddress),\n', '\n', '                    uint256(_order.feeTokenAddress)\n', '                ),\n', '                abi.encodePacked(\n', '                    _order.makerTokenId,\n', '                    _order.makerTokenAmount,\n', '                    _order.makerMarginAmount,\n', '                    _order.takerTokenId,\n', '                    _order.takerTokenAmount,\n', '                    _order.takerMarginAmount\n', '                ),\n', '                abi.encodePacked(\n', '                    _order.relayerFee,\n', '                    _order.affiliateFee,\n', '\n', '                    _order.nonce,\n', '                    _order.expiresAt\n', '                )\n', '            )\n', '        );\n', '    }\n', '\n', '    /// @notice Verifies order signature\n', '    /// @param _hash bytes32 Hash of the order\n', '    /// @param _signature bytes Signature of the order\n', '    /// @param _address address Address of the order signer\n', '    /// @return bool Returns whether `_signature` is valid and was created by `_address`\n', '    function verifySignature(bytes32 _hash, bytes memory _signature, address _address) internal view returns (bool) {\n', '        require(_signature.length == 65, "ORDER:INVALID_SIGNATURE_LENGTH");\n', '\n', '        bytes32 digest = hashEIP712Message(_hash);\n', '        address recovered = retrieveAddress(digest, _signature);\n', '        return _address == recovered;\n', '    }\n', '\n', '    /// @notice Helping function to recover signer address\n', '    /// @param _hash bytes32 Hash for signature\n', '    /// @param _signature bytes Signature\n', '    /// @return address Returns address of signature creator\n', '    function retrieveAddress(bytes32 _hash, bytes memory _signature) private pure returns (address) {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        // Divide the signature in r, s and v variables\n', '        // ecrecover takes the signature parameters, and the only way to get them\n', '        // currently is to use assembly.\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            r := mload(add(_signature, 32))\n', '            s := mload(add(_signature, 64))\n', '            v := byte(0, mload(add(_signature, 96)))\n', '        }\n', '\n', '        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        // If the version is correct return the signer address\n', '        if (v != 27 && v != 28) {\n', '            return (address(0));\n', '        } else {\n', '            // solium-disable-next-line arg-overflow\n', '            return ecrecover(_hash, v, r, s);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/Matching/Match/MatchLogic.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/// @title Opium.Matching.MatchLogic contract implements logic for order validation and cancelation\n', 'contract MatchLogic is MatchingErrors, LibOrder, UsingRegistry, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '    using LibPosition for bytes32;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // Emmitted when order was canceled\n', '    event Canceled(bytes32 orderHash);\n', '\n', '    // Base value for 100% value of token/margin amount\n', '    uint256 public constant PERCENTAGE_BASE = 10**30;\n', '\n', '    // Canceled orders\n', '    // This mapping holds hashes of canceled orders\n', '    // canceled[orderHash] => canceled\n', '    mapping (bytes32 => bool) public canceled;\n', '\n', '    // Verified orders\n', '    // This mapping holds hashes of verified orders to verify only once\n', '    // verified[orderHash] => verified\n', '    mapping (bytes32 => bool) public verified;\n', '\n', '    // Orders filling percentage\n', '    // This mapping holds orders filled percentage in base of PERCENTAGE_BASE\n', '    // filled[orderHash] => filled\n', '    mapping (bytes32 => uint256) public filled;\n', '    \n', '    // Vaults for fees\n', '    // This mapping holds balances of relayers and affiliates fees to withdraw\n', '    // balances[feeRecipientAddress][tokenAddress] => balances\n', '    mapping (address => mapping (address => uint256)) public balances;\n', '\n', '    // Keeps whether fee was already taken\n', '    mapping (bytes32 => bool) public feeTaken;\n', '\n', '    /// @notice Calling this function maker of the order could cancel it on-chain\n', '    /// @param _order Order\n', '    function cancel(Order memory _order) public {\n', '        require(msg.sender == _order.makerAddress, ERROR_MATCH_CANCELLATION_NOT_ALLOWED);\n', '        bytes32 orderHash = hashOrder(_order);\n', '        require(!canceled[orderHash], ERROR_MATCH_ALREADY_CANCELED);\n', '        canceled[orderHash] = true;\n', '\n', '        emit Canceled(orderHash);\n', '    }\n', '\n', '    /// @notice Function to withdraw fees from orders for relayer and affiliates\n', '    /// @param _token IERC20 Instance of token to withdraw\n', '    function withdraw(IERC20 _token) public nonReentrant {\n', '        uint256 balance = balances[msg.sender][address(_token)];\n', '        balances[msg.sender][address(_token)] = 0;\n', '        _token.safeTransfer(msg.sender, balance);\n', '    }\n', '\n', '    /// @notice This function checks whether order was canceled\n', '    /// @param _hash bytes32 Hash of the order\n', '    function validateNotCanceled(bytes32 _hash) internal view {\n', '        require(!canceled[_hash], ERROR_MATCH_ORDER_WAS_CANCELED);\n', '    }\n', '\n', '    /// @notice This function validates takerAddress of _leftOrder. It should match either with _rightOrder.makerAddress or be set to zero address\n', '    /// @param _leftOrder Order Left order\n', '    /// @param _rightOrder Order Right order\n', '    function validateTakerAddress(Order memory _leftOrder, Order memory _rightOrder) internal pure {\n', '        require(\n', '            _leftOrder.takerAddress == address(0) ||\n', '            _leftOrder.takerAddress == _rightOrder.makerAddress,\n', '            ERROR_MATCH_TAKER_ADDRESS_WRONG\n', '        );\n', '    }\n', '\n', "    /// @notice This function validates whether order was expired or it's `expiresAt` is set to zero\n", '    /// @param _order Order\n', '    function validateExpiration(Order memory _order) internal view {\n', '        require(\n', '            _order.expiresAt == 0 ||\n', '            _order.expiresAt > now,\n', '            ERROR_MATCH_ORDER_IS_EXPIRED\n', '        );\n', '    }\n', '\n', '    /// @notice This function validates whether sender address equals to `msg.sender` or set to zero address\n', '    /// @param _order Order\n', '    function validateSenderAddress(Order memory _order) internal view {\n', '        require(\n', '            _order.senderAddress == address(0) ||\n', '            _order.senderAddress == msg.sender,\n', '            ERROR_MATCH_SENDER_ADDRESS_WRONG\n', '        );\n', '    }\n', '\n', '    /// @notice This function validates order signature if not validated before\n', '    /// @param orderHash bytes32 Hash of the order\n', '    /// @param _order Order\n', '    function validateSignature(bytes32 orderHash, Order memory _order) internal {\n', '        if (verified[orderHash]) {\n', '            return;\n', '        }\n', '\n', '        bool result = verifySignature(orderHash, _order.signature, _order.makerAddress);\n', '\n', '        require(result, ERROR_MATCH_SIGNATURE_NOT_VERIFIED);\n', '        \n', '        verified[orderHash] = true;\n', '    }\n', '\n', '    /// @notice This function is responsible for taking relayer and affiliate fees, if they were not taken already\n', '    /// @param _orderHash bytes32 Hash of the order\n', '    /// @param _order Order Order itself\n', '    function takeFees(bytes32 _orderHash, Order memory _order) internal {\n', '        // Check if fee was already taken\n', '        if (feeTaken[_orderHash]) {\n', '            return;\n', '        }\n', '\n', '        // Check if feeTokenAddress is not set to zero address\n', '        if (_order.feeTokenAddress == address(0)) {\n', '            return;\n', '        }\n', '\n', '        // Calculate total amount of fees needs to be transfered\n', '        uint256 fees = _order.relayerFee.add(_order.affiliateFee);\n', '\n', '        // If total amount of fees is non-zero\n', '        if (fees == 0) {\n', '            return;\n', '        }\n', '\n', '        // Create instance of fee token\n', '        IERC20 feeToken = IERC20(_order.feeTokenAddress);\n', '\n', '        // Create instance of TokenSpender\n', '        TokenSpender tokenSpender = TokenSpender(registry.getTokenSpender());\n', '\n', '        // Check if user has enough token approval to pay the fees\n', '        require(feeToken.allowance(_order.makerAddress, address(tokenSpender)) >= fees, ERROR_MATCH_NOT_ENOUGH_ALLOWED_FEES);\n', '        // Transfer fee\n', '        tokenSpender.claimTokens(feeToken, _order.makerAddress, address(this), fees);\n', '\n', '        // Get opium address\n', '        address opiumAddress = registry.getOpiumAddress();\n', '\n', '        // Add commission to relayer balance, or to opium balance if relayer is not set\n', '        if (_order.relayerAddress != address(0)) {\n', '            balances[_order.relayerAddress][_order.feeTokenAddress] = balances[_order.relayerAddress][_order.feeTokenAddress].add(_order.relayerFee);\n', '        } else {\n', '            balances[opiumAddress][_order.feeTokenAddress] = balances[opiumAddress][_order.feeTokenAddress].add(_order.relayerFee);\n', '        }\n', '\n', '        // Add commission to affiliate balance, or to opium balance if affiliate is not set\n', '        if (_order.affiliateAddress != address(0)) {\n', '            balances[_order.affiliateAddress][_order.feeTokenAddress] = balances[_order.affiliateAddress][_order.feeTokenAddress].add(_order.affiliateFee);\n', '        } else {\n', '            balances[opiumAddress][_order.feeTokenAddress] = balances[opiumAddress][_order.feeTokenAddress].add(_order.affiliateFee);\n', '        }\n', '\n', '        // Mark the fee of token as taken\n', '        feeTaken[_orderHash] = true;\n', '    }\n', '\n', '    /// @notice Helper to get minimal of two integers\n', '    /// @param _a uint256 First integer\n', '    /// @param _b uint256 Second integer\n', '    /// @return uint256 Minimal integer\n', '    function min(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        return _a < _b ? _a : _b;\n', '    }\n', '\n', '    /// @notice Helper to get percentage of division in base of PERCENTAGE_BASE\n', '    /// devP = numerator / denominator * 100%\n', '    /// @param _numerator uint256 Numerator of division\n', '    /// @param _denominator uint256 Denominator of division\n', '    /// @return divisionPercentage uint256 Percentage of division\n', '    function getDivisionPercentage(uint256 _numerator, uint256 _denominator) internal pure returns (uint256 divisionPercentage) {\n', '        divisionPercentage = _numerator.mul(PERCENTAGE_BASE).div(_denominator).add(1);\n', '\n', '        // In case of numerator > denominator consider as 100%\n', '        if (divisionPercentage > PERCENTAGE_BASE) {\n', '            divisionPercentage = PERCENTAGE_BASE;\n', '        }\n', '    }\n', '\n', '    /// @notice Helper to recover numerator from percentage of division in base of PERCENTAGE_BASE\n', '    /// numerator = devP * denominator / 100%\n', '    /// @param _divisionPercentage Percentage of division\n', '    /// @param _denominator uint256 Denominator of division\n', '    /// @return numerator uint256 Recovered numerator\n', '    function getInitialPercentageValue(uint256 _divisionPercentage, uint256 _denominator) internal pure returns (uint256 numerator) {\n', '        numerator = _divisionPercentage.mul(_denominator).div(PERCENTAGE_BASE);\n', '    }\n', '}\n', '\n', '// File: contracts/Matching/Match/MatchCreate.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '/// @title Opium.Matching.MatchCreate contract implements create() function to settle a pair of orders and create derivatives for order makers\n', 'contract MatchCreate is MatchLogic, LibDerivative {\n', '    // Emmitted when new order pair was successfully settled\n', '    event Create(bytes32 derivativeHash, address buyerPremiumAddress, uint256 buyerPremiumAmount, address sellerPremiumAddress, uint256 sellerPremiumAmount, uint256 filled);\n', '\n', '    /// @notice This function receives buy and sell orders, derivative related to it and information whether buy order was first in orderbook (maker)\n', '    /// @param _buyOrder Order Order of derivative buyer\n', '    /// @param _sellOrder Order Order of derivative seller\n', '    /// @param _derivative Derivative Data of derivative for validation and calculation purposes\n', '    /// @param _buyerIsMaker bool Indicates whether buyer order came to orderbook first\n', '    function create(Order memory _buyOrder, Order memory _sellOrder, Derivative memory _derivative, bool _buyerIsMaker) public nonReentrant {\n', '        // New deals must not offer tokenIds\n', '        require(\n', '            _buyOrder.makerTokenId == _sellOrder.makerTokenId &&\n', '            _sellOrder.makerTokenId == 0,\n', '            "MATCH:NOT_CREATION"\n', '        );\n', '\n', "        // Check if it's not pooled positions\n", '        require(!IDerivativeLogic(_derivative.syntheticId).isPool(), "MATCH:CANT_BE_POOL");\n', '\n', '        // Validate taker if set\n', '        validateTakerAddress(_buyOrder, _sellOrder);\n', '        validateTakerAddress(_sellOrder, _buyOrder);\n', '\n', '        // Validate sender if set\n', '        validateSenderAddress(_buyOrder);\n', '        validateSenderAddress(_sellOrder);\n', '\n', '        // Validate expiration if set\n', '        validateExpiration(_buyOrder);\n', '        validateExpiration(_sellOrder);\n', '\n', '\n', '        // Validate orders signatures and if orders were canceled\n', '        // orderHashes[0] - buyOrderHash\n', '        // orderHashes[1] - sellOrderHash\n', '        bytes32[2] memory orderHashes;\n', '        orderHashes[0] = hashOrder(_buyOrder);\n', '        validateNotCanceled(orderHashes[0]);\n', '        validateSignature(orderHashes[0], _buyOrder);\n', '\n', '        orderHashes[1] = hashOrder(_sellOrder);\n', '        validateNotCanceled(orderHashes[1]);\n', '        validateSignature(orderHashes[1], _sellOrder);\n', '\n', '        // Validates counterparty tokens and margin\n', '        // Calculates available premiums\n', '        // margins[0] - buyerMargin\n', '        // margins[1] - sellerMargin\n', '        (uint256[2] memory margins, bytes32 derivativeHash) = _validateDerivativeAndCalculateMargin(_buyOrder, _sellOrder, _derivative);\n', '\n', '        // Premiums\n', '        // premiums[0] - buyerReceivePremium\n', '        // premiums[1] - sellerReceivePremium\n', '        uint256[2] memory premiums;\n', '\n', "        // If buyer requires premium on creation, should match with seller's margin token address\n", '        // If buyer requires premium on creation, seller should provide at least the same premium or more\n', "        // Returns buyer's premium for each contract\n", '        premiums[0] = _validatePremium(_buyOrder, _sellOrder, margins[1], _buyerIsMaker);\n', '\n', "        // If seller requires premium on creation, should match with buyer's margin token address\n", '        // If seller requires premium on creation, buyer should provide at least the same premium or more\n', "        // Returns seller's premium for each contract\n", '        premiums[1] = _validatePremium(_sellOrder, _buyOrder, margins[0], !_buyerIsMaker);\n', '\n', '        // Fill orders as much as possible\n', '        // Returns available amount of positions to be filled\n', '        uint256 fillPositions = _fillCreate(_buyOrder, orderHashes[0], _sellOrder, orderHashes[1]);\n', '\n', '        // Take fees\n', '        takeFees(orderHashes[0], _buyOrder);\n', '        takeFees(orderHashes[1], _sellOrder);\n', '\n', '        // Distribute margin and premium\n', '        _distributeFunds(_buyOrder, _sellOrder, _derivative, margins, premiums, fillPositions);\n', '        \n', '        // Settle contracts\n', '        Core(registry.getCore()).create(_derivative, fillPositions, [_buyOrder.makerAddress, _sellOrder.makerAddress]);\n', '        \n', '        emit Create(derivativeHash, _buyOrder.takerMarginAddress, premiums[0], _sellOrder.takerMarginAddress, premiums[1], fillPositions);\n', '    }\n', '\n', '    // PRIVATE FUNCTIONS\n', '\n', '    /// @notice Validates derivative, tokenIds and gets required cached margin\n', '    /// @param _buyOrder Order Order of derivative buyer\n', '    /// @param _sellOrder Order Order of derivative seller\n', '    /// @param _derivative Derivative Data of derivative for validation and calculation purposes\n', '    /// @return margins uint256[2] buyer and seller margin array\n', '    /// @return derivativeHash bytes32 Hash of derivative\n', '    function _validateDerivativeAndCalculateMargin(Order memory _buyOrder, Order memory _sellOrder, Derivative memory _derivative) private returns (uint256[2] memory margins, bytes32 derivativeHash) {\n', '        // Calculate derivative related data for validation\n', '        derivativeHash = getDerivativeHash(_derivative);\n', '        uint256 longTokenId = derivativeHash.getLongTokenId();\n', '        uint256 shortTokenId = derivativeHash.getShortTokenId();\n', '\n', '        // New deals must request opposite position tokens\n', '        require(\n', '            _buyOrder.takerTokenId != _sellOrder.takerTokenId &&\n', '            _buyOrder.takerTokenId == longTokenId &&\n', '            _sellOrder.takerTokenId == shortTokenId,\n', '            "MATCH:DERIVATIVE_NOT_MATCH"\n', '        );\n', '\n', '        // Get cached total margin required according to logic\n', '        // margins[0] - buyerMargin\n', '        // margins[1] - sellerMargin\n', '        (margins[0], margins[1]) = SyntheticAggregator(registry.getSyntheticAggregator()).getMargin(derivativeHash, _derivative);\n', '        \n', '        // Validate that provided margin token is the same as derivative margin token\n', '        require(\n', '            margins[0] == 0 || _buyOrder.makerMarginAddress == _derivative.token\n', '            , "MATCH:PROVIDED_MARGIN_CURRENCY_WRONG"\n', '        );\n', '        require(\n', '            margins[1] == 0 || _sellOrder.makerMarginAddress == _derivative.token\n', '            , "MATCH:PROVIDED_MARGIN_CURRENCY_WRONG"\n', '        );\n', '\n', '        // Validate that provided margin is enough for creating new positions\n', '        require(\n', '            _buyOrder.makerMarginAmount >= _buyOrder.takerTokenAmount.mul(margins[0]) &&\n', '            _sellOrder.makerMarginAmount >= _sellOrder.takerTokenAmount.mul(margins[1]),\n', '            "MATCH:PROVIDED_MARGIN_NOT_ENOUGH"\n', '        );\n', '    }\n', '\n', '    /// @notice Calculates and validates premium\n', '    /// @param _leftOrder Order Order for which we calculate premium\n', '    /// @param _rightOrder Order Counterparty order\n', '    /// @param _rightOrderMargin uint256 Margin of counterparty order\n', '    /// @param _leftIsMaker bool Whether left order first came to orderbook\n', '    /// @return Returns left order premium\n', '    function _validatePremium(Order memory _leftOrder, Order memory _rightOrder, uint256 _rightOrderMargin, bool _leftIsMaker) private pure returns(uint256) {\n', "        // If order doesn't require premium, exit\n", '        if (_leftOrder.takerMarginAmount == 0) {\n', '            return 0; // leftReceivePremium is 0\n', '        }\n', '\n', '        // Validate premium/margin token address\n', '        require(\n', '            _leftOrder.takerMarginAddress == _rightOrder.makerMarginAddress,\n', '            "MATCH:MARGIN_ADDRESS_NOT_MATCH"\n', '        );\n', '\n', '        // Calculate how much left order maker wants premium for each contract\n', '        uint256 leftWantsPremium = _leftOrder.takerMarginAmount.div(_leftOrder.takerTokenAmount);\n', '        // Calculate how much right order maker offers premium excluding margin required for derivative\n', '        uint256 rightOffersPremium = _rightOrder.makerMarginAmount.div(_rightOrder.takerTokenAmount).sub(_rightOrderMargin);\n', '\n', '        // Check if right order offers enough premium for left order\n', '        require(\n', '            leftWantsPremium <= rightOffersPremium,\n', '            "MATCH:PREMIUM_IS_NOT_ENOUGH"\n', '        );\n', '\n', '        // Take premium of order, who first came to orderbook\n', '        return _leftIsMaker ? leftWantsPremium : rightOffersPremium;\n', '    }\n', '\n', '    /// @notice Calculates orders fillability (available positions to fill) and validates\n', '    /// @param _leftOrder Order \n', '    /// @param _leftOrderHash bytes32\n', '    /// @param _rightOrder Order \n', '    /// @param _rightOrderHash bytes32\n', '    /// @return fillPositions uint256 Available amount of positions to be filled\n', '    function _fillCreate(Order memory _leftOrder, bytes32 _leftOrderHash, Order memory _rightOrder, bytes32 _rightOrderHash) private returns (uint256 fillPositions) {\n', '        // Keep initial orders takerTokenAmount values\n', '        uint256 leftInitial = _leftOrder.takerTokenAmount;\n', '        uint256 rightInitial = _rightOrder.takerTokenAmount;\n', '\n', '        // Calcualte already filled part\n', '        uint256 leftAlreadyFilled = getInitialPercentageValue(filled[_leftOrderHash], _leftOrder.takerTokenAmount);\n', '        uint256 rightAlreadyFilled = getInitialPercentageValue(filled[_rightOrderHash], _rightOrder.takerTokenAmount);\n', '\n', '        // Subtract already filled part and calculate left order and right order available part\n', '        (uint256 leftAvailable, uint256 rightAvailable) = (\n', '            _leftOrder.takerTokenAmount.sub(leftAlreadyFilled), \n', '            _rightOrder.takerTokenAmount.sub(rightAlreadyFilled)\n', '        );\n', '\n', '        // We could only fill minimum available of both counterparties\n', '        fillPositions = min(leftAvailable, rightAvailable);\n', '        require(fillPositions > 0, "MATCH:NO_FILLABLE_POSITIONS");\n', '\n', '        // Update filled\n', '        // If initial takerTokenAmount was 0, set filled to 100%\n', '        // Otherwise calculate new filled percetage -> (alreadyFilled + fill) / initial * 100%\n', '        filled[_leftOrderHash] = leftInitial == 0 ? PERCENTAGE_BASE : getDivisionPercentage(leftAlreadyFilled.add(fillPositions), leftInitial);\n', '        filled[_rightOrderHash] = rightInitial == 0 ? PERCENTAGE_BASE : getDivisionPercentage(rightAlreadyFilled.add(fillPositions), rightInitial);\n', '    }\n', '\n', '    /// @notice This function distributes premiums, takes margin and approves it to Core\n', '    /// @param _buyOrder Order Order of derivative buyer\n', '    /// @param _sellOrder Order Order of derivative seller\n', '    /// @param _derivative Derivative Data of derivative for validation and calculation purposes\n', '    /// @param margins uint256[2] Margins of buyer and seller\n', '    /// @param premiums uint256[2] Premiums of buyer and seller\n', '    /// @param fillPositions uint256 Quantity of positions to fill\n', '    function _distributeFunds(\n', '        Order memory _buyOrder,\n', '        Order memory _sellOrder,\n', '        Derivative memory _derivative,\n', '        uint256[2] memory margins,\n', '        uint256[2] memory premiums,\n', '        uint256 fillPositions\n', '    ) private {\n', '        IERC20 marginToken = IERC20(_derivative.token);\n', '        TokenSpender tokenSpender = TokenSpender(registry.getTokenSpender());\n', '\n', '        // Transfer margin + premium from buyer to Match and distribute\n', '        if (margins[0].add(premiums[1]) != 0) {\n', '            // Check allowance for premiums + margins\n', '            require(marginToken.allowance(_buyOrder.makerAddress, address(tokenSpender)) >= margins[0].add(premiums[1]).mul(fillPositions), "MATCH:NOT_ENOUGH_ALLOWED_MARGIN");\n', '\n', '            if (premiums[1] != 0) {\n', '                // Transfer premium to seller\n', '                tokenSpender.claimTokens(marginToken, _buyOrder.makerAddress, _sellOrder.makerAddress, premiums[1].mul(fillPositions));\n', '            }\n', '\n', '            if (margins[0] != 0) {\n', '                // Transfer margins from buyer to Match\n', '                tokenSpender.claimTokens(marginToken, _buyOrder.makerAddress, address(this), margins[0].mul(fillPositions));\n', '            }\n', '        }\n', '        \n', '        // Transfer margin + premium from seller to Match and distribute\n', '        if (margins[1].add(premiums[0]) != 0) {\n', '            // Check allowance for premiums + margin\n', '            require(marginToken.allowance(_sellOrder.makerAddress, address(tokenSpender)) >= margins[1].add(premiums[0]).mul(fillPositions), "MATCH:NOT_ENOUGH_ALLOWED_MARGIN");\n', '\n', '            if (premiums[0] != 0) {\n', '                // Transfer premium to buyer\n', '                tokenSpender.claimTokens(marginToken, _sellOrder.makerAddress, _buyOrder.makerAddress, premiums[0].mul(fillPositions));\n', '            }\n', '\n', '            if (margins[1] != 0) {\n', '                // Transfer margins from seller to Match\n', '                tokenSpender.claimTokens(marginToken, _sellOrder.makerAddress, address(this), margins[1].mul(fillPositions));\n', '            }\n', '        }\n', '\n', '        if (margins[0].add(margins[1]) != 0) {\n', '            // Approve margin to Core for derivative creation\n', '            require(marginToken.approve(address(tokenSpender), margins[0].add(margins[1]).mul(fillPositions)), "MATCH:COULDNT_APPROVE_MARGIN_FOR_CORE");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/Matching/Match/MatchSwap.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '/// @title Opium.Matching.MatchSwap contract implements swap() function to make TMtm swap\n', '/// TMtm swap is swaps of Token + Margin to Token + MArgin\n', 'contract MatchSwap is MatchLogic {\n', '    // Emmited when swap is made\n', '    event Swap(\n', '        uint256 leftMakerTokenId, uint256 leftMakerTokenAmount,\n', '        address leftMakerMarginAddress, uint256 leftMakerMarginAmount,\n', '        uint256 rightMakerTokenId, uint256 rightMakerTokenAmount,\n', '        address rightMakerMarginAddress, uint256 rightMakerMarginAmount\n', '    );\n', '\n', '    /// @notice This function receives left and right orders, and performs swap of Token + Margin to Token + Margin swaps\n', '    /// @param _leftOrder Order\n', '    /// @param _rightOrder Order\n', '    function swap(Order memory _leftOrder, Order memory _rightOrder) public nonReentrant {\n', '        // Validate taker if set\n', '        validateTakerAddress(_leftOrder, _rightOrder);\n', '        validateTakerAddress(_rightOrder, _leftOrder);\n', '\n', '        // Validate sender if set\n', '        validateSenderAddress(_leftOrder);\n', '        validateSenderAddress(_rightOrder);\n', '\n', '        // Validate expiration if set\n', '        validateExpiration(_leftOrder);\n', '        validateExpiration(_rightOrder);\n', '\n', '\n', '        // Validate if was canceled\n', '        // orderHashes[0] - leftOrderHash\n', '        // orderHashes[1] - rightOrderHash\n', '        bytes32[2] memory orderHashes;\n', '        orderHashes[0] = hashOrder(_leftOrder);\n', '        validateNotCanceled(orderHashes[0]);\n', '        validateSignature(orderHashes[0], _leftOrder);\n', '\n', '        orderHashes[1] = hashOrder(_rightOrder);\n', '        validateNotCanceled(orderHashes[1]);\n', '        validateSignature(orderHashes[1], _rightOrder);\n', '\n', '        // Validate if values are correct\n', '        // Fill orders as much as possible\n', '        // leftFill[0] - Tokens that left sends to right\n', '        // leftFill[1] - Margin that left sends to right\n', '        // rightFill[0] - Tokens that right sends to left\n', '        // rightFill[1] - Margin that right sends to left\n', '        (uint256[2] memory leftFill, uint256[2] memory rightFill) = _validateOffersAndFillSwap(_leftOrder, orderHashes[0], _rightOrder, orderHashes[1]);\n', '\n', '        // Take fees\n', '        takeFees(orderHashes[0], _leftOrder);\n', '        takeFees(orderHashes[1], _rightOrder);\n', '\n', '        // Validate if swap is possible and make it\n', '        _validateAndMakeSwap(_leftOrder, leftFill, _rightOrder, rightFill);\n', '    }\n', '\n', '    /// @notice Validates Orders according to TMtm logic and calculates fillability\n', '    /// @param _leftOrder Order\n', '    /// @param _leftOrderHash bytes32\n', '    /// @param _rightOrder Order\n', '    /// @param _rightOrderHash bytes32\n', '    /// @return leftFill uint256[2] Left fillability\n', '    /// @return rightFill uint256[2] Right fillability\n', '    function _validateOffersAndFillSwap(Order memory _leftOrder, bytes32 _leftOrderHash, Order memory _rightOrder, bytes32 _rightOrderHash) private returns (uint256[2] memory leftFill, uint256[2] memory rightFill) {\n', '        // Keep initial order takerTokenAmount and takerMarginAmount values\n', '        uint256[2] memory leftInitial;\n', '        uint256[2] memory rightInitial;\n', '        leftInitial[0] = _leftOrder.takerTokenAmount;\n', '        leftInitial[1] = _leftOrder.takerMarginAmount;\n', '        rightInitial[0] = _rightOrder.takerTokenAmount;\n', '        rightInitial[1] = _rightOrder.takerMarginAmount;\n', '        \n', '        // Calculates already filled part\n', '        uint256[2] memory leftAlreadyFilled;\n', '        leftAlreadyFilled[0] = getInitialPercentageValue(filled[_leftOrderHash], _leftOrder.takerTokenAmount);\n', '        leftAlreadyFilled[1] = getInitialPercentageValue(filled[_leftOrderHash], _leftOrder.takerMarginAmount);\n', '        _leftOrder.takerTokenAmount = _leftOrder.takerTokenAmount.sub(leftAlreadyFilled[0]);\n', '        _leftOrder.takerMarginAmount = _leftOrder.takerMarginAmount.sub(leftAlreadyFilled[1]);\n', '\n', '        // Subtract already filled part\n', '        uint256[2] memory rightAlreadyFilled;\n', '        rightAlreadyFilled[0] = getInitialPercentageValue(filled[_rightOrderHash], _rightOrder.takerTokenAmount);\n', '        rightAlreadyFilled[1] = getInitialPercentageValue(filled[_rightOrderHash], _rightOrder.takerMarginAmount);\n', '        _rightOrder.takerTokenAmount = _rightOrder.takerTokenAmount.sub(rightAlreadyFilled[0]);\n', '        _rightOrder.takerMarginAmount = _rightOrder.takerMarginAmount.sub(rightAlreadyFilled[1]);\n', '\n', '        // Calculate if swap is possible\n', '        uint256[4] memory left;\n', '        uint256[4] memory right;\n', '\n', '        left[0] = _leftOrder.makerTokenAmount.mul(_rightOrder.makerTokenAmount);\n', '        right[0] = _leftOrder.takerTokenAmount.mul(_rightOrder.takerTokenAmount);\n', '        \n', '        left[1] = _leftOrder.makerTokenAmount.mul(_rightOrder.makerMarginAmount);\n', '        right[1] = _leftOrder.takerMarginAmount.mul(_rightOrder.takerTokenAmount);\n', '        \n', '        left[2] = _leftOrder.makerMarginAmount.mul(_rightOrder.makerTokenAmount);\n', '        right[2] = _leftOrder.takerTokenAmount.mul(_rightOrder.takerMarginAmount);\n', '        \n', '        left[3] = _leftOrder.makerMarginAmount.mul(_rightOrder.makerMarginAmount);\n', '        right[3] = _leftOrder.takerMarginAmount.mul(_rightOrder.takerMarginAmount);\n', '\n', '        require(\n', '            left[0] >= right[0] &&\n', '            left[1] >= right[1] &&\n', '            left[2] >= right[2] &&\n', '            left[3] >= right[3],\n', '            "MATCH:OFFERS_CONDITIONS_ARE_NOT_MET"\n', '        );\n', '\n', '        // Calculate fillable values\n', '        leftFill[0] = min(_leftOrder.makerTokenAmount, _rightOrder.takerTokenAmount);\n', '        leftFill[1] = min(_leftOrder.makerMarginAmount, _rightOrder.takerMarginAmount);\n', '\n', '        rightFill[0] = min(_leftOrder.takerTokenAmount, _rightOrder.makerTokenAmount);\n', '        rightFill[1] = min(_leftOrder.takerMarginAmount, _rightOrder.makerMarginAmount);\n', '        require(\n', '            leftFill[0] != 0 ||\n', '            leftFill[1] != 0 ||\n', '            rightFill[0] != 0 ||\n', '            rightFill[1] != 0\n', '            , "MATCH:NO_FILLABLE_POSITIONS");\n', '\n', '        // Update filled\n', '        // See Match.create()\n', '        uint256[2] memory leftFilledPercents;\n', '        leftFilledPercents[0] = leftInitial[0] == 0 ? PERCENTAGE_BASE : getDivisionPercentage(leftAlreadyFilled[0].add(rightFill[0]), leftInitial[0]);\n', '        leftFilledPercents[1] = leftInitial[1] == 0 ? PERCENTAGE_BASE : getDivisionPercentage(leftAlreadyFilled[1].add(rightFill[1]), leftInitial[1]);\n', '\n', '        filled[_leftOrderHash] = min(leftFilledPercents[0], leftFilledPercents[1]);\n', '\n', '        uint256[2] memory rightFilledPercents;\n', '        rightFilledPercents[0] = rightInitial[0] == 0 ? PERCENTAGE_BASE : getDivisionPercentage(rightAlreadyFilled[0].add(leftFill[0]), rightInitial[0]);\n', '        rightFilledPercents[1] = rightInitial[1] == 0 ? PERCENTAGE_BASE : getDivisionPercentage(rightAlreadyFilled[1].add(leftFill[1]), rightInitial[1]);\n', '\n', '        filled[_rightOrderHash] = min(rightFilledPercents[0], rightFilledPercents[1]);\n', '    }\n', '\n', '    /// @notice Validate order properties and distribute tokens and margins\n', '    /// @param _leftOrder Order\n', '    /// @param leftFill uint256[2] Left order fillability\n', '    /// @param _rightOrder Order\n', '    /// @param rightFill uint256[2] Right order fillability\n', '    function _validateAndMakeSwap(Order memory _leftOrder, uint256[2] memory leftFill, Order memory _rightOrder, uint256[2] memory rightFill) private {\n', '        TokenMinter tm = TokenMinter(registry.getMinter());\n', '        TokenSpender tokenSpender = TokenSpender(registry.getTokenSpender());\n', '\n', '        // Transfer positions left -> right if needed\n', '        if (leftFill[0] != 0) {\n', '            require(_leftOrder.makerTokenId == _rightOrder.takerTokenId, "MATCH:NOT_VALID_SWAP");\n', '\n', '            require(tm.isApprovedOrOwner(address(tokenSpender), _leftOrder.makerAddress, _leftOrder.makerTokenId), "MATCH:NOT_ALLOWED_POSITION");\n', '            tokenSpender.claimPositions(tm, _leftOrder.makerAddress, _rightOrder.makerAddress, _leftOrder.makerTokenId, leftFill[0]);\n', '        }\n', '        \n', '        // Transfer positions right -> left if needed\n', '        if (rightFill[0] != 0) {\n', '            require(_leftOrder.takerTokenId == _rightOrder.makerTokenId, "MATCH:NOT_VALID_SWAP");\n', '\n', '            require(tm.isApprovedOrOwner(address(tokenSpender), _rightOrder.makerAddress, _rightOrder.makerTokenId), "MATCH:NOT_ALLOWED_POSITION");\n', '            tokenSpender.claimPositions(tm, _rightOrder.makerAddress, _leftOrder.makerAddress, _rightOrder.makerTokenId, rightFill[0]);\n', '        }\n', '\n', '        // Transfer margin left -> right if needed\n', '        if (leftFill[1] != 0) {\n', '            require(_leftOrder.makerMarginAddress == _rightOrder.takerMarginAddress, "MATCH:NOT_VALID_SWAP");\n', '\n', '            IERC20 makerMarginToken = IERC20(_leftOrder.makerMarginAddress);\n', '            require(makerMarginToken.allowance(_leftOrder.makerAddress, address(tokenSpender)) >= leftFill[1], "MATCH:NOT_ENOUGH_ALLOWED_MARGIN");\n', '            tokenSpender.claimTokens(makerMarginToken, _leftOrder.makerAddress, _rightOrder.makerAddress, leftFill[1]);\n', '        }\n', '\n', '        // Transfer margin right -> left if needed\n', '        if (rightFill[1] != 0) {\n', '            require(_leftOrder.takerMarginAddress == _rightOrder.makerMarginAddress, "MATCH:NOT_VALID_SWAP");\n', '\n', '            IERC20 takerMarginToken = IERC20(_leftOrder.takerMarginAddress);\n', '            require(takerMarginToken.allowance(_rightOrder.makerAddress, address(tokenSpender)) >= rightFill[1], "MATCH:NOT_ENOUGH_ALLOWED_MARGIN");\n', '            tokenSpender.claimTokens(takerMarginToken, _rightOrder.makerAddress, _leftOrder.makerAddress, rightFill[1]);\n', '        }\n', '\n', '        emit Swap(\n', '            _leftOrder.makerTokenId, leftFill[0],\n', '            _leftOrder.makerMarginAddress, leftFill[1],\n', '            _rightOrder.makerTokenId, rightFill[0],\n', '            _rightOrder.makerMarginAddress, rightFill[1]\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/Matching/Match/Match.sol\n', '\n', 'pragma solidity 0.5.16;\n', '\n', '\n', '\n', '/// @title Opium.Matching.Match contract combines Opium.Matching.MatchCreate and Opium.Matching.MatchSwap into one contract\n', 'contract Match is MatchCreate, MatchSwap {\n', '\n', '    /// @notice Calls constructors of super-contracts\n', '    /// @param _registry address Address of Opium.registry\n', '    constructor (address _registry) public UsingRegistry(_registry) {}\n', '}']