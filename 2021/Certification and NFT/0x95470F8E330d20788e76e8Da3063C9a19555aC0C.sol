['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-08\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '\n', 'contract MarketRegistry is Ownable {\n', '    \n', '    enum MarketType {Buy, Sell, Both}\n', '    enum CurrencySupported {Eth, Erc20}\n', '    \n', '    struct BuyDetails {\n', '        uint256 marketId;\n', '        bytes buyData;\n', '    }\n', '\n', '    struct SellDetails {\n', '        uint256 marketId;\n', '        bytes sellData;\n', '    }\n', '\n', '    struct Market {\n', '        MarketType marketType;\n', '        CurrencySupported currencySupported;\n', '        address proxy;\n', '        bool isActive;\n', '    }\n', '\n', '    Market[] public markets;\n', '\n', '    constructor(\n', '        MarketType[] memory marketTypes,\n', '        CurrencySupported[] memory currenciesSupported, \n', '        address[] memory proxies\n', '    ) {\n', '        for (uint256 i = 0; i < marketTypes.length; i++) {\n', '            markets.push(Market(marketTypes[i], currenciesSupported[i], proxies[i], true));    \n', '        }\n', '    }\n', '\n', '    function addMarket(\n', '        MarketType marketType, \n', '        CurrencySupported currencySupported, \n', '        address proxy\n', '    ) external onlyOwner {\n', '        markets.push(Market(marketType, currencySupported, proxy, true));\n', '    }\n', '\n', '    function setMarketStatus(uint256 marketId, bool newStatus) external onlyOwner {\n', '        Market storage market = markets[marketId];\n', '        market.isActive = newStatus;\n', '    }\n', '\n', '    function setMarketProxy(uint256 marketId, address newProxy) external onlyOwner {\n', '        Market storage market = markets[marketId];\n', '        market.proxy = newProxy;\n', '    }\n', '}\n', '\n', 'contract ExchangeRegistry is Ownable {\n', '    \n', '    struct SwapDetails {\n', '        uint256 exchangeId;\n', '        bytes swapData; \n', '    }\n', '\n', '    struct Exchange {\n', '        address proxy;\n', '        bool isActive;\n', '    }\n', '\n', '    Exchange[] public exchanges;\n', '\n', '    constructor(address[] memory proxies) {\n', '        for (uint256 i = 0; i < proxies.length; i++) {\n', '            exchanges.push(Exchange(proxies[i], true));\n', '        }\n', '    }\n', '\n', '    function addExchange(\n', '        address proxy\n', '    ) external onlyOwner {\n', '        exchanges.push(Exchange(proxy, true));\n', '    }\n', '\n', '    function setExchangeStatus(uint256 exchangeId, bool newStatus) external onlyOwner {\n', '        Exchange storage exchange = exchanges[exchangeId];\n', '        exchange.isActive = newStatus;\n', '    }\n', '\n', '    function setExchangeProxy(uint256 exchangeId, address newProxy) external onlyOwner {\n', '        Exchange storage exchange = exchanges[exchangeId];\n', '        exchange.proxy = newProxy;\n', '    }\n', '\n', '}\n', '\n', 'interface IERC20 {\n', '    /**\n', '        * @dev Returns the amount of tokens owned by `account`.\n', '        */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "        * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '        *\n', '        * Returns a boolean value indicating whether the operation succeeded.\n', '        *\n', '        * Emits a {Transfer} event.\n', '        */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IERC721 {\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\n', '    \n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    function approve(address to, uint256 tokenId) external;\n', '    \n', '    function isApprovedForAll(address owner, address operator) external returns (bool);\n', '}\n', '\n', 'interface IERC1155 {\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 id,\n', '        uint256 amount,\n', '        bytes memory data\n', '    ) external;\n', '\n', '    function safeBatchTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256[] memory ids,\n', '        uint256[] memory amounts,\n', '        bytes memory data\n', '    ) external;\n', '}\n', '\n', 'interface ISellMarket {\n', '    function sellERC721ForERC20Equivalent(\n', '        bytes memory data\n', '    ) external returns (address _erc20Address, uint256 _erc20Amount);\n', '\n', '    function sellERC1155ForERC20Equivalent(\n', '        bytes memory data\n', '    ) external returns (address erc20, uint256 amount);\n', '\n', '    function sellERC1155BatchForERC20Equivalent(\n', '        bytes memory data\n', '    ) external returns (address erc20, uint256 amount);\n', '}\n', '\n', 'interface IBuyMarket {\n', '    function buyAssetsForEth(bytes memory data, address recipient) external;\n', '    function buyAssetsForErc20(bytes memory data, address recipient) external;\n', '    function estimateBatchAssetPriceInEth(bytes memory data) external view returns(uint256 totalCost);\n', '    function estimateBatchAssetPriceInErc20(bytes memory data) external view returns(address[] memory erc20Addrs, uint256[] memory amounts);\n', '}\n', '\n', 'interface IExchange {\n', '    function swapExactERC20ForERC20(\n', '        address _from,\n', '        address _to,\n', '        address _recipient,\n', '        uint256 _amountIn\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapERC20ForExactERC20(\n', '        address _from,\n', '        address _to,\n', '        address _recipient,\n', '        uint256 _amountOut\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapERC20ForExactETH(\n', '        address _from,\n', '        address _recipient,\n', '        uint256 _amountOut\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactERC20ForETH(\n', '        address _from,\n', '        address _recipient,\n', '        uint256 _amountIn\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactERC20(\n', '        address _to,\n', '        address _recipient,\n', '        uint256 _amountOut\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForERC20(\n', '        address _to,\n', '        address _recipient,\n', '        uint256 _amountOutMin\n', '    ) external returns (uint256[] memory amounts);\n', '}\n', '\n', 'contract CrossAssetSwap is Ownable {\n', '\n', '    struct ERC20Details {\n', '        address[] tokenAddrs;\n', '        uint256[] amounts;\n', '    }\n', '\n', '    struct ERC721Details {\n', '        address tokenAddr;\n', '        uint256[] ids;\n', '        MarketRegistry.SellDetails[] sellDetails;\n', '    }\n', '\n', '    struct ERC1155Details {\n', '        address tokenAddr;\n', '        uint256[] ids;\n', '        uint256[] amounts;\n', '        MarketRegistry.SellDetails[] sellDetails;\n', '    }\n', '\n', '    MarketRegistry public marketRegistry;\n', '    ExchangeRegistry public exchangeRegistry;\n', '    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    address public constant MAINTAINER = 0x073Ab1C0CAd3677cDe9BDb0cDEEDC2085c029579;\n', '    uint256 public FEES = 300;\n', '\n', '    constructor(address _marketRegistry, address _exchangeRegistry) {\n', '        marketRegistry = MarketRegistry(_marketRegistry);\n', '        exchangeRegistry = ExchangeRegistry(_exchangeRegistry);\n', '    }\n', '\n', '    function updateFees(uint256 newFees) external {\n', '        require(msg.sender == MAINTAINER, "updateFees: invalid caller.");\n', '        FEES = newFees;\n', '    }\n', '\n', '    function _transferHelper(\n', '        ERC20Details memory _inputERC20s,\n', '        ERC721Details[] memory inputERC721s,\n', '        ERC1155Details[] memory inputERC1155s\n', '    ) internal returns (address[] memory _erc20AddrsIn, uint256[] memory _erc20AmountsIn) {\n', '        address[] memory _addrsIn1;\n', '        address[] memory _addrsIn2; \n', '        uint256[] memory _amountsIn1;\n', '        uint256[] memory _amountsIn2;\n', '\n', '        // transfer ERC20 tokens from the sender to this contract\n', '        for (uint256 i = 0; i < _inputERC20s.tokenAddrs.length; i++) {\n', '            require(\n', '                IERC20(_inputERC20s.tokenAddrs[i]).transferFrom(\n', '                    msg.sender,\n', '                    address(this),\n', '                    _inputERC20s.amounts[i]\n', '                ),\n', '                "_transferHelper: transfer failed"\n', '            );\n', '        }\n', '        // transfer ERC721 tokens from the sender to this contract\n', '        for (uint256 i = 0; i < inputERC721s.length; i++) {\n', '            for (uint256 j = 0; j < inputERC721s[i].ids.length; j++) {\n', '                IERC721(inputERC721s[i].tokenAddr).transferFrom(\n', '                    msg.sender,\n', '                    address(this),\n', '                    inputERC721s[i].ids[j]\n', '                );\n', '            }\n', '            (_addrsIn1, _amountsIn1) = _sellNFT(inputERC721s[i].sellDetails);\n', '        }\n', '        // transfer ERC1155 tokens from the sender to this contract\n', '        for (uint256 i = 0; i < inputERC1155s.length; i++) {\n', '            IERC1155(inputERC1155s[i].tokenAddr).safeBatchTransferFrom(\n', '                msg.sender,\n', '                address(this),\n', '                inputERC1155s[i].ids,\n', '                inputERC1155s[i].amounts,\n', '                ""\n', '            );\n', '            (_addrsIn2, _amountsIn2) = _sellNFT(inputERC1155s[i].sellDetails);\n', '        }\n', '        // return _erc20AddrsIn, _erc20AmountsIn\n', '        {\n', '            uint256 totalLen = msg.value > 0 \n', '            ? _inputERC20s.tokenAddrs.length+_addrsIn1.length+_addrsIn2.length+1\n', '            : _inputERC20s.tokenAddrs.length+_addrsIn1.length+_addrsIn2.length;\n', '            _erc20AddrsIn = new address[](totalLen);\n', '            _erc20AmountsIn = new uint256[](totalLen);\n', '            if (msg.value > 0) {\n', '                _erc20AddrsIn[totalLen-1] = ETH; \n', '                _erc20AmountsIn[totalLen-1] = msg.value;\n', '            }\n', '            // populate the arrays\n', '            for (uint256 i = 0; i < _inputERC20s.tokenAddrs.length; i++) {\n', '                _erc20AddrsIn[i] = _inputERC20s.tokenAddrs[i];\n', '                _erc20AmountsIn[i] = _inputERC20s.amounts[i];\n', '            }\n', '\n', '            totalLen = _inputERC20s.tokenAddrs.length-1;\n', '            for (uint256 i = 0; i < _addrsIn1.length; i++) {\n', '                _erc20AddrsIn[_inputERC20s.tokenAddrs.length+i] = _addrsIn1[i];\n', '                _erc20AmountsIn[_inputERC20s.tokenAddrs.length+i] = _amountsIn1[i];\n', '            }\n', '\n', '            totalLen = _inputERC20s.tokenAddrs.length+_addrsIn1.length-1;\n', '            for (uint256 i = 0; i < _addrsIn2.length; i++) {\n', '                _erc20AddrsIn[totalLen+i] = _addrsIn2[i];\n', '                _erc20AmountsIn[totalLen+i] = _amountsIn2[i];\n', '            }\n', '        }\n', '    }\n', '\n', '    // swaps any combination of ERC-20/721/1155\n', '    // User needs to approve assets before invoking swap\n', '    function multiAssetSwap(\n', '        ERC20Details memory inputERC20s,\n', '        ERC721Details[] memory inputERC721s,\n', '        ERC1155Details[] memory inputERC1155s,\n', '        MarketRegistry.BuyDetails[] memory buyDetails,\n', '        ExchangeRegistry.SwapDetails[] memory swapDetails,\n', '        address[] memory addrs // [changeIn, exchange, recipient]\n', '    ) payable external {\n', '        address[] memory _erc20AddrsIn;\n', '        uint256[] memory _erc20AmountsIn;\n', '        \n', '        // transfer all tokens\n', '        (_erc20AddrsIn, _erc20AmountsIn) = _transferHelper(\n', '            inputERC20s,\n', '            inputERC721s,\n', '            inputERC1155s\n', '        );\n', '\n', '        // execute all swaps\n', '        _swap(\n', '            swapDetails,\n', '            buyDetails,\n', '            _erc20AmountsIn,\n', '            _erc20AddrsIn,\n', '            addrs[0],\n', '            addrs[1],\n', '            addrs[2]\n', '        );\n', '    }\n', '    event Data(ERC721Details[]);\n', '    function buyNftForERC20(\n', '        MarketRegistry.BuyDetails[] memory buyDetails,\n', '        ExchangeRegistry.SwapDetails[] memory swapDetails,\n', '        ERC20Details memory inputErc20Details,\n', '        address[] memory addrs // [changeIn, exchange, recipient]\n', '    ) external {\n', '        // transfer the fees\n', '        require(\n', '            IERC20(inputErc20Details.tokenAddrs[0]).transferFrom(msg.sender, MAINTAINER, FEES*inputErc20Details.amounts[0]/10000),\n', '            "buyNftForERC20: fees transfer failed"\n', '        );\n', '        // transfer the inputErc20 to the contract\n', '        require(\n', '            IERC20(inputErc20Details.tokenAddrs[0]).transferFrom(msg.sender, address(this), (10000-FEES)*inputErc20Details.amounts[0]/10000),\n', '            "buyNftForERC20: transfer failed"\n', '        );\n', '        // swap to desired assets if needed\n', '        for (uint256 i=0; i < swapDetails.length; i++) {\n', '            (address proxy, ) = exchangeRegistry.exchanges(swapDetails[i].exchangeId);\n', '            (bool success, ) = proxy.delegatecall(swapDetails[i].swapData);\n', '            require(success, "buyNftForERC20: swap failed.");\n', '        }\n', '\n', '        // buy NFTs\n', '        _buyNFT(buyDetails);\n', '\n', '        // Note: We know it as a fact that only input ERC20 can be the dust asset\n', '        // return remaining input ERC20\n', '        if(addrs[0] == inputErc20Details.tokenAddrs[0]) {\n', '            IERC20(inputErc20Details.tokenAddrs[0]).transfer(msg.sender, IERC20(inputErc20Details.tokenAddrs[0]).balanceOf(address(this)));\n', '        }\n', '        // return remaining ETH\n', '        else if(addrs[0] == ETH) {\n', '            (bool success, ) = addrs[1].delegatecall(abi.encodeWithSignature("swapExactERC20ForETH(address,address,uint256)", inputErc20Details.tokenAddrs[0], addrs[2], IERC20(inputErc20Details.tokenAddrs[0]).balanceOf(address(this))));\n', '            require(success, "buyNftForERC20: return failed.");\n', '        }\n', '        // return remaining ERC20\n', '        else {\n', '            (bool success, ) = addrs[1].delegatecall(abi.encodeWithSignature("swapExactERC20ForERC20(address,address,address,uint256)", inputErc20Details.tokenAddrs[0], addrs[0], addrs[2], IERC20(inputErc20Details.tokenAddrs[0]).balanceOf(address(this))));\n', '            require(success, "buyNftForERC20: return failed.");\n', '        }\n', '    }\n', '\n', '    function buyNftForEth(\n', '        MarketRegistry.BuyDetails[] memory buyDetails,\n', '        ExchangeRegistry.SwapDetails[] memory swapDetails,\n', '        address[] memory addrs // [changeIn, exchange, recipient]\n', '    ) external payable {\n', '        bool success;\n', "        (success, ) = MAINTAINER.call{value:FEES*address(this).balance/10000}('');\n", '        require(success, "buyNftForEth: fees failed.");\n', '\n', '        // swap to desired assets if needed\n', '        for (uint256 i=0; i < swapDetails.length; i++) {\n', '            (address proxy, ) = exchangeRegistry.exchanges(swapDetails[i].exchangeId);\n', '            (success, ) = proxy.delegatecall(swapDetails[i].swapData);\n', '            require(success, "buyNftForEth: swap failed.");\n', '        }\n', '\n', '        // buy NFT\n', '        _buyNFT(buyDetails);\n', '\n', '        // Note: We know it as a fact that only Eth can be the dust asset\n', '        // return remaining ETH\n', '        if(addrs[0] == ETH) {\n', "            (success, ) = msg.sender.call{value:address(this).balance}('');\n", '            require(success, "buyNftForEth: return failed.");\n', '        }\n', '        // return remaining ERC20\n', '        else {\n', '            (success, ) = addrs[1].delegatecall(abi.encodeWithSignature("swapExactETHForERC20(address,address,uint256)", addrs[0], addrs[2], 0));\n', '            require(success, "buyNftForEth: return failed.");\n', '        }\n', '    }\n', '\n', '    function _sellNFT(\n', '        MarketRegistry.SellDetails[] memory _sellDetails\n', '    ) internal returns(address[] memory erc20Addrs, uint256[] memory erc20Amounts) {\n', '        erc20Addrs = new address[](_sellDetails.length);\n', '        erc20Amounts = new uint256[](_sellDetails.length);\n', '\n', '        // sell ERC1155 assets to respective markets\n', '        for (uint256 i = 0; i < _sellDetails.length; i++) {\n', '            // fetch the market details\n', '            (, , address _proxy, bool _isActive) = marketRegistry.markets(_sellDetails[i].marketId);\n', '            // the market should be active \n', '            require(_isActive, "_sellNFT: InActive Market");\n', '            // sell the specified asset\n', '            (bool success, bytes memory data) = _proxy.delegatecall(_sellDetails[i].sellData);\n', '            // check if the delegatecall passed successfully\n', '            require(success, "_sellNFT: sell failed.");\n', '            // populate return values            \n', '            (erc20Addrs[i], erc20Amounts[i]) = abi.decode(\n', '                data,\n', '                (address, uint256)\n', '            );\n', '        }\n', '    }\n', '\n', '    function _buyNFT(\n', '        MarketRegistry.BuyDetails[] memory _buyDetails\n', '    ) internal {\n', '        for (uint256 i = 0; i < _buyDetails.length; i++) {\n', '            // get market details\n', '            (, , address _proxy, bool _isActive) = marketRegistry.markets(_buyDetails[i].marketId);\n', '            // market should be active\n', '            require(_isActive, "function: InActive Market");\n', '            // buy NFT with ETH or ERC20\n', '            (bool success, ) = _proxy.delegatecall(_buyDetails[i].buyData);\n', '            // check if the delegatecall passed successfully\n', '            require(success, "_buyNFT: buy failed.");\n', '        }\n', '    }\n', '\n', '    function _returnChange(\n', '        address _changeIn,\n', '        address _erc20AddrIn,\n', '        address _recipient,\n', '        address _proxy,\n', '        uint256 _erc20AmountIn\n', '    ) internal {\n', '        bool success;\n', '        // in case desired changeIn is NOT the equivalent ERC20\n', '        if (_changeIn != _erc20AddrIn) {\n', '            // get market address\n', '            // (address proxy, ) = exchangeRegistry.exchanges(_exchangeId);\n', '            // in case input asset is ETH\n', '            if(_erc20AddrIn == ETH) {\n', '                (success, ) = _proxy.delegatecall(abi.encodeWithSignature("swapExactETHForERC20(address,address,uint256)", _changeIn, _recipient, 0));\n', '                require(success, "_returnChange: return failed.");\n', '            }\n', '            // in case changeIn is ETH\n', '            else if(_changeIn == ETH) {\n', '                // Convert all the _erc20Amount to _changeIn ERC20\n', '                (success, ) = _proxy.delegatecall(abi.encodeWithSignature("swapExactERC20ForETH(address,address,uint256)", _erc20AddrIn, _recipient, _erc20AmountIn));\n', '                require(success, "_returnChange: return failed.");\n', '            }\n', '            // in case changeIn is some other ERC20\n', '            else {\n', '                // execute exchange\n', '                (success, ) = _proxy.delegatecall(abi.encodeWithSignature("swapExactERC20ForERC20(address,address,address,uint256)", _erc20AddrIn, _changeIn, _recipient, _erc20AmountIn));\n', '                require(success, "_returnChange: return failed.");\n', '            }\n', '        }\n', '        // in case desired changeIn is the equivalent ERC20\n', '        else {\n', '            IERC20(_changeIn).transfer(_recipient, _erc20AmountIn);\n', '        }\n', '    }\n', '\n', '    function _swap(\n', '        ExchangeRegistry.SwapDetails[] memory _swapDetails,\n', '        MarketRegistry.BuyDetails[] memory _buyDetails,\n', '        uint256[] memory _erc20AmountsIn,\n', '        address[] memory _erc20AddrsIn,\n', '        address _changeIn,\n', '        address _exchange,\n', '        address _recipient\n', '    ) internal {\n', '        bool success;\n', '        // in case user does NOT want to buy any NFTs \n', '        if(_buyDetails.length == 0) {\n', '            for(uint256 i = 0; i < _erc20AddrsIn.length; i++) {\n', '                _returnChange(\n', '                    _changeIn,\n', '                    _erc20AddrsIn[i],\n', '                    _recipient,\n', '                    _exchange,\n', '                    _erc20AmountsIn[i]\n', '                );\n', '            }\n', '        }\n', '        // in case user wants to buy NFTs\n', '        else {\n', '            for (uint256 i = 0; i < _swapDetails.length; i++) {\n', '                // get market address\n', '                (address proxy, ) = exchangeRegistry.exchanges(_swapDetails[i].exchangeId);\n', '                // execute swap \n', '                (success, ) = proxy.delegatecall(_swapDetails[i].swapData);\n', '                require(success, "_swap: swap failed.");\n', '            }\n', '\n', '            // buy the NFTs\n', '            _buyNFT(_buyDetails);\n', '\n', '            // return remaining amount to the user\n', '            for (uint256 i = 0; i < _erc20AddrsIn.length; i++) {\n', '                _returnChange(\n', '                    _changeIn,\n', '                    _erc20AddrsIn[i],\n', '                    _recipient,\n', '                    _exchange,\n', '                    _erc20AddrsIn[i] == ETH \n', '                        ? address(this).balance\n', '                        : IERC20(_erc20AddrsIn[i]).balanceOf(address(this))\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    function _executeSingleTrxSwap(\n', '        bytes memory _data,\n', '        address _from\n', '    ) internal {\n', '        // decode the trade details\n', '        MarketRegistry.SellDetails[] memory _sellDetails;\n', '        ExchangeRegistry.SwapDetails[] memory _swapDetails;\n', '        MarketRegistry.BuyDetails[] memory _buyDetails;\n', '        address[] memory addrs; // [changeIn, exchange, recipient]\n', '\n', '        (_sellDetails, _swapDetails, _buyDetails, addrs) = abi.decode(\n', '            _data,\n', '            (MarketRegistry.SellDetails[], ExchangeRegistry.SwapDetails[], MarketRegistry.BuyDetails[], address[])\n', '        );\n', '\n', '        // _sellDetails should not be empty\n', '        require(_sellDetails.length > 0, "_executeSingleTrxSwap: no sell details");\n', '\n', '        // if recipient is zero address, then set _from as recipient\n', '        if(addrs[2] == address(0)) {\n', '            addrs[2] = _from;\n', '        }\n', '\n', '        // sell input assets\n', '        (address[] memory _erc20AddrsIn, uint256[] memory _erc20AmountsIn) = _sellNFT(_sellDetails);\n', '        \n', '        // swap ERC20 equivalents to desired intermediate assets\n', '        _swap(_swapDetails, _buyDetails, _erc20AmountsIn, _erc20AddrsIn, addrs[0], addrs[1], addrs[2]);\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address,\n', '        address,\n', '        uint256,\n', '        uint256,\n', '        bytes calldata\n', '    ) public virtual returns (bytes4) {\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(\n', '        address,\n', '        address _from,\n', '        uint256[] calldata,\n', '        uint256[] calldata,\n', '        bytes calldata _data\n', '    ) public virtual returns (bytes4) {\n', '        // return with function selector if data is empty\n', '        if(keccak256(abi.encodePacked((_data))) == keccak256(abi.encodePacked(("")))) {\n', '            return this.onERC1155BatchReceived.selector;\n', '        }\n', '        \n', '        // execute single transaction swap\n', '        _executeSingleTrxSwap(_data, _from);\n', '\n', '        // return the function selector\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '\n', '\n', '    function onERC721Received(\n', '        address,\n', '        address _from,\n', '        uint256 _tokenId,\n', '        bytes calldata _data\n', '    ) external virtual returns (bytes4) {\n', '        // return with function selector if data is empty        \n', '        if(keccak256(abi.encodePacked((_data))) == keccak256(abi.encodePacked(("")))) {\n', '            return this.onERC721Received.selector;\n', '        }\n', '\n', '        // execute single transaction swap\n', '        _executeSingleTrxSwap(_data, _from);\n', '\n', '        return this.onERC721Received.selector;\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceId)\n', '        external\n', '        virtual\n', '        view\n', '        returns (bool)\n', '    {\n', '        return interfaceId == this.supportsInterface.selector;\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    // Emergency function: In case any ERC20 tokens get stuck in the contract unintentionally\n', '    // Only owner can retrieve the asset balance to a recipient address\n', '    function rescueERC20(address asset, address recipient) onlyOwner external returns(uint256 amountRescued) {\n', '        amountRescued = IERC20(asset).balanceOf(address(this)); \n', '        IERC20(asset).transfer(recipient, amountRescued);\n', '    }\n', '\n', '    // Emergency function: In case any ERC721 tokens get stuck in the contract unintentionally\n', '    // Only owner can retrieve the asset balance to a recipient address\n', '    function rescueERC721(address asset, uint256[] calldata ids, address recipient) onlyOwner external {\n', '        for (uint256 i = 0; i < ids.length; i++) {\n', '            IERC721(asset).transferFrom(address(this), recipient, ids[i]);\n', '        }\n', '    }\n', '\n', '    // Emergency function: In case any ERC1155 tokens get stuck in the contract unintentionally\n', '    // Only owner can retrieve the asset balance to a recipient address\n', '    function rescueERC1155(address asset, uint256[] calldata ids, uint256[] calldata amounts, address recipient) onlyOwner external {\n', '        for (uint256 i = 0; i < ids.length; i++) {\n', '            IERC1155(asset).safeTransferFrom(address(this), recipient, ids[i], amounts[i], "");\n', '        }\n', '    }\n', '}']