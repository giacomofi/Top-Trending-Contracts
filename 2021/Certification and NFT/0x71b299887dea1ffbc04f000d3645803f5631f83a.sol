['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.4;\n', '\n', 'import "./DividendPayingToken.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IterableMapping.sol";\n', 'import "./Ownable.sol";\n', '\n', 'contract GODLDividendTracker is DividendPayingToken, Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeMathInt for int256;\n', '    using IterableMapping for IterableMapping.Map;\n', '\n', '    IterableMapping.Map private tokenHoldersMap;\n', '    uint256 public lastProcessedIndex;\n', '\n', '    mapping (address => bool) public excludedFromDividends;\n', '\n', '    mapping (address => uint256) public lastClaimTimes;\n', '\n', '    uint256 public claimWait;\n', '    uint256 public constant MIN_TOKEN_BALANCE_FOR_DIVIDENDS = 10000 * (10**18); // Must hold 10000+ tokens.\n', '\n', '    event ExcludedFromDividends(address indexed account);\n', '    event GasForTransferUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n', '    event ClaimWaitUpdated(uint256 indexed newValue, uint256 indexed oldValue);\n', '\n', '    event Claim(address indexed account, uint256 amount, bool indexed automatic);\n', '\n', '    constructor() DividendPayingToken("GODL_Dividend_Tracker", "GODL_Dividend_Tracker") {\n', '        claimWait = 3600;\n', '    }\n', '\n', '    function _transfer(address, address, uint256) internal pure override {\n', '        require(false, "GODL_Dividend_Tracker: No transfers allowed");\n', '    }\n', '\n', '    function withdrawDividend() public pure override {\n', '        require(false, "GODL_Dividend_Tracker: withdrawDividend disabled. Use the \'claim\' function on the main GODL contract.");\n', '    }\n', '\n', '    function excludeFromDividends(address account) external onlyOwner {\n', '        require(!excludedFromDividends[account]);\n', '        excludedFromDividends[account] = true;\n', '\n', '        _setBalance(account, 0);\n', '        tokenHoldersMap.remove(account);\n', '\n', '        emit ExcludedFromDividends(account);\n', '    }\n', '\n', '    function updateGasForTransfer(uint256 newGasForTransfer) external onlyOwner {\n', '        require(newGasForTransfer != gasForTransfer, "GODL_Dividend_Tracker: Cannot update gasForTransfer to same value");\n', '        emit GasForTransferUpdated(newGasForTransfer, gasForTransfer);\n', '        gasForTransfer = newGasForTransfer;\n', '    }\n', '\n', '    function updateClaimWait(uint256 newClaimWait) external onlyOwner {\n', '        require(newClaimWait >= 3600 && newClaimWait <= 86400, "GODL_Dividend_Tracker: claimWait must be updated to between 1 and 24 hours");\n', '        require(newClaimWait != claimWait, "GODL_Dividend_Tracker: Cannot update claimWait to same value");\n', '        emit ClaimWaitUpdated(newClaimWait, claimWait);\n', '        claimWait = newClaimWait;\n', '    }\n', '\n', '    function getLastProcessedIndex() external view returns(uint256) {\n', '        return lastProcessedIndex;\n', '    }\n', '\n', '    function getNumberOfTokenHolders() external view returns(uint256) {\n', '        return tokenHoldersMap.keys.length;\n', '    }\n', '\n', '    function getAccount(address _account)\n', '    public view returns (\n', '        address account,\n', '        int256 index,\n', '        int256 iterationsUntilProcessed,\n', '        uint256 withdrawableDividends,\n', '        uint256 totalDividends,\n', '        uint256 lastClaimTime,\n', '        uint256 nextClaimTime,\n', '        uint256 secondsUntilAutoClaimAvailable) {\n', '        account = _account;\n', '\n', '        index = tokenHoldersMap.getIndexOfKey(account);\n', '\n', '        iterationsUntilProcessed = -1;\n', '\n', '        if (index >= 0) {\n', '            if (uint256(index) > lastProcessedIndex) {\n', '                iterationsUntilProcessed = index.sub(int256(lastProcessedIndex));\n', '            } else {\n', '                uint256 processesUntilEndOfArray = tokenHoldersMap.keys.length > lastProcessedIndex ? tokenHoldersMap.keys.length.sub(lastProcessedIndex) : 0;\n', '                iterationsUntilProcessed = index.add(int256(processesUntilEndOfArray));\n', '            }\n', '        }\n', '\n', '        withdrawableDividends = withdrawableDividendOf(account);\n', '        totalDividends = accumulativeDividendOf(account);\n', '\n', '        lastClaimTime = lastClaimTimes[account];\n', '        nextClaimTime = lastClaimTime > 0 ? lastClaimTime.add(claimWait) : 0;\n', '        secondsUntilAutoClaimAvailable = nextClaimTime > block.timestamp ? nextClaimTime.sub(block.timestamp) : 0;\n', '    }\n', '\n', '    function getAccountAtIndex(uint256 index)\n', '    public view returns (\n', '        address,\n', '        int256,\n', '        int256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256,\n', '        uint256) {\n', '        if (index >= tokenHoldersMap.size()) {\n', '            return (0x0000000000000000000000000000000000000000, -1, -1, 0, 0, 0, 0, 0);\n', '        }\n', '\n', '        address account = tokenHoldersMap.getKeyAtIndex(index);\n', '        return getAccount(account);\n', '    }\n', '\n', '    function canAutoClaim(uint256 lastClaimTime) private view returns (bool) {\n', '        if (lastClaimTime > block.timestamp)  {\n', '            return false;\n', '        }\n', '        return block.timestamp.sub(lastClaimTime) >= claimWait;\n', '    }\n', '\n', '    function setBalance(address payable account, uint256 newBalance) external onlyOwner {\n', '        if (excludedFromDividends[account]) {\n', '            return;\n', '        }\n', '\n', '        if (newBalance >= MIN_TOKEN_BALANCE_FOR_DIVIDENDS) {\n', '            _setBalance(account, newBalance);\n', '            tokenHoldersMap.set(account, newBalance);\n', '        } else {\n', '            _setBalance(account, 0);\n', '            tokenHoldersMap.remove(account);\n', '        }\n', '\n', '        processAccount(account, true);\n', '    }\n', '\n', '    function process(uint256 gas) public returns (uint256, uint256, uint256) {\n', '        uint256 numberOfTokenHolders = tokenHoldersMap.keys.length;\n', '\n', '        if (numberOfTokenHolders == 0) {\n', '            return (0, 0, lastProcessedIndex);\n', '        }\n', '\n', '        uint256 _lastProcessedIndex = lastProcessedIndex;\n', '\n', '        uint256 gasUsed = 0;\n', '        uint256 gasLeft = gasleft();\n', '\n', '        uint256 iterations = 0;\n', '        uint256 claims = 0;\n', '\n', '        while (gasUsed < gas && iterations < numberOfTokenHolders) {\n', '            _lastProcessedIndex++;\n', '\n', '            if (_lastProcessedIndex >= tokenHoldersMap.keys.length) {\n', '                _lastProcessedIndex = 0;\n', '            }\n', '\n', '            address account = tokenHoldersMap.keys[_lastProcessedIndex];\n', '\n', '            if (canAutoClaim(lastClaimTimes[account])) {\n', '                if (processAccount(payable(account), true)) {\n', '                    claims++;\n', '                }\n', '            }\n', '\n', '            iterations++;\n', '\n', '            uint256 newGasLeft = gasleft();\n', '\n', '            if (gasLeft > newGasLeft) {\n', '                gasUsed = gasUsed.add(gasLeft.sub(newGasLeft));\n', '            }\n', '\n', '            gasLeft = newGasLeft;\n', '        }\n', '\n', '        lastProcessedIndex = _lastProcessedIndex;\n', '\n', '        return (iterations, claims, lastProcessedIndex);\n', '    }\n', '\n', '    function processAccount(address payable account, bool automatic) public onlyOwner returns (bool) {\n', '        uint256 amount = _withdrawDividendOfUser(account);\n', '\n', '        if (amount > 0) {\n', '            lastClaimTimes[account] = block.timestamp;\n', '            emit Claim(account, amount, automatic);\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '}']