['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-11\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev The contract has an owner address, and provides basic authorization control whitch\n', ' * simplifies the implementation of user permissions. This contract is based on the source code at:\n', ' * https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/ownership/Ownable.sol\n', ' */\n', 'contract Ownable\n', '{\n', '\n', '  /**\n', '   * @dev Error constants.\n', '   */\n', '  string public constant NOT_CURRENT_OWNER = "018001";\n', '  string public constant CANNOT_TRANSFER_TO_ZERO_ADDRESS = "018002";\n', '\n', '  /**\n', '   * @dev Current owner address.\n', '   */\n', '  address public owner;\n', '\n', '  /**\n', '   * @dev An event which is triggered when the owner is changed.\n', '   * @param previousOwner The address of the previous owner.\n', '   * @param newOwner The address of the new owner.\n', '   */\n', '  event OwnershipTransferred(\n', '    address indexed previousOwner,\n', '    address indexed newOwner\n', '  );\n', '\n', '  /**\n', '   * @dev The constructor sets the original `owner` of the contract to the sender account.\n', '   */\n', '  constructor()\n', '  {\n', '    owner = msg.sender;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner()\n', '  {\n', '    require(msg.sender == owner, NOT_CURRENT_OWNER);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '   * @param _newOwner The address to transfer ownership to.\n', '   */\n', '  function transferOwnership(\n', '    address _newOwner\n', '  )\n', '    public\n', '    onlyOwner\n', '  {\n', '    require(_newOwner != address(0), CANNOT_TRANSFER_TO_ZERO_ADDRESS);\n', '    emit OwnershipTransferred(owner, _newOwner);\n', '    owner = _newOwner;\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev Optional enumeration extension for ERC-721 non-fungible token standard.\n', ' * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n', ' */\n', 'interface ERC721Enumerable\n', '{\n', '\n', '  /**\n', '   * @dev Returns a count of valid NFTs tracked by this contract, where each one of them has an\n', '   * assigned and queryable owner not equal to the zero address.\n', '   * @return Total supply of NFTs.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT. Sort order is not specified.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   * @return Token id.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the token identifier for the `_index`th NFT assigned to `_owner`. Sort order is\n', '   * not specified. It throws if `_index` >= `balanceOf(_owner)` or if `_owner` is the zero address,\n', '   * representing invalid NFTs.\n', '   * @param _owner An address where we are interested in NFTs owned by them.\n', '   * @param _index A counter less than `balanceOf(_owner)`.\n', '   * @return Token id.\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '}\n', '\n', '/**\n', ' * @dev Optional metadata extension for ERC-721 non-fungible token standard.\n', ' * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n', ' */\n', 'interface ERC721Metadata\n', '{\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTs in this contract.\n', '   * @return _name Representing name.\n', '   */\n', '  function name()\n', '    external\n', '    view\n', '    returns (string memory _name);\n', '\n', ' /**\n', '   * @dev Returns a URI for a collection of NFTs in th\n', '   * \n', '   * \n', '   * \n', '   * \n', '   * is contract.\n', '   * @return _nftURI Representing contractURI.\n', '   */\n', '  function contractURI()\n', '    external\n', '    view\n', '    returns (string memory _nftURI);\n', '\n', '  /**\n', '   * @dev Returns a abbreviated name for a collection of NFTs in this contract.\n', '   * @return _symbol Representing symbol.\n', '   */\n', '  function symbol()\n', '    external\n', '    view\n', '    returns (string memory _symbol);\n', '\n', '  /**\n', '   * @dev Returns a distinct Uniform Resource Identifier (URI) for a given asset. It Throws if\n', '   * `_tokenId` is not a valid NFT. URIs are defined in RFC3986. The URI may point to a JSON file\n', '   * that conforms to the "ERC721 Metadata JSON Schema".\n', '   * @return URI of _tokenId.\n', '   */\n', '  function tokenURI(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (string memory);\n', '    \n', '  /**\n', '   * @dev Returns redeemed value for a given asset. It Throws if\n', '   * `_tokenId` is not a valid NFT. \n', '   * @return redeemed flag of _tokenId.\n', '   */\n', '  function tokenRedeemable(uint256 _tokenId)\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev ERC-721 interface for accepting safe transfers.\n', ' * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n', ' */\n', 'interface ERC721TokenReceiver\n', '{\n', '\n', '  /**\n', '   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\n', '   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\n', '   * of other than the magic value MUST result in the transaction being reverted.\n', '   * Returns `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))` unless throwing.\n', '   * @notice The contract address is always the message sender. A wallet/broker/auction application\n', '   * MUST implement the wallet interface if it will accept safe transfers.\n', '   * @param _operator The address which called `safeTransferFrom` function.\n', '   * @param _from The address which previously owned the token.\n', '   * @param _tokenId The NFT identifier which is being transferred.\n', '   * @param _data Additional data with no specified format.\n', '   * @return Returns `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.\n', '   */\n', '  function onERC721Received(\n', '    address _operator,\n', '    address _from,\n', '    uint256 _tokenId,\n', '    bytes calldata _data\n', '  )\n', '    external\n', '    returns(bytes4);\n', '\n', '}\n', '\n', '/**\n', ' * @dev Utility library of inline functions on addresses.\n', ' * @notice Based on:\n', ' * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\n', ' * Requires EIP-1052.\n', ' */\n', 'library AddressUtils\n', '{\n', '\n', '  /**\n', '   * @dev Returns whether the target address is a contract.\n', '   * @param _addr Address to check.\n', '   * @return addressCheck True if _addr is a contract, false if not.\n', '   */\n', '  function isContract(\n', '    address _addr\n', '  )\n', '    internal\n', '    view\n', '    returns (bool addressCheck)\n', '  {\n', '    // This method relies in extcodesize, which returns 0 for contracts in\n', '    // construction, since the code is only stored at the end of the\n', '    // constructor execution.\n', '\n', '    // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '    // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "    // for accounts without code, i.e. `keccak256('')`\n", '    bytes32 codehash;\n', '    bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '    assembly { codehash := extcodehash(_addr) } // solhint-disable-line\n', '    addressCheck = (codehash != 0x0 && codehash != accountHash);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev A standard for detecting smart contract interfaces. \n', ' * See: https://eips.ethereum.org/EIPS/eip-165.\n', ' */\n', 'interface ERC165\n', '{\n', '\n', '  /**\n', '   * @dev Checks if the smart contract includes a specific interface.\n', '   * This function uses less than 30,000 gas.\n', '   * @param _interfaceID The interface identifier, as specified in ERC-165.\n', '   * @return True if _interfaceID is supported, false otherwise.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '    \n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of standard for detect smart contract interfaces.\n', ' */\n', 'contract SupportsInterface is\n', '  ERC165\n', '{\n', '\n', '  /**\n', '   * @dev Mapping of supported intefraces. You must not set element 0xffffffff to true.\n', '   */\n', '  mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '  {\n', '    supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '  }\n', '\n', '  /**\n', '   * @dev Function to check which interfaces are suported by this contract.\n', '   * @param _interfaceID Id of the interface.\n', '   * @return True if _interfaceID is supported, false otherwise.\n', '   */\n', '  function supportsInterface(\n', '    bytes4 _interfaceID\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (bool)\n', '  {\n', '    return supportedInterfaces[_interfaceID];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev ERC-721 non-fungible token standard.\n', ' * See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md.\n', ' */\n', 'interface ERC721\n', '{\n', '\n', '  /**\n', '   * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\n', '   * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\n', '   * number of NFTs may be created and assigned without emitting Transfer. At the time of any\n', '   * transfer, the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Transfer(\n', '    address indexed _from,\n', '    address indexed _to,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\n', '   * address indicates there is no approved address. When a Transfer event emits, this also\n', '   * indicates that the approved address for that NFT (if any) is reset to none.\n', '   */\n', '  event Approval(\n', '    address indexed _owner,\n', '    address indexed _approved,\n', '    uint256 indexed _tokenId\n', '  );\n', '\n', '  /**\n', '   * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\n', '   * all NFTs of the owner.\n', '   */\n', '  event ApprovalForAll(\n', '    address indexed _owner,\n', '    address indexed _operator,\n', '    bool _approved\n', '  );\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n', '   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n', '   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n', '   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '   * `onERC721Received` on `_to` and throws if the return value is not\n', '   * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes calldata _data\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address.\n', '   * @notice This works identically to the other function with an extra data parameter, except this\n', '   * function just sets data to ""\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n', '   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n', '   * address. Throws if `_tokenId` is not a valid NFT.\n', '   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n', '   * they may be permanently lost.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Set or reaffirm the approved address for an NFT.\n', '   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n', '   * the current NFT owner, or an authorized operator of the current owner.\n', '   * @param _approved The new approved NFT controller.\n', '   * @param _tokenId The NFT to approve.\n', '   */\n', '  function approve(\n', '    address _approved,\n', '    uint256 _tokenId\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Enables or disables approval for a third party ("operator") to manage all of\n', "   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n", '   * @notice The contract MUST allow multiple operators per owner.\n', '   * @param _operator Address to add to the set of authorized operators.\n', '   * @param _approved True if the operators is approved, false to revoke approval.\n', '   */\n', '  function setApprovalForAll(\n', '    address _operator,\n', '    bool _approved\n', '  )\n', '    external;\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   * @return Balance of _owner.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    view\n', '    returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\n', '   * considered invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   * @return Address of _tokenId owner.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  /**\n', '   * @dev Get the approved address for a single NFT.\n', '   * @notice Throws if `_tokenId` is not a valid NFT.\n', '   * @param _tokenId The NFT to find the approved address for.\n', '   * @return Address that _tokenId is approved for.\n', '   */\n', '  function getApproved(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    view\n', '    returns (address);\n', '\n', '  /**\n', '   * @dev Returns true if `_operator` is an approved operator for `_owner`, false otherwise.\n', '   * @param _owner The address that owns the NFTs.\n', '   * @param _operator The address that acts on behalf of the owner.\n', '   * @return True if approved for all, false otherwise.\n', '   */\n', '  function isApprovedForAll(\n', '    address _owner,\n', '    address _operator\n', '  )\n', '    external\n', '    view\n', '    returns (bool);\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev Implementation of ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFToken is\n', '  ERC721,\n', '  SupportsInterface\n', '{\n', '  using AddressUtils for address;\n', '\n', '  /**\n', '   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\n', '   * Based on 0xcert framework error codes.\n', '   */\n', '  string constant ZERO_ADDRESS = "003001";\n', '  string constant NOT_VALID_NFT = "003002";\n', '  string constant NOT_OWNER_OR_OPERATOR = "003003";\n', '  string constant NOT_OWNER_APPROVED_OR_OPERATOR = "003004";\n', '  string constant NOT_ABLE_TO_RECEIVE_NFT = "003005";\n', '  string constant NFT_ALREADY_EXISTS = "003006";\n', '  string constant NOT_OWNER = "003007";\n', '  string constant IS_OWNER = "003008";\n', '\n', '  /**\n', '   * @dev Magic value of a smart contract that can receive NFT.\n', '   * Equal to: bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")).\n', '   */\n', '  bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n', '\n', '  /**\n', '   * @dev A mapping from NFT ID to the address that owns it.\n', '   */\n', '  mapping (uint256 => address) internal idToOwner;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to approved address.\n', '   */\n', '  mapping (uint256 => address) internal idToApproval;\n', '\n', '   /**\n', '   * @dev Mapping from owner address to count of their tokens.\n', '   */\n', '  mapping (address => uint256) private ownerToNFTokenCount;\n', '\n', '  /**\n', '   * @dev Mapping from owner address to mapping of operator addresses.\n', '   */\n', '  mapping (address => mapping (address => bool)) internal ownerToOperators;\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier canOperate(\n', '    uint256 _tokenId\n', '  )\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(\n', '      tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender],\n', '      NOT_OWNER_OR_OPERATOR\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Guarantees that the msg.sender is allowed to transfer NFT.\n', '   * @param _tokenId ID of the NFT to transfer.\n', '   */\n', '  modifier canTransfer(\n', '    uint256 _tokenId\n', '  )\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(\n', '      tokenOwner == msg.sender\n', '      || idToApproval[_tokenId] == msg.sender\n', '      || ownerToOperators[tokenOwner][msg.sender],\n', '      NOT_OWNER_APPROVED_OR_OPERATOR\n', '    );\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Guarantees that _tokenId is a valid Token.\n', '   * @param _tokenId ID of the NFT to validate.\n', '   */\n', '  modifier validNFToken(\n', '    uint256 _tokenId\n', '  )\n', '  {\n', '    require(idToOwner[_tokenId] != address(0), NOT_VALID_NFT);\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '  {\n', '    supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address. This function can\n', '   * be changed to payable.\n', '   * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\n', '   * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\n', '   * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\n', '   * function checks if `_to` is a smart contract (code size > 0). If so, it calls\n', '   * `onERC721Received` on `_to` and throws if the return value is not\n', '   * `bytes4(keccak256("onERC721Received(address,uint256,bytes)"))`.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes calldata _data\n', '  )\n', '    external\n', '    override\n', '  {\n', '    _safeTransferFrom(_from, _to, _tokenId, _data);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the ownership of an NFT from one address to another address. This function can\n', '   * be changed to payable.\n', '   * @notice This works identically to the other function with an extra data parameter, except this\n', '   * function just sets data to ""\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '  {\n', '    _safeTransferFrom(_from, _to, _tokenId, "");\n', '  }\n', '\n', '  /**\n', '   * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n', '   * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\n', '   * address. Throws if `_tokenId` is not a valid NFT. This function can be changed to payable.\n', '   * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n', '   * they may be permanently lost.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   */\n', '  function transferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '    canTransfer(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == _from, NOT_OWNER);\n', '    require(_to != address(0), ZERO_ADDRESS);\n', '\n', '    _transfer(_to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Set or reaffirm the approved address for an NFT. This function can be changed to payable.\n', '   * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\n', '   * the current NFT owner, or an authorized operator of the current owner.\n', '   * @param _approved Address to be approved for the given NFT ID.\n', '   * @param _tokenId ID of the token to be approved.\n', '   */\n', '  function approve(\n', '    address _approved,\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '    canOperate(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(_approved != tokenOwner, IS_OWNER);\n', '\n', '    idToApproval[_tokenId] = _approved;\n', '    emit Approval(tokenOwner, _approved, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Enables or disables approval for a third party ("operator") to manage all of\n', "   * `msg.sender`'s assets. It also emits the ApprovalForAll event.\n", "   * @notice This works even if sender doesn't own any tokens at the time.\n", '   * @param _operator Address to add to the set of authorized operators.\n', '   * @param _approved True if the operators is approved, false to revoke approval.\n', '   */\n', '  function setApprovalForAll(\n', '    address _operator,\n', '    bool _approved\n', '  )\n', '    external\n', '    override\n', '  {\n', '    ownerToOperators[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\n', '   * considered invalid, and this function throws for queries about the zero address.\n', '   * @param _owner Address for whom to query the balance.\n', '   * @return Balance of _owner.\n', '   */\n', '  function balanceOf(\n', '    address _owner\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_owner != address(0), ZERO_ADDRESS);\n', '    return _getOwnerNFTCount(_owner);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the owner of the NFT. NFTs assigned to the zero address are\n', '   * considered invalid, and queries about them do throw.\n', '   * @param _tokenId The identifier for an NFT.\n', '   * @return _owner Address of _tokenId owner.\n', '   */\n', '  function ownerOf(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (address _owner)\n', '  {\n', '    _owner = idToOwner[_tokenId];\n', '    require(_owner != address(0), NOT_VALID_NFT);\n', '  }\n', '\n', '  /**\n', '   * @dev Get the approved address for a single NFT.\n', '   * @notice Throws if `_tokenId` is not a valid NFT.\n', '   * @param _tokenId ID of the NFT to query the approval of.\n', '   * @return Address that _tokenId is approved for.\n', '   */\n', '  function getApproved(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '    view\n', '    validNFToken(_tokenId)\n', '    returns (address)\n', '  {\n', '    return idToApproval[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Checks if `_operator` is an approved operator for `_owner`.\n', '   * @param _owner The address that owns the NFTs.\n', '   * @param _operator The address that acts on behalf of the owner.\n', '   * @return True if approved for all, false otherwise.\n', '   */\n', '  function isApprovedForAll(\n', '    address _owner,\n', '    address _operator\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (bool)\n', '  {\n', '    return ownerToOperators[_owner][_operator];\n', '  }\n', '\n', '  /**\n', '   * @dev Actually performs the transfer.\n', '   * @notice Does NO checks.\n', '   * @param _to Address of a new owner.\n', '   * @param _tokenId The NFT that is being transferred.\n', '   */\n', '  function _transfer(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '  {\n', '    address from = idToOwner[_tokenId];\n', '    _clearApproval(_tokenId);\n', '\n', '    _removeNFToken(from, _tokenId);\n', '    _addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(from, _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is an internal function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    virtual\n', '  {\n', '    require(_to != address(0), ZERO_ADDRESS);\n', '    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n', '\n', '    _addNFToken(_to, _tokenId);\n', '\n', '    emit Transfer(address(0), _to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is an internal function which should be called from user-implemented external burn\n', '   * function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n', '   * NFT.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    virtual\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    _clearApproval(_tokenId);\n', '    _removeNFToken(tokenOwner, _tokenId);\n', '    emit Transfer(tokenOwner, address(0), _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from which we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function _removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    virtual\n', '  {\n', '    require(idToOwner[_tokenId] == _from, NOT_OWNER);\n', '    ownerToNFTokenCount[_from] -= 1;\n', '    delete idToOwner[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Assigns a new NFT to owner.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to which we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function _addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    virtual\n', '  {\n', '    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n', '\n', '    idToOwner[_tokenId] = _to;\n', '    ownerToNFTokenCount[_to] += 1;\n', '  }\n', '\n', '  /**\n', '   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n', '   * extension to remove double storage (gas optimization) of owner NFT count.\n', '   * @param _owner Address for whom to query the count.\n', '   * @return Number of _owner NFTs.\n', '   */\n', '  function _getOwnerNFTCount(\n', '    address _owner\n', '  )\n', '    internal\n', '    virtual\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return ownerToNFTokenCount[_owner];\n', '  }\n', '\n', '  /**\n', '   * @dev Actually perform the safeTransferFrom.\n', '   * @param _from The current owner of the NFT.\n', '   * @param _to The new owner.\n', '   * @param _tokenId The NFT to transfer.\n', '   * @param _data Additional data with no specified format, sent in call to `_to`.\n', '   */\n', '  function _safeTransferFrom(\n', '    address _from,\n', '    address _to,\n', '    uint256 _tokenId,\n', '    bytes memory _data\n', '  )\n', '    private\n', '    canTransfer(_tokenId)\n', '    validNFToken(_tokenId)\n', '  {\n', '    address tokenOwner = idToOwner[_tokenId];\n', '    require(tokenOwner == _from, NOT_OWNER);\n', '    require(_to != address(0), ZERO_ADDRESS);\n', '\n', '    _transfer(_to, _tokenId);\n', '\n', '    if (_to.isContract())\n', '    {\n', '      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n', '      require(retval == MAGIC_ON_ERC721_RECEIVED, NOT_ABLE_TO_RECEIVE_NFT);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Clears the current approval of a given NFT ID.\n', '   * @param _tokenId ID of the NFT to be transferred.\n', '   */\n', '  function _clearApproval(\n', '    uint256 _tokenId\n', '  )\n', '    private\n', '  {\n', '    delete idToApproval[_tokenId];\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @dev Optional metadata implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFTokenMetadata is\n', '  NFToken,\n', '  ERC721Metadata\n', '{\n', '\n', '  /**\n', '   * @dev A descriptive name for a collection of NFTs.\n', '   */\n', '  string internal nftName;\n', '\n', '  /**\n', '   * @dev An abbreviated name for NFTokens.\n', '   */\n', '  string internal nftSymbol;\n', '  \n', '    /**\n', '   * @dev A contract level URI\n', '   */\n', '  string internal nftURI;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to metadata uri.\n', '   */\n', '  mapping (uint256 => string) internal idToUri;\n', '  \n', '  \n', '    /**\n', '   * @dev Mapping from NFT ID to redeemable flag.\n', '   */\n', '  mapping (uint256 => bool) internal idToRedeemable;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', "   * @notice When implementing this contract don't forget to set nftName and nftSymbol.\n", '   */\n', '  constructor()\n', '  {\n', '    supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\n', '  }\n', '\n', '  /**\n', '   * @dev Returns a descriptive name for a collection of NFTokens.\n', '   * @return _name Representing name.\n', '   */\n', '  function name()\n', '    external\n', '    override\n', '    view\n', '    returns (string memory _name)\n', '  {\n', '    _name = nftName;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns an abbreviated name for NFTokens.\n', '   * @return _symbol Representing symbol.\n', '   */\n', '  function symbol()\n', '    external\n', '    override\n', '    view\n', '    returns (string memory _symbol)\n', '  {\n', '    _symbol = nftSymbol;\n', '  }\n', '  \n', '    /**\n', '   * @dev Returns a URI for a collection of NFTokens.\n', '   * @return _nftURI Representing nftURI.\n', '   */\n', '  function contractURI()\n', '    external\n', '    override\n', '    view\n', '    returns (string memory _nftURI)\n', '  {\n', '    _nftURI = nftURI;\n', '  }\n', '\n', '  /**\n', '   * @dev A distinct URI (RFC 3986) for a given NFT.\n', '   * @param _tokenId Id for which we want uri.\n', '   * @return URI of _tokenId.\n', '   */\n', '  function tokenURI(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '    view\n', '    validNFToken(_tokenId)\n', '    returns (string memory)\n', '  {\n', '    return idToUri[_tokenId];\n', '  }\n', '  \n', '    /**\n', '   * @dev A redeemed flag value for a given NFT.\n', '   * @param _tokenId Id for which we want uri.\n', '   * @return redeemed flag of _tokenId.\n', '   */\n', '  function tokenRedeemable(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    override\n', '    view\n', '    validNFToken(_tokenId)\n', '    returns (bool)\n', '  {\n', '    return idToRedeemable[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is an internal function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n', '   * NFT.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override\n', '    virtual\n', '  {\n', '    super._burn(_tokenId);\n', '\n', '    delete idToUri[_tokenId];\n', '  }\n', '\n', '  /**\n', '   * @dev Set a distinct URI (RFC 3986) for a given NFT ID.\n', '   * @notice This is an internal function which should be called from user-implemented external\n', '   * function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _tokenId Id for which we want URI.\n', '   * @param _uri String representing RFC 3986 URI.\n', '   */\n', '  function _setTokenUri(\n', '    uint256 _tokenId,\n', '    string memory _uri\n', '  )\n', '    internal\n', '    validNFToken(_tokenId)\n', '  {\n', '    idToUri[_tokenId] = _uri;\n', '  }\n', ' \n', '   /**\n', '   * @dev Set redeemed for a given NFT ID.\n', '   * @param _tokenId Id for which we want to set redeemed.\n', '   * @param _redeemable representing redeemed status.\n', '   */ \n', '  function _setTokenRedeemable(\n', '    uint256 _tokenId,\n', '    bool _redeemable\n', '  )\n', '    internal\n', '    validNFToken(_tokenId)\n', '  {\n', '    idToRedeemable[_tokenId] = _redeemable;\n', '  }\n', '\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Optional enumeration implementation for ERC-721 non-fungible token standard.\n', ' */\n', 'contract NFTokenEnumerable is\n', '  NFToken,\n', '  ERC721Enumerable\n', '{\n', '\n', '  /**\n', '   * @dev List of revert message codes. Implementing dApp should handle showing the correct message.\n', '   * Based on 0xcert framework error codes.\n', '   */\n', '  string constant INVALID_INDEX = "005007";\n', '\n', '  /**\n', '   * @dev Array of all NFT IDs.\n', '   */\n', '  uint256[] internal tokens;\n', '\n', '  /**\n', '   * @dev Mapping from token ID to its index in global tokens array.\n', '   */\n', '  mapping(uint256 => uint256) internal idToIndex;\n', '\n', '  /**\n', '   * @dev Mapping from owner to list of owned NFT IDs.\n', '   */\n', '  mapping(address => uint256[]) internal ownerToIds;\n', '\n', '  /**\n', '   * @dev Mapping from NFT ID to its index in the owner tokens list.\n', '   */\n', '  mapping(uint256 => uint256) internal idToOwnerIndex;\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   */\n', '  constructor()\n', '  {\n', '    supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the count of all existing NFTokens.\n', '   * @return Total supply of NFTs.\n', '   */\n', '  function totalSupply()\n', '    external\n', '    override\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return tokens.length;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns NFT ID by its index.\n', '   * @param _index A counter less than `totalSupply()`.\n', '   * @return Token id.\n', '   */\n', '  function tokenByIndex(\n', '    uint256 _index\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_index < tokens.length, INVALID_INDEX);\n', '    return tokens[_index];\n', '  }\n', '\n', '  /**\n', "   * @dev returns the n-th NFT ID from a list of owner's tokens.\n", "   * @param _owner Token owner's address.\n", "   * @param _index Index number representing n-th token in owner's list of tokens.\n", '   * @return Token id.\n', '   */\n', '  function tokenOfOwnerByIndex(\n', '    address _owner,\n', '    uint256 _index\n', '  )\n', '    external\n', '    override\n', '    view\n', '    returns (uint256)\n', '  {\n', '    require(_index < ownerToIds[_owner].length, INVALID_INDEX);\n', '    return ownerToIds[_owner][_index];\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is an internal function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override\n', '    virtual\n', '  {\n', '    super._mint(_to, _tokenId);\n', '    tokens.push(_tokenId);\n', '    idToIndex[_tokenId] = tokens.length - 1;\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is an internal function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n', '   * NFT.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override\n', '    virtual\n', '  {\n', '    super._burn(_tokenId);\n', '\n', '    uint256 tokenIndex = idToIndex[_tokenId];\n', '    uint256 lastTokenIndex = tokens.length - 1;\n', '    uint256 lastToken = tokens[lastTokenIndex];\n', '\n', '    tokens[tokenIndex] = lastToken;\n', '\n', '    tokens.pop();\n', '    // This wastes gas if you are burning the last token but saves a little gas if you are not.\n', '    idToIndex[lastToken] = tokenIndex;\n', '    idToIndex[_tokenId] = 0;\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function _removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override\n', '    virtual\n', '  {\n', '    require(idToOwner[_tokenId] == _from, NOT_OWNER);\n', '    delete idToOwner[_tokenId];\n', '\n', '    uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n', '    uint256 lastTokenIndex = ownerToIds[_from].length - 1;\n', '\n', '    if (lastTokenIndex != tokenToRemoveIndex)\n', '    {\n', '      uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n', '      ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n', '      idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n', '    }\n', '\n', '    ownerToIds[_from].pop();\n', '  }\n', '\n', '  /**\n', '   * @dev Assigns a new NFT to an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function _addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override\n', '    virtual\n', '  {\n', '    require(idToOwner[_tokenId] == address(0), NFT_ALREADY_EXISTS);\n', '    idToOwner[_tokenId] = _to;\n', '\n', '    ownerToIds[_to].push(_tokenId);\n', '    idToOwnerIndex[_tokenId] = ownerToIds[_to].length - 1;\n', '  }\n', '\n', '  /**\n', '   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n', '   * extension to remove double storage(gas optimization) of owner NFT count.\n', '   * @param _owner Address for whom to query the count.\n', '   * @return Number of _owner NFTs.\n', '   */\n', '  function _getOwnerNFTCount(\n', '    address _owner\n', '  )\n', '    internal\n', '    override\n', '    virtual\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return ownerToIds[_owner].length;\n', '  }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev This is an example contract implementation of NFToken with enumerable and metadata\n', ' * extensions.\n', ' */\n', 'contract NFT_Redeemable_Option is\n', '  NFTokenMetadata,\n', '  NFTokenEnumerable,\n', '  \n', '  Ownable\n', '{\n', '\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _name A descriptive name for a collection of NFTs.\n', '   * @param _symbol An abbreviated name for NFTokens.\n', '   * @param _nftURI A URI for the contract\n', '   */\n', '  constructor(\n', '    string memory _name,\n', '    string memory _symbol,\n', '    string memory _nftURI\n', '  )\n', '  {\n', '    nftName = _name;\n', '    nftSymbol = _symbol;\n', '    nftURI = _nftURI;\n', '  }\n', '  \n', '   /**\n', '   * @dev Returns all token Ids.\n', '   */\n', '  \n', '  function allIds(\n', '  )\n', '    external\n', '    view\n', '    returns (uint256[] memory)\n', '  {\n', '    return tokens;\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   * @param _uri String representing RFC 3986 URI.\n', '   */\n', '  function mint(\n', '    address _to,\n', '    uint256 _tokenId,\n', '    string calldata _uri,\n', '    bool _redeemable\n', '  )\n', '    external\n', '    onlyOwner\n', '  {\n', '    super._mint(_to, _tokenId);\n', '    super._setTokenUri(_tokenId, _uri);\n', '    super._setTokenRedeemable(_tokenId,_redeemable);\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from owner.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function burn(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    onlyOwner\n', '  {\n', '    super._burn(_tokenId);\n', '  }\n', '  \n', '  \n', '  /**\n', '   * @dev Sets redeem to true\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function redeem(\n', '    uint256 _tokenId\n', '  )\n', '    external\n', '    onlyOwner\n', '  {\n', '    super._setTokenRedeemable(_tokenId,false);\n', '  }\n', '\n', '  /**\n', '   * @dev Mints a new NFT.\n', '   * @notice This is an internal function which should be called from user-implemented external\n', '   * mint function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation.\n', '   * @param _to The address that will own the minted NFT.\n', '   * @param _tokenId of the NFT to be minted by the msg.sender.\n', '   */\n', '  function _mint(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override(NFToken, NFTokenEnumerable)\n', '    virtual\n', '  {\n', '    NFTokenEnumerable._mint(_to, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns a NFT.\n', '   * @notice This is an internal function which should be called from user-implemented external\n', '   * burn function. Its purpose is to show and properly initialize data structures when using this\n', '   * implementation. Also, note that this burn implementation allows the minter to re-mint a burned\n', '   * NFT.\n', '   * @param _tokenId ID of the NFT to be burned.\n', '   */\n', '  function _burn(\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override(NFTokenMetadata, NFTokenEnumerable)\n', '    virtual\n', '  {\n', '    NFTokenEnumerable._burn(_tokenId);\n', '    if (bytes(idToUri[_tokenId]).length != 0)\n', '    {\n', '      delete idToUri[_tokenId];\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Removes a NFT from an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _from Address from wich we want to remove the NFT.\n', '   * @param _tokenId Which NFT we want to remove.\n', '   */\n', '  function _removeNFToken(\n', '    address _from,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override(NFToken, NFTokenEnumerable)\n', '  {\n', '    NFTokenEnumerable._removeNFToken(_from, _tokenId);\n', '  }\n', '\n', '  /**\n', '   * @dev Assigns a new NFT to an address.\n', '   * @notice Use and override this function with caution. Wrong usage can have serious consequences.\n', '   * @param _to Address to wich we want to add the NFT.\n', '   * @param _tokenId Which NFT we want to add.\n', '   */\n', '  function _addNFToken(\n', '    address _to,\n', '    uint256 _tokenId\n', '  )\n', '    internal\n', '    override(NFToken, NFTokenEnumerable)\n', '  {\n', '    NFTokenEnumerable._addNFToken(_to, _tokenId);\n', '  }\n', '\n', '   /**\n', '   * @dev Helper function that gets NFT count of owner. This is needed for overriding in enumerable\n', '   * extension to remove double storage(gas optimization) of owner nft count.\n', '   * @param _owner Address for whom to query the count.\n', '   * @return Number of _owner NFTs.\n', '   */\n', '  function _getOwnerNFTCount(\n', '    address _owner\n', '  )\n', '    internal\n', '    override(NFToken, NFTokenEnumerable)\n', '    view\n', '    returns (uint256)\n', '  {\n', '    return NFTokenEnumerable._getOwnerNFTCount(_owner);\n', '  }\n', '\n', '}']