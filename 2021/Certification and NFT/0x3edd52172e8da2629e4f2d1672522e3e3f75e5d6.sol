['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-08\n', '*/\n', '\n', '// File: openzeppelin-solidity-2.3.0/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be aplied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * > Note: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/SpartanCouncil.sol\n', '\n', 'pragma solidity ^0.5.16;\n', '\n', '\n', '\n', '/**\n', ' * @title Custom NFT contract based off ERC721 but restricted by access control.\n', ' * @dev made for https://sips.synthetix.io/sips/sip-93\n', ' */\n', 'contract SpartanCouncil is Ownable {\n', '    // Event that is emitted when a new SpartanCouncil token is minted\n', '    event Mint(uint256 indexed tokenId, address to);\n', '    // Event that is emitted when an existing SpartanCouncil token is burned\n', '    event Burn(uint256 indexed tokenId);\n', '    // Event that is emitted when an existing SpartanCouncil token is Transferred\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', "    // Event that is emitted when an existing SpartanCouncil token's uri is altered\n", '    event TokenURISet(uint256 tokenId, string tokenURI);\n', '\n', '    // Array of token ids\n', '    uint256[] public tokens;\n', '    // Map between an owner and their tokens\n', '    mapping(address => uint256) public tokenOwned;\n', '    // Maps a token to the owner address\n', '    mapping(uint256 => address) public ownerOf;\n', '    // Optional mapping for token URIs\n', '    mapping(uint256 => string) private tokenURIs;\n', '    // Token name\n', '    string public name;\n', '    // Token symbol\n', '    string public symbol;\n', '\n', '    /**\n', '     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n', '     * @param _name the name of the token\n', '     * @param _symbol the symbol of the token\n', '     */\n', '    constructor(string memory _name, string memory _symbol) public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to check that an address is not the "0" address\n', '     * @param to address the address to check\n', '     */\n', '    modifier isValidAddress(address to) {\n', '        require(to != address(0), "Method called with the zero address");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to retrieve whether an address owns a token\n', '     * @param owner address the address to check the balance of\n', '     */\n', '    function balanceOf(address owner) public view isValidAddress(owner) returns (uint256) {\n', '        return tokenOwned[owner] > 0 ? 1 : 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer function to assign a token to another address\n', '     * Reverts if the address already owns a token\n', '     * @param from address the address that currently owns the token\n', '     * @param to address the address to assign the token to\n', '     * @param tokenId uint256 ID of the token to transfer\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) public isValidAddress(to) isValidAddress(from) onlyOwner {\n', '        require(tokenOwned[to] == 0, "Destination address already owns a token");\n', '        require(ownerOf[tokenId] == from, "From address does not own token");\n', '\n', '        tokenOwned[from] = 0;\n', '        tokenOwned[to] = tokenId;\n', '\n', '        ownerOf[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Mint function to mint a new token given a tokenId and assign it to an address\n', '     * Reverts if the tokenId is 0 or the token already exist\n', '     * @param to address the address to assign the token to\n', '     * @param tokenId uint256 ID of the token to mint\n', '     */\n', '    function mint(address to, uint256 tokenId) public onlyOwner isValidAddress(to) {\n', '        _mint(to, tokenId);\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Mint function to mint a new token given a tokenId and assign it to an address\n', '     * Reverts if the tokenId is 0 or the token already exist\n', '     * @param to address the address to assign the token to\n', '     * @param tokenId uint256 ID of the token to mint\n', '     */\n', '    function mintWithTokenURI(\n', '        address to,\n', '        uint256 tokenId,\n', '        string memory uri\n', '    ) public onlyOwner isValidAddress(to) {\n', '        require(bytes(uri).length > 0, "URI must be supplied");\n', '\n', '        _mint(to, tokenId);\n', '\n', '        tokenURIs[tokenId] = uri;\n', '        emit TokenURISet(tokenId, uri);\n', '    }\n', '\n', '    function _mint(address to, uint256 tokenId) private {\n', '        require(tokenOwned[to] == 0, "Destination address already owns a token");\n', '        require(ownerOf[tokenId] == address(0), "ERC721: token already minted");\n', '        require(tokenId != 0, "Token ID must be greater than 0");\n', '\n', '        tokens.push(tokenId);\n', '        tokenOwned[to] = tokenId;\n', '        ownerOf[tokenId] = to;\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '        emit Mint(tokenId, to);\n', '    }\n', '\n', '    /**\n', '     * @dev Burn function to remove a given tokenId\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to burn\n', '     */\n', '    function burn(uint256 tokenId) public onlyOwner {\n', '        address previousOwner = ownerOf[tokenId];\n', '        require(previousOwner != address(0), "ERC721: token does not exist");\n', '\n', '        delete tokenOwned[previousOwner];\n', '        delete ownerOf[tokenId];\n', '\n', '        for (uint256 i = 0; i < tokens.length; i++) {\n', '            if (tokens[i] == tokenId) {\n', '                tokens[i] = tokens[tokens.length - 1];\n', '                break;\n', '            }\n', '        }\n', '\n', '        tokens.pop();\n', '\n', '        if (bytes(tokenURIs[tokenId]).length != 0) {\n', '            delete tokenURIs[tokenId];\n', '        }\n', '\n', '        emit Burn(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to get the total supply of tokens currently available\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return tokens.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to get the token URI for a given token.\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to retrieve the uri for\n', '     */\n', '    function tokenURI(uint256 tokenId) public view returns (string memory) {\n', '        require(ownerOf[tokenId] != address(0), "ERC721: token does not exist");\n', '        string memory _tokenURI = tokenURIs[tokenId];\n', '        return _tokenURI;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to set the token URI for a given token.\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to set its URI\n', '     * @param uri string URI to assign\n', '     */\n', '    function setTokenURI(uint256 tokenId, string memory uri) public onlyOwner {\n', '        require(ownerOf[tokenId] != address(0), "ERC721: token does not exist");\n', '        tokenURIs[tokenId] = uri;\n', '        emit TokenURISet(tokenId, uri);\n', '    }\n', '}']