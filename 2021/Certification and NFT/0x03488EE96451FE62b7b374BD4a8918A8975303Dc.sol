['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-10\n', '*/\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'interface IGovernance {\n', '    event GovernanceChanged(address oldGovernance, address newGovernance);\n', '    event MinterAdmitted(address target);\n', '    event MinterExpelled(address target);\n', '    \n', '    function governance () external view returns (address);\n', '    function isMinter (address target) external view returns (bool);\n', '    function admitMinter (address target) external;\n', '    function expelMinter (address target) external;\n', '    function succeedGovernance (address newGovernance) external;\n', '}\n', '\n', 'contract Timelock {\n', '    struct job{\n', '        uint256 id;\n', '        uint256 state;\n', '        string action;\n', '        address arg;\n', '        uint256 queued;\n', '    }\n', '    \n', '    address public COMMUNITY;\n', '    address public TOKEN;\n', '    uint256 public LOCK_PERIOD;\n', '    mapping (uint256 => job) public JOB_DATA;\n', '    uint256 public LAST_ID;\n', '    \n', '    bytes32 constant private CONST_CHANGE_PERIOD = keccak256("changePeriod");\n', '    bytes32 constant private CONST_ADMIT_MINTER = keccak256("admitMinter");\n', '    bytes32 constant private CONST_EXPEL_MINTER = keccak256("expelMinter");\n', '    bytes32 constant private CONST_SUCCEED_GOVERNANCE = keccak256("succeedGovernance");\n', '\n', '    event JobQueued (uint256 id);\n', '    event CommunitySucceeded (address originCommunity, address newCommunity);\n', '    \n', '    constructor (address token, uint256 lockPeriod) public {\n', '        TOKEN = token;\n', '        COMMUNITY = msg.sender;\n', '        LOCK_PERIOD = lockPeriod;\n', '        LAST_ID = 0;\n', '    }\n', '    \n', '    modifier CommunityOnly () {\n', '        require (msg.sender == COMMUNITY, "Only Community can do");\n', '        _;\n', '    }\n', '    \n', '    modifier JobAlive (uint256 id) {\n', '        require(JOB_DATA[id].id > 0, "There is no job with id");\n', '        require(JOB_DATA[id].state == 0, "Already expired job");\n', '        _;\n', '    }\n', '    \n', '    function whenExecutable (uint256 id) public view JobAlive(id) returns (uint256) {\n', '        return JOB_DATA[id].queued + LOCK_PERIOD;\n', '    }\n', '    \n', '    function isExecutable (uint256 id) public view JobAlive(id) returns (bool) {\n', '        return block.number >= whenExecutable(id);\n', '    }\n', '    \n', '    function queueJob (string calldata action, address arg) external CommunityOnly returns (uint256) {\n', '        uint256 nextID = LAST_ID + 1;\n', '        \n', '        JOB_DATA[nextID] = job(nextID, 0, action, arg, block.number);\n', '        \n', '        emit JobQueued(nextID);\n', '        LAST_ID = nextID;\n', '        return nextID;\n', '    }\n', '    \n', '    function cancelJob (uint256 id) external CommunityOnly JobAlive(id) {\n', '        JOB_DATA[id].state = 2;\n', '    }\n', '    \n', '    function executeJob (uint256 id) external CommunityOnly {\n', '        require(isExecutable(id) == true, "Job isnt ready");\n', '        \n', '        JOB_DATA[id].state = 1;\n', '        \n', '        if(keccak256(abi.encodePacked(JOB_DATA[id].action)) == CONST_CHANGE_PERIOD){\n', '            _changePeriod(uint256(JOB_DATA[id].arg));\n', '            return;\n', '        }\n', '        \n', '        IGovernance tokenObj = IGovernance(TOKEN);\n', '        if(keccak256(abi.encodePacked(JOB_DATA[id].action)) == CONST_ADMIT_MINTER){\n', '            tokenObj.admitMinter(JOB_DATA[id].arg);\n', '            return;\n', '        }\n', '        if(keccak256(abi.encodePacked(JOB_DATA[id].action)) == CONST_EXPEL_MINTER){\n', '            tokenObj.expelMinter(JOB_DATA[id].arg);\n', '            return;\n', '        }\n', '        if(keccak256(abi.encodePacked(JOB_DATA[id].action)) == CONST_SUCCEED_GOVERNANCE){\n', '            tokenObj.succeedGovernance(JOB_DATA[id].arg);\n', '            return;\n', '        }\n', '    }\n', '    \n', '    function succeedCommunity (address newCommunity) external CommunityOnly {\n', '        emit CommunitySucceeded(COMMUNITY, newCommunity);\n', '        COMMUNITY = newCommunity;\n', '    }\n', '    \n', '    function _changePeriod (uint256 lockPeriod) private CommunityOnly {\n', '        LOCK_PERIOD = lockPeriod;\n', '    }\n', '}']