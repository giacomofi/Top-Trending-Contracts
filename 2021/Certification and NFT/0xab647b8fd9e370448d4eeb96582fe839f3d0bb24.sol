['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-10\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', '\n', '// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath.sol\n', '// Adapted to use pragma ^0.5.17 and satisfy our linter rules\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    string private constant ERROR_ADD_OVERFLOW = "MATH_ADD_OVERFLOW";\n', '    string private constant ERROR_SUB_UNDERFLOW = "MATH_SUB_UNDERFLOW";\n', '    string private constant ERROR_MUL_OVERFLOW = "MATH_MUL_OVERFLOW";\n', '    string private constant ERROR_DIV_ZERO = "MATH_DIV_ZERO";\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (_a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = _a * _b;\n', '        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n', '        uint256 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n', '        uint256 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n', '        uint256 c = _a + _b;\n', '        require(c >= _a, ERROR_ADD_OVERFLOW);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, ERROR_DIV_ZERO);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract IERC20 {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address _who) external view returns (uint256);\n', '\n', '    function allowance(address _owner, address _spender) external view returns (uint256);\n', '\n', '    function transfer(address _to, uint256 _value) external returns (bool);\n', '\n', '    function approve(address _spender, uint256 _value) external returns (bool);\n', '\n', '    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', '// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/SafeERC20.sol\n', '// Adapted to use pragma ^0.5.17 and satisfy our linter rules\n', 'library SafeERC20 {\n', '    /**\n', '    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n', '    *      Note that this makes an external call to the provided token and expects it to be already\n', '    *      verified as a contract.\n', '    */\n', '    function safeTransfer(IERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n', '        bytes memory transferCallData = abi.encodeWithSelector(\n', '            _token.transfer.selector,\n', '            _to,\n', '            _amount\n', '        );\n', '        return invokeAndCheckSuccess(address(_token), transferCallData);\n', '    }\n', '\n', '    /**\n', '    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n', '    *      Note that this makes an external call to the provided token and expects it to be already\n', '    *      verified as a contract.\n', '    */\n', '    function safeTransferFrom(IERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n', '        bytes memory transferFromCallData = abi.encodeWithSelector(\n', '            _token.transferFrom.selector,\n', '            _from,\n', '            _to,\n', '            _amount\n', '        );\n', '        return invokeAndCheckSuccess(address(_token), transferFromCallData);\n', '    }\n', '\n', '    /**\n', '    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n', '    *      Note that this makes an external call to the provided token and expects it to be already\n', '    *      verified as a contract.\n', '    */\n', '    function safeApprove(IERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n', '        bytes memory approveCallData = abi.encodeWithSelector(\n', '            _token.approve.selector,\n', '            _spender,\n', '            _amount\n', '        );\n', '        return invokeAndCheckSuccess(address(_token), approveCallData);\n', '    }\n', '\n', '    function invokeAndCheckSuccess(address _addr, bytes memory _calldata) private returns (bool) {\n', '        bool ret;\n', '        assembly {\n', '            let ptr := mload(0x40)    // free memory pointer\n', '\n', '            let success := call(\n', '                gas,                  // forward all gas\n', '                _addr,                // address\n', '                0,                    // no value\n', '                add(_calldata, 0x20), // calldata start\n', '                mload(_calldata),     // calldata length\n', '                ptr,                  // write output over free memory\n', '                0x20                  // uint256 return\n', '            )\n', '\n', '            if gt(success, 0) {\n', '            // Check number of bytes returned from last function call\n', '                switch returndatasize\n', '\n', '                // No bytes returned: assume success\n', '                case 0 {\n', '                    ret := 1\n', '                }\n', '\n', '                // 32 bytes returned: check if non-zero\n', '                case 0x20 {\n', '                // Only return success if returned data was true\n', '                // Already have output in ptr\n', '                    ret := eq(mload(ptr), 1)\n', '                }\n', '\n', "                // Not sure what was returned: don't mark as success\n", '                default { }\n', '            }\n', '        }\n', '        return ret;\n', '    }\n', '}\n', '\n', 'library PctHelpers {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 internal constant PCT_BASE = 10000; // â€± (1 / 10,000)\n', '\n', '    function isValid(uint16 _pct) internal pure returns (bool) {\n', '        return _pct <= PCT_BASE;\n', '    }\n', '\n', '    function pct(uint256 self, uint16 _pct) internal pure returns (uint256) {\n', '        return self.mul(uint256(_pct)) / PCT_BASE;\n', '    }\n', '\n', '    function pct256(uint256 self, uint256 _pct) internal pure returns (uint256) {\n', '        return self.mul(_pct) / PCT_BASE;\n', '    }\n', '\n', '    function pctIncrease(uint256 self, uint16 _pct) internal pure returns (uint256) {\n', '        // No need for SafeMath: for addition note that `PCT_BASE` is lower than (2^256 - 2^16)\n', '        return self.mul(PCT_BASE + uint256(_pct)) / PCT_BASE;\n', '    }\n', '}\n', '\n', '/**\n', '* @title Checkpointing - Library to handle a historic set of numeric values\n', '*/\n', 'library Checkpointing {\n', '    uint256 private constant MAX_UINT192 = uint256(uint192(-1));\n', '\n', '    string private constant ERROR_VALUE_TOO_BIG = "CHECKPOINT_VALUE_TOO_BIG";\n', '    string private constant ERROR_CANNOT_ADD_PAST_VALUE = "CHECKPOINT_CANNOT_ADD_PAST_VALUE";\n', '\n', '    /**\n', '    * @dev To specify a value at a given point in time, we need to store two values:\n', '    *      - `time`: unit-time value to denote the first time when a value was registered\n', '    *      - `value`: a positive numeric value to registered at a given point in time\n', '    *\n', '    *      Note that `time` does not need to refer necessarily to a timestamp value, any time unit could be used\n', '    *      for it like block numbers, terms, etc.\n', '    */\n', '    struct Checkpoint {\n', '        uint64 time;\n', '        uint192 value;\n', '    }\n', '\n', '    /**\n', '    * @dev A history simply denotes a list of checkpoints\n', '    */\n', '    struct History {\n', '        Checkpoint[] history;\n', '    }\n', '\n', '    /**\n', '    * @dev Add a new value to a history for a given point in time. This function does not allow to add values previous\n', '    *      to the latest registered value, if the value willing to add corresponds to the latest registered value, it\n', '    *      will be updated.\n', '    * @param self Checkpoints history to be altered\n', '    * @param _time Point in time to register the given value\n', '    * @param _value Numeric value to be registered at the given point in time\n', '    */\n', '    function add(History storage self, uint64 _time, uint256 _value) internal {\n', '        require(_value <= MAX_UINT192, ERROR_VALUE_TOO_BIG);\n', '        _add192(self, _time, uint192(_value));\n', '    }\n', '\n', '    /**\n', '    * @dev Fetch the latest registered value of history, it will return zero if there was no value registered\n', '    * @param self Checkpoints history to be queried\n', '    */\n', '    function getLast(History storage self) internal view returns (uint256) {\n', '        uint256 length = self.history.length;\n', '        if (length > 0) {\n', '            return uint256(self.history[length - 1].value);\n', '        }\n', '\n', '        return 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Fetch the most recent registered past value of a history based on a given point in time that is not known\n', '    *      how recent it is beforehand. It will return zero if there is no registered value or if given time is\n', '    *      previous to the first registered value.\n', '    *      It uses a binary search.\n', '    * @param self Checkpoints history to be queried\n', '    * @param _time Point in time to query the most recent registered past value of\n', '    */\n', '    function get(History storage self, uint64 _time) internal view returns (uint256) {\n', '        return _binarySearch(self, _time);\n', '    }\n', '\n', '    /**\n', '    * @dev Fetch the most recent registered past value of a history based on a given point in time. It will return zero\n', '    *      if there is no registered value or if given time is previous to the first registered value.\n', '    *      It uses a linear search starting from the end.\n', '    * @param self Checkpoints history to be queried\n', '    * @param _time Point in time to query the most recent registered past value of\n', '    */\n', '    function getRecent(History storage self, uint64 _time) internal view returns (uint256) {\n', '        return _backwardsLinearSearch(self, _time);\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to add a new value to a history for a given point in time. This function does not allow to\n', '    *      add values previous to the latest registered value, if the value willing to add corresponds to the latest\n', '    *      registered value, it will be updated.\n', '    * @param self Checkpoints history to be altered\n', '    * @param _time Point in time to register the given value\n', '    * @param _value Numeric value to be registered at the given point in time\n', '    */\n', '    function _add192(History storage self, uint64 _time, uint192 _value) private {\n', '        uint256 length = self.history.length;\n', '        if (length == 0 || self.history[self.history.length - 1].time < _time) {\n', '            // If there was no value registered or the given point in time is after the latest registered value,\n', '            // we can insert it to the history directly.\n', '            self.history.push(Checkpoint(_time, _value));\n', '        } else {\n', '            // If the point in time given for the new value is not after the latest registered value, we must ensure\n', '            // we are only trying to update the latest value, otherwise we would be changing past data.\n', '            Checkpoint storage currentCheckpoint = self.history[length - 1];\n', '            require(_time == currentCheckpoint.time, ERROR_CANNOT_ADD_PAST_VALUE);\n', '            currentCheckpoint.value = _value;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to execute a backwards linear search to find the most recent registered past value of a\n', '    *      history based on a given point in time. It will return zero if there is no registered value or if given time\n', '    *      is previous to the first registered value. Note that this function will be more suitable when we already know\n', '    *      that the time used to index the search is recent in the given history.\n', '    * @param self Checkpoints history to be queried\n', '    * @param _time Point in time to query the most recent registered past value of\n', '    */\n', '    function _backwardsLinearSearch(History storage self, uint64 _time) private view returns (uint256) {\n', '        // If there was no value registered for the given history return simply zero\n', '        uint256 length = self.history.length;\n', '        if (length == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 index = length - 1;\n', '        Checkpoint storage checkpoint = self.history[index];\n', '        while (index > 0 && checkpoint.time > _time) {\n', '            index--;\n', '            checkpoint = self.history[index];\n', '        }\n', '\n', '        return checkpoint.time > _time ? 0 : uint256(checkpoint.value);\n', '    }\n', '\n', '    /**\n', '    * @dev Private function execute a binary search to find the most recent registered past value of a history based on\n', '    *      a given point in time. It will return zero if there is no registered value or if given time is previous to\n', "    *      the first registered value. Note that this function will be more suitable when don't know how recent the\n", '    *      time used to index may be.\n', '    * @param self Checkpoints history to be queried\n', '    * @param _time Point in time to query the most recent registered past value of\n', '    */\n', '    function _binarySearch(History storage self, uint64 _time) private view returns (uint256) {\n', '        // If there was no value registered for the given history return simply zero\n', '        uint256 length = self.history.length;\n', '        if (length == 0) {\n', '            return 0;\n', '        }\n', '\n', '        // If the requested time is equal to or after the time of the latest registered value, return latest value\n', '        uint256 lastIndex = length - 1;\n', '        if (_time >= self.history[lastIndex].time) {\n', '            return uint256(self.history[lastIndex].value);\n', '        }\n', '\n', '        // If the requested time is previous to the first registered value, return zero to denote missing checkpoint\n', '        if (_time < self.history[0].time) {\n', '            return 0;\n', '        }\n', '\n', '        // Execute a binary search between the checkpointed times of the history\n', '        uint256 low = 0;\n', '        uint256 high = lastIndex;\n', '\n', '        while (high > low) {\n', '            // No need for SafeMath: for this to overflow array size should be ~2^255\n', '            uint256 mid = (high + low + 1) / 2;\n', '            Checkpoint storage checkpoint = self.history[mid];\n', '            uint64 midTime = checkpoint.time;\n', '\n', '            if (_time > midTime) {\n', '                low = mid;\n', '            } else if (_time < midTime) {\n', '                // No need for SafeMath: high > low >= 0 => high >= 1 => mid >= 1\n', '                high = mid - 1;\n', '            } else {\n', '                return uint256(checkpoint.value);\n', '            }\n', '        }\n', '\n', '        return uint256(self.history[low].value);\n', '    }\n', '}\n', '\n', '/**\n', '* @title HexSumTree - Library to operate checkpointed 16-ary\xa0(hex) sum trees.\n', '* @dev A sum tree is a particular case of a tree where the value of a node is equal to the sum of the values of its\n', '*      children. This library provides a set of functions to operate 16-ary sum trees, i.e. trees where every non-leaf\n', '*      node has 16 children and its value is equivalent to the sum of the values of all of them. Additionally, a\n', '*      checkpointed tree means that each time a value on a node is updated, its previous value will be saved to allow\n', '*      accessing historic information.\n', '*\n', '*      Example of a checkpointed binary sum tree:\n', '*\n', '*                                          CURRENT                                      PREVIOUS\n', '*\n', '*             Level 2                        100  ---------------------------------------- 70\n', '*                                       ______|_______                               ______|_______\n', '*                                      /              \\                             /              \\\n', '*             Level 1                 34              66 ------------------------- 23              47\n', '*                                _____|_____      _____|_____                 _____|_____      _____|_____\n', '*                               /           \\    /           \\               /           \\    /           \\\n', '*             Level 0          22           12  53           13 ----------- 22            1  17           30\n', '*\n', '*/\n', 'library HexSumTree {\n', '    using SafeMath for uint256;\n', '    using Checkpointing for Checkpointing.History;\n', '\n', '    string private constant ERROR_UPDATE_OVERFLOW = "SUM_TREE_UPDATE_OVERFLOW";\n', '    string private constant ERROR_KEY_DOES_NOT_EXIST = "SUM_TREE_KEY_DOES_NOT_EXIST";\n', '    string private constant ERROR_SEARCH_OUT_OF_BOUNDS = "SUM_TREE_SEARCH_OUT_OF_BOUNDS";\n', '    string private constant ERROR_MISSING_SEARCH_VALUES = "SUM_TREE_MISSING_SEARCH_VALUES";\n', '\n', '    // Constants used to perform tree computations\n', '    // To change any the following constants, the following relationship must be kept: 2^BITS_IN_NIBBLE = CHILDREN\n', "    // The max depth of the tree will be given by: BITS_IN_NIBBLE * MAX_DEPTH = 256 (so in this case it's 64)\n", '    uint256 private constant CHILDREN = 16;\n', '    uint256 private constant BITS_IN_NIBBLE = 4;\n', '\n', '    // All items are leaves, inserted at height or level zero. The root height will be increasing as new levels are inserted in the tree.\n', '    uint256 private constant ITEMS_LEVEL = 0;\n', '\n', '    // Tree nodes are identified with a 32-bytes length key. Leaves are identified with consecutive incremental keys\n', "    // starting with 0x0000000000000000000000000000000000000000000000000000000000000000, while non-leaf nodes' keys\n", '    // are computed based on their level and their children keys.\n', '    uint256 private constant BASE_KEY = 0;\n', '\n', '    // Timestamp used to checkpoint the first value of the tree height during initialization\n', '    uint64 private constant INITIALIZATION_INITIAL_TIME = uint64(0);\n', '\n', '    /**\n', '    * @dev The tree is stored using the following structure:\n', '    *      - nodes: A mapping indexed by a pair (level, key) with a history of the values for each node (level -> key -> value).\n', '    *      - height: A history of the heights of the tree. Minimum height is 1, a root with 16 children.\n', '    *      - nextKey: The next key to be used to identify the next new value that will be inserted into the tree.\n', '    */\n', '    struct Tree {\n', '        uint256 nextKey;\n', '        Checkpointing.History height;\n', '        mapping (uint256 => mapping (uint256 => Checkpointing.History)) nodes;\n', '    }\n', '\n', '    /**\n', '    * @dev Search params to traverse the tree caching previous results:\n', "    *      - time: Point in time to query the values being searched, this value shouldn't change during a search\n", '    *      - level: Level being analyzed for the search, it starts at the level under the root and decrements till the leaves\n', '    *      - parentKey: Key of the parent of the nodes being analyzed at the given level for the search\n', '    *      - foundValues: Number of values in the list being searched that were already found, it will go from 0 until the size of the list\n', '    *      - visitedTotal: Total sum of values that were already visited during the search, it will go from 0 until the tree total\n', '    */\n', '    struct SearchParams {\n', '        uint64 time;\n', '        uint256 level;\n', '        uint256 parentKey;\n', '        uint256 foundValues;\n', '        uint256 visitedTotal;\n', '    }\n', '\n', '    /**\n', '    * @dev Initialize tree setting the next key and first height checkpoint\n', '    */\n', '    function init(Tree storage self) internal {\n', '        self.height.add(INITIALIZATION_INITIAL_TIME, ITEMS_LEVEL + 1);\n', '        self.nextKey = BASE_KEY;\n', '    }\n', '\n', '    /**\n', '    * @dev Insert a new item to the tree at given point in time\n', '    * @param _time Point in time to register the given value\n', '    * @param _value New numeric value to be added to the tree\n', '    * @return Unique key identifying the new value inserted\n', '    */\n', '    function insert(Tree storage self, uint64 _time, uint256 _value) internal returns (uint256) {\n', '        // As the values are always stored in the leaves of the tree (level 0), the key to index each of them will be\n', '        // always incrementing, starting from zero. Add a new level if necessary.\n', '        uint256 key = self.nextKey++;\n', '        _addLevelIfNecessary(self, key, _time);\n', '\n', '        // If the new value is not zero, first set the value of the new leaf node, then add a new level at the top of\n', '        // the tree if necessary, and finally update sums cached in all the non-leaf nodes.\n', '        if (_value > 0) {\n', '            _add(self, ITEMS_LEVEL, key, _time, _value);\n', '            _updateSums(self, key, _time, _value, true);\n', '        }\n', '        return key;\n', '    }\n', '\n', '    /**\n', '    * @dev Set the value of a leaf node indexed by its key at given point in time\n', '    * @param _time Point in time to set the given value\n', '    * @param _key Key of the leaf node to be set in the tree\n', '    * @param _value New numeric value to be set for the given key\n', '    */\n', '    function set(Tree storage self, uint256 _key, uint64 _time, uint256 _value) internal {\n', '        require(_key < self.nextKey, ERROR_KEY_DOES_NOT_EXIST);\n', '\n', '        // Set the new value for the requested leaf node\n', '        uint256 lastValue = getItem(self, _key);\n', '        _add(self, ITEMS_LEVEL, _key, _time, _value);\n', '\n', '        // Update sums cached in the non-leaf nodes. Note that overflows are being checked at the end of the whole update.\n', '        if (_value > lastValue) {\n', '            _updateSums(self, _key, _time, _value - lastValue, true);\n', '        } else if (_value < lastValue) {\n', '            _updateSums(self, _key, _time, lastValue - _value, false);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Update the value of a non-leaf node indexed by its key at given point in time based on a delta\n', '    * @param _key Key of the leaf node to be updated in the tree\n', '    * @param _time Point in time to update the given value\n', '    * @param _delta Numeric delta to update the value of the given key\n', '    * @param _positive Boolean to tell whether the given delta should be added to or subtracted from the current value\n', '    */\n', '    function update(Tree storage self, uint256 _key, uint64 _time, uint256 _delta, bool _positive) internal {\n', '        require(_key < self.nextKey, ERROR_KEY_DOES_NOT_EXIST);\n', '\n', '        // Update the value of the requested leaf node based on the given delta\n', '        uint256 lastValue = getItem(self, _key);\n', '        uint256 newValue = _positive ? lastValue.add(_delta) : lastValue.sub(_delta);\n', '        _add(self, ITEMS_LEVEL, _key, _time, newValue);\n', '\n', '        // Update sums cached in the non-leaf nodes. Note that overflows is being checked at the end of the whole update.\n', '        _updateSums(self, _key, _time, _delta, _positive);\n', '    }\n', '\n', '    /**\n', '    * @dev Search a list of values in the tree at a given point in time. It will return a list with the nearest\n', '    *      high value in case a value cannot be found. This function assumes the given list of given values to be\n', '    *      searched is in ascending order. In case of searching a value out of bounds, it will return zeroed results.\n', '    * @param _values Ordered list of values to be searched in the tree\n', '    * @param _time Point in time to query the values being searched\n', '    * @return keys List of keys found for each requested value in the same order\n', '    * @return values List of node values found for each requested value in the same order\n', '    */\n', '    function search(Tree storage self, uint256[] memory _values, uint64 _time) internal view\n', '        returns (uint256[] memory keys, uint256[] memory values)\n', '    {\n', '        require(_values.length > 0, ERROR_MISSING_SEARCH_VALUES);\n', '\n', '        // Throw out-of-bounds error if there are no items in the tree or the highest value being searched is greater than the total\n', '        uint256 total = getRecentTotalAt(self, _time);\n', '        // No need for SafeMath: positive length of array already checked\n', '        require(total > 0 && total > _values[_values.length - 1], ERROR_SEARCH_OUT_OF_BOUNDS);\n', '\n', '        // Build search params for the first iteration\n', '        uint256 rootLevel = getRecentHeightAt(self, _time);\n', '        SearchParams memory searchParams = SearchParams(_time, rootLevel.sub(1), BASE_KEY, 0, 0);\n', '\n', '        // These arrays will be used to fill in the results. We are passing them as parameters to avoid extra copies\n', '        uint256 length = _values.length;\n', '        keys = new uint256[](length);\n', '        values = new uint256[](length);\n', '        _search(self, _values, searchParams, keys, values);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree\n', '    */\n', '    function getTotal(Tree storage self) internal view returns (uint256) {\n', '        uint256 rootLevel = getHeight(self);\n', '        return getNode(self, rootLevel, BASE_KEY);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree, at a given point in time\n', '    *      It uses a binary search for the root node, a linear one for the height.\n', '    * @param _time Point in time to query the sum of all the items (leaves) stored in the tree\n', '    */\n', '    function getTotalAt(Tree storage self, uint64 _time) internal view returns (uint256) {\n', '        uint256 rootLevel = getRecentHeightAt(self, _time);\n', '        return getNodeAt(self, rootLevel, BASE_KEY, _time);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the sum of the all the items (leaves) stored in the tree, i.e. value of the root of the tree, at a given point in time\n', '    *      It uses a linear search starting from the end.\n', '    * @param _time Point in time to query the sum of all the items (leaves) stored in the tree\n', '    */\n', '    function getRecentTotalAt(Tree storage self, uint64 _time) internal view returns (uint256) {\n', '        uint256 rootLevel = getRecentHeightAt(self, _time);\n', '        return getRecentNodeAt(self, rootLevel, BASE_KEY, _time);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the value of a certain leaf indexed by a given key\n', '    * @param _key Key of the leaf node querying the value of\n', '    */\n', '    function getItem(Tree storage self, uint256 _key) internal view returns (uint256) {\n', '        return getNode(self, ITEMS_LEVEL, _key);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the value of a certain leaf indexed by a given key at a given point in time\n', '    *      It uses a binary search.\n', '    * @param _key Key of the leaf node querying the value of\n', '    * @param _time Point in time to query the value of the requested leaf\n', '    */\n', '    function getItemAt(Tree storage self, uint256 _key, uint64 _time) internal view returns (uint256) {\n', '        return getNodeAt(self, ITEMS_LEVEL, _key, _time);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the value of a certain node indexed by a given (level,key) pair\n', '    * @param _level Level of the node querying the value of\n', '    * @param _key Key of the node querying the value of\n', '    */\n', '    function getNode(Tree storage self, uint256 _level, uint256 _key) internal view returns (uint256) {\n', '        return self.nodes[_level][_key].getLast();\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the value of a certain node indexed by a given (level,key) pair at a given point in time\n', '    *      It uses a binary search.\n', '    * @param _level Level of the node querying the value of\n', '    * @param _key Key of the node querying the value of\n', '    * @param _time Point in time to query the value of the requested node\n', '    */\n', '    function getNodeAt(Tree storage self, uint256 _level, uint256 _key, uint64 _time) internal view returns (uint256) {\n', '        return self.nodes[_level][_key].get(_time);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the value of a certain node indexed by a given (level,key) pair at a given point in time\n', '    *      It uses a linear search starting from the end.\n', '    * @param _level Level of the node querying the value of\n', '    * @param _key Key of the node querying the value of\n', '    * @param _time Point in time to query the value of the requested node\n', '    */\n', '    function getRecentNodeAt(Tree storage self, uint256 _level, uint256 _key, uint64 _time) internal view returns (uint256) {\n', '        return self.nodes[_level][_key].getRecent(_time);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the height of the tree\n', '    */\n', '    function getHeight(Tree storage self) internal view returns (uint256) {\n', '        return self.height.getLast();\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the height of the tree at a given point in time\n', '    *      It uses a linear search starting from the end.\n', '    * @param _time Point in time to query the height of the tree\n', '    */\n', '    function getRecentHeightAt(Tree storage self, uint64 _time) internal view returns (uint256) {\n', '        return self.height.getRecent(_time);\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to update the values of all the ancestors of the given leaf node based on the delta updated\n', '    * @param _key Key of the leaf node to update the ancestors of\n', "    * @param _time Point in time to update the ancestors' values of the given leaf node\n", "    * @param _delta Numeric delta to update the ancestors' values of the given leaf node\n", "    * @param _positive Boolean to tell whether the given delta should be added to or subtracted from ancestors' values\n", '    */\n', '    function _updateSums(Tree storage self, uint256 _key, uint64 _time, uint256 _delta, bool _positive) private {\n', '        uint256 mask = uint256(-1);\n', '        uint256 ancestorKey = _key;\n', '        uint256 currentHeight = getHeight(self);\n', '        for (uint256 level = ITEMS_LEVEL + 1; level <= currentHeight; level++) {\n', '            // Build a mask to get the key of the ancestor at a certain level. For example:\n', "            // Level  0: leaves don't have children\n", '            // Level  1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0 (up to 16 leaves)\n', '            // Level  2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00 (up to 32 leaves)\n', '            // ...\n', '            // Level 63: 0x0000000000000000000000000000000000000000000000000000000000000000 (up to 16^64 leaves - tree max height)\n', '            mask = mask << BITS_IN_NIBBLE;\n', '\n', '            // The key of the ancestor at that level "i" is equivalent to the "(64 - i)-th" most significant nibbles\n', '            // of the ancestor\'s key of the previous level "i - 1". Thus, we can compute the key of an ancestor at a\n', "            // certain level applying the mask to the ancestor's key of the previous level. Note that for the first\n", '            // iteration, the key of the ancestor of the previous level is simply the key of the leaf being updated.\n', '            ancestorKey = ancestorKey & mask;\n', '\n', '            // Update value\n', '            uint256 lastValue = getNode(self, level, ancestorKey);\n', '            uint256 newValue = _positive ? lastValue.add(_delta) : lastValue.sub(_delta);\n', '            _add(self, level, ancestorKey, _time, newValue);\n', '        }\n', '\n', '        // Check if there was an overflow. Note that we only need to check the value stored in the root since the\n', '        // sum only increases going up through the tree.\n', '        require(!_positive || getNode(self, currentHeight, ancestorKey) >= _delta, ERROR_UPDATE_OVERFLOW);\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to add a new level to the tree based on a new key that will be inserted\n', '    * @param _newKey New key willing to be inserted in the tree\n', '    * @param _time Point in time when the new key will be inserted\n', '    */\n', '    function _addLevelIfNecessary(Tree storage self, uint256 _newKey, uint64 _time) private {\n', '        uint256 currentHeight = getHeight(self);\n', '        if (_shouldAddLevel(currentHeight, _newKey)) {\n', '            // Max height allowed for the tree is 64 since we are using node keys of 32 bytes. However, note that we\n', '            // are not checking if said limit has been hit when inserting new leaves to the tree, for the purpose of\n', '            // this system having 2^256 items inserted is unrealistic.\n', '            uint256 newHeight = currentHeight + 1;\n', '            uint256 rootValue = getNode(self, currentHeight, BASE_KEY);\n', '            _add(self, newHeight, BASE_KEY, _time, rootValue);\n', '            self.height.add(_time, newHeight);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to register a new value in the history of a node at a given point in time\n', '    * @param _level Level of the node to add a new value at a given point in time to\n', '    * @param _key Key of the node to add a new value at a given point in time to\n', '    * @param _time Point in time to register a value for the given node\n', '    * @param _value Numeric value to be registered for the given node at a given point in time\n', '    */\n', '    function _add(Tree storage self, uint256 _level, uint256 _key, uint64 _time, uint256 _value) private {\n', '        self.nodes[_level][_key].add(_time, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev Recursive pre-order traversal function\n', '    *      Every time it checks a node, it traverses the input array to find the initial subset of elements that are\n', '    *      below its accumulated value and passes that sub-array to the next iteration. Actually, the array is always\n', '    *      the same, to avoid making extra copies, it just passes the number of values already found , to avoid\n', '    *      checking values that went through a different branch. The same happens with the result lists of keys and\n', '    *      values, these are the same on every recursion step. The visited total is carried over each iteration to\n', '    *      avoid having to subtract all elements in the array.\n', '    * @param _values Ordered list of values to be searched in the tree\n', '    * @param _params Search parameters for the current recursive step\n', '    * @param _resultKeys List of keys found for each requested value in the same order\n', '    * @param _resultValues List of node values found for each requested value in the same order\n', '    */\n', '    function _search(\n', '        Tree storage self,\n', '        uint256[] memory _values,\n', '        SearchParams memory _params,\n', '        uint256[] memory _resultKeys,\n', '        uint256[] memory _resultValues\n', '    )\n', '        private\n', '        view\n', '    {\n', '        uint256 levelKeyLessSignificantNibble = _params.level.mul(BITS_IN_NIBBLE);\n', '\n', '        for (uint256 childNumber = 0; childNumber < CHILDREN; childNumber++) {\n', '            // Return if we already found enough values\n', '            if (_params.foundValues >= _values.length) {\n', '                break;\n', '            }\n', '\n', '            // Build child node key shifting the child number to the position of the less significant nibble of\n', '            // the keys for the level being analyzed, and adding it to the key of the parent node. For example,\n', '            // for a tree with height 5, if we are checking the children of the second node of the level 3, whose\n', '            // key is    0x0000000000000000000000000000000000000000000000000000000000001000, its children keys are:\n', '            // Child  0: 0x0000000000000000000000000000000000000000000000000000000000001000\n', '            // Child  1: 0x0000000000000000000000000000000000000000000000000000000000001100\n', '            // Child  2: 0x0000000000000000000000000000000000000000000000000000000000001200\n', '            // ...\n', '            // Child 15: 0x0000000000000000000000000000000000000000000000000000000000001f00\n', '            uint256 childNodeKey = _params.parentKey.add(childNumber << levelKeyLessSignificantNibble);\n', '            uint256 childNodeValue = getRecentNodeAt(self, _params.level, childNodeKey, _params.time);\n', '\n', '            // Check how many values belong to the subtree of this node. As they are ordered, it will be a contiguous\n', '            // subset starting from the beginning, so we only need to know the length of that subset.\n', '            uint256 newVisitedTotal = _params.visitedTotal.add(childNodeValue);\n', '            uint256 subtreeIncludedValues = _getValuesIncludedInSubtree(_values, _params.foundValues, newVisitedTotal);\n', '\n', '            // If there are some values included in the subtree of the child node, visit them\n', '            if (subtreeIncludedValues > 0) {\n', '                // If the child node being analyzed is a leaf, add it to the list of results a number of times equals\n', '                // to the number of values that were included in it. Otherwise, descend one level.\n', '                if (_params.level == ITEMS_LEVEL) {\n', '                    _copyFoundNode(_params.foundValues, subtreeIncludedValues, childNodeKey, _resultKeys, childNodeValue, _resultValues);\n', '                } else {\n', '                    SearchParams memory nextLevelParams = SearchParams(\n', '                        _params.time,\n', '                        _params.level - 1, // No need for SafeMath: we already checked above that the level being checked is greater than zero\n', '                        childNodeKey,\n', '                        _params.foundValues,\n', '                        _params.visitedTotal\n', '                    );\n', '                    _search(self, _values, nextLevelParams, _resultKeys, _resultValues);\n', '                }\n', '                // Update the number of values that were already found\n', '                _params.foundValues = _params.foundValues.add(subtreeIncludedValues);\n', '            }\n', '            // Update the visited total for the next node in this level\n', '            _params.visitedTotal = newVisitedTotal;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to check if a new key can be added to the tree based on the current height of the tree\n', '    * @param _currentHeight Current height of the tree to check if it supports adding the given key\n', '    * @param _newKey Key willing to be added to the tree with the given current height\n', '    * @return True if the current height of the tree should be increased to add the new key, false otherwise.\n', '    */\n', '    function _shouldAddLevel(uint256 _currentHeight, uint256 _newKey) private pure returns (bool) {\n', '        // Build a mask that will match all the possible keys for the given height. For example:\n', '        // Height  1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0 (up to 16 keys)\n', '        // Height  2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00 (up to 32 keys)\n', '        // ...\n', '        // Height 64: 0x0000000000000000000000000000000000000000000000000000000000000000 (up to 16^64 keys - tree max height)\n', '        uint256 shift = _currentHeight.mul(BITS_IN_NIBBLE);\n', '        uint256 mask = uint256(-1) << shift;\n', '\n', '        // Check if the given key can be represented in the tree with the current given height using the mask.\n', '        return (_newKey & mask) != 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to tell how many values of a list can be found in a subtree\n', '    * @param _values List of values being searched in ascending order\n', '    * @param _foundValues Number of values that were already found and should be ignore\n', '    * @param _subtreeTotal Total sum of the given subtree to check the numbers that are included in it\n', '    * @return Number of values in the list that are included in the given subtree\n', '    */\n', '    function _getValuesIncludedInSubtree(uint256[] memory _values, uint256 _foundValues, uint256 _subtreeTotal) private pure returns (uint256) {\n', '        // Look for all the values that can be found in the given subtree\n', '        uint256 i = _foundValues;\n', '        while (i < _values.length && _values[i] < _subtreeTotal) {\n', '            i++;\n', '        }\n', '        return i - _foundValues;\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to copy a node a given number of times to a results list. This function assumes the given\n', '    *      results list have enough size to support the requested copy.\n', '    * @param _from Index of the results list to start copying the given node\n', '    * @param _times Number of times the given node will be copied\n', '    * @param _key Key of the node to be copied\n', '    * @param _resultKeys Lists of key results to copy the given node key to\n', '    * @param _value Value of the node to be copied\n', '    * @param _resultValues Lists of value results to copy the given node value to\n', '    */\n', '    function _copyFoundNode(\n', '        uint256 _from,\n', '        uint256 _times,\n', '        uint256 _key,\n', '        uint256[] memory _resultKeys,\n', '        uint256 _value,\n', '        uint256[] memory _resultValues\n', '    )\n', '        private\n', '        pure\n', '    {\n', '        for (uint256 i = 0; i < _times; i++) {\n', '            _resultKeys[_from + i] = _key;\n', '            _resultValues[_from + i] = _value;\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', '* @title GuardiansTreeSortition - Library to perform guardians sortition over a `HexSumTree`\n', '*/\n', 'library GuardiansTreeSortition {\n', '    using SafeMath for uint256;\n', '    using HexSumTree for HexSumTree.Tree;\n', '\n', '    string private constant ERROR_INVALID_INTERVAL_SEARCH = "TREE_INVALID_INTERVAL_SEARCH";\n', '    string private constant ERROR_SORTITION_LENGTHS_MISMATCH = "TREE_SORTITION_LENGTHS_MISMATCH";\n', '\n', '    /**\n', '    * @dev Search random items in the tree based on certain restrictions\n', '    * @param _termRandomness Randomness to compute the seed for the draft\n', '    * @param _disputeId Identification number of the dispute to draft guardians for\n', '    * @param _termId Current term when the draft is being computed\n', '    * @param _selectedGuardians Number of guardians already selected for the draft\n', '    * @param _batchRequestedGuardians Number of guardians to be selected in the given batch of the draft\n', '    * @param _roundRequestedGuardians Total number of guardians requested to be drafted\n', '    * @param _sortitionIteration Number of sortitions already performed for the given draft\n', '    * @return guardiansIds List of guardian ids obtained based on the requested search\n', '    * @return guardiansBalances List of active balances for each guardian obtained based on the requested search\n', '    */\n', '    function batchedRandomSearch(\n', '        HexSumTree.Tree storage tree,\n', '        bytes32 _termRandomness,\n', '        uint256 _disputeId,\n', '        uint64 _termId,\n', '        uint256 _selectedGuardians,\n', '        uint256 _batchRequestedGuardians,\n', '        uint256 _roundRequestedGuardians,\n', '        uint256 _sortitionIteration\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256[] memory guardiansIds, uint256[] memory guardiansBalances)\n', '    {\n', '        (uint256 low, uint256 high) = getSearchBatchBounds(\n', '            tree,\n', '            _termId,\n', '            _selectedGuardians,\n', '            _batchRequestedGuardians,\n', '            _roundRequestedGuardians\n', '        );\n', '\n', '        uint256[] memory balances = _computeSearchRandomBalances(\n', '            _termRandomness,\n', '            _disputeId,\n', '            _sortitionIteration,\n', '            _batchRequestedGuardians,\n', '            low,\n', '            high\n', '        );\n', '\n', '        (guardiansIds, guardiansBalances) = tree.search(balances, _termId);\n', '\n', '        require(guardiansIds.length == guardiansBalances.length, ERROR_SORTITION_LENGTHS_MISMATCH);\n', '        require(guardiansIds.length == _batchRequestedGuardians, ERROR_SORTITION_LENGTHS_MISMATCH);\n', '    }\n', '\n', '    /**\n', '    * @dev Get the bounds for a draft batch based on the active balances of the guardians\n', '    * @param _termId Term ID of the active balances that will be used to compute the boundaries\n', '    * @param _selectedGuardians Number of guardians already selected for the draft\n', '    * @param _batchRequestedGuardians Number of guardians to be selected in the given batch of the draft\n', '    * @param _roundRequestedGuardians Total number of guardians requested to be drafted\n', '    * @return low Low bound to be used for the sortition to draft the requested number of guardians for the given batch\n', '    * @return high High bound to be used for the sortition to draft the requested number of guardians for the given batch\n', '    */\n', '    function getSearchBatchBounds(\n', '        HexSumTree.Tree storage tree,\n', '        uint64 _termId,\n', '        uint256 _selectedGuardians,\n', '        uint256 _batchRequestedGuardians,\n', '        uint256 _roundRequestedGuardians\n', '    )\n', '        internal\n', '        view\n', '        returns (uint256 low, uint256 high)\n', '    {\n', '        uint256 totalActiveBalance = tree.getRecentTotalAt(_termId);\n', '        low = _selectedGuardians.mul(totalActiveBalance).div(_roundRequestedGuardians);\n', '\n', '        uint256 newSelectedGuardians = _selectedGuardians.add(_batchRequestedGuardians);\n', '        high = newSelectedGuardians.mul(totalActiveBalance).div(_roundRequestedGuardians);\n', '    }\n', '\n', '    /**\n', '    * @dev Get a random list of active balances to be searched in the guardians tree for a given draft batch\n', '    * @param _termRandomness Randomness to compute the seed for the draft\n', '    * @param _disputeId Identification number of the dispute to draft guardians for (for randomness)\n', '    * @param _sortitionIteration Number of sortitions already performed for the given draft (for randomness)\n', '    * @param _batchRequestedGuardians Number of guardians to be selected in the given batch of the draft\n', '    * @param _lowBatchBound Low bound to be used for the sortition batch to draft the requested number of guardians\n', '    * @param _highBatchBound High bound to be used for the sortition batch to draft the requested number of guardians\n', '    * @return Random list of active balances to be searched in the guardians tree for the given draft batch\n', '    */\n', '    function _computeSearchRandomBalances(\n', '        bytes32 _termRandomness,\n', '        uint256 _disputeId,\n', '        uint256 _sortitionIteration,\n', '        uint256 _batchRequestedGuardians,\n', '        uint256 _lowBatchBound,\n', '        uint256 _highBatchBound\n', '    )\n', '        internal\n', '        pure\n', '        returns (uint256[] memory)\n', '    {\n', '        // Calculate the interval to be used to search the balances in the tree. Since we are using a modulo function to compute the\n', '        // random balances to be searched, intervals will be closed on the left and open on the right, for example [0,10).\n', '        require(_highBatchBound > _lowBatchBound, ERROR_INVALID_INTERVAL_SEARCH);\n', '        uint256 interval = _highBatchBound - _lowBatchBound;\n', '\n', '        // Compute an ordered list of random active balance to be searched in the guardians tree\n', '        uint256[] memory balances = new uint256[](_batchRequestedGuardians);\n', '        for (uint256 batchGuardianNumber = 0; batchGuardianNumber < _batchRequestedGuardians; batchGuardianNumber++) {\n', '            // Compute a random seed using:\n', '            // - The inherent randomness associated to the term from blockhash\n', '            // - The disputeId, so 2 disputes in the same term will have different outcomes\n', '            // - The sortition iteration, to avoid getting stuck if resulting guardians are dismissed due to locked balance\n', '            // - The guardian number in this batch\n', '            bytes32 seed = keccak256(abi.encodePacked(_termRandomness, _disputeId, _sortitionIteration, batchGuardianNumber));\n', '\n', '            // Compute a random active balance to be searched in the guardians tree using the generated seed within the\n', '            // boundaries computed for the current batch.\n', '            balances[batchGuardianNumber] = _lowBatchBound.add(uint256(seed) % interval);\n', '\n', "            // Make sure it's ordered, flip values if necessary\n", '            for (uint256 i = batchGuardianNumber; i > 0 && balances[i] < balances[i - 1]; i--) {\n', '                uint256 tmp = balances[i - 1];\n', '                balances[i - 1] = balances[i];\n', '                balances[i] = tmp;\n', '            }\n', '        }\n', '        return balances;\n', '    }\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', 'interface ILockManager {\n', '    /**\n', '    * @dev Tell whether a user can unlock a certain amount of tokens\n', '    */\n', '    function canUnlock(address user, uint256 amount) external view returns (bool);\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', 'interface IGuardiansRegistry {\n', '\n', '    /**\n', '    * @dev Assign a requested amount of guardian tokens to a guardian\n', '    * @param _guardian Guardian to add an amount of tokens to\n', '    * @param _amount Amount of tokens to be added to the available balance of a guardian\n', '    */\n', '    function assignTokens(address _guardian, uint256 _amount) external;\n', '\n', '    /**\n', '    * @dev Burn a requested amount of guardian tokens\n', '    * @param _amount Amount of tokens to be burned\n', '    */\n', '    function burnTokens(uint256 _amount) external;\n', '\n', '    /**\n', '    * @dev Draft a set of guardians based on given requirements for a term id\n', '    * @param _params Array containing draft requirements:\n', '    *        0. bytes32 Term randomness\n', '    *        1. uint256 Dispute id\n', '    *        2. uint64  Current term id\n', '    *        3. uint256 Number of seats already filled\n', '    *        4. uint256 Number of seats left to be filled\n', '    *        5. uint64  Number of guardians required for the draft\n', '    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\n', '    *\n', '    * @return guardians List of guardians selected for the draft\n', '    * @return length Size of the list of the draft result\n', '    */\n', '    function draft(uint256[7] calldata _params) external returns (address[] memory guardians, uint256 length);\n', '\n', '    /**\n', '    * @dev Slash a set of guardians based on their votes compared to the winning ruling\n', '    * @param _termId Current term id\n', '    * @param _guardians List of guardian addresses to be slashed\n', '    * @param _lockedAmounts List of amounts locked for each corresponding guardian that will be either slashed or returned\n', "    * @param _rewardedGuardians List of booleans to tell whether a guardian's active balance has to be slashed or not\n", '    * @return Total amount of slashed tokens\n', '    */\n', '    function slashOrUnlock(uint64 _termId, address[] calldata _guardians, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedGuardians)\n', '        external\n', '        returns (uint256 collectedTokens);\n', '\n', '    /**\n', '    * @dev Try to collect a certain amount of tokens from a guardian for the next term\n', '    * @param _guardian Guardian to collect the tokens from\n', '    * @param _amount Amount of tokens to be collected from the given guardian and for the requested term id\n', '    * @param _termId Current term id\n', '    * @return True if the guardian has enough unlocked tokens to be collected for the requested term, false otherwise\n', '    */\n', '    function collectTokens(address _guardian, uint256 _amount, uint64 _termId) external returns (bool);\n', '\n', '    /**\n', "    * @dev Lock a guardian's withdrawals until a certain term ID\n", '    * @param _guardian Address of the guardian to be locked\n', "    * @param _termId Term ID until which the guardian's withdrawals will be locked\n", '    */\n', '    function lockWithdrawals(address _guardian, uint64 _termId) external;\n', '\n', '    /**\n', '    * @dev Tell the active balance of a guardian for a given term id\n', '    * @param _guardian Address of the guardian querying the active balance of\n', '    * @param _termId Term ID querying the active balance for\n', '    * @return Amount of active tokens for guardian in the requested past term id\n', '    */\n', '    function activeBalanceOfAt(address _guardian, uint64 _termId) external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Tell the total amount of active guardian tokens at the given term id\n', '    * @param _termId Term ID querying the total active balance for\n', '    * @return Total amount of active guardian tokens at the given term id\n', '    */\n', '    function totalActiveBalanceAt(uint64 _termId) external view returns (uint256);\n', '}\n', '\n', '// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/IsContract.sol\n', '// Adapted to use pragma ^0.5.17 and satisfy our linter rules\n', 'contract IsContract {\n', '    /*\n', '    * NOTE: this should NEVER be used for authentication\n', '    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n', '    *\n', '    * This is only intended to be used as a sanity check that an address is actually a contract,\n', '    * RATHER THAN an address not being a contract.\n', '    */\n', '    function isContract(address _target) internal view returns (bool) {\n', '        if (_target == address(0)) {\n', '            return false;\n', '        }\n', '\n', '        uint256 size;\n', '        assembly { size := extcodesize(_target) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'contract ACL {\n', '    string private constant ERROR_BAD_FREEZE = "ACL_BAD_FREEZE";\n', '    string private constant ERROR_ROLE_ALREADY_FROZEN = "ACL_ROLE_ALREADY_FROZEN";\n', '    string private constant ERROR_INVALID_BULK_INPUT = "ACL_INVALID_BULK_INPUT";\n', '\n', '    enum BulkOp { Grant, Revoke, Freeze }\n', '\n', '    address internal constant FREEZE_FLAG = address(1);\n', '    address internal constant ANY_ADDR = address(-1);\n', '\n', '    // List of all roles assigned to different addresses\n', '    mapping (bytes32 => mapping (address => bool)) public roles;\n', '\n', '    event Granted(bytes32 indexed id, address indexed who);\n', '    event Revoked(bytes32 indexed id, address indexed who);\n', '    event Frozen(bytes32 indexed id);\n', '\n', '    /**\n', '    * @dev Tell whether an address has a role assigned\n', '    * @param _who Address being queried\n', '    * @param _id ID of the role being checked\n', '    * @return True if the requested address has assigned the given role, false otherwise\n', '    */\n', '    function hasRole(address _who, bytes32 _id) public view returns (bool) {\n', '        return roles[_id][_who] || roles[_id][ANY_ADDR];\n', '    }\n', '\n', '    /**\n', '    * @dev Tell whether a role is frozen\n', '    * @param _id ID of the role being checked\n', '    * @return True if the given role is frozen, false otherwise\n', '    */\n', '    function isRoleFrozen(bytes32 _id) public view returns (bool) {\n', '        return roles[_id][FREEZE_FLAG];\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to grant a role to a given address\n', '    * @param _id ID of the role to be granted\n', '    * @param _who Address to grant the role to\n', '    */\n', '    function _grant(bytes32 _id, address _who) internal {\n', '        require(!isRoleFrozen(_id), ERROR_ROLE_ALREADY_FROZEN);\n', '        require(_who != FREEZE_FLAG, ERROR_BAD_FREEZE);\n', '\n', '        if (!hasRole(_who, _id)) {\n', '            roles[_id][_who] = true;\n', '            emit Granted(_id, _who);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to revoke a role from a given address\n', '    * @param _id ID of the role to be revoked\n', '    * @param _who Address to revoke the role from\n', '    */\n', '    function _revoke(bytes32 _id, address _who) internal {\n', '        require(!isRoleFrozen(_id), ERROR_ROLE_ALREADY_FROZEN);\n', '\n', '        if (hasRole(_who, _id)) {\n', '            roles[_id][_who] = false;\n', '            emit Revoked(_id, _who);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to freeze a role\n', '    * @param _id ID of the role to be frozen\n', '    */\n', '    function _freeze(bytes32 _id) internal {\n', '        require(!isRoleFrozen(_id), ERROR_ROLE_ALREADY_FROZEN);\n', '        roles[_id][FREEZE_FLAG] = true;\n', '        emit Frozen(_id);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to enact a bulk list of ACL operations\n', '    */\n', '    function _bulk(BulkOp[] memory _op, bytes32[] memory _id, address[] memory _who) internal {\n', '        require(_op.length == _id.length && _op.length == _who.length, ERROR_INVALID_BULK_INPUT);\n', '\n', '        for (uint256 i = 0; i < _op.length; i++) {\n', '            BulkOp op = _op[i];\n', '            if (op == BulkOp.Grant) {\n', '                _grant(_id[i], _who[i]);\n', '            } else if (op == BulkOp.Revoke) {\n', '                _revoke(_id[i], _who[i]);\n', '            } else if (op == BulkOp.Freeze) {\n', '                _freeze(_id[i]);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract ModuleIds {\n', '    // DisputeManager module ID - keccak256(abi.encodePacked("DISPUTE_MANAGER"))\n', '    bytes32 internal constant MODULE_ID_DISPUTE_MANAGER = 0x14a6c70f0f6d449c014c7bbc9e68e31e79e8474fb03b7194df83109a2d888ae6;\n', '\n', '    // GuardiansRegistry module ID - keccak256(abi.encodePacked("GUARDIANS_REGISTRY"))\n', '    bytes32 internal constant MODULE_ID_GUARDIANS_REGISTRY = 0x8af7b7118de65da3b974a3fd4b0c702b66442f74b9dff6eaed1037254c0b79fe;\n', '\n', '    // Voting module ID - keccak256(abi.encodePacked("VOTING"))\n', '    bytes32 internal constant MODULE_ID_VOTING = 0x7cbb12e82a6d63ff16fe43977f43e3e2b247ecd4e62c0e340da8800a48c67346;\n', '\n', '    // PaymentsBook module ID - keccak256(abi.encodePacked("PAYMENTS_BOOK"))\n', '    bytes32 internal constant MODULE_ID_PAYMENTS_BOOK = 0xfa275b1417437a2a2ea8e91e9fe73c28eaf0a28532a250541da5ac0d1892b418;\n', '\n', '    // Treasury module ID - keccak256(abi.encodePacked("TREASURY"))\n', '    bytes32 internal constant MODULE_ID_TREASURY = 0x06aa03964db1f7257357ef09714a5f0ca3633723df419e97015e0c7a3e83edb7;\n', '}\n', '\n', 'interface IModulesLinker {\n', '    /**\n', '    * @notice Update the implementations of a list of modules\n', '    * @param _ids List of IDs of the modules to be updated\n', '    * @param _addresses List of module addresses to be updated\n', '    */\n', '    function linkModules(bytes32[] calldata _ids, address[] calldata _addresses) external;\n', '}\n', '\n', '// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/lib/math/SafeMath64.sol\n', '// Adapted to use pragma ^0.5.17 and satisfy our linter rules\n', '/**\n', ' * @title SafeMath64\n', ' * @dev Math operations for uint64 with safety checks that revert on error\n', ' */\n', 'library SafeMath64 {\n', '    string private constant ERROR_ADD_OVERFLOW = "MATH64_ADD_OVERFLOW";\n', '    string private constant ERROR_SUB_UNDERFLOW = "MATH64_SUB_UNDERFLOW";\n', '    string private constant ERROR_MUL_OVERFLOW = "MATH64_MUL_OVERFLOW";\n', '    string private constant ERROR_DIV_ZERO = "MATH64_DIV_ZERO";\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, reverts on overflow.\n', '    */\n', '    function mul(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '        uint256 c = uint256(_a) * uint256(_b);\n', '        require(c < 0x010000000000000000, ERROR_MUL_OVERFLOW); // 2**64 (less gas this way)\n', '\n', '        return uint64(c);\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n', '        uint64 c = _a / _b;\n', "        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n', '        uint64 c = _a - _b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, reverts on overflow.\n', '    */\n', '    function add(uint64 _a, uint64 _b) internal pure returns (uint64) {\n', '        uint64 c = _a + _b;\n', '        require(c >= _a, ERROR_ADD_OVERFLOW);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\n', '        require(b != 0, ERROR_DIV_ZERO);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/Uint256Helpers.sol\n', '// Adapted to use pragma ^0.5.17 and satisfy our linter rules\n', 'library Uint256Helpers {\n', '    uint256 private constant MAX_UINT8 = uint8(-1);\n', '    uint256 private constant MAX_UINT64 = uint64(-1);\n', '\n', '    string private constant ERROR_UINT8_NUMBER_TOO_BIG = "UINT8_NUMBER_TOO_BIG";\n', '    string private constant ERROR_UINT64_NUMBER_TOO_BIG = "UINT64_NUMBER_TOO_BIG";\n', '\n', '    function toUint8(uint256 a) internal pure returns (uint8) {\n', '        require(a <= MAX_UINT8, ERROR_UINT8_NUMBER_TOO_BIG);\n', '        return uint8(a);\n', '    }\n', '\n', '    function toUint64(uint256 a) internal pure returns (uint64) {\n', '        require(a <= MAX_UINT64, ERROR_UINT64_NUMBER_TOO_BIG);\n', '        return uint64(a);\n', '    }\n', '}\n', '\n', '// Brought from https://github.com/aragon/aragonOS/blob/v4.3.0/contracts/common/TimeHelpers.sol\n', '// Adapted to use pragma ^0.5.17 and satisfy our linter rules\n', 'contract TimeHelpers {\n', '    using Uint256Helpers for uint256;\n', '\n', '    /**\n', '    * @dev Returns the current block number.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber() internal view returns (uint256) {\n', '        return block.number;\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current block number, converted to uint64.\n', '    *      Using a function rather than `block.number` allows us to easily mock the block number in\n', '    *      tests.\n', '    */\n', '    function getBlockNumber64() internal view returns (uint64) {\n', '        return getBlockNumber().toUint64();\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current timestamp.\n', '    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n', '    *      tests.\n', '    */\n', '    function getTimestamp() internal view returns (uint256) {\n', '        return block.timestamp; // solium-disable-line security/no-block-members\n', '    }\n', '\n', '    /**\n', '    * @dev Returns the current timestamp, converted to uint64.\n', '    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n', '    *      tests.\n', '    */\n', '    function getTimestamp64() internal view returns (uint64) {\n', '        return getTimestamp().toUint64();\n', '    }\n', '}\n', '\n', 'interface IClock {\n', '    /**\n', '    * @dev Ensure that the current term of the clock is up-to-date\n', '    * @return Identification number of the current term\n', '    */\n', '    function ensureCurrentTerm() external returns (uint64);\n', '\n', '    /**\n', '    * @dev Transition up to a certain number of terms to leave the clock up-to-date\n', '    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n', '    * @return Identification number of the term ID after executing the heartbeat transitions\n', '    */\n', '    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64);\n', '\n', '    /**\n', '    * @dev Ensure that a certain term has its randomness set\n', '    * @return Randomness of the current term\n', '    */\n', '    function ensureCurrentTermRandomness() external returns (bytes32);\n', '\n', '    /**\n', '    * @dev Tell the last ensured term identification number\n', '    * @return Identification number of the last ensured term\n', '    */\n', '    function getLastEnsuredTermId() external view returns (uint64);\n', '\n', '    /**\n', '    * @dev Tell the current term identification number. Note that there may be pending term transitions.\n', '    * @return Identification number of the current term\n', '    */\n', '    function getCurrentTermId() external view returns (uint64);\n', '\n', '    /**\n', '    * @dev Tell the number of terms the clock should transition to be up-to-date\n', '    * @return Number of terms the clock should transition to be up-to-date\n', '    */\n', '    function getNeededTermTransitions() external view returns (uint64);\n', '\n', '    /**\n', '    * @dev Tell the information related to a term based on its ID\n', '    * @param _termId ID of the term being queried\n', '    * @return startTime Term start time\n', '    * @return randomnessBN Block number used for randomness in the requested term\n', '    * @return randomness Randomness computed for the requested term\n', '    */\n', '    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness);\n', '\n', '    /**\n', "    * @dev Tell the randomness of a term even if it wasn't computed yet\n", '    * @param _termId Identification number of the term being queried\n', '    * @return Randomness of the requested term\n', '    */\n', '    function getTermRandomness(uint64 _termId) external view returns (bytes32);\n', '}\n', '\n', 'contract CourtClock is IClock, TimeHelpers {\n', '    using SafeMath64 for uint64;\n', '\n', '    string private constant ERROR_TERM_DOES_NOT_EXIST = "CLK_TERM_DOES_NOT_EXIST";\n', '    string private constant ERROR_TERM_DURATION_TOO_LONG = "CLK_TERM_DURATION_TOO_LONG";\n', '    string private constant ERROR_TERM_RANDOMNESS_NOT_YET = "CLK_TERM_RANDOMNESS_NOT_YET";\n', '    string private constant ERROR_TERM_RANDOMNESS_UNAVAILABLE = "CLK_TERM_RANDOMNESS_UNAVAILABLE";\n', '    string private constant ERROR_BAD_FIRST_TERM_START_TIME = "CLK_BAD_FIRST_TERM_START_TIME";\n', '    string private constant ERROR_TOO_MANY_TRANSITIONS = "CLK_TOO_MANY_TRANSITIONS";\n', '    string private constant ERROR_INVALID_TRANSITION_TERMS = "CLK_INVALID_TRANSITION_TERMS";\n', '    string private constant ERROR_CANNOT_DELAY_STARTED_COURT = "CLK_CANNOT_DELAY_STARTED_PROT";\n', '    string private constant ERROR_CANNOT_DELAY_PAST_START_TIME = "CLK_CANNOT_DELAY_PAST_START_TIME";\n', '\n', '    // Maximum number of term transitions a callee may have to assume in order to call certain functions that require the Court being up-to-date\n', '    uint64 internal constant MAX_AUTO_TERM_TRANSITIONS_ALLOWED = 1;\n', '\n', '    // Max duration in seconds that a term can last\n', '    uint64 internal constant MAX_TERM_DURATION = 365 days;\n', '\n', '    // Max time until first term starts since contract is deployed\n', '    uint64 internal constant MAX_FIRST_TERM_DELAY_PERIOD = 2 * MAX_TERM_DURATION;\n', '\n', '    struct Term {\n', '        uint64 startTime;              // Timestamp when the term started\n', '        uint64 randomnessBN;           // Block number for entropy\n', '        bytes32 randomness;            // Entropy from randomnessBN block hash\n', '    }\n', '\n', '    // Duration in seconds for each term of the Court\n', '    uint64 private termDuration;\n', '\n', '    // Last ensured term id\n', '    uint64 private termId;\n', '\n', '    // List of Court terms indexed by id\n', '    mapping (uint64 => Term) private terms;\n', '\n', '    event Heartbeat(uint64 previousTermId, uint64 currentTermId);\n', '    event StartTimeDelayed(uint64 previousStartTime, uint64 currentStartTime);\n', '\n', '    /**\n', '    * @dev Ensure a certain term has already been processed\n', '    * @param _termId Identification number of the term to be checked\n', '    */\n', '    modifier termExists(uint64 _termId) {\n', '        require(_termId <= termId, ERROR_TERM_DOES_NOT_EXIST);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    * @param _termParams Array containing:\n', '    *        0. _termDuration Duration in seconds per term\n', '    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for guardian on-boarding)\n', '    */\n', '    constructor(uint64[2] memory _termParams) public {\n', '        uint64 _termDuration = _termParams[0];\n', '        uint64 _firstTermStartTime = _termParams[1];\n', '\n', '        require(_termDuration < MAX_TERM_DURATION, ERROR_TERM_DURATION_TOO_LONG);\n', '        require(_firstTermStartTime >= getTimestamp64() + _termDuration, ERROR_BAD_FIRST_TERM_START_TIME);\n', '        require(_firstTermStartTime <= getTimestamp64() + MAX_FIRST_TERM_DELAY_PERIOD, ERROR_BAD_FIRST_TERM_START_TIME);\n', '\n', '        termDuration = _termDuration;\n', '\n', '        // No need for SafeMath: we already checked values above\n', '        terms[0].startTime = _firstTermStartTime - _termDuration;\n', '    }\n', '\n', '    /**\n', '    * @notice Ensure that the current term of the Court is up-to-date. If the Court is outdated by more than `MAX_AUTO_TERM_TRANSITIONS_ALLOWED`\n', '    *         terms, the heartbeat function must be called manually instead.\n', '    * @return Identification number of the current term\n', '    */\n', '    function ensureCurrentTerm() external returns (uint64) {\n', '        return _ensureCurrentTerm();\n', '    }\n', '\n', '    /**\n', '    * @notice Transition up to `_maxRequestedTransitions` terms\n', '    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n', '    * @return Identification number of the term ID after executing the heartbeat transitions\n', '    */\n', '    function heartbeat(uint64 _maxRequestedTransitions) external returns (uint64) {\n', '        return _heartbeat(_maxRequestedTransitions);\n', '    }\n', '\n', '    /**\n', '    * @notice Ensure that a certain term has its randomness set. As we allow to draft disputes requested for previous terms, if there\n', '    *      were mined more than 256 blocks for the current term, the blockhash of its randomness BN is no longer available, given\n', '    *      round will be able to be drafted in the following term.\n', '    * @return Randomness of the current term\n', '    */\n', '    function ensureCurrentTermRandomness() external returns (bytes32) {\n', '        // If the randomness for the given term was already computed, return\n', '        uint64 currentTermId = termId;\n', '        Term storage term = terms[currentTermId];\n', '        bytes32 termRandomness = term.randomness;\n', '        if (termRandomness != bytes32(0)) {\n', '            return termRandomness;\n', '        }\n', '\n', '        // Compute term randomness\n', '        bytes32 newRandomness = _computeTermRandomness(currentTermId);\n', '        require(newRandomness != bytes32(0), ERROR_TERM_RANDOMNESS_UNAVAILABLE);\n', '        term.randomness = newRandomness;\n', '        return newRandomness;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the term duration of the Court\n', '    * @return Duration in seconds of the Court term\n', '    */\n', '    function getTermDuration() external view returns (uint64) {\n', '        return termDuration;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the last ensured term identification number\n', '    * @return Identification number of the last ensured term\n', '    */\n', '    function getLastEnsuredTermId() external view returns (uint64) {\n', '        return _lastEnsuredTermId();\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the current term identification number. Note that there may be pending term transitions.\n', '    * @return Identification number of the current term\n', '    */\n', '    function getCurrentTermId() external view returns (uint64) {\n', '        return _currentTermId();\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the number of terms the Court should transition to be up-to-date\n', '    * @return Number of terms the Court should transition to be up-to-date\n', '    */\n', '    function getNeededTermTransitions() external view returns (uint64) {\n', '        return _neededTermTransitions();\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the information related to a term based on its ID. Note that if the term has not been reached, the\n', "    *      information returned won't be computed yet. This function allows querying future terms that were not computed yet.\n", '    * @param _termId ID of the term being queried\n', '    * @return startTime Term start time\n', '    * @return randomnessBN Block number used for randomness in the requested term\n', '    * @return randomness Randomness computed for the requested term\n', '    */\n', '    function getTerm(uint64 _termId) external view returns (uint64 startTime, uint64 randomnessBN, bytes32 randomness) {\n', '        Term storage term = terms[_termId];\n', '        return (term.startTime, term.randomnessBN, term.randomness);\n', '    }\n', '\n', '    /**\n', "    * @dev Tell the randomness of a term even if it wasn't computed yet\n", '    * @param _termId Identification number of the term being queried\n', '    * @return Randomness of the requested term\n', '    */\n', '    function getTermRandomness(uint64 _termId) external view termExists(_termId) returns (bytes32) {\n', '        return _computeTermRandomness(_termId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to ensure that the current term of the Court is up-to-date. If the Court is outdated by more than\n', '    *      `MAX_AUTO_TERM_TRANSITIONS_ALLOWED` terms, the heartbeat function must be called manually.\n', '    * @return Identification number of the resultant term ID after executing the corresponding transitions\n', '    */\n', '    function _ensureCurrentTerm() internal returns (uint64) {\n', '        // Check the required number of transitions does not exceeds the max allowed number to be processed automatically\n', '        uint64 requiredTransitions = _neededTermTransitions();\n', '        require(requiredTransitions <= MAX_AUTO_TERM_TRANSITIONS_ALLOWED, ERROR_TOO_MANY_TRANSITIONS);\n', '\n', '        // If there are no transitions pending, return the last ensured term id\n', '        if (uint256(requiredTransitions) == 0) {\n', '            return termId;\n', '        }\n', '\n', '        // Process transition if there is at least one pending\n', '        return _heartbeat(requiredTransitions);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to transition the Court terms up to a requested number of terms\n', '    * @param _maxRequestedTransitions Max number of term transitions allowed by the sender\n', '    * @return Identification number of the resultant term ID after executing the requested transitions\n', '    */\n', '    function _heartbeat(uint64 _maxRequestedTransitions) internal returns (uint64) {\n', '        // Transition the minimum number of terms between the amount requested and the amount actually needed\n', '        uint64 neededTransitions = _neededTermTransitions();\n', '        uint256 transitions = uint256(_maxRequestedTransitions < neededTransitions ? _maxRequestedTransitions : neededTransitions);\n', '        require(transitions > 0, ERROR_INVALID_TRANSITION_TERMS);\n', '\n', '        uint64 blockNumber = getBlockNumber64();\n', '        uint64 previousTermId = termId;\n', '        uint64 currentTermId = previousTermId;\n', '        for (uint256 transition = 1; transition <= transitions; transition++) {\n', '            // Term IDs are incremented by one based on the number of time periods since the Court started. Since time is represented in uint64,\n', '            // even if we chose the minimum duration possible for a term (1 second), we can ensure terms will never reach 2^64 since time is\n', '            // already assumed to fit in uint64.\n', '            Term storage previousTerm = terms[currentTermId++];\n', '            Term storage currentTerm = terms[currentTermId];\n', '            _onTermTransitioned(currentTermId);\n', '\n', '            // Set the start time of the new term. Note that we are using a constant term duration value to guarantee\n', '            // equally long terms, regardless of heartbeats.\n', '            currentTerm.startTime = previousTerm.startTime.add(termDuration);\n', '\n', '            // In order to draft a random number of guardians in a term, we use a randomness factor for each term based on a\n', '            // block number that is set once the term has started. Note that this information could not be known beforehand.\n', '            currentTerm.randomnessBN = blockNumber + 1;\n', '        }\n', '\n', '        termId = currentTermId;\n', '        emit Heartbeat(previousTermId, currentTermId);\n', '        return currentTermId;\n', '    }\n', '\n', '    /**\n', "    * @dev Internal function to delay the first term start time only if it wasn't reached yet\n", '    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\n', '    */\n', '    function _delayStartTime(uint64 _newFirstTermStartTime) internal {\n', '        require(_currentTermId() == 0, ERROR_CANNOT_DELAY_STARTED_COURT);\n', '\n', '        Term storage term = terms[0];\n', '        uint64 currentFirstTermStartTime = term.startTime.add(termDuration);\n', '        require(_newFirstTermStartTime > currentFirstTermStartTime, ERROR_CANNOT_DELAY_PAST_START_TIME);\n', '\n', '        // No need for SafeMath: we already checked above that `_newFirstTermStartTime` > `currentFirstTermStartTime` >= `termDuration`\n', '        term.startTime = _newFirstTermStartTime - termDuration;\n', '        emit StartTimeDelayed(currentFirstTermStartTime, _newFirstTermStartTime);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to notify when a term has been transitioned. This function must be overridden to provide custom behavior.\n', '    * @param _termId Identification number of the new current term that has been transitioned\n', '    */\n', '    function _onTermTransitioned(uint64 _termId) internal;\n', '\n', '    /**\n', '    * @dev Internal function to tell the last ensured term identification number\n', '    * @return Identification number of the last ensured term\n', '    */\n', '    function _lastEnsuredTermId() internal view returns (uint64) {\n', '        return termId;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to tell the current term identification number. Note that there may be pending term transitions.\n', '    * @return Identification number of the current term\n', '    */\n', '    function _currentTermId() internal view returns (uint64) {\n', '        return termId.add(_neededTermTransitions());\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to tell the number of terms the Court should transition to be up-to-date\n', '    * @return Number of terms the Court should transition to be up-to-date\n', '    */\n', '    function _neededTermTransitions() internal view returns (uint64) {\n', "        // Note that the Court is always initialized providing a start time for the first-term in the future. If that's the case,\n", '        // no term transitions are required.\n', '        uint64 currentTermStartTime = terms[termId].startTime;\n', '        if (getTimestamp64() < currentTermStartTime) {\n', '            return uint64(0);\n', '        }\n', '\n', '        // No need for SafeMath: we already know that the start time of the current term is in the past\n', '        return (getTimestamp64() - currentTermStartTime) / termDuration;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to compute the randomness that will be used to draft guardians for the given term. This\n', '    *      function assumes the given term exists. To determine the randomness factor for a term we use the hash of a\n', '    *      block number that is set once the term has started to ensure it cannot be known beforehand. Note that the\n', '    *      hash function being used only works for the 256 most recent block numbers.\n', '    * @param _termId Identification number of the term being queried\n', '    * @return Randomness computed for the given term\n', '    */\n', '    function _computeTermRandomness(uint64 _termId) internal view returns (bytes32) {\n', '        Term storage term = terms[_termId];\n', '        require(getBlockNumber64() > term.randomnessBN, ERROR_TERM_RANDOMNESS_NOT_YET);\n', '        return blockhash(term.randomnessBN);\n', '    }\n', '}\n', '\n', 'interface IConfig {\n', '\n', '    /**\n', '    * @dev Tell the full Court configuration parameters at a certain term\n', '    * @param _termId Identification number of the term querying the Court config of\n', '    * @return token Address of the token used to pay for fees\n', '    * @return fees Array containing:\n', '    *         0. guardianFee Amount of fee tokens that is paid per guardian per dispute\n', '    *         1. draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    *         2. settleFee Amount of fee tokens per guardian to cover round settlement cost\n', '    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n', '    *         0. evidenceTerms Max submitting evidence period duration in terms\n', '    *         1. commitTerms Commit period duration in terms\n', '    *         2. revealTerms Reveal period duration in terms\n', '    *         3. appealTerms Appeal period duration in terms\n', '    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n', '    * @return pcts Array containing:\n', '    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (â€± - 1/10,000)\n', '    * @return roundParams Array containing params for rounds:\n', '    *         0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\n', '    *         1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\n', '    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n', '    * @return appealCollateralParams Array containing params for appeal collateral:\n', '    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n', '    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n', '    * @return minActiveBalance Minimum amount of tokens guardians have to activate to participate in the Court\n', '    */\n', '    function getConfig(uint64 _termId) external view\n', '        returns (\n', '            IERC20 feeToken,\n', '            uint256[3] memory fees,\n', '            uint64[5] memory roundStateDurations,\n', '            uint16[2] memory pcts,\n', '            uint64[4] memory roundParams,\n', '            uint256[2] memory appealCollateralParams,\n', '            uint256 minActiveBalance\n', '        );\n', '\n', '    /**\n', '    * @dev Tell the draft config at a certain term\n', '    * @param _termId Identification number of the term querying the draft config of\n', '    * @return feeToken Address of the token used to pay for fees\n', '    * @return draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    */\n', '    function getDraftConfig(uint64 _termId) external view returns (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\n', '\n', '    /**\n', '    * @dev Tell the min active balance config at a certain term\n', '    * @param _termId Term querying the min active balance config of\n', '    * @return Minimum amount of tokens guardians have to activate to participate in the Court\n', '    */\n', '    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\n', '}\n', '\n', 'contract CourtConfigData {\n', '    struct Config {\n', '        FeesConfig fees;                        // Full fees-related config\n', '        DisputesConfig disputes;                // Full disputes-related config\n', '        uint256 minActiveBalance;               // Minimum amount of tokens guardians have to activate to participate in the Court\n', '    }\n', '\n', '    struct FeesConfig {\n', '        IERC20 token;                           // ERC20 token to be used for the fees of the Court\n', '        uint16 finalRoundReduction;             // Permyriad of fees reduction applied for final appeal round (â€± - 1/10,000)\n', '        uint256 guardianFee;                    // Amount of tokens paid to draft a guardian to adjudicate a dispute\n', '        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting guardians\n', '        uint256 settleFee;                      // Amount of tokens paid per round to cover the costs of slashing guardians\n', '    }\n', '\n', '    struct DisputesConfig {\n', '        uint64 evidenceTerms;                   // Max submitting evidence period duration in terms\n', '        uint64 commitTerms;                     // Committing period duration in terms\n', '        uint64 revealTerms;                     // Revealing period duration in terms\n', '        uint64 appealTerms;                     // Appealing period duration in terms\n', '        uint64 appealConfirmTerms;              // Confirmation appeal period duration in terms\n', '        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '        uint64 firstRoundGuardiansNumber;       // Number of guardians drafted on first round\n', '        uint64 appealStepFactor;                // Factor in which the guardians number is increased on each appeal\n', '        uint64 finalRoundLockTerms;             // Period a coherent guardian in the final round will remain locked\n', '        uint256 maxRegularAppealRounds;         // Before the final appeal\n', '        uint256 appealCollateralFactor;         // Permyriad multiple of dispute fees required to appeal a preliminary ruling (â€± - 1/10,000)\n', '        uint256 appealConfirmCollateralFactor;  // Permyriad multiple of dispute fees required to confirm appeal (â€± - 1/10,000)\n', '    }\n', '\n', '    struct DraftConfig {\n', '        IERC20 feeToken;                         // ERC20 token to be used for the fees of the Court\n', '        uint16 penaltyPct;                      // Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '        uint256 draftFee;                       // Amount of tokens paid per round to cover the costs of drafting guardians\n', '    }\n', '}\n', '\n', 'contract CourtConfig is IConfig, CourtConfigData {\n', '    using SafeMath64 for uint64;\n', '    using PctHelpers for uint256;\n', '\n', '    string private constant ERROR_TOO_OLD_TERM = "CONF_TOO_OLD_TERM";\n', '    string private constant ERROR_INVALID_PENALTY_PCT = "CONF_INVALID_PENALTY_PCT";\n', '    string private constant ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT = "CONF_INVALID_FINAL_ROUND_RED_PCT";\n', '    string private constant ERROR_INVALID_MAX_APPEAL_ROUNDS = "CONF_INVALID_MAX_APPEAL_ROUNDS";\n', '    string private constant ERROR_LARGE_ROUND_PHASE_DURATION = "CONF_LARGE_ROUND_PHASE_DURATION";\n', '    string private constant ERROR_BAD_INITIAL_GUARDIANS_NUMBER = "CONF_BAD_INITIAL_GUARDIAN_NUMBER";\n', '    string private constant ERROR_BAD_APPEAL_STEP_FACTOR = "CONF_BAD_APPEAL_STEP_FACTOR";\n', '    string private constant ERROR_ZERO_COLLATERAL_FACTOR = "CONF_ZERO_COLLATERAL_FACTOR";\n', '    string private constant ERROR_ZERO_MIN_ACTIVE_BALANCE = "CONF_ZERO_MIN_ACTIVE_BALANCE";\n', '\n', '    // Max number of terms that each of the different adjudication states can last (if lasted 1h, this would be a year)\n', '    uint64 internal constant MAX_ADJ_STATE_DURATION = 8670;\n', '\n', '    // Cap the max number of regular appeal rounds\n', '    uint256 internal constant MAX_REGULAR_APPEAL_ROUNDS_LIMIT = 10;\n', '\n', '    // Future term ID in which a config change has been scheduled\n', '    uint64 private configChangeTermId;\n', '\n', '    // List of all the configs used in the Court\n', '    Config[] private configs;\n', '\n', '    // List of configs indexed by id\n', '    mapping (uint64 => uint256) private configIdByTerm;\n', '\n', '    event NewConfig(uint64 fromTermId, uint64 courtConfigId);\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    * @param _feeToken Address of the token contract that is used to pay for fees\n', '    * @param _fees Array containing:\n', '    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\n', '    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\n', '    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n', '    *        0. evidenceTerms Max submitting evidence period duration in terms\n', '    *        1. commitTerms Commit period duration in terms\n', '    *        2. revealTerms Reveal period duration in terms\n', '    *        3. appealTerms Appeal period duration in terms\n', '    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n', '    * @param _pcts Array containing:\n', '    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (â€± - 1/10,000)\n', '    * @param _roundParams Array containing params for rounds:\n', '    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\n', '    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\n', '    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n', '    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\n', '    * @param _appealCollateralParams Array containing params for appeal collateral:\n', '    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n', '    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n', '    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\n', '    */\n', '    constructor(\n', '        IERC20 _feeToken,\n', '        uint256[3] memory _fees,\n', '        uint64[5] memory _roundStateDurations,\n', '        uint16[2] memory _pcts,\n', '        uint64[4] memory _roundParams,\n', '        uint256[2] memory _appealCollateralParams,\n', '        uint256 _minActiveBalance\n', '    )\n', '        public\n', '    {\n', '        // Leave config at index 0 empty for non-scheduled config changes\n', '        configs.length = 1;\n', '        _setConfig(\n', '            0,\n', '            0,\n', '            _feeToken,\n', '            _fees,\n', '            _roundStateDurations,\n', '            _pcts,\n', '            _roundParams,\n', '            _appealCollateralParams,\n', '            _minActiveBalance\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the full Court configuration parameters at a certain term\n', '    * @param _termId Identification number of the term querying the Court config of\n', '    * @return token Address of the token used to pay for fees\n', '    * @return fees Array containing:\n', '    *         0. guardianFee Amount of fee tokens that is paid per guardian per dispute\n', '    *         1. draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    *         2. settleFee Amount of fee tokens per guardian to cover round settlement cost\n', '    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n', '    *         0. evidenceTerms Max submitting evidence period duration in terms\n', '    *         1. commitTerms Commit period duration in terms\n', '    *         2. revealTerms Reveal period duration in terms\n', '    *         3. appealTerms Appeal period duration in terms\n', '    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n', '    * @return pcts Array containing:\n', '    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (â€± - 1/10,000)\n', '    * @return roundParams Array containing params for rounds:\n', '    *         0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\n', '    *         1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\n', '    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n', '    * @return appealCollateralParams Array containing params for appeal collateral:\n', '    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n', '    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n', '    * @return minActiveBalance Minimum amount of tokens guardians have to activate to participate in the Court\n', '    */\n', '    function getConfig(uint64 _termId) external view\n', '        returns (\n', '            IERC20 feeToken,\n', '            uint256[3] memory fees,\n', '            uint64[5] memory roundStateDurations,\n', '            uint16[2] memory pcts,\n', '            uint64[4] memory roundParams,\n', '            uint256[2] memory appealCollateralParams,\n', '            uint256 minActiveBalance\n', '        );\n', '\n', '    /**\n', '    * @dev Tell the draft config at a certain term\n', '    * @param _termId Identification number of the term querying the draft config of\n', '    * @return feeToken Address of the token used to pay for fees\n', '    * @return draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    */\n', '    function getDraftConfig(uint64 _termId) external view returns (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct);\n', '\n', '    /**\n', '    * @dev Tell the min active balance config at a certain term\n', '    * @param _termId Term querying the min active balance config of\n', '    * @return Minimum amount of tokens guardians have to activate to participate in the Court\n', '    */\n', '    function getMinActiveBalance(uint64 _termId) external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Tell the term identification number of the next scheduled config change\n', '    * @return Term identification number of the next scheduled config change\n', '    */\n', '    function getConfigChangeTermId() external view returns (uint64) {\n', '        return configChangeTermId;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal to make sure to set a config for the new term, it will copy the previous term config if none\n', '    * @param _termId Identification number of the new current term that has been transitioned\n', '    */\n', '    function _ensureTermConfig(uint64 _termId) internal {\n', '        // If the term being transitioned had no config change scheduled, keep the previous one\n', '        uint256 currentConfigId = configIdByTerm[_termId];\n', '        if (currentConfigId == 0) {\n', '            uint256 previousConfigId = configIdByTerm[_termId.sub(1)];\n', '            configIdByTerm[_termId] = previousConfigId;\n', '        }\n', '    }\n', '\n', '    /**\n', "    * @dev Assumes that sender it's allowed (either it's from governor or it's on init)\n", '    * @param _termId Identification number of the current Court term\n', '    * @param _fromTermId Identification number of the term in which the config will be effective at\n', '    * @param _feeToken Address of the token contract that is used to pay for fees.\n', '    * @param _fees Array containing:\n', '    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\n', '    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\n', '    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n', '    *        0. evidenceTerms Max submitting evidence period duration in terms\n', '    *        1. commitTerms Commit period duration in terms\n', '    *        2. revealTerms Reveal period duration in terms\n', '    *        3. appealTerms Appeal period duration in terms\n', '    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n', '    * @param _pcts Array containing:\n', '    *        0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (â€± - 1/10,000)\n', '    * @param _roundParams Array containing params for rounds:\n', '    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\n', '    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\n', '    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n', '    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\n', '    * @param _appealCollateralParams Array containing params for appeal collateral:\n', '    *        0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n', '    *        1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n', '    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\n', '    */\n', '    function _setConfig(\n', '        uint64 _termId,\n', '        uint64 _fromTermId,\n', '        IERC20 _feeToken,\n', '        uint256[3] memory _fees,\n', '        uint64[5] memory _roundStateDurations,\n', '        uint16[2] memory _pcts,\n', '        uint64[4] memory _roundParams,\n', '        uint256[2] memory _appealCollateralParams,\n', '        uint256 _minActiveBalance\n', '    )\n', '        internal\n', '    {\n', '        // If the current term is not zero, changes must be scheduled at least after the current period.\n', '        // No need to ensure delays for on-going disputes since these already use their creation term for that.\n', '        require(_termId == 0 || _fromTermId > _termId, ERROR_TOO_OLD_TERM);\n', '\n', '        // Make sure appeal collateral factors are greater than zero\n', '        require(_appealCollateralParams[0] > 0 && _appealCollateralParams[1] > 0, ERROR_ZERO_COLLATERAL_FACTOR);\n', '\n', '        // Make sure the given penalty and final round reduction pcts are not greater than 100%\n', '        require(PctHelpers.isValid(_pcts[0]), ERROR_INVALID_PENALTY_PCT);\n', '        require(PctHelpers.isValid(_pcts[1]), ERROR_INVALID_FINAL_ROUND_REDUCTION_PCT);\n', '\n', '        // Disputes must request at least one guardian to be drafted initially\n', '        require(_roundParams[0] > 0, ERROR_BAD_INITIAL_GUARDIANS_NUMBER);\n', '\n', '        // Prevent that further rounds have zero guardians\n', '        require(_roundParams[1] > 0, ERROR_BAD_APPEAL_STEP_FACTOR);\n', '\n', '        // Make sure the max number of appeals allowed does not reach the limit\n', '        uint256 _maxRegularAppealRounds = _roundParams[2];\n', '        bool isMaxAppealRoundsValid = _maxRegularAppealRounds > 0 && _maxRegularAppealRounds <= MAX_REGULAR_APPEAL_ROUNDS_LIMIT;\n', '        require(isMaxAppealRoundsValid, ERROR_INVALID_MAX_APPEAL_ROUNDS);\n', '\n', '        // Make sure each adjudication round phase duration is valid\n', '        for (uint i = 0; i < _roundStateDurations.length; i++) {\n', '            require(_roundStateDurations[i] > 0 && _roundStateDurations[i] < MAX_ADJ_STATE_DURATION, ERROR_LARGE_ROUND_PHASE_DURATION);\n', '        }\n', '\n', '        // Make sure min active balance is not zero\n', '        require(_minActiveBalance > 0, ERROR_ZERO_MIN_ACTIVE_BALANCE);\n', '\n', '        // If there was a config change already scheduled, reset it (in that case we will overwrite last array item).\n', '        // Otherwise, schedule a new config.\n', '        if (configChangeTermId > _termId) {\n', '            configIdByTerm[configChangeTermId] = 0;\n', '        } else {\n', '            configs.length++;\n', '        }\n', '\n', '        uint64 courtConfigId = uint64(configs.length - 1);\n', '        Config storage config = configs[courtConfigId];\n', '\n', '        config.fees = FeesConfig({\n', '            token: _feeToken,\n', '            guardianFee: _fees[0],\n', '            draftFee: _fees[1],\n', '            settleFee: _fees[2],\n', '            finalRoundReduction: _pcts[1]\n', '        });\n', '\n', '        config.disputes = DisputesConfig({\n', '            evidenceTerms: _roundStateDurations[0],\n', '            commitTerms: _roundStateDurations[1],\n', '            revealTerms: _roundStateDurations[2],\n', '            appealTerms: _roundStateDurations[3],\n', '            appealConfirmTerms: _roundStateDurations[4],\n', '            penaltyPct: _pcts[0],\n', '            firstRoundGuardiansNumber: _roundParams[0],\n', '            appealStepFactor: _roundParams[1],\n', '            maxRegularAppealRounds: _maxRegularAppealRounds,\n', '            finalRoundLockTerms: _roundParams[3],\n', '            appealCollateralFactor: _appealCollateralParams[0],\n', '            appealConfirmCollateralFactor: _appealCollateralParams[1]\n', '        });\n', '\n', '        config.minActiveBalance = _minActiveBalance;\n', '\n', '        configIdByTerm[_fromTermId] = courtConfigId;\n', '        configChangeTermId = _fromTermId;\n', '\n', '        emit NewConfig(_fromTermId, courtConfigId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the Court config for a given term\n', '    * @param _termId Identification number of the term querying the Court config of\n', '    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n', '    * @return token Address of the token used to pay for fees\n', '    * @return fees Array containing:\n', '    *         0. guardianFee Amount of fee tokens that is paid per guardian per dispute\n', '    *         1. draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    *         2. settleFee Amount of fee tokens per guardian to cover round settlement cost\n', '    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n', '    *         0. evidenceTerms Max submitting evidence period duration in terms\n', '    *         1. commitTerms Commit period duration in terms\n', '    *         2. revealTerms Reveal period duration in terms\n', '    *         3. appealTerms Appeal period duration in terms\n', '    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n', '    * @return pcts Array containing:\n', '    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (â€± - 1/10,000)\n', '    * @return roundParams Array containing params for rounds:\n', '    *         0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\n', '    *         1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\n', '    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n', '    *         3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\n', '    * @return appealCollateralParams Array containing params for appeal collateral:\n', '    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n', '    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n', '    * @return minActiveBalance Minimum amount of guardian tokens that can be activated\n', '    */\n', '    function _getConfigAt(uint64 _termId, uint64 _lastEnsuredTermId) internal view\n', '        returns (\n', '            IERC20 feeToken,\n', '            uint256[3] memory fees,\n', '            uint64[5] memory roundStateDurations,\n', '            uint16[2] memory pcts,\n', '            uint64[4] memory roundParams,\n', '            uint256[2] memory appealCollateralParams,\n', '            uint256 minActiveBalance\n', '        )\n', '    {\n', '        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n', '\n', '        FeesConfig storage feesConfig = config.fees;\n', '        feeToken = feesConfig.token;\n', '        fees = [feesConfig.guardianFee, feesConfig.draftFee, feesConfig.settleFee];\n', '\n', '        DisputesConfig storage disputesConfig = config.disputes;\n', '        roundStateDurations = [\n', '            disputesConfig.evidenceTerms,\n', '            disputesConfig.commitTerms,\n', '            disputesConfig.revealTerms,\n', '            disputesConfig.appealTerms,\n', '            disputesConfig.appealConfirmTerms\n', '        ];\n', '        pcts = [disputesConfig.penaltyPct, feesConfig.finalRoundReduction];\n', '        roundParams = [\n', '            disputesConfig.firstRoundGuardiansNumber,\n', '            disputesConfig.appealStepFactor,\n', '            uint64(disputesConfig.maxRegularAppealRounds),\n', '            disputesConfig.finalRoundLockTerms\n', '        ];\n', '        appealCollateralParams = [disputesConfig.appealCollateralFactor, disputesConfig.appealConfirmCollateralFactor];\n', '\n', '        minActiveBalance = config.minActiveBalance;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the draft config at a certain term\n', '    * @param _termId Identification number of the term querying the draft config of\n', '    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n', '    * @return feeToken Address of the token used to pay for fees\n', '    * @return draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    */\n', '    function _getDraftConfig(uint64 _termId,  uint64 _lastEnsuredTermId) internal view\n', '        returns (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct)\n', '    {\n', '        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n', '        return (config.fees.token, config.fees.draftFee, config.disputes.penaltyPct);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the min active balance config for a given term\n', '    * @param _termId Identification number of the term querying the min active balance config of\n', '    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n', '    * @return Minimum amount of guardian tokens that can be activated at the given term\n', '    */\n', '    function _getMinActiveBalance(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\n', '        Config storage config = _getConfigFor(_termId, _lastEnsuredTermId);\n', '        return config.minActiveBalance;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the Court config for a given term\n', '    * @param _termId Identification number of the term querying the min active balance config of\n', '    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n', '    * @return Court config for the given term\n', '    */\n', '    function _getConfigFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (Config storage) {\n', '        uint256 id = _getConfigIdFor(_termId, _lastEnsuredTermId);\n', '        return configs[id];\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the Court config ID for a given term\n', '    * @param _termId Identification number of the term querying the Court config of\n', '    * @param _lastEnsuredTermId Identification number of the last ensured term of the Court\n', '    * @return Identification number of the config for the given terms\n', '    */\n', '    function _getConfigIdFor(uint64 _termId, uint64 _lastEnsuredTermId) internal view returns (uint256) {\n', '        // If the given term is lower or equal to the last ensured Court term, it is safe to use a past Court config\n', '        if (_termId <= _lastEnsuredTermId) {\n', '            return configIdByTerm[_termId];\n', '        }\n', '\n', '        // If the given term is in the future but there is a config change scheduled before it, use the incoming config\n', '        uint64 scheduledChangeTermId = configChangeTermId;\n', '        if (scheduledChangeTermId <= _termId) {\n', '            return configIdByTerm[scheduledChangeTermId];\n', '        }\n', '\n', '        // If no changes are scheduled, use the Court config of the last ensured term\n', '        return configIdByTerm[_lastEnsuredTermId];\n', '    }\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', 'interface IArbitrator {\n', '    /**\n', '    * @dev Create a dispute over the Arbitrable sender with a number of possible rulings\n', '    * @param _possibleRulings Number of possible rulings allowed for the dispute\n', '    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n', '    * @return Dispute identification number\n', '    */\n', '    function createDispute(uint256 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n', '\n', '    /**\n', '    * @dev Submit evidence for a dispute\n', '    * @param _disputeId Id of the dispute in the Court\n', '    * @param _submitter Address of the account submitting the evidence\n', '    * @param _evidence Data submitted for the evidence related to the dispute\n', '    */\n', '    function submitEvidence(uint256 _disputeId, address _submitter, bytes calldata _evidence) external;\n', '\n', '    /**\n', '    * @dev Close the evidence period of a dispute\n', '    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n', '    */\n', '    function closeEvidencePeriod(uint256 _disputeId) external;\n', '\n', '    /**\n', '    * @notice Rule dispute #`_disputeId` if ready\n', '    * @param _disputeId Identification number of the dispute to be ruled\n', '    * @return subject Subject associated to the dispute\n', '    * @return ruling Ruling number computed for the given dispute\n', '    */\n', '    function rule(uint256 _disputeId) external returns (address subject, uint256 ruling);\n', '\n', '    /**\n', '    * @dev Tell the dispute fees information to create a dispute\n', '    * @return recipient Address where the corresponding dispute fees must be transferred to\n', '    * @return feeToken ERC20 token used for the fees\n', '    * @return feeAmount Total amount of fees that must be allowed to the recipient\n', '    */\n', '    function getDisputeFees() external view returns (address recipient, IERC20 feeToken, uint256 feeAmount);\n', '\n', '    /**\n', '    * @dev Tell the payments recipient address\n', '    * @return Address of the payments recipient module\n', '    */\n', '    function getPaymentsRecipient() external view returns (address);\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', '/**\n', "* @dev The Arbitrable instances actually don't require to follow any specific interface.\n", '*      Note that this is actually optional, although it does allow the Court to at least have a way to identify a specific set of instances.\n', '*/\n', 'contract IArbitrable {\n', '    /**\n', "    * @dev Emitted when an IArbitrable instance's dispute is ruled by an IArbitrator\n", '    * @param arbitrator IArbitrator instance ruling the dispute\n', '    * @param disputeId Identification number of the dispute being ruled by the arbitrator\n', '    * @param ruling Ruling given by the arbitrator\n', '    */\n', '    event Ruled(IArbitrator indexed arbitrator, uint256 indexed disputeId, uint256 ruling);\n', '}\n', '\n', 'interface IDisputeManager {\n', '    enum DisputeState {\n', '        PreDraft,\n', '        Adjudicating,\n', '        Ruled\n', '    }\n', '\n', '    enum AdjudicationState {\n', '        Invalid,\n', '        Committing,\n', '        Revealing,\n', '        Appealing,\n', '        ConfirmingAppeal,\n', '        Ended\n', '    }\n', '\n', '    /**\n', '    * @dev Create a dispute to be drafted in a future term\n', '    * @param _subject Arbitrable instance creating the dispute\n', '    * @param _possibleRulings Number of possible rulings allowed for the drafted guardians to vote on the dispute\n', '    * @param _metadata Optional metadata that can be used to provide additional information on the dispute to be created\n', '    * @return Dispute identification number\n', '    */\n', '    function createDispute(IArbitrable _subject, uint8 _possibleRulings, bytes calldata _metadata) external returns (uint256);\n', '\n', '    /**\n', '    * @dev Submit evidence for a dispute\n', '    * @param _subject Arbitrable instance submitting the dispute\n', '    * @param _disputeId Identification number of the dispute receiving new evidence\n', '    * @param _submitter Address of the account submitting the evidence\n', '    * @param _evidence Data submitted for the evidence of the dispute\n', '    */\n', '    function submitEvidence(IArbitrable _subject, uint256 _disputeId, address _submitter, bytes calldata _evidence) external;\n', '\n', '    /**\n', '    * @dev Close the evidence period of a dispute\n', '    * @param _subject IArbitrable instance requesting to close the evidence submission period\n', '    * @param _disputeId Identification number of the dispute to close its evidence submitting period\n', '    */\n', '    function closeEvidencePeriod(IArbitrable _subject, uint256 _disputeId) external;\n', '\n', '    /**\n', '    * @dev Draft guardians for the next round of a dispute\n', '    * @param _disputeId Identification number of the dispute to be drafted\n', '    */\n', '    function draft(uint256 _disputeId) external;\n', '\n', '    /**\n', '    * @dev Appeal round of a dispute in favor of a certain ruling\n', '    * @param _disputeId Identification number of the dispute being appealed\n', '    * @param _roundId Identification number of the dispute round being appealed\n', '    * @param _ruling Ruling appealing a dispute round in favor of\n', '    */\n', '    function createAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\n', '\n', '    /**\n', '    * @dev Confirm appeal for a round of a dispute in favor of a ruling\n', '    * @param _disputeId Identification number of the dispute confirming an appeal of\n', '    * @param _roundId Identification number of the dispute round confirming an appeal of\n', '    * @param _ruling Ruling being confirmed against a dispute round appeal\n', '    */\n', '    function confirmAppeal(uint256 _disputeId, uint256 _roundId, uint8 _ruling) external;\n', '\n', '    /**\n', '    * @dev Compute the final ruling for a dispute\n', '    * @param _disputeId Identification number of the dispute to compute its final ruling\n', '    * @return subject Arbitrable instance associated to the dispute\n', '    * @return finalRuling Final ruling decided for the given dispute\n', '    */\n', '    function computeRuling(uint256 _disputeId) external returns (IArbitrable subject, uint8 finalRuling);\n', '\n', '    /**\n', '    * @dev Settle penalties for a round of a dispute\n', '    * @param _disputeId Identification number of the dispute to settle penalties for\n', '    * @param _roundId Identification number of the dispute round to settle penalties for\n', '    * @param _guardiansToSettle Maximum number of guardians to be slashed in this call\n', '    */\n', '    function settlePenalties(uint256 _disputeId, uint256 _roundId, uint256 _guardiansToSettle) external;\n', '\n', '    /**\n', '    * @dev Claim rewards for a round of a dispute for guardian\n', '    * @dev For regular rounds, it will only reward winning guardians\n', '    * @param _disputeId Identification number of the dispute to settle rewards for\n', '    * @param _roundId Identification number of the dispute round to settle rewards for\n', '    * @param _guardian Address of the guardian to settle their rewards\n', '    */\n', '    function settleReward(uint256 _disputeId, uint256 _roundId, address _guardian) external;\n', '\n', '    /**\n', '    * @dev Settle appeal deposits for a round of a dispute\n', '    * @param _disputeId Identification number of the dispute to settle appeal deposits for\n', '    * @param _roundId Identification number of the dispute round to settle appeal deposits for\n', '    */\n', '    function settleAppealDeposit(uint256 _disputeId, uint256 _roundId) external;\n', '\n', '    /**\n', '    * @dev Tell the amount of token fees required to create a dispute\n', '    * @return feeToken ERC20 token used for the fees\n', '    * @return feeAmount Total amount of fees to be paid for a dispute at the given term\n', '    */\n', '    function getDisputeFees() external view returns (IERC20 feeToken, uint256 feeAmount);\n', '\n', '    /**\n', '    * @dev Tell information of a certain dispute\n', '    * @param _disputeId Identification number of the dispute being queried\n', '    * @return subject Arbitrable subject being disputed\n', '    * @return possibleRulings Number of possible rulings allowed for the drafted guardians to vote on the dispute\n', '    * @return state Current state of the dispute being queried: pre-draft, adjudicating, or ruled\n', '    * @return finalRuling The winning ruling in case the dispute is finished\n', '    * @return lastRoundId Identification number of the last round created for the dispute\n', '    * @return createTermId Identification number of the term when the dispute was created\n', '    */\n', '    function getDispute(uint256 _disputeId) external view\n', '        returns (IArbitrable subject, uint8 possibleRulings, DisputeState state, uint8 finalRuling, uint256 lastRoundId, uint64 createTermId);\n', '\n', '    /**\n', '    * @dev Tell information of a certain adjudication round\n', '    * @param _disputeId Identification number of the dispute being queried\n', '    * @param _roundId Identification number of the round being queried\n', '    * @return draftTerm Term from which the requested round can be drafted\n', '    * @return delayedTerms Number of terms the given round was delayed based on its requested draft term id\n', '    * @return guardiansNumber Number of guardians requested for the round\n', '    * @return selectedGuardians Number of guardians already selected for the requested round\n', '    * @return settledPenalties Whether or not penalties have been settled for the requested round\n', '    * @return collectedTokens Amount of guardian tokens that were collected from slashed guardians for the requested round\n', '    * @return coherentGuardians Number of guardians that voted in favor of the final ruling in the requested round\n', '    * @return state Adjudication state of the requested round\n', '    */\n', '    function getRound(uint256 _disputeId, uint256 _roundId) external view\n', '        returns (\n', '            uint64 draftTerm,\n', '            uint64 delayedTerms,\n', '            uint64 guardiansNumber,\n', '            uint64 selectedGuardians,\n', '            uint256 guardianFees,\n', '            bool settledPenalties,\n', '            uint256 collectedTokens,\n', '            uint64 coherentGuardians,\n', '            AdjudicationState state\n', '        );\n', '\n', '    /**\n', '    * @dev Tell appeal-related information of a certain adjudication round\n', '    * @param _disputeId Identification number of the dispute being queried\n', '    * @param _roundId Identification number of the round being queried\n', '    * @return maker Address of the account appealing the given round\n', '    * @return appealedRuling Ruling confirmed by the appealer of the given round\n', '    * @return taker Address of the account confirming the appeal of the given round\n', '    * @return opposedRuling Ruling confirmed by the appeal taker of the given round\n', '    */\n', '    function getAppeal(uint256 _disputeId, uint256 _roundId) external view\n', '        returns (address maker, uint64 appealedRuling, address taker, uint64 opposedRuling);\n', '\n', '    /**\n', '    * @dev Tell information related to the next round due to an appeal of a certain round given.\n', '    * @param _disputeId Identification number of the dispute being queried\n', '    * @param _roundId Identification number of the round requesting the appeal details of\n', '    * @return nextRoundStartTerm Term ID from which the next round will start\n', '    * @return nextRoundGuardiansNumber Guardians number for the next round\n', '    * @return newDisputeState New state for the dispute associated to the given round after the appeal\n', '    * @return feeToken ERC20 token used for the next round fees\n', '    * @return guardianFees Total amount of fees to be distributed between the winning guardians of the next round\n', '    * @return totalFees Total amount of fees for a regular round at the given term\n', '    * @return appealDeposit Amount to be deposit of fees for a regular round at the given term\n', '    * @return confirmAppealDeposit Total amount of fees for a regular round at the given term\n', '    */\n', '    function getNextRoundDetails(uint256 _disputeId, uint256 _roundId) external view\n', '        returns (\n', '            uint64 nextRoundStartTerm,\n', '            uint64 nextRoundGuardiansNumber,\n', '            DisputeState newDisputeState,\n', '            IERC20 feeToken,\n', '            uint256 totalFees,\n', '            uint256 guardianFees,\n', '            uint256 appealDeposit,\n', '            uint256 confirmAppealDeposit\n', '        );\n', '\n', '    /**\n', '    * @dev Tell guardian-related information of a certain adjudication round\n', '    * @param _disputeId Identification number of the dispute being queried\n', '    * @param _roundId Identification number of the round being queried\n', '    * @param _guardian Address of the guardian being queried\n', '    * @return weight Guardian weight drafted for the requested round\n', '    * @return rewarded Whether or not the given guardian was rewarded based on the requested round\n', '    */\n', '    function getGuardian(uint256 _disputeId, uint256 _roundId, address _guardian) external view returns (uint64 weight, bool rewarded);\n', '}\n', '\n', 'contract Controller is IsContract, ModuleIds, CourtClock, CourtConfig, ACL {\n', '    string private constant ERROR_SENDER_NOT_GOVERNOR = "CTR_SENDER_NOT_GOVERNOR";\n', '    string private constant ERROR_INVALID_GOVERNOR_ADDRESS = "CTR_INVALID_GOVERNOR_ADDRESS";\n', '    string private constant ERROR_MODULE_NOT_SET = "CTR_MODULE_NOT_SET";\n', '    string private constant ERROR_MODULE_ALREADY_ENABLED = "CTR_MODULE_ALREADY_ENABLED";\n', '    string private constant ERROR_MODULE_ALREADY_DISABLED = "CTR_MODULE_ALREADY_DISABLED";\n', '    string private constant ERROR_DISPUTE_MANAGER_NOT_ACTIVE = "CTR_DISPUTE_MANAGER_NOT_ACTIVE";\n', '    string private constant ERROR_CUSTOM_FUNCTION_NOT_SET = "CTR_CUSTOM_FUNCTION_NOT_SET";\n', '    string private constant ERROR_IMPLEMENTATION_NOT_CONTRACT = "CTR_IMPLEMENTATION_NOT_CONTRACT";\n', '    string private constant ERROR_INVALID_IMPLS_INPUT_LENGTH = "CTR_INVALID_IMPLS_INPUT_LENGTH";\n', '\n', '    address private constant ZERO_ADDRESS = address(0);\n', '\n', '    /**\n', '    * @dev Governor of the whole system. Set of three addresses to recover funds, change configuration settings and setup modules\n', '    */\n', '    struct Governor {\n', '        address funds;      // This address can be unset at any time. It is allowed to recover funds from the ControlledRecoverable modules\n', '        address config;     // This address is meant not to be unset. It is allowed to change the different configurations of the whole system\n', '        address modules;    // This address can be unset at any time. It is allowed to plug/unplug modules from the system\n', '    }\n', '\n', '    /**\n', '    * @dev Module information\n', '    */\n', '    struct Module {\n', '        bytes32 id;         // ID associated to a module\n', '        bool disabled;      // Whether the module is disabled\n', '    }\n', '\n', '    // Governor addresses of the system\n', '    Governor private governor;\n', '\n', '    // List of current modules registered for the system indexed by ID\n', '    mapping (bytes32 => address) internal currentModules;\n', '\n', '    // List of all historical modules registered for the system indexed by address\n', '    mapping (address => Module) internal allModules;\n', '\n', '    // List of custom function targets indexed by signature\n', '    mapping (bytes4 => address) internal customFunctions;\n', '\n', '    event ModuleSet(bytes32 id, address addr);\n', '    event ModuleEnabled(bytes32 id, address addr);\n', '    event ModuleDisabled(bytes32 id, address addr);\n', '    event CustomFunctionSet(bytes4 signature, address target);\n', '    event FundsGovernorChanged(address previousGovernor, address currentGovernor);\n', '    event ConfigGovernorChanged(address previousGovernor, address currentGovernor);\n', '    event ModulesGovernorChanged(address previousGovernor, address currentGovernor);\n', '\n', '    /**\n', '    * @dev Ensure the msg.sender is the funds governor\n', '    */\n', '    modifier onlyFundsGovernor {\n', '        require(msg.sender == governor.funds, ERROR_SENDER_NOT_GOVERNOR);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Ensure the msg.sender is the modules governor\n', '    */\n', '    modifier onlyConfigGovernor {\n', '        require(msg.sender == governor.config, ERROR_SENDER_NOT_GOVERNOR);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Ensure the msg.sender is the modules governor\n', '    */\n', '    modifier onlyModulesGovernor {\n', '        require(msg.sender == governor.modules, ERROR_SENDER_NOT_GOVERNOR);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Ensure the given dispute manager is active\n', '    */\n', '    modifier onlyActiveDisputeManager(IDisputeManager _disputeManager) {\n', '        require(!_isModuleDisabled(address(_disputeManager)), ERROR_DISPUTE_MANAGER_NOT_ACTIVE);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    * @param _termParams Array containing:\n', '    *        0. _termDuration Duration in seconds per term\n', '    *        1. _firstTermStartTime Timestamp in seconds when the court will open (to give time for guardian on-boarding)\n', '    * @param _governors Array containing:\n', '    *        0. _fundsGovernor Address of the funds governor\n', '    *        1. _configGovernor Address of the config governor\n', '    *        2. _modulesGovernor Address of the modules governor\n', '    * @param _feeToken Address of the token contract that is used to pay for fees\n', '    * @param _fees Array containing:\n', '    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\n', '    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\n', '    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n', '    *        0. evidenceTerms Max submitting evidence period duration in terms\n', '    *        1. commitTerms Commit period duration in terms\n', '    *        2. revealTerms Reveal period duration in terms\n', '    *        3. appealTerms Appeal period duration in terms\n', '    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n', '    * @param _pcts Array containing:\n', '    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted guardians (â€± - 1/10,000)\n', '    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (â€± - 1/10,000)\n', '    * @param _roundParams Array containing params for rounds:\n', '    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\n', '    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\n', '    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n', '    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\n', '    * @param _appealCollateralParams Array containing params for appeal collateral:\n', '    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\n', '    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\n', '    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\n', '    */\n', '    constructor(\n', '        uint64[2] memory _termParams,\n', '        address[3] memory _governors,\n', '        IERC20 _feeToken,\n', '        uint256[3] memory _fees,\n', '        uint64[5] memory _roundStateDurations,\n', '        uint16[2] memory _pcts,\n', '        uint64[4] memory _roundParams,\n', '        uint256[2] memory _appealCollateralParams,\n', '        uint256 _minActiveBalance\n', '    )\n', '        public\n', '        CourtClock(_termParams)\n', '        CourtConfig(_feeToken, _fees, _roundStateDurations, _pcts, _roundParams, _appealCollateralParams, _minActiveBalance)\n', '    {\n', '        _setFundsGovernor(_governors[0]);\n', '        _setConfigGovernor(_governors[1]);\n', '        _setModulesGovernor(_governors[2]);\n', '    }\n', '\n', '    /**\n', '    * @dev Fallback function allows to forward calls to a specific address in case it was previously registered\n', '    *      Note the sender will be always the controller in case it is forwarded\n', '    */\n', '    function () external payable {\n', '        address target = customFunctions[msg.sig];\n', '        require(target != address(0), ERROR_CUSTOM_FUNCTION_NOT_SET);\n', '\n', '        // solium-disable-next-line security/no-call-value\n', '        (bool success,) = address(target).call.value(msg.value)(msg.data);\n', '        assembly {\n', '            let size := returndatasize\n', '            let ptr := mload(0x40)\n', '            returndatacopy(ptr, 0, size)\n', '\n', '            let result := success\n', '            switch result case 0 { revert(ptr, size) }\n', '            default { return(ptr, size) }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Change Court configuration params\n', '    * @param _fromTermId Identification number of the term in which the config will be effective at\n', '    * @param _feeToken Address of the token contract that is used to pay for fees\n', '    * @param _fees Array containing:\n', '    *        0. guardianFee Amount of fee tokens that is paid per guardian per dispute\n', '    *        1. draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    *        2. settleFee Amount of fee tokens per guardian to cover round settlement cost\n', '    * @param _roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n', '    *        0. evidenceTerms Max submitting evidence period duration in terms\n', '    *        1. commitTerms Commit period duration in terms\n', '    *        2. revealTerms Reveal period duration in terms\n', '    *        3. appealTerms Appeal period duration in terms\n', '    *        4. appealConfirmationTerms Appeal confirmation period duration in terms\n', '    * @param _pcts Array containing:\n', '    *        0. penaltyPct Permyriad of min active tokens balance to be locked to each drafted guardians (â€± - 1/10,000)\n', '    *        1. finalRoundReduction Permyriad of fee reduction for the last appeal round (â€± - 1/10,000)\n', '    * @param _roundParams Array containing params for rounds:\n', '    *        0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\n', '    *        1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\n', '    *        2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n', '    *        3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\n', '    * @param _appealCollateralParams Array containing params for appeal collateral:\n', '    *        1. appealCollateralFactor Permyriad multiple of dispute fees required to appeal a preliminary ruling\n', '    *        2. appealConfirmCollateralFactor Permyriad multiple of dispute fees required to confirm appeal\n', '    * @param _minActiveBalance Minimum amount of guardian tokens that can be activated\n', '    */\n', '    function setConfig(\n', '        uint64 _fromTermId,\n', '        IERC20 _feeToken,\n', '        uint256[3] calldata _fees,\n', '        uint64[5] calldata _roundStateDurations,\n', '        uint16[2] calldata _pcts,\n', '        uint64[4] calldata _roundParams,\n', '        uint256[2] calldata _appealCollateralParams,\n', '        uint256 _minActiveBalance\n', '    )\n', '        external\n', '        onlyConfigGovernor\n', '    {\n', '        uint64 currentTermId = _ensureCurrentTerm();\n', '        _setConfig(\n', '            currentTermId,\n', '            _fromTermId,\n', '            _feeToken,\n', '            _fees,\n', '            _roundStateDurations,\n', '            _pcts,\n', '            _roundParams,\n', '            _appealCollateralParams,\n', '            _minActiveBalance\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @notice Delay the Court start time to `_newFirstTermStartTime`\n', '    * @param _newFirstTermStartTime New timestamp in seconds when the court will open\n', '    */\n', '    function delayStartTime(uint64 _newFirstTermStartTime) external onlyConfigGovernor {\n', '        _delayStartTime(_newFirstTermStartTime);\n', '    }\n', '\n', '    /**\n', '    * @notice Change funds governor address to `_newFundsGovernor`\n', '    * @param _newFundsGovernor Address of the new funds governor to be set\n', '    */\n', '    function changeFundsGovernor(address _newFundsGovernor) external onlyFundsGovernor {\n', '        require(_newFundsGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n', '        _setFundsGovernor(_newFundsGovernor);\n', '    }\n', '\n', '    /**\n', '    * @notice Change config governor address to `_newConfigGovernor`\n', '    * @param _newConfigGovernor Address of the new config governor to be set\n', '    */\n', '    function changeConfigGovernor(address _newConfigGovernor) external onlyConfigGovernor {\n', '        require(_newConfigGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n', '        _setConfigGovernor(_newConfigGovernor);\n', '    }\n', '\n', '    /**\n', '    * @notice Change modules governor address to `_newModulesGovernor`\n', '    * @param _newModulesGovernor Address of the new governor to be set\n', '    */\n', '    function changeModulesGovernor(address _newModulesGovernor) external onlyModulesGovernor {\n', '        require(_newModulesGovernor != ZERO_ADDRESS, ERROR_INVALID_GOVERNOR_ADDRESS);\n', '        _setModulesGovernor(_newModulesGovernor);\n', '    }\n', '\n', '    /**\n', '    * @notice Remove the funds governor. Set the funds governor to the zero address.\n', '    * @dev This action cannot be rolled back, once the funds governor has been unset, funds cannot be recovered from recoverable modules anymore\n', '    */\n', '    function ejectFundsGovernor() external onlyFundsGovernor {\n', '        _setFundsGovernor(ZERO_ADDRESS);\n', '    }\n', '\n', '    /**\n', '    * @notice Remove the modules governor. Set the modules governor to the zero address.\n', '    * @dev This action cannot be rolled back, once the modules governor has been unset, system modules cannot be changed anymore\n', '    */\n', '    function ejectModulesGovernor() external onlyModulesGovernor {\n', '        _setModulesGovernor(ZERO_ADDRESS);\n', '    }\n', '\n', '    /**\n', '    * @notice Grant `_id` role to `_who`\n', '    * @param _id ID of the role to be granted\n', '    * @param _who Address to grant the role to\n', '    */\n', '    function grant(bytes32 _id, address _who) external onlyConfigGovernor {\n', '        _grant(_id, _who);\n', '    }\n', '\n', '    /**\n', '    * @notice Revoke `_id` role from `_who`\n', '    * @param _id ID of the role to be revoked\n', '    * @param _who Address to revoke the role from\n', '    */\n', '    function revoke(bytes32 _id, address _who) external onlyConfigGovernor {\n', '        _revoke(_id, _who);\n', '    }\n', '\n', '    /**\n', '    * @notice Freeze `_id` role\n', '    * @param _id ID of the role to be frozen\n', '    */\n', '    function freeze(bytes32 _id) external onlyConfigGovernor {\n', '        _freeze(_id);\n', '    }\n', '\n', '    /**\n', '    * @notice Enact a bulk list of ACL operations\n', '    */\n', '    function bulk(BulkOp[] calldata _op, bytes32[] calldata _id, address[] calldata _who) external onlyConfigGovernor {\n', '        _bulk(_op, _id, _who);\n', '    }\n', '\n', '    /**\n', '    * @notice Set module `_id` to `_addr`\n', '    * @param _id ID of the module to be set\n', '    * @param _addr Address of the module to be set\n', '    */\n', '    function setModule(bytes32 _id, address _addr) external onlyModulesGovernor {\n', '        _setModule(_id, _addr);\n', '    }\n', '\n', '    /**\n', '    * @notice Set and link many modules at once\n', '    * @param _newModuleIds List of IDs of the new modules to be set\n', '    * @param _newModuleAddresses List of addresses of the new modules to be set\n', '    * @param _newModuleLinks List of IDs of the modules that will be linked in the new modules being set\n', '    * @param _currentModulesToBeSynced List of addresses of current modules to be re-linked to the new modules being set\n', '    */\n', '    function setModules(\n', '        bytes32[] calldata _newModuleIds,\n', '        address[] calldata _newModuleAddresses,\n', '        bytes32[] calldata _newModuleLinks,\n', '        address[] calldata _currentModulesToBeSynced\n', '    )\n', '        external\n', '        onlyModulesGovernor\n', '    {\n', '        // We only care about the modules being set, links are optional\n', '        require(_newModuleIds.length == _newModuleAddresses.length, ERROR_INVALID_IMPLS_INPUT_LENGTH);\n', '\n', '        // First set the addresses of the new modules or the modules to be updated\n', '        for (uint256 i = 0; i < _newModuleIds.length; i++) {\n', '            _setModule(_newModuleIds[i], _newModuleAddresses[i]);\n', '        }\n', '\n', '        // Then sync the links of the new modules based on the list of IDs specified (ideally the IDs of their dependencies)\n', '        _syncModuleLinks(_newModuleAddresses, _newModuleLinks);\n', '\n', '        // Finally sync the links of the existing modules to be synced to the new modules being set\n', '        _syncModuleLinks(_currentModulesToBeSynced, _newModuleIds);\n', '    }\n', '\n', '    /**\n', '    * @notice Sync modules for a list of modules IDs based on their current implementation address\n', '    * @param _modulesToBeSynced List of addresses of connected modules to be synced\n', '    * @param _idsToBeSet List of IDs of the modules included in the sync\n', '    */\n', '    function syncModuleLinks(address[] calldata _modulesToBeSynced, bytes32[] calldata _idsToBeSet)\n', '        external\n', '        onlyModulesGovernor\n', '    {\n', '        require(_idsToBeSet.length > 0 && _modulesToBeSynced.length > 0, ERROR_INVALID_IMPLS_INPUT_LENGTH);\n', '        _syncModuleLinks(_modulesToBeSynced, _idsToBeSet);\n', '    }\n', '\n', '    /**\n', '    * @notice Disable module `_addr`\n', '    * @dev Current modules can be disabled to allow pausing the court. However, these can be enabled back again, see `enableModule`\n', '    * @param _addr Address of the module to be disabled\n', '    */\n', '    function disableModule(address _addr) external onlyModulesGovernor {\n', '        Module storage module = allModules[_addr];\n', '        _ensureModuleExists(module);\n', '        require(!module.disabled, ERROR_MODULE_ALREADY_DISABLED);\n', '\n', '        module.disabled = true;\n', '        emit ModuleDisabled(module.id, _addr);\n', '    }\n', '\n', '    /**\n', '    * @notice Enable module `_addr`\n', '    * @param _addr Address of the module to be enabled\n', '    */\n', '    function enableModule(address _addr) external onlyModulesGovernor {\n', '        Module storage module = allModules[_addr];\n', '        _ensureModuleExists(module);\n', '        require(module.disabled, ERROR_MODULE_ALREADY_ENABLED);\n', '\n', '        module.disabled = false;\n', '        emit ModuleEnabled(module.id, _addr);\n', '    }\n', '\n', '    /**\n', '    * @notice Set custom function `_sig` for `_target`\n', '    * @param _sig Signature of the function to be set\n', '    * @param _target Address of the target implementation to be registered for the given signature\n', '    */\n', '    function setCustomFunction(bytes4 _sig, address _target) external onlyModulesGovernor {\n', '        customFunctions[_sig] = _target;\n', '        emit CustomFunctionSet(_sig, _target);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the full Court configuration parameters at a certain term\n', '    * @param _termId Identification number of the term querying the Court config of\n', '    * @return token Address of the token used to pay for fees\n', '    * @return fees Array containing:\n', '    *         0. guardianFee Amount of fee tokens that is paid per guardian per dispute\n', '    *         1. draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    *         2. settleFee Amount of fee tokens per guardian to cover round settlement cost\n', '    * @return roundStateDurations Array containing the durations in terms of the different phases of a dispute:\n', '    *         0. evidenceTerms Max submitting evidence period duration in terms\n', '    *         1. commitTerms Commit period duration in terms\n', '    *         2. revealTerms Reveal period duration in terms\n', '    *         3. appealTerms Appeal period duration in terms\n', '    *         4. appealConfirmationTerms Appeal confirmation period duration in terms\n', '    * @return pcts Array containing:\n', '    *         0. penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    *         1. finalRoundReduction Permyriad of fee reduction for the last appeal round (â€± - 1/10,000)\n', '    * @return roundParams Array containing params for rounds:\n', '    *         0. firstRoundGuardiansNumber Number of guardians to be drafted for the first round of disputes\n', '    *         1. appealStepFactor Increasing factor for the number of guardians of each round of a dispute\n', '    *         2. maxRegularAppealRounds Number of regular appeal rounds before the final round is triggered\n', '    *         3. finalRoundLockTerms Number of terms that a coherent guardian in a final round is disallowed to withdraw (to prevent 51% attacks)\n', '    * @return appealCollateralParams Array containing params for appeal collateral:\n', '    *         0. appealCollateralFactor Multiple of dispute fees required to appeal a preliminary ruling\n', '    *         1. appealConfirmCollateralFactor Multiple of dispute fees required to confirm appeal\n', '    */\n', '    function getConfig(uint64 _termId) external view\n', '        returns (\n', '            IERC20 feeToken,\n', '            uint256[3] memory fees,\n', '            uint64[5] memory roundStateDurations,\n', '            uint16[2] memory pcts,\n', '            uint64[4] memory roundParams,\n', '            uint256[2] memory appealCollateralParams,\n', '            uint256 minActiveBalance\n', '        )\n', '    {\n', '        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n', '        return _getConfigAt(_termId, lastEnsuredTermId);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the draft config at a certain term\n', '    * @param _termId Identification number of the term querying the draft config of\n', '    * @return feeToken Address of the token used to pay for fees\n', '    * @return draftFee Amount of fee tokens per guardian to cover the drafting cost\n', '    * @return penaltyPct Permyriad of min active tokens balance to be locked for each drafted guardian (â€± - 1/10,000)\n', '    */\n', '    function getDraftConfig(uint64 _termId) external view returns (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct) {\n', '        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n', '        return _getDraftConfig(_termId, lastEnsuredTermId);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the min active balance config at a certain term\n', '    * @param _termId Identification number of the term querying the min active balance config of\n', '    * @return Minimum amount of tokens guardians have to activate to participate in the Court\n', '    */\n', '    function getMinActiveBalance(uint64 _termId) external view returns (uint256) {\n', '        uint64 lastEnsuredTermId = _lastEnsuredTermId();\n', '        return _getMinActiveBalance(_termId, lastEnsuredTermId);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the address of the funds governor\n', '    * @return Address of the funds governor\n', '    */\n', '    function getFundsGovernor() external view returns (address) {\n', '        return governor.funds;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the address of the config governor\n', '    * @return Address of the config governor\n', '    */\n', '    function getConfigGovernor() external view returns (address) {\n', '        return governor.config;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the address of the modules governor\n', '    * @return Address of the modules governor\n', '    */\n', '    function getModulesGovernor() external view returns (address) {\n', '        return governor.modules;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell if a given module is active\n', '    * @param _id ID of the module to be checked\n', '    * @param _addr Address of the module to be checked\n', '    * @return True if the given module address has the requested ID and is enabled\n', '    */\n', '    function isActive(bytes32 _id, address _addr) external view returns (bool) {\n', '        Module storage module = allModules[_addr];\n', '        return module.id == _id && !module.disabled;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the current ID and disable status of a module based on a given address\n', '    * @param _addr Address of the requested module\n', '    * @return id ID of the module being queried\n', '    * @return disabled Whether the module has been disabled\n', '    */\n', '    function getModuleByAddress(address _addr) external view returns (bytes32 id, bool disabled) {\n', '        Module storage module = allModules[_addr];\n', '        id = module.id;\n', '        disabled = module.disabled;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the current address and disable status of a module based on a given ID\n', '    * @param _id ID of the module being queried\n', '    * @return addr Current address of the requested module\n', '    * @return disabled Whether the module has been disabled\n', '    */\n', '    function getModule(bytes32 _id) external view returns (address addr, bool disabled) {\n', '        return _getModule(_id);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the information for the current DisputeManager module\n', '    * @return addr Current address of the DisputeManager module\n', '    * @return disabled Whether the module has been disabled\n', '    */\n', '    function getDisputeManager() external view returns (address addr, bool disabled) {\n', '        return _getModule(MODULE_ID_DISPUTE_MANAGER);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the information for  the current GuardiansRegistry module\n', '    * @return addr Current address of the GuardiansRegistry module\n', '    * @return disabled Whether the module has been disabled\n', '    */\n', '    function getGuardiansRegistry() external view returns (address addr, bool disabled) {\n', '        return _getModule(MODULE_ID_GUARDIANS_REGISTRY);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the information for the current Voting module\n', '    * @return addr Current address of the Voting module\n', '    * @return disabled Whether the module has been disabled\n', '    */\n', '    function getVoting() external view returns (address addr, bool disabled) {\n', '        return _getModule(MODULE_ID_VOTING);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the information for the current PaymentsBook module\n', '    * @return addr Current address of the PaymentsBook module\n', '    * @return disabled Whether the module has been disabled\n', '    */\n', '    function getPaymentsBook() external view returns (address addr, bool disabled) {\n', '        return _getModule(MODULE_ID_PAYMENTS_BOOK);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the information for the current Treasury module\n', '    * @return addr Current address of the Treasury module\n', '    * @return disabled Whether the module has been disabled\n', '    */\n', '    function getTreasury() external view returns (address addr, bool disabled) {\n', '        return _getModule(MODULE_ID_TREASURY);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the target registered for a custom function\n', '    * @param _sig Signature of the function being queried\n', '    * @return Address of the target where the function call will be forwarded\n', '    */\n', '    function getCustomFunction(bytes4 _sig) external view returns (address) {\n', '        return customFunctions[_sig];\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to set the address of the funds governor\n', '    * @param _newFundsGovernor Address of the new config governor to be set\n', '    */\n', '    function _setFundsGovernor(address _newFundsGovernor) internal {\n', '        emit FundsGovernorChanged(governor.funds, _newFundsGovernor);\n', '        governor.funds = _newFundsGovernor;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to set the address of the config governor\n', '    * @param _newConfigGovernor Address of the new config governor to be set\n', '    */\n', '    function _setConfigGovernor(address _newConfigGovernor) internal {\n', '        emit ConfigGovernorChanged(governor.config, _newConfigGovernor);\n', '        governor.config = _newConfigGovernor;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to set the address of the modules governor\n', '    * @param _newModulesGovernor Address of the new modules governor to be set\n', '    */\n', '    function _setModulesGovernor(address _newModulesGovernor) internal {\n', '        emit ModulesGovernorChanged(governor.modules, _newModulesGovernor);\n', '        governor.modules = _newModulesGovernor;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to set an address as the current implementation for a module\n', '    *      Note that the disabled condition is not affected, if the module was not set before it will be enabled by default\n', '    * @param _id Id of the module to be set\n', '    * @param _addr Address of the module to be set\n', '    */\n', '    function _setModule(bytes32 _id, address _addr) internal {\n', '        require(isContract(_addr), ERROR_IMPLEMENTATION_NOT_CONTRACT);\n', '\n', '        currentModules[_id] = _addr;\n', '        allModules[_addr].id = _id;\n', '        emit ModuleSet(_id, _addr);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to sync the modules for a list of modules IDs based on their current implementation address\n', '    * @param _modulesToBeSynced List of addresses of connected modules to be synced\n', '    * @param _idsToBeSet List of IDs of the modules to be linked\n', '    */\n', '    function _syncModuleLinks(address[] memory _modulesToBeSynced, bytes32[] memory _idsToBeSet) internal {\n', '        address[] memory addressesToBeSet = new address[](_idsToBeSet.length);\n', '\n', '        // Load the addresses associated with the requested module ids\n', '        for (uint256 i = 0; i < _idsToBeSet.length; i++) {\n', '            address moduleAddress = _getModuleAddress(_idsToBeSet[i]);\n', '            Module storage module = allModules[moduleAddress];\n', '            _ensureModuleExists(module);\n', '            addressesToBeSet[i] = moduleAddress;\n', '        }\n', '\n', '        // Update the links of all the requested modules\n', '        for (uint256 j = 0; j < _modulesToBeSynced.length; j++) {\n', '            IModulesLinker(_modulesToBeSynced[j]).linkModules(_idsToBeSet, addressesToBeSet);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to notify when a term has been transitioned\n', '    * @param _termId Identification number of the new current term that has been transitioned\n', '    */\n', '    function _onTermTransitioned(uint64 _termId) internal {\n', '        _ensureTermConfig(_termId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to check if a module was set\n', '    * @param _module Module to be checked\n', '    */\n', '    function _ensureModuleExists(Module storage _module) internal view {\n', '        require(_module.id != bytes32(0), ERROR_MODULE_NOT_SET);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to tell the information for a module based on a given ID\n', '    * @param _id ID of the module being queried\n', '    * @return addr Current address of the requested module\n', '    * @return disabled Whether the module has been disabled\n', '    */\n', '    function _getModule(bytes32 _id) internal view returns (address addr, bool disabled) {\n', '        addr = _getModuleAddress(_id);\n', '        disabled = _isModuleDisabled(addr);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the current address for a module by ID\n', '    * @param _id ID of the module being queried\n', '    * @return Current address of the requested module\n', '    */\n', '    function _getModuleAddress(bytes32 _id) internal view returns (address) {\n', '        return currentModules[_id];\n', '    }\n', '\n', '    /**\n', '    * @dev Tell whether a module is disabled\n', '    * @param _addr Address of the module being queried\n', '    * @return True if the module is disabled, false otherwise\n', '    */\n', '    function _isModuleDisabled(address _addr) internal view returns (bool) {\n', '        return allModules[_addr].disabled;\n', '    }\n', '}\n', '\n', 'contract ConfigConsumer is CourtConfigData {\n', '    /**\n', '    * @dev Internal function to fetch the address of the Config module from the controller\n', '    * @return Address of the Config module\n', '    */\n', '    function _courtConfig() internal view returns (IConfig);\n', '\n', '    /**\n', '    * @dev Internal function to get the Court config for a certain term\n', '    * @param _termId Identification number of the term querying the Court config of\n', '    * @return Court config for the given term\n', '    */\n', '    function _getConfigAt(uint64 _termId) internal view returns (Config memory) {\n', '        (IERC20 _feeToken,\n', '        uint256[3] memory _fees,\n', '        uint64[5] memory _roundStateDurations,\n', '        uint16[2] memory _pcts,\n', '        uint64[4] memory _roundParams,\n', '        uint256[2] memory _appealCollateralParams,\n', '        uint256 _minActiveBalance) = _courtConfig().getConfig(_termId);\n', '\n', '        Config memory config;\n', '\n', '        config.fees = FeesConfig({\n', '            token: _feeToken,\n', '            guardianFee: _fees[0],\n', '            draftFee: _fees[1],\n', '            settleFee: _fees[2],\n', '            finalRoundReduction: _pcts[1]\n', '        });\n', '\n', '        config.disputes = DisputesConfig({\n', '            evidenceTerms: _roundStateDurations[0],\n', '            commitTerms: _roundStateDurations[1],\n', '            revealTerms: _roundStateDurations[2],\n', '            appealTerms: _roundStateDurations[3],\n', '            appealConfirmTerms: _roundStateDurations[4],\n', '            penaltyPct: _pcts[0],\n', '            firstRoundGuardiansNumber: _roundParams[0],\n', '            appealStepFactor: _roundParams[1],\n', '            maxRegularAppealRounds: _roundParams[2],\n', '            finalRoundLockTerms: _roundParams[3],\n', '            appealCollateralFactor: _appealCollateralParams[0],\n', '            appealConfirmCollateralFactor: _appealCollateralParams[1]\n', '        });\n', '\n', '        config.minActiveBalance = _minActiveBalance;\n', '\n', '        return config;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the draft config for a given term\n', '    * @param _termId Identification number of the term querying the draft config of\n', '    * @return Draft config for the given term\n', '    */\n', '    function _getDraftConfig(uint64 _termId) internal view returns (DraftConfig memory) {\n', '        (IERC20 feeToken, uint256 draftFee, uint16 penaltyPct) = _courtConfig().getDraftConfig(_termId);\n', '        return DraftConfig({ feeToken: feeToken, draftFee: draftFee, penaltyPct: penaltyPct });\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the min active balance config for a given term\n', '    * @param _termId Identification number of the term querying the min active balance config of\n', '    * @return Minimum amount of guardian tokens that can be activated\n', '    */\n', '    function _getMinActiveBalance(uint64 _termId) internal view returns (uint256) {\n', '        return _courtConfig().getMinActiveBalance(_termId);\n', '    }\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', 'interface ICRVotingOwner {\n', '    /**\n', '    * @dev Ensure votes can be committed for a vote instance, revert otherwise\n', '    * @param _voteId ID of the vote instance to request the weight of a voter for\n', '    */\n', '    function ensureCanCommit(uint256 _voteId) external;\n', '\n', '    /**\n', '    * @dev Ensure a certain voter can commit votes for a vote instance, revert otherwise\n', '    * @param _voteId ID of the vote instance to request the weight of a voter for\n', '    * @param _voter Address of the voter querying the weight of\n', '    */\n', '    function ensureCanCommit(uint256 _voteId, address _voter) external;\n', '\n', '    /**\n', '    * @dev Ensure a certain voter can reveal votes for vote instance, revert otherwise\n', '    * @param _voteId ID of the vote instance to request the weight of a voter for\n', '    * @param _voter Address of the voter querying the weight of\n', '    * @return Weight of the requested guardian for the requested vote instance\n', '    */\n', '    function ensureCanReveal(uint256 _voteId, address _voter) external returns (uint64);\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', 'interface ICRVoting {\n', '    /**\n', '    * @dev Create a new vote instance\n', '    * @dev This function can only be called by the CRVoting owner\n', '    * @param _voteId ID of the new vote instance to be created\n', '    * @param _possibleOutcomes Number of possible outcomes for the new vote instance to be created\n', '    */\n', '    function createVote(uint256 _voteId, uint8 _possibleOutcomes) external;\n', '\n', '    /**\n', '    * @dev Get the winning outcome of a vote instance\n', '    * @param _voteId ID of the vote instance querying the winning outcome of\n', "    * @return Winning outcome of the given vote instance or refused in case it's missing\n", '    */\n', '    function getWinningOutcome(uint256 _voteId) external view returns (uint8);\n', '\n', '    /**\n', '    * @dev Get the tally of an outcome for a certain vote instance\n', '    * @param _voteId ID of the vote instance querying the tally of\n', '    * @param _outcome Outcome querying the tally of\n', '    * @return Tally of the outcome being queried for the given vote instance\n', '    */\n', '    function getOutcomeTally(uint256 _voteId, uint8 _outcome) external view returns (uint256);\n', '\n', '    /**\n', '    * @dev Tell whether an outcome is valid for a given vote instance or not\n', '    * @param _voteId ID of the vote instance to check the outcome of\n', '    * @param _outcome Outcome to check if valid or not\n', '    * @return True if the given outcome is valid for the requested vote instance, false otherwise\n', '    */\n', '    function isValidOutcome(uint256 _voteId, uint8 _outcome) external view returns (bool);\n', '\n', '    /**\n', '    * @dev Get the outcome voted by a voter for a certain vote instance\n', '    * @param _voteId ID of the vote instance querying the outcome of\n', '    * @param _voter Address of the voter querying the outcome of\n', '    * @return Outcome of the voter for the given vote instance\n', '    */\n', '    function getVoterOutcome(uint256 _voteId, address _voter) external view returns (uint8);\n', '\n', '    /**\n', '    * @dev Tell whether a voter voted in favor of a certain outcome in a vote instance or not\n', '    * @param _voteId ID of the vote instance to query if a voter voted in favor of a certain outcome\n', '    * @param _outcome Outcome to query if the given voter voted in favor of\n', '    * @param _voter Address of the voter to query if voted in favor of the given outcome\n', '    * @return True if the given voter voted in favor of the given outcome, false otherwise\n', '    */\n', '    function hasVotedInFavorOf(uint256 _voteId, uint8 _outcome, address _voter) external view returns (bool);\n', '\n', '    /**\n', '    * @dev Filter a list of voters based on whether they voted in favor of a certain outcome in a vote instance or not\n', '    * @param _voteId ID of the vote instance to be checked\n', '    * @param _outcome Outcome to filter the list of voters of\n', '    * @param _voters List of addresses of the voters to be filtered\n', '    * @return List of results to tell whether a voter voted in favor of the given outcome or not\n', '    */\n', '    function getVotersInFavorOf(uint256 _voteId, uint8 _outcome, address[] calldata _voters) external view returns (bool[] memory);\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', 'interface ITreasury {\n', '    /**\n', '    * @dev Assign a certain amount of tokens to an account\n', '    * @param _token ERC20 token to be assigned\n', '    * @param _to Address of the recipient that will be assigned the tokens to\n', '    * @param _amount Amount of tokens to be assigned to the recipient\n', '    */\n', '    function assign(IERC20 _token, address _to, uint256 _amount) external;\n', '\n', '    /**\n', '    * @dev Withdraw a certain amount of tokens\n', '    * @param _token ERC20 token to be withdrawn\n', '    * @param _from Address withdrawing the tokens from\n', '    * @param _to Address of the recipient that will receive the tokens\n', '    * @param _amount Amount of tokens to be withdrawn from the sender\n', '    */\n', '    function withdraw(IERC20 _token, address _from, address _to, uint256 _amount) external;\n', '}\n', '\n', '/*\n', ' * SPDX-License-Identifier:    MIT\n', ' */\n', 'interface IPaymentsBook {\n', '    /**\n', '    * @dev Pay an amount of tokens\n', '    * @param _token Address of the token being paid\n', '    * @param _amount Amount of tokens being paid\n', '    * @param _payer Address paying on behalf of\n', '    * @param _data Optional data\n', '    */\n', '    function pay(address _token, uint256 _amount, address _payer, bytes calldata _data) external payable;\n', '}\n', '\n', 'contract Controlled is IModulesLinker, IsContract, ModuleIds, ConfigConsumer {\n', '    string private constant ERROR_MODULE_NOT_SET = "CTD_MODULE_NOT_SET";\n', '    string private constant ERROR_INVALID_MODULES_LINK_INPUT = "CTD_INVALID_MODULES_LINK_INPUT";\n', '    string private constant ERROR_CONTROLLER_NOT_CONTRACT = "CTD_CONTROLLER_NOT_CONTRACT";\n', '    string private constant ERROR_SENDER_NOT_ALLOWED = "CTD_SENDER_NOT_ALLOWED";\n', '    string private constant ERROR_SENDER_NOT_CONTROLLER = "CTD_SENDER_NOT_CONTROLLER";\n', '    string private constant ERROR_SENDER_NOT_CONFIG_GOVERNOR = "CTD_SENDER_NOT_CONFIG_GOVERNOR";\n', '    string private constant ERROR_SENDER_NOT_ACTIVE_VOTING = "CTD_SENDER_NOT_ACTIVE_VOTING";\n', '    string private constant ERROR_SENDER_NOT_ACTIVE_DISPUTE_MANAGER = "CTD_SEND_NOT_ACTIVE_DISPUTE_MGR";\n', '    string private constant ERROR_SENDER_NOT_CURRENT_DISPUTE_MANAGER = "CTD_SEND_NOT_CURRENT_DISPUTE_MGR";\n', '\n', '    // Address of the controller\n', '    Controller public controller;\n', '\n', '    // List of modules linked indexed by ID\n', '    mapping (bytes32 => address) public linkedModules;\n', '\n', '    event ModuleLinked(bytes32 id, address addr);\n', '\n', '    /**\n', "    * @dev Ensure the msg.sender is the controller's config governor\n", '    */\n', '    modifier onlyConfigGovernor {\n', '        require(msg.sender == _configGovernor(), ERROR_SENDER_NOT_CONFIG_GOVERNOR);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Ensure the msg.sender is the controller\n', '    */\n', '    modifier onlyController() {\n', '        require(msg.sender == address(controller), ERROR_SENDER_NOT_CONTROLLER);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Ensure the msg.sender is an active DisputeManager module\n', '    */\n', '    modifier onlyActiveDisputeManager() {\n', '        require(controller.isActive(MODULE_ID_DISPUTE_MANAGER, msg.sender), ERROR_SENDER_NOT_ACTIVE_DISPUTE_MANAGER);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Ensure the msg.sender is the current DisputeManager module\n', '    */\n', '    modifier onlyCurrentDisputeManager() {\n', '        (address addr, bool disabled) = controller.getDisputeManager();\n', '        require(msg.sender == addr, ERROR_SENDER_NOT_CURRENT_DISPUTE_MANAGER);\n', '        require(!disabled, ERROR_SENDER_NOT_ACTIVE_DISPUTE_MANAGER);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Ensure the msg.sender is an active Voting module\n', '    */\n', '    modifier onlyActiveVoting() {\n', '        require(controller.isActive(MODULE_ID_VOTING, msg.sender), ERROR_SENDER_NOT_ACTIVE_VOTING);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev This modifier will check that the sender is the user to act on behalf of or someone with the required permission\n', '    * @param _user Address of the user to act on behalf of\n', '    */\n', '    modifier authenticateSender(address _user) {\n', '        _authenticateSender(_user);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    * @param _controller Address of the controller\n', '    */\n', '    constructor(Controller _controller) public {\n', '        require(isContract(address(_controller)), ERROR_CONTROLLER_NOT_CONTRACT);\n', '        controller = _controller;\n', '    }\n', '\n', '    /**\n', '    * @notice Update the implementation links of a list of modules\n', '    * @dev The controller is expected to ensure the given addresses are correct modules\n', '    * @param _ids List of IDs of the modules to be updated\n', '    * @param _addresses List of module addresses to be updated\n', '    */\n', '    function linkModules(bytes32[] calldata _ids, address[] calldata _addresses) external onlyController {\n', '        require(_ids.length == _addresses.length, ERROR_INVALID_MODULES_LINK_INPUT);\n', '\n', '        for (uint256 i = 0; i < _ids.length; i++) {\n', '            linkedModules[_ids[i]] = _addresses[i];\n', '            emit ModuleLinked(_ids[i], _addresses[i]);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to ensure the Court term is up-to-date, it will try to update it if not\n', '    * @return Identification number of the current Court term\n', '    */\n', '    function _ensureCurrentTerm() internal returns (uint64) {\n', '        return _clock().ensureCurrentTerm();\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to fetch the last ensured term ID of the Court\n', '    * @return Identification number of the last ensured term\n', '    */\n', '    function _getLastEnsuredTermId() internal view returns (uint64) {\n', '        return _clock().getLastEnsuredTermId();\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to tell the current term identification number\n', '    * @return Identification number of the current term\n', '    */\n', '    function _getCurrentTermId() internal view returns (uint64) {\n', '        return _clock().getCurrentTermId();\n', '    }\n', '\n', '    /**\n', "    * @dev Internal function to fetch the controller's config governor\n", "    * @return Address of the controller's config governor\n", '    */\n', '    function _configGovernor() internal view returns (address) {\n', '        return controller.getConfigGovernor();\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to fetch the address of the DisputeManager module\n', '    * @return Address of the DisputeManager module\n', '    */\n', '    function _disputeManager() internal view returns (IDisputeManager) {\n', '        return IDisputeManager(_getLinkedModule(MODULE_ID_DISPUTE_MANAGER));\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to fetch the address of the GuardianRegistry module implementation\n', '    * @return Address of the GuardianRegistry module implementation\n', '    */\n', '    function _guardiansRegistry() internal view returns (IGuardiansRegistry) {\n', '        return IGuardiansRegistry(_getLinkedModule(MODULE_ID_GUARDIANS_REGISTRY));\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to fetch the address of the Voting module implementation\n', '    * @return Address of the Voting module implementation\n', '    */\n', '    function _voting() internal view returns (ICRVoting) {\n', '        return ICRVoting(_getLinkedModule(MODULE_ID_VOTING));\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to fetch the address of the PaymentsBook module implementation\n', '    * @return Address of the PaymentsBook module implementation\n', '    */\n', '    function _paymentsBook() internal view returns (IPaymentsBook) {\n', '        return IPaymentsBook(_getLinkedModule(MODULE_ID_PAYMENTS_BOOK));\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to fetch the address of the Treasury module implementation\n', '    * @return Address of the Treasury module implementation\n', '    */\n', '    function _treasury() internal view returns (ITreasury) {\n', '        return ITreasury(_getLinkedModule(MODULE_ID_TREASURY));\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to tell the address linked for a module based on a given ID\n', '    * @param _id ID of the module being queried\n', '    * @return Linked address of the requested module\n', '    */\n', '    function _getLinkedModule(bytes32 _id) internal view returns (address) {\n', '        address module = linkedModules[_id];\n', '        require(module != address(0), ERROR_MODULE_NOT_SET);\n', '        return module;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to fetch the address of the Clock module from the controller\n', '    * @return Address of the Clock module\n', '    */\n', '    function _clock() internal view returns (IClock) {\n', '        return IClock(controller);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to fetch the address of the Config module from the controller\n', '    * @return Address of the Config module\n', '    */\n', '    function _courtConfig() internal view returns (IConfig) {\n', '        return IConfig(controller);\n', '    }\n', '\n', '    /**\n', '    * @dev Ensure that the sender is the user to act on behalf of or someone with the required permission\n', '    * @param _user Address of the user to act on behalf of\n', '    */\n', '    function _authenticateSender(address _user) internal view {\n', '        require(_isSenderAllowed(_user), ERROR_SENDER_NOT_ALLOWED);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell whether the sender is the user to act on behalf of or someone with the required permission\n', '    * @param _user Address of the user to act on behalf of\n', '    * @return True if the sender is the user to act on behalf of or someone with the required permission, false otherwise\n', '    */\n', '    function _isSenderAllowed(address _user) internal view returns (bool) {\n', '        return msg.sender == _user || _hasRole(msg.sender);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell whether an address holds the required permission to access the requested functionality\n', '    * @param _addr Address being checked\n', '    * @return True if the given address has the required permission to access the requested functionality, false otherwise\n', '    */\n', '    function _hasRole(address _addr) internal view returns (bool) {\n', '        bytes32 roleId = keccak256(abi.encodePacked(address(this), msg.sig));\n', '        return controller.hasRole(_addr, roleId);\n', '    }\n', '}\n', '\n', 'contract ControlledRecoverable is Controlled {\n', '    using SafeERC20 for IERC20;\n', '\n', '    string private constant ERROR_SENDER_NOT_FUNDS_GOVERNOR = "CTD_SENDER_NOT_FUNDS_GOVERNOR";\n', '    string private constant ERROR_INSUFFICIENT_RECOVER_FUNDS = "CTD_INSUFFICIENT_RECOVER_FUNDS";\n', '    string private constant ERROR_RECOVER_TOKEN_FUNDS_FAILED = "CTD_RECOVER_TOKEN_FUNDS_FAILED";\n', '\n', '    event RecoverFunds(address token, address recipient, uint256 balance);\n', '\n', '    /**\n', "    * @dev Ensure the msg.sender is the controller's funds governor\n", '    */\n', '    modifier onlyFundsGovernor {\n', '        require(msg.sender == controller.getFundsGovernor(), ERROR_SENDER_NOT_FUNDS_GOVERNOR);\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @notice Transfer all `_token` tokens to `_to`\n', '    * @param _token Address of the token to be recovered\n', '    * @param _to Address of the recipient that will be receive all the funds of the requested token\n', '    */\n', '    function recoverFunds(address _token, address payable _to) external payable onlyFundsGovernor {\n', '        uint256 balance;\n', '\n', '        if (_token == address(0)) {\n', '            balance = address(this).balance;\n', '            require(_to.send(balance), ERROR_RECOVER_TOKEN_FUNDS_FAILED);\n', '        } else {\n', '            balance = IERC20(_token).balanceOf(address(this));\n', '            require(balance > 0, ERROR_INSUFFICIENT_RECOVER_FUNDS);\n', '            // No need to verify _token to be a contract as we have already checked the balance\n', '            require(IERC20(_token).safeTransfer(_to, balance), ERROR_RECOVER_TOKEN_FUNDS_FAILED);\n', '        }\n', '\n', '        emit RecoverFunds(_token, _to, balance);\n', '    }\n', '}\n', '\n', 'contract GuardiansRegistry is IGuardiansRegistry, ControlledRecoverable {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '    using PctHelpers for uint256;\n', '    using HexSumTree for HexSumTree.Tree;\n', '    using GuardiansTreeSortition for HexSumTree.Tree;\n', '\n', '    string private constant ERROR_NOT_CONTRACT = "GR_NOT_CONTRACT";\n', '    string private constant ERROR_INVALID_ZERO_AMOUNT = "GR_INVALID_ZERO_AMOUNT";\n', '    string private constant ERROR_INVALID_ACTIVATION_AMOUNT = "GR_INVALID_ACTIVATION_AMOUNT";\n', '    string private constant ERROR_INVALID_DEACTIVATION_AMOUNT = "GR_INVALID_DEACTIVATION_AMOUNT";\n', '    string private constant ERROR_INVALID_LOCKED_AMOUNTS_LENGTH = "GR_INVALID_LOCKED_AMOUNTS_LEN";\n', '    string private constant ERROR_INVALID_REWARDED_GUARDIANS_LENGTH = "GR_INVALID_REWARD_GUARDIANS_LEN";\n', '    string private constant ERROR_ACTIVE_BALANCE_BELOW_MIN = "GR_ACTIVE_BALANCE_BELOW_MIN";\n', '    string private constant ERROR_NOT_ENOUGH_AVAILABLE_BALANCE = "GR_NOT_ENOUGH_AVAILABLE_BALANCE";\n', '    string private constant ERROR_CANNOT_REDUCE_DEACTIVATION_REQUEST = "GR_CANT_REDUCE_DEACTIVATION_REQ";\n', '    string private constant ERROR_TOKEN_TRANSFER_FAILED = "GR_TOKEN_TRANSFER_FAILED";\n', '    string private constant ERROR_TOKEN_APPROVE_NOT_ALLOWED = "GR_TOKEN_APPROVE_NOT_ALLOWED";\n', '    string private constant ERROR_BAD_TOTAL_ACTIVE_BALANCE_LIMIT = "GR_BAD_TOTAL_ACTIVE_BAL_LIMIT";\n', '    string private constant ERROR_TOTAL_ACTIVE_BALANCE_EXCEEDED = "GR_TOTAL_ACTIVE_BALANCE_EXCEEDED";\n', '    string private constant ERROR_DEACTIVATION_AMOUNT_EXCEEDS_LOCK = "GR_DEACTIV_AMOUNT_EXCEEDS_LOCK";\n', '    string private constant ERROR_CANNOT_UNLOCK_ACTIVATION = "GR_CANNOT_UNLOCK_ACTIVATION";\n', '    string private constant ERROR_ZERO_LOCK_ACTIVATION = "GR_ZERO_LOCK_ACTIVATION";\n', '    string private constant ERROR_INVALID_UNLOCK_ACTIVATION_AMOUNT = "GR_INVALID_UNLOCK_ACTIVAT_AMOUNT";\n', '    string private constant ERROR_LOCK_MANAGER_NOT_ALLOWED = "GR_LOCK_MANAGER_NOT_ALLOWED";\n', '    string private constant ERROR_WITHDRAWALS_LOCK = "GR_WITHDRAWALS_LOCK";\n', '\n', '    // Address that will be used to burn guardian tokens\n', '    address internal constant BURN_ACCOUNT = address(0x000000000000000000000000000000000000dEaD);\n', '\n', '    // Maximum number of sortition iterations allowed per draft call\n', '    uint256 internal constant MAX_DRAFT_ITERATIONS = 10;\n', '\n', '    // "ERC20-lite" interface to provide help for tooling\n', '    string public constant name = "Court Staked Aragon Network Token";\n', '    string public constant symbol = "sANT";\n', '    uint8 public constant decimals = 18;\n', '\n', '    /**\n', '    * @dev Guardians have three kind of balances, these are:\n', '    *      - active: tokens activated for the Court that can be locked in case the guardian is drafted\n', '    *      - locked: amount of active tokens that are locked for a draft\n', '    *      - available: tokens that are not activated for the Court and can be withdrawn by the guardian at any time\n', '    *\n', '    *      Due to a gas optimization for drafting, the "active" tokens are stored in a `HexSumTree`, while the others\n', "    *      are stored in this contract as `lockedBalance` and `availableBalance` respectively. Given that the guardians'\n", '    *      active balances cannot be affected during the current Court term, if guardians want to deactivate some of\n', "    *      their active tokens, their balance will be updated for the following term, and they won't be allowed to\n", '    *      withdraw them until the current term has ended.\n', '    *\n', '    *      Note that even though guardians balances are stored separately, all the balances are held by this contract.\n', '    */\n', '    struct Guardian {\n', '        uint256 id;                                 // Key in the guardians tree used for drafting\n', "        uint256 lockedBalance;                      // Maximum amount of tokens that can be slashed based on the guardian's drafts\n", '        uint256 availableBalance;                   // Available tokens that can be withdrawn at any time\n', "        uint64 withdrawalsLockTermId;               // Term ID until which the guardian's withdrawals will be locked\n", "        ActivationLocks activationLocks;            // Guardian's activation locks\n", "        DeactivationRequest deactivationRequest;    // Guardian's pending deactivation request\n", '    }\n', '\n', '    /**\n', '    * @dev Guardians can define lock managers to control their minimum active balance in the registry\n', '    */\n', '    struct ActivationLocks {\n', '        uint256 total;                               // Total amount of active balance locked\n', '        mapping (address => uint256) lockedBy;       // List of locked amounts indexed by lock manager\n', '    }\n', '\n', '    /**\n', '    * @dev Given that the guardians balances cannot be affected during a Court term, if guardians want to deactivate some\n', "    *      of their tokens, the tree will always be updated for the following term, and they won't be able to\n", '    *      withdraw the requested amount until the current term has finished. Thus, we need to keep track the term\n', '    *      when a token deactivation was requested and its corresponding amount.\n', '    */\n', '    struct DeactivationRequest {\n', '        uint256 amount;                             // Amount requested for deactivation\n', '        uint64 availableTermId;                     // Term ID when guardians can withdraw their requested deactivation tokens\n', '    }\n', '\n', '    /**\n', '    * @dev Internal struct to wrap all the params required to perform guardians drafting\n', '    */\n', '    struct DraftParams {\n', '        bytes32 termRandomness;                     // Randomness seed to be used for the draft\n', '        uint256 disputeId;                          // ID of the dispute being drafted\n', "        uint64 termId;                              // Term ID of the dispute's draft term\n", '        uint256 selectedGuardians;                  // Number of guardians already selected for the draft\n', '        uint256 batchRequestedGuardians;            // Number of guardians to be selected in the given batch of the draft\n', '        uint256 roundRequestedGuardians;            // Total number of guardians requested to be drafted\n', '        uint256 draftLockAmount;                    // Amount of tokens to be locked to each drafted guardian\n', '        uint256 iteration;                          // Sortition iteration number\n', '    }\n', '\n', '    // Maximum amount of total active balance that can be held in the registry\n', '    uint256 public totalActiveBalanceLimit;\n', '\n', '    // Guardian ERC20 token\n', '    IERC20 public guardiansToken;\n', '\n', '    // Mapping of guardian data indexed by address\n', '    mapping (address => Guardian) internal guardiansByAddress;\n', '\n', '    // Mapping of guardian addresses indexed by id\n', '    mapping (uint256 => address) internal guardiansAddressById;\n', '\n', '    // Tree to store guardians active balance by term for the drafting process\n', '    HexSumTree.Tree internal tree;\n', '\n', '    event Staked(address indexed guardian, uint256 amount, uint256 total);\n', '    event Unstaked(address indexed guardian, uint256 amount, uint256 total);\n', '    event GuardianActivated(address indexed guardian, uint64 fromTermId, uint256 amount);\n', '    event GuardianDeactivationRequested(address indexed guardian, uint64 availableTermId, uint256 amount);\n', '    event GuardianDeactivationProcessed(address indexed guardian, uint64 availableTermId, uint256 amount, uint64 processedTermId);\n', '    event GuardianDeactivationUpdated(address indexed guardian, uint64 availableTermId, uint256 amount, uint64 updateTermId);\n', '    event GuardianActivationLockChanged(address indexed guardian, address indexed lockManager, uint256 amount, uint256 total);\n', '    event GuardianBalanceLocked(address indexed guardian, uint256 amount);\n', '    event GuardianBalanceUnlocked(address indexed guardian, uint256 amount);\n', '    event GuardianSlashed(address indexed guardian, uint256 amount, uint64 effectiveTermId);\n', '    event GuardianTokensAssigned(address indexed guardian, uint256 amount);\n', '    event GuardianTokensBurned(uint256 amount);\n', '    event GuardianTokensCollected(address indexed guardian, uint256 amount, uint64 effectiveTermId);\n', '    event TotalActiveBalanceLimitChanged(uint256 previousTotalActiveBalanceLimit, uint256 currentTotalActiveBalanceLimit);\n', '\n', '    /**\n', '    * @dev Constructor function\n', '    * @param _controller Address of the controller\n', '    * @param _guardiansToken Address of the ERC20 token to be used as guardian token for the registry\n', '    * @param _totalActiveBalanceLimit Maximum amount of total active balance that can be held in the registry\n', '    */\n', '    constructor(Controller _controller, IERC20 _guardiansToken, uint256 _totalActiveBalanceLimit) Controlled(_controller) public {\n', '        require(isContract(address(_guardiansToken)), ERROR_NOT_CONTRACT);\n', '\n', '        guardiansToken = _guardiansToken;\n', '        _setTotalActiveBalanceLimit(_totalActiveBalanceLimit);\n', '\n', '        tree.init();\n', '        // First tree item is an empty guardian\n', '        assert(tree.insert(0, 0) == 0);\n', '    }\n', '\n', '    /**\n', '    * @notice Stake `@tokenAmount(self.token(), _amount)` for `_guardian`\n', '    * @param _guardian Address of the guardian to stake tokens to\n', '    * @param _amount Amount of tokens to be staked\n', '    */\n', '    function stake(address _guardian, uint256 _amount) external {\n', '        _stake(_guardian, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Unstake `@tokenAmount(self.token(), _amount)` from `_guardian`\n', '    * @param _guardian Address of the guardian to unstake tokens from\n', '    * @param _amount Amount of tokens to be unstaked\n', '    */\n', '    function unstake(address _guardian, uint256 _amount) external authenticateSender(_guardian) {\n', '        _unstake(_guardian, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Activate `@tokenAmount(self.token(), _amount)` for `_guardian`\n', '    * @param _guardian Address of the guardian activating the tokens for\n', '    * @param _amount Amount of guardian tokens to be activated for the next term\n', '    */\n', '    function activate(address _guardian, uint256 _amount) external authenticateSender(_guardian) {\n', '        _activate(_guardian, _amount);\n', '    }\n', '\n', '    /**\n', "    * @notice Deactivate `_amount == 0 ? 'all unlocked tokens' : @tokenAmount(self.token(), _amount)` for `_guardian`\n", '    * @param _guardian Address of the guardian deactivating the tokens for\n', '    * @param _amount Amount of guardian tokens to be deactivated for the next term\n', '    */\n', '    function deactivate(address _guardian, uint256 _amount) external authenticateSender(_guardian) {\n', '        _deactivate(_guardian, _amount);\n', '    }\n', '\n', '    /**\n', '    * @notice Stake and activate `@tokenAmount(self.token(), _amount)` for `_guardian`\n', '    * @param _guardian Address of the guardian staking and activating tokens for\n', '    * @param _amount Amount of tokens to be staked and activated\n', '    */\n', '    function stakeAndActivate(address _guardian, uint256 _amount) external authenticateSender(_guardian) {\n', '        _stake(_guardian, _amount);\n', '        _activate(_guardian, _amount);\n', '    }\n', '\n', '    /**\n', "    * @notice Lock `@tokenAmount(self.token(), _amount)` of `_guardian`'s active balance\n", '    * @param _guardian Address of the guardian locking the activation for\n', '    * @param _lockManager Address of the lock manager that will control the lock\n', '    * @param _amount Amount of active tokens to be locked\n', '    */\n', '    function lockActivation(address _guardian, address _lockManager, uint256 _amount) external {\n', '        // Make sure the sender is the guardian, someone allowed by the guardian, or the lock manager itself\n', '        bool isLockManagerAllowed = msg.sender == _lockManager || _isSenderAllowed(_guardian);\n', '        // Make sure that the given lock manager is allowed\n', '        require(isLockManagerAllowed && _hasRole(_lockManager), ERROR_LOCK_MANAGER_NOT_ALLOWED);\n', '\n', '        _lockActivation(_guardian, _lockManager, _amount);\n', '    }\n', '\n', '    /**\n', "    * @notice Unlock  `_amount == 0 ? 'all unlocked tokens' : @tokenAmount(self.token(), _amount)` of `_guardian`'s active balance\n", '    * @param _guardian Address of the guardian unlocking the active balance of\n', '    * @param _lockManager Address of the lock manager controlling the lock\n', '    * @param _amount Amount of active tokens to be unlocked\n', '    * @param _requestDeactivation Whether the unlocked amount must be requested for deactivation immediately\n', '    */\n', '    function unlockActivation(address _guardian, address _lockManager, uint256 _amount, bool _requestDeactivation) external {\n', '        ActivationLocks storage activationLocks = guardiansByAddress[_guardian].activationLocks;\n', '        uint256 lockedAmount = activationLocks.lockedBy[_lockManager];\n', '        require(lockedAmount > 0, ERROR_ZERO_LOCK_ACTIVATION);\n', '\n', '        uint256 amountToUnlock = _amount == 0 ? lockedAmount : _amount;\n', '        require(amountToUnlock <= lockedAmount, ERROR_INVALID_UNLOCK_ACTIVATION_AMOUNT);\n', '\n', '        // Always allow the lock manager to unlock\n', '        bool canUnlock = _lockManager == msg.sender || ILockManager(_lockManager).canUnlock(_guardian, amountToUnlock);\n', '        require(canUnlock, ERROR_CANNOT_UNLOCK_ACTIVATION);\n', '\n', '        uint256 newLockedAmount = lockedAmount.sub(amountToUnlock);\n', '        uint256 newTotalLocked = activationLocks.total.sub(amountToUnlock);\n', '\n', '        activationLocks.total = newTotalLocked;\n', '        activationLocks.lockedBy[_lockManager] = newLockedAmount;\n', '        emit GuardianActivationLockChanged(_guardian, _lockManager, newLockedAmount, newTotalLocked);\n', '\n', '        // In order to request a deactivation, the request must have been originally authorized from the guardian or someone authorized to do it\n', '        if (_requestDeactivation) {\n', '            _authenticateSender(_guardian);\n', '            _deactivate(_guardian, _amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Process a token deactivation requested for `_guardian` if there is any\n', '    * @param _guardian Address of the guardian to process the deactivation request of\n', '    */\n', '    function processDeactivationRequest(address _guardian) external {\n', '        uint64 termId = _ensureCurrentTerm();\n', '        _processDeactivationRequest(_guardian, termId);\n', '    }\n', '\n', '    /**\n', '    * @notice Assign `@tokenAmount(self.token(), _amount)` to the available balance of `_guardian`\n', '    * @param _guardian Guardian to add an amount of tokens to\n', '    * @param _amount Amount of tokens to be added to the available balance of a guardian\n', '    */\n', '    function assignTokens(address _guardian, uint256 _amount) external onlyActiveDisputeManager {\n', '        if (_amount > 0) {\n', '            _updateAvailableBalanceOf(_guardian, _amount, true);\n', '            emit GuardianTokensAssigned(_guardian, _amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Burn `@tokenAmount(self.token(), _amount)`\n', '    * @param _amount Amount of tokens to be burned\n', '    */\n', '    function burnTokens(uint256 _amount) external onlyActiveDisputeManager {\n', '        if (_amount > 0) {\n', '            _updateAvailableBalanceOf(BURN_ACCOUNT, _amount, true);\n', '            emit GuardianTokensBurned(_amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Draft a set of guardians based on given requirements for a term id\n', '    * @param _params Array containing draft requirements:\n', '    *        0. bytes32 Term randomness\n', '    *        1. uint256 Dispute id\n', '    *        2. uint64  Current term id\n', '    *        3. uint256 Number of seats already filled\n', '    *        4. uint256 Number of seats left to be filled\n', '    *        5. uint64  Number of guardians required for the draft\n', '    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\n', '    *\n', '    * @return guardians List of guardians selected for the draft\n', '    * @return length Size of the list of the draft result\n', '    */\n', '    function draft(uint256[7] calldata _params) external onlyActiveDisputeManager returns (address[] memory guardians, uint256 length) {\n', '        DraftParams memory draftParams = _buildDraftParams(_params);\n', '        guardians = new address[](draftParams.batchRequestedGuardians);\n', '\n', '        // Guardians returned by the tree multi-sortition may not have enough unlocked active balance to be drafted. Thus,\n', '        // we compute several sortitions until all the requested guardians are selected. To guarantee a different set of\n', '        // guardians on each sortition, the iteration number will be part of the random seed to be used in the sortition.\n', '        // Note that we are capping the number of iterations to avoid an OOG error, which means that this function could\n', '        // return less guardians than the requested number.\n', '\n', '        for (draftParams.iteration = 0;\n', '             length < draftParams.batchRequestedGuardians && draftParams.iteration < MAX_DRAFT_ITERATIONS;\n', '             draftParams.iteration++\n', '        ) {\n', '            (uint256[] memory guardianIds, uint256[] memory activeBalances) = _treeSearch(draftParams);\n', '\n', '            for (uint256 i = 0; i < guardianIds.length && length < draftParams.batchRequestedGuardians; i++) {\n', '                // We assume the selected guardians are registered in the registry, we are not checking their addresses exist\n', '                address guardianAddress = guardiansAddressById[guardianIds[i]];\n', '                Guardian storage guardian = guardiansByAddress[guardianAddress];\n', '\n', '                // Compute new locked balance for a guardian based on the penalty applied when being drafted\n', '                uint256 newLockedBalance = guardian.lockedBalance.add(draftParams.draftLockAmount);\n', '\n', '                // Check if there is any deactivation requests for the next term. Drafts are always computed for the current term\n', '                // but we have to make sure we are locking an amount that will exist in the next term.\n', '                uint256 nextTermDeactivationRequestAmount = _deactivationRequestedAmountForTerm(guardian, draftParams.termId + 1);\n', '\n', '                // Check if guardian has enough active tokens to lock the requested amount for the draft, skip it otherwise.\n', '                uint256 currentActiveBalance = activeBalances[i];\n', '                if (currentActiveBalance >= newLockedBalance) {\n', '\n', '                    // Check if the amount of active tokens for the next term is enough to lock the required amount for\n', '                    // the draft. Otherwise, reduce the requested deactivation amount of the next term.\n', '                    // Next term deactivation amount should always be less than current active balance, but we make sure using SafeMath\n', '                    uint256 nextTermActiveBalance = currentActiveBalance.sub(nextTermDeactivationRequestAmount);\n', '                    if (nextTermActiveBalance < newLockedBalance) {\n', '                        // No need for SafeMath: we already checked values above\n', '                        _reduceDeactivationRequest(guardianAddress, newLockedBalance - nextTermActiveBalance, draftParams.termId);\n', '                    }\n', '\n', '                    // Update the current active locked balance of the guardian\n', '                    guardian.lockedBalance = newLockedBalance;\n', '                    guardians[length++] = guardianAddress;\n', '                    emit GuardianBalanceLocked(guardianAddress, draftParams.draftLockAmount);\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Slash a set of guardians based on their votes compared to the winning ruling. This function will unlock the\n', '    *         corresponding locked balances of those guardians that are set to be slashed.\n', '    * @param _termId Current term id\n', '    * @param _guardians List of guardian addresses to be slashed\n', '    * @param _lockedAmounts List of amounts locked for each corresponding guardian that will be either slashed or returned\n', "    * @param _rewardedGuardians List of booleans to tell whether a guardian's active balance has to be slashed or not\n", '    * @return Total amount of slashed tokens\n', '    */\n', '    function slashOrUnlock(uint64 _termId, address[] calldata _guardians, uint256[] calldata _lockedAmounts, bool[] calldata _rewardedGuardians)\n', '        external\n', '        onlyActiveDisputeManager\n', '        returns (uint256)\n', '    {\n', '        require(_guardians.length == _lockedAmounts.length, ERROR_INVALID_LOCKED_AMOUNTS_LENGTH);\n', '        require(_guardians.length == _rewardedGuardians.length, ERROR_INVALID_REWARDED_GUARDIANS_LENGTH);\n', '\n', '        uint64 nextTermId = _termId + 1;\n', '        uint256 collectedTokens;\n', '\n', '        for (uint256 i = 0; i < _guardians.length; i++) {\n', '            uint256 lockedAmount = _lockedAmounts[i];\n', '            address guardianAddress = _guardians[i];\n', '            Guardian storage guardian = guardiansByAddress[guardianAddress];\n', '            guardian.lockedBalance = guardian.lockedBalance.sub(lockedAmount);\n', '\n', "            // Slash guardian if requested. Note that there's no need to check if there was a deactivation\n", "            // request since we're working with already locked balances.\n", '            if (_rewardedGuardians[i]) {\n', '                emit GuardianBalanceUnlocked(guardianAddress, lockedAmount);\n', '            } else {\n', '                collectedTokens = collectedTokens.add(lockedAmount);\n', '                tree.update(guardian.id, nextTermId, lockedAmount, false);\n', '                emit GuardianSlashed(guardianAddress, lockedAmount, nextTermId);\n', '            }\n', '        }\n', '\n', '        return collectedTokens;\n', '    }\n', '\n', '    /**\n', '    * @notice Try to collect `@tokenAmount(self.token(), _amount)` from `_guardian` for the term #`_termId + 1`.\n', '    * @dev This function tries to decrease the active balance of a guardian for the next term based on the requested\n', "    *      amount. It can be seen as a way to early-slash a guardian's active balance.\n", '    * @param _guardian Guardian to collect the tokens from\n', '    * @param _amount Amount of tokens to be collected from the given guardian and for the requested term id\n', '    * @param _termId Current term id\n', '    * @return True if the guardian has enough unlocked tokens to be collected for the requested term, false otherwise\n', '    */\n', '    function collectTokens(address _guardian, uint256 _amount, uint64 _termId) external onlyActiveDisputeManager returns (bool) {\n', '        if (_amount == 0) {\n', '            return true;\n', '        }\n', '\n', '        uint64 nextTermId = _termId + 1;\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        uint256 unlockedActiveBalance = _lastUnlockedActiveBalanceOf(guardian);\n', '        uint256 nextTermDeactivationRequestAmount = _deactivationRequestedAmountForTerm(guardian, nextTermId);\n', '\n', '        // Check if the guardian has enough unlocked tokens to collect the requested amount\n', "        // Note that we're also considering the deactivation request if there is any\n", '        uint256 totalUnlockedActiveBalance = unlockedActiveBalance.add(nextTermDeactivationRequestAmount);\n', '        if (_amount > totalUnlockedActiveBalance) {\n', '            return false;\n', '        }\n', '\n', '        // Check if the amount of active tokens is enough to collect the requested amount, otherwise reduce the requested deactivation amount of\n', '        // the next term. Note that this behaviour is different to the one when drafting guardians since this function is called as a side effect\n', '        // of a guardian deliberately voting in a final round, while drafts occur randomly.\n', '        if (_amount > unlockedActiveBalance) {\n', '            // No need for SafeMath: amounts were already checked above\n', '            uint256 amountToReduce = _amount - unlockedActiveBalance;\n', '            _reduceDeactivationRequest(_guardian, amountToReduce, _termId);\n', '        }\n', '        tree.update(guardian.id, nextTermId, _amount, false);\n', '\n', '        emit GuardianTokensCollected(_guardian, _amount, nextTermId);\n', '        return true;\n', '    }\n', '\n', '    /**\n', "    * @notice Lock `_guardian`'s withdrawals until term #`_termId`\n", '    * @dev This is intended for guardians who voted in a final round and were coherent with the final ruling to prevent 51% attacks\n', '    * @param _guardian Address of the guardian to be locked\n', "    * @param _termId Term ID until which the guardian's withdrawals will be locked\n", '    */\n', '    function lockWithdrawals(address _guardian, uint64 _termId) external onlyActiveDisputeManager {\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        guardian.withdrawalsLockTermId = _termId;\n', '    }\n', '\n', '    /**\n', '    * @notice Set new limit of total active balance of guardian tokens\n', '    * @param _totalActiveBalanceLimit New limit of total active balance of guardian tokens\n', '    */\n', '    function setTotalActiveBalanceLimit(uint256 _totalActiveBalanceLimit) external onlyConfigGovernor {\n', '        _setTotalActiveBalanceLimit(_totalActiveBalanceLimit);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the total supply of guardian tokens staked\n', '    * @return Supply of guardian tokens staked\n', '    */\n', '    function totalSupply() external view returns (uint256) {\n', '        return guardiansToken.balanceOf(address(this));\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the total amount of active guardian tokens\n', '    * @return Total amount of active guardian tokens\n', '    */\n', '    function totalActiveBalance() external view returns (uint256) {\n', '        return tree.getTotal();\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the total amount of active guardian tokens for a given term id\n', '    * @param _termId Term ID to query on\n', '    * @return Total amount of active guardian tokens at the given term id\n', '    */\n', '    function totalActiveBalanceAt(uint64 _termId) external view returns (uint256) {\n', '        return _totalActiveBalanceAt(_termId);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the total balance of tokens held by a guardian\n', '    *      This includes the active balance, the available balances, and the pending balance for deactivation.\n', "    *      Note that we don't have to include the locked balances since these represent the amount of active tokens\n", '    *      that are locked for drafts, i.e. these are already included in the active balance of the guardian.\n', '    * @param _guardian Address of the guardian querying the balance of\n', '    * @return Total amount of tokens of a guardian\n', '    */\n', '    function balanceOf(address _guardian) external view returns (uint256) {\n', '        return _balanceOf(_guardian);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the detailed balance information of a guardian\n', '    * @param _guardian Address of the guardian querying the detailed balance information of\n', '    * @return active Amount of active tokens of a guardian\n', '    * @return available Amount of available tokens of a guardian\n', '    * @return locked Amount of active tokens that are locked due to ongoing disputes\n', '    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\n', '    */\n', '    function detailedBalanceOf(address _guardian) external view\n', '        returns (uint256 active, uint256 available, uint256 locked, uint256 pendingDeactivation)\n', '    {\n', '        return _detailedBalanceOf(_guardian);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the active balance of a guardian for a given term id\n', '    * @param _guardian Address of the guardian querying the active balance of\n', '    * @param _termId Term ID to query on\n', '    * @return Amount of active tokens for guardian in the requested past term id\n', '    */\n', '    function activeBalanceOfAt(address _guardian, uint64 _termId) external view returns (uint256) {\n', '        return _activeBalanceOfAt(_guardian, _termId);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the amount of active tokens of a guardian at the last ensured term that are not locked due to ongoing disputes\n', '    * @param _guardian Address of the guardian querying the unlocked balance of\n', '    * @return Amount of active tokens of a guardian that are not locked due to ongoing disputes\n', '    */\n', '    function unlockedActiveBalanceOf(address _guardian) external view returns (uint256) {\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        return _currentUnlockedActiveBalanceOf(guardian);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the pending deactivation details for a guardian\n', '    * @param _guardian Address of the guardian whose info is requested\n', '    * @return amount Amount to be deactivated\n', '    * @return availableTermId Term in which the deactivated amount will be available\n', '    */\n', '    function getDeactivationRequest(address _guardian) external view returns (uint256 amount, uint64 availableTermId) {\n', '        DeactivationRequest storage request = guardiansByAddress[_guardian].deactivationRequest;\n', '        return (request.amount, request.availableTermId);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the activation amount locked for a guardian by a lock manager\n', '    * @param _guardian Address of the guardian whose info is requested\n', '    * @param _lockManager Address of the lock manager querying the lock of\n', '    * @return amount Activation amount locked by the lock manager\n', '    * @return total Total activation amount locked for the guardian\n', '    */\n', '    function getActivationLock(address _guardian, address _lockManager) external view returns (uint256 amount, uint256 total) {\n', '        ActivationLocks storage activationLocks = guardiansByAddress[_guardian].activationLocks;\n', '        total = activationLocks.total;\n', '        amount = activationLocks.lockedBy[_lockManager];\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the withdrawals lock term ID for a guardian\n', '    * @param _guardian Address of the guardian whose info is requested\n', "    * @return Term ID until which the guardian's withdrawals will be locked\n", '    */\n', '    function getWithdrawalsLockTermId(address _guardian) external view returns (uint64) {\n', '        return guardiansByAddress[_guardian].withdrawalsLockTermId;\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the identification number associated to a guardian address\n', '    * @param _guardian Address of the guardian querying the identification number of\n', "    * @return Identification number associated to a guardian address, zero in case it wasn't registered yet\n", '    */\n', '    function getGuardianId(address _guardian) external view returns (uint256) {\n', '        return guardiansByAddress[_guardian].id;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to activate a given amount of tokens for a guardian.\n', '    *      This function assumes that the given term is the current term and has already been ensured.\n', '    * @param _guardian Address of the guardian to activate tokens\n', '    * @param _amount Amount of guardian tokens to be activated\n', '    */\n', '    function _activate(address _guardian, uint256 _amount) internal {\n', '        uint64 termId = _ensureCurrentTerm();\n', '\n', '        // Try to clean a previous deactivation request if any\n', '        _processDeactivationRequest(_guardian, termId);\n', '\n', '        uint256 availableBalance = guardiansByAddress[_guardian].availableBalance;\n', '        uint256 amountToActivate = _amount == 0 ? availableBalance : _amount;\n', '        require(amountToActivate > 0, ERROR_INVALID_ZERO_AMOUNT);\n', '        require(amountToActivate <= availableBalance, ERROR_INVALID_ACTIVATION_AMOUNT);\n', '\n', '        uint64 nextTermId = termId + 1;\n', '        _checkTotalActiveBalance(nextTermId, amountToActivate);\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        uint256 minActiveBalance = _getMinActiveBalance(nextTermId);\n', '\n', '        if (_existsGuardian(guardian)) {\n', "            // Even though we are adding amounts, let's check the new active balance is greater than or equal to the\n", '            // minimum active amount. Note that the guardian might have been slashed.\n', '            uint256 activeBalance = tree.getItem(guardian.id);\n', '            require(activeBalance.add(amountToActivate) >= minActiveBalance, ERROR_ACTIVE_BALANCE_BELOW_MIN);\n', '            tree.update(guardian.id, nextTermId, amountToActivate, true);\n', '        } else {\n', '            require(amountToActivate >= minActiveBalance, ERROR_ACTIVE_BALANCE_BELOW_MIN);\n', '            guardian.id = tree.insert(nextTermId, amountToActivate);\n', '            guardiansAddressById[guardian.id] = _guardian;\n', '        }\n', '\n', '        _updateAvailableBalanceOf(_guardian, amountToActivate, false);\n', '        emit GuardianActivated(_guardian, nextTermId, amountToActivate);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to deactivate a given amount of tokens for a guardian.\n', '    * @param _guardian Address of the guardian to deactivate tokens\n', '    * @param _amount Amount of guardian tokens to be deactivated for the next term\n', '    */\n', '    function _deactivate(address _guardian, uint256 _amount) internal {\n', '        uint64 termId = _ensureCurrentTerm();\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        uint256 unlockedActiveBalance = _lastUnlockedActiveBalanceOf(guardian);\n', '        uint256 amountToDeactivate = _amount == 0 ? unlockedActiveBalance : _amount;\n', '        require(amountToDeactivate > 0, ERROR_INVALID_ZERO_AMOUNT);\n', '        require(amountToDeactivate <= unlockedActiveBalance, ERROR_INVALID_DEACTIVATION_AMOUNT);\n', '\n', '        // Check future balance is not below the total activation lock of the guardian\n', '        // No need for SafeMath: we already checked values above\n', '        uint256 futureActiveBalance = unlockedActiveBalance - amountToDeactivate;\n', '        uint256 totalActivationLock = guardian.activationLocks.total;\n', '        require(futureActiveBalance >= totalActivationLock, ERROR_DEACTIVATION_AMOUNT_EXCEEDS_LOCK);\n', '\n', '        // Check that the guardian is leaving or that the minimum active balance is met\n', '        uint256 minActiveBalance = _getMinActiveBalance(termId);\n', '        require(futureActiveBalance == 0 || futureActiveBalance >= minActiveBalance, ERROR_INVALID_DEACTIVATION_AMOUNT);\n', '\n', '        _createDeactivationRequest(_guardian, amountToDeactivate);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to create a token deactivation request for a guardian. Guardians will be allowed\n', '    *      to process a deactivation request from the next term.\n', '    * @param _guardian Address of the guardian to create a token deactivation request for\n', '    * @param _amount Amount of guardian tokens requested for deactivation\n', '    */\n', '    function _createDeactivationRequest(address _guardian, uint256 _amount) internal {\n', '        uint64 termId = _ensureCurrentTerm();\n', '\n', '        // Try to clean a previous deactivation request if possible\n', '        _processDeactivationRequest(_guardian, termId);\n', '\n', '        uint64 nextTermId = termId + 1;\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        DeactivationRequest storage request = guardian.deactivationRequest;\n', '        request.amount = request.amount.add(_amount);\n', '        request.availableTermId = nextTermId;\n', '        tree.update(guardian.id, nextTermId, _amount, false);\n', '\n', '        emit GuardianDeactivationRequested(_guardian, nextTermId, _amount);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to process a token deactivation requested by a guardian. It will move the requested amount\n', '    *      to the available balance of the guardian if the term when the deactivation was requested has already finished.\n', '    * @param _guardian Address of the guardian to process the deactivation request of\n', '    * @param _termId Current term id\n', '    */\n', '    function _processDeactivationRequest(address _guardian, uint64 _termId) internal {\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        DeactivationRequest storage request = guardian.deactivationRequest;\n', '        uint64 deactivationAvailableTermId = request.availableTermId;\n', '\n', '        // If there is a deactivation request, ensure that the deactivation term has been reached\n', '        if (deactivationAvailableTermId == uint64(0) || _termId < deactivationAvailableTermId) {\n', '            return;\n', '        }\n', '\n', '        uint256 deactivationAmount = request.amount;\n', '        // Note that we can use a zeroed term ID to denote void here since we are storing\n', '        // the minimum allowed term to deactivate tokens which will always be at least 1.\n', '        request.availableTermId = uint64(0);\n', '        request.amount = 0;\n', '        _updateAvailableBalanceOf(_guardian, deactivationAmount, true);\n', '\n', '        emit GuardianDeactivationProcessed(_guardian, deactivationAvailableTermId, deactivationAmount, _termId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to reduce a token deactivation requested by a guardian. It assumes the deactivation request\n', '    *      cannot be processed for the given term yet.\n', '    * @param _guardian Address of the guardian to reduce the deactivation request of\n', '    * @param _amount Amount to be reduced from the current deactivation request\n', '    * @param _termId Term ID in which the deactivation request is being reduced\n', '    */\n', '    function _reduceDeactivationRequest(address _guardian, uint256 _amount, uint64 _termId) internal {\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        DeactivationRequest storage request = guardian.deactivationRequest;\n', '        uint256 currentRequestAmount = request.amount;\n', '        require(currentRequestAmount >= _amount, ERROR_CANNOT_REDUCE_DEACTIVATION_REQUEST);\n', '\n', '        // No need for SafeMath: we already checked values above\n', '        uint256 newRequestAmount = currentRequestAmount - _amount;\n', '        request.amount = newRequestAmount;\n', '\n', '        // Move amount back to the tree\n', '        tree.update(guardian.id, _termId + 1, _amount, true);\n', '\n', '        emit GuardianDeactivationUpdated(_guardian, request.availableTermId, newRequestAmount, _termId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to update the activation locked amount of a guardian\n', '    * @param _guardian Guardian to update the activation locked amount of\n', '    * @param _lockManager Address of the lock manager controlling the lock\n', '    * @param _amount Amount of tokens to be added to the activation locked amount of the guardian\n', '    */\n', '    function _lockActivation(address _guardian, address _lockManager, uint256 _amount) internal {\n', '        ActivationLocks storage activationLocks = guardiansByAddress[_guardian].activationLocks;\n', '        uint256 newTotalLocked = activationLocks.total.add(_amount);\n', '        uint256 newLockedAmount = activationLocks.lockedBy[_lockManager].add(_amount);\n', '\n', '        activationLocks.total = newTotalLocked;\n', '        activationLocks.lockedBy[_lockManager] = newLockedAmount;\n', '        emit GuardianActivationLockChanged(_guardian, _lockManager, newLockedAmount, newTotalLocked);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to stake an amount of tokens for a guardian\n', '    * @param _guardian Address of the guardian to deposit the tokens to\n', '    * @param _amount Amount of tokens to be deposited\n', '    */\n', '    function _stake(address _guardian, uint256 _amount) internal {\n', '        require(_amount > 0, ERROR_INVALID_ZERO_AMOUNT);\n', '        _updateAvailableBalanceOf(_guardian, _amount, true);\n', '\n', '        emit Staked(_guardian, _amount, _balanceOf(_guardian));\n', '        require(guardiansToken.safeTransferFrom(msg.sender, address(this), _amount), ERROR_TOKEN_TRANSFER_FAILED);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to unstake an amount of tokens of a guardian\n', '    * @param _guardian Address of the guardian to to unstake the tokens of\n', '    * @param _amount Amount of tokens to be unstaked\n', '    */\n', '    function _unstake(address _guardian, uint256 _amount) internal {\n', '        require(_amount > 0, ERROR_INVALID_ZERO_AMOUNT);\n', '\n', "        // Try to process a deactivation request for the current term if there is one. Note that we don't need to ensure\n", '        // the current term this time since deactivation requests always work with future terms, which means that if\n', '        // the current term is outdated, it will never match the deactivation term id. We avoid ensuring the term here\n', '        // to avoid forcing guardians to do that in order to withdraw their available balance. Same applies to final round locks.\n', '        uint64 lastEnsuredTermId = _getLastEnsuredTermId();\n', '\n', "        // Check that guardian's withdrawals are not locked\n", '        uint64 withdrawalsLockTermId = guardiansByAddress[_guardian].withdrawalsLockTermId;\n', '        require(withdrawalsLockTermId == 0 || withdrawalsLockTermId < lastEnsuredTermId, ERROR_WITHDRAWALS_LOCK);\n', '\n', '        _processDeactivationRequest(_guardian, lastEnsuredTermId);\n', '\n', '        _updateAvailableBalanceOf(_guardian, _amount, false);\n', '        emit Unstaked(_guardian, _amount, _balanceOf(_guardian));\n', '        require(guardiansToken.safeTransfer(_guardian, _amount), ERROR_TOKEN_TRANSFER_FAILED);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to update the available balance of a guardian\n', '    * @param _guardian Guardian to update the available balance of\n', '    * @param _amount Amount of tokens to be added to or removed from the available balance of a guardian\n', '    * @param _positive True if the given amount should be added, or false to remove it from the available balance\n', '    */\n', '    function _updateAvailableBalanceOf(address _guardian, uint256 _amount, bool _positive) internal {\n', '        // We are not using a require here to avoid reverting in case any of the treasury maths reaches this point\n', '        // with a zeroed amount value. Instead, we are doing this validation in the external entry points such as\n', '        // stake, unstake, activate, deactivate, among others.\n', '        if (_amount == 0) {\n', '            return;\n', '        }\n', '\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        if (_positive) {\n', '            guardian.availableBalance = guardian.availableBalance.add(_amount);\n', '        } else {\n', '            require(_amount <= guardian.availableBalance, ERROR_NOT_ENOUGH_AVAILABLE_BALANCE);\n', '            // No need for SafeMath: we already checked values right above\n', '            guardian.availableBalance -= _amount;\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to set new limit of total active balance of guardian tokens\n', '    * @param _totalActiveBalanceLimit New limit of total active balance of guardian tokens\n', '    */\n', '    function _setTotalActiveBalanceLimit(uint256 _totalActiveBalanceLimit) internal {\n', '        require(_totalActiveBalanceLimit > 0, ERROR_BAD_TOTAL_ACTIVE_BALANCE_LIMIT);\n', '        emit TotalActiveBalanceLimitChanged(totalActiveBalanceLimit, _totalActiveBalanceLimit);\n', '        totalActiveBalanceLimit = _totalActiveBalanceLimit;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to tell the total balance of tokens held by a guardian\n', '    * @param _guardian Address of the guardian querying the total balance of\n', '    * @return Total amount of tokens of a guardian\n', '    */\n', '    function _balanceOf(address _guardian) internal view returns (uint256) {\n', '        (uint256 active, uint256 available, , uint256 pendingDeactivation) = _detailedBalanceOf(_guardian);\n', '        return available.add(active).add(pendingDeactivation);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to tell the detailed balance information of a guardian\n', '    * @param _guardian Address of the guardian querying the balance information of\n', '    * @return active Amount of active tokens of a guardian\n', '    * @return available Amount of available tokens of a guardian\n', '    * @return locked Amount of active tokens that are locked due to ongoing disputes\n', '    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\n', '    */\n', '    function _detailedBalanceOf(address _guardian) internal view\n', '        returns (uint256 active, uint256 available, uint256 locked, uint256 pendingDeactivation)\n', '    {\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '\n', '        active = _existsGuardian(guardian) ? tree.getItem(guardian.id) : 0;\n', '        (available, locked, pendingDeactivation) = _getBalances(guardian);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the active balance of a guardian for a given term id\n', '    * @param _guardian Address of the guardian querying the active balance of\n', '    * @param _termId Term ID querying the active balance for\n', '    * @return Amount of active tokens for guardian in the requested past term id\n', '    */\n', '    function _activeBalanceOfAt(address _guardian, uint64 _termId) internal view returns (uint256) {\n', '        Guardian storage guardian = guardiansByAddress[_guardian];\n', '        return _existsGuardian(guardian) ? tree.getItemAt(guardian.id, _termId) : 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the amount of active tokens of a guardian that are not locked due to ongoing disputes\n', '    *      It will use the last value, that might be in a future term\n', '    * @param _guardian Guardian querying the unlocked active balance of\n', '    * @return Amount of active tokens of a guardian that are not locked due to ongoing disputes\n', '    */\n', '    function _lastUnlockedActiveBalanceOf(Guardian storage _guardian) internal view returns (uint256) {\n', '        return _existsGuardian(_guardian) ? tree.getItem(_guardian.id).sub(_guardian.lockedBalance) : 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the amount of active tokens at the last ensured term of a guardian that are not locked due to ongoing disputes\n', '    * @param _guardian Guardian querying the unlocked active balance of\n', '    * @return Amount of active tokens of a guardian that are not locked due to ongoing disputes\n', '    */\n', '    function _currentUnlockedActiveBalanceOf(Guardian storage _guardian) internal view returns (uint256) {\n', '        uint64 lastEnsuredTermId = _getLastEnsuredTermId();\n', '        return _existsGuardian(_guardian) ? tree.getItemAt(_guardian.id, lastEnsuredTermId).sub(_guardian.lockedBalance) : 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to check if a guardian was already registered\n', '    * @param _guardian Guardian to be checked\n', '    * @return True if the given guardian was already registered, false otherwise\n', '    */\n', '    function _existsGuardian(Guardian storage _guardian) internal view returns (bool) {\n', '        return _guardian.id != 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to get the amount of a deactivation request for a given term id\n', '    * @param _guardian Guardian to query the deactivation request amount of\n', '    * @param _termId Term ID of the deactivation request to be queried\n', '    * @return Amount of the deactivation request for the given term, 0 otherwise\n', '    */\n', '    function _deactivationRequestedAmountForTerm(Guardian storage _guardian, uint64 _termId) internal view returns (uint256) {\n', '        DeactivationRequest storage request = _guardian.deactivationRequest;\n', '        return request.availableTermId == _termId ? request.amount : 0;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to tell the total amount of active guardian tokens at the given term id\n', '    * @param _termId Term ID querying the total active balance for\n', '    * @return Total amount of active guardian tokens at the given term id\n', '    */\n', '    function _totalActiveBalanceAt(uint64 _termId) internal view returns (uint256) {\n', '        // This function will return always the same values, the\xa0only difference remains on gas costs. In case we look for a\n', '        // recent term, in this case current or future ones, we perform a backwards linear search from the last checkpoint.\n', '        // Otherwise, a binary search is computed.\n', '        bool recent = _termId >= _getLastEnsuredTermId();\n', '        return recent ? tree.getRecentTotalAt(_termId) : tree.getTotalAt(_termId);\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to check if its possible to add a given new amount to the registry or not\n', '    * @param _termId Term ID when the new amount will be added\n', '    * @param _amount Amount of tokens willing to be added to the registry\n', '    */\n', '    function _checkTotalActiveBalance(uint64 _termId, uint256 _amount) internal view {\n', '        uint256 currentTotalActiveBalance = _totalActiveBalanceAt(_termId);\n', '        uint256 newTotalActiveBalance = currentTotalActiveBalance.add(_amount);\n', '        require(newTotalActiveBalance <= totalActiveBalanceLimit, ERROR_TOTAL_ACTIVE_BALANCE_EXCEEDED);\n', '    }\n', '\n', '    /**\n', '    * @dev Tell the local balance information of a guardian (that is not on the tree)\n', '    * @param _guardian Address of the guardian querying the balance information of\n', '    * @return available Amount of available tokens of a guardian\n', '    * @return locked Amount of active tokens that are locked due to ongoing disputes\n', '    * @return pendingDeactivation Amount of active tokens that were requested for deactivation\n', '    */\n', '    function _getBalances(Guardian storage _guardian) internal view returns (uint256 available, uint256 locked, uint256 pendingDeactivation) {\n', '        available = _guardian.availableBalance;\n', '        locked = _guardian.lockedBalance;\n', '        pendingDeactivation = _guardian.deactivationRequest.amount;\n', '    }\n', '\n', '    /**\n', '    * @dev Internal function to search guardians in the tree based on certain search restrictions\n', '    * @param _params Draft params to be used for the guardians search\n', '    * @return ids List of guardian ids obtained based on the requested search\n', '    * @return activeBalances List of active balances for each guardian obtained based on the requested search\n', '    */\n', '    function _treeSearch(DraftParams memory _params) internal view returns (uint256[] memory ids, uint256[] memory activeBalances) {\n', '        (ids, activeBalances) = tree.batchedRandomSearch(\n', '            _params.termRandomness,\n', '            _params.disputeId,\n', '            _params.termId,\n', '            _params.selectedGuardians,\n', '            _params.batchRequestedGuardians,\n', '            _params.roundRequestedGuardians,\n', '            _params.iteration\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev Private function to parse a certain set given of draft params\n', '    * @param _params Array containing draft requirements:\n', '    *        0. bytes32 Term randomness\n', '    *        1. uint256 Dispute id\n', '    *        2. uint64  Current term id\n', '    *        3. uint256 Number of seats already filled\n', '    *        4. uint256 Number of seats left to be filled\n', '    *        5. uint64  Number of guardians required for the draft\n', '    *        6. uint16  Permyriad of the minimum active balance to be locked for the draft\n', '    *\n', '    * @return Draft params object parsed\n', '    */\n', '    function _buildDraftParams(uint256[7] memory _params) private view returns (DraftParams memory) {\n', '        uint64 termId = uint64(_params[2]);\n', '        uint256 minActiveBalance = _getMinActiveBalance(termId);\n', '\n', '        return DraftParams({\n', '            termRandomness: bytes32(_params[0]),\n', '            disputeId: _params[1],\n', '            termId: termId,\n', '            selectedGuardians: _params[3],\n', '            batchRequestedGuardians: _params[4],\n', '            roundRequestedGuardians: _params[5],\n', '            draftLockAmount: minActiveBalance.pct(uint16(_params[6])),\n', '            iteration: 0\n', '        });\n', '    }\n', '}']