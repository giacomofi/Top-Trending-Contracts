['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-11\n', '*/\n', '\n', '// File: contracts/interfaces/IReserveInterestRateStrategy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', '* IReserveInterestRateStrategyInterface interface\n', '* -\n', '* Interface for the calculation of the interest rates.\n', '* -\n', '* This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', '**/\n', '\n', 'interface IReserveInterestRateStrategy {\n', '\n', '    /**\n', '    * @dev returns the base variable borrow rate, in rays\n', '    */\n', '\n', '    function getBaseVariableBorrowRate() external view returns (uint256);\n', '    /**\n', '    * @dev calculates the liquidity, stable, and variable rates depending on the current utilization rate\n', '    *      and the base parameters\n', '    *\n', '    */\n', '    function calculateInterestRates(\n', '        address _reserve,\n', '        uint256 _utilizationRate,\n', '        uint256 _totalBorrowsStable,\n', '        uint256 _totalBorrowsVariable,\n', '        uint256 _averageStableBorrowRate)\n', '    external\n', '    view\n', '    returns (uint256 liquidityRate, uint256 stableBorrowRate, uint256 variableBorrowRate);\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/WadRayMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * WadRayMath library\n', ' * -\n', ' *  Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n', ' * -\n', ' * This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', ' **/\n', '\n', 'library WadRayMath {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 internal constant WAD = 1e18;\n', '    uint256 internal constant halfWAD = WAD / 2;\n', '\n', '    uint256 internal constant RAY = 1e27;\n', '    uint256 internal constant halfRAY = RAY / 2;\n', '\n', '    uint256 internal constant WAD_RAY_RATIO = 1e9;\n', '\n', '    function ray() internal pure returns (uint256) {\n', '        return RAY;\n', '    }\n', '\n', '    function wad() internal pure returns (uint256) {\n', '        return WAD;\n', '    }\n', '\n', '    function halfRay() internal pure returns (uint256) {\n', '        return halfRAY;\n', '    }\n', '\n', '    function halfWad() internal pure returns (uint256) {\n', '        return halfWAD;\n', '    }\n', '\n', '    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return halfWAD.add(a.mul(b)).div(WAD);\n', '    }\n', '\n', '    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 halfB = b / 2;\n', '\n', '        return halfB.add(a.mul(WAD)).div(b);\n', '    }\n', '\n', '    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return halfRAY.add(a.mul(b)).div(RAY);\n', '    }\n', '\n', '    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 halfB = b / 2;\n', '\n', '        return halfB.add(a.mul(RAY)).div(b);\n', '    }\n', '\n', '    function rayToWad(uint256 a) internal pure returns (uint256) {\n', '        uint256 halfRatio = WAD_RAY_RATIO / 2;\n', '\n', '        return halfRatio.add(a).div(WAD_RAY_RATIO);\n', '    }\n', '\n', '    function wadToRay(uint256 a) internal pure returns (uint256) {\n', '        return a.mul(WAD_RAY_RATIO);\n', '    }\n', '\n', '    /**\n', '     * @dev calculates base^exp. The code uses the ModExp precompile\n', '     * @return base^exp, in ray\n', '     */\n', '    //solium-disable-next-line\n', '    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n', '        z = n % 2 != 0 ? x : RAY;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            x = rayMul(x, x);\n', '\n', '            if (n % 2 != 0) {\n', '                z = rayMul(z, x);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/openzeppelin-upgradeability/Proxy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'contract Proxy {\n', '    /**\n', '   * @dev Fallback function.\n', '   * Implemented entirely in `_fallback`.\n', '   */\n', '    function() external payable {\n', '        _fallback();\n', '    }\n', '\n', '    /**\n', '   * @return The Address of the implementation.\n', '   */\n', '    function _implementation() internal view returns (address);\n', '\n', '    /**\n', '   * @dev Delegates execution to an implementation contract.\n', "   * This is a low level function that doesn't return to its internal call site.\n", '   * It will return to the external caller whatever the implementation returns.\n', '   * @param implementation Address to delegate.\n', '   */\n', '    function _delegate(address implementation) internal {\n', '        //solium-disable-next-line\n', '        assembly {\n', '            // Copy msg.data. We take full control of memory in this inline assembly\n', '            // block because it will not return to Solidity code. We overwrite the\n', '            // Solidity scratch pad at memory position 0.\n', '            calldatacopy(0, 0, calldatasize)\n', '\n', '            // Call the implementation.\n', "            // out and outsize are 0 because we don't know the size yet.\n", '            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\n', '\n', '            // Copy the returned data.\n', '            returndatacopy(0, 0, returndatasize)\n', '\n', '            switch result\n', '                // delegatecall returns 0 on error.\n', '                case 0 {\n', '                    revert(0, returndatasize)\n', '                }\n', '                default {\n', '                    return(0, returndatasize)\n', '                }\n', '        }\n', '    }\n', '\n', '    /**\n', '   * @dev Function that is run as the first thing in the fallback function.\n', '   * Can be redefined in derived contracts to add functionality.\n', '   * Redefinitions must call super._willFallback().\n', '   */\n', '    function _willFallback() internal {}\n', '\n', '    /**\n', '   * @dev fallback implementation.\n', '   * Extracted to enable manual triggering.\n', '   */\n', '    function _fallback() internal {\n', '        _willFallback();\n', '        _delegate(_implementation());\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following \n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/openzeppelin-upgradeability/BaseUpgradeabilityProxy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @title BaseUpgradeabilityProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'contract BaseUpgradeabilityProxy is Proxy {\n', '    /**\n', '   * @dev Emitted when the implementation is upgraded.\n', '   * @param implementation Address of the new implementation.\n', '   */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    /**\n', '   * @dev Storage slot with the address of the current implementation.\n', '   * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n', '   * validated in the constructor.\n', '   */\n', '    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    /**\n', '   * @dev Returns the current implementation.\n', '   * @return Address of the current implementation\n', '   */\n', '    function _implementation() internal view returns (address impl) {\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '        //solium-disable-next-line\n', '        assembly {\n', '            impl := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '   * @dev Upgrades the proxy to a new implementation.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '    function _upgradeTo(address newImplementation) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '\n', '    /**\n', '   * @dev Sets the implementation address of the proxy.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '    function _setImplementation(address newImplementation) internal {\n', '        require(\n', '            Address.isContract(newImplementation),\n', '            "Cannot set a proxy implementation to a non-contract address"\n', '        );\n', '\n', '        bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '        //solium-disable-next-line\n', '        assembly {\n', '            sstore(slot, newImplementation)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/openzeppelin-upgradeability/UpgradeabilityProxy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n', ' * implementation and init data.\n', ' */\n', 'contract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '    /**\n', '   * @dev Contract constructor.\n', '   * @param _logic Address of the initial implementation.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '    constructor(address _logic, bytes memory _data) public payable {\n', '        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));\n', '        _setImplementation(_logic);\n', '        if (_data.length > 0) {\n', '            (bool success, ) = _logic.delegatecall(_data);\n', '            require(success);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/openzeppelin-upgradeability/BaseAdminUpgradeabilityProxy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title BaseAdminUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with an authorization\n', ' * mechanism for administrative tasks.\n', ' * All external functions in this contract must be guarded by the\n', ' * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n', ' * feature proposal that would enable this to be done automatically.\n', ' */\n', 'contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '    /**\n', '   * @dev Emitted when the administration has been transferred.\n', '   * @param previousAdmin Address of the previous admin.\n', '   * @param newAdmin Address of the new admin.\n', '   */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '   * @dev Storage slot with the admin of the contract.\n', '   * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n', '   * validated in the constructor.\n', '   */\n', '\n', '    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n', '\n', '    /**\n', '   * @dev Modifier to check whether the `msg.sender` is the admin.\n', '   * If it is, it will run the function. Otherwise, it will delegate the call\n', '   * to the implementation.\n', '   */\n', '    modifier ifAdmin() {\n', '        if (msg.sender == _admin()) {\n', '            _;\n', '        } else {\n', '            _fallback();\n', '        }\n', '    }\n', '\n', '    /**\n', '   * @return The address of the proxy admin.\n', '   */\n', '    function admin() external ifAdmin returns (address) {\n', '        return _admin();\n', '    }\n', '\n', '    /**\n', '   * @return The address of the implementation.\n', '   */\n', '    function implementation() external ifAdmin returns (address) {\n', '        return _implementation();\n', '    }\n', '\n', '    /**\n', '   * @dev Changes the admin of the proxy.\n', '   * Only the current admin can call this function.\n', '   * @param newAdmin Address to transfer proxy administration to.\n', '   */\n', '    function changeAdmin(address newAdmin) external ifAdmin {\n', '        require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");\n', '        emit AdminChanged(_admin(), newAdmin);\n', '        _setAdmin(newAdmin);\n', '    }\n', '\n', '    /**\n', '   * @dev Upgrade the backing implementation of the proxy.\n', '   * Only the admin can call this function.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '    function upgradeTo(address newImplementation) external ifAdmin {\n', '        _upgradeTo(newImplementation);\n', '    }\n', '\n', '    /**\n', '   * @dev Upgrade the backing implementation of the proxy and call a function\n', '   * on the new implementation.\n', '   * This is useful to initialize the proxied contract.\n', '   * @param newImplementation Address of the new implementation.\n', '   * @param data Data to send as msg.data in the low level call.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   */\n', '    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n', '        _upgradeTo(newImplementation);\n', '        (bool success, ) = newImplementation.delegatecall(data);\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '   * @return The admin slot.\n', '   */\n', '    function _admin() internal view returns (address adm) {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        //solium-disable-next-line\n', '        assembly {\n', '            adm := sload(slot)\n', '        }\n', '    }\n', '\n', '    /**\n', '   * @dev Sets the address of the proxy admin.\n', '   * @param newAdmin Address of the new proxy admin.\n', '   */\n', '    function _setAdmin(address newAdmin) internal {\n', '        bytes32 slot = ADMIN_SLOT;\n', '        //solium-disable-next-line\n', '        assembly {\n', '            sstore(slot, newAdmin)\n', '        }\n', '    }\n', '\n', '    /**\n', '   * @dev Only fall back when the sender is not the admin.\n', '   */\n', '    function _willFallback() internal {\n', '        require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");\n', '        super._willFallback();\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/openzeppelin-upgradeability/InitializableUpgradeabilityProxy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title InitializableUpgradeabilityProxy\n', ' * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n', ' * implementation and init data.\n', ' */\n', 'contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '    /**\n', '   * @dev Contract initializer.\n', '   * @param _logic Address of the initial implementation.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '    function initialize(address _logic, bytes memory _data) public payable {\n', '        require(_implementation() == address(0));\n', '        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));\n', '        _setImplementation(_logic);\n', '        if (_data.length > 0) {\n', '            (bool success, ) = _logic.delegatecall(_data);\n', '            require(success);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/openzeppelin-upgradeability/InitializableAdminUpgradeabilityProxy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @title InitializableAdminUpgradeabilityProxy\n', ' * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \n', ' * initializing the implementation, admin, and init data.\n', ' */\n', 'contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n', '    /**\n', '   * Contract initializer.\n', '   * @param _logic address of the initial implementation.\n', '   * @param _admin Address of the proxy administrator.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '    function initialize(address _logic, address _admin, bytes memory _data) public payable {\n', '        require(_implementation() == address(0));\n', '        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n', '        assert(ADMIN_SLOT == bytes32(uint256(keccak256("eip1967.proxy.admin")) - 1));\n', '        _setAdmin(_admin);\n', '    }\n', '}\n', '\n', '// File: contracts/configuration/AddressStorage.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'contract AddressStorage {\n', '    mapping(bytes32 => address) private addresses;\n', '\n', '    function getAddress(bytes32 _key) public view returns (address) {\n', '        return addresses[_key];\n', '    }\n', '\n', '    function _setAddress(bytes32 _key, address _value) internal {\n', '        addresses[_key] = _value;\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/interfaces/ILendingPoolAddressesProvider.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', '* ILendingPoolAddressesProvider interface\n', '* -\n', '* Provides the interface to fetch the LendingPoolCore address\n', '* -\n', '* This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', '**/\n', '\n', 'contract ILendingPoolAddressesProvider {\n', '\n', '    function getLendingPool() public view returns (address);\n', '    function setLendingPoolImpl(address _pool) public;\n', '\n', '    function getLendingPoolCore() public view returns (address payable);\n', '    function setLendingPoolCoreImpl(address _lendingPoolCore) public;\n', '\n', '    function getLendingPoolConfigurator() public view returns (address);\n', '    function setLendingPoolConfiguratorImpl(address _configurator) public;\n', '\n', '    function getLendingPoolDataProvider() public view returns (address);\n', '    function setLendingPoolDataProviderImpl(address _provider) public;\n', '\n', '    function getLendingPoolParametersProvider() public view returns (address);\n', '    function setLendingPoolParametersProviderImpl(address _parametersProvider) public;\n', '\n', '    function getTokenDistributor() public view returns (address);\n', '    function setTokenDistributor(address _tokenDistributor) public;\n', '\n', '\n', '    function getFeeProvider() public view returns (address);\n', '    function setFeeProviderImpl(address _feeProvider) public;\n', '\n', '    function getLendingPoolLiquidationManager() public view returns (address);\n', '    function setLendingPoolLiquidationManager(address _manager) public;\n', '\n', '    function getLendingPoolManager() public view returns (address);\n', '    function setLendingPoolManager(address _lendingPoolManager) public;\n', '\n', '    function getPriceOracle() public view returns (address);\n', '    function setPriceOracle(address _priceOracle) public;\n', '\n', '    function getLendingRateOracle() public view returns (address);\n', '    function setLendingRateOracle(address _lendingRateOracle) public;\n', '\n', '}\n', '\n', '// File: contracts/configuration/LendingPoolAddressesProvider.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* LendingPoolAddressesProvider contract\n', '* -\n', '* Is the main registry of the protocol. All the different components of the protocol are accessible\n', '* through the addresses provider.\n', '* -\n', '* This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', '**/\n', '\n', '/**\n', '\n', '\n', ' */\n', '\n', 'contract LendingPoolAddressesProvider is Ownable, ILendingPoolAddressesProvider, AddressStorage {\n', '    //events\n', '    event LendingPoolUpdated(address indexed newAddress);\n', '    event LendingPoolCoreUpdated(address indexed newAddress);\n', '    event LendingPoolParametersProviderUpdated(address indexed newAddress);\n', '    event LendingPoolManagerUpdated(address indexed newAddress);\n', '    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n', '    event LendingPoolLiquidationManagerUpdated(address indexed newAddress);\n', '    event LendingPoolDataProviderUpdated(address indexed newAddress);\n', '    event EthereumAddressUpdated(address indexed newAddress);\n', '    event PriceOracleUpdated(address indexed newAddress);\n', '    event LendingRateOracleUpdated(address indexed newAddress);\n', '    event FeeProviderUpdated(address indexed newAddress);\n', '    event TokenDistributorUpdated(address indexed newAddress);\n', '\n', '    event ProxyCreated(bytes32 id, address indexed newAddress);\n', '\n', '    bytes32 private constant LENDING_POOL = "LENDING_POOL";\n', '    bytes32 private constant LENDING_POOL_CORE = "LENDING_POOL_CORE";\n', '    bytes32 private constant LENDING_POOL_CONFIGURATOR = "LENDING_POOL_CONFIGURATOR";\n', '    bytes32 private constant LENDING_POOL_PARAMETERS_PROVIDER = "PARAMETERS_PROVIDER";\n', '    bytes32 private constant LENDING_POOL_MANAGER = "LENDING_POOL_MANAGER";\n', '    bytes32 private constant LENDING_POOL_LIQUIDATION_MANAGER = "LIQUIDATION_MANAGER";\n', '    bytes32 private constant LENDING_POOL_FLASHLOAN_PROVIDER = "FLASHLOAN_PROVIDER";\n', '    bytes32 private constant DATA_PROVIDER = "DATA_PROVIDER";\n', '    bytes32 private constant ETHEREUM_ADDRESS = "ETHEREUM_ADDRESS";\n', '    bytes32 private constant PRICE_ORACLE = "PRICE_ORACLE";\n', '    bytes32 private constant LENDING_RATE_ORACLE = "LENDING_RATE_ORACLE";\n', '    bytes32 private constant FEE_PROVIDER = "FEE_PROVIDER";\n', '    bytes32 private constant WALLET_BALANCE_PROVIDER = "WALLET_BALANCE_PROVIDER";\n', '    bytes32 private constant TOKEN_DISTRIBUTOR = "TOKEN_DISTRIBUTOR";\n', '\n', '\n', '    /**\n', '    * @dev returns the address of the LendingPool proxy\n', '    * @return the lending pool proxy address\n', '    **/\n', '    function getLendingPool() public view returns (address) {\n', '        return getAddress(LENDING_POOL);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev updates the implementation of the lending pool\n', '    * @param _pool the new lending pool implementation\n', '    **/\n', '    function setLendingPoolImpl(address _pool) public onlyOwner {\n', '        updateImplInternal(LENDING_POOL, _pool);\n', '        emit LendingPoolUpdated(_pool);\n', '    }\n', '\n', '    /**\n', '    * @dev returns the address of the LendingPoolCore proxy\n', '    * @return the lending pool core proxy address\n', '     */\n', '    function getLendingPoolCore() public view returns (address payable) {\n', '        address payable core = address(uint160(getAddress(LENDING_POOL_CORE)));\n', '        return core;\n', '    }\n', '\n', '    /**\n', '    * @dev updates the implementation of the lending pool core\n', '    * @param _lendingPoolCore the new lending pool core implementation\n', '    **/\n', '    function setLendingPoolCoreImpl(address _lendingPoolCore) public onlyOwner {\n', '        updateImplInternal(LENDING_POOL_CORE, _lendingPoolCore);\n', '        emit LendingPoolCoreUpdated(_lendingPoolCore);\n', '    }\n', '\n', '    /**\n', '    * @dev returns the address of the LendingPoolConfigurator proxy\n', '    * @return the lending pool configurator proxy address\n', '    **/\n', '    function getLendingPoolConfigurator() public view returns (address) {\n', '        return getAddress(LENDING_POOL_CONFIGURATOR);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the implementation of the lending pool configurator\n', '    * @param _configurator the new lending pool configurator implementation\n', '    **/\n', '    function setLendingPoolConfiguratorImpl(address _configurator) public onlyOwner {\n', '        updateImplInternal(LENDING_POOL_CONFIGURATOR, _configurator);\n', '        emit LendingPoolConfiguratorUpdated(_configurator);\n', '    }\n', '\n', '    /**\n', '    * @dev returns the address of the LendingPoolDataProvider proxy\n', '    * @return the lending pool data provider proxy address\n', '     */\n', '    function getLendingPoolDataProvider() public view returns (address) {\n', '        return getAddress(DATA_PROVIDER);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the implementation of the lending pool data provider\n', '    * @param _provider the new lending pool data provider implementation\n', '    **/\n', '    function setLendingPoolDataProviderImpl(address _provider) public onlyOwner {\n', '        updateImplInternal(DATA_PROVIDER, _provider);\n', '        emit LendingPoolDataProviderUpdated(_provider);\n', '    }\n', '\n', '    /**\n', '    * @dev returns the address of the LendingPoolParametersProvider proxy\n', '    * @return the address of the Lending pool parameters provider proxy\n', '    **/\n', '    function getLendingPoolParametersProvider() public view returns (address) {\n', '        return getAddress(LENDING_POOL_PARAMETERS_PROVIDER);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the implementation of the lending pool parameters provider\n', '    * @param _parametersProvider the new lending pool parameters provider implementation\n', '    **/\n', '    function setLendingPoolParametersProviderImpl(address _parametersProvider) public onlyOwner {\n', '        updateImplInternal(LENDING_POOL_PARAMETERS_PROVIDER, _parametersProvider);\n', '        emit LendingPoolParametersProviderUpdated(_parametersProvider);\n', '    }\n', '\n', '    /**\n', '    * @dev returns the address of the FeeProvider proxy\n', '    * @return the address of the Fee provider proxy\n', '    **/\n', '    function getFeeProvider() public view returns (address) {\n', '        return getAddress(FEE_PROVIDER);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the implementation of the FeeProvider proxy\n', '    * @param _feeProvider the new lending pool fee provider implementation\n', '    **/\n', '    function setFeeProviderImpl(address _feeProvider) public onlyOwner {\n', '        updateImplInternal(FEE_PROVIDER, _feeProvider);\n', '        emit FeeProviderUpdated(_feeProvider);\n', '    }\n', '\n', '    /**\n', '    * @dev returns the address of the LendingPoolLiquidationManager. Since the manager is used\n', '    * through delegateCall within the LendingPool contract, the proxy contract pattern does not work properly hence\n', '    * the addresses are changed directly.\n', '    * @return the address of the Lending pool liquidation manager\n', '    **/\n', '\n', '    function getLendingPoolLiquidationManager() public view returns (address) {\n', '        return getAddress(LENDING_POOL_LIQUIDATION_MANAGER);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the address of the Lending pool liquidation manager\n', '    * @param _manager the new lending pool liquidation manager address\n', '    **/\n', '    function setLendingPoolLiquidationManager(address _manager) public onlyOwner {\n', '        _setAddress(LENDING_POOL_LIQUIDATION_MANAGER, _manager);\n', '        emit LendingPoolLiquidationManagerUpdated(_manager);\n', '    }\n', '\n', '    /**\n', '    * @dev the functions below are storing specific addresses that are outside the context of the protocol\n', '    * hence the upgradable proxy pattern is not used\n', '    **/\n', '\n', '\n', '    function getLendingPoolManager() public view returns (address) {\n', '        return getAddress(LENDING_POOL_MANAGER);\n', '    }\n', '\n', '    function setLendingPoolManager(address _lendingPoolManager) public onlyOwner {\n', '        _setAddress(LENDING_POOL_MANAGER, _lendingPoolManager);\n', '        emit LendingPoolManagerUpdated(_lendingPoolManager);\n', '    }\n', '\n', '    function getPriceOracle() public view returns (address) {\n', '        return getAddress(PRICE_ORACLE);\n', '    }\n', '\n', '    function setPriceOracle(address _priceOracle) public onlyOwner {\n', '        _setAddress(PRICE_ORACLE, _priceOracle);\n', '        emit PriceOracleUpdated(_priceOracle);\n', '    }\n', '\n', '    function getLendingRateOracle() public view returns (address) {\n', '        return getAddress(LENDING_RATE_ORACLE);\n', '    }\n', '\n', '    function setLendingRateOracle(address _lendingRateOracle) public onlyOwner {\n', '        _setAddress(LENDING_RATE_ORACLE, _lendingRateOracle);\n', '        emit LendingRateOracleUpdated(_lendingRateOracle);\n', '    }\n', '\n', '\n', '    function getTokenDistributor() public view returns (address) {\n', '        return getAddress(TOKEN_DISTRIBUTOR);\n', '    }\n', '\n', '    function setTokenDistributor(address _tokenDistributor) public onlyOwner {\n', '        _setAddress(TOKEN_DISTRIBUTOR, _tokenDistributor);\n', '        emit TokenDistributorUpdated(_tokenDistributor);\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev internal function to update the implementation of a specific component of the protocol\n', '    * @param _id the id of the contract to be updated\n', '    * @param _newAddress the address of the new implementation\n', '    **/\n', '    function updateImplInternal(bytes32 _id, address _newAddress) internal {\n', '        address payable proxyAddress = address(uint160(getAddress(_id)));\n', '\n', '        InitializableAdminUpgradeabilityProxy proxy = InitializableAdminUpgradeabilityProxy(proxyAddress);\n', '        bytes memory params = abi.encodeWithSignature("initialize(address)", address(this));\n', '\n', '        if (proxyAddress == address(0)) {\n', '            proxy = new InitializableAdminUpgradeabilityProxy();\n', '            proxy.initialize(_newAddress, address(this), params);\n', '            _setAddress(_id, address(proxy));\n', '            emit ProxyCreated(_id, address(proxy));\n', '        } else {\n', '            proxy.upgradeToAndCall(_newAddress, params);\n', '        }\n', '\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20Mintable}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See {_burn} and {_approve}.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));\n', '    }\n', '}\n', '\n', '// File: contracts/libraries/openzeppelin-upgradeability/VersionedInitializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.6.0;\n', '\n', '/**\n', ' * VersionedInitializable\n', ' * -\n', ' * Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' * -\n', ' * This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', ' **/\n', 'contract VersionedInitializable {\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    uint256 private lastInitializedRevision = 0;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private initializing;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        uint256 revision = getRevision();\n', '        require(\n', '            initializing ||\n', '                isConstructor() ||\n', '                revision > lastInitializedRevision,\n', '            "Contract instance has already been initialized"\n', '        );\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            lastInitializedRevision = revision;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev returns the revision number of the contract.\n', '    /// Needs to be defined in the inherited class as a constant.\n', '    function getRevision() internal pure returns (uint256);\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        uint256 cs;\n', '        //solium-disable-next-line\n', '        assembly {\n', '            cs := extcodesize(address)\n', '        }\n', '        return cs == 0;\n', '    }\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '// File: contracts/libraries/CoreLibrary.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * CoreLibrary library\n', ' * -\n', ' * Defines the data structures of the reserves and the user data\n', ' * -\n', ' * This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', ' **/\n', '\n', 'library CoreLibrary {\n', '    using SafeMath for uint256;\n', '    using WadRayMath for uint256;\n', '\n', '\n', '    enum InterestRateMode {NONE, STABLE, VARIABLE}\n', '\n', '    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n', '\n', '    struct UserReserveData {\n', '        //principal amount borrowed by the user.\n', '        uint256 principalBorrowBalance;\n', '        //cumulated variable borrow index for the user. Expressed in ray\n', '        uint256 lastVariableBorrowCumulativeIndex;\n', '        //origination fee cumulated by the user\n', '        uint256 originationFee;\n', '        // stable borrow rate at which the user has borrowed. Expressed in ray\n', '        uint256 stableBorrowRate;\n', '        uint40 lastUpdateTimestamp;\n', '        //defines if a specific deposit should or not be used as a collateral in borrows\n', '        bool useAsCollateral;\n', '    }\n', '\n', '    struct ReserveData {\n', '        /**\n', '         * @dev refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n', '         **/\n', '        //the liquidity index. Expressed in ray\n', '        uint256 lastLiquidityCumulativeIndex;\n', '        //the current supply rate. Expressed in ray\n', '        uint256 currentLiquidityRate;\n', '        //the total borrows of the reserve at a stable rate. Expressed in the currency decimals\n', '        uint256 totalBorrowsStable;\n', '        //the total borrows of the reserve at a variable rate. Expressed in the currency decimals\n', '        uint256 totalBorrowsVariable;\n', '        //the current variable borrow rate. Expressed in ray\n', '        uint256 currentVariableBorrowRate;\n', '        //the current stable borrow rate. Expressed in ray\n', '        uint256 currentStableBorrowRate;\n', '        //the current average stable borrow rate (weighted average of all the different stable rate loans). Expressed in ray\n', '        uint256 currentAverageStableBorrowRate;\n', '        //variable borrow index. Expressed in ray\n', '        uint256 lastVariableBorrowCumulativeIndex;\n', '        //the ltv of the reserve. Expressed in percentage (0-100)\n', '        uint256 baseLTVasCollateral;\n', '        //the liquidation threshold of the reserve. Expressed in percentage (0-100)\n', '        uint256 liquidationThreshold;\n', '        //the liquidation bonus of the reserve. Expressed in percentage\n', '        uint256 liquidationBonus;\n', '        //the decimals of the reserve asset\n', '        uint256 decimals;\n', '        /**\n', '         * @dev address of the PToken representing the asset\n', '         **/\n', '        address PTokenAddress;\n', '        /**\n', '         * @dev address of the interest rate strategy contract\n', '         **/\n', '        address interestRateStrategyAddress;\n', '        uint40 lastUpdateTimestamp;\n', '        // borrowingEnabled = true means users can borrow from this reserve\n', '        bool borrowingEnabled;\n', '        // usageAsCollateralEnabled = true means users can use this reserve as collateral\n', '        bool usageAsCollateralEnabled;\n', '        // isStableBorrowRateEnabled = true means users can borrow at a stable rate\n', '        bool isStableBorrowRateEnabled;\n', '        // isActive = true means the reserve has been activated and properly configured\n', '        bool isActive;\n', '        // isFreezed = true means the reserve only allows repays and redeems, but not deposits, new borrowings or rate swap\n', '        bool isFreezed;\n', '    }\n', '\n', '    /**\n', '     * @dev returns the ongoing normalized income for the reserve.\n', '     * a value of 1e27 means there is no income. As time passes, the income is accrued.\n', '     * A value of 2*1e27 means that the income of the reserve is double the initial amount.\n', '     * @param _reserve the reserve object\n', '     * @return the normalized income. expressed in ray\n', '     **/\n', '    function getNormalizedIncome(CoreLibrary.ReserveData storage _reserve)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        uint256 cumulated = calculateLinearInterest(\n', '            _reserve\n', '                .currentLiquidityRate,\n', '            _reserve\n', '                .lastUpdateTimestamp\n', '        )\n', '            .rayMul(_reserve.lastLiquidityCumulativeIndex);\n', '\n', '        return cumulated;\n', '    }\n', '\n', '    /**\n', '     * @dev Updates the liquidity cumulative index Ci and variable borrow cumulative index Bvc. Refer to the whitepaper for\n', '     * a formal specification.\n', '     * @param _self the reserve object\n', '     **/\n', '    function updateCumulativeIndexes(ReserveData storage _self) internal {\n', '        uint256 totalBorrows = getTotalBorrows(_self);\n', '\n', '        if (totalBorrows > 0) {\n', '            //only cumulating if there is any income being produced\n', '            uint256 cumulatedLiquidityInterest = calculateLinearInterest(\n', '                _self.currentLiquidityRate,\n', '                _self.lastUpdateTimestamp\n', '            );\n', '\n', '            _self.lastLiquidityCumulativeIndex = cumulatedLiquidityInterest\n', '                .rayMul(_self.lastLiquidityCumulativeIndex);\n', '\n', '\n', '                uint256 cumulatedVariableBorrowInterest\n', '             = calculateCompoundedInterest(\n', '                _self.currentVariableBorrowRate,\n', '                _self.lastUpdateTimestamp\n', '            );\n', '            _self\n', '                .lastVariableBorrowCumulativeIndex = cumulatedVariableBorrowInterest\n', '                .rayMul(_self.lastVariableBorrowCumulativeIndex);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev accumulates a predefined amount of asset to the reserve as a fixed, one time income. Used for example to accumulate\n', '     * the flashloan fee to the reserve, and spread it through the depositors.\n', '     * @param _self the reserve object\n', '     * @param _totalLiquidity the total liquidity available in the reserve\n', '     * @param _amount the amount to accomulate\n', '     **/\n', '    function cumulateToLiquidityIndex(\n', '        ReserveData storage _self,\n', '        uint256 _totalLiquidity,\n', '        uint256 _amount\n', '    ) internal {\n', '        uint256 amountToLiquidityRatio = _amount.wadToRay().rayDiv(\n', '            _totalLiquidity.wadToRay()\n', '        );\n', '\n', '        uint256 cumulatedLiquidity = amountToLiquidityRatio.add(\n', '            WadRayMath.ray()\n', '        );\n', '\n', '        _self.lastLiquidityCumulativeIndex = cumulatedLiquidity.rayMul(\n', '            _self.lastLiquidityCumulativeIndex\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev initializes a reserve\n', '     * @param _self the reserve object\n', '     * @param _PTokenAddress the address of the overlying PToken contract\n', '     * @param _decimals the number of decimals of the underlying asset\n', '     * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n', '     **/\n', '    function init(\n', '        ReserveData storage _self,\n', '        address _PTokenAddress,\n', '        uint256 _decimals,\n', '        address _interestRateStrategyAddress\n', '    ) external {\n', '        require(\n', '            _self.PTokenAddress == address(0),\n', '            "Reserve has already been initialized"\n', '        );\n', '\n', '        if (_self.lastLiquidityCumulativeIndex == 0) {\n', '            //if the reserve has not been initialized yet\n', '            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\n', '        }\n', '\n', '        if (_self.lastVariableBorrowCumulativeIndex == 0) {\n', '            _self.lastVariableBorrowCumulativeIndex = WadRayMath.ray();\n', '        }\n', '\n', '        _self.PTokenAddress = _PTokenAddress;\n', '        _self.decimals = _decimals;\n', '\n', '        _self.interestRateStrategyAddress = _interestRateStrategyAddress;\n', '        _self.isActive = true;\n', '        _self.isFreezed = false;\n', '    }\n', '\n', '    /**\n', '     * @dev enables borrowing on a reserve\n', '     * @param _self the reserve object\n', '     * @param _stableBorrowRateEnabled true if the stable borrow rate must be enabled by default, false otherwise\n', '     **/\n', '    function enableBorrowing(\n', '        ReserveData storage _self,\n', '        bool _stableBorrowRateEnabled\n', '    ) external {\n', '        require(_self.borrowingEnabled == false, "Reserve is already enabled");\n', '\n', '        _self.borrowingEnabled = true;\n', '        _self.isStableBorrowRateEnabled = _stableBorrowRateEnabled;\n', '    }\n', '\n', '    /**\n', '     * @dev disables borrowing on a reserve\n', '     * @param _self the reserve object\n', '     **/\n', '    function disableBorrowing(ReserveData storage _self) external {\n', '        _self.borrowingEnabled = false;\n', '    }\n', '\n', '    /**\n', '     * @dev enables a reserve to be used as collateral\n', '     * @param _self the reserve object\n', '     * @param _baseLTVasCollateral the loan to value of the asset when used as collateral\n', '     * @param _liquidationThreshold the threshold at which loans using this asset as collateral will be considered undercollateralized\n', '     * @param _liquidationBonus the bonus liquidators receive to liquidate this asset\n', '     **/\n', '    function enableAsCollateral(\n', '        ReserveData storage _self,\n', '        uint256 _baseLTVasCollateral,\n', '        uint256 _liquidationThreshold,\n', '        uint256 _liquidationBonus\n', '    ) external {\n', '        require(\n', '            _self.usageAsCollateralEnabled == false,\n', '            "Reserve is already enabled as collateral"\n', '        );\n', '\n', '        _self.usageAsCollateralEnabled = true;\n', '        _self.baseLTVasCollateral = _baseLTVasCollateral;\n', '        _self.liquidationThreshold = _liquidationThreshold;\n', '        _self.liquidationBonus = _liquidationBonus;\n', '\n', '        if (_self.lastLiquidityCumulativeIndex == 0)\n', '            _self.lastLiquidityCumulativeIndex = WadRayMath.ray();\n', '    }\n', '\n', '    /**\n', '     * @dev disables a reserve as collateral\n', '     * @param _self the reserve object\n', '     **/\n', '    function disableAsCollateral(ReserveData storage _self) external {\n', '        _self.usageAsCollateralEnabled = false;\n', '    }\n', '\n', '    \n', '\n', '    /**\n', '     * @dev calculates the compounded borrow balance of a user\n', '     * @param _self the userReserve object\n', '     * @param _reserve the reserve object\n', '     * @return the user compounded borrow balance\n', '     **/\n', '    function getCompoundedBorrowBalance(\n', '        CoreLibrary.UserReserveData storage _self,\n', '        CoreLibrary.ReserveData storage _reserve\n', '    ) internal view returns (uint256) {\n', '        if (_self.principalBorrowBalance == 0) return 0;\n', '\n', '        uint256 principalBorrowBalanceRay = _self\n', '            .principalBorrowBalance\n', '            .wadToRay();\n', '        uint256 compoundedBalance = 0;\n', '        uint256 cumulatedInterest = 0;\n', '\n', '        if (_self.stableBorrowRate > 0) {\n', '            cumulatedInterest = calculateCompoundedInterest(\n', '                _self.stableBorrowRate,\n', '                _self.lastUpdateTimestamp\n', '            );\n', '        } else {\n', '            //variable interest\n', '            cumulatedInterest = calculateCompoundedInterest(\n', '                _reserve\n', '                    .currentVariableBorrowRate,\n', '                _reserve\n', '                    .lastUpdateTimestamp\n', '            )\n', '                .rayMul(_reserve.lastVariableBorrowCumulativeIndex)\n', '                .rayDiv(_self.lastVariableBorrowCumulativeIndex);\n', '        }\n', '\n', '        compoundedBalance = principalBorrowBalanceRay\n', '            .rayMul(cumulatedInterest)\n', '            .rayToWad();\n', '\n', '        if (compoundedBalance == _self.principalBorrowBalance) {\n', '            //solium-disable-next-line\n', '            if (_self.lastUpdateTimestamp != block.timestamp) {\n', '                //no interest cumulation because of the rounding - we add 1 wei\n', '                //as symbolic cumulated interest to avoid interest free loans.\n', '\n', '                return _self.principalBorrowBalance.add(1 wei);\n', '            }\n', '        }\n', '\n', '        return compoundedBalance;\n', '    }\n', '\n', '    /**\n', '     * @dev increases the total borrows at a stable rate on a specific reserve and updates the\n', '     * average stable rate consequently\n', '     * @param _reserve the reserve object\n', '     * @param _amount the amount to add to the total borrows stable\n', '     * @param _rate the rate at which the amount has been borrowed\n', '     **/\n', '    function increaseTotalBorrowsStableAndUpdateAverageRate(\n', '        ReserveData storage _reserve,\n', '        uint256 _amount,\n', '        uint256 _rate\n', '    ) internal {\n', '        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\n', '        //updating reserve borrows stable\n', '        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.add(_amount);\n', '\n', '        //update the average stable rate\n', '        //weighted average of all the borrows\n', '        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\n', '        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable\n', '            .wadToRay()\n', '            .rayMul(_reserve.currentAverageStableBorrowRate);\n', '\n', '        _reserve.currentAverageStableBorrowRate = weightedLastBorrow\n', '            .add(weightedPreviousTotalBorrows)\n', '            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\n', '    }\n', '\n', '    /**\n', '     * @dev decreases the total borrows at a stable rate on a specific reserve and updates the\n', '     * average stable rate consequently\n', '     * @param _reserve the reserve object\n', '     * @param _amount the amount to substract to the total borrows stable\n', '     * @param _rate the rate at which the amount has been repaid\n', '     **/\n', '    function decreaseTotalBorrowsStableAndUpdateAverageRate(\n', '        ReserveData storage _reserve,\n', '        uint256 _amount,\n', '        uint256 _rate\n', '    ) internal {\n', '        require(\n', '            _reserve.totalBorrowsStable >= _amount,\n', '            "Invalid amount to decrease"\n', '        );\n', '\n', '        uint256 previousTotalBorrowStable = _reserve.totalBorrowsStable;\n', '\n', '        //updating reserve borrows stable\n', '        _reserve.totalBorrowsStable = _reserve.totalBorrowsStable.sub(_amount);\n', '\n', '        if (_reserve.totalBorrowsStable == 0) {\n', '            _reserve.currentAverageStableBorrowRate = 0; //no income if there are no stable rate borrows\n', '            return;\n', '        }\n', '\n', '        //update the average stable rate\n', '        //weighted average of all the borrows\n', '        uint256 weightedLastBorrow = _amount.wadToRay().rayMul(_rate);\n', '        uint256 weightedPreviousTotalBorrows = previousTotalBorrowStable\n', '            .wadToRay()\n', '            .rayMul(_reserve.currentAverageStableBorrowRate);\n', '\n', '        require(\n', '            weightedPreviousTotalBorrows >= weightedLastBorrow,\n', '            "The amounts to subtract don\'t match"\n', '        );\n', '\n', '        _reserve.currentAverageStableBorrowRate = weightedPreviousTotalBorrows\n', '            .sub(weightedLastBorrow)\n', '            .rayDiv(_reserve.totalBorrowsStable.wadToRay());\n', '    }\n', '\n', '    /**\n', '     * @dev increases the total borrows at a variable rate\n', '     * @param _reserve the reserve object\n', '     * @param _amount the amount to add to the total borrows variable\n', '     **/\n', '    function increaseTotalBorrowsVariable(\n', '        ReserveData storage _reserve,\n', '        uint256 _amount\n', '    ) internal {\n', '        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.add(\n', '            _amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev decreases the total borrows at a variable rate\n', '     * @param _reserve the reserve object\n', '     * @param _amount the amount to substract to the total borrows variable\n', '     **/\n', '    function decreaseTotalBorrowsVariable(\n', '        ReserveData storage _reserve,\n', '        uint256 _amount\n', '    ) internal {\n', '        require(\n', '            _reserve.totalBorrowsVariable >= _amount,\n', '            "The amount that is being subtracted from the variable total borrows is incorrect"\n', '        );\n', '        _reserve.totalBorrowsVariable = _reserve.totalBorrowsVariable.sub(\n', '            _amount\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev function to calculate the interest using a linear interest rate formula\n', '     * @param _rate the interest rate, in ray\n', '     * @param _lastUpdateTimestamp the timestamp of the last update of the interest\n', '     * @return the interest rate linearly accumulated during the timeDelta, in ray\n', '     **/\n', '\n', '    function calculateLinearInterest(uint256 _rate, uint40 _lastUpdateTimestamp)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        //solium-disable-next-line\n', '        uint256 timeDifference = block.timestamp.sub(\n', '            uint256(_lastUpdateTimestamp)\n', '        );\n', '\n', '        uint256 timeDelta = timeDifference.wadToRay().rayDiv(\n', '            SECONDS_PER_YEAR.wadToRay()\n', '        );\n', '\n', '        return _rate.rayMul(timeDelta).add(WadRayMath.ray());\n', '    }\n', '\n', '    /**\n', '     * @dev function to calculate the interest using a compounded interest rate formula\n', '     * @param _rate the interest rate, in ray\n', '     * @param _lastUpdateTimestamp the timestamp of the last update of the interest\n', '     * @return the interest rate compounded during the timeDelta, in ray\n', '     **/\n', '    function calculateCompoundedInterest(\n', '        uint256 _rate,\n', '        uint40 _lastUpdateTimestamp\n', '    ) internal view returns (uint256) {\n', '        //solium-disable-next-line\n', '        uint256 timeDifference = block.timestamp.sub(\n', '            uint256(_lastUpdateTimestamp)\n', '        );\n', '\n', '        uint256 ratePerSecond = _rate.div(SECONDS_PER_YEAR);\n', '\n', '        return ratePerSecond.add(WadRayMath.ray()).rayPow(timeDifference);\n', '    }\n', '\n', '    /**\n', '     * @dev returns the total borrows on the reserve\n', '     * @param _reserve the reserve object\n', '     * @return the total borrows (stable + variable)\n', '     **/\n', '    function getTotalBorrows(CoreLibrary.ReserveData storage _reserve)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _reserve.totalBorrowsStable.add(_reserve.totalBorrowsVariable);\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/ILendingRateOracle.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', '* ILendingRateOracle interface\n', '* -\n', '* Interface for the Populous borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\n', '* -\n', '* This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', '**/\n', '\n', 'interface ILendingRateOracle {\n', '    /**\n', '    @dev returns the market borrow rate in ray\n', '    **/\n', '    function getMarketBorrowRate(address _asset) external view returns (uint256);\n', '\n', '    /**\n', '    @dev sets the market borrow rate. Rate value must be in ray\n', '    **/\n', '    function setMarketBorrowRate(address _asset, uint256 _rate) external;\n', '}\n', '\n', '// File: contracts/libraries/EthAddressLib.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'library EthAddressLib {\n', '\n', '    /**\n', '    * @dev returns the address used within the protocol to identify ETH\n', '    * @return the address assigned to ETH\n', '     */\n', '    function ethAddress() internal pure returns(address) {\n', '        return 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IPToken.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '//note create a proper PToken interface\n', '\n', 'interface IPToken {\n', '    event Redeem(\n', '        address indexed _from,\n', '        uint256 _value,\n', '        uint256 _fromBalanceIncrease,\n', '        uint256 _fromIndex\n', '    );\n', '    event MintOnDeposit(\n', '        address indexed _from,\n', '        uint256 _value,\n', '        uint256 _fromBalanceIncrease,\n', '        uint256 _fromIndex\n', '    );\n', '    event BurnOnLiquidation(\n', '        address indexed _from,\n', '        uint256 _value,\n', '        uint256 _fromBalanceIncrease,\n', '        uint256 _fromIndex\n', '    );\n', '    event BalanceTransfer(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _value,\n', '        uint256 _fromBalanceIncrease,\n', '        uint256 _toBalanceIncrease,\n', '        uint256 _fromIndex,\n', '        uint256 _toIndex\n', '    );\n', '    event InterestStreamRedirected(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint256 _redirectedBalance,\n', '        uint256 _fromBalanceIncrease,\n', '        uint256 _fromIndex\n', '    );\n', '    event RedirectedBalanceUpdated(\n', '        address indexed _targetAddress,\n', '        uint256 _targetBalanceIncrease,\n', '        uint256 _targetIndex,\n', '        uint256 _redirectedBalanceAdded,\n', '        uint256 _redirectedBalanceRemoved\n', '    );\n', '    event InterestRedirectionAllowanceChanged(\n', '        address indexed _from,\n', '        address indexed _to\n', '    );\n', '\n', '    function balanceOf(address _user) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/lendingpool/LendingPoolCore.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '//import "../tokenization/PToken.sol";\n', '\n', '\n', '\n', '/**\n', ' *LendingPoolCore contract\n', ' * -\n', ' * Holds the state of the lending pool and all the funds deposited\n', '* NOTE: The core does not enforce security checks on the update of the state\n', '* (eg, updateStateOnBorrow() does not enforce that borrowed is enabled on the reserve).\n', '* The check that an action can be performed is a duty of the overlying LendingPool contract.\n', ' * -\n', ' * This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', ' **/\n', '\n', 'contract LendingPoolCore is VersionedInitializable {\n', '    using SafeMath for uint256;\n', '    using WadRayMath for uint256;\n', '    using CoreLibrary for CoreLibrary.ReserveData;\n', '    using CoreLibrary for CoreLibrary.UserReserveData;\n', '    using SafeERC20 for ERC20;\n', '    using Address for address payable;\n', '\n', '    /**\n', '    * @dev Emitted when the state of a reserve is updated\n', '    * @param reserve the address of the reserve\n', '    * @param liquidityRate the new liquidity rate\n', '    * @param stableBorrowRate the new stable borrow rate\n', '    * @param variableBorrowRate the new variable borrow rate\n', '    * @param liquidityIndex the new liquidity index\n', '    * @param variableBorrowIndex the new variable borrow index\n', '    **/\n', '    event ReserveUpdated(\n', '        address indexed reserve,\n', '        uint256 liquidityRate,\n', '        uint256 stableBorrowRate,\n', '        uint256 variableBorrowRate,\n', '        uint256 liquidityIndex,\n', '        uint256 variableBorrowIndex\n', '    );\n', '\n', '    address public lendingPoolAddress;\n', '\n', '    LendingPoolAddressesProvider public addressesProvider;\n', '\n', '    /**\n', '    * @dev only lending pools can use functions affected by this modifier\n', '    **/\n', '    modifier onlyLendingPool {\n', '        require(lendingPoolAddress == msg.sender, "The caller must be a lending pool contract");\n', '        _;\n', '    }\n', '\n', '    /**\n', '    * @dev only lending pools configurator can use functions affected by this modifier\n', '    **/\n', '    modifier onlyLendingPoolConfigurator {\n', '        require(\n', '            addressesProvider.getLendingPoolConfigurator() == msg.sender,\n', '            "The caller must be a lending pool configurator contract"\n', '        );\n', '        _;\n', '    }\n', '\n', '    mapping(address => CoreLibrary.ReserveData) internal reserves;\n', '    mapping(address => mapping(address => CoreLibrary.UserReserveData)) internal usersReserveData;\n', '\n', '    address[] public reservesList;\n', '\n', '    uint256 public constant CORE_REVISION = 0x4;\n', '\n', '    /**\n', '    * @dev returns the revision number of the contract\n', '    **/\n', '    function getRevision() internal pure returns (uint256) {\n', '        return CORE_REVISION;\n', '    }\n', '\n', '    /**\n', '    * @dev initializes the Core contract, invoked upon registration on the AddressesProvider\n', '    * @param _addressesProvider the addressesProvider contract\n', '    **/\n', '\n', '    function initialize(LendingPoolAddressesProvider _addressesProvider) public initializer {\n', '        addressesProvider = _addressesProvider;\n', '        refreshConfigInternal();\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the core as a result of a deposit action\n', '    * @param _reserve the address of the reserve in which the deposit is happening\n', '    * @param _user the address of the the user depositing\n', '    * @param _amount the amount being deposited\n', '    * @param _isFirstDeposit true if the user is depositing for the first time\n', '    **/\n', '\n', '    function updateStateOnDeposit(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _amount,\n', '        bool _isFirstDeposit\n', '    ) external onlyLendingPool {\n', '        reserves[_reserve].updateCumulativeIndexes();\n', '        updateReserveInterestRatesAndTimestampInternal(_reserve, _amount, 0);\n', '\n', '        if (_isFirstDeposit) {\n', '            //if this is the first deposit of the user, we configure the deposit as enabled to be used as collateral\n', '            setUserUseReserveAsCollateral(_reserve, _user, true);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the core as a result of a redeem action\n', '    * @param _reserve the address of the reserve in which the redeem is happening\n', '    * @param _user the address of the user redeeming\n', '    * @param _amountRedeemed the amount being redeemed\n', '    * @param _userRedeemedEverything true if the user is redeeming everything\n', '    **/\n', '    function updateStateOnRedeem(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _amountRedeemed,\n', '        bool _userRedeemedEverything\n', '    ) external onlyLendingPool {\n', '        //compound liquidity and variable borrow interests\n', '        reserves[_reserve].updateCumulativeIndexes();\n', '        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountRedeemed);\n', '\n', '        //if user redeemed everything the useReserveAsCollateral flag is reset\n', '        if (_userRedeemedEverything) {\n', '            setUserUseReserveAsCollateral(_reserve, _user, false);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the core as a result of a flashloan action\n', '    * @param _reserve the address of the reserve in which the flashloan is happening\n', '    * @param _income the income of the protocol as a result of the action\n', '    **/\n', '    function updateStateOnFlashLoan(\n', '        address _reserve,\n', '        uint256 _availableLiquidityBefore,\n', '        uint256 _income,\n', '        uint256 _protocolFee\n', '    ) external onlyLendingPool {\n', '        transferFlashLoanProtocolFeeInternal(_reserve, _protocolFee);\n', '\n', '        //compounding the cumulated interest\n', '        reserves[_reserve].updateCumulativeIndexes();\n', '\n', '        uint256 totalLiquidityBefore = _availableLiquidityBefore.add(\n', '            getReserveTotalBorrows(_reserve)\n', '        );\n', '\n', '        //compounding the received fee into the reserve\n', '        reserves[_reserve].cumulateToLiquidityIndex(totalLiquidityBefore, _income);\n', '\n', '        //refresh interest rates\n', '        updateReserveInterestRatesAndTimestampInternal(_reserve, _income, 0);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the core as a consequence of a borrow action.\n', '    * @param _reserve the address of the reserve on which the user is borrowing\n', '    * @param _user the address of the borrower\n', '    * @param _amountBorrowed the new amount borrowed\n', '    * @param _borrowFee the fee on the amount borrowed\n', '    * @param _rateMode the borrow rate mode (stable, variable)\n', '    * @return the new borrow rate for the user\n', '    **/\n', '    function updateStateOnBorrow(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _amountBorrowed,\n', '        uint256 _borrowFee,\n', '        CoreLibrary.InterestRateMode _rateMode\n', '    ) external onlyLendingPool returns (uint256, uint256) {\n', '        // getting the previous borrow data of the user\n', '        (uint256 principalBorrowBalance, , uint256 balanceIncrease) = getUserBorrowBalances(\n', '            _reserve,\n', '            _user\n', '        );\n', '\n', '        updateReserveStateOnBorrowInternal(\n', '            _reserve,\n', '            _user,\n', '            principalBorrowBalance,\n', '            balanceIncrease,\n', '            _amountBorrowed,\n', '            _rateMode\n', '        );\n', '\n', '        updateUserStateOnBorrowInternal(\n', '            _reserve,\n', '            _user,\n', '            _amountBorrowed,\n', '            balanceIncrease,\n', '            _borrowFee,\n', '            _rateMode\n', '        );\n', '\n', '        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, _amountBorrowed);\n', '\n', '        return (getUserCurrentBorrowRate(_reserve, _user), balanceIncrease);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the core as a consequence of a repay action.\n', '    * @param _reserve the address of the reserve on which the user is repaying\n', '    * @param _user the address of the borrower\n', '    * @param _paybackAmountMinusFees the amount being paid back minus fees\n', '    * @param _originationFeeRepaid the fee on the amount that is being repaid\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    * @param _repaidWholeLoan true if the user is repaying the whole loan\n', '    **/\n', '\n', '    function updateStateOnRepay(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _paybackAmountMinusFees,\n', '        uint256 _originationFeeRepaid,\n', '        uint256 _balanceIncrease,\n', '        bool _repaidWholeLoan\n', '    ) external onlyLendingPool {\n', '        updateReserveStateOnRepayInternal(\n', '            _reserve,\n', '            _user,\n', '            _paybackAmountMinusFees,\n', '            _balanceIncrease\n', '        );\n', '        updateUserStateOnRepayInternal(\n', '            _reserve,\n', '            _user,\n', '            _paybackAmountMinusFees,\n', '            _originationFeeRepaid,\n', '            _balanceIncrease,\n', '            _repaidWholeLoan\n', '        );\n', '\n', '        updateReserveInterestRatesAndTimestampInternal(_reserve, _paybackAmountMinusFees, 0);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the core as a consequence of a swap rate action.\n', '    * @param _reserve the address of the reserve on which the user is repaying\n', '    * @param _user the address of the borrower\n', '    * @param _principalBorrowBalance the amount borrowed by the user\n', '    * @param _compoundedBorrowBalance the amount borrowed plus accrued interest\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    * @param _currentRateMode the current interest rate mode for the user\n', '    **/\n', '    function updateStateOnSwapRate(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _principalBorrowBalance,\n', '        uint256 _compoundedBorrowBalance,\n', '        uint256 _balanceIncrease,\n', '        CoreLibrary.InterestRateMode _currentRateMode\n', '    ) external onlyLendingPool returns (CoreLibrary.InterestRateMode, uint256) {\n', '        updateReserveStateOnSwapRateInternal(\n', '            _reserve,\n', '            _user,\n', '            _principalBorrowBalance,\n', '            _compoundedBorrowBalance,\n', '            _currentRateMode\n', '        );\n', '\n', '        CoreLibrary.InterestRateMode newRateMode = updateUserStateOnSwapRateInternal(\n', '            _reserve,\n', '            _user,\n', '            _balanceIncrease,\n', '            _currentRateMode\n', '        );\n', '\n', '        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n', '\n', '        return (newRateMode, getUserCurrentBorrowRate(_reserve, _user));\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the core as a consequence of a liquidation action.\n', '    * @param _principalReserve the address of the principal reserve that is being repaid\n', '    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n', '    * @param _user the address of the borrower\n', '    * @param _amountToLiquidate the amount being repaid by the liquidator\n', '    * @param _collateralToLiquidate the amount of collateral being liquidated\n', '    * @param _feeLiquidated the amount of origination fee being liquidated\n', '    * @param _liquidatedCollateralForFee the amount of collateral equivalent to the origination fee + bonus\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    * @param _liquidatorReceivesPToken true if the liquidator will receive PTokens, false otherwise\n', '    **/\n', '    function updateStateOnLiquidation(\n', '        address _principalReserve,\n', '        address _collateralReserve,\n', '        address _user,\n', '        uint256 _amountToLiquidate,\n', '        uint256 _collateralToLiquidate,\n', '        uint256 _feeLiquidated,\n', '        uint256 _liquidatedCollateralForFee,\n', '        uint256 _balanceIncrease,\n', '        bool _liquidatorReceivesPToken\n', '    ) external onlyLendingPool {\n', '        updatePrincipalReserveStateOnLiquidationInternal(\n', '            _principalReserve,\n', '            _user,\n', '            _amountToLiquidate,\n', '            _balanceIncrease\n', '        );\n', '\n', '        updateCollateralReserveStateOnLiquidationInternal(\n', '            _collateralReserve\n', '        );\n', '\n', '        updateUserStateOnLiquidationInternal(\n', '            _principalReserve,\n', '            _user,\n', '            _amountToLiquidate,\n', '            _feeLiquidated,\n', '            _balanceIncrease\n', '        );\n', '\n', '        updateReserveInterestRatesAndTimestampInternal(_principalReserve, _amountToLiquidate, 0);\n', '\n', '        if (!_liquidatorReceivesPToken) {\n', '            updateReserveInterestRatesAndTimestampInternal(\n', '                _collateralReserve,\n', '                0,\n', '                _collateralToLiquidate.add(_liquidatedCollateralForFee)\n', '            );\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the core as a consequence of a stable rate rebalance\n', '    * @param _reserve the address of the principal reserve where the user borrowed\n', '    * @param _user the address of the borrower\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    * @return the new stable rate for the user\n', '    **/\n', '    function updateStateOnRebalance(address _reserve, address _user, uint256 _balanceIncrease)\n', '        external\n', '        onlyLendingPool\n', '        returns (uint256)\n', '    {\n', '        updateReserveStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n', '\n', '        //update user data and rebalance the rate\n', '        updateUserStateOnRebalanceInternal(_reserve, _user, _balanceIncrease);\n', '        updateReserveInterestRatesAndTimestampInternal(_reserve, 0, 0);\n', '        return usersReserveData[_user][_reserve].stableBorrowRate;\n', '    }\n', '\n', '    /**\n', '    * @dev enables or disables a reserve as collateral\n', '    * @param _reserve the address of the principal reserve where the user deposited\n', '    * @param _user the address of the depositor\n', '    * @param _useAsCollateral true if the depositor wants to use the reserve as collateral\n', '    **/\n', '    function setUserUseReserveAsCollateral(address _reserve, address _user, bool _useAsCollateral)\n', '        public\n', '        onlyLendingPool\n', '    {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        user.useAsCollateral = _useAsCollateral;\n', '    }\n', '\n', '    /**\n', '    * @notice ETH/token transfer functions\n', '    **/\n', '\n', '    /**\n', '    * @dev fallback function enforces that the caller is a contract, to support flashloan transfers\n', '    **/\n', '    function() external payable {\n', '        //only contracts can send ETH to the core\n', '        require(msg.sender.isContract(), "Only contracts can send ether to the Lending pool core");\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev transfers to the user a specific amount from the reserve.\n', '    * @param _reserve the address of the reserve where the transfer is happening\n', '    * @param _user the address of the user receiving the transfer\n', '    * @param _amount the amount being transferred\n', '    **/\n', '    function transferToUser(address _reserve, address payable _user, uint256 _amount)\n', '        external\n', '        onlyLendingPool\n', '    {\n', '        if (_reserve != EthAddressLib.ethAddress()) {\n', '            ERC20(_reserve).safeTransfer(_user, _amount);\n', '        } else {\n', '            //solium-disable-next-line\n', '            (bool result, ) = _user.call.value(_amount).gas(50000)("");\n', '            require(result, "Transfer of ETH failed");\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev transfers the protocol fees to the fees collection address\n', '    * @param _token the address of the token being transferred\n', '    * @param _user the address of the user from where the transfer is happening\n', '    * @param _amount the amount being transferred\n', '    * @param _destination the fee receiver address\n', '    **/\n', '\n', '    function transferToFeeCollectionAddress(\n', '        address _token,\n', '        address _user,\n', '        uint256 _amount,\n', '        address _destination\n', '    ) external payable onlyLendingPool {\n', '        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n', '\n', '        if (_token != EthAddressLib.ethAddress()) {\n', '            require(\n', '                msg.value == 0,\n', '                "User is sending ETH along with the ERC20 transfer. Check the value attribute of the transaction"\n', '            );\n', '            ERC20(_token).safeTransferFrom(_user, feeAddress, _amount);\n', '        } else {\n', '            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");\n', '            //solium-disable-next-line\n', '            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n', '            require(result, "Transfer of ETH failed");\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev transfers the fees to the fees collection address in the case of liquidation\n', '    * @param _token the address of the token being transferred\n', '    * @param _amount the amount being transferred\n', '    * @param _destination the fee receiver address\n', '    **/\n', '    function liquidateFee(\n', '        address _token,\n', '        uint256 _amount,\n', '        address _destination\n', '    ) external payable onlyLendingPool {\n', '        address payable feeAddress = address(uint160(_destination)); //cast the address to payable\n', '        require(\n', '            msg.value == 0,\n', '            "Fee liquidation does not require any transfer of value"\n', '        );\n', '\n', '        if (_token != EthAddressLib.ethAddress()) {\n', '            ERC20(_token).safeTransfer(feeAddress, _amount);\n', '        } else {\n', '            //solium-disable-next-line\n', '            (bool result, ) = feeAddress.call.value(_amount).gas(50000)("");\n', '            require(result, "Transfer of ETH failed");\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev transfers an amount from a user to the destination reserve\n', '    * @param _reserve the address of the reserve where the amount is being transferred\n', '    * @param _user the address of the user from where the transfer is happening\n', '    * @param _amount the amount being transferred\n', '    **/\n', '    function transferToReserve(address _reserve, address payable _user, uint256 _amount)\n', '        external\n', '        payable\n', '        onlyLendingPool\n', '    {\n', '        if (_reserve != EthAddressLib.ethAddress()) {\n', '            require(msg.value == 0, "User is sending ETH along with the ERC20 transfer.");\n', '            ERC20(_reserve).safeTransferFrom(_user, address(this), _amount);\n', '\n', '        } else {\n', '            require(msg.value >= _amount, "The amount and the value sent to deposit do not match");\n', '\n', '            if (msg.value > _amount) {\n', '                //send back excess ETH\n', '                uint256 excessAmount = msg.value.sub(_amount);\n', '                //solium-disable-next-line\n', '                (bool result, ) = _user.call.value(excessAmount).gas(50000)("");\n', '                require(result, "Transfer of ETH failed");\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice data access functions\n', '    **/\n', '\n', '    /**\n', '    * @dev returns the basic data (balances, fee accrued, reserve enabled/disabled as collateral)\n', '    * needed to calculate the global account data in the LendingPoolDataProvider\n', '    * @param _reserve the address of the reserve\n', '    * @param _user the address of the user\n', '    * @return the user deposited balance, the principal borrow balance, the fee, and if the reserve is enabled as collateral or not\n', '    **/\n', '    function getUserBasicReserveData(address _reserve, address _user)\n', '        external\n', '        view\n', '        returns (uint256, uint256, uint256, bool)\n', '    {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '\n', '        uint256 underlyingBalance = getUserUnderlyingAssetBalance(_reserve, _user);\n', '\n', '        if (user.principalBorrowBalance == 0) {\n', '            return (underlyingBalance, 0, 0, user.useAsCollateral);\n', '        }\n', '\n', '        return (\n', '            underlyingBalance,\n', '            user.getCompoundedBorrowBalance(reserve),\n', '            user.originationFee,\n', '            user.useAsCollateral\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev checks if a user is allowed to borrow at a stable rate\n', '    * @param _reserve the reserve address\n', '    * @param _user the user\n', '    * @param _amount the amount the the user wants to borrow\n', '    * @return true if the user is allowed to borrow at a stable rate, false otherwise\n', '    **/\n', '\n', '    function isUserAllowedToBorrowAtStable(address _reserve, address _user, uint256 _amount)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '\n', '        if (!reserve.isStableBorrowRateEnabled) return false;\n', '\n', '        return\n', '            !user.useAsCollateral ||\n', '            !reserve.usageAsCollateralEnabled ||\n', '            _amount > getUserUnderlyingAssetBalance(_reserve, _user);\n', '    }\n', '\n', '    /**\n', '    * @dev gets the underlying asset balance of a user based on the corresponding PToken balance.\n', '    * @param _reserve the reserve address\n', '    * @param _user the user address\n', '    * @return the underlying deposit balance of the user\n', '    **/\n', '\n', '    function getUserUnderlyingAssetBalance(address _reserve, address _user)\n', '        public\n', '        view\n', '        returns (uint256)\n', '    {\n', '        IPToken PToken = IPToken(reserves[_reserve].PTokenAddress);\n', '        return PToken.balanceOf(_user);\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev gets the interest rate strategy contract address for the reserve\n', '    * @param _reserve the reserve address\n', '    * @return the address of the interest rate strategy contract\n', '    **/\n', '    function getReserveInterestRateStrategyAddress(address _reserve) public view returns (address) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.interestRateStrategyAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the PToken contract address for the reserve\n', '    * @param _reserve the reserve address\n', '    * @return the address of the PToken contract\n', '    **/\n', '\n', '    function getReservePTokenAddress(address _reserve) public view returns (address) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.PTokenAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the available liquidity in the reserve. The available liquidity is the balance of the core contract\n', '    * @param _reserve the reserve address\n', '    * @return the available liquidity\n', '    **/\n', '    function getReserveAvailableLiquidity(address _reserve) public view returns (uint256) {\n', '        uint256 balance = 0;\n', '\n', '        if (_reserve == EthAddressLib.ethAddress()) {\n', '            balance = address(this).balance;\n', '        } else {\n', '            balance = IERC20(_reserve).balanceOf(address(this));\n', '        }\n', '        return balance;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the total liquidity in the reserve. The total liquidity is the balance of the core contract + total borrows\n', '    * @param _reserve the reserve address\n', '    * @return the total liquidity\n', '    **/\n', '    function getReserveTotalLiquidity(address _reserve) public view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return getReserveAvailableLiquidity(_reserve).add(reserve.getTotalBorrows());\n', '    }\n', '\n', '    /**\n', '    * @dev gets the normalized income of the reserve. a value of 1e27 means there is no income. A value of 2e27 means there\n', '    * there has been 100% income.\n', '    * @param _reserve the reserve address\n', '    * @return the reserve normalized income\n', '    **/\n', '    function getReserveNormalizedIncome(address _reserve) external view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.getNormalizedIncome();\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve total borrows\n', '    * @param _reserve the reserve address\n', '    * @return the total borrows (stable + variable)\n', '    **/\n', '    function getReserveTotalBorrows(address _reserve) public view returns (uint256) {\n', '        return reserves[_reserve].getTotalBorrows();\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve total borrows stable\n', '    * @param _reserve the reserve address\n', '    * @return the total borrows stable\n', '    **/\n', '    function getReserveTotalBorrowsStable(address _reserve) external view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.totalBorrowsStable;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve total borrows variable\n', '    * @param _reserve the reserve address\n', '    * @return the total borrows variable\n', '    **/\n', '\n', '    function getReserveTotalBorrowsVariable(address _reserve) external view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.totalBorrowsVariable;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve liquidation threshold\n', '    * @param _reserve the reserve address\n', '    * @return the reserve liquidation threshold\n', '    **/\n', '\n', '    function getReserveLiquidationThreshold(address _reserve) external view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.liquidationThreshold;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve liquidation bonus\n', '    * @param _reserve the reserve address\n', '    * @return the reserve liquidation bonus\n', '    **/\n', '\n', '    function getReserveLiquidationBonus(address _reserve) external view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.liquidationBonus;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve current variable borrow rate. Is the base variable borrow rate if the reserve is empty\n', '    * @param _reserve the reserve address\n', '    * @return the reserve current variable borrow rate\n', '    **/\n', '\n', '    function getReserveCurrentVariableBorrowRate(address _reserve) external view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '\n', '        if (reserve.currentVariableBorrowRate == 0) {\n', '            return\n', '                IReserveInterestRateStrategy(reserve.interestRateStrategyAddress)\n', '                .getBaseVariableBorrowRate();\n', '        }\n', '        return reserve.currentVariableBorrowRate;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve current stable borrow rate. Is the market rate if the reserve is empty\n', '    * @param _reserve the reserve address\n', '    * @return the reserve current stable borrow rate\n', '    **/\n', '\n', '    function getReserveCurrentStableBorrowRate(address _reserve) public view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        ILendingRateOracle oracle = ILendingRateOracle(addressesProvider.getLendingRateOracle());\n', '\n', '        if (reserve.currentStableBorrowRate == 0) {\n', '            //no stable rate borrows yet\n', '            return oracle.getMarketBorrowRate(_reserve);\n', '        }\n', '\n', '        return reserve.currentStableBorrowRate;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve average stable borrow rate. The average stable rate is the weighted average\n', '    * of all the loans taken at stable rate.\n', '    * @param _reserve the reserve address\n', '    * @return the reserve current average borrow rate\n', '    **/\n', '    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.currentAverageStableBorrowRate;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve liquidity rate\n', '    * @param _reserve the reserve address\n', '    * @return the reserve liquidity rate\n', '    **/\n', '    function getReserveCurrentLiquidityRate(address _reserve) external view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.currentLiquidityRate;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve liquidity cumulative index\n', '    * @param _reserve the reserve address\n', '    * @return the reserve liquidity cumulative index\n', '    **/\n', '    function getReserveLiquidityCumulativeIndex(address _reserve) external view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.lastLiquidityCumulativeIndex;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the reserve variable borrow index\n', '    * @param _reserve the reserve address\n', '    * @return the reserve variable borrow index\n', '    **/\n', '    function getReserveVariableBorrowsCumulativeIndex(address _reserve)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.lastVariableBorrowCumulativeIndex;\n', '    }\n', '\n', '    /**\n', '    * @dev this function aggregates the configuration parameters of the reserve.\n', "    * It's used in the LendingPoolDataProvider specifically to save gas, and avoid\n", '    * multiple external contract calls to fetch the same data.\n', '    * @param _reserve the reserve address\n', '    * @return the reserve decimals\n', '    * @return the base ltv as collateral\n', '    * @return the liquidation threshold\n', '    * @return if the reserve is used as collateral or not\n', '    **/\n', '    function getReserveConfiguration(address _reserve)\n', '        external\n', '        view\n', '        returns (uint256, uint256, uint256, bool)\n', '    {\n', '        uint256 decimals;\n', '        uint256 baseLTVasCollateral;\n', '        uint256 liquidationThreshold;\n', '        bool usageAsCollateralEnabled;\n', '\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        decimals = reserve.decimals;\n', '        baseLTVasCollateral = reserve.baseLTVasCollateral;\n', '        liquidationThreshold = reserve.liquidationThreshold;\n', '        usageAsCollateralEnabled = reserve.usageAsCollateralEnabled;\n', '\n', '        return (decimals, baseLTVasCollateral, liquidationThreshold, usageAsCollateralEnabled);\n', '    }\n', '\n', '    /**\n', '    * @dev returns the decimals of the reserve\n', '    * @param _reserve the reserve address\n', '    * @return the reserve decimals\n', '    **/\n', '    function getReserveDecimals(address _reserve) external view returns (uint256) {\n', '        return reserves[_reserve].decimals;\n', '    }\n', '\n', '    /**\n', '    * @dev returns true if the reserve is enabled for borrowing\n', '    * @param _reserve the reserve address\n', '    * @return true if the reserve is enabled for borrowing, false otherwise\n', '    **/\n', '\n', '    function isReserveBorrowingEnabled(address _reserve) external view returns (bool) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.borrowingEnabled;\n', '    }\n', '\n', '    /**\n', '    * @dev returns true if the reserve is enabled as collateral\n', '    * @param _reserve the reserve address\n', '    * @return true if the reserve is enabled as collateral, false otherwise\n', '    **/\n', '\n', '    function isReserveUsageAsCollateralEnabled(address _reserve) external view returns (bool) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.usageAsCollateralEnabled;\n', '    }\n', '\n', '    /**\n', '    * @dev returns true if the stable rate is enabled on reserve\n', '    * @param _reserve the reserve address\n', '    * @return true if the stable rate is enabled on reserve, false otherwise\n', '    **/\n', '    function getReserveIsStableBorrowRateEnabled(address _reserve) external view returns (bool) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.isStableBorrowRateEnabled;\n', '    }\n', '\n', '    /**\n', '    * @dev returns true if the reserve is active\n', '    * @param _reserve the reserve address\n', '    * @return true if the reserve is active, false otherwise\n', '    **/\n', '    function getReserveIsActive(address _reserve) external view returns (bool) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.isActive;\n', '    }\n', '\n', '    /**\n', '    * @notice returns if a reserve is freezed\n', '    * @param _reserve the reserve for which the information is needed\n', '    * @return true if the reserve is freezed, false otherwise\n', '    **/\n', '\n', '    function getReserveIsFreezed(address _reserve) external view returns (bool) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        return reserve.isFreezed;\n', '    }\n', '\n', '    /**\n', '    * @notice returns the timestamp of the last action on the reserve\n', '    * @param _reserve the reserve for which the information is needed\n', '    * @return the last updated timestamp of the reserve\n', '    **/\n', '\n', '    function getReserveLastUpdate(address _reserve) external view returns (uint40 timestamp) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        timestamp = reserve.lastUpdateTimestamp;\n', '    }\n', '\n', '    /**\n', '    * @dev returns the utilization rate U of a specific reserve\n', '    * @param _reserve the reserve for which the information is needed\n', '    * @return the utilization rate in ray\n', '    **/\n', '\n', '    function getReserveUtilizationRate(address _reserve) public view returns (uint256) {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '\n', '        uint256 totalBorrows = reserve.getTotalBorrows();\n', '\n', '        if (totalBorrows == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 availableLiquidity = getReserveAvailableLiquidity(_reserve);\n', '\n', '        return totalBorrows.rayDiv(availableLiquidity.add(totalBorrows));\n', '    }\n', '\n', '    /**\n', '    * @return the array of reserves configured on the core\n', '    **/\n', '    function getReserves() external view returns (address[] memory) {\n', '        return reservesList;\n', '    }\n', '\n', '    /**\n', '    * @param _reserve the address of the reserve for which the information is needed\n', '    * @param _user the address of the user for which the information is needed\n', '    * @return true if the user has chosen to use the reserve as collateral, false otherwise\n', '    **/\n', '    function isUserUseReserveAsCollateralEnabled(address _reserve, address _user)\n', '        external\n', '        view\n', '        returns (bool)\n', '    {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        return user.useAsCollateral;\n', '    }\n', '\n', '    /**\n', '    * @param _reserve the address of the reserve for which the information is needed\n', '    * @param _user the address of the user for which the information is needed\n', '    * @return the origination fee for the user\n', '    **/\n', '    function getUserOriginationFee(address _reserve, address _user)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        return user.originationFee;\n', '    }\n', '\n', '    /**\n', '    * @dev users with no loans in progress have NONE as borrow rate mode\n', '    * @param _reserve the address of the reserve for which the information is needed\n', '    * @param _user the address of the user for which the information is needed\n', '    * @return the borrow rate mode for the user,\n', '    **/\n', '\n', '    function getUserCurrentBorrowRateMode(address _reserve, address _user)\n', '        public\n', '        view\n', '        returns (CoreLibrary.InterestRateMode)\n', '    {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '\n', '        if (user.principalBorrowBalance == 0) {\n', '            return CoreLibrary.InterestRateMode.NONE;\n', '        }\n', '\n', '        return\n', '            user.stableBorrowRate > 0\n', '            ? CoreLibrary.InterestRateMode.STABLE\n', '            : CoreLibrary.InterestRateMode.VARIABLE;\n', '    }\n', '\n', '    /**\n', '    * @dev gets the current borrow rate of the user\n', '    * @param _reserve the address of the reserve for which the information is needed\n', '    * @param _user the address of the user for which the information is needed\n', '    * @return the borrow rate for the user,\n', '    **/\n', '    function getUserCurrentBorrowRate(address _reserve, address _user)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        CoreLibrary.InterestRateMode rateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n', '\n', '        if (rateMode == CoreLibrary.InterestRateMode.NONE) {\n', '            return 0;\n', '        }\n', '\n', '        return\n', '            rateMode == CoreLibrary.InterestRateMode.STABLE\n', '            ? usersReserveData[_user][_reserve].stableBorrowRate\n', '            : reserves[_reserve].currentVariableBorrowRate;\n', '    }\n', '\n', '    /**\n', '    * @dev the stable rate returned is 0 if the user is borrowing at variable or not borrowing at all\n', '    * @param _reserve the address of the reserve for which the information is needed\n', '    * @param _user the address of the user for which the information is needed\n', '    * @return the user stable rate\n', '    **/\n', '    function getUserCurrentStableBorrowRate(address _reserve, address _user)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        return user.stableBorrowRate;\n', '    }\n', '\n', '    /**\n', '    * @dev calculates and returns the borrow balances of the user\n', '    * @param _reserve the address of the reserve\n', '    * @param _user the address of the user\n', '    * @return the principal borrow balance, the compounded balance and the balance increase since the last borrow/repay/swap/rebalance\n', '    **/\n', '\n', '    function getUserBorrowBalances(address _reserve, address _user)\n', '        public\n', '        view\n', '        returns (uint256, uint256, uint256)\n', '    {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        if (user.principalBorrowBalance == 0) {\n', '            return (0, 0, 0);\n', '        }\n', '\n', '        uint256 principal = user.principalBorrowBalance;\n', '        uint256 compoundedBalance = CoreLibrary.getCompoundedBorrowBalance(\n', '            user,\n', '            reserves[_reserve]\n', '        );\n', '        return (principal, compoundedBalance, compoundedBalance.sub(principal));\n', '    }\n', '\n', '    /**\n', '    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n', '    * @param _reserve the address of the reserve for which the information is needed\n', '    * @param _user the address of the user for which the information is needed\n', '    * @return the variable borrow index for the user\n', '    **/\n', '\n', '    function getUserVariableBorrowCumulativeIndex(address _reserve, address _user)\n', '        external\n', '        view\n', '        returns (uint256)\n', '    {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        return user.lastVariableBorrowCumulativeIndex;\n', '    }\n', '\n', '    /**\n', '    * @dev the variable borrow index of the user is 0 if the user is not borrowing or borrowing at stable\n', '    * @param _reserve the address of the reserve for which the information is needed\n', '    * @param _user the address of the user for which the information is needed\n', '    * @return the variable borrow index for the user\n', '    **/\n', '\n', '    function getUserLastUpdate(address _reserve, address _user)\n', '        external\n', '        view\n', '        returns (uint256 timestamp)\n', '    {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        timestamp = user.lastUpdateTimestamp;\n', '    }\n', '\n', '    /**\n', '    * @dev updates the lending pool core configuration\n', '    **/\n', '    function refreshConfiguration() external onlyLendingPoolConfigurator {\n', '        refreshConfigInternal();\n', '    }\n', '\n', '    /**\n', '    * @dev initializes a reserve\n', '    * @param _reserve the address of the reserve\n', '    * @param _PTokenAddress the address of the overlying PToken contract\n', '    * @param _decimals the decimals of the reserve currency\n', '    * @param _interestRateStrategyAddress the address of the interest rate strategy contract\n', '    **/\n', '    function initReserve(\n', '        address _reserve,\n', '        address _PTokenAddress,\n', '        uint256 _decimals,\n', '        address _interestRateStrategyAddress\n', '    ) external onlyLendingPoolConfigurator {\n', '        reserves[_reserve].init(_PTokenAddress, _decimals, _interestRateStrategyAddress);\n', '        addReserveToListInternal(_reserve);\n', '\n', '    }\n', '\n', '\n', '\n', '    /**\n', '    * @dev removes the last added reserve in the reservesList array\n', '    * @param _reserveToRemove the address of the reserve\n', '    **/\n', '    function removeLastAddedReserve(address _reserveToRemove)\n', '     external onlyLendingPoolConfigurator {\n', '\n', '        address lastReserve = reservesList[reservesList.length-1];\n', '\n', '        require(lastReserve == _reserveToRemove, "Reserve being removed is different than the reserve requested");\n', '\n', "        //as we can't check if totalLiquidity is 0 (since the reserve added might not be an ERC20) we at least check that there is nothing borrowed\n", '        require(getReserveTotalBorrows(lastReserve) == 0, "Cannot remove a reserve with liquidity deposited");\n', '\n', '        reserves[lastReserve].isActive = false;\n', '        reserves[lastReserve].PTokenAddress = address(0);\n', '        reserves[lastReserve].decimals = 0;\n', '        reserves[lastReserve].lastLiquidityCumulativeIndex = 0;\n', '        reserves[lastReserve].lastVariableBorrowCumulativeIndex = 0;\n', '        reserves[lastReserve].borrowingEnabled = false;\n', '        reserves[lastReserve].usageAsCollateralEnabled = false;\n', '        reserves[lastReserve].baseLTVasCollateral = 0;\n', '        reserves[lastReserve].liquidationThreshold = 0;\n', '        reserves[lastReserve].liquidationBonus = 0;\n', '        reserves[lastReserve].interestRateStrategyAddress = address(0);\n', '\n', '        reservesList.pop();\n', '    }\n', '\n', '    /**\n', '    * @dev updates the address of the interest rate strategy contract\n', '    * @param _reserve the address of the reserve\n', '    * @param _rateStrategyAddress the address of the interest rate strategy contract\n', '    **/\n', '\n', '    function setReserveInterestRateStrategyAddress(address _reserve, address _rateStrategyAddress)\n', '        external\n', '        onlyLendingPoolConfigurator\n', '    {\n', '        reserves[_reserve].interestRateStrategyAddress = _rateStrategyAddress;\n', '    }\n', '\n', '    /**\n', '    * @dev enables borrowing on a reserve. Also sets the stable rate borrowing\n', '    * @param _reserve the address of the reserve\n', '    * @param _stableBorrowRateEnabled true if the stable rate needs to be enabled, false otherwise\n', '    **/\n', '\n', '    function enableBorrowingOnReserve(address _reserve, bool _stableBorrowRateEnabled)\n', '        external\n', '        onlyLendingPoolConfigurator\n', '    {\n', '        reserves[_reserve].enableBorrowing(_stableBorrowRateEnabled);\n', '    }\n', '\n', '    /**\n', '    * @dev disables borrowing on a reserve\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '\n', '    function disableBorrowingOnReserve(address _reserve) external onlyLendingPoolConfigurator {\n', '        reserves[_reserve].disableBorrowing();\n', '    }\n', '\n', '    /**\n', '    * @dev enables a reserve to be used as collateral\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '    function enableReserveAsCollateral(\n', '        address _reserve,\n', '        uint256 _baseLTVasCollateral,\n', '        uint256 _liquidationThreshold,\n', '        uint256 _liquidationBonus\n', '    ) external onlyLendingPoolConfigurator {\n', '        reserves[_reserve].enableAsCollateral(\n', '            _baseLTVasCollateral,\n', '            _liquidationThreshold,\n', '            _liquidationBonus\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev disables a reserve to be used as collateral\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '    function disableReserveAsCollateral(address _reserve) external onlyLendingPoolConfigurator {\n', '        reserves[_reserve].disableAsCollateral();\n', '    }\n', '\n', '    /**\n', '    * @dev enable the stable borrow rate mode on a reserve\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '    function enableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.isStableBorrowRateEnabled = true;\n', '    }\n', '\n', '    /**\n', '    * @dev disable the stable borrow rate mode on a reserve\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '    function disableReserveStableBorrowRate(address _reserve) external onlyLendingPoolConfigurator {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.isStableBorrowRateEnabled = false;\n', '    }\n', '\n', '    /**\n', '    * @dev activates a reserve\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '    function activateReserve(address _reserve) external onlyLendingPoolConfigurator {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '\n', '        require(\n', '            reserve.lastLiquidityCumulativeIndex > 0 &&\n', '                reserve.lastVariableBorrowCumulativeIndex > 0,\n', '            "Reserve has not been initialized yet"\n', '        );\n', '        reserve.isActive = true;\n', '    }\n', '\n', '    /**\n', '    * @dev deactivates a reserve\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '    function deactivateReserve(address _reserve) external onlyLendingPoolConfigurator {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.isActive = false;\n', '    }\n', '\n', '    /**\n', '    * @notice allows the configurator to freeze the reserve.\n', '    * A freezed reserve does not allow any action apart from repay, redeem, liquidationCall, rebalance.\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '    function freezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.isFreezed = true;\n', '    }\n', '\n', '    /**\n', '    * @notice allows the configurator to unfreeze the reserve. A unfreezed reserve allows any action to be executed.\n', '    * @param _reserve the address of the reserve\n', '    **/\n', '    function unfreezeReserve(address _reserve) external onlyLendingPoolConfigurator {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.isFreezed = false;\n', '    }\n', '\n', '    /**\n', '    * @notice allows the configurator to update the loan to value of a reserve\n', '    * @param _reserve the address of the reserve\n', '    * @param _ltv the new loan to value\n', '    **/\n', '    function setReserveBaseLTVasCollateral(address _reserve, uint256 _ltv)\n', '        external\n', '        onlyLendingPoolConfigurator\n', '    {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.baseLTVasCollateral = _ltv;\n', '    }\n', '\n', '    /**\n', '    * @notice allows the configurator to update the liquidation threshold of a reserve\n', '    * @param _reserve the address of the reserve\n', '    * @param _threshold the new liquidation threshold\n', '    **/\n', '    function setReserveLiquidationThreshold(address _reserve, uint256 _threshold)\n', '        external\n', '        onlyLendingPoolConfigurator\n', '    {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.liquidationThreshold = _threshold;\n', '    }\n', '\n', '    /**\n', '    * @notice allows the configurator to update the liquidation bonus of a reserve\n', '    * @param _reserve the address of the reserve\n', '    * @param _bonus the new liquidation bonus\n', '    **/\n', '    function setReserveLiquidationBonus(address _reserve, uint256 _bonus)\n', '        external\n', '        onlyLendingPoolConfigurator\n', '    {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.liquidationBonus = _bonus;\n', '    }\n', '\n', '    /**\n', '    * @notice allows the configurator to update the reserve decimals\n', '    * @param _reserve the address of the reserve\n', '    * @param _decimals the decimals of the reserve\n', '    **/\n', '    function setReserveDecimals(address _reserve, uint256 _decimals)\n', '        external\n', '        onlyLendingPoolConfigurator\n', '    {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        reserve.decimals = _decimals;\n', '    }\n', '\n', '    /**\n', '    * @notice internal functions\n', '    **/\n', '\n', '    /**\n', '    * @dev updates the state of a reserve as a consequence of a borrow action.\n', '    * @param _reserve the address of the reserve on which the user is borrowing\n', '    * @param _user the address of the borrower\n', '    * @param _principalBorrowBalance the previous borrow balance of the borrower before the action\n', '    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n', '    * @param _amountBorrowed the new amount borrowed\n', '    * @param _rateMode the borrow rate mode (stable, variable)\n', '    **/\n', '\n', '    function updateReserveStateOnBorrowInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _principalBorrowBalance,\n', '        uint256 _balanceIncrease,\n', '        uint256 _amountBorrowed,\n', '        CoreLibrary.InterestRateMode _rateMode\n', '    ) internal {\n', '        reserves[_reserve].updateCumulativeIndexes();\n', '\n', '        //increasing reserve total borrows to account for the new borrow balance of the user\n', '        //NOTE: Depending on the previous borrow mode, the borrows might need to be switched from variable to stable or vice versa\n', '\n', '        updateReserveTotalBorrowsByRateModeInternal(\n', '            _reserve,\n', '            _user,\n', '            _principalBorrowBalance,\n', '            _balanceIncrease,\n', '            _amountBorrowed,\n', '            _rateMode\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of a user as a consequence of a borrow action.\n', '    * @param _reserve the address of the reserve on which the user is borrowing\n', '    * @param _user the address of the borrower\n', '    * @param _amountBorrowed the amount borrowed\n', '    * @param _balanceIncrease the accrued interest of the user on the previous borrowed amount\n', '    * @param _rateMode the borrow rate mode (stable, variable)\n', '    * @return the final borrow rate for the user. Emitted by the borrow() event\n', '    **/\n', '\n', '    function updateUserStateOnBorrowInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _amountBorrowed,\n', '        uint256 _balanceIncrease,\n', '        uint256 _fee,\n', '        CoreLibrary.InterestRateMode _rateMode\n', '    ) internal {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '\n', '        if (_rateMode == CoreLibrary.InterestRateMode.STABLE) {\n', '            //stable\n', '            //reset the user variable index, and update the stable rate\n', '            user.stableBorrowRate = reserve.currentStableBorrowRate;\n', '            user.lastVariableBorrowCumulativeIndex = 0;\n', '        } else if (_rateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n', '            //variable\n', '            //reset the user stable rate, and store the new borrow index\n', '            user.stableBorrowRate = 0;\n', '            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n', '        } else {\n', '            revert("Invalid borrow rate mode");\n', '        }\n', '        //increase the principal borrows and the origination fee\n', '        user.principalBorrowBalance = user.principalBorrowBalance.add(_amountBorrowed).add(\n', '            _balanceIncrease\n', '        );\n', '        user.originationFee = user.originationFee.add(_fee);\n', '\n', '        //solium-disable-next-line\n', '        user.lastUpdateTimestamp = uint40(block.timestamp);\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the reserve as a consequence of a repay action.\n', '    * @param _reserve the address of the reserve on which the user is repaying\n', '    * @param _user the address of the borrower\n', '    * @param _paybackAmountMinusFees the amount being paid back minus fees\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    **/\n', '\n', '    function updateReserveStateOnRepayInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _paybackAmountMinusFees,\n', '        uint256 _balanceIncrease\n', '    ) internal {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_reserve][_user];\n', '\n', '        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(_reserve, _user);\n', '\n', '        //update the indexes\n', '        reserves[_reserve].updateCumulativeIndexes();\n', '\n', '        //compound the cumulated interest to the borrow balance and then subtracting the payback amount\n', '        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n', '            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n', '                _balanceIncrease,\n', '                user.stableBorrowRate\n', '            );\n', '            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n', '                _paybackAmountMinusFees,\n', '                user.stableBorrowRate\n', '            );\n', '        } else {\n', '            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n', '            reserve.decreaseTotalBorrowsVariable(_paybackAmountMinusFees);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the user as a consequence of a repay action.\n', '    * @param _reserve the address of the reserve on which the user is repaying\n', '    * @param _user the address of the borrower\n', '    * @param _paybackAmountMinusFees the amount being paid back minus fees\n', '    * @param _originationFeeRepaid the fee on the amount that is being repaid\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    * @param _repaidWholeLoan true if the user is repaying the whole loan\n', '    **/\n', '    function updateUserStateOnRepayInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _paybackAmountMinusFees,\n', '        uint256 _originationFeeRepaid,\n', '        uint256 _balanceIncrease,\n', '        bool _repaidWholeLoan\n', '    ) internal {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '\n', '        //update the user principal borrow balance, adding the cumulated interest and then subtracting the payback amount\n', '        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n', '            _paybackAmountMinusFees\n', '        );\n', '        user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n', '\n', '        //if the balance decrease is equal to the previous principal (user is repaying the whole loan)\n', '        //and the rate mode is stable, we reset the interest rate mode of the user\n', '        if (_repaidWholeLoan) {\n', '            user.stableBorrowRate = 0;\n', '            user.lastVariableBorrowCumulativeIndex = 0;\n', '        }\n', '        user.originationFee = user.originationFee.sub(_originationFeeRepaid);\n', '\n', '        //solium-disable-next-line\n', '        user.lastUpdateTimestamp = uint40(block.timestamp);\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the user as a consequence of a swap rate action.\n', '    * @param _reserve the address of the reserve on which the user is performing the rate swap\n', '    * @param _user the address of the borrower\n', '    * @param _principalBorrowBalance the the principal amount borrowed by the user\n', '    * @param _compoundedBorrowBalance the principal amount plus the accrued interest\n', '    * @param _currentRateMode the rate mode at which the user borrowed\n', '    **/\n', '    function updateReserveStateOnSwapRateInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _principalBorrowBalance,\n', '        uint256 _compoundedBorrowBalance,\n', '        CoreLibrary.InterestRateMode _currentRateMode\n', '    ) internal {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '\n', '        //compounding reserve indexes\n', '        reserve.updateCumulativeIndexes();\n', '\n', '        if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n', '            uint256 userCurrentStableRate = user.stableBorrowRate;\n', '\n', '            //swap to variable\n', '            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n', '                _principalBorrowBalance,\n', '                userCurrentStableRate\n', '            ); //decreasing stable from old principal balance\n', '            reserve.increaseTotalBorrowsVariable(_compoundedBorrowBalance); //increase variable borrows\n', '        } else if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n', '            //swap to stable\n', '            uint256 currentStableRate = reserve.currentStableBorrowRate;\n', '            reserve.decreaseTotalBorrowsVariable(_principalBorrowBalance);\n', '            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n', '                _compoundedBorrowBalance,\n', '                currentStableRate\n', '            );\n', '\n', '        } else {\n', '            revert("Invalid rate mode received");\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the user as a consequence of a swap rate action.\n', '    * @param _reserve the address of the reserve on which the user is performing the swap\n', '    * @param _user the address of the borrower\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    * @param _currentRateMode the current rate mode of the user\n', '    **/\n', '\n', '    function updateUserStateOnSwapRateInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _balanceIncrease,\n', '        CoreLibrary.InterestRateMode _currentRateMode\n', '    ) internal returns (CoreLibrary.InterestRateMode) {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '\n', '        CoreLibrary.InterestRateMode newMode = CoreLibrary.InterestRateMode.NONE;\n', '\n', '        if (_currentRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n', '            //switch to stable\n', '            newMode = CoreLibrary.InterestRateMode.STABLE;\n', '            user.stableBorrowRate = reserve.currentStableBorrowRate;\n', '            user.lastVariableBorrowCumulativeIndex = 0;\n', '        } else if (_currentRateMode == CoreLibrary.InterestRateMode.STABLE) {\n', '            newMode = CoreLibrary.InterestRateMode.VARIABLE;\n', '            user.stableBorrowRate = 0;\n', '            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n', '        } else {\n', '            revert("Invalid interest rate mode received");\n', '        }\n', '        //compounding cumulated interest\n', '        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n', '        //solium-disable-next-line\n', '        user.lastUpdateTimestamp = uint40(block.timestamp);\n', '\n', '        return newMode;\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the principal reserve as a consequence of a liquidation action.\n', '    * @param _principalReserve the address of the principal reserve that is being repaid\n', '    * @param _user the address of the borrower\n', '    * @param _amountToLiquidate the amount being repaid by the liquidator\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    **/\n', '\n', '    function updatePrincipalReserveStateOnLiquidationInternal(\n', '        address _principalReserve,\n', '        address _user,\n', '        uint256 _amountToLiquidate,\n', '        uint256 _balanceIncrease\n', '    ) internal {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_principalReserve];\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_principalReserve];\n', '\n', '        //update principal reserve data\n', '        reserve.updateCumulativeIndexes();\n', '\n', '        CoreLibrary.InterestRateMode borrowRateMode = getUserCurrentBorrowRateMode(\n', '            _principalReserve,\n', '            _user\n', '        );\n', '\n', '        if (borrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n', '            //increase the total borrows by the compounded interest\n', '            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n', '                _balanceIncrease,\n', '                user.stableBorrowRate\n', '            );\n', '\n', '            //decrease by the actual amount to liquidate\n', '            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n', '                _amountToLiquidate,\n', '                user.stableBorrowRate\n', '            );\n', '\n', '        } else {\n', '            //increase the total borrows by the compounded interest\n', '            reserve.increaseTotalBorrowsVariable(_balanceIncrease);\n', '\n', '            //decrease by the actual amount to liquidate\n', '            reserve.decreaseTotalBorrowsVariable(_amountToLiquidate);\n', '        }\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the collateral reserve as a consequence of a liquidation action.\n', '    * @param _collateralReserve the address of the collateral reserve that is being liquidated\n', '    **/\n', '    function updateCollateralReserveStateOnLiquidationInternal(\n', '        address _collateralReserve\n', '    ) internal {\n', '        //update collateral reserve\n', '        reserves[_collateralReserve].updateCumulativeIndexes();\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the user being liquidated as a consequence of a liquidation action.\n', '    * @param _reserve the address of the principal reserve that is being repaid\n', '    * @param _user the address of the borrower\n', '    * @param _amountToLiquidate the amount being repaid by the liquidator\n', '    * @param _feeLiquidated the amount of origination fee being liquidated\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    **/\n', '    function updateUserStateOnLiquidationInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _amountToLiquidate,\n', '        uint256 _feeLiquidated,\n', '        uint256 _balanceIncrease\n', '    ) internal {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        //first increase by the compounded interest, then decrease by the liquidated amount\n', '        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease).sub(\n', '            _amountToLiquidate\n', '        );\n', '\n', '        if (\n', '            getUserCurrentBorrowRateMode(_reserve, _user) == CoreLibrary.InterestRateMode.VARIABLE\n', '        ) {\n', '            user.lastVariableBorrowCumulativeIndex = reserve.lastVariableBorrowCumulativeIndex;\n', '        }\n', '\n', '        if(_feeLiquidated > 0){\n', '            user.originationFee = user.originationFee.sub(_feeLiquidated);\n', '        }\n', '\n', '        //solium-disable-next-line\n', '        user.lastUpdateTimestamp = uint40(block.timestamp);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the reserve as a consequence of a stable rate rebalance\n', '    * @param _reserve the address of the principal reserve where the user borrowed\n', '    * @param _user the address of the borrower\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    **/\n', '\n', '    function updateReserveStateOnRebalanceInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _balanceIncrease\n', '    ) internal {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '\n', '        reserve.updateCumulativeIndexes();\n', '\n', '        reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n', '            _balanceIncrease,\n', '            user.stableBorrowRate\n', '        );\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the user as a consequence of a stable rate rebalance\n', '    * @param _reserve the address of the principal reserve where the user borrowed\n', '    * @param _user the address of the borrower\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    **/\n', '\n', '    function updateUserStateOnRebalanceInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _balanceIncrease\n', '    ) internal {\n', '        CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '\n', '        user.principalBorrowBalance = user.principalBorrowBalance.add(_balanceIncrease);\n', '        user.stableBorrowRate = reserve.currentStableBorrowRate;\n', '\n', '        //solium-disable-next-line\n', '        user.lastUpdateTimestamp = uint40(block.timestamp);\n', '    }\n', '\n', '    /**\n', '    * @dev updates the state of the user as a consequence of a stable rate rebalance\n', '    * @param _reserve the address of the principal reserve where the user borrowed\n', '    * @param _user the address of the borrower\n', '    * @param _balanceIncrease the accrued interest on the borrowed amount\n', '    * @param _amountBorrowed the accrued interest on the borrowed amount\n', '    **/\n', '    function updateReserveTotalBorrowsByRateModeInternal(\n', '        address _reserve,\n', '        address _user,\n', '        uint256 _principalBalance,\n', '        uint256 _balanceIncrease,\n', '        uint256 _amountBorrowed,\n', '        CoreLibrary.InterestRateMode _newBorrowRateMode\n', '    ) internal {\n', '        CoreLibrary.InterestRateMode previousRateMode = getUserCurrentBorrowRateMode(\n', '            _reserve,\n', '            _user\n', '        );\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '\n', '        if (previousRateMode == CoreLibrary.InterestRateMode.STABLE) {\n', '            CoreLibrary.UserReserveData storage user = usersReserveData[_user][_reserve];\n', '            reserve.decreaseTotalBorrowsStableAndUpdateAverageRate(\n', '                _principalBalance,\n', '                user.stableBorrowRate\n', '            );\n', '        } else if (previousRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n', '            reserve.decreaseTotalBorrowsVariable(_principalBalance);\n', '        }\n', '\n', '        uint256 newPrincipalAmount = _principalBalance.add(_balanceIncrease).add(_amountBorrowed);\n', '        if (_newBorrowRateMode == CoreLibrary.InterestRateMode.STABLE) {\n', '            reserve.increaseTotalBorrowsStableAndUpdateAverageRate(\n', '                newPrincipalAmount,\n', '                reserve.currentStableBorrowRate\n', '            );\n', '        } else if (_newBorrowRateMode == CoreLibrary.InterestRateMode.VARIABLE) {\n', '            reserve.increaseTotalBorrowsVariable(newPrincipalAmount);\n', '        } else {\n', '            revert("Invalid new borrow rate mode");\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev Updates the reserve current stable borrow rate Rf, the current variable borrow rate Rv and the current liquidity rate Rl.\n', '    * Also updates the lastUpdateTimestamp value. Please refer to the whitepaper for further information.\n', '    * @param _reserve the address of the reserve to be updated\n', '    * @param _liquidityAdded the amount of liquidity added to the protocol (deposit or repay) in the previous action\n', '    * @param _liquidityTaken the amount of liquidity taken from the protocol (redeem or borrow)\n', '    **/\n', '\n', '    function updateReserveInterestRatesAndTimestampInternal(\n', '        address _reserve,\n', '        uint256 _liquidityAdded,\n', '        uint256 _liquidityTaken\n', '    ) internal {\n', '        CoreLibrary.ReserveData storage reserve = reserves[_reserve];\n', '        (uint256 newLiquidityRate, uint256 newStableRate, uint256 newVariableRate) = IReserveInterestRateStrategy(\n', '            reserve\n', '                .interestRateStrategyAddress\n', '        )\n', '            .calculateInterestRates(\n', '            _reserve,\n', '            getReserveAvailableLiquidity(_reserve).add(_liquidityAdded).sub(_liquidityTaken),\n', '            reserve.totalBorrowsStable,\n', '            reserve.totalBorrowsVariable,\n', '            reserve.currentAverageStableBorrowRate\n', '        );\n', '\n', '        reserve.currentLiquidityRate = newLiquidityRate;\n', '        reserve.currentStableBorrowRate = newStableRate;\n', '        reserve.currentVariableBorrowRate = newVariableRate;\n', '\n', '        //solium-disable-next-line\n', '        reserve.lastUpdateTimestamp = uint40(block.timestamp);\n', '\n', '        emit ReserveUpdated(\n', '            _reserve,\n', '            newLiquidityRate,\n', '            newStableRate,\n', '            newVariableRate,\n', '            reserve.lastLiquidityCumulativeIndex,\n', '            reserve.lastVariableBorrowCumulativeIndex\n', '        );\n', '    }\n', '\n', '    /**\n', '    * @dev transfers to the protocol fees of a flashloan to the fees collection address\n', '    * @param _token the address of the token being transferred\n', '    * @param _amount the amount being transferred\n', '    **/\n', '\n', '    function transferFlashLoanProtocolFeeInternal(address _token, uint256 _amount) internal {\n', '        address payable receiver = address(uint160(addressesProvider.getTokenDistributor()));\n', '\n', '        if (_token != EthAddressLib.ethAddress()) {\n', '            ERC20(_token).safeTransfer(receiver, _amount);\n', '        } else {\n', '            receiver.transfer(_amount);\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @dev updates the internal configuration of the core\n', '    **/\n', '    function refreshConfigInternal() internal {\n', '        lendingPoolAddress = addressesProvider.getLendingPool();\n', '    }\n', '\n', '    /**\n', '    * @dev adds a reserve to the array of the reserves address\n', '    **/\n', '    function addReserveToListInternal(address _reserve) internal {\n', '        bool reserveAlreadyAdded = false;\n', '        for (uint256 i = 0; i < reservesList.length; i++)\n', '            if (reservesList[i] == _reserve) {\n', '                reserveAlreadyAdded = true;\n', '            }\n', '        if (!reserveAlreadyAdded) reservesList.push(_reserve);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/lendingpool/DefaultReserveInterestRateStrategy.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '* DefaultReserveInterestRateStrategy contract\n', '* -\n', '* implements the calculation of the interest rates depending on the reserve parameters.\n', '* if there is need to update the calculation of the interest rates for a specific reserve,\n', '* a new version of this contract will be deployed.\n', '* -\n', '* This contract was cloned from Populous and modified to work with the Populous World eco-system.\n', '**/\n', '\n', 'contract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n', '    using WadRayMath for uint256;\n', '    using SafeMath for uint256;\n', '\n', '\n', '\n', '   /**\n', '    * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates\n', '    * expressed in ray\n', '    **/\n', '    uint256 public constant OPTIMAL_UTILIZATION_RATE = 0.8 * 1e27;\n', '\n', '   /**\n', "    * @dev this constant represents the excess utilization rate above the optimal. It's always equal to\n", '    * 1-optimal utilization rate. Added as a constant here for gas optimizations\n', '    * expressed in ray\n', '    **/\n', '\n', '    uint256 public constant EXCESS_UTILIZATION_RATE = 0.2 * 1e27;\n', '\n', '    LendingPoolAddressesProvider public addressesProvider;\n', '\n', '\n', '    //base variable borrow rate when Utilization rate = 0. Expressed in ray\n', '    uint256 public baseVariableBorrowRate;\n', '\n', '    //slope of the variable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n', '    uint256 public variableRateSlope1;\n', '\n', '    //slope of the variable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n', '    uint256 public variableRateSlope2;\n', '\n', '    //slope of the stable interest curve when utilization rate > 0 and <= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n', '    uint256 public stableRateSlope1;\n', '\n', '    //slope of the stable interest curve when utilization rate > OPTIMAL_UTILIZATION_RATE. Expressed in ray\n', '    uint256 public stableRateSlope2;\n', '    \n', '    address public reserve;\n', '\n', '    constructor(\n', '        address _reserve,\n', '        LendingPoolAddressesProvider _provider,\n', '        uint256 _baseVariableBorrowRate,\n', '        uint256 _variableRateSlope1,\n', '        uint256 _variableRateSlope2,\n', '        uint256 _stableRateSlope1,\n', '        uint256 _stableRateSlope2\n', '    ) public {\n', '        addressesProvider = _provider;\n', '        baseVariableBorrowRate = _baseVariableBorrowRate;\n', '        variableRateSlope1 = _variableRateSlope1;\n', '        variableRateSlope2 = _variableRateSlope2;\n', '        stableRateSlope1 = _stableRateSlope1;\n', '        stableRateSlope2 = _stableRateSlope2;\n', '        reserve = _reserve;\n', '    }\n', '\n', '    /**\n', '    @dev accessors\n', '     */\n', '\n', '    function getBaseVariableBorrowRate() external view returns (uint256) {\n', '        return baseVariableBorrowRate;\n', '    }\n', '\n', '    function getVariableRateSlope1() external view returns (uint256) {\n', '        return variableRateSlope1;\n', '    }\n', '\n', '    function getVariableRateSlope2() external view returns (uint256) {\n', '        return variableRateSlope2;\n', '    }\n', '\n', '    function getStableRateSlope1() external view returns (uint256) {\n', '        return stableRateSlope1;\n', '    }\n', '\n', '    function getStableRateSlope2() external view returns (uint256) {\n', '        return stableRateSlope2;\n', '    }\n', '\n', '    /**\n', '    * @dev calculates the interest rates depending on the available liquidity and the total borrowed.\n', '    * @param _reserve the address of the reserve\n', '    * @param _availableLiquidity the liquidity available in the reserve\n', '    * @param _totalBorrowsStable the total borrowed from the reserve a stable rate\n', '    * @param _totalBorrowsVariable the total borrowed from the reserve at a variable rate\n', '    * @param _averageStableBorrowRate the weighted average of all the stable rate borrows\n', '    * @return the liquidity rate, stable borrow rate and variable borrow rate calculated from the input parameters\n', '    **/\n', '    function calculateInterestRates(\n', '        address _reserve,\n', '        uint256 _availableLiquidity,\n', '        uint256 _totalBorrowsStable,\n', '        uint256 _totalBorrowsVariable,\n', '        uint256 _averageStableBorrowRate\n', '    )\n', '        external\n', '        view\n', '        returns (\n', '            uint256 currentLiquidityRate,\n', '            uint256 currentStableBorrowRate,\n', '            uint256 currentVariableBorrowRate\n', '        )\n', '    {\n', '        uint256 totalBorrows = _totalBorrowsStable.add(_totalBorrowsVariable);\n', '\n', '        uint256 utilizationRate = (totalBorrows == 0 && _availableLiquidity == 0)\n', '            ? 0\n', '            : totalBorrows.rayDiv(_availableLiquidity.add(totalBorrows));\n', '\n', '        currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle())\n', '            .getMarketBorrowRate(_reserve);\n', '\n', '        if (utilizationRate > OPTIMAL_UTILIZATION_RATE) {\n', '            uint256 excessUtilizationRateRatio = utilizationRate\n', '                .sub(OPTIMAL_UTILIZATION_RATE)\n', '                .rayDiv(EXCESS_UTILIZATION_RATE);\n', '\n', '            currentStableBorrowRate = currentStableBorrowRate.add(stableRateSlope1).add(\n', '                stableRateSlope2.rayMul(excessUtilizationRateRatio)\n', '            );\n', '\n', '            currentVariableBorrowRate = baseVariableBorrowRate.add(variableRateSlope1).add(\n', '                variableRateSlope2.rayMul(excessUtilizationRateRatio)\n', '            );\n', '        } else {\n', '            currentStableBorrowRate = currentStableBorrowRate.add(\n', '                stableRateSlope1.rayMul(\n', '                    utilizationRate.rayDiv(\n', '                        OPTIMAL_UTILIZATION_RATE\n', '                    )\n', '                )\n', '            );\n', '            currentVariableBorrowRate = baseVariableBorrowRate.add(\n', '                utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE).rayMul(variableRateSlope1)\n', '            );\n', '        }\n', '\n', '        currentLiquidityRate = getOverallBorrowRateInternal(\n', '            _totalBorrowsStable,\n', '            _totalBorrowsVariable,\n', '            currentVariableBorrowRate,\n', '            _averageStableBorrowRate\n', '        )\n', '            .rayMul(utilizationRate);\n', '\n', '    }\n', '\n', '    /**\n', '    * @dev calculates the overall borrow rate as the weighted average between the total variable borrows and total stable borrows.\n', '    * @param _totalBorrowsStable the total borrowed from the reserve a stable rate\n', '    * @param _totalBorrowsVariable the total borrowed from the reserve at a variable rate\n', '    * @param _currentVariableBorrowRate the current variable borrow rate\n', '    * @param _currentAverageStableBorrowRate the weighted average of all the stable rate borrows\n', '    * @return the weighted averaged borrow rate\n', '    **/\n', '    function getOverallBorrowRateInternal(\n', '        uint256 _totalBorrowsStable,\n', '        uint256 _totalBorrowsVariable,\n', '        uint256 _currentVariableBorrowRate,\n', '        uint256 _currentAverageStableBorrowRate\n', '    ) internal pure returns (uint256) {\n', '        uint256 totalBorrows = _totalBorrowsStable.add(_totalBorrowsVariable);\n', '\n', '        if (totalBorrows == 0) return 0;\n', '\n', '        uint256 weightedVariableRate = _totalBorrowsVariable.wadToRay().rayMul(\n', '            _currentVariableBorrowRate\n', '        );\n', '\n', '        uint256 weightedStableRate = _totalBorrowsStable.wadToRay().rayMul(\n', '            _currentAverageStableBorrowRate\n', '        );\n', '\n', '        uint256 overallBorrowRate = weightedVariableRate.add(weightedStableRate).rayDiv(\n', '            totalBorrows.wadToRay()\n', '        );\n', '\n', '        return overallBorrowRate;\n', '    }\n', '}']