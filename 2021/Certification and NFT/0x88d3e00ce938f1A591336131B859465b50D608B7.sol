['// SPDX-License-Identifier: MIT\n', '\n', 'import "./ReentrancyGuard.sol";\n', 'import "./Context.sol";\n', 'import "./Ownable.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Address.sol";\n', 'import "./IERC1155.sol";\n', 'import "./ERC1155.sol";\n', 'import "./FlatPriceSale.sol";\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'contract NFT_FM is ERC1155, Ownable, ReentrancyGuard {\n', '    constructor(address _authAddress)\n', '        ERC1155("https://nftfm.io/api/nft/{id}")\n', '    {\n', '        authAddress = _authAddress;\n', '        onlyMintersCanMint = false;\n', '    }\n', '\n', '    address public authAddress;\n', '    uint256 public nftID;\n', '    bool public onlyMintersCanMint;\n', '    mapping(address => bool) public isMinter;\n', '    mapping(uint256 => address) public owners;\n', '    mapping(address => uint256[]) public artists;\n', '    mapping(address => bool) public isSaleContract;\n', '\n', '    event MintAndStake(\n', '        uint256 indexed nftID,\n', '        uint32 quantity,\n', '        uint256 price,\n', '        uint256 startTime,\n', '        address saleAddress,\n', '        bytes data,\n', '        string databaseID\n', '    );\n', '\n', '    function setMinter(address minter, bool status)\n', '        public\n', '        nonReentrant\n', '        onlyOwner\n', '    {\n', '        isMinter[minter] = status;\n', '    }\n', '\n', '    function setSaleContract(address saleContract, bool status)\n', '        public\n', '        nonReentrant\n', '        onlyOwner\n', '    {\n', '        isSaleContract[saleContract] = status;\n', '    }\n', '\n', '    function setAuthAddress(address _address) public nonReentrant onlyOwner {\n', '        authAddress = _address;\n', '    }\n', '\n', '    function mintAndStake(\n', '        uint32 quantity,\n', '        uint256 price,\n', '        uint256 startTime,\n', '        address saleAddress,\n', '        bytes calldata data,\n', '        string calldata databaseID,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public nonReentrant {\n', '        require(price >= 0, "Price less than 0");\n', '        require(quantity > 0, "Price greater than 1");\n', '        if (onlyMintersCanMint)\n', '            require(isMinter[_msgSender()] == true, "Caller is not a minter");\n', '        require(isSaleContract[saleAddress], "Unrecognized sale contract.");\n', '        address signer = ecrecover(\n', '            keccak256(\n', '                abi.encode(\n', '                    "NFTFM_mintAndStake",\n', '                    _msgSender(),\n', '                    quantity,\n', '                    price,\n', '                    startTime,\n', '                    saleAddress,\n', '                    data\n', '                )\n', '            ),\n', '            v, r, s\n', '        );\n', '        require(signer == authAddress, "Invalid signature");\n', '        nftID++;\n', '        owners[nftID] = _msgSender();\n', '        artists[_msgSender()].push(nftID);\n', '        _mint(saleAddress, nftID, quantity, "initial mint");\n', '        INFTSale(saleAddress).stake(\n', '            nftID,\n', '            payable(_msgSender()),\n', '            quantity,\n', '            price,\n', '            startTime,\n', '            data\n', '        );\n', '        emit MintAndStake(\n', '            nftID,\n', '            quantity,\n', '            price,\n', '            startTime,\n', '            saleAddress,\n', '            data,\n', '            databaseID\n', '        );\n', '    }\n', '\n', '    function mint(\n', '        address to,\n', '        uint256 id,\n', '        uint256 quantity\n', '    ) public nonReentrant {\n', '        if (onlyMintersCanMint)\n', '            require(isMinter[_msgSender()] == true, "Caller is not a minter");\n', '        require(owners[id] == _msgSender(), "Caller does not own id");\n', '        _mint(to, id, quantity, "the more the merrier!");\n', '        // TODO should additional minting also be sent to a sales contract?\n', '    }\n', '\n', '    function burn(uint256 id, uint256 quantity) public nonReentrant {\n', '        _burn(_msgSender(), id, quantity);\n', '    }\n', '\n', '    function burnBatch(uint256[] memory ids, uint256[] memory quantitys)\n', '        public\n', '        nonReentrant\n', '    {\n', '        _burnBatch(_msgSender(), ids, quantitys);\n', '    }\n', '\n', '    function getArtistsNFTs(address _owner)\n', '        public\n', '        view\n', '        returns (uint256[] memory)\n', '    {\n', '        return artists[_owner];\n', '    }\n', '\n', '    function getFullBalance(address user)\n', '        public\n', '        view\n', '        returns (uint256[] memory, uint256[] memory)\n', '    {\n', '        uint256[] memory ids = new uint256[](nftID);\n', '        uint256[] memory balances = new uint256[](nftID);\n', '        for (uint256 id = 1; id <= nftID; id++) {\n', '            ids[id - 1] = id;\n', '            balances[id - 1] = balanceOf(user, id);\n', '        }\n', '        return (ids, balances);\n', '    }\n', '}']