['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-26\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.3;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '/**\n', ' * @dev Library used to query support of an interface declared via {IERC165}.\n', ' *\n', ' * Note that these functions return the actual result of the query: they do not\n', ' * `revert` if an interface is not supported. It is up to the caller to decide\n', ' * what to do in these cases.\n', ' */\n', 'library ERC165Checker {\n', '    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n', '    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n', '\n', '    /**\n', '     * @dev Returns true if `account` supports the {IERC165} interface,\n', '     */\n', '    function supportsERC165(address account) internal view returns (bool) {\n', '        // Any contract that implements ERC165 must explicitly indicate support of\n', '        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n', '        return\n', '            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\n', '            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if `account` supports the interface defined by\n', '     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n', '     *\n', '     * See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(address account, bytes4 interfaceId)\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // query support of both ERC165 as per the spec and support of _interfaceId\n', '        return\n', '            supportsERC165(account) &&\n', '            _supportsERC165Interface(account, interfaceId);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns a boolean array where each value corresponds to the\n', "     * interfaces passed in and whether they're supported or not. This allows\n", '     * you to batch check interfaces for a contract where your expectation\n', '     * is that some interfaces may not be supported.\n', '     *\n', '     * See {IERC165-supportsInterface}.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function getSupportedInterfaces(\n', '        address account,\n', '        bytes4[] memory interfaceIds\n', '    ) internal view returns (bool[] memory) {\n', "        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n", '        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n', '\n', '        // query support of ERC165 itself\n', '        if (supportsERC165(account)) {\n', '            // query support of each interface in interfaceIds\n', '            for (uint256 i = 0; i < interfaceIds.length; i++) {\n', '                interfaceIdsSupported[i] = _supportsERC165Interface(\n', '                    account,\n', '                    interfaceIds[i]\n', '                );\n', '            }\n', '        }\n', '\n', '        return interfaceIdsSupported;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if `account` supports all the interfaces defined in\n', '     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n', '     *\n', '     * Batch-querying can lead to gas savings by skipping repeated checks for\n', '     * {IERC165} support.\n', '     *\n', '     * See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsAllInterfaces(\n', '        address account,\n', '        bytes4[] memory interfaceIds\n', '    ) internal view returns (bool) {\n', '        // query support of ERC165 itself\n', '        if (!supportsERC165(account)) {\n', '            return false;\n', '        }\n', '\n', '        // query support of each interface in _interfaceIds\n', '        for (uint256 i = 0; i < interfaceIds.length; i++) {\n', '            if (!_supportsERC165Interface(account, interfaceIds[i])) {\n', '                return false;\n', '            }\n', '        }\n', '\n', '        // all interfaces supported\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @notice Query if a contract implements an interface, does not check ERC165 support\n', '     * @param account The address of the contract to query for support of an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @return true if the contract at account indicates support of the interface with\n', '     * identifier interfaceId, false otherwise\n', '     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n', '     * the behavior of this method is undefined. This precondition can be checked\n', '     * with {supportsERC165}.\n', '     * Interface identification is specified in ERC-165.\n', '     */\n', '    function _supportsERC165Interface(address account, bytes4 interfaceId)\n', '        private\n', '        view\n', '        returns (bool)\n', '    {\n', '        bytes memory encodedParams =\n', '            abi.encodeWithSelector(\n', '                IERC165(account).supportsInterface.selector,\n', '                interfaceId\n', '            );\n', '        (bool success, bytes memory result) =\n', '            account.staticcall{gas: 30000}(encodedParams);\n', '        if (result.length < 32) return false;\n', '        return success && abi.decode(result, (bool));\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n', ' * for the additional interface id that will be supported. For example:\n', ' *\n', ' * ```solidity\n', ' * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', ' *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n', ' * }\n', ' * ```\n', ' *\n', ' * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        return interfaceId == type(IERC165).interfaceId;\n', '    }\n', '}\n', '\n', 'abstract contract MinterReceiver is ERC165 {\n', '    function onSharesMinted(\n', '        uint40 stakeId,\n', '        address supplier,\n', '        uint72 stakedHearts,\n', '        uint72 stakeShares\n', '    ) external virtual;\n', '\n', '    function onEarningsMinted(uint40 stakeId, uint72 heartsEarned)\n', '        external\n', '        virtual;\n', '\n', '    function supportsInterface(bytes4 interfaceId)\n', '        public\n', '        view\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        return\n', '            interfaceId == type(MinterReceiver).interfaceId ||\n', '            super.supportsInterface(interfaceId);\n', '    }\n', '}\n', '\n', 'interface IHEX {\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function currentDay() external view returns (uint256);\n', '\n', '    function stakeCount(address stakerAddr) external view returns (uint256);\n', '\n', '    function stakeEnd(uint256 stakeIndex, uint40 stakeIdParam) external;\n', '\n', '    function stakeLists(address, uint256)\n', '        external\n', '        view\n', '        returns (\n', '            uint40 stakeId,\n', '            uint72 stakedHearts,\n', '            uint72 stakeShares,\n', '            uint16 lockedDay,\n', '            uint16 stakedDays,\n', '            uint16 unlockedDay,\n', '            bool isAutoStake\n', '        );\n', '\n', '    function stakeStart(uint256 newStakedHearts, uint256 newStakedDays)\n', '        external;\n', '\n', '    function transfer(address recipient, uint256 amount)\n', '        external\n', '        returns (bool);\n', '\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}\n', '\n', 'contract ShareMinter {\n', '    IHEX public hexContract;\n', '\n', '    struct Stake {\n', '        uint24 unlockDay;\n', '        MinterReceiver receiver;\n', '    }\n', '    mapping(uint40 => Stake) public stakes;\n', '\n', '    event MintShares(uint40 stakeId, MinterReceiver receiver, uint72 shares);\n', '    event MintEarnings(uint40 stakeId, MinterReceiver receiver, uint72 hearts);\n', '\n', '    uint256 private unlocked = 1;\n', '    modifier lock() {\n', '        require(unlocked == 1, "LOCKED");\n', '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    constructor(IHEX _hex) {\n', '        hexContract = _hex;\n', '    }\n', '\n', '    function mintShares(\n', '        MinterReceiver receiver,\n', '        address supplier,\n', '        uint256 newStakedHearts,\n', '        uint256 newStakedDays\n', '    ) external lock {\n', '        require(\n', '            ERC165Checker.supportsInterface(\n', '                address(receiver),\n', '                type(MinterReceiver).interfaceId\n', '            ),\n', '            "UNSUPPORTED_RECEIVER"\n', '        );\n', '\n', '        hexContract.transferFrom(msg.sender, address(this), newStakedHearts);\n', '        hexContract.stakeStart(newStakedHearts, newStakedDays);\n', '\n', '        uint256 stakeCount = hexContract.stakeCount(address(this));\n', '        (\n', '            uint40 stakeId,\n', '            uint72 stakedHearts,\n', '            uint72 stakeShares,\n', '            uint16 lockedDay,\n', '            uint16 stakedDays,\n', '            ,\n', '\n', '        ) = hexContract.stakeLists(address(this), stakeCount - 1);\n', '        uint24 unlockDay = lockedDay + stakedDays;\n', '\n', '        Stake storage stake = stakes[stakeId];\n', '        stake.receiver = receiver;\n', '        stake.unlockDay = unlockDay;\n', '\n', '        receiver.onSharesMinted(stakeId, supplier, stakedHearts, stakeShares);\n', '\n', '        emit MintShares(stakeId, receiver, stakeShares);\n', '    }\n', '\n', '    function mintEarnings(uint256 stakeIndex, uint40 stakeId) external lock {\n', '        Stake memory stake = stakes[stakeId];\n', '        uint256 currentDay = hexContract.currentDay();\n', '        require(currentDay >= stake.unlockDay, "STAKE_NOT_MATURE");\n', '\n', '        uint256 prevHearts = hexContract.balanceOf(address(this));\n', '        hexContract.stakeEnd(stakeIndex, stakeId);\n', '        uint256 newHearts = hexContract.balanceOf(address(this));\n', '        uint72 heartsEarned = uint72(newHearts - prevHearts);\n', '\n', '        hexContract.transfer(address(stake.receiver), heartsEarned);\n', '        stake.receiver.onEarningsMinted(stakeId, heartsEarned);\n', '\n', '        emit MintEarnings(stakeId, stake.receiver, heartsEarned);\n', '    }\n', '}']