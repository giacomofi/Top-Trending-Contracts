['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-08\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Proxy\n', ' * @dev Implements delegation of calls to other contracts, with proper\n', ' * forwarding of return values and bubbling of failures.\n', ' * It defines a fallback function that delegates all calls to the address\n', ' * returned by the abstract _implementation() internal function.\n', ' */\n', 'abstract contract Proxy {\n', '  /**\n', '   * @dev Fallback function.\n', '   * Implemented entirely in `_fallback`.\n', '   */\n', '  fallback () payable external {\n', '    _fallback();\n', '  }\n', '  \n', '  receive () payable external {\n', '    _fallback();\n', '  }\n', '\n', '  /**\n', '   * @return The Address of the implementation.\n', '   */\n', '  function _implementation() virtual internal view returns (address);\n', '\n', '  /**\n', '   * @dev Delegates execution to an implementation contract.\n', "   * This is a low level function that doesn't return to its internal call site.\n", '   * It will return to the external caller whatever the implementation returns.\n', '   * @param implementation Address to delegate.\n', '   */\n', '  function _delegate(address implementation) internal {\n', '    assembly {\n', '      // Copy msg.data. We take full control of memory in this inline assembly\n', '      // block because it will not return to Solidity code. We overwrite the\n', '      // Solidity scratch pad at memory position 0.\n', '      calldatacopy(0, 0, calldatasize())\n', '\n', '      // Call the implementation.\n', "      // out and outsize are 0 because we don't know the size yet.\n", '      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n', '\n', '      // Copy the returned data.\n', '      returndatacopy(0, 0, returndatasize())\n', '\n', '      switch result\n', '      // delegatecall returns 0 on error.\n', '      case 0 { revert(0, returndatasize()) }\n', '      default { return(0, returndatasize()) }\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Function that is run as the first thing in the fallback function.\n', '   * Can be redefined in derived contracts to add functionality.\n', '   * Redefinitions must call super._willFallback().\n', '   */\n', '  function _willFallback() virtual internal {\n', '      \n', '  }\n', '\n', '  /**\n', '   * @dev fallback implementation.\n', '   * Extracted to enable manual triggering.\n', '   */\n', '  function _fallback() internal {\n', '    if(OpenZeppelinUpgradesAddress.isContract(msg.sender) && msg.data.length == 0 && gasleft() <= 2300)         // for receive ETH only from other contract\n', '        return;\n', '    _willFallback();\n', '    _delegate(_implementation());\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title BaseUpgradeabilityProxy\n', ' * @dev This contract implements a proxy that allows to change the\n', ' * implementation address to which it will delegate.\n', ' * Such a change is called an implementation upgrade.\n', ' */\n', 'abstract contract BaseUpgradeabilityProxy is Proxy {\n', '  /**\n', '   * @dev Emitted when the implementation is upgraded.\n', '   * @param implementation Address of the new implementation.\n', '   */\n', '  event Upgraded(address indexed implementation);\n', '\n', '  /**\n', '   * @dev Storage slot with the address of the current implementation.\n', '   * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n', '   * validated in the constructor.\n', '   */\n', '  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '  /**\n', '   * @dev Returns the current implementation.\n', '   * @return impl Address of the current implementation\n', '   */\n', '  function _implementation() override internal view returns (address impl) {\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '    assembly {\n', '      impl := sload(slot)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrades the proxy to a new implementation.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _upgradeTo(address newImplementation) internal {\n', '    _setImplementation(newImplementation);\n', '    emit Upgraded(newImplementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the implementation address of the proxy.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function _setImplementation(address newImplementation) internal {\n', '    require(OpenZeppelinUpgradesAddress.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");\n', '\n', '    bytes32 slot = IMPLEMENTATION_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newImplementation)\n', '    }\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title BaseAdminUpgradeabilityProxy\n', ' * @dev This contract combines an upgradeability proxy with an authorization\n', ' * mechanism for administrative tasks.\n', ' * All external functions in this contract must be guarded by the\n', ' * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n', ' * feature proposal that would enable this to be done automatically.\n', ' */\n', 'contract BaseAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '  /**\n', '   * @dev Emitted when the administration has been transferred.\n', '   * @param previousAdmin Address of the previous admin.\n', '   * @param newAdmin Address of the new admin.\n', '   */\n', '  event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '  /**\n', '   * @dev Storage slot with the admin of the contract.\n', '   * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n', '   * validated in the constructor.\n', '   */\n', '\n', '  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n', '\n', '  /**\n', '   * @dev Modifier to check whether the `msg.sender` is the admin.\n', '   * If it is, it will run the function. Otherwise, it will delegate the call\n', '   * to the implementation.\n', '   */\n', '  modifier ifAdmin() {\n', '    if (msg.sender == _admin()) {\n', '      _;\n', '    } else {\n', '      _fallback();\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @return The address of the proxy admin.\n', '   */\n', '  function admin() external ifAdmin returns (address) {\n', '    return _admin();\n', '  }\n', '\n', '  /**\n', '   * @return The address of the implementation.\n', '   */\n', '  function implementation() external ifAdmin returns (address) {\n', '    return _implementation();\n', '  }\n', '\n', '  /**\n', '   * @dev Changes the admin of the proxy.\n', '   * Only the current admin can call this function.\n', '   * @param newAdmin Address to transfer proxy administration to.\n', '   */\n', '  function changeAdmin(address newAdmin) external ifAdmin {\n', '    require(newAdmin != address(0), "Cannot change the admin of a proxy to the zero address");\n', '    emit AdminChanged(_admin(), newAdmin);\n', '    _setAdmin(newAdmin);\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrade the backing implementation of the proxy.\n', '   * Only the admin can call this function.\n', '   * @param newImplementation Address of the new implementation.\n', '   */\n', '  function upgradeTo(address newImplementation) external ifAdmin {\n', '    _upgradeTo(newImplementation);\n', '  }\n', '\n', '  /**\n', '   * @dev Upgrade the backing implementation of the proxy and call a function\n', '   * on the new implementation.\n', '   * This is useful to initialize the proxied contract.\n', '   * @param newImplementation Address of the new implementation.\n', '   * @param data Data to send as msg.data in the low level call.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   */\n', '  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n', '    _upgradeTo(newImplementation);\n', '    (bool success,) = newImplementation.delegatecall(data);\n', '    require(success);\n', '  }\n', '\n', '  /**\n', '   * @return adm The admin slot.\n', '   */\n', '  function _admin() internal view returns (address adm) {\n', '    bytes32 slot = ADMIN_SLOT;\n', '    assembly {\n', '      adm := sload(slot)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the address of the proxy admin.\n', '   * @param newAdmin Address of the new proxy admin.\n', '   */\n', '  function _setAdmin(address newAdmin) internal {\n', '    bytes32 slot = ADMIN_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newAdmin)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Only fall back when the sender is not the admin.\n', '   */\n', '  function _willFallback() virtual override internal {\n', '    require(msg.sender != _admin(), "Cannot call fallback function from the proxy admin");\n', '    //super._willFallback();\n', '  }\n', '}\n', '\n', 'interface IAdminUpgradeabilityProxyView {\n', '  function admin() external view returns (address);\n', '  function implementation() external view returns (address);\n', '}\n', '\n', '\n', '/**\n', ' * @title UpgradeabilityProxy\n', ' * @dev Extends BaseUpgradeabilityProxy with a constructor for initializing\n', ' * implementation and init data.\n', ' */\n', 'abstract contract UpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '  /**\n', '   * @dev Contract constructor.\n', '   * @param _logic Address of the initial implementation.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '  constructor(address _logic, bytes memory _data) public payable {\n', "    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n", '    _setImplementation(_logic);\n', '    if(_data.length > 0) {\n', '      (bool success,) = _logic.delegatecall(_data);\n', '      require(success);\n', '    }\n', '  }  \n', '  \n', '  //function _willFallback() virtual override internal {\n', '    //super._willFallback();\n', '  //}\n', '}\n', '\n', '\n', '/**\n', ' * @title AdminUpgradeabilityProxy\n', ' * @dev Extends from BaseAdminUpgradeabilityProxy with a constructor for \n', ' * initializing the implementation, admin, and init data.\n', ' */\n', 'contract AdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, UpgradeabilityProxy {\n', '  /**\n', '   * Contract constructor.\n', '   * @param _logic address of the initial implementation.\n', '   * @param _admin Address of the proxy administrator.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '  constructor(address _admin, address _logic, bytes memory _data) UpgradeabilityProxy(_logic, _data) public payable {\n', "    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n", '    _setAdmin(_admin);\n', '  }\n', '  \n', '  function _willFallback() override(Proxy, BaseAdminUpgradeabilityProxy) internal {\n', '    super._willFallback();\n', '  }\n', '}\n', '\n', '\n', '/**\n', ' * @title InitializableUpgradeabilityProxy\n', ' * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing\n', ' * implementation and init data.\n', ' */\n', 'abstract contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {\n', '  /**\n', '   * @dev Contract initializer.\n', '   * @param _logic Address of the initial implementation.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '  function initialize(address _logic, bytes memory _data) public payable {\n', '    require(_implementation() == address(0));\n', "    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n", '    _setImplementation(_logic);\n', '    if(_data.length > 0) {\n', '      (bool success,) = _logic.delegatecall(_data);\n', '      require(success);\n', '    }\n', '  }  \n', '}\n', '\n', '\n', '/**\n', ' * @title InitializableAdminUpgradeabilityProxy\n', ' * @dev Extends from BaseAdminUpgradeabilityProxy with an initializer for \n', ' * initializing the implementation, admin, and init data.\n', ' */\n', 'contract InitializableAdminUpgradeabilityProxy is BaseAdminUpgradeabilityProxy, InitializableUpgradeabilityProxy {\n', '  /**\n', '   * Contract initializer.\n', '   * @param _logic address of the initial implementation.\n', '   * @param _admin Address of the proxy administrator.\n', '   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '  function initialize(address _admin, address _logic, bytes memory _data) public payable {\n', '    require(_implementation() == address(0));\n', '    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n', "    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n", '    _setAdmin(_admin);\n', '  }\n', '  \n', '  function _willFallback() override(Proxy, BaseAdminUpgradeabilityProxy) internal {\n', '    super._willFallback();\n', '  }\n', '\n', '}\n', '\n', '\n', 'interface IProxyFactory {\n', '    function productImplementation() external view returns (address);\n', '    function productImplementations(bytes32 name) external view returns (address);\n', '}\n', '\n', '\n', '/**\n', ' * @title ProductProxy\n', ' * @dev This contract implements a proxy that \n', ' * it is deploied by ProxyFactory, \n', " * and it's implementation is stored in factory.\n", ' */\n', 'contract ProductProxy is Proxy {\n', '    \n', '  /**\n', '   * @dev Storage slot with the address of the ProxyFactory.\n', '   * This is the keccak-256 hash of "eip1967.proxy.factory" subtracted by 1, and is\n', '   * validated in the constructor.\n', '   */\n', '  bytes32 internal constant FACTORY_SLOT = 0x7a45a402e4cb6e08ebc196f20f66d5d30e67285a2a8aa80503fa409e727a4af1;\n', "  bytes32 internal constant NAME_SLOT    = 0x4cd9b827ca535ceb0880425d70eff88561ecdf04dc32fcf7ff3b15c587f8a870;      // bytes32(uint256(keccak256('eip1967.proxy.name')) - 1)\n", '\n', '  function _name() virtual internal view returns (bytes32 name_) {\n', '    bytes32 slot = NAME_SLOT;\n', '    assembly {  name_ := sload(slot)  }\n', '  }\n', '  \n', '  function _setName(bytes32 name_) internal {\n', '    bytes32 slot = NAME_SLOT;\n', '    assembly {  sstore(slot, name_)  }\n', '  }\n', '\n', '  /**\n', '   * @dev Sets the factory address of the ProductProxy.\n', '   * @param newFactory Address of the new factory.\n', '   */\n', '  function _setFactory(address newFactory) internal {\n', '    require(OpenZeppelinUpgradesAddress.isContract(newFactory), "Cannot set a factory to a non-contract address");\n', '\n', '    bytes32 slot = FACTORY_SLOT;\n', '\n', '    assembly {\n', '      sstore(slot, newFactory)\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the factory.\n', '   * @return factory_ Address of the factory.\n', '   */\n', '  function _factory() internal view returns (address factory_) {\n', '    bytes32 slot = FACTORY_SLOT;\n', '    assembly {\n', '      factory_ := sload(slot)\n', '    }\n', '  }\n', '  \n', '  /**\n', '   * @dev Returns the current implementation.\n', '   * @return Address of the current implementation\n', '   */\n', '  function _implementation() virtual override internal view returns (address) {\n', '    address factory_ = _factory();\n', '    if(OpenZeppelinUpgradesAddress.isContract(factory_))\n', '        return IProxyFactory(factory_).productImplementations(_name());\n', '    else\n', '        return address(0);\n', '  }\n', '\n', '}\n', '\n', '\n', '/**\n', ' * @title InitializableProductProxy\n', ' * @dev Extends ProductProxy with an initializer for initializing\n', ' * factory and init data.\n', ' */\n', 'contract InitializableProductProxy is ProductProxy {\n', '  /**\n', '   * @dev Contract initializer.\n', '   * @param factory_ Address of the initial factory.\n', '   * @param data_ Data to send as msg.data to the implementation to initialize the proxied contract.\n', '   * It should include the signature and the parameters of the function to be called, as described in\n', '   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n', '   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n', '   */\n', '  function __InitializableProductProxy_init(address factory_, bytes32 name_, bytes memory data_) public payable {\n', '    require(_factory() == address(0));\n', "    assert(FACTORY_SLOT == bytes32(uint256(keccak256('eip1967.proxy.factory')) - 1));\n", "    assert(NAME_SLOT    == bytes32(uint256(keccak256('eip1967.proxy.name')) - 1));\n", '    _setFactory(factory_);\n', '    _setName(name_);\n', '    if(data_.length > 0) {\n', '      (bool success,) = _implementation().delegatecall(data_);\n', '      require(success);\n', '    }\n', '  }  \n', '}\n', '\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract ContextUpgradeSafe is Initializable {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '\n', '\n', '    }\n', '\n', '\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '    \n', '    function max_(int256 a, int256 b) internal pure returns (int256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function min_(int256 a, int256 b) internal pure returns (int256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '    \n', '    function abs(int a) internal pure returns (uint) {\n', '        return a >= 0 ? uint(a) : uint(-a);\n', '    }\n', '}\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '    \n', '    function add(uint256 a, int256 b) internal pure returns (uint256 c) {\n', '        c = a + uint256(b);\n', '        require(b >= 0 && c >= a || b < 0 && c < a, "SafeMath: addition overflow");\n', '    }\n', '    \n', '    function add_(int256 a, uint256 b) internal pure returns (int256 c) {\n', '        c = a + int256(b);\n', '        require(c >= a, "SafeMath: addition overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    \n', '    function sub(uint256 a, int256 b) internal pure returns (uint256 c) {\n', '        c = a - uint256(b);\n', '        require(b >= 0 && c <= a || b < 0 && c > a, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub0(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a > b ? a - b : 0;\n', '    }\n', '    \n', '    function sub_(uint256 a, uint256 b) internal pure returns (int256 c) {\n', '        c = int256(a - b);\n', '        require(a >= b && c >= 0 || a < b && c < 0, "SafeMath: sub_ overflow");\n', '    }\n', '\n', '    function sub_(int256 a, int256 b) internal pure returns (int256 c) {\n', '        c = a - b;\n', '        require(a >= b && c >= 0 || a < b && c < 0, "SafeMath: sub_ overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' *\n', ' * Source https://raw.githubusercontent.com/OpenZeppelin/openzeppelin-solidity/v2.1.3/contracts/utils/Address.sol\n', ' * This contract is copied here and renamed from the original to avoid clashes in the compiled artifacts\n', ' * when the user imports a zos-lib contract (that transitively causes this contract to be compiled and added to the\n', ' * build/artifacts folder) as well as the vanilla Address implementation from an openzeppelin version.\n', ' */\n', 'library OpenZeppelinUpgradesAddress {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20MinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20UpgradeSafe is Initializable, ContextUpgradeSafe, IERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping (address => uint256) internal _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    string internal _name;\n', '    string internal _symbol;\n', '    uint8 internal _decimals;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n', '     * a default value of 18.\n', '     *\n', '     * To select a different value for {decimals}, use {_setupDecimals}.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '\n', '    function __ERC20_init(string memory name, string memory symbol) internal initializer {\n', '        __Context_init_unchained();\n', '        __ERC20_init_unchained(name, symbol);\n', '    }\n', '\n', '    function __ERC20_init_unchained(string memory name, string memory symbol) internal initializer {\n', '        _name = name;\n', '        _symbol = symbol;\n', '        _decimals = 18;\n', '        DOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), _chainId(), address(this)));\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        if(sender != _msgSender() && _allowances[sender][_msgSender()] != uint(-1))\n', '            _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '\n', '    function _chainId() internal pure returns (uint id) {\n', '        assembly { id := chainid() }\n', '    }\n', '    \n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '    mapping (address => uint) public nonces;\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n', "        require(deadline >= block.timestamp, 'permit EXPIRED');\n", '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', "                '\\x19\\x01',\n", '                DOMAIN_SEPARATOR,\n', '                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n', '            )\n', '        );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', "        require(recoveredAddress != address(0) && recoveredAddress == owner, 'permit INVALID_SIGNATURE');\n", '        _approve(owner, spender, value);\n', '    }\n', '    \n', '    uint256[42] private __gap;\n', '}\n', '\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that adds a cap to the supply of tokens.\n', ' */\n', 'abstract contract ERC20CappedUpgradeSafe is Initializable, ERC20UpgradeSafe {\n', '    uint256 private _cap;\n', '\n', '    /**\n', '     * @dev Sets the value of the `cap`. This value is immutable, it can only be\n', '     * set once during construction.\n', '     */\n', '\n', '    function __ERC20Capped_init(uint256 cap) internal initializer {\n', '        __Context_init_unchained();\n', '        __ERC20Capped_init_unchained(cap);\n', '    }\n', '\n', '    function __ERC20Capped_init_unchained(uint256 cap) internal initializer {\n', '\n', '\n', '        require(cap > 0, "ERC20Capped: cap is 0");\n', '        _cap = cap;\n', '\n', '    }\n', '\n', '\n', '    /**\n', "     * @dev Returns the cap on the token's total supply.\n", '     */\n', '    function cap() public view returns (uint256) {\n', '        return _cap;\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20-_beforeTokenTransfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - minted tokens must not cause the total supply to go over the cap.\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n', '        super._beforeTokenTransfer(from, to, amount);\n', '\n', '        if (from == address(0)) { // When minting tokens\n', '            require(totalSupply().add(amount) <= _cap, "ERC20Capped: cap exceeded");\n', '        }\n', '    }\n', '\n', '    uint256[49] private __gap;\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract Governable is Initializable {\n', '    address public governor;\n', '\n', '    event GovernorshipTransferred(address indexed previousGovernor, address indexed newGovernor);\n', '\n', '    /**\n', '     * @dev Contract initializer.\n', '     * called once by the factory at time of deployment\n', '     */\n', '    function __Governable_init_unchained(address governor_) virtual public initializer {\n', '        governor = governor_;\n', '        emit GovernorshipTransferred(address(0), governor);\n', '    }\n', '\n', '    modifier governance() {\n', '        require(msg.sender == governor);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current governor to relinquish control of the contract.\n', '     * @notice Renouncing to governorship will leave the contract without an governor.\n', '     * It will not be possible to call the functions with the `governance`\n', '     * modifier anymore.\n', '     */\n', '    function renounceGovernorship() public governance {\n', '        emit GovernorshipTransferred(governor, address(0));\n', '        governor = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current governor to transfer control of the contract to a newGovernor.\n', '     * @param newGovernor The address to transfer governorship to.\n', '     */\n', '    function transferGovernorship(address newGovernor) public governance {\n', '        _transferGovernorship(newGovernor);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newGovernor.\n', '     * @param newGovernor The address to transfer governorship to.\n', '     */\n', '    function _transferGovernorship(address newGovernor) internal {\n', '        require(newGovernor != address(0));\n', '        emit GovernorshipTransferred(governor, newGovernor);\n', '        governor = newGovernor;\n', '    }\n', '}\n', '\n', '\n', 'contract Configurable is Governable {\n', '\n', '    mapping (bytes32 => uint) internal config;\n', '    \n', '    function getConfig(bytes32 key) public view returns (uint) {\n', '        return config[key];\n', '    }\n', '    function getConfigI(bytes32 key, uint index) public view returns (uint) {\n', '        return config[bytes32(uint(key) ^ index)];\n', '    }\n', '    function getConfigA(bytes32 key, address addr) public view returns (uint) {\n', '        return config[bytes32(uint(key) ^ uint(addr))];\n', '    }\n', '\n', '    function _setConfig(bytes32 key, uint value) internal {\n', '        if(config[key] != value)\n', '            config[key] = value;\n', '    }\n', '    function _setConfig(bytes32 key, uint index, uint value) internal {\n', '        _setConfig(bytes32(uint(key) ^ index), value);\n', '    }\n', '    function _setConfig(bytes32 key, address addr, uint value) internal {\n', '        _setConfig(bytes32(uint(key) ^ uint(addr)), value);\n', '    }\n', '    \n', '    function setConfig(bytes32 key, uint value) external governance {\n', '        _setConfig(key, value);\n', '    }\n', '    function setConfigI(bytes32 key, uint index, uint value) external governance {\n', '        _setConfig(bytes32(uint(key) ^ index), value);\n', '    }\n', '    function setConfigA(bytes32 key, address addr, uint value) public governance {\n', '        _setConfig(bytes32(uint(key) ^ uint(addr)), value);\n', '    }\n', '}\n', '\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '}\n', '\n', '\n', 'contract Constants {\n', "    bytes32 internal constant _Call_            = 'Call';\n", "    bytes32 internal constant _Put_             = 'Put';\n", "    bytes32 internal constant _permissionless_  = 'permissionless';\n", "    //bytes32 internal constant _feeRate_         = 'feeRate';\n", "    bytes32 internal constant _feeTo_           = 'feeTo';\n", "    //bytes32 internal constant _uniswapRounter_  = 'uniswapRounter';\n", "    bytes32 internal constant _WETH_            = 'WETH';\n", '\n', '    uint256 internal constant MAX_FEE_RATE      = 0.10 ether;   // 10%\n', '    \n', "    //string  internal constant INPUT_OVERFLOW    = 'INPUT_OVERFLOW';\n", '    //uint256 internal constant MIN_UINT256       = 0;\n', '    //uint256 internal constant MAX_UINT256       = uint256(-1);\n', '    //int256  internal constant MAX_INT256        = int256(MAX_UINT256/2);\n', '    //int256  internal constant MIN_INT256        = MAX_INT256 + 1;               // overflow is desired\n', '}\n', '\n', 'contract Factory is Configurable, ContextUpgradeSafe, Constants {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '    using SafeMath for int;\n', '\n', '    mapping(bytes32 => address) public productImplementations;\n', '    mapping(address => mapping(address => mapping(uint => mapping(uint => address)))) public calls;     // _underlying => _currency => _priceFloor => _priceCap => call\n', '    mapping(address => mapping(address => mapping(uint => mapping(uint => address)))) public puts;\n', '    address[] public allCalls;\n', '    address[] public allPuts;\n', '    \n', '    function length() public view returns (uint) {\n', '        return allCalls.length;\n', '    }\n', '    \n', '    uint public feeRate;\n', '    \n', '    function setFee(uint feeRate_, address feeTo) public governance {\n', '        require(feeRate_ <= MAX_FEE_RATE);\n', '        feeRate = feeRate_;\n', '        config[_feeTo_] = uint(feeTo);\n', '    }\n', '\n', '    function __Factory_init(address governor, address implCall, address implPut, address WETH, address feeTo) public initializer {\n', '        __Governable_init_unchained(governor);\n', '        __Factory_init_unchained(implCall, implPut, WETH, feeTo);\n', '    }\n', '\n', '    function __Factory_init_unchained(address implCall, address implPut, address WETH, address feeTo) public governance {\n', '        productImplementations[_Call_]  = implCall;\n', '        productImplementations[_Put_]   = implPut;\n', '        config[_WETH_]                  = uint(WETH);\n', '        //config[_uniswapRounter_]        = uint(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        setFee(0.005 ether, feeTo);     // 0.5%\n', '    }\n', '    \n', '    function upgradeProductImplementationsTo(address implCall, address implPut) external governance {\n', '        productImplementations[_Call_] = implCall;\n', '        productImplementations[_Put_]  = implPut;\n', '    }\n', '    \n', '    function createOption(address underlying, address currency, uint priceFloor, uint priceCap) public returns (address call_, address put) {\n', "        require(underlying != currency, 'IDENTICAL_ADDRESSES');\n", "        require(underlying != address(0) && currency != address(0), 'ZERO_ADDRESS');\n", "        require(priceFloor < priceCap, 'priceCap should biger than priceFloor');\n", '        require(config[_permissionless_] != 0 || _msgSender() == governor);\n', '\n', "        require(calls[underlying][currency][priceFloor][priceCap] == address(0), 'the Call/Put exist already');     // single check is sufficient\n", '\n', '        bytes memory bytecode = type(InitializableProductProxy).creationCode;\n', '\n', '        bytes32 salt = keccak256(abi.encodePacked(_Call_, underlying, currency, priceFloor, priceCap));\n', '        assembly {\n', '            call_ := create2(0, add(bytecode, 32), mload(bytecode), salt)\n', '        }\n', "        InitializableProductProxy(payable(call_)).__InitializableProductProxy_init(address(this), _Call_, abi.encodeWithSignature('__Call_init(address,address,uint256,uint256)', underlying, currency, priceFloor, priceCap));\n", '        \n', '        salt = keccak256(abi.encodePacked(_Put_, underlying, currency, priceFloor, priceCap));\n', '        assembly {\n', '            put := create2(0, add(bytecode, 32), mload(bytecode), salt)\n', '        }\n', "        InitializableProductProxy(payable(put)).__InitializableProductProxy_init(address(this), _Put_, abi.encodeWithSignature('__Put_init(address,address,uint256,uint256)',  underlying, currency, priceFloor, priceCap));\n", '\n', '        calls[underlying][currency][priceFloor][priceCap] = call_;\n', '        puts [underlying][currency][priceFloor][priceCap] = put;\n', '        allCalls.push(call_);\n', '        allPuts.push(put);\n', '        emit CreateOption(_msgSender(), underlying, currency, priceFloor, priceCap, call_, put, allCalls.length);\n', '    }\n', '    event CreateOption(address indexed creator, address indexed underlying, address indexed currency, uint priceFloor, uint priceCap, address call, address put, uint count);\n', '    \n', '        //if(dCur > 0) {\n', '        //    IERC20(currency).safeTransferFrom(sender, put, uint(dCur));\n', '        //    IERC20(currency).safeTransferFrom(sender, address(config[_feeTo_]), uint(dCur).mul(feeRate).div(1e18));\n', '        //} else if(dCur < 0) {\n', '        //    uint fee = uint(-dCur).mul(feeRate).div(1e18);\n', '        //    Put(put).withdraw_(address(config[_feeTo_]), fee);\n', '        //    Put(put).withdraw_(sender, uint(-dCur).sub(fee));\n', '        //}\n', '    function _transfer(address payable sender, address callOrPut, address undOrCur, int vol) internal {\n', '        if(vol > 0) {\n', '            address from = sender;\n', '            uint fee = uint(vol).mul(feeRate).div(1e18);\n', '            if(msg.value > 0 && undOrCur == address(config[_WETH_])) {\n', '                uint deltaAndFee = uint(vol).add(fee);\n', "                require(msg.value >= deltaAndFee, 'msg.value not enough');\n", '                IWETH(config[_WETH_]).deposit{value: deltaAndFee}();\n', '                if(msg.value > deltaAndFee)\n', '                    sender.transfer(msg.value - deltaAndFee);\n', '                from = address(this);\n', '            }\n', '            if(from == address(this)) {\n', '                IERC20(undOrCur).safeTransfer(callOrPut, uint(vol));\n', '                IERC20(undOrCur).safeTransfer(address(config[_feeTo_]), fee);\n', '            } else {\n', '                IERC20(undOrCur).safeTransferFrom(from, callOrPut, uint(vol));\n', '                IERC20(undOrCur).safeTransferFrom(from, address(config[_feeTo_]), fee);\n', '            }\n', '        } else if(vol < 0) {\n', '            uint fee = uint(-vol).mul(feeRate).div(1e18);\n', '            Call(callOrPut).withdraw_(address(config[_feeTo_]), fee);\n', '            address to = sender;\n', '            if(undOrCur == address(config[_WETH_]))\n', '                to = address(this);\n', '            uint v = uint(-vol).sub(fee);\n', '            Call(callOrPut).withdraw_(to, v);\n', '            if(to == address(this)) {\n', '                IWETH(config[_WETH_]).withdraw(v);\n', '                sender.transfer(v);\n', '            }\n', '        }\n', '    }\n', '    \n', '    function _checkMistakeETH(address payable sender, address underlying, address currency, int dUnd, int dCur) internal {\n', '        address WETH = address(config[_WETH_]);\n', '        if(msg.value > 0 && ((underlying != WETH && currency != WETH) || (underlying == WETH && dUnd <= 0) || (currency == WETH && dCur <= 0)))\n', '            sender.transfer(msg.value);\n', '    }\n', '    \n', '    function swap(address underlying, address currency, uint priceFloor, uint priceCap, int dCall, int dPut, int undMax, int curMax) public payable returns (address call, address put, int dUnd, int dCur) {\n', '        return _swap(_msgSender(), underlying, currency, priceFloor, priceCap, dCall, dPut, undMax, curMax);\n', '    }\n', '    function _swap(address payable sender, address underlying, address currency, uint priceFloor, uint priceCap, int dCall, int dPut, int undMax, int curMax) internal returns (address call, address put, int dUnd, int dCur) {\n', '        call = calls[underlying][currency][priceFloor][priceCap];\n', '        put  = puts [underlying][currency][priceFloor][priceCap];\n', '        if(put == address(0))                                                                      // single check is sufficient\n', '            (call, put) = createOption(underlying, currency, priceFloor, priceCap);\n', '        \n', '        //uint totalUnd;    // share priceFloor instead of totalUnd to avoid stack too deep errors\n', '        //uint totalCur;    // share priceCap   instead of totalCur to avoid stack too deep errors\n', '        //(dUnd, dCur, totalUnd, totalCur) = calcDelta(priceFloor, priceCap, Call(call).totalSupply(), Put(put).totalSupply(), dCall, dPut);\n', '        (dUnd, dCur, priceFloor, priceCap) = calcDelta(priceFloor, priceCap, Call(call).totalSupply(), Put(put).totalSupply(), dCall, dPut);\n', "        require(SafeMath.add_(dUnd, Math.abs(dUnd).mul(feeRate).div(1e18)) <= undMax && SafeMath.add_(dCur, Math.abs(dCur).mul(feeRate).div(1e18)) <= curMax, 'slippage too high');\n", '\n', '        _transfer(sender, call, underlying, dUnd);\n', '        _transfer(sender, put, currency, dCur);\n', '        _checkMistakeETH(sender, underlying, currency, dUnd, dCur);\n', '        \n', '        if(dCall > 0)\n', '            Call(call).mint_(sender, uint(dCall));\n', '        else if(dCall < 0)\n', '            Call(call).burn_(sender, uint(-dCall));\n', '            \n', '        if(dPut > 0)\n', '            Put(put).mint_(sender, uint(dPut));\n', '        else if(dPut < 0)\n', '            Put(put).burn_(sender, uint(-dPut));\n', '        \n', "        //require(IERC20(underlying).balanceOf(call) >= totalUnd && IERC20(currency).balanceOf(put) >= totalCur, 'reserve less than expected');\n", '        //emit Swap(sender, underlying, currency, priceFloor, priceCap, call, put, dCall, dPut, dUnd, dCur);\n', "        require(IERC20(underlying).balanceOf(call) >= priceFloor && IERC20(currency).balanceOf(put) >= priceCap, 'reserve less than expected');     // share priceFloor and priceCap instead of totalUnd and totalCur to avoid stack too deep errors \n", '        emit Swap(sender, underlying, currency, Call(call).priceFloor(), Call(call).priceCap(), call, put, dCall, dPut, dUnd, dCur);\n', '    }\n', '    event Swap(address indexed sender, address indexed underlying, address indexed currency, uint priceFloor, uint priceCap, address call, address put, int dCall, int dPut, int dUnd, int dCur);\n', '\n', '    function _swap2(address undFrom, address curFrom, address underlying, address currency, uint priceFloor, uint priceCap, int volCall, int volPut, int undMax, int curMax) internal returns (address call, address put, int dUnd, int dCur) {\n', '        call = calls[underlying][currency][priceFloor][priceCap];\n', '        put  = puts [underlying][currency][priceFloor][priceCap];\n', '\n', '        if(volCall < 0)\n', '            Call(call).transferFrom(undFrom, address(this), uint(-volCall));\n', '        if(volPut < 0)\n', '            Put (put ).transferFrom(curFrom, address(this), uint(-volPut));\n', '        \n', '        if(undMax > 0)\n', '            IERC20(underlying).safeTransferFrom(undFrom, address(this), uint(undMax));\n', '        if(curMax > 0)\n', '            IERC20(currency  ).safeTransferFrom(curFrom, address(this), uint(curMax));\n', '        \n', '        (call, put, dUnd, dCur) = _swap(address(uint160(address(this))), underlying, currency, priceFloor, priceCap, volCall, volPut, undMax, curMax);\n', '        \n', '        if(Math.max_(0, undMax) > dUnd)\n', '            IERC20(underlying).safeTransfer(undFrom, uint(Math.max_(0, undMax).sub_(dUnd)));\n', '        if(Math.max_(0, curMax) > dCur)\n', '            IERC20(currency  ).safeTransfer(curFrom, uint(Math.max_(0, curMax).sub_(dCur)));\n', '        \n', '        if(volCall > 0)\n', '            Call(call).transfer(undFrom, uint(volCall));\n', '        if(volPut > 0)\n', '            Put (put ).transfer(curFrom, uint(volPut));\n', '    }\n', '    \n', '    function swap2_(address undFrom, address curFrom, address underlying, address currency, uint priceFloor, uint priceCap, int volCall, int volPut, int undMax, int curMax) external governance returns (address call, address put, int dUnd, int dCur) {\n', '        uint oldFeeRate = feeRate;\n', '        feeRate = 0;\n', '        (call, put, dUnd, dCur) = _swap2(undFrom, curFrom, underlying, currency, priceFloor, priceCap, volCall, volPut, undMax, curMax);\n', '        feeRate = oldFeeRate;\n', '    }\n', '    \n', '    function mint4(address underlying, address currency, uint priceFloor, uint priceCap, int volCall, int volPut, int undMax, int curMax) public payable returns (address call, address put, int dUnd, int dCur) {\n', '        return swap(underlying, currency, priceFloor, priceCap, volCall, volPut, undMax, curMax);\n', '    }\n', '    function mint(address callOrPut, int volCall, int volPut, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        (address underlying, address currency, uint priceFloor, uint priceCap) = Call(callOrPut).attributes();\n', '        (, , dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, volCall, volPut, undMax, curMax);\n', '    }\n', '\n', '    function mintCall4(address underlying, address currency, uint priceFloor, uint priceCap, int volCall, int undMax, int curMax) public payable returns (address call, int dUnd, int dCur) {\n', '        (call, , dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, volCall, 0, undMax, curMax);\n', '    }\n', '    function mintCall(address call, int volCall, int undMax, int curMax) public payable returns (int dUnd, int dCur) {\n', '        (address underlying, address currency, uint priceFloor, uint priceCap) = Call(call).attributes();\n', '        (, , dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, volCall, 0, undMax, curMax);\n', '    }\n', '    function mintCall_(address payable sender, address underlying, address currency, uint priceFloor, uint priceCap, int volCall, int undMax, int curMax) public payable returns (int dUnd, int dCur) {\n', "        require(msg.sender == calls[underlying][currency][priceFloor][priceCap], 'Only Call');\n", '        (, , dUnd, dCur) = _swap(sender, underlying, currency, priceFloor, priceCap, volCall, 0, undMax, curMax);\n', '    }\n', '\n', '    function mintPut4(address underlying, address currency, uint priceFloor, uint priceCap, int volPut, int undMax, int curMax) public payable returns (address put, int dUnd, int dCur) {\n', '        (, put, dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, 0, volPut, undMax, curMax);\n', '    }\n', '    function mintPut(address put, int volPut, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        (address underlying, address currency, uint priceFloor, uint priceCap) = Put(put).attributes();\n', '        (, , dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, 0, volPut, undMax, curMax);\n', '    }\n', '    function mintPut_(address payable sender, address underlying, address currency, uint priceFloor, uint priceCap, int volPut, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', "        require(msg.sender == puts[underlying][currency][priceFloor][priceCap], 'Only Put');\n", '        (, , dUnd, dCur) = _swap(sender, underlying, currency, priceFloor, priceCap, 0, volPut, undMax, curMax);\n', '    }\n', '\n', '    function burn4(address underlying, address currency, uint priceFloor, uint priceCap, int volCall, int volPut, int undMax, int curMax) public payable returns (address call, address put, int dUnd, int dCur) {\n', '        return swap(underlying, currency, priceFloor, priceCap, volCall, volPut, undMax, curMax);\n', '    }\n', '    function burn(address callOrPut, int volCall, int volPut, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        (address underlying, address currency, uint priceFloor, uint priceCap) = Call(callOrPut).attributes();\n', '        (, , dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, volCall, volPut, undMax, curMax);\n', '    }\n', '\n', '    function burnCall4(address underlying, address currency, uint priceFloor, uint priceCap, int volCall, int undMax, int curMax) public payable returns (address call, int dUnd, int dCur) {\n', '        (call, , dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, volCall, 0, undMax, curMax);\n', '    }\n', '    function burnCall(address call, int volCall, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        (address underlying, address currency, uint priceFloor, uint priceCap) = Call(call).attributes();\n', '        (, , dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, volCall, undMax, curMax, curMax);\n', '    }\n', '    function burnCall_(address payable sender, address underlying, address currency, uint priceFloor, uint priceCap, int volCall, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', "        require(msg.sender == calls[underlying][currency][priceFloor][priceCap], 'Only Call');\n", '        (, , dUnd, dCur) = _swap(sender, underlying, currency, priceFloor, priceCap, volCall, undMax, curMax, curMax);\n', '    }\n', '\n', '    function burnPut4(address underlying, address currency, uint priceFloor, uint priceCap, int volPut, int undMax, int curMax) public payable returns (address put, int dUnd, int dCur) {\n', '        (, put, dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, 0, volPut, undMax, curMax);\n', '    }\n', '    function burnPut(address put, int volPut, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        (address underlying, address currency, uint priceFloor, uint priceCap) = Put(put).attributes();\n', '        (, , dUnd, dCur) = swap(underlying, currency, priceFloor, priceCap, 0, volPut, undMax, curMax);\n', '    }\n', '    function burnPut_(address payable sender, address underlying, address currency, uint priceFloor, uint priceCap, int volPut, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', "        require(msg.sender == puts[underlying][currency][priceFloor][priceCap], 'Only Put');\n", '        (, , dUnd, dCur) = _swap(sender, underlying, currency, priceFloor, priceCap, 0, volPut, undMax, curMax);\n', '    }\n', '\n', '    function calc(uint priceFloor, uint priceCap, uint totalCall, uint totalPut) public pure returns (uint totalUnd, uint totalCur) {\n', '        if(totalCall == 0 && totalPut == 0)\n', '            return (0, 0);\n', '        uint temp = totalCall.mul(totalPut).div(totalCall.add(totalPut)).mul(priceCap.sub(priceFloor)).div(1e18).mul(2);\n', '        totalUnd = temp.mul(totalCall).div(totalCall.mul(priceFloor).add(totalPut.mul(priceCap)).div(1e18));\n', '        totalCur = temp.mul(totalPut).div(totalCall.add(totalPut));\n', '    }\n', '    \n', '    function calcDelta(uint priceFloor, uint priceCap, uint totalCall, uint totalPut, int dCall, int dPut) public pure returns (int dUnd, int dCur, uint totalUnd, uint totalCur) {\n', '        (uint oldUnd, uint oldCur) = calc(priceFloor, priceCap, totalCall, totalPut);\n', '        (totalUnd, totalCur) = calc(priceFloor, priceCap, totalCall.add(dCall), totalPut.add(dPut));\n', '        dUnd = totalUnd.sub_(oldUnd);\n', '        dCur = totalCur.sub_(oldCur);\n', '    }\n', '\n', '    function calcDeltaWithFeeAndSlippage(uint priceFloor, uint priceCap, uint totalCall, uint totalPut, int dCall, int dPut, uint slippage) public view returns (int undMax, int curMax, uint totalUnd, uint totalCur) {\n', '        (undMax, curMax, totalUnd, totalCur) = calcDelta(priceFloor, priceCap, totalCall, totalPut, dCall, dPut);\n', '        undMax = SafeMath.add_(undMax, Math.abs(undMax).mul(feeRate.add(slippage)).div(1e18));\n', '        curMax = SafeMath.add_(curMax, Math.abs(curMax).mul(feeRate.add(slippage)).div(1e18));\n', '    }\n', '\n', '    //function calcDelta(uint priceFloor, uint priceCap, uint totalCall, uint totalPut, uint incCall, uint incPut, uint decCall, uint decPut) public pure returns (uint incUnd, uint incCur, uint decUnd, uint decCur, uint totalUnd, uint totalCur) {\n', '    //    (decUnd, decCur) = calc(priceFloor, priceCap, totalCall, totalPut);     // share decUnd, decCur instead of oldTotalUnd, oldTotalCur to avoid stack too deep errors\n', '    //    totalCall = totalCall.add(incCall).sub(decCall);\n', '    //    totalPut = totalPut.add(incPut).sub(decPut);\n', '    //    (totalUnd, totalCur) = calc(priceFloor, priceCap, totalCall, totalPut);\n', '    //    if(totalUnd > decUnd) {\n', '    //        incUnd = totalUnd.sub(decUnd);\n', '    //        decUnd = 0;\n', '    //    } else\n', '    //        decUnd = decUnd.sub(totalUnd);\n', '    //    if(totalCur > decCur) {\n', '    //        incCur = totalCur.sub(decCur);\n', '    //        decCur = 0;\n', '    //    } else\n', '    //        decCur = decCur.sub(totalCur);\n', '    //}\n', '\n', '    function priceValue(uint priceFloor, uint priceCap, uint totalCall, uint totalPut) public pure returns (uint priceUnderlying, uint valueReserve) {\n', '        priceUnderlying = (priceFloor.mul(totalCall).add(priceCap.mul(totalPut))).div(totalCall.add(totalPut));\n', '        valueReserve = priceUnderlying.sub(priceFloor).mul(totalCall).add(priceCap.sub(priceUnderlying).mul(totalPut)).div(1e18);\n', '    }\n', '    \n', '    function priceValue4(address underlying, address currency, uint priceFloor, uint priceCap) public view returns (uint priceUnderlying, uint valueReserve) {\n', '        address call = calls[underlying][currency][priceFloor][priceCap];\n', '        address put  = puts [underlying][currency][priceFloor][priceCap];\n', '        if(put == address(0))                                                                      // single check is sufficient\n', '            return (0, 0);\n', '        return priceValue(priceFloor, priceCap, Call(call).totalSupply(), Put(put).totalSupply());\n', '    }\n', '    \n', '    function priceValue1(address callOrPut) public view returns (uint priceUnderlying, uint valueReserve) {\n', '        (address underlying, address currency, uint priceFloor, uint priceCap) = Call(callOrPut).attributes();\n', '        return priceValue4(underlying, currency, priceFloor, priceCap);\n', '    }\n', '    \n', '    function priceTo18(uint _price, uint8 underlyingDecimals, uint8 currencyDecimals) public pure returns (uint) {\n', '        return _price.mul(10 ** uint256(underlyingDecimals)).div(10 ** uint256(currencyDecimals));\n', '    }\n', '    function priceTo18a(uint _price, address underlying, address currency) public view returns (uint) {\n', '        return priceTo18(_price, ERC20UpgradeSafe(underlying).decimals(), ERC20UpgradeSafe(currency).decimals());\n', '    }\n', '    \n', '    function priceFrom18(uint price18, uint8 underlyingDecimals, uint8 currencyDecimals) public pure returns (uint) {\n', '        return price18.mul(10 ** uint256(currencyDecimals)).div(10 ** uint256(underlyingDecimals));\n', '    }\n', '    function priceFrom18a(uint price18, address underlying, address currency) public view returns (uint) {\n', '        return priceFrom18(price18, ERC20UpgradeSafe(underlying).decimals(), ERC20UpgradeSafe(currency).decimals());\n', '    }\n', '}\n', '\n', '\n', 'contract Call is ERC20UpgradeSafe {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '    \n', '    address public factory;\n', '    address public underlying;\n', '    address public currency;\n', '    uint public priceFloor;\n', '    uint public priceCap;\n', '\n', '    function __Call_init(address _underlying, address _currency, uint _priceFloor, uint _priceCap) external initializer {\n', '        (string memory name, string memory symbol) = spellNameAndSymbol(_underlying, _currency, _priceFloor, _priceCap);\n', '        __ERC20_init(name, symbol);\n', '        _setupDecimals(ERC20UpgradeSafe(_underlying).decimals());\n', '\n', '        factory = _msgSender();\n', '        underlying = _underlying;\n', '        currency = _currency;\n', '        priceFloor = _priceFloor;\n', '        priceCap = _priceCap;\n', '    }\n', '    \n', '    function spellNameAndSymbol(address _underlying, address _currency, uint _priceFloor, uint _priceCap) public view returns (string memory name, string memory symbol) {\n', "        //return ('AntiMatter.Finance ETH Perpetual Call Option Floor $1000 Cap $2000', '+ETH(1000$2000)');\n", "        return('AntiMatter.Finance Perpetual Call Token', 'Call');\n", '    }\n', '\n', '    function setNameAndSymbol(string memory name, string memory symbol) external {\n', '        require(_msgSender() == Factory(factory).governor());\n', '        _name = name;\n', '        _symbol = symbol;\n', '    }\n', '\n', '    modifier onlyFactory {\n', "        require(_msgSender() == factory, 'Only Factory');\n", '        _;\n', '    }\n', '    \n', '    function withdraw_(address to, uint volume) external onlyFactory {\n', '        IERC20(underlying).safeTransfer(to, volume);\n', '    }\n', '\n', '    function mint_(address _to, uint volume) external onlyFactory {\n', '        _mint(_to, volume);\n', '    }\n', '    \n', '    function burn_(address _from, uint volume) external onlyFactory {\n', '        _burn(_from, volume);\n', '    }\n', '    \n', '    function mint(int volume, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        return Factory(factory).mintCall_{value: msg.value}(_msgSender(), underlying, currency, priceFloor, priceCap, volume, undMax, curMax);\n', '    }\n', '    \n', '    function burn(int volume, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        return Factory(factory).burnCall_{value: msg.value}(_msgSender(), underlying, currency, priceFloor, priceCap, volume, undMax, curMax);\n', '    }\n', '    function burnAll(int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        return Factory(factory).burnCall_{value: msg.value}(_msgSender(), underlying, currency, priceFloor, priceCap, int(balanceOf(_msgSender())), undMax, curMax);\n', '    }\n', '    \n', '    function attributes() public view returns (address _underlying, address _currency, uint _priceFloor, uint _priceCap) {\n', '        return (underlying, currency, priceFloor, priceCap);\n', '    }\n', '    \n', '    function priceValue() public view returns (uint priceUnderlying, uint valueReserve) {\n', '        return Factory(factory).priceValue1(address(this));\n', '    }\n', '}\n', '\n', 'contract Put is ERC20UpgradeSafe, Constants {\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '    \n', '    address public factory;\n', '    address public underlying;\n', '    address public currency;\n', '    uint public priceFloor;\n', '    uint public priceCap;\n', '\n', '    function __Put_init(address _underlying, address _currency, uint _priceFloor, uint _priceCap) external initializer {\n', '        (string memory name, string memory symbol) = spellNameAndSymbol(_underlying, _currency, _priceFloor, _priceCap);\n', '        __ERC20_init(name, symbol);\n', '        _setupDecimals(ERC20UpgradeSafe(_underlying).decimals());\n', '\n', '        factory = _msgSender();\n', '        underlying = _underlying;\n', '        currency = _currency;\n', '        priceFloor = _priceFloor;\n', '        priceCap = _priceCap;\n', '    }\n', '\n', '    function spellNameAndSymbol(address _underlying, address _currency, uint _priceFloor, uint _priceCap) public view returns (string memory name, string memory symbol) {\n', "        //return ('AntiMatter.Finance ETH Perpetual Put Option Floor $1000 Cap $2000', '-ETH(1000$2000)');\n", "        return('AntiMatter.Finance Perpetual Put Token', 'Put');\n", '    }\n', '\n', '    function setNameAndSymbol(string memory name, string memory symbol) external {\n', '        require(_msgSender() == Factory(factory).governor());\n', '        _name = name;\n', '        _symbol = symbol;\n', '    }\n', '\n', '    modifier onlyFactory {\n', "        require(_msgSender() == factory, 'Only Factory');\n", '        _;\n', '    }\n', '    \n', '    function withdraw_(address to, uint volume) external onlyFactory {\n', '        IERC20(currency).safeTransfer(to, volume);\n', '    }\n', '\n', '    function mint_(address _to, uint volume) external onlyFactory {\n', '        _mint(_to, volume);\n', '    }\n', '    \n', '    function burn_(address _from, uint volume) external onlyFactory {\n', '        _burn(_from, volume);\n', '    }\n', '    \n', '    function mint(int volume, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        return Factory(factory).mintPut_{value: msg.value}(_msgSender(), underlying, currency, priceFloor, priceCap, volume, undMax, curMax);\n', '    }\n', '    \n', '    function burn(int volume, int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        return Factory(factory).burnPut_{value: msg.value}(_msgSender(), underlying, currency, priceFloor, priceCap, volume, undMax, curMax);\n', '    }\n', '    function burnAll(int undMax, int curMax) external payable returns (int dUnd, int dCur) {\n', '        return Factory(factory).burnPut_{value: msg.value}(_msgSender(), underlying, currency, priceFloor, priceCap, int(balanceOf(_msgSender())), undMax, curMax);\n', '    }\n', '    \n', '    function attributes() public view returns (address _underlying, address _currency, uint _priceFloor, uint _priceCap) {\n', '        return (underlying, currency, priceFloor, priceCap);\n', '    }\n', '    \n', '    function priceValue() public view returns (uint priceUnderlying, uint valueReserve) {\n', '        return Factory(factory).priceValue1(address(this));\n', '    }\n', '}']