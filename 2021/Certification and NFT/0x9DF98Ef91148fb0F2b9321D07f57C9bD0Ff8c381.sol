['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-17\n', '*/\n', '\n', '// File: contracts/interface/ICoFiXV2DAO.sol\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface ICoFiXV2DAO {\n', '\n', '    function setGovernance(address gov) external;\n', '    function start() external; \n', '\n', '    // function addETHReward() external payable; \n', '\n', '    event FlagSet(address gov, uint256 flag);\n', '    event CoFiBurn(address gov, uint256 amount);\n', '}\n', '// File: contracts/lib/TransferHelper.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/interface/IWETH.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '    function balanceOf(address account) external view returns (uint);\n', '}\n', '\n', '// File: contracts/interface/ICoFiXV2Controller.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface ICoFiXV2Controller {\n', '\n', '    event NewK(address token, uint256 K, uint256 sigma, uint256 T, uint256 ethAmount, uint256 erc20Amount, uint256 blockNum);\n', '    event NewGovernance(address _new);\n', '    event NewOracle(address _priceOracle);\n', '    event NewKTable(address _kTable);\n', '    event NewTimespan(uint256 _timeSpan);\n', '    event NewKRefreshInterval(uint256 _interval);\n', '    event NewKLimit(int128 maxK0);\n', '    event NewGamma(int128 _gamma);\n', '    event NewTheta(address token, uint32 theta);\n', '    event NewK(address token, uint32 k);\n', '    event NewCGamma(address token, uint32 gamma);\n', '\n', '    function addCaller(address caller) external;\n', '\n', '    function setCGamma(address token, uint32 gamma) external;\n', '\n', '    function queryOracle(address token, uint8 op, bytes memory data) external payable returns (uint256 k, uint256 ethAmount, uint256 erc20Amount, uint256 blockNum, uint256 theta);\n', '\n', '    function getKInfo(address token) external view returns (uint32 k, uint32 updatedAt, uint32 theta);\n', '\n', '    function getLatestPriceAndAvgVola(address token) external payable returns (uint256, uint256, uint256, uint256);\n', '}\n', '// File: contracts/interface/ICoFiXV2Factory.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface ICoFiXV2Factory {\n', '    // All pairs: {ETH <-> ERC20 Token}\n', '    event PairCreated(address indexed token, address pair, uint256);\n', '    event NewGovernance(address _new);\n', '    event NewController(address _new);\n', '    event NewFeeReceiver(address _new);\n', '    event NewFeeVaultForLP(address token, address feeVault);\n', '    event NewVaultForLP(address _new);\n', '    event NewVaultForTrader(address _new);\n', '    event NewVaultForCNode(address _new);\n', '    event NewDAO(address _new);\n', '\n', '    /// @dev Create a new token pair for trading\n', '    /// @param  token the address of token to trade\n', '    /// @param  initToken0Amount the initial asset ratio (initToken0Amount:initToken1Amount)\n', '    /// @param  initToken1Amount the initial asset ratio (initToken0Amount:initToken1Amount)\n', '    /// @return pair the address of new token pair\n', '    function createPair(\n', '        address token,\n', '\t    uint256 initToken0Amount,\n', '        uint256 initToken1Amount\n', '        )\n', '        external\n', '        returns (address pair);\n', '\n', '    function getPair(address token) external view returns (address pair);\n', '    function allPairs(uint256) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint256);\n', '\n', '    function getTradeMiningStatus(address token) external view returns (bool status);\n', '    function setTradeMiningStatus(address token, bool status) external;\n', '    function getFeeVaultForLP(address token) external view returns (address feeVault); // for LPs\n', '    function setFeeVaultForLP(address token, address feeVault) external;\n', '\n', '    function setGovernance(address _new) external;\n', '    function setController(address _new) external;\n', '    function setFeeReceiver(address _new) external;\n', '    function setVaultForLP(address _new) external;\n', '    function setVaultForTrader(address _new) external;\n', '    function setVaultForCNode(address _new) external;\n', '    function setDAO(address _new) external;\n', '    function getController() external view returns (address controller);\n', '    function getFeeReceiver() external view returns (address feeReceiver); // For CoFi Holders\n', '    function getVaultForLP() external view returns (address vaultForLP);\n', '    function getVaultForTrader() external view returns (address vaultForTrader);\n', '    function getVaultForCNode() external view returns (address vaultForCNode);\n', '    function getDAO() external view returns (address dao);\n', '}\n', '\n', '// File: contracts/interface/ICoFiXERC20.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface ICoFiXERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    // function name() external pure returns (string memory);\n', '    // function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', '// File: contracts/CoFiXERC20.sol\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// ERC20 token implementation, inherited by CoFiXPair contract, no owner or governance\n', 'contract CoFiXERC20 is ICoFiXERC20 {\n', '    using SafeMath for uint;\n', '\n', "    string public constant nameForDomain = 'CoFiX Pool Token';\n", '    uint8 public override constant decimals = 18;\n', '    uint  public override totalSupply;\n', '    mapping(address => uint) public override balanceOf;\n', '    mapping(address => mapping(address => uint)) public override allowance;\n', '\n', '    bytes32 public override DOMAIN_SEPARATOR;\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public override constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '    mapping(address => uint) public override nonces;\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    constructor() public {\n', '        uint chainId;\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', "                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n", '                keccak256(bytes(nameForDomain)),\n', "                keccak256(bytes('1')),\n", '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    function _mint(address to, uint value) internal {\n', '        totalSupply = totalSupply.add(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(address(0), to, value);\n', '    }\n', '\n', '    function _burn(address from, uint value) internal {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Transfer(from, address(0), value);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint value) private {\n', '        allowance[owner][spender] = value;\n', '        emit Approval(owner, spender, value);\n', '    }\n', '\n', '    function _transfer(address from, address to, uint value) private {\n', '        balanceOf[from] = balanceOf[from].sub(value);\n', '        balanceOf[to] = balanceOf[to].add(value);\n', '        emit Transfer(from, to, value);\n', '    }\n', '\n', '    function approve(address spender, uint value) external override returns (bool) {\n', '        _approve(msg.sender, spender, value);\n', '        return true;\n', '    }\n', '\n', '    function transfer(address to, uint value) external override returns (bool) {\n', '        _transfer(msg.sender, to, value);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address from, address to, uint value) external override returns (bool) {\n', '        if (allowance[from][msg.sender] != uint(-1)) {\n', '            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n', '        }\n', '        _transfer(from, to, value);\n', '        return true;\n', '    }\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external override {\n', "        require(deadline >= block.timestamp, 'CERC20: EXPIRED');\n", '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', "                '\\x19\\x01',\n", '                DOMAIN_SEPARATOR,\n', '                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n', '            )\n', '        );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', "        require(recoveredAddress != address(0) && recoveredAddress == owner, 'CERC20: INVALID_SIGNATURE');\n", '        _approve(owner, spender, value);\n', '    }\n', '}\n', '\n', '// File: contracts/interface/ICoFiXV2Pair.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface ICoFiXV2Pair is ICoFiXERC20 {\n', '\n', '    struct OraclePrice {\n', '        uint256 ethAmount;\n', '        uint256 erc20Amount;\n', '        uint256 blockNum;\n', '        uint256 K;\n', '        uint256 theta;\n', '    }\n', '\n', '    // All pairs: {ETH <-> ERC20 Token}\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, address outToken, uint outAmount, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amountIn,\n', '        uint amountOut,\n', '        address outToken,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\n', '\n', '    function mint(address to, uint amountETH, uint amountToken) external payable returns (uint liquidity, uint oracleFeeChange);\n', '    function burn(address tokenTo, address ethTo) external payable returns (uint amountTokenOut, uint amountETHOut, uint oracleFeeChange);\n', '    function swapWithExact(address outToken, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[5] memory tradeInfo);\n', '    // function swapForExact(address outToken, uint amountOutExact, address to) external payable returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[4] memory tradeInfo);\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address, string memory, string memory, uint256, uint256) external;\n', '\n', '    /// @dev get Net Asset Value Per Share\n', '    /// @param  ethAmount ETH side of Oracle price {ETH <-> ERC20 Token}\n', '    /// @param  erc20Amount Token side of Oracle price {ETH <-> ERC20 Token}\n', '    /// @return navps The Net Asset Value Per Share (liquidity) represents\n', '    function getNAVPerShare(uint256 ethAmount, uint256 erc20Amount) external view returns (uint256 navps);\n', '\n', '    /// @dev get initial asset ratio\n', '    /// @return _initToken0Amount Token0(ETH) side of initial asset ratio {ETH <-> ERC20 Token}\n', '    /// @return _initToken1Amount Token1(ERC20) side of initial asset ratio {ETH <-> ERC20 Token}\n', '    function getInitialAssetRatio() external view returns (uint256 _initToken0Amount, uint256 _initToken1Amount);\n', '}\n', '\n', '// File: contracts/CoFiXV2Pair.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// Pair contract for each trading pair, storing assets and handling settlement\n', '// No owner or governance\n', 'contract CoFiXV2Pair is ICoFiXV2Pair, CoFiXERC20 {\n', '    using SafeMath for uint;\n', '\n', '    enum CoFiX_OP { QUERY, MINT, BURN, SWAP_WITH_EXACT, SWAP_FOR_EXACT } // operations in CoFiX\n', '\n', "    uint public override constant MINIMUM_LIQUIDITY = 10**9; // it's negligible because we calc liquidity in ETH\n", '    bytes4 private constant SELECTOR = bytes4(keccak256(bytes("transfer(address,uint256)")));\n', '\n', '    uint256 constant public K_BASE = 1E8; // K\n', '    uint256 constant public NAVPS_BASE = 1E18; // NAVPS (Net Asset Value Per Share), need accuracy\n', '    uint256 constant public THETA_BASE = 1E8; // theta\n', '\n', '    string public name;\n', '    string public symbol;\n', '\n', '    address public override immutable factory;\n', '    address public override token0; // WETH token\n', '    address public override token1; // any ERC20 token\n', '\n', '    uint112 private reserve0;           // uses single storage slot, accessible via getReserves\n', '    uint112 private reserve1;           // uses single storage slot, accessible via getReserves\n', '\n', '    uint256 public initToken1Amount;\n', '    uint256 public initToken0Amount;\n', '\n', '    uint private unlocked = 1;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, address outToken, uint outAmount, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amountIn,\n', '        uint amountOut,\n', '        address outToken,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    modifier lock() {\n', '        require(unlocked == 1, "CPair: LOCKED");\n', '        unlocked = 0;\n', '        _;\n', '        unlocked = 1;\n', '    }\n', '\n', '    constructor() public {\n', '        factory = msg.sender;\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    // called once by the factory at time of deployment\n', '    function initialize(address _token0, address _token1, string memory _name, string memory _symbol, uint256 _initToken0Amount, uint256 _initToken1Amount) external override {\n', '        require(msg.sender == factory, "CPair: FORBIDDEN"); // sufficient check\n', '        token0 = _token0;\n', '        token1 = _token1;\n', '        name = _name;\n', '        symbol = _symbol;\n', '        initToken1Amount = _initToken1Amount;\n', '        initToken0Amount = _initToken0Amount;\n', '    }\n', '\n', '    function getInitialAssetRatio() public override view returns (uint256 _initToken0Amount, uint256 _initToken1Amount) {\n', '        _initToken1Amount = initToken1Amount;\n', '        _initToken0Amount = initToken0Amount;\n', '    }\n', '\n', '    function getReserves() public override view returns (uint112 _reserve0, uint112 _reserve1) {\n', '        _reserve0 = reserve0;\n', '        _reserve1 = reserve1;\n', '    }\n', '\n', '    function _safeTransfer(address token, address to, uint value) private {\n', '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "CPair: TRANSFER_FAILED");\n', '    }\n', '\n', '    // update reserves\n', '    function _update(uint balance0, uint balance1) private {\n', '        require(balance0 <= uint112(-1) && balance1 <= uint112(-1), "CPair: OVERFLOW");\n', '        reserve0 = uint112(balance0);\n', '        reserve1 = uint112(balance1);\n', '        emit Sync(reserve0, reserve1);\n', '    }\n', '\n', '    // this low-level function should be called from a contract which performs important safety checks\n', '    function mint(address to, uint amountETH, uint amountToken) external payable override lock returns (uint liquidity, uint oracleFeeChange) {\n', '        address _token0 = token0;                                // gas savings\n', '        address _token1 = token1;                                // gas savings\n', '        (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n', '        uint balance0 = IERC20(_token0).balanceOf(address(this));\n', '        uint balance1 = IERC20(_token1).balanceOf(address(this));\n', '        uint amount0 = balance0.sub(_reserve0);\n', '        uint amount1 = balance1.sub(_reserve1);\n', '\n', '        require(amountETH <= amount0 && amountToken <= amount1, "CPair: illegal ammount");\n', '        \n', '        amount0 = amountETH;\n', '        amount1 = amountToken;\n', '        require(amount0.mul(initToken1Amount) == amount1.mul(initToken0Amount), "CPair: invalid asset ratio");\n', '        \n', '        uint256 _ethBalanceBefore = address(this).balance;\n', '        { // scope for ethAmount/erc20Amount/blockNum to avoid stack too deep error\n', '            bytes memory data = abi.encode(msg.sender, to, amount0, amount1);\n', '            // query price\n', '            OraclePrice memory _op;\n', '            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.MINT, data);\n', '            uint256 navps = calcNAVPerShare(_reserve0, _reserve1, _op.ethAmount, _op.erc20Amount);\n', '            if (totalSupply == 0) {\n', '                liquidity = calcLiquidity(amount0, navps).sub(MINIMUM_LIQUIDITY);\n', '                _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\n', '            } else {\n', '                liquidity = calcLiquidity(amount0, navps);\n', '            }\n', '        }\n', '        oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\n', '\n', '        require(liquidity > 0, "CPair: SHORT_LIQUIDITY_MINTED");\n', '        _mint(to, liquidity);\n', '\n', '        _update(balance0, balance1);\n', '        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n', '\n', '        emit Mint(msg.sender, amount0, amount1);\n', '    }\n', '\n', '    // this low-level function should be called from a contract which performs important safety checks\n', '    function burn(address tokenTo, address ethTo) external payable override lock returns (uint amountTokenOut, uint amountEthOut, uint oracleFeeChange) {\n', '        address _token0 = token0;                                // gas savings\n', '        address _token1 = token1;                                // gas savings\n', '        uint balance0 = IERC20(_token0).balanceOf(address(this));\n', '        uint balance1 = IERC20(_token1).balanceOf(address(this));\n', '        uint liquidity = balanceOf[address(this)];\n', '\n', '        uint256 _ethBalanceBefore = address(this).balance;\n', '        // uint256 fee;\n', '        {\n', '            bytes memory data = abi.encode(msg.sender, liquidity);\n', '            // query price\n', '            OraclePrice memory _op;\n', '            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.BURN, data);\n', '\n', '            (amountTokenOut, amountEthOut) = calcOutTokenAndETHForBurn(liquidity, _op); // navps calculated\n', '        }\n', '        oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\n', '\n', '        require(amountTokenOut > 0 && amountEthOut > 0, "CPair: SHORT_LIQUIDITY_BURNED");\n', '\n', '        _burn(address(this), liquidity);\n', '        _safeTransfer(_token1, tokenTo, amountTokenOut);\n', '        _safeTransfer(_token0, ethTo, amountEthOut);\n', '\n', '        balance0 = IERC20(_token0).balanceOf(address(this));\n', '        balance1 = IERC20(_token1).balanceOf(address(this));\n', '\n', '        _update(balance0, balance1);\n', '        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n', '\n', '        emit Burn(msg.sender, _token0, amountEthOut, ethTo);\n', '        emit Burn(msg.sender, _token1, amountTokenOut, tokenTo);\n', '    }\n', '\n', '    // this low-level function should be called from a contract which performs important safety checks\n', '    function swapWithExact(address outToken, address to)\n', '        external\n', '        payable override lock\n', '        returns (uint amountIn, uint amountOut, uint oracleFeeChange, uint256[5] memory tradeInfo)\n', '    {\n', '        // tradeInfo[0]: thetaFee, tradeInfo[1]: ethAmount, tradeInfo[2]: erc20Amount\n', '        address _token0 = token0;\n', '        address _token1 = token1;\n', '        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\n', '        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\n', '\n', '        // uint256 fee;\n', '        { // scope for ethAmount/erc20Amount/blockNum to avoid stack too deep error\n', '            uint256 _ethBalanceBefore = address(this).balance;\n', '            (uint112 _reserve0, uint112 _reserve1) = getReserves(); // gas savings\n', '\n', '            // calc amountIn\n', '            if (outToken == _token1) {\n', '                amountIn = balance0.sub(_reserve0);\n', '            } else if (outToken == _token0) {\n', '                amountIn = balance1.sub(_reserve1);\n', '            } else {\n', '                revert("CPair: wrong outToken");\n', '            }\n', '            require(amountIn > 0, "CPair: wrong amountIn");\n', '            bytes memory data = abi.encode(msg.sender, outToken, to, amountIn);\n', '            // query price\n', '            OraclePrice memory _op;\n', '            (_op.K, _op.ethAmount, _op.erc20Amount, _op.blockNum, _op.theta) = _queryOracle(_token1, CoFiX_OP.SWAP_WITH_EXACT, data);\n', '            \n', '            if (outToken == _token1) {\n', '                (amountOut, tradeInfo[0]) = calcOutToken1(amountIn, _op);\n', '            } else if (outToken == _token0) {\n', '                (amountOut, tradeInfo[0]) = calcOutToken0(amountIn, _op);\n', '            }\n', '            oracleFeeChange = msg.value.sub(_ethBalanceBefore.sub(address(this).balance));\n', '            tradeInfo[1] = _op.ethAmount;\n', '            tradeInfo[2] = _op.erc20Amount;\n', '        }\n', '        \n', '        require(to != _token0 && to != _token1, "CPair: INVALID_TO");\n', '\n', '        _safeTransfer(outToken, to, amountOut); // optimistically transfer tokens\n', '        if (tradeInfo[0] > 0) {\n', '            if (ICoFiXV2Factory(factory).getTradeMiningStatus(_token1)) {\n', '                // only transfer fee to protocol feeReceiver when trade mining is enabled for this trading pair\n', '                _safeSendFeeForDAO(_token0, tradeInfo[0]);\n', '            } else {\n', '                _safeSendFeeForLP(_token0, _token1, tradeInfo[0]);\n', "                tradeInfo[0] = 0; // so router won't go into the trade mining logic (reduce one more call gas cost)\n", '            }\n', '        }\n', '        balance0 = IERC20(_token0).balanceOf(address(this));\n', '        balance1 = IERC20(_token1).balanceOf(address(this));\n', '\n', '        _update(balance0, balance1);\n', '        if (oracleFeeChange > 0) TransferHelper.safeTransferETH(msg.sender, oracleFeeChange);\n', '\n', '        emit Swap(msg.sender, amountIn, amountOut, outToken, to);\n', '    }\n', '\n', '    // force balances to match reserves\n', '    function skim(address to) external override lock {\n', '        address _token0 = token0; // gas savings\n', '        address _token1 = token1; // gas savings\n', '        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));\n', '        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));\n', '    }\n', '\n', '    // force reserves to match balances\n', '    function sync() external override lock {\n', '        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)));\n', '    }\n', '\n', '    // calc Net Asset Value Per Share (no K)\n', '    // use it in this contract, for optimized gas usage\n', '    function calcNAVPerShare(uint256 balance0, uint256 balance1, uint256 ethAmount, uint256 erc20Amount) public view returns (uint256 navps) {\n', '        uint _totalSupply = totalSupply;\n', '        if (_totalSupply == 0) {\n', '            navps = NAVPS_BASE;\n', '        } else {\n', '            /*\n', '            NV  = \\frac{E_t + U_t/P_t}{(1 + \\frac{k_0}{P_t})*F_t}\\\\\\\\\n', '                = \\frac{E_t + U_t * \\frac{ethAmount}{erc20Amount}}{(1 + \\frac{initToken1Amount}{initToken0Amount} * \\frac{ethAmount}{erc20Amount})*F_t}\\\\\\\\\n', '                = \\frac{E_t * erc20Amount + U_t * ethAmount}{(erc20Amount + \\frac{initToken1Amount * ethAmount}{initToken0Amount}) * F_t}\\\\\\\\\n', '                = \\frac{E_t * erc20Amount * initToken0Amount + U_t * ethAmount * initToken0Amount}{( erc20Amount * initToken0Amount + initToken1Amount * ethAmount) * F_t} \\\\\\\\\n', '                = \\frac{balance0 * erc20Amount * initToken0Amount + balance1 * ethAmount * initToken0Amount}{(erc20Amount * initToken0Amount + initToken1Amount * ethAmount) * totalSupply}\n', '             */\n', '            uint256 balance0MulErc20AmountMulInitToken0Amount = balance0.mul(erc20Amount).mul(initToken0Amount);\n', '            uint256 balance1MulEthAmountMulInitToken0Amount = balance1.mul(ethAmount).mul(initToken0Amount);\n', '            uint256 initToken1AmountMulEthAmount = initToken1Amount.mul(ethAmount);\n', '            uint256 initToken0AmountMulErc20Amount = erc20Amount.mul(initToken0Amount);\n', '\n', '            navps = (balance0MulErc20AmountMulInitToken0Amount.add(balance1MulEthAmountMulInitToken0Amount))\n', '                        .div(_totalSupply).mul(NAVPS_BASE)\n', '                        .div(initToken1AmountMulEthAmount.add(initToken0AmountMulErc20Amount));\n', '        }\n', '    }\n', '\n', '    // use it in this contract, for optimized gas usage\n', '    function calcLiquidity(uint256 amount0, uint256 navps) public pure returns (uint256 liquidity) {\n', '        liquidity = amount0.mul(NAVPS_BASE).div(navps);\n', '    }\n', '\n', '    // get Net Asset Value Per Share for mint\n', '    // only for read, could cost more gas if use it directly in contract\n', '    function getNAVPerShareForMint(OraclePrice memory _op) public view returns (uint256 navps) {\n', '        return calcNAVPerShare(reserve0, reserve1, _op.ethAmount, _op.erc20Amount);\n', '    }\n', '\n', '    // get Net Asset Value Per Share for burn\n', '    // only for read, could cost more gas if use it directly in contract\n', '    function getNAVPerShareForBurn(OraclePrice memory _op) external view returns (uint256 navps) {\n', '        return calcNAVPerShare(reserve0, reserve1, _op.ethAmount, _op.erc20Amount);\n', '    }\n', '\n', '    // get Net Asset Value Per Share\n', '    // only for read, could cost more gas if use it directly in contract\n', '    function getNAVPerShare(uint256 ethAmount, uint256 erc20Amount) external override view returns (uint256 navps) {\n', '        return calcNAVPerShare(reserve0, reserve1, ethAmount, erc20Amount);\n', '    }\n', '\n', '    // get estimated liquidity amount (it represents the amount of pool tokens will be minted if someone provide liquidity to the pool)\n', '    // only for read, could cost more gas if use it directly in contract\n', '    function getLiquidity(uint256 amount0, OraclePrice memory _op) external view returns (uint256 liquidity) {\n', '        uint256 navps = getNAVPerShareForMint(_op);\n', '        return calcLiquidity(amount0, navps);\n', '    }\n', '\n', '    function calcOutTokenAndETHForBurn(uint256 liquidity, OraclePrice memory _op) public view returns (uint256 amountTokenOut, uint256 amountEthOut) {\n', '        // amountEthOut = liquidity * navps * (THETA_BASE - theta) / THETA_BASE\n', '        // amountTokenOut = liquidity * navps * (THETA_BASE - theta) * initToken1Amount / (initToken0Amount * THETA_BASE)\n', '        uint256 navps;\n', '        {\n', '            navps = calcNAVPerShare(reserve0, reserve1, _op.ethAmount, _op.erc20Amount);\n', '            uint256 amountEth = liquidity.mul(navps);\n', '\n', '            uint256 amountEthOutLarge = amountEth.mul(THETA_BASE.sub(_op.theta));\n', '            amountEthOut = amountEthOutLarge.div(NAVPS_BASE).div(THETA_BASE);\n', '            amountTokenOut = amountEthOutLarge.mul(initToken1Amount).div(NAVPS_BASE).div(initToken0Amount).div(THETA_BASE);\n', '            // amountTokenOut = amountEthOut.mul(initToken1Amount).div(initToken0Amount);\n', '        }\n', '\n', '        // recalc amountOut when has no enough reserve0 or reserve1 to out in initAssetRatio\n', '        {\n', '            if (amountEthOut > reserve0) {\n', '                // user first, out eth as much as possibile. And may leave over a few amounts of reserve1. \n', '                uint256 amountEthInsufficient = amountEthOut - reserve0;\n', '                uint256 amountTokenEquivalent = amountEthInsufficient.mul(_op.erc20Amount).div(_op.ethAmount);\n', '                amountTokenOut = amountTokenOut.add(amountTokenEquivalent);\n', '                if (amountTokenOut > reserve1) {\n', '                    amountTokenOut = reserve1;\n', '                }\n', '                amountEthOut = reserve0;\n', '                // amountEthOut = reserve0 - fee;    \n', '            } else if (amountTokenOut > reserve1) {\n', '                uint256 amountTokenInsufficient = amountTokenOut - reserve1;\n', '                uint256 amountEthEquivalent = amountTokenInsufficient.mul(_op.ethAmount).div(_op.erc20Amount);\n', '                amountEthOut = amountEthOut.add(amountEthEquivalent);\n', '                if (amountEthOut > reserve0) {\n', '                    amountEthOut = reserve0;\n', '                }\n', '                amountTokenOut = reserve1;\n', '            }\n', '        }   \n', '    }\n', '\n', '    // get estimated amountOut for token0 (WETH) when swapWithExact\n', '    function calcOutToken0(uint256 amountIn, OraclePrice memory _op) public pure returns (uint256 amountOut, uint256 fee) {\n', '        /*\n', "        x &= (a/P_{b}^{'})*\\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n", '          &= a / (\\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} + k)}{(k_{BASE})}) * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n', '          &= \\frac{a*ethAmount*k_{BASE}}{erc20Amount*(k_{BASE} + k)} * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n', '          &= \\frac{a*ethAmount*k_{BASE}*(THETA_{BASE} - \\theta)}{erc20Amount*(k_{BASE} + k)*THETA_{BASE}} \\\\\\\\\n', '        // amountOut = amountIn * _op.ethAmount * K_BASE * (THETA_BASE - _op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\n', '        */\n', '        amountOut = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE.sub(_op.theta)).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\n', '        if (_op.theta != 0) {\n', '            // fee = amountIn * _op.ethAmount * K_BASE * (_op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\n', '            fee = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(_op.theta).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\n', '        }\n', '        return (amountOut, fee);\n', '    }\n', '\n', '    // get estimated amountOut for token1 (ERC20 token) when swapWithExact\n', '    function calcOutToken1(uint256 amountIn, OraclePrice memory _op) public pure returns (uint256 amountOut, uint256 fee) {\n', '        /*\n', "        y &= b*P_{s}^{'}*\\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n", '          &= b * \\frac{erc20Amount}{ethAmount} * \\frac{(k_{BASE} - k)}{(k_{BASE})} * \\frac{THETA_{BASE} - \\theta}{THETA_{BASE}} \\\\\\\\\n', '          &= \\frac{b*erc20Amount*(k_{BASE} - k)*(THETA_{BASE} - \\theta)}{ethAmount*k_{BASE}*THETA_{BASE}} \\\\\\\\\n', '        // amountOut = amountIn * _op.erc20Amount * (K_BASE - _op.K) * (THETA_BASE - _op.theta) / _op.ethAmount / K_BASE / THETA_BASE;\n', '        */\n', '        amountOut = amountIn.mul(_op.erc20Amount).mul(K_BASE.sub(_op.K)).mul(THETA_BASE.sub(_op.theta)).div(_op.ethAmount).div(K_BASE).div(THETA_BASE);\n', '        if (_op.theta != 0) {\n', '            // fee = amountIn * _op.theta / THETA_BASE;\n', '            fee = amountIn.mul(_op.theta).div(THETA_BASE);\n', '        }\n', '        return (amountOut, fee);\n', '    }\n', '\n', '    // get estimate amountInNeeded for token0 (WETH) when swapForExact\n', '    function calcInNeededToken0(uint256 amountOut, OraclePrice memory _op) public pure returns (uint256 amountInNeeded, uint256 fee) {\n', '        // inverse of calcOutToken1\n', '        // amountOut = amountIn.mul(_op.erc20Amount).mul(K_BASE.sub(_op.K)).mul(THETA_BASE.sub(_op.theta)).div(_op.ethAmount).div(K_BASE).div(THETA_BASE);\n', '        amountInNeeded = amountOut.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE).div(_op.erc20Amount).div(K_BASE.sub(_op.K)).div(THETA_BASE.sub(_op.theta));\n', '        if (_op.theta != 0) {\n', '            // fee = amountIn * _op.theta / THETA_BASE;\n', '            fee = amountInNeeded.mul(_op.theta).div(THETA_BASE);\n', '        }\n', '        return (amountInNeeded, fee);\n', '    }\n', '\n', '    // get estimate amountInNeeded for token1 (ERC20 token) when swapForExact\n', '    function calcInNeededToken1(uint256 amountOut, OraclePrice memory _op) public pure returns (uint256 amountInNeeded, uint256 fee) {\n', '        // inverse of calcOutToken0\n', '        // amountOut = amountIn.mul(_op.ethAmount).mul(K_BASE).mul(THETA_BASE.sub(_op.theta)).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\n', '        amountInNeeded = amountOut.mul(_op.erc20Amount).mul(K_BASE.add(_op.K)).mul(THETA_BASE).div(_op.ethAmount).div(K_BASE).div(THETA_BASE.sub(_op.theta));\n', '        if (_op.theta != 0) {\n', '            // fee = amountIn * _op.ethAmount * K_BASE * (_op.theta) / _op.erc20Amount / (K_BASE + _op.K) / THETA_BASE;\n', '            fee = amountInNeeded.mul(_op.ethAmount).mul(K_BASE).mul(_op.theta).div(_op.erc20Amount).div(K_BASE.add(_op.K)).div(THETA_BASE);\n', '        }\n', '        return (amountInNeeded, fee);\n', '    }\n', '\n', '    function _queryOracle(address token, CoFiX_OP op, bytes memory data) internal returns (uint256, uint256, uint256, uint256, uint256) {\n', '        return ICoFiXV2Controller(ICoFiXV2Factory(factory).getController()).queryOracle{value: msg.value}(token, uint8(op), data);\n', '    }\n', '\n', '    function _safeSendFeeForDAO(address _token0, uint256 _fee) internal {\n', '        address feeReceiver = ICoFiXV2Factory(factory).getFeeReceiver();\n', '        if (feeReceiver == address(0)) {\n', '            return; // if feeReceiver not set, theta fee keeps in pair pool\n', '        }\n', '        uint256 bal = IWETH(_token0).balanceOf(address(this));\n', '        if (_fee > bal) {\n', '            _fee = bal;\n', '        }\n', '\n', '        IWETH(_token0).withdraw(_fee);\n', '        if (_fee > 0) TransferHelper.safeTransferETH(feeReceiver, _fee); // transfer fee to protocol dao for redeem Cofi\n', '        // ICoFiXV2DAO(dao).addETHReward{value: _fee}(); \n', '    }\n', '\n', '    // Safe WETH transfer function, just in case not having enough WETH. LP will earn these fees.\n', '    function _safeSendFeeForLP(address _token0, address _token1, uint256 _fee) internal {\n', '        address feeVault = ICoFiXV2Factory(factory).getFeeVaultForLP(_token1);\n', '        if (feeVault == address(0)) {\n', '            return; // if fee vault not set, theta fee keeps in pair pool\n', '        }\n', '        _safeSendFee(_token0, feeVault, _fee); // transfer fee to protocol fee reward pool for LP\n', '    }\n', '\n', '    function _safeSendFee(address _token0, address _receiver, uint256 _fee) internal {\n', '        uint256 wethBal = IERC20(_token0).balanceOf(address(this));\n', '        if (_fee > wethBal) {\n', '            _fee = wethBal;\n', '        }\n', '        if (_fee > 0) _safeTransfer(_token0, _receiver, _fee); \n', '    }\n', '}\n', '// 🦄 & CoFi Rocks']