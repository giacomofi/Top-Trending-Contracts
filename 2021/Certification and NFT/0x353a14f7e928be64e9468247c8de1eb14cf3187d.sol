['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-11\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-04\n', '*/\n', '\n', 'pragma solidity 0.5.16;\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    \n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract FUNDSZ{\n', '    \n', '    using SafeMath for uint;\n', '    \n', '    struct UserStruct {\n', '        bool isExist;\n', '        uint id;\n', '        uint referrerID;\n', '        uint orginalRefID;\n', '        uint placementSponser;\n', '        uint donated;\n', '        uint totalEarnedETH;\n', '        uint teamNetworkEarnETH;\n', '        bool blocked;\n', '        address[] personallyEnrolled;\n', '        address[] referrals;\n', '        uint membershipExpired;\n', '    }\n', '    \n', '    address payable public admin;\n', '    \n', '    uint  REFERRER_1_LEVEL_LIMIT = 4;\n', '    uint public PERIOD_LENGTH = 30 days;\n', '    uint public blockTime = 90 days;\n', '    uint public GRACE_PERIOD = 7 days;\n', '    \n', '    uint MatchingBonusUplineLimit = 5;\n', '    \n', '    uint public usdPrice;\n', '    \n', '    uint public currUserID = 0;\n', '    bool public lockStatus;\n', '    \n', '    mapping (address => UserStruct) public users;\n', '    mapping (uint => address) public userList;\n', '    mapping (uint => uint) public MEMBERSHIP_PRICE;\n', '    \n', '    mapping(address => uint) matrixCommissionBreakage;\n', '    mapping(address => uint) commissionsReceivedValue;\n', '    mapping(address => uint) adminBreakageAmount;\n', '    \n', '    event MatrixCommission(\n', '        address indexed _user,\n', '        address _level1,\n', '        address _level2,\n', '        address _level3,\n', '        address _level4,\n', '        address _level5,\n', '        address _level6,\n', '        address _level7,\n', '        address _level8,\n', '        uint _levelValue\n', '    );\n', '    event MatchingCarBonus(\n', '        address indexed _user,\n', '        address _sponser,\n', '        address[] receiver,\n', '        uint _value\n', '    );\n', '    event RefBonus(\n', '        address indexed _user,\n', '        address _sponser,\n', '        uint _value\n', '    );\n', '    event InfinityHouseBonus(\n', '        address _user,\n', '        address _upline9,\n', '        address _upline10,\n', '        address _upline11,\n', '        address _upline12,\n', '        uint _uplineAmount9To12\n', '    );\n', '    event regMemberEvent(\n', '        address indexed _user,\n', '        address indexed _referrer,\n', '        uint _value,\n', '        uint _vipID,\n', '        uint _time\n', '    );\n', '    event BuyMembershipEvent(\n', '        address indexed _user,\n', '        uint _value,\n', '        uint _vipID,\n', '        uint _time\n', '    );\n', '    \n', '    event BreakageEvent(\n', '        address indexed _user,\n', '        uint _value,\n', '        uint _time\n', '    );\n', '    \n', '    constructor() public {\n', '        admin = msg.sender;\n', '        UserStruct memory userStruct;\n', '        currUserID++;\n', '        userStruct = UserStruct({\n', '            isExist: true,\n', '            id: currUserID,\n', '            referrerID: 0,\n', '            orginalRefID: 0,\n', '            placementSponser: 0,\n', '            donated:2,\n', '            teamNetworkEarnETH:0,\n', '            totalEarnedETH: 0,\n', '            blocked:false,\n', '            personallyEnrolled : new address[](0),\n', '            referrals: new address[](0),\n', '            membershipExpired:55555555555\n', '        });\n', '        \n', '        users[admin] = userStruct;    \n', '        userList[currUserID] = admin;\n', '    \n', '        MEMBERSHIP_PRICE[1] = 10;\n', '        MEMBERSHIP_PRICE[2] = 50;\n', '    }\n', '    \n', '    modifier contractStatus(){\n', '        require(lockStatus == false,"contract locked");\n', '        _;\n', '    }\n', '    \n', '    modifier OnlyOwner(){\n', '        require(msg.sender == admin,"OnlyOwner");\n', '        _;\n', '    }\n', '    \n', '    function() external payable OnlyOwner{\n', '        \n', '    }\n', '    \n', '    \n', '    function subscription(uint _placementSponser, uint _referrerID, uint _orginalRefID, uint _usdValue) public contractStatus payable returns(bool){\n', '        require(!users[msg.sender].isExist,"User exist");\n', '        require(!isContract(msg.sender),"Invalid address");\n', '        require((_referrerID > 0) && (_referrerID <= currUserID),"Invalid referrerID");\n', '        require((_orginalRefID > 0) && (_orginalRefID <= currUserID),"Invalid referrerID");\n', '        require((_placementSponser > 0) && (_placementSponser <= currUserID),"Invalid referrerID");\n', '        require(_usdValue == 10 || (_usdValue == 50),"Invalid membership");\n', '        require(usdPrice > 0, "usdPrice must be greater than zero");\n', '        require(msg.value == usdPrice.mul(_usdValue),"Invalid value");\n', '        \n', '        UserStruct memory userStruct;\n', '        currUserID++;\n', '\n', '        userStruct = UserStruct({\n', '            isExist: true,\n', '            id: currUserID,\n', '            referrerID: _referrerID,\n', '            orginalRefID : _orginalRefID,\n', '            placementSponser : _placementSponser,\n', '            donated:0,\n', '            teamNetworkEarnETH:0,\n', '            // referralTeamNetWorkEarnings : 0,\n', '            totalEarnedETH: 0,\n', '            blocked:false,\n', '            personallyEnrolled : new address[](0),\n', '            referrals: new address[](0),\n', '            membershipExpired: now.add(PERIOD_LENGTH)\n', '        });\n', '\n', '        users[msg.sender] = userStruct;\n', '        userList[currUserID] = msg.sender;\n', '        \n', '        uint _DonateID;\n', '        \n', '        if(MEMBERSHIP_PRICE[1] == _usdValue)\n', '            _DonateID = 1;\n', '        else\n', '            _DonateID = 2;\n', '\n', '        users[msg.sender].donated = _DonateID;\n', '        users[userList[_placementSponser]].personallyEnrolled.push(msg.sender);\n', '        users[userList[_referrerID]].referrals.push(msg.sender);\n', '\n', '        address upline_8_address = matrixCommission(msg.sender,msg.value);\n', '        \n', '        referralBonus(msg.sender,msg.value);\n', '        matchingCarBonus(msg.sender);\n', '        infinityHouseBonus(upline_8_address,msg.value); \n', '        \n', '        uint breakage = msg.value.sub(commissionsReceivedValue[msg.sender]);\n', '        \n', '        require(address(uint160(admin)).send(breakage), "breakage amount transfer failed");\n', '        users[admin].totalEarnedETH = users[admin].totalEarnedETH.add(breakage);\n', '\n', '        emit regMemberEvent(msg.sender, userList[_referrerID], msg.value, _DonateID, now);\n', '        emit BreakageEvent(msg.sender, adminBreakageAmount[msg.sender].add(breakage), now);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function donate(uint _usdValue, uint _days)  public contractStatus payable returns(bool){\n', '        require(_days > 0,"_days must be greater than zero");\n', '        require(users[msg.sender].isExist,"User does not exist"); \n', '        require(!isContract(msg.sender),"Invalid address");\n', '        require((_usdValue == 10 || _usdValue == 50), "Invalid membership");\n', '        require(usdPrice > 0, "usdPrice must be greater than zero");\n', '        require(msg.value == (usdPrice.mul(_usdValue)).mul(_days),"Invalid value");\n', '        \n', '        uint _DonateID;\n', '        \n', '        if(MEMBERSHIP_PRICE[1] == _usdValue)\n', '            _DonateID = 1;\n', '        else\n', '            _DonateID = 2;\n', '        \n', '        if(users[msg.sender].donated == _DonateID)    \n', '            users[msg.sender].membershipExpired = users[msg.sender].membershipExpired.add(PERIOD_LENGTH.mul(_days));\n', '        else{\n', '            users[msg.sender].membershipExpired = now.add(PERIOD_LENGTH.mul(_days));\n', '            users[msg.sender].donated = _DonateID;\n', '        }\n', '        \n', '        \n', '        address upline_8_address = matrixCommission(msg.sender,msg.value);\n', '        \n', '        matchingCarBonus(msg.sender);\n', '        referralBonus(msg.sender,msg.value);\n', '        infinityHouseBonus(upline_8_address,msg.value);   \n', '        \n', '        uint breakage = msg.value.sub(commissionsReceivedValue[msg.sender]);\n', '        \n', '        require(address(uint160(admin)).send(breakage), "breakage amount transfer failed");\n', '        users[admin].totalEarnedETH = users[admin].totalEarnedETH.add(breakage);\n', '        \n', '        emit BuyMembershipEvent(msg.sender, msg.value, _DonateID, now);\n', '        emit BreakageEvent(msg.sender, adminBreakageAmount[msg.sender].add(breakage), now);\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function updateUSDPrice( uint _usdPrice) public OnlyOwner returns(bool){\n', '        require(_usdPrice > 0, "_usdPrice must be greater than zero");\n', '        usdPrice = _usdPrice;\n', '        return true;\n', '    }\n', '    \n', '    mapping( address => address[]) bonusEligibleUsers;\n', '    \n', '    // Matrix Commission\n', '    function matrixCommission(address _user, uint _amount) internal returns(address){\n', '        matrixCommissionBreakage[msg.sender] = 0;\n', '        commissionsReceivedValue[msg.sender] = 0;\n', '        adminBreakageAmount[msg.sender] = 0;\n', '        bonusEligibleUsers[msg.sender] = new address[](0);\n', '        \n', '        address[8] memory   matrix_commission;\n', '        matrix_commission[0] = rollUp(userList[users[_user].referrerID]);\n', '        matrix_commission[1] = rollUp(userList[users[matrix_commission[0]].referrerID]);\n', '        matrix_commission[2] = rollUp(userList[users[matrix_commission[1]].referrerID]);\n', '        matrix_commission[3] = rollUp(userList[users[matrix_commission[2]].referrerID]);\n', '        matrix_commission[4] = rollUp(userList[users[matrix_commission[3]].referrerID]);\n', '        matrix_commission[5] = rollUp(userList[users[matrix_commission[4]].referrerID]);\n', '        matrix_commission[6] = rollUp(userList[users[matrix_commission[5]].referrerID]);\n', '        matrix_commission[7] = rollUp(userList[users[matrix_commission[6]].referrerID]);\n', '        \n', '        for(uint i = 0; i < matrix_commission.length; i++){\n', '            if(matrix_commission[i] == address(0)){\n', '                matrix_commission[i] = userList[1];\n', '            }\n', '        }\n', '\n', '        uint matrix_commission_upline_percentage = (_amount.mul(8 ether).div(10**20));\n', '        \n', '        for(uint i=0; i<matrix_commission.length; i++){\n', '            if(matrix_commission[i] == userList[1]){\n', '                uint commission = matrix_commission_upline_percentage.mul(matrix_commission.length.sub(i));\n', '                require(address(uint160(matrix_commission[i])).send(commission),"transfer failed");\n', '                users[matrix_commission[i]].totalEarnedETH = users[matrix_commission[i]].totalEarnedETH.add(commission);\n', '                users[matrix_commission[i]].teamNetworkEarnETH = users[matrix_commission[i]].teamNetworkEarnETH.add(commission);\n', '                commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(commission);\n', '                break;\n', '            }\n', '            else{\n', '                require(address(uint160(matrix_commission[i])).send(matrix_commission_upline_percentage),"transfer failed");\n', '                users[matrix_commission[i]].totalEarnedETH = users[matrix_commission[i]].totalEarnedETH.add(matrix_commission_upline_percentage);\n', '                users[matrix_commission[i]].teamNetworkEarnETH = users[matrix_commission[i]].teamNetworkEarnETH.add(matrix_commission_upline_percentage);\n', '                commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(matrix_commission_upline_percentage);\n', '            }\n', '        }\n', '        \n', '        adminBreakageAmount[msg.sender] = adminBreakageAmount[msg.sender].add(matrix_commission_upline_percentage.mul(matrixCommissionBreakage[msg.sender]));\n', '        \n', '        emit MatrixCommission(\n', '            _user,\n', '            bonusEligibleUsers[msg.sender][0],\n', '            bonusEligibleUsers[msg.sender][1],\n', '            bonusEligibleUsers[msg.sender][2],\n', '            bonusEligibleUsers[msg.sender][3],\n', '            bonusEligibleUsers[msg.sender][4],\n', '            bonusEligibleUsers[msg.sender][5],\n', '            bonusEligibleUsers[msg.sender][6],\n', '            bonusEligibleUsers[msg.sender][7],\n', '            matrix_commission_upline_percentage\n', '        );\n', '        \n', '        return matrix_commission[7];\n', '    }\n', '    \n', '    // roll up - matrix commission\n', '    function rollUp(address _user) internal returns(address) {\n', '        \n', '        if(!users[_user].isExist) {\n', '            matrixCommissionBreakage[msg.sender]++;\n', '            bonusEligibleUsers[msg.sender].push(_user);\n', '            return userList[1];\n', '        }\n', '        \n', '\n', '        if((users[_user].membershipExpired.add(GRACE_PERIOD) >= now) && (!users[_user].blocked)){\n', '            bonusEligibleUsers[msg.sender].push(_user);\n', '            return _user;\n', '        }\n', '        else if(\n', '            ((users[_user].membershipExpired).add(blockTime.add(GRACE_PERIOD)) < now) \n', '            && (!users[_user].blocked))\n', '        {\n', '            users[_user].blocked = true;\n', '        }        \n', '        \n', '        return rollUp(userList[users[_user].referrerID]);\n', '    }\n', '    \n', '    mapping(address => address[]) public _teamNetworkEarnWallet;\n', '    \n', '    // Matching Commission\n', '    function matchingCarBonus(address _user) internal {\n', '        address sponser = userList[users[_user].referrerID];\n', '        \n', '        uint _carBonus;\n', '        \n', '        if(sponser == address(0)) sponser = userList[1];\n', '        \n', '        _teamNetworkEarnWallet[sponser] = new address[](0);\n', '        \n', '        if(((users[sponser].membershipExpired).add(blockTime.add(GRACE_PERIOD)) < now) && (!users[sponser].blocked)){\n', '            users[sponser].blocked = true;\n', '        }\n', '        \n', '        if(sponser != userList[1])\n', '            getAllDirectSponsor( sponser, userList[users[sponser].referrerID], 0);\n', '\n', '        if((_teamNetworkEarnWallet[sponser].length > 0) && (users[sponser].teamNetworkEarnETH > 0)){\n', '            _carBonus = (users[sponser].teamNetworkEarnETH.mul(25 ether).div(100 ether)).div(MatchingBonusUplineLimit);\n', '            \n', '            if(_carBonus > 0){\n', '                for(uint j=0; j<_teamNetworkEarnWallet[sponser].length;j++){\n', '                    require(address(uint160(_teamNetworkEarnWallet[sponser][j])).send(_carBonus),"transfer car bonus failed");\n', '                    users[_teamNetworkEarnWallet[sponser][j]].totalEarnedETH = users[_teamNetworkEarnWallet[sponser][j]].totalEarnedETH.add(_carBonus);\n', '                    commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(_carBonus);\n', '                }\n', '                \n', '                if(_teamNetworkEarnWallet[sponser].length != MatchingBonusUplineLimit){\n', '                    uint breakage = MatchingBonusUplineLimit.sub(_teamNetworkEarnWallet[sponser].length);\n', '                    if(breakage > 0){\n', '                        require(address(uint160(admin)).send(_carBonus.mul(breakage)),"transfer car bonus failed");\n', '                        users[admin].totalEarnedETH = users[admin].totalEarnedETH.add(_carBonus.mul(breakage));\n', '                        adminBreakageAmount[msg.sender] = adminBreakageAmount[msg.sender].add(_carBonus.mul(breakage));\n', '                        commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(_carBonus.mul(breakage));\n', '                    }\n', '                }    \n', '                    \n', '                \n', '                emit MatchingCarBonus(\n', '                    _user,\n', '                    sponser,\n', '                    _teamNetworkEarnWallet[sponser],\n', '                    _carBonus\n', '                );\n', '            }\n', '        }\n', '    }\n', '    \n', '    // get all qualified direct sponsers.\n', '    function getAllDirectSponsor(address _sponser, address _directSponser, uint _limit) internal returns(bool){\n', '        \n', '        uint referralCount = rollUpD50Enrolled( _directSponser, 0, users[_directSponser].referrals.length-1); \n', '                    \n', '        if(referralCount >= 1)\n', '          _teamNetworkEarnWallet[_sponser].push(_directSponser);\n', '        \n', '        if(_directSponser == userList[1])\n', '            return true;\n', '        \n', '        _limit++;\n', '        \n', '        if(_limit == MatchingBonusUplineLimit)\n', '            return true;\n', '        \n', '        return getAllDirectSponsor( _sponser, userList[users[_directSponser].referrerID], _limit);\n', '    }\n', '    \n', '    // roll up $50 - Matching bonus \n', '    function rollUpD50Enrolled(address _user, uint _referralCount, uint _referralIndex) internal  returns(uint){\n', '        \n', '        if(((users[users[_user].referrals[_referralIndex]].membershipExpired).add(GRACE_PERIOD) >= now) && (users[users[_user].referrals[_referralIndex]].donated == 2)){\n', '            _referralCount++;\n', '        }\n', '        \n', '        if(_referralIndex == 0)\n', '            return _referralCount;\n', '            \n', '        _referralIndex--;\n', '        \n', '        return rollUpD50Enrolled( _user, _referralCount, _referralIndex);\n', '    }\n', '    \n', '\n', '    // Referral Commission    \n', '    function referralBonus(address _user, uint _value) internal{\n', '        address sponser = userList[users[_user].placementSponser]; \n', '        uint _refBonus = ((_value).mul(12 ether).div(10**20));\n', '        \n', '        if(sponser == address(0)) sponser = userList[1];\n', '        \n', '        if(((users[sponser].membershipExpired).add(blockTime.add(GRACE_PERIOD)) < now)  && (!users[sponser].blocked))\n', '            users[sponser].blocked = true;              \n', '        \n', '        if(users[sponser].blocked){\n', '            sponser = admin;\n', '        }  \n', '        \n', '        require(address(uint160(sponser)).send(_refBonus),"transfer failed");\n', '        users[sponser].totalEarnedETH = users[sponser].totalEarnedETH.add(_refBonus);\n', '        commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(_refBonus);\n', '        \n', '        if(sponser != userList[users[_user].placementSponser])\n', '            adminBreakageAmount[msg.sender] = adminBreakageAmount[msg.sender].add(_refBonus);\n', '        else{\n', '            emit RefBonus(\n', '                _user,\n', '                sponser,\n', '                _refBonus\n', '            );\n', '        }\n', '    }\n', '\n', '    mapping(address => address[]) _addressList;\n', '\n', '    // Infinity Commission    \n', '    function infinityHouseBonus(address _user, uint _amount) internal {\n', '        address[4] memory   house_bonus;\n', '        _addressList[msg.sender] = new address[](0);\n', '        bonusEligibleUsers[msg.sender] = new address[](0);\n', '        \n', '        _addressList[msg.sender].push(userList[1]);\n', '        \n', '        house_bonus[0] = matchingHouseBonusRollUp(userList[users[_user].referrerID],usdPrice.mul(500000), _addressList[msg.sender]); // 2%\n', '        _addressList[msg.sender].push(house_bonus[0]);\n', '        \n', '        house_bonus[1] = matchingHouseBonusRollUp(userList[users[_user].referrerID],usdPrice.mul(200000), _addressList[msg.sender]); // 2%\n', '        if((house_bonus[1] == userList[1]))\n', '            house_bonus[1] = house_bonus[0];\n', '            \n', '        _addressList[msg.sender].push(house_bonus[1]);    \n', '        \n', '        house_bonus[2] = matchingHouseBonusRollUp(userList[users[_user].referrerID],usdPrice.mul(100000), _addressList[msg.sender]); // 2%\n', '        if((house_bonus[2] == userList[1]))\n', '            house_bonus[2] = house_bonus[1];\n', '        \n', '        _addressList[msg.sender].push(house_bonus[2]);    \n', '        \n', '        house_bonus[3] = matchingHouseBonusRollUp(userList[users[_user].referrerID], usdPrice.mul(20000), _addressList[msg.sender]); // 2%\n', '        \n', '        if((house_bonus[3] == userList[1]))\n', '            house_bonus[3] = house_bonus[2];\n', '        \n', '        uint houseUpline_9_12 = (_amount.mul(2 ether).div(10**20));\n', '        \n', '        for(uint i=0; i<house_bonus.length;i++){\n', '            require(address(uint160(house_bonus[i])).send(houseUpline_9_12),"transfer failed");\n', '            users[house_bonus[i]].totalEarnedETH = users[house_bonus[i]].totalEarnedETH.add(houseUpline_9_12);\n', '            commissionsReceivedValue[msg.sender] = commissionsReceivedValue[msg.sender].add(houseUpline_9_12);\n', '        }\n', '        \n', '        emit InfinityHouseBonus(\n', '            msg.sender,\n', '            bonusEligibleUsers[msg.sender][0],\n', '            bonusEligibleUsers[msg.sender][1],\n', '            bonusEligibleUsers[msg.sender][2],\n', '            bonusEligibleUsers[msg.sender][3],\n', '            houseUpline_9_12\n', '        );\n', '    }\n', '    \n', '    // roll up - House bonus\n', '    function matchingHouseBonusRollUp(address _user,uint _usdETHValue, address[] memory __previousAddress) internal  returns(address) {\n', '        \n', '        for(uint i=0;i<__previousAddress.length;i++){\n', '            if((_user == __previousAddress[i]) && (_user != userList[1]))\n', '                matchingHouseBonusRollUp(userList[users[_user].referrerID],_usdETHValue, __previousAddress);\n', '        }\n', '        \n', '        if(!users[_user].isExist) {\n', '            bonusEligibleUsers[msg.sender].push(_user);\n', '            return userList[1];\n', '        }\n', '        \n', '         if(((users[_user].membershipExpired).add(GRACE_PERIOD) >= now) && (users[_user].donated == 2) && (!users[_user].blocked))\n', '        {\n', '            uint referralCount;\n', '            if(users[_user].referrals.length > 0)\n', '                referralCount = rollUpD50FL( _user, 0, users[_user].referrals.length-1);\n', '            \n', '            \n', '            if(referralCount >= 4){\n', '                if(users[_user].totalEarnedETH >= _usdETHValue){\n', '                    bonusEligibleUsers[msg.sender].push(_user);\n', '                    return _user;\n', '                }\n', '            } \n', '        } \n', '        \n', '        return matchingHouseBonusRollUp(userList[users[_user].referrerID],_usdETHValue, __previousAddress);\n', '    }\n', '\n', '    // roll up $50 - House bonus    \n', '    function rollUpD50FL(address _user, uint _referralCount, uint _referralIndex) internal  returns(uint){\n', '        \n', '        if(((users[users[_user].referrals[_referralIndex]].membershipExpired).add(GRACE_PERIOD) >= now)  && (users[users[_user].referrals[_referralIndex]].donated == 2)){\n', '            _referralCount++;\n', '        }\n', '        \n', '        if(_referralIndex == 0)\n', '            return _referralCount;\n', '            \n', '        _referralIndex--;\n', '        \n', '        return rollUpD50FL( _user, _referralCount, _referralIndex);\n', '    }\n', '    \n', '    function updateGracePeriod(uint _gracePeriod) public OnlyOwner returns(bool) {\n', '        GRACE_PERIOD = _gracePeriod;\n', '        return true;\n', '    }\n', '    \n', '    function failSafe(address payable _toUser, uint _amount) public OnlyOwner returns (bool) {\n', '        require(_toUser != address(0), "Invalid Address");\n', '        require(address(this).balance >= _amount, "Insufficient balance");\n', '\n', '        (_toUser).transfer(_amount);\n', '        return true;\n', '    }\n', ' \n', '    function contractLock(bool _lockStatus) public OnlyOwner returns(bool) {\n', '        lockStatus = _lockStatus;\n', '        return true;\n', '    }\n', '    \n', '    function updateBlockTime(uint _newBlockTime) public OnlyOwner returns(bool) {\n', '        blockTime = _newBlockTime;\n', '        return true;\n', '    }\n', '    \n', '    function updateMatchingBonusUplineLimit(uint _MatchingBonusUplineLimit) public OnlyOwner returns(bool) {\n', '        require(_MatchingBonusUplineLimit > 0, "MatchingBonusUplineLimit must be greater than zero");\n', '        MatchingBonusUplineLimit = _MatchingBonusUplineLimit;\n', '        return true;\n', '    }\n', '    \n', '    function updateAdminWallet( address payable _newAdminWallet) public OnlyOwner returns(bool){\n', '        require(_newAdminWallet != address(0), "_newAdminWallet must not be zero wallet");\n', '        \n', '        UserStruct memory userStruct;\n', '        userStruct = UserStruct({\n', '            isExist: true,\n', '            id: 1,\n', '            referrerID: 0,\n', '            orginalRefID: 0,\n', '            placementSponser: 0,\n', '            donated: users[admin].donated,\n', '            teamNetworkEarnETH: users[admin].teamNetworkEarnETH,\n', '            totalEarnedETH: users[admin].totalEarnedETH,\n', '            blocked: users[admin].blocked,\n', '            personallyEnrolled : users[admin].personallyEnrolled,\n', '            referrals: users[admin].referrals,\n', '            membershipExpired:users[admin].membershipExpired\n', '        });\n', '        \n', '        UserStruct memory userStruct_;\n', '        \n', '        users[admin] = userStruct_;\n', '        \n', '        admin = _newAdminWallet;\n', '        \n', '        users[admin] = userStruct;    \n', '        userList[1] = admin;\n', '        \n', '        return true;\n', '    }\n', '    \n', '    function isContract(address account) public view returns (bool) {\n', '        uint32 size;\n', '        assembly {\n', '                size := extcodesize(account)\n', '            }\n', '        if(size != 0)\n', '            return true;\n', '            \n', '        return false;\n', '    }\n', '    \n', '    function viewMembershipExpired(address _user) public view returns(uint) {\n', '        return users[_user].membershipExpired;\n', '    }\n', '    \n', '    function viewUserReferral(address _user) public view returns(address[] memory) {\n', '        return users[_user].personallyEnrolled;\n', '    } \n', '    \n', '    function viewUserDirectReferral(address _user) public view returns(address[] memory) {\n', '        return users[_user].referrals;\n', '    } \n', '    \n', '}']