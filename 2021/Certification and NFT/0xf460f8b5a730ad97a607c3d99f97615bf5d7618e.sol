['// SPDX-License-Identifier: BSD-3-Clause\n', '\n', 'pragma solidity 0.6.11;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./GovernorBravoInterfaces.sol";\n', '\n', 'contract GovernorBravoDelegate is GovernorBravoDelegateStorageV1, GovernorBravoEvents {\n', '\n', '    /// @notice The name of this contract\n', '    string public constant name = "Ampleforth Governor Bravo";\n', '\n', '    /// @notice The minimum setable proposal threshold\n', '    uint public constant MIN_PROPOSAL_THRESHOLD = 75000e18; // 75,000 Forth\n', '\n', '    /// @notice The maximum setable proposal threshold\n', '    uint public constant MAX_PROPOSAL_THRESHOLD = 150000e18; // 150,000 Forth\n', '\n', '    /// @notice The minimum setable voting period\n', '    uint public constant MIN_VOTING_PERIOD = 5760; // About 24 hours\n', '\n', '    /// @notice The max setable voting period\n', '    uint public constant MAX_VOTING_PERIOD = 80640; // About 2 weeks\n', '\n', '    /// @notice The min setable voting delay\n', '    uint public constant MIN_VOTING_DELAY = 1;\n', '\n', '    /// @notice The max setable voting delay\n', '    uint public constant MAX_VOTING_DELAY = 40320; // About 1 week\n', '\n', '    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n', '    uint public constant quorumVotes = 600000e18; // 600,000 = 4% of Forth\n', '\n', '    /// @notice The maximum number of actions that can be included in a proposal\n', '    uint public constant proposalMaxOperations = 10; // 10 actions\n', '\n', "    /// @notice The EIP-712 typehash for the contract's domain\n", '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '\n', '    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n', '    bytes32 public constant BALLOT_TYPEHASH = keccak256("Ballot(uint256 proposalId,uint8 support)");\n', '\n', '    /**\n', '     * @notice Used to initialize the contract during delegator contructor\n', '     * @param timelock_ The address of the Timelock\n', '     * @param forth_ The address of the FORTH token\n', '     * @param votingPeriod_ The initial voting period\n', '     * @param votingDelay_ The initial voting delay\n', '     * @param proposalThreshold_ The initial proposal threshold\n', '     */\n', '    function initialize(address timelock_, address forth_, uint votingPeriod_, uint votingDelay_, uint proposalThreshold_) public {\n', '        require(address(timelock) == address(0), "GovernorBravo::initialize: can only initialize once");\n', '        require(msg.sender == admin, "GovernorBravo::initialize: admin only");\n', '        require(timelock_ != address(0), "GovernorBravo::initialize: invalid timelock address");\n', '        require(forth_ != address(0), "GovernorBravo::initialize: invalid forth address");\n', '        require(votingPeriod_ >= MIN_VOTING_PERIOD && votingPeriod_ <= MAX_VOTING_PERIOD, "GovernorBravo::initialize: invalid voting period");\n', '        require(votingDelay_ >= MIN_VOTING_DELAY && votingDelay_ <= MAX_VOTING_DELAY, "GovernorBravo::initialize: invalid voting delay");\n', '        require(proposalThreshold_ >= MIN_PROPOSAL_THRESHOLD && proposalThreshold_ <= MAX_PROPOSAL_THRESHOLD, "GovernorBravo::initialize: invalid proposal threshold");\n', '\n', '        timelock = TimelockInterface(timelock_);\n', '        timelock.acceptAdmin();\n', '        forth = ForthInterface(forth_);\n', '        votingPeriod = votingPeriod_;\n', '        votingDelay = votingDelay_;\n', '        proposalThreshold = proposalThreshold_;\n', '    }\n', '\n', '    /**\n', '     * @notice Function used to propose a new proposal. Sender must have delegates above the proposal threshold\n', '     * @param targets Target addresses for proposal calls\n', '     * @param values Eth values for proposal calls\n', '     * @param signatures Function signatures for proposal calls\n', '     * @param calldatas Calldatas for proposal calls\n', '     * @param description String description of the proposal\n', '     * @return Proposal id of new proposal\n', '     */\n', '    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n', '        require(forth.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, "GovernorBravo::propose: proposer votes below proposal threshold");\n', '        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, "GovernorBravo::propose: proposal function information arity mismatch");\n', '        require(targets.length != 0, "GovernorBravo::propose: must provide actions");\n', '        require(targets.length <= proposalMaxOperations, "GovernorBravo::propose: too many actions");\n', '\n', '        uint latestProposalId = latestProposalIds[msg.sender];\n', '        if (latestProposalId != 0) {\n', '            ProposalState proposersLatestProposalState = state(latestProposalId);\n', '            require(proposersLatestProposalState != ProposalState.Active, "GovernorBravo::propose: one live proposal per proposer, found an already active proposal");\n', '            require(proposersLatestProposalState != ProposalState.Pending, "GovernorBravo::propose: one live proposal per proposer, found an already pending proposal");\n', '        }\n', '\n', '        uint startBlock = add256(block.number, votingDelay);\n', '        uint endBlock = add256(startBlock, votingPeriod);\n', '\n', '        proposalCount++;\n', '        Proposal memory newProposal = Proposal({\n', '            id: proposalCount,\n', '                    proposer: msg.sender,\n', '                    eta: 0,\n', '                    targets: targets,\n', '                    values: values,\n', '                    signatures: signatures,\n', '                    calldatas: calldatas,\n', '                    startBlock: startBlock,\n', '                    endBlock: endBlock,\n', '                    forVotes: 0,\n', '                    againstVotes: 0,\n', '                    abstainVotes: 0,\n', '                    canceled: false,\n', '                    executed: false\n', '                    });\n', '\n', '        proposals[newProposal.id] = newProposal;\n', '        latestProposalIds[newProposal.proposer] = newProposal.id;\n', '\n', '        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n', '        return newProposal.id;\n', '    }\n', '\n', '    /**\n', '     * @notice Queues a proposal of state succeeded\n', '     * @param proposalId The id of the proposal to queue\n', '     */\n', '    function queue(uint proposalId) external {\n', '        require(state(proposalId) == ProposalState.Succeeded, "GovernorBravo::queue: proposal can only be queued if it is succeeded");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        uint eta = add256(block.timestamp, timelock.delay());\n', '        for (uint i = 0; i < proposal.targets.length; i++) {\n', '            queueOrRevertInternal(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n', '        }\n', '        proposal.eta = eta;\n', '        emit ProposalQueued(proposalId, eta);\n', '    }\n', '\n', '    function queueOrRevertInternal(address target, uint value, string memory signature, bytes memory data, uint eta) internal {\n', '        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), "GovernorBravo::queueOrRevertInternal: identical proposal action already queued at eta");\n', '        timelock.queueTransaction(target, value, signature, data, eta);\n', '    }\n', '\n', '    /**\n', '     * @notice Executes a queued proposal if eta has passed\n', '     * @param proposalId The id of the proposal to execute\n', '     */\n', '    function execute(uint proposalId) external payable {\n', '        require(state(proposalId) == ProposalState.Queued, "GovernorBravo::execute: proposal can only be executed if it is queued");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        proposal.executed = true;\n', '        for (uint i = 0; i < proposal.targets.length; i++) {\n', '            timelock.executeTransaction{value: proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n', '        }\n', '        emit ProposalExecuted(proposalId);\n', '    }\n', '\n', '    /**\n', '     * @notice Cancels a proposal only if sender is the proposer, or proposer delegates dropped below proposal threshold\n', '     * @param proposalId The id of the proposal to cancel\n', '     */\n', '    function cancel(uint proposalId) external {\n', '        require(state(proposalId) != ProposalState.Executed, "GovernorBravo::cancel: cannot cancel executed proposal");\n', '\n', '        Proposal storage proposal = proposals[proposalId];\n', '        require(msg.sender == proposal.proposer || forth.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold, "GovernorBravo::cancel: proposer above threshold");\n', '\n', '        proposal.canceled = true;\n', '        for (uint i = 0; i < proposal.targets.length; i++) {\n', '            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n', '        }\n', '\n', '        emit ProposalCanceled(proposalId);\n', '    }\n', '\n', '    /**\n', '     * @notice Gets actions of a proposal\n', '     * @param proposalId the id of the proposal\n', '     * @return targets proposal targets\n', '     * @return values proposal values\n', '     * @return signatures proposal signatures\n', '     * @return calldatas proposal calldatas\n', '     */\n', '    function getActions(uint proposalId) external view returns (address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas) {\n', '        Proposal storage p = proposals[proposalId];\n', '        return (p.targets, p.values, p.signatures, p.calldatas);\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the receipt for a voter on a given proposal\n', '     * @param proposalId the id of proposal\n', '     * @param voter The address of the voter\n', '     * @return The voting receipt\n', '     */\n', '    function getReceipt(uint proposalId, address voter) external view returns (Receipt memory) {\n', '        return proposals[proposalId].receipts[voter];\n', '    }\n', '\n', '    /**\n', '     * @notice Gets the state of a proposal\n', '     * @param proposalId The id of the proposal\n', '     * @return Proposal state\n', '     */\n', '    function state(uint proposalId) public view returns (ProposalState) {\n', '        require(proposalCount >= proposalId && proposalId > 0, "GovernorBravo::state: invalid proposal id");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        if (proposal.canceled) {\n', '            return ProposalState.Canceled;\n', '        } else if (block.number <= proposal.startBlock) {\n', '            return ProposalState.Pending;\n', '        } else if (block.number <= proposal.endBlock) {\n', '            return ProposalState.Active;\n', '        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes) {\n', '            return ProposalState.Defeated;\n', '        } else if (proposal.eta == 0) {\n', '            return ProposalState.Succeeded;\n', '        } else if (proposal.executed) {\n', '            return ProposalState.Executed;\n', '        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n', '            return ProposalState.Expired;\n', '        } else {\n', '            return ProposalState.Queued;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Cast a vote for a proposal\n', '     * @param proposalId The id of the proposal to vote on\n', '     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n', '     */\n', '    function castVote(uint proposalId, uint8 support) external {\n', '        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), "");\n', '    }\n', '\n', '    /**\n', '     * @notice Cast a vote for a proposal with a reason\n', '     * @param proposalId The id of the proposal to vote on\n', '     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n', '     * @param reason The reason given for the vote by the voter\n', '     */\n', '    function castVoteWithReason(uint proposalId, uint8 support, string calldata reason) external {\n', '        emit VoteCast(msg.sender, proposalId, support, castVoteInternal(msg.sender, proposalId, support), reason);\n', '    }\n', '\n', '    /**\n', '     * @notice Cast a vote for a proposal by signature\n', '     * @dev External function that accepts EIP-712 signatures for voting on proposals.\n', '     */\n', '    function castVoteBySig(uint proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) external {\n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainIdInternal(), address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "GovernorBravo::castVoteBySig: invalid signature");\n', '        emit VoteCast(signatory, proposalId, support, castVoteInternal(signatory, proposalId, support), "");\n', '    }\n', '\n', '    /**\n', '     * @notice Internal function that caries out voting logic\n', '     * @param voter The voter that is casting their vote\n', '     * @param proposalId The id of the proposal to vote on\n', '     * @param support The support value for the vote. 0=against, 1=for, 2=abstain\n', '     * @return The number of votes cast\n', '     */\n', '    function castVoteInternal(address voter, uint proposalId, uint8 support) internal returns (uint96) {\n', '        require(state(proposalId) == ProposalState.Active, "GovernorBravo::castVoteInternal: voting is closed");\n', '        require(support <= 2, "GovernorBravo::castVoteInternal: invalid vote type");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        Receipt storage receipt = proposal.receipts[voter];\n', '        require(receipt.hasVoted == false, "GovernorBravo::castVoteInternal: voter already voted");\n', '        uint96 votes = forth.getPriorVotes(voter, proposal.startBlock);\n', '\n', '        if (support == 0) {\n', '            proposal.againstVotes = add256(proposal.againstVotes, votes);\n', '        } else if (support == 1) {\n', '            proposal.forVotes = add256(proposal.forVotes, votes);\n', '        } else if (support == 2) {\n', '            proposal.abstainVotes = add256(proposal.abstainVotes, votes);\n', '        }\n', '\n', '        receipt.hasVoted = true;\n', '        receipt.support = support;\n', '        receipt.votes = votes;\n', '\n', '        return votes;\n', '    }\n', '\n', '    /**\n', '     * @notice Admin function for setting the voting delay\n', '     * @param newVotingDelay new voting delay, in blocks\n', '     */\n', '    function _setVotingDelay(uint newVotingDelay) external {\n', '        require(msg.sender == admin, "GovernorBravo::_setVotingDelay: admin only");\n', '        require(newVotingDelay >= MIN_VOTING_DELAY && newVotingDelay <= MAX_VOTING_DELAY, "GovernorBravo::_setVotingDelay: invalid voting delay");\n', '        uint oldVotingDelay = votingDelay;\n', '        votingDelay = newVotingDelay;\n', '\n', '        emit VotingDelaySet(oldVotingDelay,votingDelay);\n', '    }\n', '\n', '    /**\n', '     * @notice Admin function for setting the voting period\n', '     * @param newVotingPeriod new voting period, in blocks\n', '     */\n', '    function _setVotingPeriod(uint newVotingPeriod) external {\n', '        require(msg.sender == admin, "GovernorBravo::_setVotingPeriod: admin only");\n', '        require(newVotingPeriod >= MIN_VOTING_PERIOD && newVotingPeriod <= MAX_VOTING_PERIOD, "GovernorBravo::_setVotingPeriod: invalid voting period");\n', '        uint oldVotingPeriod = votingPeriod;\n', '        votingPeriod = newVotingPeriod;\n', '\n', '        emit VotingPeriodSet(oldVotingPeriod, votingPeriod);\n', '    }\n', '\n', '    /**\n', '     * @notice Admin function for setting the proposal threshold\n', '     * @dev newProposalThreshold must be greater than the hardcoded min\n', '     * @param newProposalThreshold new proposal threshold\n', '     */\n', '    function _setProposalThreshold(uint newProposalThreshold) external {\n', '        require(msg.sender == admin, "GovernorBravo::_setProposalThreshold: admin only");\n', '        require(newProposalThreshold >= MIN_PROPOSAL_THRESHOLD && newProposalThreshold <= MAX_PROPOSAL_THRESHOLD, "GovernorBravo::_setProposalThreshold: invalid proposal threshold");\n', '        uint oldProposalThreshold = proposalThreshold;\n', '        proposalThreshold = newProposalThreshold;\n', '\n', '        emit ProposalThresholdSet(oldProposalThreshold, proposalThreshold);\n', '    }\n', '\n', '    /**\n', '     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n', '     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n', '     * @param newPendingAdmin New pending admin.\n', '     */\n', '    function _setPendingAdmin(address newPendingAdmin) external {\n', '        // Check caller = admin\n', '        require(msg.sender == admin, "GovernorBravo:_setPendingAdmin: admin only");\n', '\n', '        // Save current value, if any, for inclusion in log\n', '        address oldPendingAdmin = pendingAdmin;\n', '\n', '        // Store pendingAdmin with value newPendingAdmin\n', '        pendingAdmin = newPendingAdmin;\n', '\n', '        // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n', '        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n', '    }\n', '\n', '    /**\n', '     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n', '     * @dev Admin function for pending admin to accept role and update admin\n', '     */\n', '    function _acceptAdmin() external {\n', '        // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n', '        require(msg.sender == pendingAdmin && msg.sender != address(0), "GovernorBravo:_acceptAdmin: pending admin only");\n', '\n', '        // Save current values for inclusion in log\n', '        address oldAdmin = admin;\n', '        address oldPendingAdmin = pendingAdmin;\n', '\n', '        // Store admin with value pendingAdmin\n', '        admin = pendingAdmin;\n', '\n', '        // Clear the pending value\n', '        pendingAdmin = address(0);\n', '\n', '        emit NewAdmin(oldAdmin, admin);\n', '        emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n', '    }\n', '\n', '    function add256(uint256 a, uint256 b) internal pure returns (uint) {\n', '        uint c = a + b;\n', '        require(c >= a, "addition overflow");\n', '        return c;\n', '    }\n', '\n', '    function sub256(uint256 a, uint256 b) internal pure returns (uint) {\n', '        require(b <= a, "subtraction underflow");\n', '        return a - b;\n', '    }\n', '\n', '    function getChainIdInternal() internal pure returns (uint) {\n', '        uint chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '}']