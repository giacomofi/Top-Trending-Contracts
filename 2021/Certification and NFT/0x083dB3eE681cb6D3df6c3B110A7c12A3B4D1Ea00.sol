['// SPDX-License-Identifier: U-U-U-UPPPPP!!!\n', 'pragma solidity ^0.7.4;\n', '\n', 'import "./IMarketDistribution.sol";\n', 'import "./IMarketGeneration.sol";\n', 'import "./TokensRecoverable.sol";\n', 'import "./SafeERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./IERC20.sol";\n', '\n', 'contract MarketGeneration is TokensRecoverable, IMarketGeneration\n', '{\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => mapping (uint8 => uint256)) public override contributionPerRound;\n', '    mapping (address => uint256) public override totalContribution;\n', '    mapping (uint8 => uint256) public override totalContributionPerRound;\n', '    mapping (address => uint256) public override referralPoints;\n', '    mapping (uint8 => bool) public disabledRounds;\n', '    uint256 public override totalReferralPoints;\n', '    address public immutable devAddress;\n', '\n', '    bool public isActive;\n', '\n', '    IERC20 immutable baseToken;\n', '    IMarketDistribution public marketDistribution;\n', '    uint256 refundsAllowedUntil;\n', '    uint8 constant public override buyRoundsCount = 3;\n', '    uint256 constant public hardCap = 1234567890000;\n', '\n', '    constructor (IERC20 _baseToken, address _devAddress)\n', '    {\n', '        baseToken = _baseToken;\n', '        devAddress = _devAddress;\n', '    }\n', '\n', '    modifier active()\n', '    {\n', '        require (isActive, "Distribution not active");\n', '        _;\n', '    }\n', '\n', '    function activate(IMarketDistribution _marketDistribution) public ownerOnly()\n', '    {\n', '        require (!isActive && block.timestamp >= refundsAllowedUntil, "Already activated");        \n', '        require (address(_marketDistribution) != address(0));\n', '        marketDistribution = _marketDistribution;\n', '        isActive = true;\n', '    }\n', '\n', '    function setMarketDistribution(IMarketDistribution _marketDistribution) public ownerOnly() active()\n', '    {\n', '        require (address(_marketDistribution) != address(0), "Invalid market distribution");\n', '        if (_marketDistribution == marketDistribution) { return; }\n', '        marketDistribution = _marketDistribution;\n', '\n', "        // Give everyone 1 day to claim refunds if they don't approve of the new distributor\n", '        refundsAllowedUntil = block.timestamp + 86400;\n', '    }\n', '\n', '    function disableBuyRound(uint8 round, bool disabled) public ownerOnly() active()\n', '    {\n', '        require (round > 0 && round <= buyRoundsCount, "Round must be 1 to 3");\n', '        disabledRounds[round] = disabled;\n', '    }\n', '\n', '    function complete() public ownerOnly() active()\n', '    {\n', '        require (block.timestamp >= refundsAllowedUntil, "Refund period is still active");\n', '        isActive = false;\n', '        if (baseToken.balanceOf(address(this)) == 0) { return; }\n', '\n', '        baseToken.safeApprove(address(marketDistribution), uint256(-1));\n', '\n', '        marketDistribution.distribute();\n', '    }\n', '\n', '    function allowRefunds() public ownerOnly() active()\n', '    {\n', '        isActive = false;\n', '        refundsAllowedUntil = uint256(-1);\n', '    }\n', '\n', '    function refund(uint256 amount) private\n', '    {\n', '        baseToken.safeTransfer(msg.sender, amount);\n', '            \n', '        totalContribution[msg.sender] = 0;           \n', '\n', '        for (uint8 round = 1; round <= buyRoundsCount; round++)\n', '        {\n', '            uint256 amountPerRound = contributionPerRound[msg.sender][round];\n', '            if (amountPerRound > 0)\n', '            {\n', '                contributionPerRound[msg.sender][round] = 0;\n', '                totalContributionPerRound[round] -= amountPerRound;\n', '            }\n', '        }\n', '\n', '        uint256 refPoints = referralPoints[msg.sender];\n', '       \n', '        if (refPoints > 0)\n', '        {\n', '            totalReferralPoints -= refPoints;\n', '            referralPoints[msg.sender] = 0;\n', '        }\n', '    }\n', '\n', '    function claim() public \n', '    {\n', '        uint256 amount = totalContribution[msg.sender];\n', '\n', '        require (amount > 0, "Nothing to claim");\n', '        \n', '        if (refundsAllowedUntil > block.timestamp) \n', '        {\n', '            refund(amount);\n', '        }\n', '        else \n', '        {\n', '            marketDistribution.claim(msg.sender);\n', '        }\n', '    }\n', '\n', '    function claimReferralRewards() public\n', '    {\n', '        require (referralPoints[msg.sender] > 0, "No rewards to claim");\n', '        \n', '        uint256 refShare = referralPoints[msg.sender];\n', '        referralPoints[msg.sender] = 0;\n', '        marketDistribution.claimReferralRewards(msg.sender, refShare);\n', '    }\n', '\n', '    function contribute(uint256 amount, uint8 round, address referral) public active() \n', '    {\n', '        require (round > 0 && round <= buyRoundsCount, "Round must be 1 to 3");\n', '        require (!disabledRounds[round], "Round is disabled");\n', '        require (baseToken.balanceOf(address(this)) < hardCap, "Hard Cap reached");\n', '\n', '        baseToken.safeTransferFrom(msg.sender, address(this), amount);\n', '\n', '        if (referral == address(0) || referral == msg.sender) \n', '        {\n', '            referralPoints[devAddress] +=amount;\n', '            totalReferralPoints += amount;\n', '        }\n', '        else \n', '        {\n', '            referralPoints[msg.sender] += amount;\n', '            referralPoints[referral] += amount;\n', '            totalReferralPoints +=(amount + amount);\n', '        }\n', '\n', '        totalContribution[msg.sender] += amount;\n', '        contributionPerRound[msg.sender][round] += amount;\n', '        totalContributionPerRound[round] += amount;\n', '    }\n', '}']