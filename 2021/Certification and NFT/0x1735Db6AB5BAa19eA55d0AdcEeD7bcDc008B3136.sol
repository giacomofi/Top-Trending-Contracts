['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-31\n', '*/\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Context.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}.\n', '     *\n', '     * The defaut value of {decimals} is 18. To select a different value for\n', '     * {decimals} you should overload it.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    constructor (string memory name_, string memory symbol_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view virtual returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view virtual returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n', '     * overloaded;\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view virtual returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][_msgSender()];\n', '        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '        _approve(sender, _msgSender(), currentAllowance - amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        uint256 currentAllowance = _allowances[_msgSender()][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '        _balances[account] = accountBalance - amount;\n', '        _totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/structs/EnumerableSet.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Library for managing\n', ' * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n', ' * types.\n', ' *\n', ' * Sets have the following properties:\n', ' *\n', ' * - Elements are added, removed, and checked for existence in constant time\n', ' * (O(1)).\n', ' * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n', ' *\n', ' * ```\n', ' * contract Example {\n', ' *     // Add the library methods\n', ' *     using EnumerableSet for EnumerableSet.AddressSet;\n', ' *\n', ' *     // Declare a set state variable\n', ' *     EnumerableSet.AddressSet private mySet;\n', ' * }\n', ' * ```\n', ' *\n', ' * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n', ' * and `uint256` (`UintSet`) are supported.\n', ' */\n', 'library EnumerableSet {\n', '    // To implement this library for multiple types with as little code\n', '    // repetition as possible, we write it in terms of a generic Set type with\n', '    // bytes32 values.\n', '    // The Set implementation uses private functions, and user-facing\n', '    // implementations (such as AddressSet) are just wrappers around the\n', '    // underlying Set.\n', '    // This means that we can only create new EnumerableSets for types that fit\n', '    // in bytes32.\n', '\n', '    struct Set {\n', '        // Storage of set values\n', '        bytes32[] _values;\n', '\n', '        // Position of the value in the `values` array, plus 1 because index 0\n', '        // means a value is not in the set.\n', '        mapping (bytes32 => uint256) _indexes;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function _add(Set storage set, bytes32 value) private returns (bool) {\n', '        if (!_contains(set, value)) {\n', '            set._values.push(value);\n', '            // The value is stored at length-1, but we add 1 to all indexes\n', '            // and use 0 as a sentinel value\n', '            set._indexes[value] = set._values.length;\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function _remove(Set storage set, bytes32 value) private returns (bool) {\n', "        // We read and store the value's index to prevent multiple reads from the same storage slot\n", '        uint256 valueIndex = set._indexes[value];\n', '\n', '        if (valueIndex != 0) { // Equivalent to contains(set, value)\n', '            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n', "            // the array, and then remove the last element (sometimes called as 'swap and pop').\n", '            // This modifies the order of the array, as noted in {at}.\n', '\n', '            uint256 toDeleteIndex = valueIndex - 1;\n', '            uint256 lastIndex = set._values.length - 1;\n', '\n', '            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n', "            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n", '\n', '            bytes32 lastvalue = set._values[lastIndex];\n', '\n', '            // Move the last value to the index where the value to delete is\n', '            set._values[toDeleteIndex] = lastvalue;\n', '            // Update the index for the moved value\n', '            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n', '\n', '            // Delete the slot where the moved value was stored\n', '            set._values.pop();\n', '\n', '            // Delete the index for the deleted slot\n', '            delete set._indexes[value];\n', '\n', '            return true;\n', '        } else {\n', '            return false;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n', '        return set._indexes[value] != 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function _length(Set storage set) private view returns (uint256) {\n', '        return set._values.length;\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n', '        require(set._values.length > index, "EnumerableSet: index out of bounds");\n', '        return set._values[index];\n', '    }\n', '\n', '    // Bytes32Set\n', '\n', '    struct Bytes32Set {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _add(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n', '        return _remove(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n', '        return _contains(set._inner, value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(Bytes32Set storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n', '        return _at(set._inner, index);\n', '    }\n', '\n', '    // AddressSet\n', '\n', '    struct AddressSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(AddressSet storage set, address value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(AddressSet storage set, address value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(AddressSet storage set, address value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(uint256(uint160(value))));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values in the set. O(1).\n', '     */\n', '    function length(AddressSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n', '        return address(uint160(uint256(_at(set._inner, index))));\n', '    }\n', '\n', '\n', '    // UintSet\n', '\n', '    struct UintSet {\n', '        Set _inner;\n', '    }\n', '\n', '    /**\n', '     * @dev Add a value to a set. O(1).\n', '     *\n', '     * Returns true if the value was added to the set, that is if it was not\n', '     * already present.\n', '     */\n', '    function add(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _add(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Removes a value from a set. O(1).\n', '     *\n', '     * Returns true if the value was removed from the set, that is if it was\n', '     * present.\n', '     */\n', '    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n', '        return _remove(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the value is in the set. O(1).\n', '     */\n', '    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n', '        return _contains(set._inner, bytes32(value));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of values on the set. O(1).\n', '     */\n', '    function length(UintSet storage set) internal view returns (uint256) {\n', '        return _length(set._inner);\n', '    }\n', '\n', '   /**\n', '    * @dev Returns the value stored at position `index` in the set. O(1).\n', '    *\n', '    * Note that there are no guarantees on the ordering of values inside the\n', '    * array, and it may change when more values are added or removed.\n', '    *\n', '    * Requirements:\n', '    *\n', '    * - `index` must be strictly less than {length}.\n', '    */\n', '    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n', '        return uint256(_at(set._inner, index));\n', '    }\n', '}\n', '\n', '// File: contracts/OwnershipAgreement.sol\n', '\n', 'pragma solidity >=0.7.0 <0.9.0;\n', '\n', '\n', '/// @title Creates an Ownership Agreement, with an optional Operator role\n', '/// @author Dr. Jonathan Shahen at UREEQA\n', '/// @notice TODO\n', '/// @dev Maximum number of Owners is set to 255 (unit8.MAX_VALUE)\n', 'contract OwnershipAgreement {\n', '    /*\n', '     * Storage\n', '     */\n', '    enum ResolutionType {\n', "        None, // This indicates that the resolution hasn't been set (default value)\n", '        AddOwner,\n', '        RemoveOwner,\n', '        ReplaceOwner,\n', '        AddOperator,\n', '        RemoveOperator,\n', '        ReplaceOperator,\n', '        UpdateThreshold,\n', '        UpdateTransactionLimit,\n', '        Pause,\n', '        Unpause,\n', '        Custom\n', '    }\n', '    struct Resolution {\n', '        // Has the resolution already been passed\n', '        bool passed;\n', '        // The type of resolution\n', '        ResolutionType resType;\n', '        // The old address, can be address(0). oldAddress and newAddress cannot both equal address(0).\n', '        address oldAddress;\n', '        // The new address, can be address(0). oldAddress and newAddress cannot both equal address(0).\n', '        address newAddress;\n', '    }\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '    // Set of owners\n', '    // NOTE: we utilize a set, so we can enumerate the owners and so that the list only contains one instance of an account\n', '    // NOTE: address(0) is not a valid owner\n', '    EnumerableSet.AddressSet private _owners;\n', '    // Value to indicate if the smart contract is paused\n', '    bool private _paused;\n', '    // An address, usually controlled by a computer, that performs regular/automated operations within the smart contract\n', '    // NOTE: address(0) is not a valid operator\n', '    EnumerableSet.AddressSet private _operators;\n', '    // Limit the number of operators\n', '    uint160 public operatorLimit = 1;\n', '    // The number of owners it takes to come to an agreement\n', '    uint160 public ownerAgreementThreshold = 1;\n', '    // Limit per Transaction to impose\n', '    // A limit of zero means no limit imposed\n', '    uint256 public transactionLimit = 0;\n', '    // Stores each vote for each resolution number (int)\n', '    mapping(address => mapping(uint256 => bool)) public ownerVotes;\n', '    // The next available resolution number\n', '    uint256 public nextResolution = 1;\n', '    mapping(address => uint256) lastOwnerResolutionNumber;\n', '    // Stores the resolutions\n', '    mapping(uint256 => Resolution) public resolutions;\n', '\n', '    // ////////////////////////////////////////////////////\n', '    // EVENTS\n', '    // ////////////////////////////////////////////////////\n', '    event OwnerAddition(address owner);\n', '    event OwnerRemoval(address owner);\n', '    event OwnerReplacement(address oldOwner, address newOwner);\n', '\n', '    event OperatorAddition(address newOperator);\n', '    event OperatorRemoval(address oldOperator);\n', '    event OperatorReplacement(address oldOperator, address newOperator);\n', '\n', '    event UpdateThreshold(uint160 newThreshold);\n', '    event UpdateNumberOfOperators(uint160 newOperators);\n', '    event UpdateTransactionLimit(uint256 newLimit);\n', '    /// @dev Emitted when the pause is triggered by `account`.\n', '    event Paused(address account);\n', '    /// @dev Emitted when the pause is lifted by `account`.\n', '    event Unpaused(address account);\n', '\n', '    // ////////////////////////////////////////////////////\n', '    // MODIFIERS\n', '    // ////////////////////////////////////////////////////\n', '    function isValidAddress(address newAddr) public pure {\n', '        require(newAddr != address(0), "Invaild Address");\n', '    }\n', '\n', '    modifier onlyOperators() {\n', '        isValidAddress(msg.sender);\n', '        require(\n', '            EnumerableSet.contains(_operators, msg.sender) == true,\n', '            "Only the operator can run this function."\n', '        );\n', '        _;\n', '    }\n', '    modifier onlyOwners() {\n', '        isValidAddress(msg.sender);\n', '        require(\n', '            EnumerableSet.contains(_owners, msg.sender) == true,\n', '            "Only an owner can run this function."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwnersOrOperator() {\n', '        isValidAddress(msg.sender);\n', '        require(\n', '            EnumerableSet.contains(_operators, msg.sender) == true || \n', '            EnumerableSet.contains(_owners, msg.sender) == true,\n', '            "Only an owner or the operator can run this function."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier ownerExists(address owner) {\n', '        require(\n', '            EnumerableSet.contains(_owners, owner) == true,\n', '            "Owner does not exists."\n', '        );\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is not paused.\n', '     * Requirements: The contract must not be paused.\n', '     */\n', '    modifier whenNotPaused() {\n', '        require(!_paused, "Smart Contract is paused");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to make a function callable only when the contract is paused.\n', '     * Requirements: The contract must be paused.\n', '     */\n', '    modifier whenPaused() {\n', '        require(_paused, "Smart Contract is not paused");\n', '        _;\n', '    }\n', '\n', '    /// @dev Modifier to make a function callable only when the amount is within the transaction limit\n', '    modifier withinLimit(uint256 amount) {\n', '        require(transactionLimit == 0 || amount <= transactionLimit, "Amount is over the transaction limit");\n', '        _;\n', '    }\n', '\n', '    // ////////////////////////////////////////////////////\n', '    // CONSTRUCTOR\n', '    // ////////////////////////////////////////////////////\n', '    constructor() {\n', '        _addOwner(msg.sender);\n', '        _paused = false;\n', '    }\n', '\n', '    // ////////////////////////////////////////////////////\n', '    // VIEW FUNCTIONS\n', '    // ////////////////////////////////////////////////////\n', '\n', '    /// @dev Returns list of owners.\n', '    /// @return List of owner addresses.\n', '    function getOwners() public view returns (address[] memory) {\n', '        uint256 len = EnumerableSet.length(_owners);\n', '        address[] memory o = new address[](len);\n', '\n', '        for (uint256 i = 0; i < len; i++) {\n', '            o[i] = EnumerableSet.at(_owners, i);\n', '        }\n', '\n', '        return o;\n', '    }\n', '\n', '    /// @dev Returns the number of owners.\n', '    /// @return Number of owners.\n', '    function getNumberOfOwners() public view returns (uint8) {\n', '        return uint8(EnumerableSet.length(_owners));\n', '    }\n', '\n', '    /// @dev Returns list of owners.\n', '    /// @return List of owner addresses.\n', '    function getOperators() public view returns (address[] memory) {\n', '        uint256 len = EnumerableSet.length(_operators);\n', '        address[] memory o = new address[](len);\n', '\n', '        for (uint256 i = 0; i < len; i++) {\n', '            o[i] = EnumerableSet.at(_operators, i);\n', '        }\n', '\n', '        return o;\n', '    }\n', '\n', '    /// @dev Returns the number of operators.\n', '    /// @return Number of operators.\n', '    function getNumberOfOperators() public view returns (uint8) {\n', '        return uint8(EnumerableSet.length(_operators));\n', '    }\n', '\n', '    /// @dev How many owners does it take to approve a resolution\n', '    /// @return minimum number of owner votes\n', '    function getVoteThreshold() public view returns (uint160) {\n', '        return ownerAgreementThreshold;\n', '    }\n', '\n', '    /// @dev Returns the maximum amount a transaction can contain\n', '    /// @return maximum amount or zero is no limit\n', '    function getTransactionLimit() public view returns (uint256) {\n', '        return transactionLimit;\n', '    }\n', '\n', '    /// @dev Returns the next available resolution.\n', '    /// @return The next available resolution number\n', '    function getNextResolutionNumber() public view returns (uint256) {\n', '        return nextResolution;\n', '    }\n', '\n', '    /// @dev Returns the next available resolution.\n', '    /// @return The next available resolution number\n', '    function getLastOwnerResolutionNumber(address owner) public view returns (uint256) {\n', '        return lastOwnerResolutionNumber[owner];\n', '    }\n', '\n', '    /// @dev Returns true if the contract is paused, and false otherwise.\n', '    function paused() public view returns (bool) {\n', '        return _paused;\n', '    }\n', '\n', '    /// @dev Helper function to fail if resolution number is already in use.\n', '    function resolutionAlreadyUsed(uint256 resNum) public view {\n', '        require(\n', '            // atleast one of the address must not be equal to address(0)\n', '            !(resolutions[resNum].oldAddress != address(0) ||\n', '                resolutions[resNum].newAddress != address(0)),\n', '            "Resolution is already in use."\n', '        );\n', '    }\n', '\n', '    function isResolutionPassed(uint256 resNum) public view returns (bool) {\n', '        return resolutions[resNum].passed;\n', '    }\n', '\n', '    function canResolutionPass(uint256 resNum) public view returns (bool) {\n', '        uint256 voteCount = 0;\n', '        uint256 len = EnumerableSet.length(_owners);\n', '\n', '        for (uint256 i = 0; i < len; i++) {\n', '            if (ownerVotes[EnumerableSet.at(_owners, i)][resNum] == true) {\n', '                voteCount++;\n', '            }\n', '        }\n', '\n', '        return voteCount >= ownerAgreementThreshold;\n', '    }\n', '\n', '    // ////////////////////////////////////////////////////\n', '    // PUBLIC FUNCTIONS\n', '    // ////////////////////////////////////////////////////\n', '\n', '    /// @notice Vote Yes on a Resolution.\n', '    /// @dev The owner who tips the agreement threshold will pay the gas for performing the resolution.\n', '    /// @return TRUE if the resolution passed\n', '    function voteResolution(uint256 resNum) public onlyOwners() returns (bool) {\n', '        ownerVotes[msg.sender][resNum] = true;\n', '\n', '        // If the reolution has already passed, then do nothing\n', '        if (isResolutionPassed(resNum)) {\n', '            return true;\n', '        }\n', '\n', '        // If the resolution can now be passed, then do so\n', '        if (canResolutionPass(resNum)) {\n', '            _performResolution(resNum);\n', '            return true;\n', '        }\n', '\n', '        // The resolution cannot be passed yet\n', '        return false;\n', '    }\n', '\n', '    /// @dev Create a resolution to add an owner. Performs addition if threshold is 1 or zero.\n', '    function createResolutionAddOwner(address newOwner) public onlyOwners() {\n', '        isValidAddress(newOwner);\n', '        require(!EnumerableSet.contains(_owners, newOwner),"newOwner already exists.");\n', '\n', '        createResolution(ResolutionType.AddOwner, address(0), newOwner);\n', '    }\n', '\n', '    /// @dev Create a resolution to remove an owner. Performs removal if threshold is 1 or zero.\n', '    /// @dev Updates the threshold to keep it less than or equal to the number of new owners\n', '    function createResolutionRemoveOwner(address owner) public onlyOwners() {\n', '        isValidAddress(owner);\n', '        require(getNumberOfOwners() > 1, "Must always be one owner");\n', '        require(EnumerableSet.contains(_owners, owner),"owner is not an owner.");\n', '\n', '        createResolution(ResolutionType.RemoveOwner, owner, address(0));\n', '    }\n', '\n', '    /// @dev Create a resolution to repalce an owner. Performs replacement if threshold is 1 or zero.\n', '    function createResolutionReplaceOwner(address oldOwner, address newOwner)\n', '        public\n', '        onlyOwners()\n', '    {\n', '        isValidAddress(oldOwner);\n', '        isValidAddress(newOwner);\n', '        require(EnumerableSet.contains(_owners, oldOwner),"oldOwner is not an owner.");\n', '        require(!EnumerableSet.contains(_owners, newOwner),"newOwner already exists.");\n', '\n', '        createResolution(ResolutionType.ReplaceOwner, oldOwner, newOwner);\n', '    }\n', '\n', '    /// @dev Create a resolution to add an operator. Performs addition if threshold is 1 or zero.\n', '    function createResolutionAddOperator(address newOperator) public onlyOwners() {\n', '        isValidAddress(newOperator);\n', '        require(!EnumerableSet.contains(_operators, newOperator),"newOperator already exists.");\n', '\n', '        createResolution(ResolutionType.AddOperator, address(0), newOperator);\n', '    }\n', '\n', '    /// @dev Create a resolution to remove the operator. Performs removal if threshold is 1 or zero.\n', '    function createResolutionRemoveOperator(address operator) public onlyOwners() {\n', '        require(EnumerableSet.contains(_operators, operator),"operator is not an Operator.");\n', '        createResolution(ResolutionType.RemoveOperator, operator, address(0));\n', '    }\n', '\n', '    /// @dev Create a resolution to replace the operator account. Performs replacement if threshold is 1 or zero.\n', '    function createResolutionReplaceOperator(address oldOperator, address newOperator)\n', '        public\n', '        onlyOwners()\n', '    {\n', '        isValidAddress(oldOperator);\n', '        isValidAddress(newOperator);\n', '        require(EnumerableSet.contains(_operators, oldOperator),"oldOperator is not an Operator.");\n', '        require(!EnumerableSet.contains(_operators, newOperator),"newOperator already exists.");\n', '\n', '        createResolution(ResolutionType.ReplaceOperator, oldOperator, newOperator);\n', '    }\n', '\n', '    /// @dev Create a resolution to update the transaction limit. Performs update if threshold is 1 or zero.\n', '    function createResolutionUpdateTransactionLimit(uint160 newLimit)\n', '        public\n', '        onlyOwners()\n', '    {\n', '        createResolution(ResolutionType.UpdateTransactionLimit, address(0), address(newLimit));\n', '    }\n', '\n', '    /// @dev Create a resolution to update the owner agreement threshold. Performs update if threshold is 1 or zero.\n', '    function createResolutionUpdateThreshold(uint160 threshold)\n', '        public\n', '        onlyOwners()\n', '    {\n', '        createResolution(ResolutionType.UpdateThreshold, address(0), address(threshold));\n', '    }\n', '\n', '    /// @dev Pause the contract. Does not require owner agreement.\n', '    function pause() public onlyOwners() {\n', '        _pause();\n', '    }\n', '\n', '    /// @dev Create a resolution to unpause the contract. Performs update if threshold is 1 or zero.\n', '    function createResolutionUnpause() public onlyOwners() {\n', '        createResolution(ResolutionType.Unpause, address(1), address(1));\n', '    }\n', '\n', '    // ////////////////////////////////////////////////////\n', '    // INTERNAL FUNCTIONS\n', '    // ////////////////////////////////////////////////////\n', '    /// @dev Create a resolution and check if we can call perofrm the resolution with 1 vote.\n', '    function createResolution(ResolutionType resType, address oldAddress, address newAddress) internal {\n', '        uint256 resNum = nextResolution;\n', '        nextResolution++;\n', '        resolutionAlreadyUsed(resNum);\n', '\n', '        resolutions[resNum].resType = resType;\n', '        resolutions[resNum].oldAddress = oldAddress;\n', '        resolutions[resNum].newAddress = newAddress;\n', '\n', '        ownerVotes[msg.sender][resNum] = true;\n', '        lastOwnerResolutionNumber[msg.sender] = resNum;\n', '\n', '        // Check if agreement is already reached\n', '        if (ownerAgreementThreshold <= 1) {\n', '            _performResolution(resNum);\n', '        }\n', '    }\n', '\n', '    /// @dev Performs the resolution and then marks it as passed. No checks prevent it from performing the resolutions.\n', '    function _performResolution(uint256 resNum) internal {\n', '        if (resolutions[resNum].resType == ResolutionType.AddOwner) {\n', '            _addOwner(resolutions[resNum].newAddress);\n', '        } else if (resolutions[resNum].resType == ResolutionType.RemoveOwner) {\n', '            _removeOwner(resolutions[resNum].oldAddress);\n', '        } else if (resolutions[resNum].resType == ResolutionType.ReplaceOwner) {\n', '            _replaceOwner(\n', '                resolutions[resNum].oldAddress,\n', '                resolutions[resNum].newAddress\n', '            );\n', '        } else if (\n', '            resolutions[resNum].resType == ResolutionType.AddOperator\n', '        ) {\n', '            _addOperator(resolutions[resNum].newAddress);\n', '        } else if (\n', '            resolutions[resNum].resType == ResolutionType.RemoveOperator\n', '        ) {\n', '            _removeOperator(resolutions[resNum].oldAddress);\n', '        } else if (\n', '            resolutions[resNum].resType == ResolutionType.ReplaceOperator\n', '        ) {\n', '            _replaceOperator(resolutions[resNum].oldAddress,resolutions[resNum].newAddress);\n', '        } else if (\n', '            resolutions[resNum].resType == ResolutionType.UpdateTransactionLimit\n', '        ) {\n', '            _updateTransactionLimit(uint160(resolutions[resNum].newAddress));\n', '        } else if (\n', '            resolutions[resNum].resType == ResolutionType.UpdateThreshold\n', '        ) {\n', '            _updateThreshold(uint160(resolutions[resNum].newAddress));\n', '        } else if (\n', '            resolutions[resNum].resType == ResolutionType.Pause\n', '        ) {\n', '            _pause();\n', '        } else if (\n', '            resolutions[resNum].resType == ResolutionType.Unpause\n', '        ) {\n', '            _unpause();\n', '        }\n', '\n', '        resolutions[resNum].passed = true;\n', '    }\n', '\n', '    /// @dev\n', '    function _addOwner(address owner) internal {\n', '        EnumerableSet.add(_owners, owner);\n', '        emit OwnerAddition(owner);\n', '    }\n', '\n', '    /// @dev\n', '    function _removeOwner(address owner) internal {\n', '        EnumerableSet.remove(_owners, owner);\n', '        emit OwnerRemoval(owner);\n', '\n', '        uint8 numOwners = getNumberOfOwners();\n', '        if(ownerAgreementThreshold > numOwners) {\n', '            _updateThreshold(numOwners);\n', '        }\n', '    }\n', '\n', '    /// @dev\n', '    function _replaceOwner(address oldOwner, address newOwner) internal {\n', '        EnumerableSet.remove(_owners, oldOwner);\n', '        EnumerableSet.add(_owners, newOwner);\n', '        emit OwnerReplacement(oldOwner, newOwner);\n', '    }\n', '\n', '    /// @dev\n', '    function _addOperator(address operator) internal {\n', '        EnumerableSet.add(_operators, operator);\n', '        emit OperatorAddition(operator);\n', '    }\n', '\n', '    /// @dev\n', '    function _removeOperator(address operator) internal {\n', '        EnumerableSet.remove(_operators, operator);\n', '        emit OperatorRemoval(operator);\n', '    }\n', '\n', '    /// @dev\n', '    function _replaceOperator(address oldOperator, address newOperator) internal {\n', '        emit OperatorReplacement(oldOperator, newOperator);\n', '        EnumerableSet.remove(_operators, oldOperator);\n', '        EnumerableSet.add(_operators, newOperator);\n', '    }\n', '\n', '    /// @dev Internal function to update and emit the new transaction limit\n', '    function _updateTransactionLimit(uint256 newLimit) internal {\n', '        emit UpdateTransactionLimit(newLimit);\n', '        transactionLimit = newLimit;\n', '    }\n', '\n', '    /// @dev Internal function to update and emit the new voting threshold\n', '    function _updateThreshold(uint160 threshold) internal {\n', '        require(threshold <= getNumberOfOwners(), "Unable to set threshold above the number of owners");\n', '        emit UpdateThreshold(threshold);\n', '        ownerAgreementThreshold = threshold;\n', '    }\n', '\n', '    /// @dev Internal function to update and emit the new voting threshold\n', '    function _updateNumberOfOperators(uint160 numOperators) internal {\n', '        require(numOperators >= getNumberOfOperators(), "Unable to set number of Operators below the number of operators");\n', '        emit UpdateNumberOfOperators(numOperators);\n', '        operatorLimit = numOperators;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Triggers stopped state.\n', '     *\n', '     * Requirements: The contract must not be paused.\n', '     */\n', '    function _pause() internal virtual whenNotPaused {\n', '        _paused = true;\n', '        emit Paused(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns to normal state.\n', '     *\n', '     * Requirements: The contract must be paused.\n', '     */\n', '    function _unpause() internal virtual whenPaused {\n', '        _paused = false;\n', '        emit Unpaused(msg.sender);\n', '    }\n', '}\n', '\n', '// File: contracts/URQAToken.sol\n', '\n', 'pragma solidity >=0.7.0 <0.9.0;\n', '\n', '\n', '\n', "/// @title UREEQA's URQA Token\n", '/// @author Dr. Jonathan Shahen at UREEQA\n', 'contract URQAToken is OwnershipAgreement, ERC20 {\n', '\n', '    constructor() ERC20("UREEQA Token", "URQA") {\n', '        // Total Supply: 100 million\n', '        _mint(msg.sender, 100_000_000e18);\n', '    }\n', '\n', '    /**\n', '     * @dev Batch transfer to reduce gas fees. Utilizes SafeMath and self.transfer\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipients` cannot contain the zero address.\n', '     * - the caller must have a balance of at least SUM `amounts`.\n', '     */\n', '    function batchTransfer(address[] memory recipients, uint256[] memory amounts) public returns (bool) {\n', '        for(uint256 i=0; i< amounts.length; i++) {\n', '            transfer(recipients[i], amounts[i]);\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n', '        super._beforeTokenTransfer(from, to, amount);\n', '\n', '        require(!paused(), "Cannot complete token transfer while Contract is Paused");\n', '    }\n', '}']