['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-23\n', '*/\n', '\n', '// File: contracts/token/IERC20Basic.sol\n', '\n', 'pragma solidity <0.6 >=0.4.21;\n', '\n', '\n', '/**\n', ' * @title ERC20Basic\n', ' * @dev Simpler version of ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/179\n', ' */\n', 'contract IERC20Basic {\n', '  function totalSupply() public view returns (uint256);\n', '  function balanceOf(address who) public view returns (uint256);\n', '  function transfer(address to, uint256 value) public returns (bool);\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '}\n', '\n', '// File: contracts/token/IERC20.sol\n', '\n', 'pragma solidity <0.6 >=0.4.21;\n', '\n', '\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'contract IERC20 is IERC20Basic {\n', '  function name() external view returns (string memory);\n', '  function symbol() external view returns (string memory);\n', '  function allowance(address owner, address spender) public view returns (uint256);\n', '  function transferFrom(address from, address to, uint256 value) public returns (bool);\n', '  function approve(address spender, uint256 value) public returns (bool);\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts/ICycloneV2dot2.sol\n', '\n', 'pragma solidity <0.6 >=0.4.24;\n', '\n', '\n', 'interface ICycloneV2dot2 {\n', '\n', '  function coinDenomination() external view returns (uint256);\n', '  function tokenDenomination() external view returns (uint256);\n', '  function cycDenomination() external view returns (uint256);\n', '  function token() external view returns (IERC20);\n', '  function cycToken() external view returns (IERC20);\n', '  function deposit(bytes32 _commitment) external payable;\n', '  function withdraw(bytes calldata _proof, bytes32 _root, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund) external payable;\n', '  function anonymityFee() external view returns (uint256);\n', '}\n', '\n', '// File: contracts/math/SafeMath.sol\n', '\n', 'pragma solidity <0.6 >=0.4.21;\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Math operations with safety checks that throw on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '  * @dev Multiplies two numbers, throws on overflow.\n', '  */\n', '\n', '  /*@CTK SafeMath_mul\n', '    @tag spec\n', '    @post __reverted == __has_assertion_failure\n', '    @post __has_assertion_failure == __has_overflow\n', '    @post __reverted == false -> c == a * b\n', '    @post msg == msg__post\n', '   */\n', '  /* CertiK Smart Labelling, for more details visit: https://certik.org */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '    c = a * b;\n', '    assert(c / a == b);\n', '    return c;\n', '  }\n', '\n', '  /**\n', '  * @dev Integer division of two numbers, truncating the quotient.\n', '  */\n', '  /*@CTK SafeMath_div\n', '    @tag spec\n', '    @pre b != 0\n', '    @post __reverted == __has_assertion_failure\n', '    @post __has_overflow == true -> __has_assertion_failure == true\n', '    @post __reverted == false -> __return == a / b\n', '    @post msg == msg__post\n', '   */\n', '  /* CertiK Smart Labelling, for more details visit: https://certik.org */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '    // uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '    return a / b;\n', '  }\n', '\n', '  /**\n', '  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '  */\n', '  /*@CTK SafeMath_sub\n', '    @tag spec\n', '    @post __reverted == __has_assertion_failure\n', '    @post __has_overflow == true -> __has_assertion_failure == true\n', '    @post __reverted == false -> __return == a - b\n', '    @post msg == msg__post\n', '   */\n', '  /* CertiK Smart Labelling, for more details visit: https://certik.org */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    assert(b <= a);\n', '    return a - b;\n', '  }\n', '\n', '  /**\n', '  * @dev Adds two numbers, throws on overflow.\n', '  */\n', '  /*@CTK SafeMath_add\n', '    @tag spec\n', '    @post __reverted == __has_assertion_failure\n', '    @post __has_assertion_failure == __has_overflow\n', '    @post __reverted == false -> c == a + b\n', '    @post msg == msg__post\n', '   */\n', '  /* CertiK Smart Labelling, for more details visit: https://certik.org */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '    c = a + b;\n', '    assert(c >= a);\n', '    return c;\n', '  }\n', '}\n', '\n', '// File: contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type,\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * This test is non-exhaustive, and there may be false-negatives: during the\n', "     * execution of a contract's constructor, its address will be reported as\n", '     * not containing a contract.\n', '     *\n', '     * > It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: contracts/token/SafeERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/uniswapv2/IRouter.sol\n', '\n', 'pragma solidity >=0.5.0 <0.8.0;\n', '\n', 'interface IRouter {\n', '    function removeLiquidity(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint liquidity,\n', '        uint amountAMin,\n', '        uint amountBMin,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint amountA, uint amountB);\n', '    function swapETHForExactTokens(\n', '        uint amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint[] memory amounts);\n', '    function swapExactTokensForTokens(\n', '        uint amountIn,\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    ) external returns (uint[] memory amounts);\n', '    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n', '}\n', '\n', '// File: contracts/uniswapv2/CycloneWrapper.sol\n', '\n', 'pragma solidity <0.6 >=0.4.24;\n', '\n', '\n', '\n', '\n', '\n', 'contract CycloneWrapper {\n', '  using SafeMath for uint256;\n', '  using SafeERC20 for IERC20;\n', '  IRouter public router;\n', '  address public wrappedCoin;\n', '  mapping(address => bool) public whitelisted;\n', '\n', '  constructor(IRouter _router, address _wrappedCoin) public {\n', '    router = _router;\n', '    wrappedCoin = _wrappedCoin;\n', '  }\n', '\n', '  function () external payable {}\n', '\n', '  function purchaseCost(ICycloneV2dot2 _cyclone) external view returns (uint256) {\n', '    uint256 cycAmount = _cyclone.cycDenomination().add(_cyclone.anonymityFee());\n', '    if (cycAmount == 0) {\n', '        return 0;\n', '    }\n', '    address[] memory paths = new address[](2);\n', '    paths[0] = wrappedCoin;\n', '    paths[1] = address(_cyclone.cycToken());\n', '    uint256[] memory amounts = router.getAmountsIn(cycAmount, paths);\n', '    return amounts[0];\n', '  }\n', '\n', '  function deposit(ICycloneV2dot2 _cyclone, bytes32 _commitment, bool _buyCYC) external payable {\n', '    require(whitelisted[address(_cyclone)], "not whitelisted");\n', '    uint256 coinAmount = _cyclone.coinDenomination();\n', '    require(msg.value >= coinAmount, "CycloneWrapper: insufficient coin");\n', '    uint256 tokenAmount = _cyclone.tokenDenomination();\n', '    uint256 cycAmount = _cyclone.cycDenomination().add(_cyclone.anonymityFee());\n', '    uint256 remainingCoin = msg.value.sub(coinAmount);\n', '    if (tokenAmount > 0) {\n', '      _cyclone.token().safeTransferFrom(msg.sender, address(this), tokenAmount);\n', '    }\n', '    if (cycAmount > 0) {\n', '      if (_buyCYC) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = wrappedCoin;\n', '        path[1] = address(_cyclone.cycToken());\n', '        uint256[] memory amounts = router.swapETHForExactTokens.value(remainingCoin)(cycAmount, path, address(this), block.timestamp.mul(2));\n', '        require(remainingCoin >= amounts[0], "CycloneWrapper: unexpected status");\n', '        remainingCoin -= amounts[0];\n', '      } else {\n', '        _cyclone.cycToken().safeTransferFrom(msg.sender, address(this), cycAmount);\n', '      }\n', '    }\n', '    _cyclone.deposit.value(coinAmount)(_commitment);\n', '    if (remainingCoin > 0) {\n', '      (bool success,) = msg.sender.call.value(remainingCoin)("");\n', "      require(success, 'CycloneWrapper: refund');\n", '    }\n', '  }\n', '\n', '  function whitelist(ICycloneV2dot2 _cyclone) public {\n', '    address cycloneAddr = address(_cyclone);\n', '    require(!whitelisted[cycloneAddr], "already whitelisted");\n', '    IERC20 token = _cyclone.token();\n', '    if (address(token) != address(0)) {\n', '        token.safeApprove(cycloneAddr, uint256(-1));\n', '    }\n', '    _cyclone.cycToken().safeApprove(cycloneAddr, uint256(-1));\n', '    whitelisted[cycloneAddr] = true;\n', '  }\n', '}']