['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-22\n', '*/\n', '\n', '// Sources flattened with hardhat v2.1.1 https://hardhat.org\n', '\n', '// File @openzeppelin/contracts-upgradeable/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library AddressUpgradeable {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/proxy/utils/[email\xa0protected]\n', '\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' *\n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n', ' *\n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/token/ERC20/[email\xa0protected]\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20Upgradeable {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// File contracts/library/ERC20ReInitializable.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', 'contract ERC20ReInitializable is Initializable, IERC20Upgradeable {\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '\n', '    /**\n', '     * @dev Sets the values for {name} and {symbol}.\n', '     *\n', '     * The defaut value of {decimals} is 18. To select a different value for\n', '     * {decimals} you should overload it.\n', '     *\n', '     * All three of these values are immutable: they can only be set once during\n', '     * construction.\n', '     */\n', '    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n', '        __ERC20_init_unchained(name_, symbol_);\n', '    }\n', '\n', '    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    function __ERC20_re_initialize(string memory name_, string memory symbol_) internal {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public view virtual returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public view virtual returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n', '     * overloaded;\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public view virtual returns (uint8) {\n', '        return 18;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view virtual override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '\n', '        uint256 currentAllowance = _allowances[sender][msg.sender];\n', '        require(currentAllowance >= amount, "ERC20: transfer amount exceeds allowance");\n', '        _approve(sender, msg.sender, currentAllowance - amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        uint256 currentAllowance = _allowances[msg.sender][spender];\n', '        require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");\n', '        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        uint256 senderBalance = _balances[sender];\n', '        require(senderBalance >= amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[sender] = senderBalance - amount;\n', '        _balances[recipient] += amount;\n', '\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _beforeTokenTransfer(address(0), account, amount);\n', '\n', '        _totalSupply += amount;\n', '        _balances[account] += amount;\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        uint256 accountBalance = _balances[account];\n', '        require(accountBalance >= amount, "ERC20: burn amount exceeds balance");\n', '        _balances[account] = accountBalance - amount;\n', '        _totalSupply -= amount;\n', '\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n', '     *\n', '     * This internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '    uint256[45] private __gap;\n', '}\n', '\n', '\n', '// File contracts/interfaces/IOwnable.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface IOwnable{\n', '    function owner() external view returns(address);\n', '}\n', '\n', '\n', '// File contracts/interfaces/IWhitelist.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * Source: https://raw.githubusercontent.com/simple-restricted-token/reference-implementation/master/contracts/token/ERC1404/ERC1404.sol\n', ' * With ERC-20 APIs removed (will be implemented as a separate contract).\n', ' * And adding authorizeTransfer.\n', ' */\n', 'interface IWhitelist {\n', '  /**\n', '   * @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\n', '   * @param from Sending address\n', '   * @param to Receiving address\n', '   * @param value Amount of tokens being transferred\n', '   * @return Code by which to reference message for rejection reasoning\n', '   * @dev Overwrite with your custom transfer restriction logic\n', '   */\n', '  function detectTransferRestriction(\n', '    address from,\n', '    address to,\n', '    uint value\n', '  ) external view returns (uint8);\n', '\n', '  /**\n', '   * @notice Returns a human-readable message for a given restriction code\n', '   * @param restrictionCode Identifier for looking up a message\n', "   * @return Text showing the restriction's reasoning\n", '   * @dev Overwrite with your custom message and restrictionCode handling\n', '   */\n', '  function messageForTransferRestriction(uint8 restrictionCode)\n', '    external\n', '    pure\n', '    returns (string memory);\n', '\n', '  /**\n', '   * @notice Called by the DAT contract before a transfer occurs.\n', '   * @dev This call will revert when the transfer is not authorized.\n', '   * This is a mutable call to allow additional data to be recorded,\n', '   * such as when the user aquired their tokens.\n', '   */\n', '  function authorizeTransfer(\n', '    address _from,\n', '    address _to,\n', '    uint _value,\n', '    bool _isSell\n', '  ) external;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/token/ERC20/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// File contracts/interfaces/IERC20Metadata.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface for the optional metadata functions from the ERC20 standard.\n', ' */\n', 'interface IERC20Metadata is IERC20 {\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token.\n', '     */\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the decimals places of the token.\n', '     */\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '\n', '// File contracts/math/BigDiv.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '/**\n', ' * @title Reduces the size of terms before multiplication, to avoid an overflow, and then\n', '*stores the proper size after division.\n', ' * @notice This effectively allows us to overflow values in the numerator and/or denominator\n', '* a fraction, so long as the end result does not overflow as well.\n', ' * @dev Results may be off by 1 + 0.000001% for 2x1 calls and 2 + 0.00001% for 2x2 calls.\n', ' * Do not use if your contract expects very small result values to be accurate.\n', ' */\n', 'library BigDiv {\n', "    // When multiplying 2 terms <= this value the result won't overflow\n", '    uint private constant MAX_BEFORE_SQUARE = 2**128 - 1;\n', '\n', '    // The max error target is off by 1 plus up to 0.000001% error\n', '    // for bigDiv2x1 and that `* 2` for bigDiv2x2\n', '    uint private constant MAX_ERROR = 100000000;\n', '\n', '    // A larger error threshold to use when multiple rounding errors may apply\n', '    uint private constant MAX_ERROR_BEFORE_DIV = MAX_ERROR * 2;\n', '\n', '    /**\n', '     * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\n', '     * @param _numA the first numerator term\n', '     * @param _numB the second numerator term\n', '     * @param _den the denominator\n', '     * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\n', '     */\n', '    function bigDiv2x1(\n', '        uint _numA,\n', '        uint _numB,\n', '        uint _den\n', '    ) internal pure returns (uint) {\n', '        if (_numA == 0 || _numB == 0) {\n', "            // would div by 0 or underflow if we don't special case 0\n", '            return 0;\n', '        }\n', '\n', '        uint value;\n', '\n', '        if (type(uint256).max / _numA >= _numB) {\n', '            // a*b does not overflow, return exact math\n', '            value = _numA * _numB;\n', '            value /= _den;\n', '            return value;\n', '        }\n', '\n', '        // Sort numerators\n', '        uint numMax = _numB;\n', '        uint numMin = _numA;\n', '        if (_numA > _numB) {\n', '            numMax = _numA;\n', '            numMin = _numB;\n', '        }\n', '\n', '        value = numMax / _den;\n', '        if (value > MAX_ERROR) {\n', '            // _den is small enough to be MAX_ERROR or better w/o a factor\n', '            value = value * numMin;\n', '            return value;\n', '        }\n', '\n', '        // formula = ((a / f) * b) / (d / f)\n', '        // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\n', '        uint factor = numMin - 1;\n', '        factor /= MAX_BEFORE_SQUARE;\n', '        factor += 1;\n', '        uint temp = numMax - 1;\n', '        temp /= MAX_BEFORE_SQUARE;\n', '        temp += 1;\n', '        if (type(uint256).max / factor >= temp) {\n', '            factor *= temp;\n', '            value = numMax / factor;\n', '            if (value > MAX_ERROR_BEFORE_DIV) {\n', '                value = value * numMin;\n', '                temp = _den - 1;\n', '                temp /= factor;\n', '                temp = temp + 1;\n', '                value /= temp;\n', '                return value;\n', '            }\n', '        }\n', '\n', '        // formula: (a / (d / f)) * (b / f)\n', '        // factor: b / sqrt(MAX)\n', '        factor = numMin - 1;\n', '        factor /= MAX_BEFORE_SQUARE;\n', '        factor += 1;\n', '        value = numMin / factor;\n', '        temp = _den - 1;\n', '        temp /= factor;\n', '        temp += 1;\n', '        temp = numMax / temp;\n', '        value = value * temp;\n', '        return value;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the approx result of `a * b / d` so long as the result is <= MAX_UINT\n', '     * @param _numA the first numerator term\n', '     * @param _numB the second numerator term\n', '     * @param _den the denominator\n', '     * @return the approx result with up to off by 1 + MAX_ERROR, rounding down if needed\n', '     * @dev roundUp is implemented by first rounding down and then adding the max error to the result\n', '     */\n', '    function bigDiv2x1RoundUp(\n', '        uint _numA,\n', '        uint _numB,\n', '        uint _den\n', '    ) internal pure returns (uint) {\n', '        // first get the rounded down result\n', '        uint value = bigDiv2x1(_numA, _numB, _den);\n', '\n', '        if (value == 0) {\n', '            // when the value rounds down to 0, assume up to an off by 1 error\n', '            return 1;\n', '        }\n', '\n', '        // round down has a max error of MAX_ERROR, add that to the result\n', '        // for a round up error of <= MAX_ERROR\n', '        uint temp = value - 1;\n', '        temp /= MAX_ERROR;\n', '        temp += 1;\n', '        if (type(uint256).max - value < temp) {\n', '            // value + error would overflow, return MAX\n', '            return type(uint256).max;\n', '        }\n', '\n', '        value += temp;\n', '\n', '        return value;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the approx result of `a * b / (c * d)` so long as the result is <= MAX_UINT\n', '     * @param _numA the first numerator term\n', '     * @param _numB the second numerator term\n', '     * @param _denA the first denominator term\n', '     * @param _denB the second denominator term\n', '     * @return the approx result with up to off by 2 + MAX_ERROR*10 error, rounding down if needed\n', '     * @dev this uses bigDiv2x1 and adds additional rounding error so the max error of this\n', '     * formula is larger\n', '     */\n', '    function bigDiv2x2(\n', '        uint _numA,\n', '        uint _numB,\n', '        uint _denA,\n', '        uint _denB\n', '    ) internal pure returns (uint) {\n', '        if (type(uint256).max / _denA >= _denB) {\n', '            // denA*denB does not overflow, use bigDiv2x1 instead\n', '            return bigDiv2x1(_numA, _numB, _denA * _denB);\n', '        }\n', '\n', '        if (_numA == 0 || _numB == 0) {\n', "            // would div by 0 or underflow if we don't special case 0\n", '            return 0;\n', '        }\n', '\n', '        // Sort denominators\n', '        uint denMax = _denB;\n', '        uint denMin = _denA;\n', '        if (_denA > _denB) {\n', '            denMax = _denA;\n', '            denMin = _denB;\n', '        }\n', '\n', '        uint value;\n', '\n', '        if (type(uint256).max / _numA >= _numB) {\n', '            // a*b does not overflow, use `a / d / c`\n', '            value = _numA * _numB;\n', '            value /= denMin;\n', '            value /= denMax;\n', '            return value;\n', '        }\n', '\n', '        // `ab / cd` where both `ab` and `cd` would overflow\n', '\n', '        // Sort numerators\n', '        uint numMax = _numB;\n', '        uint numMin = _numA;\n', '        if (_numA > _numB) {\n', '            numMax = _numA;\n', '            numMin = _numB;\n', '        }\n', '\n', '        // formula = (a/d) * b / c\n', '        uint temp = numMax / denMin;\n', '        if (temp > MAX_ERROR_BEFORE_DIV) {\n', '            return bigDiv2x1(temp, numMin, denMax);\n', '        }\n', '\n', '        // formula: ((a/f) * b) / d then either * f / c or / c * f\n', '        // factor >= a / sqrt(MAX) * (b / sqrt(MAX))\n', '        uint factor = numMin - 1;\n', '        factor /= MAX_BEFORE_SQUARE;\n', '        factor += 1;\n', '        temp = numMax - 1;\n', '        temp /= MAX_BEFORE_SQUARE;\n', '        temp += 1;\n', '        if (type(uint256).max / factor >= temp) {\n', '            factor *= temp;\n', '\n', '            value = numMax / factor;\n', '            if (value > MAX_ERROR_BEFORE_DIV) {\n', '                value = value * numMin;\n', '                value /= denMin;\n', '                if (value > 0 && type(uint256).max / value >= factor) {\n', '                    value *= factor;\n', '                    value /= denMax;\n', '                    return value;\n', '                }\n', '            }\n', '        }\n', '\n', '        // formula: (a/f) * b / ((c*d)/f)\n', '        // factor >= c / sqrt(MAX) * (d / sqrt(MAX))\n', '        factor = denMin;\n', '        factor /= MAX_BEFORE_SQUARE;\n', '        temp = denMax;\n', '        // + 1 here prevents overflow of factor*temp\n', '        temp /= MAX_BEFORE_SQUARE + 1;\n', '        factor *= temp;\n', '        return bigDiv2x1(numMax / factor, numMin, type(uint256).max);\n', '    }\n', '}\n', '\n', '\n', '// File contracts/math/Sqrt.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @title Calculates the square root of a given value.\n', ' * @dev Results may be off by 1.\n', ' */\n', 'library Sqrt {\n', '    // Source: https://github.com/ethereum/dapp-bin/pull/50\n', '    function sqrt(uint x) internal pure returns (uint y) {\n', '        if (x == 0) {\n', '            return 0;\n', '        } else if (x <= 3) {\n', '            return 1;\n', '        } else if (x == type(uint256).max) {\n', '            // Without this we fail on x + 1 below\n', '            return 2**128 - 1;\n', '        }\n', '\n', '        uint z = (x + 1) / 2;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract ContextUpgradeable is Initializable {\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '    }\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '    uint256[50] private __gap;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/access/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '    uint256[49] private __gap;\n', '}\n', '\n', '\n', '// File contracts/mixins/OperatorRole.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', "// Original source: openzeppelin's SignerRole\n", '\n', '/**\n', ' * @notice allows a single owner to manage a group of operators which may\n', ' * have some special permissions in the contract.\n', ' */\n', 'contract OperatorRole is OwnableUpgradeable {\n', '    mapping (address => bool) internal _operators;\n', '\n', '    event OperatorAdded(address indexed account);\n', '    event OperatorRemoved(address indexed account);\n', '\n', '    function _initializeOperatorRole() internal {\n', '        __Ownable_init();\n', '        _addOperator(msg.sender);\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(\n', '            isOperator(msg.sender),\n', '            "OperatorRole: caller does not have the Operator role"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function isOperator(address account) public view returns (bool) {\n', '        return _operators[account];\n', '    }\n', '\n', '    function addOperator(address account) public onlyOwner {\n', '        _addOperator(account);\n', '    }\n', '\n', '    function removeOperator(address account) public onlyOwner {\n', '        _removeOperator(account);\n', '    }\n', '\n', '    function renounceOperator() public {\n', '        _removeOperator(msg.sender);\n', '    }\n', '\n', '    function _addOperator(address account) internal {\n', '        _operators[account] = true;\n', '        emit OperatorAdded(account);\n', '    }\n', '\n', '    function _removeOperator(address account) internal {\n', '        _operators[account] = false;\n', '        emit OperatorRemoved(account);\n', '    }\n', '\n', '    uint[50] private ______gap;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/token/ERC20/utils/[email\xa0protected]\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender) + value;\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        unchecked {\n', '            uint256 oldAllowance = token.allowance(address(this), spender);\n', '            require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");\n', '            uint256 newAllowance = oldAllowance - value;\n', '            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/CAFE.sol\n', '\n', 'pragma solidity ^0.8.3;\n', 'pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Continuous Agreement for Future Equity\n', ' */\n', 'contract CAFE\n', '    is ERC20ReInitializable\n', '{\n', '    using Sqrt for uint;\n', '    using SafeERC20 for IERC20;\n', '    event Buy(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint _currencyValue,\n', '        uint _fairValue\n', '    );\n', '    event Sell(\n', '        address indexed _from,\n', '        address indexed _to,\n', '        uint _currencyValue,\n', '        uint _fairValue\n', '    );\n', '    event Burn(\n', '        address indexed _from,\n', '        uint _fairValue\n', '    );\n', '    event StateChange(\n', '        uint _previousState,\n', '        uint _newState\n', '    );\n', '    event Close();\n', '    event UpdateConfig(\n', '        address _whitelistAddress,\n', '        address indexed _beneficiary,\n', '        address indexed _control,\n', '        address indexed _feeCollector,\n', '        uint _feeBasisPoints,\n', '        uint _minInvestment,\n', '        uint _minDuration,\n', '        uint _stakeholdersPoolAuthorized,\n', '        uint _gasFee\n', '    );\n', '\n', '    //\n', '    // Constants\n', '    //\n', '\n', '    enum State {\n', '        Init,\n', '        Run,\n', '        Close,\n', '        Cancel\n', '    }\n', '\n', '    // The denominator component for values specified in basis points.\n', '    uint internal constant BASIS_POINTS_DEN = 10000;\n', '\n', '    uint internal constant MAX_ITERATION = 10;\n', '\n', '    /**\n', '     * Data specific to our token business logic\n', '     */\n', '\n', '    /// @notice The contract for transfer authorizations, if any.\n', '    IWhitelist public whitelist;\n', '\n', '    /// @notice The total number of burned FAIR tokens, excluding tokens burned from a `Sell` action in the DAT.\n', '    uint public burnedSupply;\n', '\n', '    /**\n', '     * Data for DAT business logic\n', '     */\n', '\n', '    /// @notice The address of the beneficiary organization which receives the investments.\n', '    /// Points to the wallet of the organization.\n', '    address payable public beneficiary;\n', '\n', '    struct BuySlope {\n', '        uint128 num;\n', '        uint128 den;\n', '    }\n', '\n', '    BuySlope public buySlope;\n', '\n', '    /// @notice The address from which the updatable variables can be updated\n', '    address public control;\n', '\n', '    /// @notice The address of the token used as reserve in the bonding curve\n', '    /// (e.g. the DAI contract). Use ETH if 0.\n', '    IERC20 public currency;\n', '\n', '    /// @notice The address where fees are sent.\n', '    address payable public feeCollector;\n', '\n', '    /// @notice The percent fee collected each time new FAIR are issued expressed in basis points.\n', '    uint public feeBasisPoints;\n', '\n', '    /// @notice The initial fundraising goal (expressed in FAIR) to start the c-org.\n', '    /// `0` means that there is no initial fundraising and the c-org immediately moves to run state.\n', '    uint public initGoal;\n', '\n', '    /// @notice A map with all investors in init state using address as a key and amount as value.\n', "    /// @dev This structure's purpose is to make sure that only investors can withdraw their money if init_goal is not reached.\n", '    mapping(address => uint) public initInvestors;\n', '\n', '    /// @notice The initial number of FAIR created at initialization for the beneficiary.\n', '    /// Technically however, this variable is not a constant as we must always have\n', '    ///`init_reserve>=total_supply+burnt_supply` which means that `init_reserve` will be automatically\n', '    /// decreased to equal `total_supply+burnt_supply` in case `init_reserve>total_supply+burnt_supply`\n', '    /// after an investor sells his FAIRs.\n', '    /// @dev Organizations may move these tokens into vesting contract(s)\n', '    uint public initReserve;\n', '\n', '    /// @notice The minimum amount of `currency` investment accepted.\n', '    uint public minInvestment;\n', '\n', '    /// @notice The current state of the contract.\n', '    /// @dev See the constants above for possible state values.\n', '    State public state;\n', '\n', '    /// @dev If this value changes we need to reconstruct the DOMAIN_SEPARATOR\n', '    string public constant version = "cafe-2.0";\n', '    // --- EIP712 niceties ---\n', '    // Original source: https://etherscan.io/address/0x6b175474e89094c44da98b954eedeac495271d0f#code\n', '    mapping (address => uint) public nonces;\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    // The success fee (expressed in currency) that will be earned by setupFeeRecipient as soon as initGoal\n', '    // is reached. We must have setup_fee <= buy_slope*init_goal^(2)/2\n', '    uint public setupFee;\n', '\n', '    // The recipient of the setup_fee once init_goal is reached\n', '    address payable public setupFeeRecipient;\n', '\n', '    /// @notice The minimum time before which the c-org contract cannot be closed once the contract has\n', '    /// reached the `run` state.\n', '    /// @dev When updated, the new value of `minimum_duration` cannot be earlier than the previous value.\n', '    uint public minDuration;\n', '\n', '    /// @dev Initialized at `0` and updated when the contract switches from `init` state to `run` state\n', '    /// or when the initial trial period ends.\n', '    uint private startedOn;\n', '\n', '    // keccak256("PermitBuy(address from,address to,uint256 currencyValue,uint256 minTokensBought,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_BUY_TYPEHASH = 0xaf42a244b3020d6a2253d9f291b4d3e82240da42b22129a8113a58aa7a3ddb6a;\n', '\n', '    // keccak256("PermitSell(address from,address to,uint256 quantityToSell,uint256 minCurrencyReturned,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_SELL_TYPEHASH = 0x5dfdc7fb4c68a4c249de5e08597626b84fbbe7bfef4ed3500f58003e722cc548;\n', '\n', '    // stkaeholdersPool struct separated\n', '    uint public stakeholdersPoolIssued;\n', '\n', '    uint public stakeholdersPoolAuthorized;\n', '\n', '    // The orgs commitement that backs the value of CAFEs.\n', '    // This value may be increased but not decreased.\n', '    uint public equityCommitment;\n', '\n', '    // Total number of tokens that have been attributed to current shareholders\n', '    uint public shareholdersPool;\n', '\n', '    // The max number of CAFEs investors can purchase (excludes the stakeholdersPool)\n', '    uint public maxGoal;\n', '\n', '    // The amount of CAFE to be sold to exit the trial mode.\n', '    // 0 means there is no trial.\n', '    uint public initTrial;\n', '\n', '    // Represents the fundraising amount that can be sold as a fixed price\n', '    uint public fundraisingGoal;\n', '\n', '    // To fund operator a gasFee\n', '    uint public gasFee;\n', '\n', '    // increased when manual buy\n', '    uint public manualBuybackReserve;\n', '\n', '    uint public totalInvested;\n', '\n', '    bytes32 private constant BEACON_SLOT = keccak256(abi.encodePacked("fairmint.beaconproxy.beacon"));\n', '    modifier onlyBeaconOperator() {\n', '        bytes32 slot = BEACON_SLOT;\n', '        address beacon;\n', '        assembly {\n', '            beacon := sload(slot)\n', '        }\n', '        require(beacon == address(0) || OperatorRole(beacon).isOperator(msg.sender), "!BeaconOperator");\n', '        _;\n', '    }\n', '\n', '    modifier authorizeTransfer(\n', '        address _from,\n', '        address _to,\n', '        uint _value,\n', '        bool _isSell\n', '    )\n', '    {\n', '        require(state != State.Close, "INVALID_STATE");\n', '        if(address(whitelist) != address(0))\n', '        {\n', '            // This is not set for the minting of initialReserve\n', '            whitelist.authorizeTransfer(_from, _to, _value, _isSell);\n', '        }\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * BuySlope\n', '     */\n', '    function buySlopeNum() external view returns(uint256) {\n', '        return uint256(buySlope.num);\n', '    }\n', '\n', '    function buySlopeDen() external view returns(uint256) {\n', '        return uint256(buySlope.den);\n', '    }\n', '\n', '    /**\n', '     * Stakeholders Pool\n', '     */\n', '    function stakeholdersPool() public view returns (uint256 issued, uint256 authorized) {\n', '        return (stakeholdersPoolIssued, stakeholdersPoolAuthorized);\n', '    }\n', '\n', '    function trialEndedOn() public view returns(uint256 timestamp) {\n', '        return startedOn;\n', '    }\n', '\n', '    /**\n', '     * Buyback reserve\n', '     */\n', '\n', '    /// @notice The total amount of currency value currently locked in the contract and available to sellers.\n', '    function buybackReserve() public view returns (uint)\n', '    {\n', '        uint reserve = address(this).balance;\n', '        if(address(currency) != address(0))\n', '        {\n', '            reserve = currency.balanceOf(address(this));\n', '        }\n', '\n', '        if(reserve > type(uint128).max)\n', '        {\n', '            /// Math: If the reserve becomes excessive, cap the value to prevent overflowing in other formulas\n', '            return type(uint128).max;\n', '        }\n', '\n', '        return reserve + manualBuybackReserve;\n', '    }\n', '\n', '    /**\n', '     * Functions required by the ERC-20 token standard\n', '     */\n', '\n', '    /// @dev Moves tokens from one account to another if authorized.\n', '    function _transfer(\n', '        address _from,\n', '        address _to,\n', '        uint _amount\n', '    ) internal override\n', '        authorizeTransfer(_from, _to, _amount, false)\n', '    {\n', '        require(state != State.Init || _from == beneficiary, "ONLY_BENEFICIARY_DURING_INIT");\n', '        super._transfer(_from, _to, _amount);\n', '    }\n', '\n', '    /// @dev Removes tokens from the circulating supply.\n', '    function _burn(\n', '        address _from,\n', '        uint _amount,\n', '        bool _isSell\n', '    ) internal\n', '        authorizeTransfer(_from, address(0), _amount, _isSell)\n', '    {\n', '        super._burn(_from, _amount);\n', '\n', '        if(!_isSell)\n', '        {\n', '            // This is a burn\n', '            // SafeMath not required as we cap how high this value may get during mint\n', '            burnedSupply += _amount;\n', '            emit Burn(_from, _amount);\n', '        }\n', '    }\n', '\n', '    /// @notice Called to mint tokens on `buy`.\n', '    function _mint(\n', '        address _to,\n', '        uint _quantity\n', '    ) internal override\n', '        authorizeTransfer(address(0), _to, _quantity, false)\n', '    {\n', '        super._mint(_to, _quantity);\n', '\n', '        // Math: If this value got too large, the DAT may overflow on sell\n', '        require(totalSupply() + burnedSupply <= type(uint128).max, "EXCESSIVE_SUPPLY");\n', '    }\n', '\n', '    /**\n', '     * Transaction Helpers\n', '     */\n', '\n', '    /// @notice Confirms the transfer of `_quantityToInvest` currency to the contract.\n', '    function _collectInvestment(\n', '        address payable _from,\n', '        uint _quantityToInvest,\n', '        uint _msgValue\n', '    ) internal\n', '    {\n', '        if(address(currency) == address(0))\n', '        {\n', '            // currency is ETH\n', '            require(_quantityToInvest == _msgValue, "INCORRECT_MSG_VALUE");\n', '        }\n', '        else\n', '        {\n', '            // currency is ERC20\n', '            require(_msgValue == 0, "DO_NOT_SEND_ETH");\n', '\n', '            currency.safeTransferFrom(_from, address(this), _quantityToInvest);\n', '        }\n', '    }\n', '\n', '    /// @dev Send `_amount` currency from the contract to the `_to` account.\n', '    function _transferCurrency(\n', '        address payable _to,\n', '        uint _amount\n', '    ) internal\n', '    {\n', '        if(_amount > 0)\n', '        {\n', '            if(address(currency) == address(0))\n', '            {\n', '                Address.sendValue(_to, _amount);\n', '            }\n', '            else\n', '            {\n', '                currency.safeTransfer(_to, _amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Config / Control\n', '     */\n', '\n', '    struct MileStone {\n', '        uint128 initReserve;\n', '        uint128 initTrial;\n', '        uint128 initGoal;\n', '        uint128 maxGoal;\n', '    }\n', '\n', '    /// @notice Called once after deploy to set the initial configuration.\n', '    /// None of the values provided here may change once initially set.\n', '    /// @dev using the init pattern in order to support zos upgrades\n', '    function initialize(\n', '        string calldata _name,\n', '        string calldata _symbol,\n', '        address _currencyAddress,\n', '        MileStone calldata _mileStone,\n', '        BuySlope calldata _buySlope,\n', '        uint _stakeholdersAuthorized,\n', '        uint _equityCommitment,\n', '        uint _setupFee,\n', '        address payable _setupFeeRecipient\n', '    ) external\n', '        onlyBeaconOperator\n', '    {\n', '        // _initialize will enforce this is only called once\n', '        // The ERC-20 implementation will confirm initialize is only run once\n', '        ERC20ReInitializable.__ERC20_init(_name, _symbol);\n', '        _initialize(\n', '            _currencyAddress,\n', '            _mileStone,\n', '            _buySlope,\n', '            _stakeholdersAuthorized,\n', '            _equityCommitment,\n', '            _setupFee,\n', '            _setupFeeRecipient\n', '        );\n', '    }\n', '\n', '    function reInitialize(\n', '        string calldata _name,\n', '        string calldata _symbol,\n', '        address _currencyAddress,\n', '        MileStone calldata _mileStone,\n', '        BuySlope calldata _buySlope,\n', '        uint _stakeholdersAuthorized,\n', '        uint _equityCommitment,\n', '        uint _setupFee,\n', '        address payable _setupFeeRecipient\n', '    ) external {\n', '        require(msg.sender == beneficiary, "ONLY_BENEFICIARY_CAN_REINITIALIZE");\n', '        require(balanceOf(msg.sender) == totalSupply(), "BENEFICIARY_SHOULD_HAVE_ALL_TOKENS");\n', '        require(initReserve == totalSupply(), "SHOULD_NOT_HAVE_RECEIVED_ANY_FUND");\n', '        ERC20ReInitializable.__ERC20_re_initialize(_name, _symbol);\n', '        _burn(msg.sender, totalSupply());\n', '        _initialize(\n', '            _currencyAddress,\n', '            _mileStone,\n', '            _buySlope,\n', '            _stakeholdersAuthorized,\n', '            _equityCommitment,\n', '            _setupFee,\n', '            _setupFeeRecipient\n', '        );\n', '    }\n', '\n', '    function _initialize(\n', '        address _currencyAddress,\n', '        MileStone memory _mileStone,\n', '        BuySlope memory _buySlope,\n', '        uint _stakeholdersAuthorized,\n', '        uint _equityCommitment,\n', '        uint _setupFee,\n', '        address payable _setupFeeRecipient\n', '    ) internal {\n', '        require(_buySlope.num > 0, "INVALID_SLOPE_NUM");\n', '        require(_buySlope.den > 0, "INVALID_SLOPE_DEN");\n', '        buySlope = _buySlope;\n', '\n', '        // Setup Fee\n', '        require(_setupFee == 0 || _setupFeeRecipient != address(0), "MISSING_SETUP_FEE_RECIPIENT");\n', '        require(_setupFeeRecipient == address(0) || _setupFee != 0, "MISSING_SETUP_FEE");\n', '        // setup_fee <= (n/d)*(g^2)/2\n', '        uint initGoalInCurrency = uint256(_mileStone.initGoal) * uint256(_mileStone.initGoal);\n', '        initGoalInCurrency = initGoalInCurrency * uint256(_buySlope.num);\n', '        initGoalInCurrency /= 2 * uint256(_buySlope.den);\n', '        require(_setupFee <= initGoalInCurrency, "EXCESSIVE_SETUP_FEE");\n', '        setupFee = _setupFee;\n', '        setupFeeRecipient = _setupFeeRecipient;\n', '\n', '        // Set default values (which may be updated using `updateConfig`)\n', '        uint decimals = 18;\n', '        if(_currencyAddress != address(0)){\n', '            decimals = IERC20Metadata(_currencyAddress).decimals();\n', '        }\n', '        minInvestment = 100 * (10 ** decimals);\n', '        beneficiary = payable(msg.sender);\n', '        control = msg.sender;\n', '        feeCollector = payable(msg.sender);\n', '\n', '        // Save currency\n', '        currency = IERC20(_currencyAddress);\n', '\n', '        // Mint the initial reserve\n', '        if(_mileStone.initReserve > 0)\n', '        {\n', '            initReserve = _mileStone.initReserve;\n', '            _mint(beneficiary, initReserve);\n', '        }\n', '\n', '        initializeDomainSeparator();\n', '        // Math: If this value got too large, the DAT would overflow on sell\n', '        // new settings for CAFE\n', '        require(_mileStone.maxGoal == 0 || _mileStone.initGoal == 0 || _mileStone.maxGoal >= _mileStone.initGoal, "MAX_GOAL_SMALLER_THAN_INIT_GOAL");\n', '        require(_mileStone.initGoal == 0 || _mileStone.initTrial == 0 || _mileStone.initGoal >= _mileStone.initTrial, "INIT_GOAL_SMALLER_THAN_INIT_TRIAL");\n', '        maxGoal = _mileStone.maxGoal;\n', '        initTrial = _mileStone.initTrial;\n', '        stakeholdersPoolIssued = _mileStone.initReserve;\n', '        require(_stakeholdersAuthorized <= BASIS_POINTS_DEN, "STAKEHOLDERS_POOL_AUTHORIZED_SHOULD_BE_SMALLER_THAN_BASIS_POINTS_DEN");\n', '        stakeholdersPoolAuthorized = _stakeholdersAuthorized;\n', '        require(_equityCommitment > 0, "EQUITY_COMMITMENT_CANNOT_BE_ZERO");\n', '        require(_equityCommitment <= BASIS_POINTS_DEN, "EQUITY_COMMITMENT_SHOULD_BE_LESS_THAN_100%");\n', '        equityCommitment = _equityCommitment;\n', '        // Set initGoal, which in turn defines the initial state\n', '        if(_mileStone.initGoal == 0)\n', '        {\n', '            _stateChange(State.Run);\n', '            startedOn = block.timestamp;\n', '        }\n', '        else\n', '        {\n', '            initGoal = _mileStone.initGoal;\n', '            state = State.Init;\n', '            startedOn = 0;\n', '        }\n', '    }\n', '\n', '    function _stateChange(State _state) internal {\n', '        emit StateChange(uint256(state), uint256(_state));\n', '        state = _state;\n', '    }\n', '\n', '    function updateConfig(\n', '        address _whitelistAddress,\n', '        address payable _beneficiary,\n', '        address _control,\n', '        address payable _feeCollector,\n', '        uint _feeBasisPoints,\n', '        uint _minInvestment,\n', '        uint _minDuration,\n', '        uint _stakeholdersAuthorized,\n', '        uint _gasFee\n', '    ) external\n', '    {\n', '        // This require(also confirms that initialize has been called.\n', '        require(msg.sender == control, "CONTROL_ONLY");\n', '\n', '        // address(0) is okay\n', '        whitelist = IWhitelist(_whitelistAddress);\n', '\n', '        require(_control != address(0), "INVALID_ADDRESS");\n', '        control = _control;\n', '\n', '        require(_feeCollector != address(0), "INVALID_ADDRESS");\n', '        feeCollector = _feeCollector;\n', '\n', '        require(_feeBasisPoints <= BASIS_POINTS_DEN, "INVALID_FEE");\n', '        feeBasisPoints = _feeBasisPoints;\n', '\n', '        require(_minInvestment > 0, "INVALID_MIN_INVESTMENT");\n', '        minInvestment = _minInvestment;\n', '\n', '        require(_minDuration >= minDuration, "MIN_DURATION_MAY_NOT_BE_REDUCED");\n', '        minDuration = _minDuration;\n', '\n', '        if(beneficiary != _beneficiary)\n', '        {\n', '            require(_beneficiary != address(0), "INVALID_ADDRESS");\n', '            uint tokens = balanceOf(beneficiary);\n', '            initInvestors[_beneficiary] = initInvestors[_beneficiary] + initInvestors[beneficiary];\n', '            initInvestors[beneficiary] = 0;\n', '            if(tokens > 0)\n', '            {\n', '                _transfer(beneficiary, _beneficiary, tokens);\n', '            }\n', '            beneficiary = _beneficiary;\n', '        }\n', '\n', '        // new settings for CAFE\n', '        require(_stakeholdersAuthorized <= BASIS_POINTS_DEN, "STAKEHOLDERS_POOL_AUTHORIZED_SHOULD_BE_SMALLER_THAN_BASIS_POINTS_DEN");\n', '        stakeholdersPoolAuthorized = _stakeholdersAuthorized;\n', '\n', '        gasFee = _gasFee;\n', '\n', '        emit UpdateConfig(\n', '            _whitelistAddress,\n', '            _beneficiary,\n', '            _control,\n', '            _feeCollector,\n', '            _feeBasisPoints,\n', '            _minInvestment,\n', '            _minDuration,\n', '            _stakeholdersAuthorized,\n', '            _gasFee\n', '        );\n', '    }\n', '\n', '    /// @notice Used to initialize the domain separator used in meta-transactions\n', '    /// @dev This is separate from `initialize` to allow upgraded contracts to update the version\n', '    /// There is no harm in calling this multiple times / no permissions required\n', '    function initializeDomainSeparator() public\n', '    {\n', '        uint id;\n', '        // solium-disable-next-line\n', '        assembly\n', '        {\n', '            id := chainid()\n', '        }\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n', '                keccak256(bytes(name())),\n', '                keccak256(bytes(version)),\n', '                id,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    /**\n', '     * Functions for our business logic\n', '     */\n', '\n', '    /// @notice Burn the amount of tokens from the address msg.sender if authorized.\n', '    /// @dev Note that this is not the same as a `sell` via the DAT.\n', '    function burn(\n', '        uint _amount\n', '    ) public\n', '    {\n', '        require(state == State.Run, "INVALID_STATE");\n', '        require(msg.sender == beneficiary, "BENEFICIARY_ONLY");\n', '        _burn(msg.sender, _amount, false);\n', '    }\n', '\n', '    // Buy\n', '\n', '    /// @notice Purchase FAIR tokens with the given amount of currency.\n', '    /// @param _to The account to receive the FAIR tokens from this purchase.\n', '    /// @param _currencyValue How much currency to spend in order to buy FAIR.\n', '    /// @param _minTokensBought Buy at least this many FAIR tokens or the transaction reverts.\n', '    /// @dev _minTokensBought is necessary as the price will change if some elses transaction mines after\n', '    /// yours was submitted.\n', '    function buy(\n', '        address _to,\n', '        uint _currencyValue,\n', '        uint _minTokensBought\n', '    ) public payable\n', '    {\n', '        _collectInvestment(payable(msg.sender), _currencyValue, msg.value);\n', '        //deduct gas fee and send it to feeCollector\n', '        uint256 currencyValue = _currencyValue - gasFee;\n', '        _transferCurrency(feeCollector, gasFee);\n', '        _buy(payable(msg.sender), _to, currencyValue, _minTokensBought, false);\n', '    }\n', '\n', '    /// @notice Allow users to sign a message authorizing a buy\n', '    function permitBuy(\n', '        address payable _from,\n', '        address _to,\n', '        uint _currencyValue,\n', '        uint _minTokensBought,\n', '        uint _deadline,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) external\n', '    {\n', '        require(_deadline >= block.timestamp, "EXPIRED");\n', '        bytes32 digest = keccak256(abi.encode(PERMIT_BUY_TYPEHASH, _from, _to, _currencyValue, _minTokensBought, nonces[_from]++, _deadline));\n', '        digest = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                digest\n', '            )\n', '        );\n', '        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n', '        require(recoveredAddress != address(0) && recoveredAddress == _from, "INVALID_SIGNATURE");\n', '        // CHECK !!! this is suspicious!! 0 should be msg.value but this is not payable function\n', '        // msg.value will be zero since it is non-payable function and designed to be used to usdc-base CAFE contract\n', '        _collectInvestment(_from, _currencyValue, 0);\n', '        uint256 currencyValue = _currencyValue - gasFee;\n', '        _transferCurrency(feeCollector, gasFee);\n', '        _buy(_from, _to, currencyValue, _minTokensBought, false);\n', '    }\n', '\n', '    function _buy(\n', '        address payable _from,\n', '        address _to,\n', '        uint _currencyValue,\n', '        uint _minTokensBought,\n', '        bool _manual\n', '    ) internal\n', '    {\n', '        require(_to != address(0), "INVALID_ADDRESS");\n', '        require(_to != beneficiary, "BENEFICIARY_CANNOT_BUY");\n', '        require(_minTokensBought > 0, "MUST_BUY_AT_LEAST_1");\n', '        require(state == State.Init || state == State.Run, "ONLY_BUY_IN_INIT_OR_RUN");\n', '        // Calculate the tokenValue for this investment\n', '        // returns zero if _currencyValue < minInvestment\n', '        uint tokenValue = _estimateBuyValue(_currencyValue);\n', '        require(tokenValue >= _minTokensBought, "PRICE_SLIPPAGE");\n', '        if(state == State.Init){\n', '            if(tokenValue + shareholdersPool < initTrial){\n', '                //already received all currency from _collectInvestment\n', '                if(!_manual) {\n', '                    initInvestors[_to] = initInvestors[_to] + tokenValue;\n', '                }\n', '                initTrial = initTrial - tokenValue;\n', '            }\n', '            else if (initTrial > shareholdersPool){\n', '                //already received all currency from _collectInvestment\n', '                //send setup fee to beneficiary\n', '                if(setupFee > 0){\n', '                    _transferCurrency(setupFeeRecipient, setupFee);\n', '                }\n', '                _distributeInvestment(buybackReserve() - manualBuybackReserve);\n', '                manualBuybackReserve = 0;\n', '                initTrial = shareholdersPool;\n', '                startedOn = block.timestamp;\n', '            }\n', '            else{\n', '                _distributeInvestment(buybackReserve() - manualBuybackReserve);\n', '                manualBuybackReserve = 0;\n', '            }\n', '        }\n', '        else { //state == State.Run\n', '            require(maxGoal == 0 || tokenValue + totalSupply() - stakeholdersPoolIssued <= maxGoal, "EXCEEDING_MAX_GOAL");\n', '            _distributeInvestment(buybackReserve() - manualBuybackReserve);\n', '            manualBuybackReserve = 0;\n', '            if(fundraisingGoal != 0){\n', '                if (tokenValue >= fundraisingGoal){\n', '                    changeBuySlope(totalSupply() - stakeholdersPoolIssued, fundraisingGoal + totalSupply() - stakeholdersPoolIssued);\n', '                    fundraisingGoal = 0;\n', '                } else { //if (tokenValue < fundraisingGoal) {\n', '                    changeBuySlope(totalSupply() - stakeholdersPoolIssued, tokenValue + totalSupply() - stakeholdersPoolIssued);\n', '                    fundraisingGoal -= tokenValue;\n', '                }\n', '            }\n', '        }\n', '\n', '        totalInvested = totalInvested + _currencyValue;\n', '\n', '        emit Buy(_from, _to, _currencyValue, tokenValue);\n', '        _mint(_to, tokenValue);\n', '\n', '        if(state == State.Init && totalSupply() - stakeholdersPoolIssued >= initGoal){\n', '            _stateChange(State.Run);\n', '        }\n', '    }\n', '\n', '    /// @dev Distributes _value currency between the beneficiary and feeCollector.\n', '    function _distributeInvestment(\n', '        uint _value\n', '    ) internal\n', '    {\n', '        uint fee = _value * feeBasisPoints;\n', '        fee /= BASIS_POINTS_DEN;\n', '\n', '        // Math: since feeBasisPoints is <= BASIS_POINTS_DEN, this will never underflow.\n', '        _transferCurrency(beneficiary, _value - fee);\n', '        _transferCurrency(feeCollector, fee);\n', '    }\n', '\n', '    function estimateBuyValue(\n', '        uint _currencyValue\n', '    ) external view\n', '    returns(uint)\n', '    {\n', '        return _estimateBuyValue(_currencyValue - gasFee);\n', '    }\n', '\n', '    /// @notice Calculate how many FAIR tokens you would buy with the given amount of currency if `buy` was called now.\n', '    /// @param _currencyValue How much currency to spend in order to buy FAIR.\n', '    function _estimateBuyValue(\n', '        uint _currencyValue\n', '    ) internal view\n', '    returns(uint)\n', '    {\n', '        if(_currencyValue < minInvestment){\n', '            return 0;\n', '        }\n', '        if(state == State.Init){\n', '            uint currencyValue = _currencyValue;\n', '            uint _totalSupply = totalSupply();\n', '            uint max = BigDiv.bigDiv2x1(\n', '                initGoal * buySlope.num,\n', '                initGoal - (_totalSupply - stakeholdersPoolIssued),\n', '                buySlope.den\n', '            );\n', '\n', '            if(currencyValue > max)\n', '            {\n', '                currencyValue = max;\n', '            }\n', '\n', '            uint256 tokenAmount = BigDiv.bigDiv2x1(\n', '                currencyValue,\n', '                buySlope.den,\n', '                initGoal * buySlope.num\n', '            );\n', '            if(currencyValue != _currencyValue)\n', '            {\n', '                currencyValue = _currencyValue - max;\n', '                // ((2*next_amount/buy_slope)+init_goal^2)^(1/2)-init_goal\n', '                // a: next_amount | currencyValue\n', '                // n/d: buy_slope (type(uint128).max / type(uint128).max)\n', '                // g: init_goal (type(uint128).max/2)\n', '                // r: init_reserve (type(uint128).max/2)\n', '                // sqrt(((2*a/(n/d))+g^2)-g\n', '                // sqrt((2 d a + n g^2)/n) - g\n', '\n', '                // currencyValue == 2 d a\n', '                uint temp = 2 * buySlope.den;\n', '                currencyValue = temp * currencyValue;\n', '\n', '                // temp == g^2\n', '                temp = initGoal;\n', '                temp *= temp;\n', '\n', '                // temp == n g^2\n', '                temp = temp * buySlope.num;\n', '\n', '                // temp == (2 d a) + n g^2\n', '                temp = currencyValue + temp;\n', '\n', '                // temp == (2 d a + n g^2)/n\n', '                temp /= buySlope.num;\n', '\n', '                // temp == sqrt((2 d a + n g^2)/n)\n', '                temp = temp.sqrt();\n', '\n', '                // temp == sqrt((2 d a + n g^2)/n) - g\n', '                temp -= initGoal;\n', '\n', '                tokenAmount = tokenAmount + temp;\n', '            }\n', '            return tokenAmount;\n', '        }\n', '        else if(state == State.Run) {//state == State.Run{\n', '            uint supply = totalSupply() - stakeholdersPoolIssued;\n', '            // calculate fundraising amount (static price)\n', '            uint currencyValue = _currencyValue;\n', '            uint fundraisedAmount;\n', '            if(fundraisingGoal > 0){\n', '                uint max = BigDiv.bigDiv2x1(\n', '                    supply,\n', '                    fundraisingGoal * buySlope.num,\n', '                    buySlope.den\n', '                );\n', '                if(currencyValue > max){\n', '                    currencyValue = max;\n', '                }\n', '                fundraisedAmount = BigDiv.bigDiv2x2(\n', '                    currencyValue,\n', '                    buySlope.den,\n', '                    supply,\n', '                    buySlope.num\n', '                );\n', '                //forward leftover currency to be used as normal buy\n', '                currencyValue = _currencyValue - currencyValue;\n', '            }\n', '\n', '            // initReserve is reduced on sell as necessary to ensure that this line will not overflow\n', '            // Math: worst case\n', '            // MAX * 2 * type(uint128).max\n', '            // / type(uint128).max\n', '            uint tokenAmount = BigDiv.bigDiv2x1(\n', '                currencyValue,\n', '                2 * buySlope.den,\n', '                buySlope.num\n', '            );\n', '\n', '            // Math: worst case MAX + (type(uint128).max * type(uint128).max)\n', '            tokenAmount = tokenAmount + supply * supply;\n', '            tokenAmount = tokenAmount.sqrt();\n', '\n', '            // Math: small chance of underflow due to possible rounding in sqrt\n', '            tokenAmount = tokenAmount - supply;\n', '            return fundraisedAmount + tokenAmount;\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    // Sell\n', '\n', '    /// @notice Sell FAIR tokens for at least the given amount of currency.\n', '    /// @param _to The account to receive the currency from this sale.\n', '    /// @param _quantityToSell How many FAIR tokens to sell for currency value.\n', '    /// @param _minCurrencyReturned Get at least this many currency tokens or the transaction reverts.\n', '    /// @dev _minCurrencyReturned is necessary as the price will change if some elses transaction mines after\n', '    /// yours was submitted.\n', '    function sell(\n', '        address payable _to,\n', '        uint _quantityToSell,\n', '        uint _minCurrencyReturned\n', '    ) public\n', '    {\n', '        _sell(msg.sender, _to, _quantityToSell, _minCurrencyReturned);\n', '    }\n', '\n', '    /// @notice Allow users to sign a message authorizing a sell\n', '    function permitSell(\n', '        address _from,\n', '        address payable _to,\n', '        uint _quantityToSell,\n', '        uint _minCurrencyReturned,\n', '        uint _deadline,\n', '        uint8 _v,\n', '        bytes32 _r,\n', '        bytes32 _s\n', '    ) external\n', '    {\n', '        require(_deadline >= block.timestamp, "EXPIRED");\n', '        bytes32 digest = keccak256(\n', '            abi.encode(PERMIT_SELL_TYPEHASH, _from, _to, _quantityToSell, _minCurrencyReturned, nonces[_from]++, _deadline)\n', '        );\n', '        digest = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                digest\n', '            )\n', '        );\n', '        address recoveredAddress = ecrecover(digest, _v, _r, _s);\n', '        require(recoveredAddress != address(0) && recoveredAddress == _from, "INVALID_SIGNATURE");\n', '        _sell(_from, _to, _quantityToSell, _minCurrencyReturned);\n', '    }\n', '\n', '    function _sell(\n', '        address _from,\n', '        address payable _to,\n', '        uint _quantityToSell,\n', '        uint _minCurrencyReturned\n', '    ) internal\n', '    {\n', '        require(_from != beneficiary, "BENEFICIARY_CANNOT_SELL");\n', '        require(state != State.Init || initTrial != shareholdersPool, "INIT_TRIAL_ENDED");\n', '        require(state == State.Init || state == State.Cancel, "ONLY_SELL_IN_INIT_OR_CANCEL");\n', '        require(_minCurrencyReturned > 0, "MUST_SELL_AT_LEAST_1");\n', '        // check for slippage\n', '        uint currencyValue = estimateSellValue(_quantityToSell);\n', '        require(currencyValue >= _minCurrencyReturned, "PRICE_SLIPPAGE");\n', '        // it will work as checking _from has morethan _quantityToSell as initInvestors\n', '        initInvestors[_from] = initInvestors[_from] - _quantityToSell;\n', '        _burn(_from, _quantityToSell, true);\n', '        _transferCurrency(_to, currencyValue);\n', '        if(state == State.Init && initTrial != 0){\n', '            // this can only happen if initTrial is set to zero from day one\n', '            initTrial = initTrial + _quantityToSell;\n', '        }\n', '        totalInvested = totalInvested - currencyValue;\n', '        emit Sell(_from, _to, currencyValue, _quantityToSell);\n', '    }\n', '\n', '    function estimateSellValue(\n', '        uint _quantityToSell\n', '    ) public view\n', '        returns(uint)\n', '    {\n', '        if(state != State.Init && state != State.Cancel){\n', '            return 0;\n', '        }\n', '        uint reserve = buybackReserve();\n', '\n', '        // Calculate currencyValue for this sale\n', '        uint currencyValue;\n', '        // State.Init or State.Cancel\n', '        // Math worst case:\n', '        // MAX * type(uint128).max\n', '        currencyValue = _quantityToSell * reserve;\n', '        // Math: FAIR blocks initReserve from being burned unless we reach the RUN state which prevents an underflow\n', '        currencyValue /= totalSupply() - stakeholdersPoolIssued - shareholdersPool;\n', '\n', '        return currencyValue;\n', '    }\n', '\n', '\n', '    // Close\n', '\n', '    /// @notice Called by the beneficiary account to State.Close or State.Cancel the c-org,\n', '    /// preventing any more tokens from being minted.\n', '    function close() public\n', '    {\n', '        _close();\n', '        emit Close();\n', '    }\n', '\n', '    /// @notice Called by the beneficiary account to State.Close or State.Cancel the c-org,\n', '    /// preventing any more tokens from being minted.\n', '    /// @dev Requires an `exitFee` to be paid.    If the currency is ETH, include a little more than\n', '    /// what appears to be required and any remainder will be returned to your account.    This is\n', '    /// because another user may have a transaction mined which changes the exitFee required.\n', '    /// For other `currency` types, the beneficiary account will be billed the exact amount required.\n', '    function _close() internal\n', '    {\n', '        require(msg.sender == beneficiary, "BENEFICIARY_ONLY");\n', '\n', '        if(state == State.Init)\n', '        {\n', '            // Allow the org to cancel anytime if the initGoal was not reached.\n', '            require(initTrial > shareholdersPool,"CANNOT_CANCEL_IF_INITTRIAL_IS_ZERO");\n', '            _stateChange(State.Cancel);\n', '        }\n', '        else if(state == State.Run)\n', '        {\n', '            require(type(uint256).max - minDuration > startedOn, "MAY_NOT_CLOSE");\n', '            require(minDuration + startedOn <= block.timestamp, "TOO_EARLY");\n', '            _stateChange(State.Close);\n', '        }\n', '        else\n', '        {\n', '            revert("INVALID_STATE");\n', '        }\n', '    }\n', '\n', '    /// @notice mint new CAFE and send them to `wallet`\n', '    function mint(\n', '        address _wallet,\n', '        uint256 _amount\n', '    ) external\n', '    {\n', '        require(msg.sender == beneficiary, "ONLY_BENEFICIARY_CAN_MINT");\n', '        require(\n', '            _amount + stakeholdersPoolIssued <= (stakeholdersPoolAuthorized * (totalSupply() + _amount)) / BASIS_POINTS_DEN,\n', '            "CANNOT_MINT_MORE_THAN_AUTHORIZED_PERCENTAGE"\n', '        );\n', '        //update stakeholdersPool issued value\n', '        stakeholdersPoolIssued = stakeholdersPoolIssued + _amount;\n', '        address to = _wallet == address(0) ? beneficiary : _wallet;\n', '        //check if wallet is whitelist in the _mint() function\n', '        _mint(to, _amount);\n', '    }\n', '\n', '    function manualBuy(\n', '        address payable _wallet,\n', '        uint256 _currencyValue\n', '    ) external\n', '    {\n', '        require(msg.sender == beneficiary, "ONLY_BENEFICIARY_CAN_MINT");\n', '        manualBuybackReserve += _currencyValue;\n', '        _buy(_wallet, _wallet, _currencyValue, 1, true);\n', '    }\n', '\n', '    function increaseCommitment(\n', '        uint256 _newCommitment,\n', '        uint256 _amount\n', '    ) external\n', '    {\n', '        require(state == State.Init || state == State.Run, "ONLY_IN_INIT_OR_RUN");\n', '        require(msg.sender == beneficiary, "ONLY_BENEFICIARY_CAN_INCREASE_COMMITMENT");\n', '        require(_newCommitment > 0, "COMMITMENT_CANT_BE_ZERO");\n', '        require(equityCommitment + _newCommitment <= BASIS_POINTS_DEN, "EQUITY_COMMITMENT_SHOULD_BE_LESS_THAN_100%");\n', '        equityCommitment = equityCommitment + _newCommitment;\n', '        if(_amount > 0 ){\n', '            if(state == State.Init){\n', '                changeBuySlope(initGoal, _amount + initGoal);\n', '                initGoal = initGoal + _amount;\n', '            } else {\n', '                fundraisingGoal = _amount;\n', '            }\n', '            if(maxGoal != 0){\n', '                maxGoal = maxGoal + _amount;\n', '            }\n', '        }\n', '    }\n', '\n', '    function convertToCafe(\n', '        uint256 _newCommitment,\n', '        uint256 _amount,\n', '        address _wallet\n', '    ) external {\n', '        require(state == State.Init || state == State.Run, "ONLY_IN_INIT_OR_RUN");\n', '        require(msg.sender == beneficiary, "ONLY_BENEFICIARY_CAN_INCREASE_COMMITMENT");\n', '        require(_newCommitment > 0, "COMMITMENT_CANT_BE_ZERO");\n', '        require(equityCommitment + _newCommitment <= BASIS_POINTS_DEN, "EQUITY_COMMITMENT_SHOULD_BE_LESS_THAN_100%");\n', '        require(_wallet != beneficiary && _wallet != address(0), "WALLET_CANNOT_BE_ZERO_OR_BENEFICIARY");\n', '        equityCommitment = equityCommitment + _newCommitment;\n', '        if(_amount > 0 ){\n', '            shareholdersPool = shareholdersPool + _amount;\n', '            if(state == State.Init){\n', '                changeBuySlope(initGoal, _amount + initGoal);\n', '                initGoal = initGoal + _amount;\n', '                if(initTrial != 0){\n', '                    initTrial = initTrial + _amount;\n', '                }\n', '            }\n', '            else {\n', '                changeBuySlope(totalSupply() - stakeholdersPoolIssued, _amount + totalSupply() - stakeholdersPoolIssued);\n', '            }\n', '            _mint(_wallet, _amount);\n', '            if(maxGoal != 0){\n', '                maxGoal = maxGoal + _amount;\n', '            }\n', '        }\n', '    }\n', '\n', '    function increaseValuation(uint256 _newValuation) external {\n', '        require(state == State.Init || state == State.Run, "ONLY_IN_INIT_OR_RUN");\n', '        require(msg.sender == beneficiary, "ONLY_BENEFICIARY_CAN_INCREASE_VALUATION");\n', '        uint256 oldValuation;\n', '        if(state == State.Init){\n', '            oldValuation = (initGoal * initGoal * buySlope.num * BASIS_POINTS_DEN) / (buySlope.den * equityCommitment);\n', '            require(_newValuation > oldValuation, "VALUATION_CAN_NOT_DECREASE");\n', '            changeBuySlope(_newValuation, oldValuation);\n', '        }else {\n', '            oldValuation = ((totalSupply() - stakeholdersPoolIssued) * (totalSupply() - stakeholdersPoolIssued) * buySlope.num * BASIS_POINTS_DEN) / (buySlope.den * equityCommitment);\n', '            require(_newValuation > oldValuation, "VALUATION_CAN_NOT_DECREASE");\n', '            changeBuySlope(_newValuation, oldValuation);\n', '        }\n', '    }\n', '\n', '    function changeBuySlope(uint256 _numerator, uint256 _denominator) internal {\n', '        require(_denominator > 0, "DIV_0");\n', '        if(_numerator == 0){\n', '            buySlope.num = 0;\n', '            return;\n', '        }\n', '        uint256 tryDen = BigDiv.bigDiv2x1(\n', '            buySlope.den,\n', '            _denominator,\n', '            _numerator\n', '        );\n', '        if(tryDen <= type(uint128).max){\n', '            buySlope.den = uint128(tryDen);\n', '            return;\n', '        }\n', '        //if den exceeds type(uint128).max try num\n', '        uint256 tryNum = BigDiv.bigDiv2x1(\n', '            buySlope.num,\n', '            _numerator,\n', '            _denominator\n', '        );\n', '        if(tryNum > 0 && tryNum <= type(uint128).max) {\n', '            buySlope.num = uint128(tryNum);\n', '            return;\n', '        }\n', '        revert("error while changing slope");\n', '    }\n', '\n', '    function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external {\n', '        require(msg.sender == beneficiary, "ONLY_BENEFICIARY_CAN_BATCH_TRANSFER");\n', '        require(recipients.length == amounts.length, "ARRAY_LENGTH_DIFF");\n', '        require(recipients.length <= MAX_ITERATION, "EXCEEDS_MAX_ITERATION");\n', '        for(uint256 i = 0; i<recipients.length; i++) {\n', '            _transfer(msg.sender, recipients[i], amounts[0]);\n', '        }\n', '    }\n', '\n', '    /// @notice Pay the organization on-chain without minting any tokens.\n', '    /// @dev This allows you to add funds directly to the buybackReserve.\n', '    receive() external payable {\n', '        require(address(currency) == address(0), "ONLY_FOR_CURRENCY_ETH");\n', '    }\n', '\n', '\n', '    // --- Approve by signature ---\n', '    // EIP-2612\n', '    // Original source: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint value,\n', '        uint deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external\n', '    {\n', '        require(deadline >= block.timestamp, "EXPIRED");\n', '        bytes32 digest = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\n', '        digest = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                digest\n', '            )\n', '        );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', '        require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNATURE");\n', '        _approve(owner, spender, value);\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}']