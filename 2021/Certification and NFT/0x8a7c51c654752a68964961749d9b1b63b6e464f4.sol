['// SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./HoldefiPausableOwnable.sol";\n', 'import "./HoldefiCollaterals.sol";\n', '\n', '\n', '/// @notice File: contracts/HoldefiPrices.sol\n', 'interface HoldefiPricesInterface {\n', '\tfunction getAssetValueFromAmount(address asset, uint256 amount) external view returns(uint256 value);\n', '\tfunction getAssetAmountFromValue(address asset, uint256 value) external view returns(uint256 amount);\t\n', '}\n', '\n', '/// @notice File: contracts/HoldefiSettings.sol\n', 'interface HoldefiSettingsInterface {\n', '\n', '\t/// @notice Markets Features\n', '\tstruct MarketSettings {\n', '\t\tbool isExist;\n', '\t\tbool isActive;      \n', '\n', '\t\tuint256 borrowRate;\n', '\t\tuint256 borrowRateUpdateTime;\n', '\n', '\t\tuint256 suppliersShareRate;\n', '\t\tuint256 suppliersShareRateUpdateTime;\n', '\n', '\t\tuint256 promotionRate;\n', '\t}\n', '\n', '\t/// @notice Collateral Features\n', '\tstruct CollateralSettings {\n', '\t\tbool isExist;\n', '\t\tbool isActive;    \n', '\n', '\t\tuint256 valueToLoanRate; \n', '\t\tuint256 VTLUpdateTime;\n', '\n', '\t\tuint256 penaltyRate;\n', '\t\tuint256 penaltyUpdateTime;\n', '\n', '\t\tuint256 bonusRate;\n', '\t}\n', '\n', '\tfunction getInterests(address market)\n', '\t\texternal\n', '\t\tview\n', '\t\treturns (uint256 borrowRate, uint256 supplyRateBase, uint256 promotionRate);\n', '\tfunction resetPromotionRate (address market) external;\n', '\tfunction getMarketsList() external view returns(address[] memory marketsList);\n', '\tfunction marketAssets(address market) external view returns(MarketSettings memory);\n', '\tfunction collateralAssets(address collateral) external view returns(CollateralSettings memory);\n', '}\n', '\n', '/// @title Main Holdefi contract\n', '/// @author Holdefi Team\n', '/// @dev The address of ETH considered as 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n', '/// @dev All indexes are scaled by (secondsPerYear * rateDecimals)\n', '/// @dev All values are based ETH price considered 1 and all values decimals considered 30\n', 'contract Holdefi is HoldefiPausableOwnable {\n', '\n', '\tusing SafeMath for uint256;\n', '\n', '\t/// @notice Markets are assets can be supplied and borrowed\n', '\tstruct Market {\n', '\t\tuint256 totalSupply;\n', '\n', '\t\tuint256 supplyIndex;      \t\t\t\t// Scaled by: secondsPerYear * rateDecimals\n', '\t\tuint256 supplyIndexUpdateTime;\n', '\n', '\t\tuint256 totalBorrow;\n', '\n', '\t\tuint256 borrowIndex;      \t\t\t\t// Scaled by: secondsPerYear * rateDecimals\n', '\t\tuint256 borrowIndexUpdateTime;\n', '\n', '\t\tuint256 promotionReserveScaled;      \t// Scaled by: secondsPerYear * rateDecimals\n', '\t\tuint256 promotionReserveLastUpdateTime;\n', '\n', '\t\tuint256 promotionDebtScaled;      \t\t// Scaled by: secondsPerYear * rateDecimals\n', '\t\tuint256 promotionDebtLastUpdateTime;\n', '\t}\n', '\n', '\t/// @notice Collaterals are assets can be used only as collateral for borrowing with no interest\n', '\tstruct Collateral {\n', '\t\tuint256 totalCollateral;\n', '\t\tuint256 totalLiquidatedCollateral;\n', '\t}\n', '\n', '\t/// @notice Users profile for each market\n', '\tstruct MarketAccount {\n', '\t\tmapping (address => uint) allowance;\n', '\t\tuint256 balance;\n', '\t\tuint256 accumulatedInterest;\n', '\n', '\t\tuint256 lastInterestIndex;      \t\t// Scaled by: secondsPerYear * rateDecimals\n', '\t}\n', '\n', '\t/// @notice Users profile for each collateral\n', '\tstruct CollateralAccount {\n', '\t\tmapping (address => uint) allowance;\n', '\t\tuint256 balance;\n', '\t\tuint256 lastUpdateTime;\n', '\t}\n', '\n', '\tstruct MarketData {\n', '\t\tuint256 balance;\n', '\t\tuint256 interest;\n', '\t\tuint256 currentIndex; \n', '\t}\n', '\n', '\taddress constant public ethAddress = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '\t/// @notice All rates in this contract are scaled by rateDecimals\n', '\tuint256 constant public rateDecimals = 10 ** 4;\n', '\n', '\tuint256 constant public secondsPerYear = 31536000;\n', '\n', '\t/// @dev For round up borrow interests\n', '\tuint256 constant private oneUnit = 1;\n', '\n', '\t/// @dev Used for calculating liquidation threshold \n', '\t/// @dev There is 5% gap between value to loan rate and liquidation rate\n', '\tuint256 constant private fivePercentLiquidationGap = 500;\n', '\n', '\t/// @notice Contract for getting protocol settings\n', '\tHoldefiSettingsInterface public holdefiSettings;\n', '\n', '\t/// @notice Contract for getting asset prices\n', '\tHoldefiPricesInterface public holdefiPrices;\n', '\n', '\t/// @notice Contract for holding collaterals\n', '\tHoldefiCollaterals public holdefiCollaterals;\n', '\n', '\t/// @dev Markets: marketAddress => marketDetails\n', '\tmapping (address => Market) public marketAssets;\n', '\n', '\t/// @dev Collaterals: collateralAddress => collateralDetails\n', '\tmapping (address => Collateral) public collateralAssets;\n', '\n', '\t/// @dev Markets Debt after liquidation: collateralAddress => marketAddress => marketDebtBalance\n', '\tmapping (address => mapping (address => uint)) public marketDebt;\n', '\n', '\t/// @dev Users Supplies: userAddress => marketAddress => supplyDetails\n', '\tmapping (address => mapping (address => MarketAccount)) private supplies;\n', '\n', '\t/// @dev Users Borrows: userAddress => collateralAddress => marketAddress => borrowDetails\n', '\tmapping (address => mapping (address => mapping (address => MarketAccount))) private borrows;\n', '\n', '\t/// @dev Users Collaterals: userAddress => collateralAddress => collateralDetails\n', '\tmapping (address => mapping (address => CollateralAccount)) private collaterals;\n', '\t\n', '\t// ----------- Events -----------\n', '\n', '\t/// @notice Event emitted when a market asset is supplied\n', '\tevent Supply(\n', '\t\taddress sender,\n', '\t\taddress indexed supplier,\n', '\t\taddress indexed market,\n', '\t\tuint256 amount,\n', '\t\tuint256 balance,\n', '\t\tuint256 interest,\n', '\t\tuint256 index,\n', '\t\tuint16 referralCode\n', '\t);\n', '\n', '\t/// @notice Event emitted when a supply is withdrawn\n', '\tevent WithdrawSupply(\n', '\t\taddress sender,\n', '\t\taddress indexed supplier,\n', '\t\taddress indexed market,\n', '\t\tuint256 amount,\n', '\t\tuint256 balance,\n', '\t\tuint256 interest,\n', '\t\tuint256 index\n', '\t);\n', '\n', '\t/// @notice Event emitted when a collateral asset is deposited\n', '\tevent Collateralize(\n', '\t\taddress sender,\n', '\t\taddress indexed collateralizer,\n', '\t\taddress indexed collateral,\n', '\t\tuint256 amount,\n', '\t\tuint256 balance\n', '\t);\n', '\n', '\t/// @notice Event emitted when a collateral is withdrawn\n', '\tevent WithdrawCollateral(\n', '\t\taddress sender,\n', '\t\taddress indexed collateralizer,\n', '\t\taddress indexed collateral,\n', '\t\tuint256 amount,\n', '\t\tuint256 balance\n', '\t);\n', '\n', '\t/// @notice Event emitted when a market asset is borrowed\n', '\tevent Borrow(\n', '\t\taddress sender,\n', '\t\taddress indexed borrower,\n', '\t\taddress indexed market,\n', '\t\taddress indexed collateral,\n', '\t\tuint256 amount,\n', '\t\tuint256 balance,\n', '\t\tuint256 interest,\n', '\t\tuint256 index,\n', '\t\tuint16 referralCode\n', '\t);\n', '\n', '\t/// @notice Event emitted when a borrow is repaid\n', '\tevent RepayBorrow(\n', '\t\taddress sender,\n', '\t\taddress indexed borrower,\n', '\t\taddress indexed market,\n', '\t\taddress indexed collateral,\n', '\t\tuint256 amount,\n', '\t\tuint256 balance,\n', '\t\tuint256 interest,\n', '\t\tuint256 index\n', '\t);\n', '\n', '\t/// @notice Event emitted when the supply index is updated for a market asset\n', '\tevent UpdateSupplyIndex(address indexed market, uint256 newSupplyIndex, uint256 supplyRate);\n', '\n', '\t/// @notice Event emitted when the borrow index is updated for a market asset\n', '\tevent UpdateBorrowIndex(address indexed market, uint256 newBorrowIndex);\n', '\n', '\t/// @notice Event emitted when a collateral is liquidated\n', '\tevent CollateralLiquidated(\n', '\t\taddress indexed borrower,\n', '\t\taddress indexed market,\n', '\t\taddress indexed collateral,\n', '\t\tuint256 marketDebt,\n', '\t\tuint256 liquidatedCollateral\n', '\t);\n', '\n', '\t/// @notice Event emitted when a liquidated collateral is purchased in exchange for the specified market\n', '\tevent BuyLiquidatedCollateral(\n', '\t\taddress indexed market,\n', '\t\taddress indexed collateral,\n', '\t\tuint256 marketAmount,\n', '\t\tuint256 collateralAmount\n', '\t);\n', '\n', '\t/// @notice Event emitted when HoldefiPrices contract is changed\n', '\tevent HoldefiPricesContractChanged(address newAddress, address oldAddress);\n', '\n', '\t/// @notice Event emitted when a liquidation reserve is withdrawn by the owner\n', '\tevent LiquidationReserveWithdrawn(address indexed collateral, uint256 amount);\n', '\n', '\t/// @notice Event emitted when a liquidation reserve is deposited\n', '\tevent LiquidationReserveDeposited(address indexed collateral, uint256 amount);\n', '\n', '\t/// @notice Event emitted when a promotion reserve is withdrawn by the owner\n', '\tevent PromotionReserveWithdrawn(address indexed market, uint256 amount);\n', '\n', '\t/// @notice Event emitted when a promotion reserve is deposited\n', '\tevent PromotionReserveDeposited(address indexed market, uint256 amount);\n', '\n', '\t/// @notice Event emitted when a promotion reserve is updated\n', '\tevent PromotionReserveUpdated(address indexed market, uint256 promotionReserve);\n', '\n', '\t/// @notice Event emitted when a promotion debt is updated\n', '\tevent PromotionDebtUpdated(address indexed market, uint256 promotionDebt);\n', '\n', '\t/// @notice Initializes the Holdefi contract\n', '    /// @param holdefiSettingsAddress Holdefi settings contract address\n', '    /// @param holdefiPricesAddress Holdefi prices contract address\n', '\tconstructor(\n', '\t\tHoldefiSettingsInterface holdefiSettingsAddress,\n', '\t\tHoldefiPricesInterface holdefiPricesAddress\n', '\t)\n', '\t\tpublic\n', '\t{\n', '\t\tholdefiSettings = holdefiSettingsAddress;\n', '\t\tholdefiPrices = holdefiPricesAddress;\n', '\t\tholdefiCollaterals = new HoldefiCollaterals();\n', '\t}\n', '\n', '\n', '\t/// @dev Modifier to check if the asset is ETH or not\n', '\t/// @param asset Address of the given asset\n', '    modifier isNotETHAddress(address asset) {\n', '        require (asset != ethAddress, "Asset should not be ETH address");\n', '        _;\n', '    }\n', '\n', '\t/// @dev Modifier to check if the market is active or not\n', '\t/// @param market Address of the given market\n', '    modifier marketIsActive(address market) {\n', '\t\trequire (holdefiSettings.marketAssets(market).isActive, "Market is not active");\n', '        _;\n', '    }\n', '\n', '\t/// @dev Modifier to check if the collateral is active or not\n', '\t/// @param collateral Address of the given collateral\n', '    modifier collateralIsActive(address collateral) {\n', '\t\trequire (holdefiSettings.collateralAssets(collateral).isActive, "Collateral is not active");\n', '        _;\n', '    }\n', '\n', '\t/// @dev Modifier to check if the account address is equal to the msg.sender or not\n', '    /// @param account The given account address\n', '    modifier accountIsValid(address account) {\n', '\t\trequire (msg.sender != account, "Account is not valid");\n', '        _;\n', '    }\n', '\n', '    receive() external payable {\n', '        revert();\n', '    }\n', '\n', '\t/// @notice Returns balance and interest of an account for a given market\n', '    /// @dev supplyInterest = accumulatedInterest + (balance * (marketSupplyIndex - userLastSupplyInterestIndex))\n', '    /// @param account Supplier address to get supply information\n', '    /// @param market Address of the given market\n', '    /// @return balance Supplied amount on the specified market\n', '    /// @return interest Profit earned\n', '    /// @return currentSupplyIndex Supply index for the given market at current time\n', '\tfunction getAccountSupply(address account, address market)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256 balance, uint256 interest, uint256 currentSupplyIndex)\n', '\t{\n', '\t\tbalance = supplies[account][market].balance;\n', '\n', '\t\t(currentSupplyIndex,,) = getCurrentSupplyIndex(market);\n', '\n', '\t\tuint256 deltaInterestIndex = currentSupplyIndex.sub(supplies[account][market].lastInterestIndex);\n', '\t\tuint256 deltaInterestScaled = deltaInterestIndex.mul(balance);\n', '\t\tuint256 deltaInterest = deltaInterestScaled.div(secondsPerYear).div(rateDecimals);\n', '\t\t\n', '\t\tinterest = supplies[account][market].accumulatedInterest.add(deltaInterest);\n', '\t}\n', '\n', '\t/// @notice Returns balance and interest of an account for a given market on a given collateral\n', '    /// @dev borrowInterest = accumulatedInterest + (balance * (marketBorrowIndex - userLastBorrowInterestIndex))\n', '    /// @param account Borrower address to get Borrow information\n', '    /// @param market Address of the given market\n', '    /// @param collateral Address of the given collateral\n', '    /// @return balance Borrowed amount on the specified market\n', '    /// @return interest The amount of interest the borrower should pay\n', '    /// @return currentBorrowIndex Borrow index for the given market at current time\n', '\tfunction getAccountBorrow(address account, address market, address collateral)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256 balance, uint256 interest, uint256 currentBorrowIndex)\n', '\t{\n', '\t\tbalance = borrows[account][collateral][market].balance;\n', '\n', '\t\t(currentBorrowIndex,,) = getCurrentBorrowIndex(market);\n', '\n', '\t\tuint256 deltaInterestIndex =\n', '\t\t\tcurrentBorrowIndex.sub(borrows[account][collateral][market].lastInterestIndex);\n', '\n', '\t\tuint256 deltaInterestScaled = deltaInterestIndex.mul(balance);\n', '\t\tuint256 deltaInterest = deltaInterestScaled.div(secondsPerYear).div(rateDecimals);\n', '\t\tif (balance > 0) {\n', '\t\t\tdeltaInterest = deltaInterest.add(oneUnit);\n', '\t\t}\n', '\n', '\t\tinterest = borrows[account][collateral][market].accumulatedInterest.add(deltaInterest);\n', '\t}\n', '\n', '\n', '\t/// @notice Returns collateral balance, time since last activity, borrow power, total borrow value, and liquidation status for a given collateral\n', '    /// @dev borrowPower = (collateralValue / collateralValueToLoanRate) - totalBorrowValue\n', '    /// @dev liquidationThreshold = collateralValueToLoanRate - 5%\n', '    /// @dev User will be in liquidation state if (collateralValue / totalBorrowValue) < liquidationThreshold\n', '    /// @param account Account address to get collateral information\n', '    /// @param collateral Address of the given collateral\n', '    /// @return balance Amount of the specified collateral\n', '    /// @return timeSinceLastActivity Time since last activity performed by the account\n', '    /// @return borrowPowerValue The borrowing power for the account of the given collateral\n', '    /// @return totalBorrowValue Accumulative borrowed values on the given collateral\n', '    /// @return underCollateral A boolean value indicates whether the user is in the liquidation state or not\n', '\tfunction getAccountCollateral(address account, address collateral)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (\n', '\t\t\tuint256 balance,\n', '\t\t\tuint256 timeSinceLastActivity,\n', '\t\t\tuint256 borrowPowerValue,\n', '\t\t\tuint256 totalBorrowValue,\n', '\t\t\tbool underCollateral\n', '\t\t)\n', '\t{\n', '\t\tuint256 valueToLoanRate = holdefiSettings.collateralAssets(collateral).valueToLoanRate;\n', '\t\tif (valueToLoanRate == 0) {\n', '\t\t\treturn (0, 0, 0, 0, false);\n', '\t\t}\n', '\n', '\t\tbalance = collaterals[account][collateral].balance;\n', '\n', '\t\tuint256 collateralValue = holdefiPrices.getAssetValueFromAmount(collateral, balance);\n', '\t\tuint256 liquidationThresholdRate = valueToLoanRate.sub(fivePercentLiquidationGap);\n', '\n', '\t\tuint256 totalBorrowPowerValue = collateralValue.mul(rateDecimals).div(valueToLoanRate);\n', '\t\tuint256 liquidationThresholdValue = collateralValue.mul(rateDecimals).div(liquidationThresholdRate);\n', '\n', '\t\ttotalBorrowValue = getAccountTotalBorrowValue(account, collateral);\n', '\t\tif (totalBorrowValue > 0) {\n', '\t\t\ttimeSinceLastActivity = block.timestamp.sub(collaterals[account][collateral].lastUpdateTime);\n', '\t\t}\n', '\n', '\t\tborrowPowerValue = 0;\n', '\t\tif (totalBorrowValue < totalBorrowPowerValue) {\n', '\t\t\tborrowPowerValue = totalBorrowPowerValue.sub(totalBorrowValue);\n', '\t\t}\n', '\n', '\t\tunderCollateral = false;\t\n', '\t\tif (totalBorrowValue > liquidationThresholdValue) {\n', '\t\t\tunderCollateral = true;\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Returns maximum amount spender can withdraw from account supplies on a given market\n', '\t/// @param account Supplier address\n', '\t/// @param spender Spender address\n', '\t/// @param market Address of the given market\n', '\t/// @return res Maximum amount spender can withdraw from account supplies on a given market\n', '\tfunction getAccountWithdrawSupplyAllowance (address account, address spender, address market)\n', '\t\texternal \n', '\t\tview\n', '\t\treturns (uint256 res)\n', '\t{\n', '\t\tres = supplies[account][market].allowance[spender];\n', '\t}\n', '\n', '\t/// @notice Returns maximum amount spender can withdraw from account balance on a given collateral\n', '\t/// @param account Account address\n', '\t/// @param spender Spender address\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @return res Maximum amount spender can withdraw from account balance on a given collateral\n', '\tfunction getAccountWithdrawCollateralAllowance (\n', '\t\taddress account, \n', '\t\taddress spender, \n', '\t\taddress collateral\n', '\t)\n', '\t\texternal \n', '\t\tview\n', '\t\treturns (uint256 res)\n', '\t{\n', '\t\tres = collaterals[account][collateral].allowance[spender];\n', '\t}\n', '\n', '\t/// @notice Returns maximum amount spender can withdraw from account borrows on a given market based on a given collteral\n', '\t/// @param account Borrower address\n', '\t/// @param spender Spender address\n', '\t/// @param market Address of the given market\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @return res Maximum amount spender can withdraw from account borrows on a given market based on a given collteral\n', '\tfunction getAccountBorrowAllowance (\n', '\t\taddress account, \n', '\t\taddress spender, \n', '\t\taddress market, \n', '\t\taddress collateral\n', '\t)\n', '\t\texternal \n', '\t\tview\n', '\t\treturns (uint256 res)\n', '\t{\n', '\t\tres = borrows[account][collateral][market].allowance[spender];\n', '\t}\n', '\n', '\t/// @notice Returns total borrow value of an account based on a given collateral \n', '\t/// @param account Account address\n', '    /// @param collateral Address of the given collateral\n', '    /// @return totalBorrowValue Accumulative borrowed values on the given collateral\n', '\tfunction getAccountTotalBorrowValue (address account, address collateral)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256 totalBorrowValue)\n', '\t{\n', '\t\tMarketData memory borrowData;\n', '\t\taddress market;\n', '\t\tuint256 totalDebt;\n', '\t\tuint256 assetValue;\n', '\t\t\n', '\t\ttotalBorrowValue = 0;\n', '\t\taddress[] memory marketsList = holdefiSettings.getMarketsList();\n', '\t\tfor (uint256 i = 0 ; i < marketsList.length ; i++) {\n', '\t\t\tmarket = marketsList[i];\n', '\t\t\t\n', '\t\t\t(borrowData.balance, borrowData.interest,) = getAccountBorrow(account, market, collateral);\n', '\t\t\ttotalDebt = borrowData.balance.add(borrowData.interest);\n', '\n', '\t\t\tassetValue = holdefiPrices.getAssetValueFromAmount(market, totalDebt);\n', '\t\t\ttotalBorrowValue = totalBorrowValue.add(assetValue);\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice The collateral reserve amount for buying liquidated collateral\n', '    /// @param collateral Address of the given collateral\n', '    /// @return reserve Liquidation reserves for the given collateral\n', '\tfunction getLiquidationReserve (address collateral) public view returns(uint256 reserve) {\n', '\t\taddress market;\n', '\t\tuint256 assetValue;\n', '\t\tuint256 totalDebtValue = 0;\n', '\n', '\t\taddress[] memory marketsList = holdefiSettings.getMarketsList();\n', '\t\tfor (uint256 i = 0 ; i < marketsList.length ; i++) {\n', '\t\t\tmarket = marketsList[i];\n', '\t\t\tassetValue = holdefiPrices.getAssetValueFromAmount(market, marketDebt[collateral][market]);\n', '\t\t\ttotalDebtValue = totalDebtValue.add(assetValue); \n', '\t\t}\n', '\n', '\t\tuint256 bonusRate = holdefiSettings.collateralAssets(collateral).bonusRate;\n', '\t\tuint256 totalDebtCollateralValue = totalDebtValue.mul(bonusRate).div(rateDecimals);\n', '\t\tuint256 liquidatedCollateralNeeded = holdefiPrices.getAssetAmountFromValue(\n', '\t\t\tcollateral,\n', '\t\t\ttotalDebtCollateralValue\n', '\t\t);\n', '\t\t\n', '\t\treserve = 0;\n', '\t\tuint256 totalLiquidatedCollateral = collateralAssets[collateral].totalLiquidatedCollateral;\n', '\t\tif (totalLiquidatedCollateral > liquidatedCollateralNeeded) {\n', '\t\t\treserve = totalLiquidatedCollateral.sub(liquidatedCollateralNeeded);\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Returns the amount of discounted collateral can be bought in exchange for the amount of a given market\n', '    /// @param market Address of the given market\n', '    /// @param collateral Address of the given collateral\n', '    /// @param marketAmount The amount of market should be paid\n', '    /// @return collateralAmountWithDiscount Amount of discounted collateral can be bought\n', '\tfunction getDiscountedCollateralAmount (address market, address collateral, uint256 marketAmount)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256 collateralAmountWithDiscount)\n', '\t{\n', '\t\tuint256 marketValue = holdefiPrices.getAssetValueFromAmount(market, marketAmount);\n', '\t\tuint256 bonusRate = holdefiSettings.collateralAssets(collateral).bonusRate;\n', '\t\tuint256 collateralValue = marketValue.mul(bonusRate).div(rateDecimals);\n', '\n', '\t\tcollateralAmountWithDiscount = holdefiPrices.getAssetAmountFromValue(collateral, collateralValue);\n', '\t}\n', '\n', '\t/// @notice Returns supply index and supply rate for a given market at current time\n', '\t/// @dev newSupplyIndex = oldSupplyIndex + (deltaTime * supplyRate)\n', '    /// @param market Address of the given market\n', '    /// @return supplyIndex Supply index of the given market\n', '    /// @return supplyRate Supply rate of the given market\n', '    /// @return currentTime Current block timestamp\n', '\tfunction getCurrentSupplyIndex (address market)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (\n', '\t\t\tuint256 supplyIndex,\n', '\t\t\tuint256 supplyRate,\n', '\t\t\tuint256 currentTime\n', '\t\t)\n', '\t{\n', '\t\t(, uint256 supplyRateBase, uint256 promotionRate) = holdefiSettings.getInterests(market);\n', '\t\t\n', '\t\tcurrentTime = block.timestamp;\n', '\t\tuint256 deltaTimeSupply = currentTime.sub(marketAssets[market].supplyIndexUpdateTime);\n', '\n', '\t\tsupplyRate = supplyRateBase.add(promotionRate);\n', '\t\tuint256 deltaTimeInterest = deltaTimeSupply.mul(supplyRate);\n', '\t\tsupplyIndex = marketAssets[market].supplyIndex.add(deltaTimeInterest);\n', '\t}\n', '\n', '\t/// @notice Returns borrow index and borrow rate for the given market at current time\n', '\t/// @dev newBorrowIndex = oldBorrowIndex + (deltaTime * borrowRate)\n', '    /// @param market Address of the given market\n', '    /// @return borrowIndex Borrow index of the given market\n', '    /// @return borrowRate Borrow rate of the given market\n', '    /// @return currentTime Current block timestamp\n', '\tfunction getCurrentBorrowIndex (address market)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (\n', '\t\t\tuint256 borrowIndex,\n', '\t\t\tuint256 borrowRate,\n', '\t\t\tuint256 currentTime\n', '\t\t)\n', '\t{\n', '\t\tborrowRate = holdefiSettings.marketAssets(market).borrowRate;\n', '\t\t\n', '\t\tcurrentTime = block.timestamp;\n', '\t\tuint256 deltaTimeBorrow = currentTime.sub(marketAssets[market].borrowIndexUpdateTime);\n', '\n', '\t\tuint256 deltaTimeInterest = deltaTimeBorrow.mul(borrowRate);\n', '\t\tborrowIndex = marketAssets[market].borrowIndex.add(deltaTimeInterest);\n', '\t}\n', '\n', '\t/// @notice Returns promotion reserve for a given market at current time\n', '\t/// @dev promotionReserveScaled is scaled by (secondsPerYear * rateDecimals)\n', '\t/// @param market Address of the given market\n', '    /// @return promotionReserveScaled Promotion reserve of the given market\n', '    /// @return currentTime Current block timestamp\n', '\tfunction getPromotionReserve (address market)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256 promotionReserveScaled, uint256 currentTime)\n', '\t{\n', '\t\t(uint256 borrowRate, uint256 supplyRateBase,) = holdefiSettings.getInterests(market);\n', '\t\tcurrentTime = block.timestamp;\n', '\t\n', '\t\tuint256 allSupplyInterest = marketAssets[market].totalSupply.mul(supplyRateBase);\n', '\t\tuint256 allBorrowInterest = marketAssets[market].totalBorrow.mul(borrowRate);\n', '\n', '\t\tuint256 deltaTime = currentTime.sub(marketAssets[market].promotionReserveLastUpdateTime);\n', '\t\tuint256 currentInterest = allBorrowInterest.sub(allSupplyInterest);\n', '\t\tuint256 deltaTimeInterest = currentInterest.mul(deltaTime);\n', '\t\tpromotionReserveScaled = marketAssets[market].promotionReserveScaled.add(deltaTimeInterest);\n', '\t}\n', '\n', '\t/// @notice Returns promotion debt for a given market at current time\n', '\t/// @dev promotionDebtScaled is scaled by secondsPerYear * rateDecimals\n', '\t/// @param market Address of the given market\n', '    /// @return promotionDebtScaled Promotion debt of the given market\n', '    /// @return currentTime Current block timestamp\n', '\tfunction getPromotionDebt (address market)\n', '\t\tpublic\n', '\t\tview\n', '\t\treturns (uint256 promotionDebtScaled, uint256 currentTime)\n', '\t{\n', '\t\tuint256 promotionRate = holdefiSettings.marketAssets(market).promotionRate;\n', '\n', '\t\tcurrentTime = block.timestamp;\n', '\t\tpromotionDebtScaled = marketAssets[market].promotionDebtScaled;\n', '\n', '\t\tif (promotionRate != 0) {\n', '\t\t\tuint256 deltaTime = block.timestamp.sub(marketAssets[market].promotionDebtLastUpdateTime);\n', '\t\t\tuint256 currentInterest = marketAssets[market].totalSupply.mul(promotionRate);\n', '\t\t\tuint256 deltaTimeInterest = currentInterest.mul(deltaTime);\n', '\t\t\tpromotionDebtScaled = promotionDebtScaled.add(deltaTimeInterest);\n', '\t\t}\n', '\t}\n', '\n', '\t/// @notice Update a market supply index, promotion reserve, and promotion debt\n', '\t/// @param market Address of the given market\n', '\tfunction beforeChangeSupplyRate (address market) public {\n', '\t\tupdateSupplyIndex(market);\n', '\t\tupdatePromotionReserve(market);\n', '\t\tupdatePromotionDebt(market);\n', '\t}\n', '\n', '\t/// @notice Update a market borrow index, supply index, promotion reserve, and promotion debt \n', '\t/// @param market Address of the given market\n', '\tfunction beforeChangeBorrowRate (address market) external {\n', '\t\tupdateBorrowIndex(market);\n', '\t\tbeforeChangeSupplyRate(market);\n', '\t}\n', '\n', '\t/// @notice Deposit ERC20 asset for supplying\n', '\t/// @param market Address of the given market\n', '\t/// @param amount The amount of asset supplier supplies\n', '\t/// @param referralCode A unique code used as an identifier of referrer\n', '\tfunction supply(address market, uint256 amount, uint16 referralCode)\n', '\t\texternal\n', '\t\tisNotETHAddress(market)\n', '\t{\n', '\t\tsupplyInternal(msg.sender, market, amount, referralCode);\n', '\t}\n', '\n', '\t/// @notice Deposit ETH for supplying\n', '\t/// @notice msg.value The amount of asset supplier supplies\n', '\t/// @param referralCode A unique code used as an identifier of referrer\n', '\tfunction supply(uint16 referralCode) external payable {\t\t\n', '\t\tsupplyInternal(msg.sender, ethAddress, msg.value, referralCode);\n', '\t}\n', '\n', '\t/// @notice Sender deposits ERC20 asset belonging to the supplier\n', '\t/// @param account Address of the supplier\n', '\t/// @param market Address of the given market\n', '\t/// @param amount The amount of asset supplier supplies\n', '\t/// @param referralCode A unique code used as an identifier of referrer\n', '\tfunction supplyBehalf(address account, address market, uint256 amount, uint16 referralCode)\n', '\t\texternal\n', '\t\tisNotETHAddress(market)\n', '\t{\n', '\t\tsupplyInternal(account, market, amount, referralCode);\n', '\t}\n', '\n', '\t/// @notice Sender deposits ETH belonging to the supplier\n', '\t/// @notice msg.value The amount of ETH sender deposits belonging to the supplier\n', '\t/// @param account Address of the supplier\n', '\t/// @param referralCode A unique code used as an identifier of referrer\n', '\tfunction supplyBehalf(address account, uint16 referralCode) \n', '\t\texternal\n', '\t\tpayable\n', '\t{\n', '\t\tsupplyInternal(account, ethAddress, msg.value, referralCode);\n', '\t}\n', '\n', '\t/// @notice Sender approves of the withdarawl for the account in the market asset\n', '\t/// @param account Address of the account allowed to withdrawn\n', '\t/// @param market Address of the given market\n', '\t/// @param amount The amount is allowed to withdrawn\n', '\tfunction approveWithdrawSupply(address account, address market, uint256 amount)\n', '\t\texternal\n', '\t\taccountIsValid(account)\n', '\t\tmarketIsActive(market)\n', '\t{\n', '\t\tsupplies[msg.sender][market].allowance[account] = amount;\n', '\t}\n', '\n', '\t/// @notice Withdraw supply of a given market\n', '\t/// @param market Address of the given market\n', '\t/// @param amount The amount will be withdrawn from the market\n', '\tfunction withdrawSupply(address market, uint256 amount)\n', '\t\texternal\n', '\t{\n', '\t\twithdrawSupplyInternal(msg.sender, market, amount);\n', '\t}\n', '\n', '\t/// @notice Sender withdraws supply belonging to the supplier\n', '\t/// @param account Address of the supplier\n', '\t/// @param market Address of the given market\n', '\t/// @param amount The amount will be withdrawn from the market\n', '\tfunction withdrawSupplyBehalf(address account, address market, uint256 amount) external {\n', '\t\tuint256 allowance = supplies[account][market].allowance[msg.sender];\n', '\t\trequire(\n', '\t\t\tamount <= allowance, \n', '\t\t\t"Withdraw not allowed"\n', '\t\t);\n', '\t\tsupplies[account][market].allowance[msg.sender] = allowance.sub(amount);\n', '\t\twithdrawSupplyInternal(account, market, amount);\n', '\t}\n', '\n', '\t/// @notice Deposit ERC20 asset as a collateral\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount will be collateralized\n', '\tfunction collateralize (address collateral, uint256 amount)\n', '\t\texternal\n', '\t\tisNotETHAddress(collateral)\n', '\t{\n', '\t\tcollateralizeInternal(msg.sender, collateral, amount);\n', '\t}\n', '\n', '\t/// @notice Deposit ETH as a collateral\n', '\t/// @notice msg.value The amount of ETH will be collateralized\n', '\tfunction collateralize () external payable {\n', '\t\tcollateralizeInternal(msg.sender, ethAddress, msg.value);\n', '\t}\n', '\n', '\t/// @notice Sender deposits ERC20 asset as a collateral belonging to the user\n', '\t/// @param account Address of the user\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount will be collateralized\n', '\tfunction collateralizeBehalf (address account, address collateral, uint256 amount)\n', '\t\texternal\n', '\t\tisNotETHAddress(collateral)\n', '\t{\n', '\t\tcollateralizeInternal(account, collateral, amount);\n', '\t}\n', '\n', '\t/// @notice Sender deposits ETH as a collateral belonging to the user\n', '\t/// @notice msg.value The amount of ETH Sender deposits as a collateral belonging to the user\n', '\t/// @param account Address of the user\n', '\tfunction collateralizeBehalf (address account) external payable {\n', '\t\tcollateralizeInternal(account, ethAddress, msg.value);\n', '\t}\n', '\n', '\t/// @notice Sender approves the account to withdraw the collateral\n', '\t/// @param account Address is allowed to withdraw the collateral\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount is allowed to withdrawn\n', '\tfunction approveWithdrawCollateral (address account, address collateral, uint256 amount)\n', '\t\texternal\n', '\t\taccountIsValid(account)\n', '\t\tcollateralIsActive(collateral)\n', '\t{\n', '\t\tcollaterals[msg.sender][collateral].allowance[account] = amount;\n', '\t}\n', '\n', '\t/// @notice Withdraw a collateral\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount will be withdrawn from the collateral\n', '\tfunction withdrawCollateral (address collateral, uint256 amount)\n', '\t\texternal\n', '\t{\n', '\t\twithdrawCollateralInternal(msg.sender, collateral, amount);\n', '\t}\n', '\n', '\t/// @notice Sender withdraws a collateral belonging to the user\n', '\t/// @param account Address of the user\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount will be withdrawn from the collateral\n', '\tfunction withdrawCollateralBehalf (address account, address collateral, uint256 amount)\n', '\t\texternal\n', '\t{\n', '\t\tuint256 allowance = collaterals[account][collateral].allowance[msg.sender];\n', '\t\trequire(\n', '\t\t\tamount <= allowance,\n', '\t\t\t"Withdraw not allowed"\n', '\t\t);\n', '\t\tcollaterals[account][collateral].allowance[msg.sender] = allowance.sub(amount);\n', '\t\twithdrawCollateralInternal(account, collateral, amount);\n', '\t}\n', '\n', '\t/// @notice Sender approves the account to borrow a given market based on given collateral\n', '\t/// @param account Address that is allowed to borrow the given market\n', '\t/// @param market Address of the given market\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount is allowed to withdrawn\n', '\tfunction approveBorrow (address account, address market, address collateral, uint256 amount)\n', '\t\texternal\n', '\t\taccountIsValid(account)\n', '\t\tmarketIsActive(market)\n', '\t{\n', '\t\tborrows[msg.sender][collateral][market].allowance[account] = amount;\n', '\t}\n', '\n', '\t/// @notice Borrow an asset\n', '\t/// @param market Address of the given market\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount of the given market will be borrowed\n', '\t/// @param referralCode A unique code used as an identifier of referrer\n', '\tfunction borrow (address market, address collateral, uint256 amount, uint16 referralCode)\n', '\t\texternal\n', '\t{\n', '\t\tborrowInternal(msg.sender, market, collateral, amount, referralCode);\n', '\t}\n', '\n', '\t/// @notice Sender borrows an asset belonging to the borrower\n', '\t/// @param account Address of the borrower\n', '\t/// @param market Address of the given market\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount will be borrowed\n', '\t/// @param referralCode A unique code used as an identifier of referrer\n', '\tfunction borrowBehalf (address account, address market, address collateral, uint256 amount, uint16 referralCode)\n', '\t\texternal\n', '\t{\n', '\t\tuint256 allowance = borrows[account][collateral][market].allowance[msg.sender];\n', '\t\trequire(\n', '\t\t\tamount <= allowance,\n', '\t\t\t"Withdraw not allowed"\n', '\t\t);\n', '\t\tborrows[account][collateral][market].allowance[msg.sender] = allowance.sub(amount);\n', '\t\tborrowInternal(account, market, collateral, amount, referralCode);\n', '\t}\n', '\n', '\t/// @notice Repay an ERC20 asset based on a given collateral\n', '\t/// @param market Address of the given market\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount of the market will be Repaid\n', '\tfunction repayBorrow (address market, address collateral, uint256 amount)\n', '\t\texternal\n', '\t\tisNotETHAddress(market)\n', '\t{\n', '\t\trepayBorrowInternal(msg.sender, market, collateral, amount);\n', '\t}\n', '\n', '\t/// @notice Repay an ETH based on a given collateral\n', '\t/// @notice msg.value The amount of ETH will be repaid\n', '\t/// @param collateral Address of the given collateral\n', '\tfunction repayBorrow (address collateral) external payable {\t\t\n', '\t\trepayBorrowInternal(msg.sender, ethAddress, collateral, msg.value);\n', '\t}\n', '\n', '\t/// @notice Sender repays an ERC20 asset based on a given collateral belonging to the borrower\n', '\t/// @param account Address of the borrower\n', '\t/// @param market Address of the given market\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount of the market will be repaid\n', '\tfunction repayBorrowBehalf (address account, address market, address collateral, uint256 amount)\n', '\t\texternal\n', '\t\tisNotETHAddress(market)\n', '\t{\n', '\t\trepayBorrowInternal(account, market, collateral, amount);\n', '\t}\n', '\n', '\t/// @notice Sender repays an ETH based on a given collateral belonging to the borrower\n', '\t/// @notice msg.value The amount of ETH sender repays belonging to the borrower\n', '\t/// @param account Address of the borrower\n', '\t/// @param collateral Address of the given collateral\n', '\tfunction repayBorrowBehalf (address account, address collateral)\n', '\t\texternal\n', '\t\tpayable\n', '\t{\t\t\n', '\t\trepayBorrowInternal(account, ethAddress, collateral, msg.value);\n', '\t}\n', '\n', "\t/// @notice Liquidate borrower's collateral\n", '\t/// @param borrower Address of the borrower who should be liquidated\n', '\t/// @param market Address of the given market\n', '\t/// @param collateral Address of the given collateral\n', '\tfunction liquidateBorrowerCollateral (address borrower, address market, address collateral)\n', '\t\texternal\n', '\t\twhenNotPaused("liquidateBorrowerCollateral")\n', '\t{\n', '\t\tMarketData memory borrowData;\n', '\t\t(borrowData.balance, borrowData.interest,) = getAccountBorrow(borrower, market, collateral);\n', '\t\trequire(borrowData.balance > 0, "User should have debt");\n', '\n', '\t\t(uint256 collateralBalance, uint256 timeSinceLastActivity,,, bool underCollateral) = \n', '\t\t\tgetAccountCollateral(borrower, collateral);\n', '\t\trequire (underCollateral || (timeSinceLastActivity > secondsPerYear),\n', '\t\t\t"User should be under collateral or time is over"\n', '\t\t);\n', '\n', '\t\tuint256 totalBorrowedBalance = borrowData.balance.add(borrowData.interest);\n', '\t\tuint256 totalBorrowedBalanceValue = holdefiPrices.getAssetValueFromAmount(market, totalBorrowedBalance);\n', '\t\t\n', '\t\tuint256 liquidatedCollateralValue = totalBorrowedBalanceValue\n', '\t\t.mul(holdefiSettings.collateralAssets(collateral).penaltyRate)\n', '\t\t.div(rateDecimals);\n', '\n', '\t\tuint256 liquidatedCollateral =\n', '\t\t\tholdefiPrices.getAssetAmountFromValue(collateral, liquidatedCollateralValue);\n', '\n', '\t\tif (liquidatedCollateral > collateralBalance) {\n', '\t\t\tliquidatedCollateral = collateralBalance;\n', '\t\t}\n', '\n', '\t\tcollaterals[borrower][collateral].balance = collateralBalance.sub(liquidatedCollateral);\n', '\t\tcollateralAssets[collateral].totalCollateral =\n', '\t\t\tcollateralAssets[collateral].totalCollateral.sub(liquidatedCollateral);\n', '\t\tcollateralAssets[collateral].totalLiquidatedCollateral =\n', '\t\t\tcollateralAssets[collateral].totalLiquidatedCollateral.add(liquidatedCollateral);\n', '\n', '\t\tdelete borrows[borrower][collateral][market];\n', '\t\tbeforeChangeSupplyRate(market);\n', '\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.sub(borrowData.balance);\n', '\t\tmarketDebt[collateral][market] = marketDebt[collateral][market].add(totalBorrowedBalance);\n', '\n', '\t\temit CollateralLiquidated(borrower, market, collateral, totalBorrowedBalance, liquidatedCollateral);\t\n', '\t}\n', '\n', '\t/// @notice Buy collateral in exchange for ERC20 asset\n', '\t/// @param market Address of the market asset should be paid to buy collateral\n', '\t/// @param collateral Address of the liquidated collateral\n', '\t/// @param marketAmount The amount of the given market will be paid\n', '\tfunction buyLiquidatedCollateral (address market, address collateral, uint256 marketAmount)\n', '\t\texternal\n', '\t\tisNotETHAddress(market)\n', '\t{\n', '\t\tbuyLiquidatedCollateralInternal(market, collateral, marketAmount);\n', '\t}\n', '\n', '\t/// @notice Buy collateral in exchange for ETH\n', '\t/// @notice msg.value The amount of the given market that will be paid\n', '\t/// @param collateral Address of the liquidated collateral\n', '\tfunction buyLiquidatedCollateral (address collateral) external payable {\n', '\t\tbuyLiquidatedCollateralInternal(ethAddress, collateral, msg.value);\n', '\t}\n', '\n', '\t/// @notice Deposit ERC20 asset as liquidation reserve\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount that will be deposited\n', '\tfunction depositLiquidationReserve(address collateral, uint256 amount)\n', '\t\texternal\n', '\t\tisNotETHAddress(collateral)\n', '\t{\n', '\t\tdepositLiquidationReserveInternal(collateral, amount);\n', '\t}\n', '\n', '\t/// @notice Deposit ETH asset as liquidation reserve\n', '\t/// @notice msg.value The amount of ETH that will be deposited\n', '\tfunction depositLiquidationReserve() external payable {\n', '\t\tdepositLiquidationReserveInternal(ethAddress, msg.value);\n', '\t}\n', '\n', '\t/// @notice Withdraw liquidation reserve only by the owner\n', '\t/// @param collateral Address of the given collateral\n', '\t/// @param amount The amount that will be withdrawn\n', '\tfunction withdrawLiquidationReserve (address collateral, uint256 amount) external onlyOwner {\n', '\t\tuint256 maxWithdraw = getLiquidationReserve(collateral);\n', '\t\tuint256 transferAmount = amount;\n', '\t\t\n', '\t\tif (transferAmount > maxWithdraw){\n', '\t\t\ttransferAmount = maxWithdraw;\n', '\t\t}\n', '\n', '\t\tcollateralAssets[collateral].totalLiquidatedCollateral =\n', '\t\t\tcollateralAssets[collateral].totalLiquidatedCollateral.sub(transferAmount);\n', '\t\tholdefiCollaterals.withdraw(collateral, msg.sender, transferAmount);\n', '\n', '\t\temit LiquidationReserveWithdrawn(collateral, amount);\n', '\t}\n', '\n', '\t/// @notice Deposit ERC20 asset as promotion reserve\n', '\t/// @param market Address of the given market\n', '\t/// @param amount The amount that will be deposited\n', '\tfunction depositPromotionReserve (address market, uint256 amount)\n', '\t\texternal\n', '\t\tisNotETHAddress(market)\n', '\t{\n', '\t\tdepositPromotionReserveInternal(market, amount);\n', '\t}\n', '\n', '\t/// @notice Deposit ETH as promotion reserve\n', '\t/// @notice msg.value The amount of ETH that will be deposited\n', '\tfunction depositPromotionReserve () external payable {\n', '\t\tdepositPromotionReserveInternal(ethAddress, msg.value);\n', '\t}\n', '\n', '\t/// @notice Withdraw promotion reserve only by the owner\n', '\t/// @param market Address of the given market\n', '\t/// @param amount The amount that will be withdrawn\n', '\tfunction withdrawPromotionReserve (address market, uint256 amount) external onlyOwner {\n', '\t    (uint256 reserveScaled,) = getPromotionReserve(market);\n', '\t    (uint256 debtScaled,) = getPromotionDebt(market);\n', '\n', '\t    uint256 amountScaled = amount.mul(secondsPerYear).mul(rateDecimals);\n', '\t    uint256 increasedDebtScaled = amountScaled.add(debtScaled);\n', '\t    require (reserveScaled > increasedDebtScaled, "Amount should be less than max");\n', '\n', '\t    marketAssets[market].promotionReserveScaled = reserveScaled.sub(amountScaled);\n', '\n', '\t    transferFromHoldefi(msg.sender, market, amount);\n', '\n', '\t    emit PromotionReserveWithdrawn(market, amount);\n', '\t }\n', '\n', '\n', '\t/// @notice Set Holdefi prices contract only by the owner\n', '\t/// @param newHoldefiPrices Address of the new Holdefi prices contract\n', '\tfunction setHoldefiPricesContract (HoldefiPricesInterface newHoldefiPrices) external onlyOwner {\n', '\t\temit HoldefiPricesContractChanged(address(newHoldefiPrices), address(holdefiPrices));\n', '\t\tholdefiPrices = newHoldefiPrices;\n', '\t}\n', '\n', '\t/// @notice Promotion reserve and debt settlement\n', '\t/// @param market Address of the given market\n', '\tfunction reserveSettlement (address market) external {\n', '\t\trequire(msg.sender == address(holdefiSettings), "Sender should be Holdefi Settings contract");\n', '\n', '\t\tuint256 promotionReserve = marketAssets[market].promotionReserveScaled;\n', '\t\tuint256 promotionDebt = marketAssets[market].promotionDebtScaled;\n', '\t\trequire(promotionReserve > promotionDebt, "Not enough promotion reserve");\n', '\t\t\n', '\t\tpromotionReserve = promotionReserve.sub(promotionDebt);\n', '\t\tmarketAssets[market].promotionReserveScaled = promotionReserve;\n', '\t\tmarketAssets[market].promotionDebtScaled = 0;\n', '\n', '\t\tmarketAssets[market].promotionReserveLastUpdateTime = block.timestamp;\n', '\t\tmarketAssets[market].promotionDebtLastUpdateTime = block.timestamp;\n', '\n', '\t\temit PromotionReserveUpdated(market, promotionReserve);\n', '\t\temit PromotionDebtUpdated(market, 0);\n', '\t}\n', '\n', '\t/// @notice Update supply index of a market\n', '\t/// @param market Address of the given market\n', '\tfunction updateSupplyIndex (address market) internal {\n', '\t\t(uint256 currentSupplyIndex, uint256 supplyRate, uint256 currentTime) =\n', '\t\t\tgetCurrentSupplyIndex(market);\n', '\n', '\t\tmarketAssets[market].supplyIndex = currentSupplyIndex;\n', '\t\tmarketAssets[market].supplyIndexUpdateTime = currentTime;\n', '\n', '\t\temit UpdateSupplyIndex(market, currentSupplyIndex, supplyRate);\n', '\t}\n', '\n', '\t/// @notice Update borrow index of a market\n', '\t/// @param market Address of the given market\n', '\tfunction updateBorrowIndex (address market) internal {\n', '\t\t(uint256 currentBorrowIndex,, uint256 currentTime) = getCurrentBorrowIndex(market);\n', '\n', '\t\tmarketAssets[market].borrowIndex = currentBorrowIndex;\n', '\t\tmarketAssets[market].borrowIndexUpdateTime = currentTime;\n', '\n', '\t\temit UpdateBorrowIndex(market, currentBorrowIndex);\n', '\t}\n', '\n', '\t/// @notice Update promotion reserve of a market\n', '\t/// @param market Address of the given market\n', '\tfunction updatePromotionReserve(address market) internal {\n', '\t\t(uint256 reserveScaled,) = getPromotionReserve(market);\n', '\n', '\t\tmarketAssets[market].promotionReserveScaled = reserveScaled;\n', '\t\tmarketAssets[market].promotionReserveLastUpdateTime = block.timestamp;\n', '\n', '\t\temit PromotionReserveUpdated(market, reserveScaled);\n', '\t}\n', '\n', '\t/// @notice Update promotion debt of a market\n', '\t/// @dev Promotion rate will be set to 0 if (promotionDebt >= promotionReserve)\n', '\t/// @param market Address of the given market\n', '\tfunction updatePromotionDebt(address market) internal {\n', '    \t(uint256 debtScaled,) = getPromotionDebt(market);\n', '    \tif (marketAssets[market].promotionDebtScaled != debtScaled){\n', '      \t\tmarketAssets[market].promotionDebtScaled = debtScaled;\n', '      \t\tmarketAssets[market].promotionDebtLastUpdateTime = block.timestamp;\n', '\n', '      \t\temit PromotionDebtUpdated(market, debtScaled);\n', '    \t}\n', '    \tif (marketAssets[market].promotionReserveScaled <= debtScaled) {\n', '      \t\tholdefiSettings.resetPromotionRate(market);\n', '    \t}\n', '  \t}\n', '\n', '\t/// @notice transfer ETH or ERC20 asset from this contract\n', '\tfunction transferFromHoldefi(address receiver, address asset, uint256 amount) internal {\n', '\t\tbool success = false;\n', '\t\tif (asset == ethAddress){\n', '\t\t\t(success, ) = receiver.call{value:amount}("");\n', '\t\t}\n', '\t\telse {\n', '\t\t\tIERC20 token = IERC20(asset);\n', '\t\t\tsuccess = token.transfer(receiver, amount);\n', '\t\t}\n', '\t\trequire (success, "Cannot Transfer");\n', '\t}\n', '\t/// @notice transfer ERC20 asset to this contract\n', '\tfunction transferToHoldefi(address receiver, address asset, uint256 amount) internal {\n', '\t\tIERC20 token = IERC20(asset);\n', '\t\tbool success = token.transferFrom(msg.sender, receiver, amount);\n', '\t\trequire (success, "Cannot Transfer");\n', '\t}\n', '\n', '\t/// @notice Perform supply operation\n', '\tfunction supplyInternal(address account, address market, uint256 amount, uint16 referralCode)\n', '\t\tinternal\n', '\t\twhenNotPaused("supply")\n', '\t\tmarketIsActive(market)\n', '\t{\n', '\t\tif (market != ethAddress) {\n', '\t\t\ttransferToHoldefi(address(this), market, amount);\n', '\t\t}\n', '\n', '\t\tMarketData memory supplyData;\n', '\t\t(supplyData.balance, supplyData.interest, supplyData.currentIndex) = getAccountSupply(account, market);\n', '\t\t\n', '\t\tsupplyData.balance = supplyData.balance.add(amount);\n', '\t\tsupplies[account][market].balance = supplyData.balance;\n', '\t\tsupplies[account][market].accumulatedInterest = supplyData.interest;\n', '\t\tsupplies[account][market].lastInterestIndex = supplyData.currentIndex;\n', '\n', '\t\tbeforeChangeSupplyRate(market);\n', '\t\t\n', '\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.add(amount);\n', '\n', '\t\temit Supply(\n', '\t\t\tmsg.sender,\n', '\t\t\taccount,\n', '\t\t\tmarket,\n', '\t\t\tamount,\n', '\t\t\tsupplyData.balance,\n', '\t\t\tsupplyData.interest,\n', '\t\t\tsupplyData.currentIndex,\n', '\t\t\treferralCode\n', '\t\t);\n', '\t}\n', '\n', '\t/// @notice Perform withdraw supply operation\n', '\tfunction withdrawSupplyInternal (address account, address market, uint256 amount) \n', '\t\tinternal\n', '\t\twhenNotPaused("withdrawSupply")\n', '\t{\n', '\t\tMarketData memory supplyData;\n', '\t\t(supplyData.balance, supplyData.interest, supplyData.currentIndex) = getAccountSupply(account, market);\n', '\t\tuint256 totalSuppliedBalance = supplyData.balance.add(supplyData.interest);\n', '\t\trequire (totalSuppliedBalance != 0, "Total balance should not be zero");\n', '\n', '\t\tuint256 transferAmount = amount;\n', '\t\tif (transferAmount > totalSuppliedBalance){\n', '\t\t\ttransferAmount = totalSuppliedBalance;\n', '\t\t}\n', '\n', '\t\tuint256 remaining = 0;\n', '\t\tif (transferAmount <= supplyData.interest) {\n', '\t\t\tsupplyData.interest = supplyData.interest.sub(transferAmount);\n', '\t\t}\n', '\t\telse {\n', '\t\t\tremaining = transferAmount.sub(supplyData.interest);\n', '\t\t\tsupplyData.interest = 0;\n', '\t\t\tsupplyData.balance = supplyData.balance.sub(remaining);\n', '\t\t}\n', '\n', '\t\tsupplies[account][market].balance = supplyData.balance;\n', '\t\tsupplies[account][market].accumulatedInterest = supplyData.interest;\n', '\t\tsupplies[account][market].lastInterestIndex = supplyData.currentIndex;\n', '\n', '\t\tbeforeChangeSupplyRate(market);\n', '\t\t\n', '\t\tmarketAssets[market].totalSupply = marketAssets[market].totalSupply.sub(remaining);\t\n', '\t\t\n', '\t\ttransferFromHoldefi(msg.sender, market, transferAmount);\n', '\t\n', '\t\temit WithdrawSupply(\n', '\t\t\tmsg.sender,\n', '\t\t\taccount,\n', '\t\t\tmarket,\n', '\t\t\ttransferAmount,\n', '\t\t\tsupplyData.balance,\n', '\t\t\tsupplyData.interest,\n', '\t\t\tsupplyData.currentIndex\n', '\t\t);\n', '\t}\n', '\n', '\t/// @notice Perform collateralize operation\n', '\tfunction collateralizeInternal (address account, address collateral, uint256 amount)\n', '\t\tinternal\n', '\t\twhenNotPaused("collateralize")\n', '\t\tcollateralIsActive(collateral)\n', '\t{\n', '\t\tif (collateral != ethAddress) {\n', '\t\t\ttransferToHoldefi(address(holdefiCollaterals), collateral, amount);\n', '\t\t}\n', '\t\telse {\n', '\t\t\ttransferFromHoldefi(address(holdefiCollaterals), collateral, amount);\n', '\t\t}\n', '\n', '\t\tuint256 balance = collaterals[account][collateral].balance.add(amount);\n', '\t\tcollaterals[account][collateral].balance = balance;\n', '\t\tcollaterals[account][collateral].lastUpdateTime = block.timestamp;\n', '\n', '\t\tcollateralAssets[collateral].totalCollateral = collateralAssets[collateral].totalCollateral.add(amount);\t\n', '\t\t\n', '\t\temit Collateralize(msg.sender, account, collateral, amount, balance);\n', '\t}\n', '\n', '\t/// @notice Perform withdraw collateral operation\n', '\tfunction withdrawCollateralInternal (address account, address collateral, uint256 amount) \n', '\t\tinternal\n', '\t\twhenNotPaused("withdrawCollateral")\n', '\t{\n', '\t\t(uint256 balance,, uint256 borrowPowerValue, uint256 totalBorrowValue,) =\n', '\t\t\tgetAccountCollateral(account, collateral);\n', '\n', '\t\trequire (borrowPowerValue != 0, "Borrow power should not be zero");\n', '\n', '\t\tuint256 collateralNedeed = 0;\n', '\t\tif (totalBorrowValue != 0) {\n', '\t\t\tuint256 valueToLoanRate = holdefiSettings.collateralAssets(collateral).valueToLoanRate;\n', '\t\t\tuint256 totalCollateralValue = totalBorrowValue.mul(valueToLoanRate).div(rateDecimals);\n', '\t\t\tcollateralNedeed = holdefiPrices.getAssetAmountFromValue(collateral, totalCollateralValue);\n', '\t\t}\n', '\n', '\t\tuint256 maxWithdraw = balance.sub(collateralNedeed);\n', '\t\tuint256 transferAmount = amount;\n', '\t\tif (transferAmount > maxWithdraw){\n', '\t\t\ttransferAmount = maxWithdraw;\n', '\t\t}\n', '\t\tbalance = balance.sub(transferAmount);\n', '\t\tcollaterals[account][collateral].balance = balance;\n', '\t\tcollaterals[account][collateral].lastUpdateTime = block.timestamp;\n', '\n', '\t\tcollateralAssets[collateral].totalCollateral =\n', '\t\t\tcollateralAssets[collateral].totalCollateral.sub(transferAmount);\n', '\n', '\t\tholdefiCollaterals.withdraw(collateral, msg.sender, transferAmount);\n', '\n', '\t\temit WithdrawCollateral(msg.sender, account, collateral, transferAmount, balance);\n', '\t}\n', '\n', '\t/// @notice Perform borrow operation\n', '\tfunction borrowInternal (address account, address market, address collateral, uint256 amount, uint16 referralCode)\n', '\t\tinternal\n', '\t\twhenNotPaused("borrow")\n', '\t\tmarketIsActive(market)\n', '\t\tcollateralIsActive(collateral)\n', '\t{\n', '\t\trequire (\n', '\t\t\tamount <= (marketAssets[market].totalSupply.sub(marketAssets[market].totalBorrow)),\n', '\t\t\t"Amount should be less than cash"\n', '\t\t);\n', '\n', '\t\t(,, uint256 borrowPowerValue,,) = getAccountCollateral(account, collateral);\n', '\t\tuint256 assetToBorrowValue = holdefiPrices.getAssetValueFromAmount(market, amount);\n', '\t\trequire (\n', '\t\t\tborrowPowerValue >= assetToBorrowValue,\n', '\t\t\t"Borrow power should be more than new borrow value"\n', '\t\t);\n', '\n', '\t\tMarketData memory borrowData;\n', '\t\t(borrowData.balance, borrowData.interest, borrowData.currentIndex) = getAccountBorrow(account, market, collateral);\n', '\t\t\n', '\t\tborrowData.balance = borrowData.balance.add(amount);\n', '\t\tborrows[account][collateral][market].balance = borrowData.balance;\n', '\t\tborrows[account][collateral][market].accumulatedInterest = borrowData.interest;\n', '\t\tborrows[account][collateral][market].lastInterestIndex = borrowData.currentIndex;\n', '\t\tcollaterals[account][collateral].lastUpdateTime = block.timestamp;\n', '\n', '\t\tbeforeChangeSupplyRate(market);\n', '\n', '\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.add(amount);\n', '\n', '\t\ttransferFromHoldefi(msg.sender, market, amount);\n', '\n', '\t\temit Borrow(\n', '\t\t\tmsg.sender, \n', '\t\t\taccount,\n', '\t\t\tmarket,\n', '\t\t\tcollateral,\n', '\t\t\tamount,\n', '\t\t\tborrowData.balance,\n', '\t\t\tborrowData.interest,\n', '\t\t\tborrowData.currentIndex,\n', '\t\t\treferralCode\n', '\t\t);\n', '\t}\n', '\n', '\t/// @notice Perform repay borrow operation\n', '\tfunction repayBorrowInternal (address account, address market, address collateral, uint256 amount)\n', '\t\tinternal\n', '\t\twhenNotPaused("repayBorrow")\n', '\t{\n', '\t\tMarketData memory borrowData;\n', '\t\t(borrowData.balance, borrowData.interest, borrowData.currentIndex) =\n', '\t\t\tgetAccountBorrow(account, market, collateral);\n', '\n', '\t\tuint256 totalBorrowedBalance = borrowData.balance.add(borrowData.interest);\n', '\t\trequire (totalBorrowedBalance != 0, "Total balance should not be zero");\n', '\n', '\t\tuint256 transferAmount = amount;\n', '\t\tif (transferAmount > totalBorrowedBalance) {\n', '\t\t\ttransferAmount = totalBorrowedBalance;\n', '\t\t\tif (market == ethAddress) {\n', '\t\t\t\tuint256 extra = amount.sub(transferAmount);\n', '\t\t\t\ttransferFromHoldefi(msg.sender, ethAddress, extra);\n', '\t\t\t}\n', '\t\t}\n', '\t\t\n', '\t\tif (market != ethAddress) {\n', '\t\t\ttransferToHoldefi(address(this), market, transferAmount);\n', '\t\t}\n', '\n', '\t\tuint256 remaining = 0;\n', '\t\tif (transferAmount <= borrowData.interest) {\n', '\t\t\tborrowData.interest = borrowData.interest.sub(transferAmount);\n', '\t\t}\n', '\t\telse {\n', '\t\t\tremaining = transferAmount.sub(borrowData.interest);\n', '\t\t\tborrowData.interest = 0;\n', '\t\t\tborrowData.balance = borrowData.balance.sub(remaining);\n', '\t\t}\n', '\t\tborrows[account][collateral][market].balance = borrowData.balance;\n', '\t\tborrows[account][collateral][market].accumulatedInterest = borrowData.interest;\n', '\t\tborrows[account][collateral][market].lastInterestIndex = borrowData.currentIndex;\n', '\t\tcollaterals[account][collateral].lastUpdateTime = block.timestamp;\n', '\n', '\t\tbeforeChangeSupplyRate(market);\n', '\t\t\n', '\t\tmarketAssets[market].totalBorrow = marketAssets[market].totalBorrow.sub(remaining);\t\n', '\n', '\t\temit RepayBorrow (\n', '\t\t\tmsg.sender,\n', '\t\t\taccount,\n', '\t\t\tmarket,\n', '\t\t\tcollateral,\n', '\t\t\ttransferAmount,\n', '\t\t\tborrowData.balance,\n', '\t\t\tborrowData.interest,\n', '\t\t\tborrowData.currentIndex\n', '\t\t);\n', '\t}\n', '\n', '\t/// @notice Perform buy liquidated collateral operation\n', '\tfunction buyLiquidatedCollateralInternal (address market, address collateral, uint256 marketAmount)\n', '\t\tinternal\n', '\t\twhenNotPaused("buyLiquidatedCollateral")\n', '\t{\n', '\t\tuint256 debt = marketDebt[collateral][market];\n', '\t\trequire (marketAmount <= debt,\n', '\t\t\t"Amount should be less than total liquidated assets"\n', '\t\t);\n', '\n', '\t\tuint256 collateralAmountWithDiscount =\n', '\t\t\tgetDiscountedCollateralAmount(market, collateral, marketAmount);\n', '\n', '\t\tuint256 totalLiquidatedCollateral = collateralAssets[collateral].totalLiquidatedCollateral;\n', '\t\trequire (\n', '\t\t\tcollateralAmountWithDiscount <= totalLiquidatedCollateral,\n', '\t\t\t"Collateral amount with discount should be less than total liquidated assets"\n', '\t\t);\n', '\n', '\t\tif (market != ethAddress) {\n', '\t\t\ttransferToHoldefi(address(this), market, marketAmount);\n', '\t\t}\n', '\n', '\t\tcollateralAssets[collateral].totalLiquidatedCollateral = totalLiquidatedCollateral.sub(collateralAmountWithDiscount);\n', '\t\tmarketDebt[collateral][market] = debt.sub(marketAmount);\n', '\n', '\t\tholdefiCollaterals.withdraw(collateral, msg.sender, collateralAmountWithDiscount);\n', '\n', '\t\temit BuyLiquidatedCollateral(market, collateral, marketAmount, collateralAmountWithDiscount);\n', '\t}\n', '\n', '\t/// @notice Perform deposit promotion reserve operation\n', '\tfunction depositPromotionReserveInternal (address market, uint256 amount)\n', '\t\tinternal\n', '\t\tmarketIsActive(market)\n', '\t{\n', '\t\tif (market != ethAddress) {\n', '\t\t\ttransferToHoldefi(address(this), market, amount);\n', '\t\t}\n', '\t\tuint256 amountScaled = amount.mul(secondsPerYear).mul(rateDecimals);\n', '\n', '\t\tmarketAssets[market].promotionReserveScaled = \n', '\t\t\tmarketAssets[market].promotionReserveScaled.add(amountScaled);\n', '\n', '\t\temit PromotionReserveDeposited(market, amount);\n', '\t}\n', '\n', '\t/// @notice Perform deposit liquidation reserve operation\n', '\tfunction depositLiquidationReserveInternal (address collateral, uint256 amount)\n', '\t\tinternal\n', '\t\tcollateralIsActive(ethAddress)\n', '\t{\n', '\t\tif (collateral != ethAddress) {\n', '\t\t\ttransferToHoldefi(address(holdefiCollaterals), collateral, amount);\n', '\t\t}\n', '\t\telse {\n', '\t\t\ttransferFromHoldefi(address(holdefiCollaterals), collateral, amount);\n', '\t\t}\n', '\t\tcollateralAssets[ethAddress].totalLiquidatedCollateral =\n', '\t\t\tcollateralAssets[ethAddress].totalLiquidatedCollateral.add(msg.value);\n', '\t\t\n', '\t\temit LiquidationReserveDeposited(ethAddress, msg.value);\n', '\t}\n', '}']