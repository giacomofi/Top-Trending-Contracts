['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-31\n', '*/\n', '\n', '// File: contracts/ErrorReporter.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', 'contract ErrorReporter {\n', '    /**\n', '     * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n', '     * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n', '     */\n', '    event Failure(uint error, uint info, uint detail);\n', '\n', '    enum Error {\n', '        NO_ERROR,\n', '        OPAQUE_ERROR, // To be used when reporting errors from upgradeable contracts; the opaque code should be given as `detail` in the `Failure` event\n', '        UNAUTHORIZED,\n', '        INTEGER_OVERFLOW,\n', '        INTEGER_UNDERFLOW,\n', '        DIVISION_BY_ZERO,\n', '        BAD_INPUT,\n', '        TOKEN_INSUFFICIENT_ALLOWANCE,\n', '        TOKEN_INSUFFICIENT_BALANCE,\n', '        TOKEN_TRANSFER_FAILED,\n', '        MARKET_NOT_SUPPORTED,\n', '        SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_RATE_CALCULATION_FAILED,\n', '        TOKEN_INSUFFICIENT_CASH,\n', '        TOKEN_TRANSFER_OUT_FAILED,\n', '        INSUFFICIENT_LIQUIDITY,\n', '        INSUFFICIENT_BALANCE,\n', '        INVALID_COLLATERAL_RATIO,\n', '        MISSING_ASSET_PRICE,\n', '        EQUITY_INSUFFICIENT_BALANCE,\n', '        INVALID_CLOSE_AMOUNT_REQUESTED,\n', '        ASSET_NOT_PRICED,\n', '        INVALID_LIQUIDATION_DISCOUNT,\n', '        INVALID_COMBINED_RISK_PARAMETERS,\n', '        ZERO_ORACLE_ADDRESS,\n', '        CONTRACT_PAUSED,\n', '        KYC_ADMIN_CHECK_FAILED,\n', '        KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n', '        KYC_CUSTOMER_VERIFICATION_CHECK_FAILED,\n', '        LIQUIDATOR_CHECK_FAILED,\n', '        LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n', '        SET_WETH_ADDRESS_ADMIN_CHECK_FAILED,\n', '        WETH_ADDRESS_NOT_SET_ERROR,\n', '        ETHER_AMOUNT_MISMATCH_ERROR\n', '    }\n', '\n', '    /**\n', '     * Note: FailureInfo (but not Error) is kept in alphabetical order\n', '     *       This is because FailureInfo grows significantly faster, and\n', '     *       the order of Error has some meaning, while the order of FailureInfo\n', '     *       is entirely arbitrary.\n', '     */\n', '    enum FailureInfo {\n', '        ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n', '        BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        BORROW_ACCOUNT_SHORTFALL_PRESENT,\n', '        BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        BORROW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        BORROW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        BORROW_CONTRACT_PAUSED,\n', '        BORROW_MARKET_NOT_SUPPORTED,\n', '        BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        BORROW_ORIGINATION_FEE_CALCULATION_FAILED,\n', '        BORROW_TRANSFER_OUT_FAILED,\n', '        EQUITY_WITHDRAWAL_AMOUNT_VALIDATION,\n', '        EQUITY_WITHDRAWAL_CALCULATE_EQUITY,\n', '        EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK,\n', '        EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED,\n', '        LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED,\n', '        LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED,\n', '        LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH,\n', '        LIQUIDATE_CONTRACT_PAUSED,\n', '        LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET,\n', '        LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET,\n', '        LIQUIDATE_FETCH_ASSET_PRICE_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_FAILED,\n', '        LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE,\n', '        REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_CONTRACT_PAUSED,\n', '        REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED,\n', '        REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_FAILED,\n', '        REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE,\n', '        SET_ASSET_PRICE_CHECK_ORACLE,\n', '        SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK,\n', '        SET_ORACLE_OWNER_CHECK,\n', '        SET_ORIGINATION_FEE_OWNER_CHECK,\n', '        SET_PAUSED_OWNER_CHECK,\n', '        SET_PENDING_ADMIN_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_OWNER_CHECK,\n', '        SET_RISK_PARAMETERS_VALIDATION,\n', '        SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_CONTRACT_PAUSED,\n', '        SUPPLY_MARKET_NOT_SUPPORTED,\n', '        SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED,\n', '        SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        SUPPLY_TRANSFER_IN_FAILED,\n', '        SUPPLY_TRANSFER_IN_NOT_POSSIBLE,\n', '        SUPPORT_MARKET_FETCH_PRICE_FAILED,\n', '        SUPPORT_MARKET_OWNER_CHECK,\n', '        SUPPORT_MARKET_PRICE_CHECK,\n', '        SUSPEND_MARKET_OWNER_CHECK,\n', '        WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED,\n', '        WITHDRAW_ACCOUNT_SHORTFALL_PRESENT,\n', '        WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL,\n', '        WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED,\n', '        WITHDRAW_CAPACITY_CALCULATION_FAILED,\n', '        WITHDRAW_CONTRACT_PAUSED,\n', '        WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED,\n', '        WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_FAILED,\n', '        WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE,\n', '        KYC_ADMIN_CHECK_FAILED,\n', '        KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n', '        KYC_CUSTOMER_VERIFICATION_CHECK_FAILED,\n', '        LIQUIDATOR_CHECK_FAILED,\n', '        LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED,\n', '        SET_WETH_ADDRESS_ADMIN_CHECK_FAILED,\n', '        WETH_ADDRESS_NOT_SET_ERROR,\n', '        SEND_ETHER_ADMIN_CHECK_FAILED,\n', '        ETHER_AMOUNT_MISMATCH_ERROR\n', '    }\n', '\n', '    /**\n', '     * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n', '     */\n', '    function fail(Error err, FailureInfo info) internal returns (uint) {\n', '        emit Failure(uint(err), uint(info), 0);\n', '\n', '        return uint(err);\n', '    }\n', '\n', '    /**\n', '     * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n', '     */\n', '    function failOpaque(FailureInfo info, uint opaqueError) internal returns (uint) {\n', '        emit Failure(uint(Error.OPAQUE_ERROR), uint(info), opaqueError);\n', '\n', '        return uint(Error.OPAQUE_ERROR);\n', '    }\n', '}\n', '\n', '// File: contracts/CarefulMath.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '/**\n', ' * @title Careful Math\n', " * @notice Derived from OpenZeppelin's SafeMath library\n", ' *         https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n', ' */\n', 'contract CarefulMath is ErrorReporter {\n', '    /**\n', '     * @dev Multiplies two numbers, returns an error on overflow.\n', '     */\n', '    function mul(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (a == 0) {\n', '            return (Error.NO_ERROR, 0);\n', '        }\n', '\n', '        uint c = a * b;\n', '\n', '        if (c / a != b) {\n', '            return (Error.INTEGER_OVERFLOW, 0);\n', '        } else {\n', '            return (Error.NO_ERROR, c);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two numbers, truncating the quotient.\n', '     */\n', '    function div(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (b == 0) {\n', '            return (Error.DIVISION_BY_ZERO, 0);\n', '        }\n', '\n', '        return (Error.NO_ERROR, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint a, uint b) internal pure returns (Error, uint) {\n', '        if (b <= a) {\n', '            return (Error.NO_ERROR, a - b);\n', '        } else {\n', '            return (Error.INTEGER_UNDERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two numbers, returns an error on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function subInt(uint a, uint b) internal pure returns (Error, int) {\n', '            return (Error.NO_ERROR, int(a - b));\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, returns an error on overflow.\n', '     */\n', '    function add(uint a, uint b) internal pure returns (Error, uint) {\n', '        uint c = a + b;\n', '\n', '        if (c >= a) {\n', '            return (Error.NO_ERROR, c);\n', '        } else {\n', '            return (Error.INTEGER_OVERFLOW, 0);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two numbers, returns an error on overflow.\n', '     */\n', '    function addInt(uint a, int b) internal pure returns (Error, int) {\n', '        int c = int(a) + b;\n', '            return (Error.NO_ERROR, c);\n', '    }\n', '\n', '    /**\n', '     * @dev add a and b and then subtract c\n', '     */\n', '    function addThenSub(uint a, uint b, uint c) internal pure returns (Error, uint) {\n', '        (Error err0, uint sum) = add(a, b);\n', '\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        return sub(sum, c);\n', '    }\n', '}\n', '\n', '// File: contracts/Exponential.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '\n', '\n', 'contract Exponential is ErrorReporter, CarefulMath {\n', '    // TODO: We may wish to put the result of 10**18 here instead of the expression.\n', '    // Per https://solidity.readthedocs.io/en/latest/contracts.html#constant-state-variables\n', '    // the optimizer MAY replace the expression 10**18 with its calculated value.\n', '    uint constant expScale = 10**18;\n', '\n', '    // See TODO on expScale\n', '    uint constant halfExpScale = expScale/2;\n', '\n', '    struct Exp {\n', '        uint mantissa;\n', '    }\n', '\n', '    struct ExpNegative {\n', '        int mantissa;\n', '    }\n', '\n', '    uint constant mantissaOne = 10**18;\n', '    uint constant mantissaOneTenth = 10**17;\n', '\n', '    /**\n', '     * @dev Creates an exponential from numerator and denominator values.\n', '     *      Note: Returns an error if (`num` * 10e18) > MAX_INT,\n', '     *            or if `denom` is zero.\n', '     */\n', '    function getExp(uint num, uint denom) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint scaledNumerator) = mul(num, expScale);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err1, uint rational) = div(scaledNumerator, denom);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: rational}));\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two exponentials, returning a new exponential.\n', '     */\n', '    function addExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        (Error error, uint result) = add(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two exponentials, returning a new exponential.\n', '     */\n', '    function addExpNegative(Exp memory a, ExpNegative memory b) pure internal returns (Error, Exp memory) {\n', '        (Error error, int result) = addInt(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: uint(result)}));\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two exponentials, returning a new exponential.\n', '     */\n', '    function subExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        (Error error, uint result) = sub(a.mantissa, b.mantissa);\n', '\n', '        return (error, Exp({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two exponentials, returning a new exponential.\n', '     */\n', '    function subExpNegative(Exp memory a, Exp memory b) pure internal returns (Error, ExpNegative memory) {\n', '        (Error error, int result) = subInt(a.mantissa, b.mantissa);\n', '\n', '        return (error, ExpNegative({mantissa: result}));\n', '    }\n', '\n', '    /**\n', '     * @dev Multiply an Exp by a scalar, returning a new Exp.\n', '     */\n', '    function mulScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint scaledMantissa) = mul(a.mantissa, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: scaledMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @dev Divide an Exp by a scalar, returning a new Exp.\n', '     */\n', '    function divScalar(Exp memory a, uint scalar) pure internal returns (Error, Exp memory) {\n', '        (Error err0, uint descaledMantissa) = div(a.mantissa, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: descaledMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @dev Divide a scalar by an Exp, returning a new Exp.\n', '     */\n', '    function divScalarByExp(uint scalar, Exp divisor) pure internal returns (Error, Exp memory) {\n', '        /*\n', '            We are doing this as:\n', '            getExp(mul(expScale, scalar), divisor.mantissa)\n', '\n', '            How it works:\n', '            Exp = a / b;\n', '            Scalar = s;\n', '            `s / (a / b)` = `b * s / a` and since for an Exp `a = mantissa, b = expScale`\n', '        */\n', '        (Error err0, uint numerator) = mul(expScale, scalar);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '        return getExp(numerator, divisor.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @dev Multiplies two exponentials, returning a new exponential.\n', '     */\n', '    function mulExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '\n', '        (Error err0, uint doubleScaledProduct) = mul(a.mantissa, b.mantissa);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}));\n', '        }\n', '\n', '        // We add half the scale before dividing so that we get rounding instead of truncation.\n', '        //  See "Listing 6" and text above it at https://accu.org/index.php/journals/1717\n', '        // Without this change, a result like 6.6...e-19 will be truncated to 0 instead of being rounded to 1e-18.\n', '        (Error err1, uint doubleScaledProductWithHalfScale) = add(halfExpScale, doubleScaledProduct);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (err1, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err2, uint product) = div(doubleScaledProductWithHalfScale, expScale);\n', '        // The only error `div` can return is Error.DIVISION_BY_ZERO but we control `expScale` and it is not zero.\n', '        assert(err2 == Error.NO_ERROR);\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: product}));\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two exponentials, returning a new exponential.\n', '     *     (a/scale) / (b/scale) = (a/scale) * (scale/b) = a/b,\n', '     *  which we can scale as an Exp by calling getExp(a.mantissa, b.mantissa)\n', '     */\n', '    function divExp(Exp memory a, Exp memory b) pure internal returns (Error, Exp memory) {\n', '        return getExp(a.mantissa, b.mantissa);\n', '    }\n', '\n', '    /**\n', '     * @dev Truncates the given exp to a whole number value.\n', '     *      For example, truncate(Exp{mantissa: 15 * (10**18)}) = 15\n', '     */\n', '    function truncate(Exp memory exp) pure internal returns (uint) {\n', "        // Note: We are not using careful math here as we're performing a division that cannot fail\n", '        return exp.mantissa / 10**18;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if first Exp is less than second Exp.\n', '     */\n', '    function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa < right.mantissa; //TODO: Add some simple tests and this in another PR yo.\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if left Exp <= right Exp.\n', '     */\n', '    function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa <= right.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Checks if first Exp is greater than second Exp.\n', '     */\n', '    function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n', '        return left.mantissa > right.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev returns true if Exp is exactly zero\n', '     */\n', '    function isZeroExp(Exp memory value) pure internal returns (bool) {\n', '        return value.mantissa == 0;\n', '    }\n', '}\n', '\n', '// File: contracts/AlkemiRateModel.sol\n', '\n', 'pragma solidity ^0.4.24;\n', '\n', '/**\n', '  * @title  Earn Interest Rate Model\n', '  * @author ShiftForex\n', '  * @notice See Model here\n', '  */\n', '\n', 'contract AlkemiRateModel is Exponential {\n', '\n', '    uint constant blocksPerYear = 2102400;\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    string public contractName;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "non-owner");\n', '        _;\n', '    }\n', '\n', '    enum IRError {\n', '        NO_ERROR,\n', '        FAILED_TO_ADD_CASH_PLUS_BORROWS,\n', '        FAILED_TO_GET_EXP,\n', '        FAILED_TO_MUL_PRODUCT_TIMES_BORROW_RATE\n', '    }\n', '\n', '    event OwnerUpdate(address indexed owner, address indexed newOwner);\n', '\n', '    Exp internal SpreadLow;\n', '    Exp internal BreakPointLow;\n', '    Exp internal ReserveLow;\n', '    Exp internal ReserveMid;\n', '    Exp internal SpreadMid;\n', '    Exp internal BreakPointHigh;\n', '    Exp internal ReserveHigh;\n', '    ExpNegative internal SpreadHigh;\n', '\n', '    Exp internal MinRateActual;\n', '    Exp internal HealthyMinURActual;\n', '    Exp internal HealthyMinRateActual;\n', '    Exp internal MaxRateActual;\n', '    Exp internal HealthyMaxURActual;\n', '    Exp internal HealthyMaxRateActual;\n', '\n', '    constructor(string memory _contractName,uint MinRate,uint HealthyMinUR,uint HealthyMinRate,uint HealthyMaxUR,uint HealthyMaxRate,uint MaxRate) public {\n', '        // Remember to enter percentage times 100. ex., if it is 2.50%, enter 250\n', '        owner = msg.sender;\n', '        contractName = _contractName;\n', '        Exp memory  temp1;\n', '        Exp memory temp2;\n', '        Exp memory HunderedMantissa;\n', '        Error err;\n', '\n', '        (err,HunderedMantissa) = getExp(100,1);\n', '\n', '        (err,MinRateActual) = getExp(MinRate,100);\n', '        (err,HealthyMinURActual) = getExp(HealthyMinUR,100);\n', '        (err,HealthyMinRateActual) = getExp(HealthyMinRate,100);\n', '        (err,MaxRateActual) = getExp(MaxRate,100);\n', '        (err,HealthyMaxURActual) = getExp(HealthyMaxUR,100);\n', '        (err,HealthyMaxRateActual) = getExp(HealthyMaxRate,100);\n', '\n', '        SpreadLow = MinRateActual;\n', '        BreakPointLow = HealthyMinURActual;\n', '        BreakPointHigh = HealthyMaxURActual;\n', '\n', '        // ReserveLow = (HealthyMinRate-SpreadLow)/BreakPointLow;\n', '        (err,temp1) = subExp(HealthyMinRateActual,SpreadLow);\n', '        (err,ReserveLow) = divExp(temp1,BreakPointLow);\n', '\n', '        // ReserveMid = (HealthyMaxRate-HealthyMinRate)/(HealthyMaxUR-HealthyMinUR);\n', '        (err,temp1) = subExp(HealthyMaxRateActual,HealthyMinRateActual);\n', '        (err,temp2) = subExp(HealthyMaxURActual,HealthyMinURActual);\n', '        (err,ReserveMid) = divExp(temp1,temp2);\n', '\n', '        // SpreadMid = HealthyMinRate - (ReserveMid * BreakPointLow);\n', '        (err,temp1) = mulExp(ReserveMid,BreakPointLow);\n', '        (err,SpreadMid) = subExp(HealthyMinRateActual,temp1);\n', '\n', '        // ReserveHigh = (MaxRate - HealthyMaxRate) / (100 - HealthyMaxUR);\n', '        (err,temp1) = subExp(MaxRateActual,HealthyMaxRateActual);\n', '        (err,temp2) = subExp(HunderedMantissa,HealthyMaxURActual);\n', '        (err,ReserveHigh) = divExp(temp1,temp2);\n', '\n', '        // SpreadHigh = HealthyMaxRate - (ReserveHigh * BreakPointHigh);\n', '        (err,temp2) = mulExp(ReserveHigh,BreakPointHigh);\n', '        (err,SpreadHigh) = subExpNegative(HealthyMaxRateActual,temp2);\n', '    }\n', '\n', '    function changeRates(string memory _contractName,uint MinRate,uint HealthyMinUR,uint HealthyMinRate,uint HealthyMaxUR,uint HealthyMaxRate,uint MaxRate) public onlyOwner {\n', '        // Remember to enter percentage times 100. ex., if it is 2.50%, enter 250\n', '        contractName = _contractName;\n', '        Exp memory  temp1;\n', '        Exp memory temp2;\n', '        Exp memory HunderedMantissa;\n', '        Error err;\n', '\n', '        (err,HunderedMantissa) = getExp(100,1);\n', '\n', '        (err,MinRateActual) = getExp(MinRate,100);\n', '        (err,HealthyMinURActual) = getExp(HealthyMinUR,100);\n', '        (err,HealthyMinRateActual) = getExp(HealthyMinRate,100);\n', '        (err,MaxRateActual) = getExp(MaxRate,100);\n', '        (err,HealthyMaxURActual) = getExp(HealthyMaxUR,100);\n', '        (err,HealthyMaxRateActual) = getExp(HealthyMaxRate,100);\n', '\n', '        SpreadLow = MinRateActual;\n', '        BreakPointLow = HealthyMinURActual;\n', '        BreakPointHigh = HealthyMaxURActual;\n', '\n', '        // ReserveLow = (HealthyMinRate-SpreadLow)/BreakPointLow;\n', '        (err,temp1) = subExp(HealthyMinRateActual,SpreadLow);\n', '        (err,ReserveLow) = divExp(temp1,BreakPointLow);\n', '\n', '        // ReserveMid = (HealthyMaxRate-HealthyMinRate)/(HealthyMaxUR-HealthyMinUR);\n', '        (err,temp1) = subExp(HealthyMaxRateActual,HealthyMinRateActual);\n', '        (err,temp2) = subExp(HealthyMaxURActual,HealthyMinURActual);\n', '        (err,ReserveMid) = divExp(temp1,temp2);\n', '\n', '        // SpreadMid = HealthyMinRate - (ReserveMid * BreakPointLow);\n', '        (err,temp1) = mulExp(ReserveMid,BreakPointLow);\n', '        (err,SpreadMid) = subExp(HealthyMinRateActual,temp1);\n', '\n', '        // ReserveHigh = (MaxRate - HealthyMaxRate) / (100 - HealthyMaxUR);\n', '        (err,temp1) = subExp(MaxRateActual,HealthyMaxRateActual);\n', '        (err,temp2) = subExp(HunderedMantissa,HealthyMaxURActual);\n', '        (err,ReserveHigh) = divExp(temp1,temp2);\n', '\n', '        // SpreadHigh = HealthyMaxRate - (ReserveHigh * BreakPointHigh);\n', '        (err,temp2) = mulExp(ReserveHigh,BreakPointHigh);\n', '        (err,SpreadHigh) = subExpNegative(HealthyMaxRateActual,temp2);\n', '    }\n', '\n', '    function transferOwnership(address newOwner_) external onlyOwner {\n', '        require(newOwner_ != owner, "TransferOwnership: the same owner.");\n', '        newOwner = newOwner_;\n', '    }\n', '\n', '    function acceptOwnership() external {\n', '        require(msg.sender == newOwner, "AcceptOwnership: only new owner do this.");\n', '        emit OwnerUpdate(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0x0);\n', '    }\n', '\n', '    /*\n', '     * @dev Calculates the utilization rate (borrows / (cash + borrows)) as an Exp\n', '     */\n', '    function getUtilizationRate(uint cash, uint borrows) pure internal returns (IRError, Exp memory) {\n', '        if (borrows == 0) {\n', "            // Utilization rate is zero when there's no borrows\n", '            return (IRError.NO_ERROR, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err0, uint cashPlusBorrows) = add(cash, borrows);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (IRError.FAILED_TO_ADD_CASH_PLUS_BORROWS, Exp({mantissa: 0}));\n', '        }\n', '\n', '        (Error err1, Exp memory utilizationRate) = getExp(borrows, cashPlusBorrows);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (IRError.FAILED_TO_GET_EXP, Exp({mantissa: 0}));\n', '        }\n', '        (err1,utilizationRate) = mulScalar(utilizationRate,100);\n', '\n', '        return (IRError.NO_ERROR, utilizationRate);\n', '    }\n', '\n', '    /*\n', '     * @dev Calculates the utilization and borrow rates for use by get{Supply,Borrow}Rate functions\n', '     */\n', '    function getUtilizationAndAnnualBorrowRate(uint cash, uint borrows) view internal returns (IRError, Exp memory, Exp memory) {\n', '        (IRError err0, Exp memory utilizationRate) = getUtilizationRate(cash, borrows);\n', '        if (err0 != IRError.NO_ERROR) {\n', '            return (err0, Exp({mantissa: 0}), Exp({mantissa: 0}));\n', '        }\n', '\n', '        /**\n', '         *  Borrow Rate\n', '         *  0 < UR < 20% :      SpreadLow + UR * ReserveLow\n', '         *  20% <= UR <= 80% :  SpreadMid + UR * ReserveMid\n', '         *  80% < UR :          SpreadHigh + UR * ReserveHigh\n', '         */\n', '\n', '        Error err;\n', '\n', '        uint annualBorrowRateScaled;\n', '        Exp memory tempScaled;\n', '        Exp memory tempScaled2;\n', '\n', '        if(utilizationRate.mantissa < BreakPointLow.mantissa) {\n', '            (err, tempScaled) = mulExp(utilizationRate, ReserveLow);\n', '            assert(err == Error.NO_ERROR);\n', '            (err, tempScaled2) = addExp(tempScaled, SpreadLow);\n', '            annualBorrowRateScaled = tempScaled2.mantissa;\n', '            assert(err == Error.NO_ERROR);\n', '        }\n', '        else if (utilizationRate.mantissa > BreakPointHigh.mantissa) {\n', '            (err, tempScaled) = mulExp(utilizationRate, ReserveHigh);\n', '            assert(err == Error.NO_ERROR);\n', '            (err, tempScaled2) = addExpNegative(tempScaled, SpreadHigh);\n', '            annualBorrowRateScaled = tempScaled2.mantissa;\n', '            assert(err == Error.NO_ERROR);\n', '        }\n', '        else if (utilizationRate.mantissa >= BreakPointLow.mantissa && utilizationRate.mantissa <= BreakPointHigh.mantissa) {\n', '            (err, tempScaled) = mulExp(utilizationRate, ReserveMid);\n', '            assert(err == Error.NO_ERROR);\n', '            (err, tempScaled2) = addExp(tempScaled, SpreadMid);\n', '            annualBorrowRateScaled = tempScaled2.mantissa;\n', '            assert(err == Error.NO_ERROR);\n', '        }\n', '\n', '        return (IRError.NO_ERROR, utilizationRate, Exp({mantissa: annualBorrowRateScaled / 100}));\n', '    }\n', '\n', '    /**\n', '      * @notice Gets the current supply interest rate based on the given asset, total cash and total borrows\n', '      * @dev The return value should be scaled by 1e18, thus a return value of\n', '      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n', '      * @param _asset The asset to get the interest rate of\n', '      * @param cash The total cash of the asset in the market\n', '      * @param borrows The total borrows of the asset in the market\n', '      * @return Success or failure and the supply interest rate per block scaled by 10e18\n', '      */\n', '    function getSupplyRate(address _asset, uint cash, uint borrows) public view returns (uint, uint) {\n', '        _asset; // pragma ignore unused argument\n', '        (IRError err0, Exp memory utilizationRate0, Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n', '        if (err0 != IRError.NO_ERROR) {\n', '            return (uint(err0), 0);\n', '        }\n', '\n', '       /**\n', '       *  Supply Rate\n', '       *  = BorrowRate * utilizationRate * (1 - SpreadLow)\n', '       */\n', '       Exp memory temp1;\n', '       Error err1;\n', '       Exp memory oneMinusSpreadBasisPoints;\n', '       (err1,temp1) = getExp(100,1);\n', '       assert(err1 == Error.NO_ERROR);\n', '       (err1,oneMinusSpreadBasisPoints) = subExp(temp1,SpreadLow);\n', '\n', '        // mulScalar only overflows when product is greater than or equal to 2^256.\n', "        // utilization rate's mantissa is a number between [0e18,1e18]. That means that\n", '        // utilizationRate1 is a value between [0e18,8.5e21]. This is strictly less than 2^256.\n', '        assert(err1 == Error.NO_ERROR);\n', '\n', '        // Next multiply this product times the borrow rate\n', '        (err1, temp1) = mulExp(utilizationRate0, annualBorrowRate);\n', '        // If the product of the mantissas for mulExp are both less than 2^256,\n', '        // then this operation will never fail. TODO: Verify.\n', '        // We know that borrow rate is in the interval [0, 2.25e17] from above.\n', '        // We know that utilizationRate1 is in the interval [0, 9e21] from directly above.\n', '        // As such, the multiplication is in the interval of [0, 2.025e39]. This is strictly\n', '        // less than 2^256 (which is about 10e77).\n', '        assert(err1 == Error.NO_ERROR);\n', '\n', '        (err1, temp1) = mulExp(temp1, oneMinusSpreadBasisPoints);\n', '        assert(err1 == Error.NO_ERROR);\n', '\n', "        // And then divide down by the spread's denominator (basis points divisor)\n", '        // as well as by blocks per year.\n', '        (Error err4, Exp memory supplyRate) = divScalar(temp1, 10000 * blocksPerYear); // basis points * blocks per year\n', '        // divScalar only fails when divisor is zero. This is clearly not the case.\n', '        assert(err4 == Error.NO_ERROR);\n', '\n', '        return (uint(IRError.NO_ERROR), supplyRate.mantissa);\n', '    }\n', '\n', '    /**\n', '      * @notice Gets the current borrow interest rate based on the given asset, total cash and total borrows\n', '      * @dev The return value should be scaled by 1e18, thus a return value of\n', '      *      `(true, 1000000000000)` implies an interest rate of 0.000001 or 0.0001% *per block*.\n', '      * @param asset The asset to get the interest rate of\n', '      * @param cash The total cash of the asset in the market\n', '      * @param borrows The total borrows of the asset in the market\n', '      * @return Success or failure and the borrow interest rate per block scaled by 10e18\n', '      */\n', '    function getBorrowRate(address asset, uint cash, uint borrows) public view returns (uint, uint) {\n', '        asset; // pragma ignore unused argument\n', '\n', '        (IRError err0, , Exp memory annualBorrowRate) = getUtilizationAndAnnualBorrowRate(cash, borrows);\n', '        if (err0 != IRError.NO_ERROR) {\n', '            return (uint(err0), 0);\n', '        }\n', '\n', '        // And then divide down by blocks per year.\n', '        (Error err1, Exp memory borrowRate) = divScalar(annualBorrowRate, blocksPerYear); // basis points * blocks per year\n', '        // divScalar only fails when divisor is zero. This is clearly not the case.\n', '        assert(err1 == Error.NO_ERROR);\n', '\n', '        // Note: mantissa is the rate scaled 1e18, which matches the expected result\n', '        return (uint(IRError.NO_ERROR), borrowRate.mantissa);\n', '    }\n', '}']