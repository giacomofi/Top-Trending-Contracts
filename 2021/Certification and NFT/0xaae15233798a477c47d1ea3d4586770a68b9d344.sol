['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-02\n', '*/\n', '\n', 'pragma solidity ^0.5.16;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', 'interface GasToken {\n', '    function freeFromUpTo(address from, uint256 value) external returns (uint256 freed);\n', '}\n', 'contract SigRelayer2 {\n', '\tmodifier discountGST2 {\n', '\t\tuint256 gasStart = gasleft();\n', '\t\t_;\n', '\t\tuint256 gasSpent = 21000 + gasStart - gasleft() + 16 * msg.data.length;\n', '\t\tuint gas_left = gasleft();\n', '\t\tuint maxtokens = (gas_left - 27710) / 7020;\n', '\t\tuint tokens = (gasSpent + 14154) / 41130;\n', '\t\tif(tokens > maxtokens) tokens = maxtokens;\n', '\t\tGasToken(0x0000000000b3F879cb30FE243b4Dfee438691c04).freeFromUpTo(msg.sender, tokens);\n', '\t}\n', '\n', '\tbytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '\tbytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");\n', '\tbytes32 public constant BALLOT_TYPEHASH = keccak256("Ballot(uint256 proposalId,uint8 support)");\n', '\tstring public constant name = "Compound";\n', '\tstring public constant name2 = "Compound Governor Bravo";\n', '\n', '\taddress public governorBravo;\n', '\taddress public compToken;\n', '\taddress public owner;\n', '\n', '\tconstructor(address governorBravo_, address compToken_) public {\n', '\t\tgovernorBravo = governorBravo_;\n', '\t\tcompToken = compToken_;\n', '\t\towner = msg.sender;\n', '\t}\n', '\n', '\tfunction setGovernorBravo(address governorBravo_) public  {\n', '\t\trequire(msg.sender == owner);\n', '\t\tgovernorBravo = governorBravo_;\n', '\t}\n', '\n', '\n', '\tfunction relayBySigsGST(DelegationSig[] memory s1, VoteSig[] memory s2) public discountGST2 {\n', '\t\tfor (uint i = 0; i < s1.length; i++) {\n', '\t\t\tDelegationSig memory sig = s1[i];\n', '\t\t\tcompToken.call(abi.encodeWithSignature("delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)", sig.delegatee, sig.nonce, sig.expiry, sig.v, sig.r, sig.s));\n', '\t\t}\n', '\t\tfor (uint i = 0; i < s2.length; i++) {\n', '\t\t\tVoteSig memory sig = s2[i];\n', '\t\t\tgovernorBravo.call(abi.encodeWithSignature("castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)", sig.proposalId,sig.support,sig.v,sig.r,sig.s));\n', '\t\t}\n', '\t}\n', '\n', '\tfunction relayBySigs(DelegationSig[] memory s1, VoteSig[] memory s2) public {\n', '\t\tfor (uint i = 0; i < s1.length; i++) {\n', '\t\t\tDelegationSig memory sig = s1[i];\n', '\t\t\tcompToken.call(abi.encodeWithSignature("delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)", sig.delegatee, sig.nonce, sig.expiry, sig.v, sig.r, sig.s));\n', '\t\t}\n', '\t\tfor (uint i = 0; i < s2.length; i++) {\n', '\t\t\tVoteSig memory sig = s2[i];\n', '\t\t\tgovernorBravo.call(abi.encodeWithSignature("castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)", sig.proposalId,sig.support,sig.v,sig.r,sig.s));\n', '\t\t}\n', '\t}\n', '\n', '\tfunction signatoryFromDelegateSig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public view returns (address) {\n', '\t    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), compToken));\n', '\t    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n', '\t    bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '\t    address signatory = ecrecover(digest, v, r, s);\n', '\t    require(signatory != address(0), "invalid signature");\n', '\t    require(now <= expiry, "signature expired");\n', '\t    return signatory;\n', '\t}\n', '\n', '\tfunction signatoryFromVoteSig(uint proposalId, uint8 support, uint8 v, bytes32 r, bytes32 s) public view returns (address) {\n', '\t    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name2)), getChainId(), governorBravo));\n', '\t    bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n', '\t    bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '\t    address signatory = ecrecover(digest, v, r, s);\n', '\t    require(signatory != address(0), "invalid signature");\n', '\t    return signatory;\n', '\t}\n', '\n', '\n', '  \tstruct DelegationSig {\n', '\t    address delegatee;\n', '\t    uint nonce;\n', '\t    uint expiry;\n', '\t    uint8 v;\n', '\t    bytes32 r;\n', '\t    bytes32 s;\n', '  \t}\n', '  \tstruct VoteSig {\n', '  \t\tuint proposalId;\n', '  \t\tuint8 support;\n', '  \t\tuint8 v;\n', '  \t\tbytes32 r;\n', '  \t\tbytes32 s;\n', '  \t}\n', '\n', '  \tfunction getChainId() internal pure returns (uint) {\n', '        uint256 chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '}']