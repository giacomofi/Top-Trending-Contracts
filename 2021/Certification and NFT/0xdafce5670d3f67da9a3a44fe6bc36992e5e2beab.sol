['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-18\n', '*/\n', '\n', '// SPDX-License-Identifier: No\n', '\n', '// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts-ethereum-package/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/v612/DELTA/Periphery/DELTA_Limited_Staking_Window.sol\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', '\n', '\n', '\n', '\n', 'interface IWETH {\n', '    function deposit() external payable;\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function withdraw(uint) external;\n', '    function balanceOf(address) external returns (uint256);\n', '}\n', '\n', 'interface IRLP {\n', '  function rebase() external;\n', '  function wrap() external;\n', '  function setBaseLPToken(address) external;\n', '  function openRebasing() external;\n', '  function balanceOf(address) external returns (uint256);\n', '  function transfer(address, uint256) external returns (bool);\n', '}\n', '\n', 'interface IDELTA_DEEP_FARMING_VAULT {\n', '    function depositFor(address, uint256,uint256) external;\n', '}\n', '\n', 'interface IRESERVE_VAULT {\n', '    function setRatio(uint256) external;\n', '}\n', '\n', 'contract DELTA_Limited_Staking_Window {\n', '  using SafeMath for uint256;\n', '  \n', '  struct LiquidityContribution {\n', '    address byWho;\n', '    uint256 howMuchETHUnits;\n', '    uint256 contributionTimestamp;\n', '    uint256 creditsAdded;\n', '  }\n', '\n', '\n', '  //////////\n', '  // STORAGE\n', '  //////////\n', '\n', '  ///////////\n', '  // Unchanging variables and constants \n', '  /// @dev All this variables should be set only once. Anything else is a bug.\n', '\n', '  // Constants\n', '  address constant internal UNISWAP_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n', '  address public DELTA_FINANCIAL_MULTISIG;\n', '  /// @notice the person who sets the multisig wallet, happens only once\n', '  // This person has no power over the contract only power to set the multisig wallet\n', '  address immutable public INTERIM_ADMIN;\n', '  IWETH constant public wETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n', '  address public reserveVaultAddress;\n', '  address public deltaDeepFarmingVaultAddress;\n', '  uint256 public LSW_RUN_TIME = 10 days;\n', '  uint256 public constant MAX_ETH_POOL_SEED = 1500 ether;\n', '\n', '  // @notice periode after the LSW is ended to claim the LP and the bonuses\n', '  uint256 public constant CLAIMING_PERIOD = 30 days;\n', '  uint256 public constant MAX_TIME_BONUS_PERCENT = 30;\n', '\n', '  IRLP public rebasingLP; // Wrapped LP\n', '  address public deltaTokenAddress;\n', '\n', '  ///////////\n', '\n', '  ///////////\n', '  // Referral handling variables\n', '  /// @dev Variables handling referral bonuses and IDs calculations\n', '\n', '  /// @dev Sequential referral IDs (skipping 0)\n', '  uint256 public totalReferralIDs; \n', '  /// @dev mappings and reverse mapping handling the referral id ( for links to be smaller)\n', '  mapping(uint256 => address) public referralCodeMappingIndexedByID; \n', '  mapping(address => uint256) public referralCodeMappingIndexedByAddress;\n', "  /// @dev we store bonus WETH in this variable because we don't want to send it until LSW is over... Because of the possibility of refund\n", '  mapping(address => uint256) public referralBonusWETH;\n', '  /// @dev boolean flag if the user already claimed his WETH bonus\n', '  mapping(address => bool) public referralBonusWETHClaimed;\n', '  uint256 public totalWETHEarmarkedForReferrers;\n', '\n', '  ///////////\n', '\n', '\n', '  ///////////\n', '  // Liquidity contribution variables\n', '  /// @dev variables for storing liquidity contributions and subsequent calculation for LP distribution\n', '\n', '  /// @dev An array of all contributions with metadata\n', '  LiquidityContribution [] public liquidityContributionsArray;\n', "  /// @dev This is ETH contributed by the specific person, it doesn't include any bonuses this is used to handle refunds\n", '  mapping(address => uint256) public liquidityContributedInETHUnitsMapping;  \n', '  /// @notice Each person has a credit based on their referrals and other bonuses as well as ETH contributions. This is what is used for owed LP\n', '  mapping(address => uint256) public liquidityCreditsMapping;\n', '  /// @dev a boolean flag for an address to signify they have already claimed LP owed to them\n', '  mapping(address => bool) public claimedLP;\n', '  /// @notice Calculated at the time of liquidity addition. RLP per each credit\n', '  /// @dev stored multiplied by 1e12 for change\n', '  uint256 public rlpPerCredit;\n', '  /// @dev total Credit inside the smart contract used for ending calculation for rlpPerCredit\n', '  uint256 public totalCreditValue;\n', '  ///////////\n', '\n', '\n', '  ///////////\n', '  // Refund handling variables\n', '\n', '  /// @notice Variables used for potential refund if the liquidity addition fails. This failover happens 2 days after LSW is supposed to be over, and its is not.\n', '  /// @dev mapping of boolean flags if the user already claimed his refund\n', '  mapping(address => bool) public refundClaimed;\n', '  /// @notice boolean flag that can be initiated if LSW didnt end 2 days after it was supposed to calling the refund function.\n', '  /// @dev This opens refunds, refunds do not adjust anything except the above mapping. Its important this variable is never triggered\n', '  bool public refundsOpen;\n', '  ///////////\n', '\n', '  ///////////\n', '  // Handling LSW timing variables\n', '\n', '  /// @dev variables for length of LSW, separate from constant ones above\n', '  bool public liquidityGenerationHasStarted;\n', '  bool public liquidityGenerationHasEnded;\n', '  /// @dev timestamps are not dynamic and generated upon calling the start function\n', '  uint256 public liquidityGenerationStartTimestamp;\n', '  uint256 public liquidityGenerationEndTimestamp;\n', '  ///////////\n', '\n', '\n', '\n', '  // constructor is only called by the token contract\n', '  constructor() public {\n', '      INTERIM_ADMIN = msg.sender;\n', '  }\n', '\n', '\n', "  /// @dev fallback on eth sent to the contract ( note WETH doesn't send ETH to this contract so no carveout is needed )\n", '  receive() external payable {\n', '    revertBecauseUserDidNotProvideAgreement();\n', '  }\n', '\n', '  function setMultisig(address multisig) public {\n', '      onlyInterimAdmin();\n', '    \n', '      require(DELTA_FINANCIAL_MULTISIG == address(0), "only set once");\n', '      DELTA_FINANCIAL_MULTISIG = multisig;\n', '  }\n', '\n', '  function onlyInterimAdmin() public view {\n', '      require(INTERIM_ADMIN == msg.sender, "wrong");\n', '  }\n', '\n', '  function setReserveVault(address reserveVault) public {\n', '      onlyMultisig();\n', '      reserveVaultAddress = reserveVault;\n', '  }\n', '\n', '  /// Helper functions\n', '  function setRLPWrap(address rlpAddress) public {\n', '      onlyMultisig();\n', '      rebasingLP = IRLP(rlpAddress);\n', '  }\n', '\n', '  function setDELTAToken(address deltaToken, bool delegateCall) public {\n', '      onlyMultisig();\n', '      if(delegateCall == false) {\n', '        deltaTokenAddress = deltaToken;\n', '      } else {\n', '          bytes memory callData = abi.encodePacked(bytes4(keccak256(bytes("getTokenInfo()"))), "");\n', '        (,bytes memory addressDelta)= deltaToken.delegatecall(callData);\n', '        deltaTokenAddress = abi.decode(addressDelta, (address));\n', '      }\n', '  }\n', '\n', '  function setFarmingVaultAddress(address farmingVault) public {\n', '      onlyMultisig();\n', '      deltaDeepFarmingVaultAddress = farmingVault;\n', '      require(address(rebasingLP) != address(0), "Need rlp to be set");\n', '      require(farmingVault != address(0), "Provide an address for farmingVault");\n', '      IERC20(address(rebasingLP)).approve(farmingVault, uint(-1));\n', '  }\n', '  \n', '  function extendLSWEndTime(uint256 numberSeconds) public {\n', '      onlyMultisig();\n', '      liquidityGenerationEndTimestamp = liquidityGenerationEndTimestamp.add(numberSeconds);\n', '      LSW_RUN_TIME = LSW_RUN_TIME.add(numberSeconds);\n', '  }\n', '\n', '\n', '\n', '  /// @notice This function starts the LSW and opens deposits and creates the RLP wrap\n', '  function startLiquidityGeneration() public {\n', '    onlyMultisig();\n', '\n', '    // We check that this is called by the correct authorithy\n', '    /// @dev deltaToken has a time countdown in it that will make this function avaible to call \n', '    require(liquidityGenerationHasStarted == false, "startLiquidityGeneration() called when LSW had already started");\n', '\n', '    // We start the LSW\n', '    liquidityGenerationHasStarted = true;\n', '    // Informational timestamp only written here\n', '    // All calculations are based on the variable below end timestamp and run time which is used to bonus calculations\n', '    liquidityGenerationStartTimestamp = block.timestamp;\n', '    liquidityGenerationEndTimestamp = liquidityGenerationStartTimestamp + LSW_RUN_TIME;\n', '\n', '  }\n', ' \n', '  /// @notice publically callable function that assigns a sequential shortened referral ID so a long one doesnt need to be provided in the URL\n', '  function makeRefCode() public returns (uint256) {\n', '    // If that address already has one, we dont make a new one\n', '    if(referralCodeMappingIndexedByAddress[msg.sender] != 0){\n', '       return referralCodeMappingIndexedByAddress[msg.sender];\n', '     }\n', '     else {\n', '       return _makeRefCode(msg.sender);\n', '     }\n', '  }\n', '\n', '  /// @dev Assigns a unique index to referrers, starting at 1\n', '  function _makeRefCode(address referrer) internal returns (uint256) {\n', '      totalReferralIDs++; // lead to skip 0 code for the LSW \n', '      // Populate reverse as well for lookup above\n', '      referralCodeMappingIndexedByID[totalReferralIDs] = referrer;\n', '      referralCodeMappingIndexedByAddress[msg.sender] = totalReferralIDs;\n', '      return totalReferralIDs;\n', '  }\n', '\n', '  /// @dev Not using modifiers is a purposeful choice for code readability.\n', '  function revertBecauseUserDidNotProvideAgreement() internal pure {\n', '    revert("No agreement provided, please review the smart contract before interacting with it");\n', '  }\n', '\n', '\n', '  function adminEndLSWAndRefundEveryone() public {\n', '    onlyMultisig();\n', '    liquidityGenerationEndTimestamp = 0;\n', '    openRefunds();\n', '  }\n', '\n', '  function onlyMultisig() public view {\n', '    require(msg.sender == DELTA_FINANCIAL_MULTISIG, "FBI OPEN UP");\n', '  }\n', '\n', '\n', '  /// @notice a publically callable function that ends the LSW, adds liquidity and splits RLP for each credit.\n', '  function endLiquidityDeployment() public {\n', '    // Check if it already ended\n', '    require(block.timestamp > liquidityGenerationEndTimestamp.add(5 minutes), "LSW Not over yet."); // Added few blocks here\n', '    // Check if it was already run\n', '    require(liquidityGenerationHasEnded == false, "LSW Already ended");\n', '    require(refundsOpen == false, "Refunds Opened, no ending");\n', '\n', '    // Check if all variable addresses are set\n', '    // This includes the delta token\n', '    // Rebasing lp wrap\n', '    // Reserve vault which acts as options plunge insurance and floor price reserve \n', '    // And operating capital for loans\n', '    // And the farming vault which is used to auto stake in it\n', '    require(deltaTokenAddress != address(0), "Delta Token is not set");\n', '    require(address(rebasingLP) != address(0), "Rlp is not set");\n', '    require(address(reserveVaultAddress) != address(0), "Reserve Vault is not set");\n', '    require(address(deltaDeepFarmingVaultAddress) != address(0), "Deep farming vault isn\'t set");\n', '\n', '    // We wrap the delta token in the interface\n', '    IERC20 deltaToken = IERC20(deltaTokenAddress);\n', '    // Check the balance we have\n', "    // Note : if the process wan't complete correctly, the balance here would be wrong\n", '    // Because DELTA token returns a balanace \n', '    uint256 balanceOfDELTA = deltaToken.balanceOf(address(this)); \n', '    // We make sure we for sure have the total supply\n', '    require(balanceOfDELTA == deltaToken.totalSupply(), "Did not get the whole supply of deltaToken");\n', '    /// We mkake sure the supply is equal to the agreed on 45mln\n', '    require(balanceOfDELTA == 45_000_000e18, "Did not get the whole supply of deltaToken");\n', '\n', '    // Optimistically get pair\n', '    address deltaWethUniswapPair = IUniswapV2Factory(UNISWAP_FACTORY).getPair(deltaTokenAddress, address(wETH));\n', "    if(deltaWethUniswapPair == address(0)) { // Pair doesn't exist yet \n", '      // create pair returns address\n', '      deltaWethUniswapPair = IUniswapV2Factory(UNISWAP_FACTORY).createPair(\n', '        deltaTokenAddress,\n', '        address(wETH)\n', '      );\n', '    }\n', '\n', '    // Split between DELTA financial and pool\n', '    // intented outcome 50% split between pool and further fund for tokens and WETH\n', '    uint256 balanceWETHPreSplit = wETH.balanceOf(address(this));\n', '    require(balanceWETHPreSplit > 0, "Not enough WETH");\n', '    wETH.transfer(DELTA_FINANCIAL_MULTISIG, balanceWETHPreSplit.div(2)); // send half\n', '    uint256 balanceWETHPostSplit = wETH.balanceOf(address(this)); // requery\n', '    // We remove the WETH we had earmarked for referals\n', '    uint256 balanceWETHPostReferal = balanceWETHPostSplit.sub(totalWETHEarmarkedForReferrers);\n', '\n', '    /// @dev note this will revert if there is less than 1500 eth at this stage\n', "    /// We just want refunds if that's the case cause it's not worth bothering\n", '    uint256 balanceWETHForReserves = balanceWETHPostReferal.sub(MAX_ETH_POOL_SEED, "Not enough ETH");\n', '\n', '    /// @dev we check that bonuses are less than 5% of total deposited because they should be at max 5\n', '    /// Anything else is a issue\n', '    /// Note added 1ETH for possible change\n', '    require(totalWETHEarmarkedForReferrers <= balanceWETHPreSplit.div(20).add(1e18), "Sanity check failure 3");\n', '    wETH.transfer(reserveVaultAddress, balanceWETHForReserves);\n', '    // We seed the pool with WETH\n', '    wETH.transfer(deltaWethUniswapPair, MAX_ETH_POOL_SEED);\n', '    require(wETH.balanceOf(address(this)) == totalWETHEarmarkedForReferrers, "Math Error");\n', '\n', '    // Transfer DELTA\n', '    /// @dev this address is already mature as in it has 100% of DELTA in its balance \n', '    uint256 deltaForPoolAndReserve = balanceOfDELTA.div(2);\n', '    /// Smaller number / bigger number = float  with 1000 for precision\n', '    uint256 percentOfBalanceToReserves = MAX_ETH_POOL_SEED.mul(1000).div(balanceWETHPostReferal);\n', '    // We take the precision out here\n', '    uint256 delfaForPool = deltaForPoolAndReserve.mul(percentOfBalanceToReserves).div(1000);\n', '\n', '    // transfer to pool\n', '    deltaToken.transfer(deltaWethUniswapPair, delfaForPool);\n', '    // We check if we are not sending 10% by mistake not whitelisting this address for whole sends\n', "    // Note we don't check the rest because it should not deviate \n", '    require(deltaToken.balanceOf(deltaWethUniswapPair) == delfaForPool, "LSW did not get permissions to send directly to balance");\n', '    // Transfer to team vesting\n', '    deltaToken.transfer(DELTA_FINANCIAL_MULTISIG, balanceOfDELTA.div(2));\n', '    // transfer to floor/liqudation insurance reserves\n', '    deltaToken.transfer(reserveVaultAddress, deltaToken.balanceOf(address(this))); // queried again in case of rounding problems\n', '    \n', '    /// This ratio is set as how much 1 whole eth buys\n', '    /// Since eth is 1e18 and delta is same we can do this here\n', "    /// Note that we don't expect 45mln eth so we dont really lose precision (delta supply is 45mln)\n", '    IRESERVE_VAULT(reserveVaultAddress).setRatio(\n', '        delfaForPool.div(MAX_ETH_POOL_SEED)\n', '    );\n', '\n', '    // just wrapping in the interface\n', '    IUniswapV2Pair newPair = IUniswapV2Pair(deltaWethUniswapPair);\n', '    // Add liquidity\n', '    newPair.mint(address(this)); //transfer LP here\n', '    // WE approve the rlp to spend because thats what the wrap function uses (transferFor)\n', '    newPair.approve(address(rebasingLP), uint(-1));\n', '\n', '    // We set the base token in a whitelist for rLP for LSW\n', '    rebasingLP.setBaseLPToken(address(newPair));\n', '\n', '    /// @dev outside call, this function is supposed to wrap all LP of this address and issue rebasibngLP and send it to this address\n', '    /// This switch is 1:1 1LP for 1 rebasingLP\n', '    rebasingLP.wrap();\n', '\n', '    // Rebase liquidity \n', '    /// @notice First rebase rebases RLP 3x. This means this would hit the gas limit if it was made in this call. \n', '    /// So it just triggers a boolean flag to rebase and then trading is opened.\n', '    /// @dev itended side effect of this is flipping a boolean flag inside the rebasingLP contract. It will open the rebasing function to be called about 30 times\n', '    /// Until its called that amount of times trading or transfering of DELTA token will not be opened. \n', '    /// This is done so price of RLP will be 3x that it was minted at instantly. Also will generate about 30bln in volume\n', '    rebasingLP.openRebasing();\n', '    // Split LP per Credit\n', '    uint256 totalRLP = rebasingLP.balanceOf(address(this));\n', '    require(totalRLP > 0, "Sanity check failure 1");\n', '    // We store as 1e12 more for change\n', '    rlpPerCredit = totalRLP.mul(1e12).div(totalCreditValue);\n', '    require(rlpPerCredit > 0, "Sanity check failure 2");\n', '\n', '    // Finalize to open claims (claimLP and ETH claiming for referal)\n', '    liquidityGenerationHasEnded = true;\n', '  }\n', '\n', '  function claimOrStakeAndClaimLP(bool claimToWalletInstead) public {\n', '    // Make sure the LSW ended ( this is set in fn endLiquidityDeployment() only)\n', '    // And is only set when all checks have passed and we good\n', '    require(liquidityGenerationHasEnded, "Liquidity Generation isn\'t over");\n', '\n', "    // Make sure the claiming period isn't over\n", '    // Note that we hav ea claiming period here so rLP doesnt get stuck or ETH doesnt get stuck in thsi contract\n', '    // This is because of the referal system having wrong addresses in it possibly\n', '    require(block.timestamp < liquidityGenerationEndTimestamp.add(CLAIMING_PERIOD), "Claiming period is over");\n', '  \n', '    // Make sure the person has something to claim\n', '    require(liquidityContributedInETHUnitsMapping[msg.sender] > 0, "You have nothing to claim.");\n', '    // Make sure the person hasnt already claimed\n', '    require(claimedLP[msg.sender] == false, "You have already claimed.");\n', '    // Set the already claimed flag\n', '    claimedLP[msg.sender] = true;\n', '\n', '    // We calculate the amount of rebasing LP due\n', '    uint256 rlpDue = liquidityCreditsMapping[msg.sender].mul(rlpPerCredit).div(1e12);\n', '    // And send it out\n', '    // We check if the person wants to claim to the wallet, the default is to stake it for him in the vault\n', '    if(claimToWalletInstead) {\n', '        rebasingLP.transfer(msg.sender, rlpDue);\n', '    }\n', '    else {\n', '        IDELTA_DEEP_FARMING_VAULT(deltaDeepFarmingVaultAddress).depositFor(msg.sender,rlpDue,0);\n', '    }\n', '  }\n', '\n', '\n', '\n', '  /// @dev we loop over all liquidity contributions of a person and return them here for front end display\n', '  /// Note this might suffer from gas limits on infura if there are enogh deposits and we are aware of that\n', '  /// Its just a nice helper function that is not nessesary\n', '  function allLiquidityContributionsOfAnAddress(address person) public view returns (LiquidityContribution  [] memory liquidityContributionsOfPerson) {\n', '\n', '    uint256 j; // Index of the memory array\n', '\n', '    /// @dev we grab liquidity contributions at current index and compare to the provided address, and if it matches we push it to the array\n', '    for(uint256 i = 0; i < liquidityContributionsArray.length; i++) {\n', '      LiquidityContribution memory currentContribution = liquidityContributionsArray[i];\n', '      if(currentContribution.byWho == person) {\n', '        liquidityContributionsOfPerson[j] = currentContribution;\n', '        j++;\n', '      }\n', '    }\n', '  }\n', '\n', '\n', '  /// @notice Sends the bonus WETH to the referer after LSW is over.\n', '  function getWETHBonusForReferrals() public {\n', '    require(liquidityGenerationHasEnded == true, "LSW Not ended");\n', '\n', "    // Make sure the claiming period isn't over\n", '    // This is done in case ETH is stuck with malformed addresses\n', '    require(block.timestamp < liquidityGenerationEndTimestamp.add(CLAIMING_PERIOD), "Claiming period is over");\n', '    require(referralBonusWETHClaimed[msg.sender] == false, "Already claimed, check wETH balance not ETH");\n', '    require(referralBonusWETH[msg.sender] > 0, "nothing to claim");\n', '    /// @dev flag as claimed so no other calls is possible to this\n', '    /// Note that even if reentry was possible here we set it first before sending out weth\n', '    referralBonusWETHClaimed[msg.sender] = true;\n', '    /// @dev wETH transfer( token ) has no hook possibility\n', '    wETH.transfer(msg.sender, referralBonusWETH[msg.sender]); \n', '  }\n', '\n', '  /// @notice Transfer any remaining tokens in the contract\n', '  /// This is done after the claiming period is over in case there are malformed not claimed referal amounts \n', '  function finalizeLSW(address _token) public {\n', '    onlyMultisig();\n', '\n', '    require(liquidityGenerationHasEnded == true, "LSW Not ended");\n', '    require(block.timestamp >= liquidityGenerationEndTimestamp.add(CLAIMING_PERIOD), "Claiming period is not over");\n', '    \n', '    IERC20 token = IERC20(_token);\n', '\n', '    /// @dev Transfer remaining tokens to the team. Those are tokens that has been\n', '    /// unclaimed or transferred to the contract.\n', '    token.transfer(DELTA_FINANCIAL_MULTISIG, token.balanceOf(address(this)));\n', '  }\n', '\n', '  /// @notice this function allows anyone to refund the eth deposited in case the contract cannot finish\n', '  /// This is a nessesary function because of the contrract not having admin controls\n', '  /// And is only here as a safety pillow failure\n', '  function getRefund() public {\n', '    require(refundsOpen, "Refunds are not open");\n', '    require(refundClaimed[msg.sender]  == false, "Already got a refund, check your wETH balance.");\n', '    refundClaimed[msg.sender] = true;\n', '\n', '    // We send wETH9 here so there is no callback\n', '    wETH.transfer(msg.sender, liquidityContributedInETHUnitsMapping[msg.sender]);\n', '  }\n', '\n', '  // This function opens refunds,  if LSW didnt finish 2 days after it was supposed to. This means something went wrong.\n', '  function openRefunds() public {\n', '\n', '    require(liquidityGenerationHasEnded == false, "Liquidity generation has ended"); // We correctly ended the LSW\n', '    require(liquidityGenerationHasStarted == true, "Liquidity generation has not started");\n', '    // Liquidity genertion should had ended 2 days ago!\n', '    require(block.timestamp > liquidityGenerationEndTimestamp.add(2 days), "Post LSW grace period isn\'t over");\n', '    /// This can be set over and over again with no issue here\n', '    refundsOpen = true;\n', '\n', '  }\n', '\n', '\n', '  /// @dev Returns bonus in credit units, and adds and calculates credit for the referrer\n', '  /// @return credit units (something like wETH but in credit) this is for the referee ( person who was refered)\n', '  function handleReferredDepositWithAddress(address referrerAddress) internal returns (uint256) {\n', '\n', '    if(referrerAddress == msg.sender)  { return 0; } //We dont let self referrals and bail here without any bonuses.\n', '\n', '    require(msg.value > 0, "Sanity check failure");\n', '    uint256 wETHBonus = msg.value.div(20); // 5%\n', '    uint256 creditBonus = wETHBonus; // Samesies\n', '    totalWETHEarmarkedForReferrers = totalWETHEarmarkedForReferrers.add(wETHBonus);\n', '    require(wETHBonus > 0 && creditBonus > 0 , "Sanity check failure 2");\n', '\n', '    // We give 5% wETH of the deposit to the person\n', '    referralBonusWETH[referrerAddress] = referralBonusWETH[referrerAddress].add(wETHBonus);\n', '\n', '    //We add credit\n', '    liquidityCreditsMapping[referrerAddress] = liquidityCreditsMapping[referrerAddress].add(creditBonus);\n', '    // Update total credits\n', '    totalCreditValue = totalCreditValue.add(creditBonus);\n', '    \n', '    // We return 10% bonus for the person who was refered\n', '    return creditBonus.mul(2);\n', '  }\n', '\n', '  /// @dev checks if a address for this referral ID exists, if it doesnt just returns 0 skipping the adding function\n', '  function handleReferredDepositWithReferralID(uint256 referralID) internal returns (uint256 personWhoGotReferedBonus) {\n', '    address referrerAddress = referralCodeMappingIndexedByID[referralID];\n', '    // We check if the referral number was registered, and if its not the same person.\n', '    if(referrerAddress != address(0) && referrerAddress != msg.sender) {\n', '      return handleReferredDepositWithAddress(referrerAddress);\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function secondsLeftInLiquidityGenerationEvent() public view returns ( uint256 ) {\n', '\n', '    if(block.timestamp >= liquidityGenerationEndTimestamp) { return 0; }\n', '    return liquidityGenerationEndTimestamp - block.timestamp;\n', '\n', '  }\n', '\n', '  function liquidityGenerationParticipationAgreement() public pure returns (string memory) {\n', '    return "I understand that I\'m interacting with a smart contract. I understand that liquidity im providing is locked forever. I reviewed code of the smart contract and understand it fully. I agree to not hold developers or other people associated with the project to liable for any losses of misunderstandings";\n', '  }\n', '\n', '  // referrerAddress or referralID must be provided, the unused parameter should be left as 0\n', '  function contributeLiquidity(bool readAndAgreedToLiquidityProviderAgreement, address referrerAddress, uint256 referralID) public payable {\n', '    require(refundsOpen == false, "Refunds Opened, no deposit");\n', '    // We check that LSW has already started\n', '    require(liquidityGenerationHasStarted, "Liquidity generation did not start");\n', "    // We check if liquidity generation didn't end\n", '    require(liquidityGenerationHasEnded == false, "Liquidity generation has ended");\n', '    // We check if liquidity genration still has time in it\n', '    require(secondsLeftInLiquidityGenerationEvent() > 0, "Liquidity generation has ended 2");\n', '    // We check if user agreed with the terms of the smart contract\n', '    if(readAndAgreedToLiquidityProviderAgreement == false) {\n', '      revertBecauseUserDidNotProvideAgreement();\n', '    }\n', '    require(msg.value > 0, "Ethereum needs to be provided");\n', '\n', '    // We add credit bonus, which is 10% if user is referred\n', '    // RefID takes precedence here\n', '    uint256 creditBonus;\n', '    if(referralID != 0) {\n', '      creditBonus = handleReferredDepositWithReferralID(referralID); // TO REVIEW: handleReferredDepositWithReferralID returns the reward (referrer and referee)\n', '    } else if (referrerAddress != address(0)){\n', '      creditBonus = handleReferredDepositWithAddress(referrerAddress); // TO REVIEW: handleReferredDepositWithReferralID returns the reward (referrer and referee)\n', '    } // Else bonus is 0\n', '\n', '    // We add the time bonus to the credit \n', '    creditBonus = creditBonus.add(calculateCreditBonusBasedOnCurrentTime(msg.value));\n', '\n', '    // Credit bonus should never be bigger than credit here. Max 30% + 10%. Aka 40% of msg.value\n', '    // Note this is a magic number here, since we dont really want to read the max bonus again from storage\n', '    require(msg.value.mul(41).div(100) > creditBonus, "Sanity check failure");\n', '\n', '    // We update the global number of credit so we can distribute LP later\n', '    uint256 creditValue = msg.value.add(creditBonus);\n', '    totalCreditValue = totalCreditValue.add(creditValue);\n', '\n', '    // Give the person credit and the bonus\n', '    liquidityCreditsMapping[msg.sender] = liquidityCreditsMapping[msg.sender].add(creditValue);\n', '    // Save the persons deposit for refunds in case\n', '    liquidityContributedInETHUnitsMapping[msg.sender] = liquidityContributedInETHUnitsMapping[msg.sender].add(msg.value);\n', '\n', '    // We add it to array of all deposits\n', '    liquidityContributionsArray.push(LiquidityContribution({\n', '      byWho : msg.sender,\n', '      howMuchETHUnits : msg.value,\n', '      contributionTimestamp : block.timestamp,\n', '      creditsAdded : creditValue // Stores the deposit + the bonus\n', '    }));\n', '\n', '    // We turn ETH into WETH9\n', '    wETH.deposit{value : msg.value}();\n', '  }\n', '\n', '  /// @dev intended return is the bonus credit in terms of ETH units\n', '  // At the start of LSW is 30%, ramping down to 0% in the last 12 hours of LSW.\n', '  function calculateCreditBonusBasedOnCurrentTime(uint256 depositValue) internal view returns (uint256) {\n', '    uint256 secondsLeft = secondsLeftInLiquidityGenerationEvent();\n', '    uint256 totalSeconds = LSW_RUN_TIME;\n', '\n', '    // We get percent left in the LSW\n', '    uint256 percentLeft = secondsLeft.mul(100).div(totalSeconds); // 24 hours before LSW end, we get 7 for percentLeft - highest value for this possible is 100 (by a bot)\n', '\n', '    // We calculate bonus based on percent left. Eg 100% of the time remaining, means a 30% bonus. 50% of the time remaining, means a 15% bonus.\n', '    // MAX_TIME_BONUS_PERCENT is a constant set to 30 (double-check on review)\n', '    // Max example with 1 ETH contribute: 30 * 100 * 1eth / 10000 = 0.3eth\n', '    // Low end (towards the end of LSW) > 0 example MAX_TIME_BONUS_PERCENT == 7;\n', '      // 30 * 7 * 1eth / 10000 = 0.021 eth\n', '    // Min example MAX_TIME_BONUS_PERCENT == 0; returns 0\n', '    /// 100 % bonus\n', '    /// 30*100*1e18/10000 == 0.3 * 1e18\n', '    /// Dust numbers\n', '    /// 30*100*1/10000 == 0\n', '    uint256 bonus = MAX_TIME_BONUS_PERCENT.mul(percentLeft).mul(depositValue).div(10000);\n', '    require(depositValue.mul(31).div(100) > bonus , "Sanity check failure bonus");\n', '    return bonus;\n', '  }\n', '\n', '}']