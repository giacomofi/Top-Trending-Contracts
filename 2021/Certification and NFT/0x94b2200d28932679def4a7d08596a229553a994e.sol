['pragma solidity ^0.5.16;\n', '\n', 'import "./CToken.sol";\n', 'import "./CErc20.sol";\n', 'import "./ErrorReporter.sol";\n', 'import "./Exponential.sol";\n', 'import "./PriceOracle.sol";\n', 'import "./ComptrollerInterface.sol";\n', 'import "./ComptrollerStorage.sol";\n', 'import "./Unitroller.sol";\n', '\n', '/**\n', " * @title Compound's Comptroller Contract\n", ' * @author Compound\n', ' */\n', 'contract Comptroller is ComptrollerV2Storage, ComptrollerInterface, ComptrollerErrorReporter, Exponential {\n', '    /**\n', '     * @notice Emitted when an admin supports a market\n', '     */\n', '    event MarketListed(CToken cToken);\n', '\n', '    /**\n', '     * @notice Emitted when an account enters a market\n', '     */\n', '    event MarketEntered(CToken cToken, address account);\n', '\n', '    /**\n', '     * @notice Emitted when an account exits a market\n', '     */\n', '    event MarketExited(CToken cToken, address account);\n', '\n', '    /**\n', '     * @notice Emitted when close factor is changed by admin\n', '     */\n', '    event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n', '\n', '    /**\n', '     * @notice Emitted when a collateral factor is changed by admin\n', '     */\n', '    event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n', '\n', '    /**\n', '     * @notice Emitted when liquidation incentive is changed by admin\n', '     */\n', '    event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n', '\n', '    /**\n', '     * @notice Emitted when maxAssets is changed by admin\n', '     */\n', '    event NewMaxAssets(uint oldMaxAssets, uint newMaxAssets);\n', '\n', '    /**\n', '     * @notice Emitted when price oracle is changed\n', '     */\n', '    event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n', '\n', '    /**\n', '     * @notice Emitted when pause guardian is changed\n', '     */\n', '    event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n', '\n', '    /**\n', '     * @notice Emitted when an action is paused globally\n', '     */\n', '    event ActionPaused(string action, bool pauseState);\n', '\n', '    /**\n', '     * @notice Emitted when an action is paused on a market\n', '     */\n', '    event ActionPaused(CToken cToken, string action, bool pauseState);\n', '\n', '    // closeFactorMantissa must be strictly greater than this value\n', '    uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n', '\n', '    // closeFactorMantissa must not exceed this value\n', '    uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n', '\n', '    // No collateralFactorMantissa may exceed this value\n', '    uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n', '\n', '    // liquidationIncentiveMantissa must be no less than this value\n', '    uint internal constant liquidationIncentiveMinMantissa = 1.0e18; // 1.0\n', '\n', '    // liquidationIncentiveMantissa must be no greater than this value\n', '    uint internal constant liquidationIncentiveMaxMantissa = 1.5e18; // 1.5\n', '\n', '    constructor() public {\n', '        admin = msg.sender;\n', '    }\n', '\n', '    /*** Assets You Are In ***/\n', '\n', '    /**\n', '     * @notice Returns the assets an account has entered\n', '     * @param account The address of the account to pull assets for\n', '     * @return A dynamic list with the assets the account has entered\n', '     */\n', '    function getAssetsIn(address account) external view returns (CToken[] memory) {\n', '        CToken[] memory assetsIn = accountAssets[account];\n', '\n', '        return assetsIn;\n', '    }\n', '\n', '    /**\n', '     * @notice Returns whether the given account is entered in the given asset\n', '     * @param account The address of the account to check\n', '     * @param cToken The cToken to check\n', '     * @return True if the account is in the asset, otherwise false.\n', '     */\n', '    function checkMembership(address account, CToken cToken) external view returns (bool) {\n', '        return markets[address(cToken)].accountMembership[account];\n', '    }\n', '\n', '    /**\n', '     * @notice Add assets to be included in account liquidity calculation\n', '     * @param cTokens The list of addresses of the cToken markets to be enabled\n', '     * @return Success indicator for whether each corresponding market was entered\n', '     */\n', '    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n', '        uint len = cTokens.length;\n', '\n', '        uint[] memory results = new uint[](len);\n', '        for (uint i = 0; i < len; i++) {\n', '            CToken cToken = CToken(cTokens[i]);\n', '\n', '            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n', '        }\n', '\n', '        return results;\n', '    }\n', '\n', '    /**\n', '     * @notice Add the market to the borrower\'s "assets in" for liquidity calculations\n', '     * @param cToken The market to enter\n', '     * @param borrower The address of the account to modify\n', '     * @return Success indicator for whether the market was entered\n', '     */\n', '    function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n', '        Market storage marketToJoin = markets[address(cToken)];\n', '\n', '        if (!marketToJoin.isListed) {\n', '            // market is not listed, cannot join\n', '            return Error.MARKET_NOT_LISTED;\n', '        }\n', '\n', '        if (marketToJoin.accountMembership[borrower] == true) {\n', '            // already joined\n', '            return Error.NO_ERROR;\n', '        }\n', '\n', '        if (accountAssets[borrower].length >= maxAssets)  {\n', '            // no space, cannot join\n', '            return Error.TOO_MANY_ASSETS;\n', '        }\n', '\n', '        // survived the gauntlet, add to list\n', '        // NOTE: we store these somewhat redundantly as a significant optimization\n', '        //  this avoids having to iterate through the list for the most common use cases\n', '        //  that is, only when we need to perform liquidity checks\n', '        //  and not whenever we want to check if an account is in a particular market\n', '        marketToJoin.accountMembership[borrower] = true;\n', '        accountAssets[borrower].push(cToken);\n', '        \n', '        // Add to allBorrowers\n', '        if (!borrowers[borrower]) {\n', '            allBorrowers.push(borrower);\n', '            borrowers[borrower] = true;\n', '            borrowerIndexes[borrower] = allBorrowers.length - 1;\n', '        }\n', '\n', '        emit MarketEntered(cToken, borrower);\n', '\n', '        return Error.NO_ERROR;\n', '    }\n', '\n', '    /**\n', "     * @notice Removes asset from sender's account liquidity calculation\n", '     * @dev Sender must not have an outstanding borrow balance in the asset,\n', '     *  or be providing neccessary collateral for an outstanding borrow.\n', '     * @param cTokenAddress The address of the asset to be removed\n', '     * @return Whether or not the account successfully exited the market\n', '     */\n', '    function exitMarket(address cTokenAddress) external returns (uint) {\n', '        CToken cToken = CToken(cTokenAddress);\n', '        /* Get sender tokensHeld and amountOwed underlying from the cToken */\n', '        (uint oErr, uint tokensHeld, uint amountOwed, ) = cToken.getAccountSnapshot(msg.sender);\n', '        require(oErr == 0, "exitMarket: getAccountSnapshot failed"); // semi-opaque error code\n', '\n', '        /* Fail if the sender has a borrow balance */\n', '        if (amountOwed != 0) {\n', '            return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n', '        }\n', '\n', '        /* Fail if the sender is not permitted to redeem all of their tokens */\n', '        uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n', '        if (allowed != 0) {\n', '            return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n', '        }\n', '\n', '        Market storage marketToExit = markets[address(cToken)];\n', '\n', '        /* Return true if the sender is not already ‘in’ the market */\n', '        if (!marketToExit.accountMembership[msg.sender]) {\n', '            return uint(Error.NO_ERROR);\n', '        }\n', '\n', '        /* Set cToken account membership to false */\n', '        delete marketToExit.accountMembership[msg.sender];\n', '\n', '        /* Delete cToken from the account’s list of assets */\n', '        // load into memory for faster iteration\n', '        CToken[] memory userAssetList = accountAssets[msg.sender];\n', '        uint len = userAssetList.length;\n', '        uint assetIndex = len;\n', '        for (uint i = 0; i < len; i++) {\n', '            if (userAssetList[i] == cToken) {\n', '                assetIndex = i;\n', '                break;\n', '            }\n', '        }\n', '\n', '        // We *must* have found the asset in the list or our redundant data structure is broken\n', '        assert(assetIndex < len);\n', '\n', '        // copy last item in list to location of item to be removed, reduce length by 1\n', '        CToken[] storage storedList = accountAssets[msg.sender];\n', '        storedList[assetIndex] = storedList[storedList.length - 1];\n', '        storedList.length--;\n', '\n', '        // If the user has exited all markets, remove them from the `allBorrowers` array\n', '        if (storedList.length == 0) {\n', '            allBorrowers[borrowerIndexes[msg.sender]] = allBorrowers[allBorrowers.length - 1]; // Copy last item in list to location of item to be removed\n', '            allBorrowers.length--; // Reduce length by 1\n', '            borrowerIndexes[allBorrowers[borrowerIndexes[msg.sender]]] = borrowerIndexes[msg.sender]; // Set borrower index of moved item to correct index\n', '            borrowerIndexes[msg.sender] = 0; // Reset sender borrower index to 0 for a gas refund\n', '            borrowers[msg.sender] = false; // Tell the contract that the sender is no longer a borrower (so it knows to add the borrower back if they enter a market in the future)\n', '        }\n', '\n', '        emit MarketExited(cToken, msg.sender);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /*** Policy Hooks ***/\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to mint tokens in the given market\n', '     * @param cToken The market to verify the mint against\n', '     * @param minter The account which would get the minted tokens\n', '     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n', '     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function mintAllowed(address cToken, address minter, uint mintAmount) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!mintGuardianPaused[cToken], "mint is paused");\n', '\n', '        // Shh - currently unused\n', '        minter;\n', '        mintAmount;\n', '\n', '        // Make sure market is listed\n', '        if (!markets[cToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // *may include Policy Hook-type checks\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates mint and reverts on rejection. May emit logs.\n', '     * @param cToken Asset being minted\n', '     * @param minter The address minting the tokens\n', '     * @param actualMintAmount The amount of the underlying asset being minted\n', '     * @param mintTokens The number of tokens being minted\n', '     */\n', '    function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) external {\n', '        // Shh - currently unused\n', '        cToken;\n', '        minter;\n', '        actualMintAmount;\n', '        mintTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '\n', '        // Add minter to suppliers mapping\n', '        suppliers[minter] = true;\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to redeem tokens in the given market\n', '     * @param cToken The market to verify the redeem against\n', '     * @param redeemer The account which would redeem the tokens\n', '     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n', '     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function redeemAllowed(address cToken, address redeemer, uint redeemTokens) external returns (uint) {\n', '        return redeemAllowedInternal(cToken, redeemer, redeemTokens);\n', '    }\n', '\n', '    function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n', '        if (!markets[cToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // *may include Policy Hook-type checks\n', '\n', "        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n", '        if (!markets[cToken].accountMembership[redeemer]) {\n', '            return uint(Error.NO_ERROR);\n', '        }\n', '\n', '        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n', '        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall > 0) {\n', '            return uint(Error.INSUFFICIENT_LIQUIDITY);\n', '        }\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates redeem and reverts on rejection. May emit logs.\n', '     * @param cToken Asset being redeemed\n', '     * @param redeemer The address redeeming the tokens\n', '     * @param redeemAmount The amount of the underlying asset being redeemed\n', '     * @param redeemTokens The number of tokens being redeemed\n', '     */\n', '    function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) external {\n', '        // Shh - currently unused\n', '        cToken;\n', '        redeemer;\n', '\n', '        // Require tokens is zero or amount is also zero\n', '        if (redeemTokens == 0 && redeemAmount > 0) {\n', '            revert("redeemTokens zero");\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n', '     * @param cToken The market to verify the borrow against\n', '     * @param borrower The account which would borrow the asset\n', '     * @param borrowAmount The amount of underlying the account would borrow\n', '     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function borrowAllowed(address cToken, address borrower, uint borrowAmount) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!borrowGuardianPaused[cToken], "borrow is paused");\n', '\n', '        // Make sure market is listed\n', '        if (!markets[cToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // *may include Policy Hook-type checks\n', '\n', '        if (!markets[cToken].accountMembership[borrower]) {\n', '            // only cTokens may call borrowAllowed if borrower not in market\n', '            require(msg.sender == cToken, "sender must be cToken");\n', '\n', '            // attempt to add borrower to the market\n', '            Error err = addToMarketInternal(CToken(msg.sender), borrower);\n', '            if (err != Error.NO_ERROR) {\n', '                return uint(err);\n', '            }\n', '\n', '            // it should be impossible to break the important invariant\n', '            assert(markets[cToken].accountMembership[borrower]);\n', '        }\n', '\n', '        if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n', '            return uint(Error.PRICE_ERROR);\n', '        }\n', '\n', '        (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall > 0) {\n', '            return uint(Error.INSUFFICIENT_LIQUIDITY);\n', '        }\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n', '     * @param cToken Asset whose underlying is being borrowed\n', "     * @param accountBorrowsNew The user's new borrow balance of the underlying asset\n", '     */\n', '    function borrowWithinLimits(address cToken, uint accountBorrowsNew) external returns (uint) {\n', '        uint oraclePriceMantissa = oracle.getUnderlyingPrice(CToken(cToken));\n', '        if (oraclePriceMantissa == 0) return uint(Error.PRICE_ERROR);\n', '        (MathError mathErr, uint borrowBalanceEth) = mulScalarTruncate(Exp({mantissa: oraclePriceMantissa}), accountBorrowsNew);\n', '        if (mathErr != MathError.NO_ERROR) return uint(Error.MATH_ERROR);\n', '        if (borrowBalanceEth < fuseAdmin.minBorrowEth()) return uint(Error.BORROW_BELOW_MIN);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n', '     * @param cToken Asset whose underlying is being borrowed\n', '     * @param exchangeRateMantissa Underlying/cToken exchange rate\n', '     * @param accountTokens Initial account cToken balance\n', '     * @param accountTokens Underlying amount to mint\n', '     */\n', '    function mintWithinLimits(address cToken, uint exchangeRateMantissa, uint accountTokens, uint mintAmount) external returns (uint) {\n', '        // Check max supply\n', '        uint maxSupplyEth = fuseAdmin.maxSupplyEth();\n', '\n', '        if (maxSupplyEth < uint(-1)) {\n', '            (MathError mathErr, uint newUnderlyingBalance) = mulScalarTruncateAddUInt(Exp({mantissa: exchangeRateMantissa}), accountTokens, mintAmount);\n', '            if (mathErr != MathError.NO_ERROR) return uint(Error.MATH_ERROR);\n', '            uint newEthBalance;\n', '            (mathErr, newEthBalance) = mulScalarTruncate(Exp({mantissa: oracle.getUnderlyingPrice(CToken(cToken))}), newUnderlyingBalance);\n', '            if (mathErr != MathError.NO_ERROR) return uint(Error.MATH_ERROR);\n', '            if (newEthBalance > maxSupplyEth) return uint(Error.SUPPLY_ABOVE_MAX);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Validates borrow and reverts on rejection. May emit logs.\n', '     * @param cToken Asset whose underlying is being borrowed\n', '     * @param borrower The address borrowing the underlying\n', '     * @param borrowAmount The amount of the underlying asset requested to borrow\n', '     */\n', '    function borrowVerify(address cToken, address borrower, uint borrowAmount) external {\n', '        // Shh - currently unused\n', '        cToken;\n', '        borrower;\n', '        borrowAmount;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to repay a borrow in the given market\n', '     * @param cToken The market to verify the repay against\n', '     * @param payer The account which would repay the asset\n', '     * @param borrower The account which would borrowed the asset\n', '     * @param repayAmount The amount of the underlying asset the account would repay\n', '     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function repayBorrowAllowed(\n', '        address cToken,\n', '        address payer,\n', '        address borrower,\n', '        uint repayAmount) external returns (uint) {\n', '        // Shh - currently unused\n', '        payer;\n', '        borrower;\n', '        repayAmount;\n', '\n', '        if (!markets[cToken].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // *may include Policy Hook-type checks\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n', '     * @param cToken Asset being repaid\n', '     * @param payer The address repaying the borrow\n', '     * @param borrower The address of the borrower\n', '     * @param actualRepayAmount The amount of underlying being repaid\n', '     */\n', '    function repayBorrowVerify(\n', '        address cToken,\n', '        address payer,\n', '        address borrower,\n', '        uint actualRepayAmount,\n', '        uint borrowerIndex) external {\n', '        // Shh - currently unused\n', '        cToken;\n', '        payer;\n', '        borrower;\n', '        actualRepayAmount;\n', '        borrowerIndex;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the liquidation should be allowed to occur\n', '     * @param cTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param cTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param repayAmount The amount of underlying being repaid\n', '     */\n', '    function liquidateBorrowAllowed(\n', '        address cTokenBorrowed,\n', '        address cTokenCollateral,\n', '        address liquidator,\n', '        address borrower,\n', '        uint repayAmount) external returns (uint) {\n', '        // Shh - currently unused\n', '        liquidator;\n', '\n', '        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        // *may include Policy Hook-type checks\n', '\n', '        /* The borrower must have shortfall in order to be liquidatable */\n', '        (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\n', '        if (err != Error.NO_ERROR) {\n', '            return uint(err);\n', '        }\n', '        if (shortfall == 0) {\n', '            return uint(Error.INSUFFICIENT_SHORTFALL);\n', '        }\n', '\n', '        /* The liquidator may not repay more than what is allowed by the closeFactor */\n', '        uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n', '        (MathError mathErr, uint maxClose) = mulScalarTruncate(Exp({mantissa: closeFactorMantissa}), borrowBalance);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return uint(Error.MATH_ERROR);\n', '        }\n', '        if (repayAmount > maxClose) {\n', '            return uint(Error.TOO_MUCH_REPAY);\n', '        }\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n', '     * @param cTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param cTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param actualRepayAmount The amount of underlying being repaid\n', '     */\n', '    function liquidateBorrowVerify(\n', '        address cTokenBorrowed,\n', '        address cTokenCollateral,\n', '        address liquidator,\n', '        address borrower,\n', '        uint actualRepayAmount,\n', '        uint seizeTokens) external {\n', '        // Shh - currently unused\n', '        cTokenBorrowed;\n', '        cTokenCollateral;\n', '        liquidator;\n', '        borrower;\n', '        actualRepayAmount;\n', '        seizeTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the seizing of assets should be allowed to occur\n', '     * @param cTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param cTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param seizeTokens The number of collateral tokens to seize\n', '     */\n', '    function seizeAllowed(\n', '        address cTokenCollateral,\n', '        address cTokenBorrowed,\n', '        address liquidator,\n', '        address borrower,\n', '        uint seizeTokens) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!seizeGuardianPaused, "seize is paused");\n', '\n', '        // Shh - currently unused\n', '        liquidator;\n', '        borrower;\n', '        seizeTokens;\n', '\n', '        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n', '            return uint(Error.MARKET_NOT_LISTED);\n', '        }\n', '\n', '        if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n', '            return uint(Error.COMPTROLLER_MISMATCH);\n', '        }\n', '\n', '        // *may include Policy Hook-type checks\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates seize and reverts on rejection. May emit logs.\n', '     * @param cTokenCollateral Asset which was used as collateral and will be seized\n', '     * @param cTokenBorrowed Asset which was borrowed by the borrower\n', '     * @param liquidator The address repaying the borrow and seizing the collateral\n', '     * @param borrower The address of the borrower\n', '     * @param seizeTokens The number of collateral tokens to seize\n', '     */\n', '    function seizeVerify(\n', '        address cTokenCollateral,\n', '        address cTokenBorrowed,\n', '        address liquidator,\n', '        address borrower,\n', '        uint seizeTokens) external {\n', '        // Shh - currently unused\n', '        cTokenCollateral;\n', '        cTokenBorrowed;\n', '        liquidator;\n', '        borrower;\n', '        seizeTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if the account should be allowed to transfer tokens in the given market\n', '     * @param cToken The market to verify the transfer against\n', '     * @param src The account which sources the tokens\n', '     * @param dst The account which receives the tokens\n', '     * @param transferTokens The number of cTokens to transfer\n', '     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n', '     */\n', '    function transferAllowed(address cToken, address src, address dst, uint transferTokens) external returns (uint) {\n', '        // Pausing is a very serious situation - we revert to sound the alarms\n', '        require(!transferGuardianPaused, "transfer is paused");\n', '\n', '        // Shh - currently unused\n', '        dst;\n', '\n', '        // *may include Policy Hook-type checks\n', '\n', '        // Currently the only consideration is whether or not\n', '        //  the src is allowed to redeem this many tokens\n', '        return redeemAllowedInternal(cToken, src, transferTokens);\n', '    }\n', '\n', '    /**\n', '     * @notice Validates transfer and reverts on rejection. May emit logs.\n', '     * @param cToken Asset being transferred\n', '     * @param src The account which sources the tokens\n', '     * @param dst The account which receives the tokens\n', '     * @param transferTokens The number of cTokens to transfer\n', '     */\n', '    function transferVerify(address cToken, address src, address dst, uint transferTokens) external {\n', '        // Shh - currently unused\n', '        cToken;\n', '        src;\n', '        dst;\n', '        transferTokens;\n', '\n', "        // Shh - we don't ever want this hook to be marked pure\n", '        if (false) {\n', '            maxAssets = maxAssets;\n', '        }\n', '    }\n', '\n', '    /*** Liquidity/Liquidation Calculations ***/\n', '\n', '    /**\n', '     * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n', '     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n', '     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n', '     */\n', '    struct AccountLiquidityLocalVars {\n', '        uint sumCollateral;\n', '        uint sumBorrowPlusEffects;\n', '        uint cTokenBalance;\n', '        uint borrowBalance;\n', '        uint exchangeRateMantissa;\n', '        uint oraclePriceMantissa;\n', '        Exp collateralFactor;\n', '        Exp exchangeRate;\n', '        Exp oraclePrice;\n', '        Exp tokensToEther;\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the current account liquidity wrt collateral requirements\n', '     * @return (possible error code (semi-opaque),\n', '                account liquidity in excess of collateral requirements,\n', '     *          account shortfall below collateral requirements)\n', '     */\n', '    function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n', '        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n', '\n', '        return (uint(err), liquidity, shortfall);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the current account liquidity wrt collateral requirements\n', '     * @return (possible error code,\n', '                account liquidity in excess of collateral requirements,\n', '     *          account shortfall below collateral requirements)\n', '     */\n', '    function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n', '        return getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n', '     * @param cTokenModify The market to hypothetically redeem/borrow in\n', '     * @param account The account to determine liquidity for\n', '     * @param redeemTokens The number of tokens to hypothetically redeem\n', '     * @param borrowAmount The amount of underlying to hypothetically borrow\n', '     * @return (possible error code (semi-opaque),\n', '                hypothetical account liquidity in excess of collateral requirements,\n', '     *          hypothetical account shortfall below collateral requirements)\n', '     */\n', '    function getHypotheticalAccountLiquidity(\n', '        address account,\n', '        address cTokenModify,\n', '        uint redeemTokens,\n', '        uint borrowAmount) public view returns (uint, uint, uint) {\n', '        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);\n', '        return (uint(err), liquidity, shortfall);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n', '     * @param cTokenModify The market to hypothetically redeem/borrow in\n', '     * @param account The account to determine liquidity for\n', '     * @param redeemTokens The number of tokens to hypothetically redeem\n', '     * @param borrowAmount The amount of underlying to hypothetically borrow\n', '     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n', '     *  without calculating accumulated interest.\n', '     * @return (possible error code,\n', '                hypothetical account liquidity in excess of collateral requirements,\n', '     *          hypothetical account shortfall below collateral requirements)\n', '     */\n', '    function getHypotheticalAccountLiquidityInternal(\n', '        address account,\n', '        CToken cTokenModify,\n', '        uint redeemTokens,\n', '        uint borrowAmount) internal view returns (Error, uint, uint) {\n', '\n', '        AccountLiquidityLocalVars memory vars; // Holds all our calculation results\n', '        uint oErr;\n', '        MathError mErr;\n', '\n', '        // For each asset the account is in\n', '        CToken[] memory assets = accountAssets[account];\n', '        for (uint i = 0; i < assets.length; i++) {\n', '            CToken asset = assets[i];\n', '\n', '            // Read the balances and exchange rate from the cToken\n', '            (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n', '            if (oErr != 0) { // semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n', '                return (Error.SNAPSHOT_ERROR, 0, 0);\n', '            }\n', '            vars.collateralFactor = Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\n', '            vars.exchangeRate = Exp({mantissa: vars.exchangeRateMantissa});\n', '\n', '            // Get the normalized price of the asset\n', '            vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n', '            if (vars.oraclePriceMantissa == 0) {\n', '                return (Error.PRICE_ERROR, 0, 0);\n', '            }\n', '            vars.oraclePrice = Exp({mantissa: vars.oraclePriceMantissa});\n', '\n', '            // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n', '            (mErr, vars.tokensToEther) = mulExp3(vars.collateralFactor, vars.exchangeRate, vars.oraclePrice);\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0);\n', '            }\n', '\n', '            // sumCollateral += tokensToEther * cTokenBalance\n', '            (mErr, vars.sumCollateral) = mulScalarTruncateAddUInt(vars.tokensToEther, vars.cTokenBalance, vars.sumCollateral);\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0);\n', '            }\n', '\n', '            // sumBorrowPlusEffects += oraclePrice * borrowBalance\n', '            (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n', '            if (mErr != MathError.NO_ERROR) {\n', '                return (Error.MATH_ERROR, 0, 0);\n', '            }\n', '\n', '            // Calculate effects of interacting with cTokenModify\n', '            if (asset == cTokenModify) {\n', '                // redeem effect\n', '                // sumBorrowPlusEffects += tokensToEther * redeemTokens\n', '                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.tokensToEther, redeemTokens, vars.sumBorrowPlusEffects);\n', '                if (mErr != MathError.NO_ERROR) {\n', '                    return (Error.MATH_ERROR, 0, 0);\n', '                }\n', '\n', '                // borrow effect\n', '                // sumBorrowPlusEffects += oraclePrice * borrowAmount\n', '                (mErr, vars.sumBorrowPlusEffects) = mulScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n', '                if (mErr != MathError.NO_ERROR) {\n', '                    return (Error.MATH_ERROR, 0, 0);\n', '                }\n', '            }\n', '        }\n', '\n', '        // These are safe, as the underflow condition is checked first\n', '        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n', '            return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n', '        } else {\n', '            return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the maximum redeem amount of a cToken\n', '     * @param cTokenModify The market to hypothetically redeem in\n', '     * @param account The account to determine liquidity for\n', '     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n', '     *  without calculating accumulated interest.\n', '     * @return (possible error code,\n', '                maximum redeem amount)\n', '     */\n', '    function getMaxRedeem(address account, CToken cTokenModify) external returns (uint, uint) {\n', '        (Error err, uint maxRedeem) = getMaxRedeemOrBorrow(account, cTokenModify, false);\n', '        return (uint(err), maxRedeem);\n', '    }\n', '\n', '    /**\n', '     * @notice Determine the maximum borrow amount of a cToken\n', '     * @param cTokenModify The market to hypothetically borrow in\n', '     * @param account The account to determine liquidity for\n', '     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n', '     *  without calculating accumulated interest.\n', '     * @return (possible error code,\n', '                maximum borrow amount)\n', '     */\n', '    function getMaxBorrow(address account, CToken cTokenModify) external returns (uint, uint) {\n', '        (Error err, uint maxBorrow) = getMaxRedeemOrBorrow(account, cTokenModify, true);\n', '        return (uint(err), maxBorrow);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to determine the maximum borrow/redeem amount of a cToken\n', '     * @param cTokenModify The market to hypothetically borrow/redeem in\n', '     * @param account The account to determine liquidity for\n', '     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n', '     *  without calculating accumulated interest.\n', '     * @return (possible error code,\n', '                maximum borrow/redeem amount)\n', '     */\n', '    function getMaxRedeemOrBorrow(address account, CToken cTokenModify, bool isBorrow) internal returns (Error, uint) {\n', '        // Accrue interest\n', '        uint balanceOfUnderlying = cTokenModify.balanceOfUnderlying(account);\n', '\n', '        // Get account liquidity\n', '        (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(0), 0, 0);\n', '        if (err != Error.NO_ERROR) return (err, 0);\n', '        if (shortfall > 0) return (Error.NO_ERROR, 0); // Shortfall, so no more borrow/redeem\n', '\n', '        // Get max borrow/redeem\n', '        uint maxBorrowOrRedeemAmount;\n', '\n', '        if (!isBorrow && !markets[address(cTokenModify)].accountMembership[msg.sender]) {\n', '            // Max redeem = balance of underlying if not used as collateral\n', '            maxBorrowOrRedeemAmount = balanceOfUnderlying;\n', '        } else {\n', '            // Avoid "stack too deep" error by separating this logic\n', '            (err, maxBorrowOrRedeemAmount) = _getMaxRedeemOrBorrow(liquidity, cTokenModify, isBorrow);\n', '            if (err != Error.NO_ERROR) return (err, 0);\n', '\n', '            // Redeem only: max out at underlying balance\n', '            if (!isBorrow && balanceOfUnderlying < maxBorrowOrRedeemAmount) maxBorrowOrRedeemAmount = balanceOfUnderlying;\n', '        }\n', '\n', '        // Get max borrow or redeem considering cToken liquidity\n', '        uint cTokenLiquidity = cTokenModify.getCash();\n', '\n', '        // Return the minimum of the two maximums\n', '        return (Error.NO_ERROR, maxBorrowOrRedeemAmount <= cTokenLiquidity ? maxBorrowOrRedeemAmount : cTokenLiquidity);\n', '    }\n', '\n', '    /**\n', '     * @dev Portion of the logic above separated to avoid "stack too deep" errors.\n', '     */\n', '    function _getMaxRedeemOrBorrow(uint liquidity, CToken cTokenModify, bool isBorrow) internal view returns (Error, uint) {\n', '        if (liquidity <= 0) return (Error.NO_ERROR, 0); // No available account liquidity, so no more borrow/redeem\n', '\n', '        // Get the normalized price of the asset\n', '        uint oraclePriceMantissa = oracle.getUnderlyingPrice(cTokenModify);\n', '        if (oraclePriceMantissa == 0) return (Error.PRICE_ERROR, 0);\n', '        Exp memory conversionFactor = Exp({mantissa: oraclePriceMantissa});\n', '\n', '        // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n', '        MathError mErr;\n', '\n', '        if (!isBorrow) {\n', '            Exp memory collateralFactor = Exp({mantissa: markets[address(cTokenModify)].collateralFactorMantissa});\n', '            (mErr, conversionFactor) = mulExp(collateralFactor, conversionFactor);\n', '            if (mErr != MathError.NO_ERROR) return (Error.MATH_ERROR, 0);\n', '        }\n', '\n', '        // Get max borrow or redeem considering excess account liquidity\n', '        uint maxBorrowOrRedeemAmount;\n', '        (mErr, maxBorrowOrRedeemAmount) = divScalarByExpTruncate(liquidity, conversionFactor);\n', '        if (mErr != MathError.NO_ERROR) return (Error.MATH_ERROR, 0);\n', '        return (Error.NO_ERROR, maxBorrowOrRedeemAmount);\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n', '     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n', '     * @param cTokenBorrowed The address of the borrowed cToken\n', '     * @param cTokenCollateral The address of the collateral cToken\n', '     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n', '     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n', '     */\n', '    function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) external view returns (uint, uint) {\n', '        /* Read oracle prices for borrowed and collateral markets */\n', '        uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n', '        uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n', '        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n', '            return (uint(Error.PRICE_ERROR), 0);\n', '        }\n', '\n', '        /*\n', '         * Get the exchange rate and calculate the number of collateral tokens to seize:\n', '         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n', '         *  seizeTokens = seizeAmount / exchangeRate\n', '         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n', '         */\n', '        uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored(); // Note: reverts on error\n', '        uint seizeTokens;\n', '        Exp memory numerator;\n', '        Exp memory denominator;\n', '        Exp memory ratio;\n', '        MathError mathErr;\n', '\n', '        (mathErr, numerator) = mulExp(liquidationIncentiveMantissa, priceBorrowedMantissa);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return (uint(Error.MATH_ERROR), 0);\n', '        }\n', '\n', '        (mathErr, denominator) = mulExp(priceCollateralMantissa, exchangeRateMantissa);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return (uint(Error.MATH_ERROR), 0);\n', '        }\n', '\n', '        (mathErr, ratio) = divExp(numerator, denominator);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return (uint(Error.MATH_ERROR), 0);\n', '        }\n', '\n', '        (mathErr, seizeTokens) = mulScalarTruncate(ratio, actualRepayAmount);\n', '        if (mathErr != MathError.NO_ERROR) {\n', '            return (uint(Error.MATH_ERROR), 0);\n', '        }\n', '\n', '        return (uint(Error.NO_ERROR), seizeTokens);\n', '    }\n', '\n', '    /*** Admin Functions ***/\n', '\n', '    /**\n', '      * @notice Sets a new price oracle for the comptroller\n', '      * @dev Admin function to set a new price oracle\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n', '        // Check caller is admin\n', '        if (!hasAdminRights()) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n', '        }\n', '\n', '        // Track the old oracle for the comptroller\n', '        PriceOracle oldOracle = oracle;\n', '\n', "        // Set comptroller's oracle to newOracle\n", '        oracle = newOracle;\n', '\n', '        // Emit NewPriceOracle(oldOracle, newOracle)\n', '        emit NewPriceOracle(oldOracle, newOracle);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets the closeFactor used when liquidating borrows\n', '      * @dev Admin function to set closeFactor\n', '      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint256) {\n', '        // Check caller is admin\n', '        if (!hasAdminRights()) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_CLOSE_FACTOR_OWNER_CHECK);\n', '        }\n', '\n', '        Exp memory newCloseFactorExp = Exp({mantissa: newCloseFactorMantissa});\n', '        Exp memory lowLimit = Exp({mantissa: closeFactorMinMantissa});\n', '        if (lessThanOrEqualExp(newCloseFactorExp, lowLimit)) {\n', '            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n', '        }\n', '\n', '        Exp memory highLimit = Exp({mantissa: closeFactorMaxMantissa});\n', '        if (lessThanExp(highLimit, newCloseFactorExp)) {\n', '            return fail(Error.INVALID_CLOSE_FACTOR, FailureInfo.SET_CLOSE_FACTOR_VALIDATION);\n', '        }\n', '\n', '        uint oldCloseFactorMantissa = closeFactorMantissa;\n', '        closeFactorMantissa = newCloseFactorMantissa;\n', '        emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets the collateralFactor for a market\n', '      * @dev Admin function to set per-market collateralFactor\n', '      * @param cToken The market to set the factor on\n', '      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) public returns (uint256) {\n', '        // Check caller is admin\n', '        if (!hasAdminRights()) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n', '        }\n', '\n', '        // Verify market is listed\n', '        Market storage market = markets[address(cToken)];\n', '        if (!market.isListed) {\n', '            return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n', '        }\n', '\n', '        Exp memory newCollateralFactorExp = Exp({mantissa: newCollateralFactorMantissa});\n', '\n', '        // Check collateral factor <= 0.9\n', '        Exp memory highLimit = Exp({mantissa: collateralFactorMaxMantissa});\n', '        if (lessThanExp(highLimit, newCollateralFactorExp)) {\n', '            return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n', '        }\n', '\n', '        // If collateral factor != 0, fail if price == 0\n', '        if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n', '            return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n', '        }\n', '\n', "        // Set market's collateral factor to new collateral factor, remember old value\n", '        uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n', '        market.collateralFactorMantissa = newCollateralFactorMantissa;\n', '\n', '        // Emit event with asset, old collateral factor, and new collateral factor\n', '        emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets maxAssets which controls how many markets can be entered\n', '      * @dev Admin function to set maxAssets\n', '      * @param newMaxAssets New max assets\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setMaxAssets(uint newMaxAssets) external returns (uint) {\n', '        // Check caller is admin\n', '        if (!hasAdminRights()) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MAX_ASSETS_OWNER_CHECK);\n', '        }\n', '\n', '        uint oldMaxAssets = maxAssets;\n', '        maxAssets = newMaxAssets;\n', '        emit NewMaxAssets(oldMaxAssets, newMaxAssets);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Sets liquidationIncentive\n', '      * @dev Admin function to set liquidationIncentive\n', '      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n', '      */\n', '    function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n', '        // Check caller is admin\n', '        if (!hasAdminRights()) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n', '        }\n', '\n', '        // Check de-scaled min <= newLiquidationIncentive <= max\n', '        Exp memory newLiquidationIncentive = Exp({mantissa: newLiquidationIncentiveMantissa});\n', '        Exp memory minLiquidationIncentive = Exp({mantissa: liquidationIncentiveMinMantissa});\n', '        if (lessThanExp(newLiquidationIncentive, minLiquidationIncentive)) {\n', '            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n', '        }\n', '\n', '        Exp memory maxLiquidationIncentive = Exp({mantissa: liquidationIncentiveMaxMantissa});\n', '        if (lessThanExp(maxLiquidationIncentive, newLiquidationIncentive)) {\n', '            return fail(Error.INVALID_LIQUIDATION_INCENTIVE, FailureInfo.SET_LIQUIDATION_INCENTIVE_VALIDATION);\n', '        }\n', '\n', '        // Save current value for use in log\n', '        uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n', '\n', '        // Set liquidation incentive to new incentive\n', '        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n', '\n', '        // Emit event with old incentive, new incentive\n', '        emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Add the market to the markets mapping and set it as listed\n', '      * @dev Admin function to set isListed and add support for the market\n', '      * @param cToken The address of the market (token) to list\n', '      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n', '      */\n', '    function _supportMarket(CToken cToken) public returns (uint) {\n', '        // Check caller is admin\n', '        if (!hasAdminRights()) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n', '        }\n', '\n', '        // Is market already listed?\n', '        if (markets[address(cToken)].isListed) {\n', '            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n', '        }\n', '\n', '        // Sanity check to make sure its really a CToken\n', '        cToken.isCToken();\n', '\n', '        // Check cToken.comptroller == this\n', '        require(address(cToken.comptroller()) == address(this), "Cannot support a market with a different Comptroller.");\n', '\n', '        // Make sure market is not already listed\n', '        address underlying = cToken.isCEther() ? address(0) : CErc20(address(cToken)).underlying();\n', '\n', '        if (address(cTokensByUnderlying[underlying]) != address(0)) {\n', '            return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n', '        }\n', '\n', '        // List market and emit event\n', '        markets[address(cToken)] = Market({isListed: true, collateralFactorMantissa: 0});\n', '        allMarkets.push(cToken);\n', '        cTokensByUnderlying[underlying] = cToken;\n', '        emit MarketListed(cToken);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '      * @notice Add the market to the markets mapping and set it as listed and set the collateral factor\n', '      * @dev Admin function to set isListed and add support for the market and set the collateral factor\n', '      * @param cToken The address of the market (token) to list\n', '      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n', '      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n', '      */\n', '    function _supportMarketAndSetCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\n', '        uint256 err = _supportMarket(cToken);\n', '        return err == uint(Error.NO_ERROR) ? _setCollateralFactor(cToken, newCollateralFactorMantissa) : err;\n', '    }\n', '\n', '    /**\n', '     * @notice Admin function to change the Pause Guardian\n', '     * @param newPauseGuardian The address of the new Pause Guardian\n', '     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n', '     */\n', '    function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n', '        if (!hasAdminRights()) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n', '        }\n', '\n', '        // Save current value for inclusion in log\n', '        address oldPauseGuardian = pauseGuardian;\n', '\n', '        // Store pauseGuardian with value newPauseGuardian\n', '        pauseGuardian = newPauseGuardian;\n', '\n', '        // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n', '        emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n', '        require(markets[address(cToken)].isListed, "cannot pause a market that is not listed");\n', '        require(msg.sender == pauseGuardian || hasAdminRights(), "only pause guardian and admin can pause");\n', '        require(hasAdminRights() || state == true, "only admin can unpause");\n', '\n', '        mintGuardianPaused[address(cToken)] = state;\n', '        emit ActionPaused(cToken, "Mint", state);\n', '        return state;\n', '    }\n', '\n', '    function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n', '        require(markets[address(cToken)].isListed, "cannot pause a market that is not listed");\n', '        require(msg.sender == pauseGuardian || hasAdminRights(), "only pause guardian and admin can pause");\n', '        require(hasAdminRights() || state == true, "only admin can unpause");\n', '\n', '        borrowGuardianPaused[address(cToken)] = state;\n', '        emit ActionPaused(cToken, "Borrow", state);\n', '        return state;\n', '    }\n', '\n', '    function _setTransferPaused(bool state) public returns (bool) {\n', '        require(msg.sender == pauseGuardian || hasAdminRights(), "only pause guardian and admin can pause");\n', '        require(hasAdminRights() || state == true, "only admin can unpause");\n', '\n', '        transferGuardianPaused = state;\n', '        emit ActionPaused("Transfer", state);\n', '        return state;\n', '    }\n', '\n', '    function _setSeizePaused(bool state) public returns (bool) {\n', '        require(msg.sender == pauseGuardian || hasAdminRights(), "only pause guardian and admin can pause");\n', '        require(hasAdminRights() || state == true, "only admin can unpause");\n', '\n', '        seizeGuardianPaused = state;\n', '        emit ActionPaused("Seize", state);\n', '        return state;\n', '    }\n', '\n', '    function _become(Unitroller unitroller) public {\n', '        require(msg.sender == unitroller.admin(), "only unitroller admin can change brains");\n', '\n', '        uint changeStatus = unitroller._acceptImplementation();\n', '        require(changeStatus == 0, "change not authorized");\n', '    }\n', '\n', '    /**\n', '     * @notice Return all of the markets\n', '     * @dev The automatic getter may be used to access an individual market.\n', '     * @return The list of market addresses\n', '     */\n', '    function getAllMarkets() public view returns (CToken[] memory) {\n', '        return allMarkets;\n', '    }\n', '\n', '    /**\n', '     * @notice Return all of the borrowers\n', '     * @dev The automatic getter may be used to access an individual borrower.\n', '     * @return The list of borrower account addresses\n', '     */\n', '    function getAllBorrowers() public view returns (address[] memory) {\n', '        return allBorrowers;\n', '    }\n', '}']