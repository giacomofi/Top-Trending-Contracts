['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-02\n', '*/\n', '\n', '// File: openzeppelin-solidity/contracts/GSN/Context.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: @daostack/infra/contracts/Reputation.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', '\n', '\n', '/**\n', ' * @title Reputation system\n', ' * @dev A DAO has Reputation System which allows peers to rate other peers in order to build trust .\n', " * A reputation is use to assign influence measure to a DAO'S peers.\n", ' * Reputation is similar to regular tokens but with one crucial difference: It is non-transferable.\n', ' * The Reputation contract maintain a map of address to reputation value.\n', ' * It provides an onlyOwner functions to mint and burn reputation _to (or _from) a specific address.\n', ' */\n', 'contract Reputation is Ownable {\n', '\n', '    uint8 public decimals = 18;             //Number of decimals of the smallest unit\n', '    // Event indicating minting of reputation to an address.\n', '    event Mint(address indexed _to, uint256 _amount);\n', '    // Event indicating burning of reputation for an address.\n', '    event Burn(address indexed _from, uint256 _amount);\n', '\n', '      /// @dev `Checkpoint` is the structure that attaches a block number to a\n', '      ///  given value, the block number attached is the one that last changed the\n', '      ///  value\n', '    struct Checkpoint {\n', '\n', '    // `fromBlock` is the block number that the value was generated from\n', '        uint128 fromBlock;\n', '\n', '          // `value` is the amount of reputation at a specific block number\n', '        uint128 value;\n', '    }\n', '\n', '      // `balances` is the map that tracks the balance of each address, in this\n', '      //  contract when the balance changes the block number that the change\n', '      //  occurred is also included in the map\n', '    mapping (address => Checkpoint[]) private balances;\n', '\n', '      // Tracks the history of the `totalSupply` of the reputation\n', '    Checkpoint[] private totalSupplyHistory;\n', '\n', '      /// @notice Generates `_amount` reputation that are assigned to `_owner`\n', '      /// @param _user The address that will be assigned the new reputation\n', '      /// @param _amount The quantity of reputation generated\n', '      /// @return True if the reputation are generated correctly\n', '    function mint(address _user, uint256 _amount) public onlyOwner returns (bool) {\n', '        uint256 curTotalSupply = totalSupply();\n', '        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n', '        uint256 previousBalanceTo = balanceOf(_user);\n', '        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n', '        updateValueAtNow(balances[_user], previousBalanceTo + _amount);\n', '        emit Mint(_user, _amount);\n', '        return true;\n', '    }\n', '\n', '      /// @notice Burns `_amount` reputation from `_owner`\n', '      /// @param _user The address that will lose the reputation\n', '      /// @param _amount The quantity of reputation to burn\n', '      /// @return True if the reputation are burned correctly\n', '    function burn(address _user, uint256 _amount) public onlyOwner returns (bool) {\n', '        uint256 curTotalSupply = totalSupply();\n', '        uint256 amountBurned = _amount;\n', '        uint256 previousBalanceFrom = balanceOf(_user);\n', '        if (previousBalanceFrom < amountBurned) {\n', '            amountBurned = previousBalanceFrom;\n', '        }\n', '        updateValueAtNow(totalSupplyHistory, curTotalSupply - amountBurned);\n', '        updateValueAtNow(balances[_user], previousBalanceFrom - amountBurned);\n', '        emit Burn(_user, amountBurned);\n', '        return true;\n', '    }\n', '\n', '    /// @dev This function makes it easy to get the total number of reputation\n', '    /// @return The total number of reputation\n', '    function totalSupply() public view returns (uint256) {\n', '        return totalSupplyAt(block.number);\n', '    }\n', '\n', '    ////////////////\n', '    // Query balance and totalSupply in History\n', '    ////////////////\n', '    /**\n', '    * @dev return the reputation amount of a given owner\n', '    * @param _owner an address of the owner which we want to get his reputation\n', '    */\n', '    function balanceOf(address _owner) public view returns (uint256 balance) {\n', '        return balanceOfAt(_owner, block.number);\n', '    }\n', '\n', '    /// @notice Total amount of reputation at a specific `_blockNumber`.\n', '    /// @param _blockNumber The block number when the totalSupply is queried\n', '    /// @return The total amount of reputation at `_blockNumber`\n', '    function totalSupplyAt(uint256 _blockNumber) public view returns(uint256) {\n', '        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n', '            return 0;\n', '          // This will return the expected totalSupply during normal situations\n', '        } else {\n', '            return getValueAt(totalSupplyHistory, _blockNumber);\n', '        }\n', '    }\n', '\n', '  /// @dev Queries the balance of `_owner` at a specific `_blockNumber`\n', '  /// @param _owner The address from which the balance will be retrieved\n', '  /// @param _blockNumber The block number when the balance is queried\n', '  /// @return The balance at `_blockNumber`\n', '    function balanceOfAt(address _owner, uint256 _blockNumber)\n', '    public view returns (uint256)\n', '    {\n', '        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n', '            return 0;\n', '        // This will return the expected balance during normal situations\n', '        } else {\n', '            return getValueAt(balances[_owner], _blockNumber);\n', '        }\n', '    }\n', '  ////////////////\n', '  // Internal helper functions to query and set a value in a snapshot array\n', '  ////////////////\n', '\n', '      /// @dev `getValueAt` retrieves the number of reputation at a given block number\n', '      /// @param checkpoints The history of values being queried\n', '      /// @param _block The block number to retrieve the value at\n', '      /// @return The number of reputation being queried\n', '    function getValueAt(Checkpoint[] storage checkpoints, uint256 _block) internal view returns (uint256) {\n', '        if (checkpoints.length == 0) {\n', '            return 0;\n', '        }\n', '\n', '          // Shortcut for the actual value\n', '        if (_block >= checkpoints[checkpoints.length-1].fromBlock) {\n', '            return checkpoints[checkpoints.length-1].value;\n', '        }\n', '        if (_block < checkpoints[0].fromBlock) {\n', '            return 0;\n', '        }\n', '\n', '          // Binary search of the value in the array\n', '        uint256 min = 0;\n', '        uint256 max = checkpoints.length-1;\n', '        while (max > min) {\n', '            uint256 mid = (max + min + 1) / 2;\n', '            if (checkpoints[mid].fromBlock <= _block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid-1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '      /// @dev `updateValueAtNow` used to update the `balances` map and the\n', '      ///  `totalSupplyHistory`\n', '      /// @param checkpoints The history of data being updated\n', '      /// @param _value The new number of reputation\n', '    function updateValueAtNow(Checkpoint[] storage checkpoints, uint256 _value) internal {\n', '        require(uint128(_value) == _value); //check value is in the 128 bits bounderies\n', '        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n', '            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n', '            newCheckPoint.fromBlock = uint128(block.number);\n', '            newCheckPoint.value = uint128(_value);\n', '        } else {\n', '            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\n', '            oldCheckPoint.value = uint128(_value);\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20Mintable}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract ERC20 is Context, IERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    mapping (address => uint256) private _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) private _allowances;\n', '\n', '    uint256 private _totalSupply;\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    function balanceOf(address account) public view returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for `sender`'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n', '        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(address sender, address recipient, uint256 amount) internal {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '    function _mint(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: mint to the zero address");\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _balances[account] = _balances[account].add(amount);\n', '        emit Transfer(address(0), account, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`, reducing the\n', '     * total supply.\n', '     *\n', '     * Emits a {Transfer} event with `to` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     * - `account` must have at least `amount` tokens.\n', '     */\n', '    function _burn(address account, uint256 amount) internal {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(address owner, address spender, uint256 amount) internal {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\n', "     * from the caller's allowance.\n", '     *\n', '     * See {_burn} and {_approve}.\n', '     */\n', '    function _burnFrom(address account, uint256 amount) internal {\n', '        _burn(account, amount);\n', '        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, "ERC20: burn amount exceeds allowance"));\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '/**\n', ' * @dev Extension of {ERC20} that allows token holders to destroy both their own\n', ' * tokens and those that they have an allowance for, in a way that can be\n', ' * recognized off-chain (via event analysis).\n', ' */\n', 'contract ERC20Burnable is Context, ERC20 {\n', '    /**\n', '     * @dev Destroys `amount` tokens from the caller.\n', '     *\n', '     * See {ERC20-_burn}.\n', '     */\n', '    function burn(uint256 amount) public {\n', '        _burn(_msgSender(), amount);\n', '    }\n', '\n', '    /**\n', '     * @dev See {ERC20-_burnFrom}.\n', '     */\n', '    function burnFrom(address account, uint256 amount) public {\n', '        _burnFrom(account, amount);\n', '    }\n', '}\n', '\n', '// File: @daostack/arc/contracts/controller/DAOToken.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title DAOToken, base on zeppelin contract.\n', ' * @dev ERC20 compatible token. It is a mintable, burnable token.\n', ' */\n', '\n', 'contract DAOToken is ERC20, ERC20Burnable, Ownable {\n', '\n', '    string public name;\n', '    string public symbol;\n', '    // solhint-disable-next-line const-name-snakecase\n', '    uint8 public constant decimals = 18;\n', '    uint256 public cap;\n', '\n', '    /**\n', '    * @dev Constructor\n', '    * @param _name - token name\n', '    * @param _symbol - token symbol\n', '    * @param _cap - token cap - 0 value means no cap\n', '    */\n', '    constructor(string memory _name, string memory _symbol, uint256 _cap)\n', '    public {\n', '        name = _name;\n', '        symbol = _symbol;\n', '        cap = _cap;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to mint tokens\n', '     * @param _to The address that will receive the minted tokens.\n', '     * @param _amount The amount of tokens to mint.\n', '     */\n', '    function mint(address _to, uint256 _amount) public onlyOwner returns (bool) {\n', '        if (cap > 0)\n', '            require(totalSupply().add(_amount) <= cap);\n', '        _mint(_to, _amount);\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.5;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following \n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: @daostack/arc/contracts/libs/SafeERC20.sol\n', '\n', '/*\n', '\n', 'SafeERC20 by daostack.\n', 'The code is based on a fix by SECBIT Team.\n', '\n', 'USE WITH CAUTION & NO WARRANTY\n', '\n', 'REFERENCE & RELATED READING\n', '- https://github.com/ethereum/solidity/issues/4116\n', '- https://medium.com/@chris_77367/explaining-unexpected-reverts-starting-with-solidity-0-4-22-3ada6e82308c\n', '- https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n', '- https://gist.github.com/BrendanChou/88a2eeb80947ff00bcf58ffdafeaeb61\n', '\n', '*/\n', 'pragma solidity 0.5.13;\n', '\n', '\n', '\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    bytes4 constant private TRANSFER_SELECTOR = bytes4(keccak256(bytes("transfer(address,uint256)")));\n', '    bytes4 constant private TRANSFERFROM_SELECTOR = bytes4(keccak256(bytes("transferFrom(address,address,uint256)")));\n', '    bytes4 constant private APPROVE_SELECTOR = bytes4(keccak256(bytes("approve(address,uint256)")));\n', '\n', '    function safeTransfer(address _erc20Addr, address _to, uint256 _value) internal {\n', '\n', '        // Must be a contract addr first!\n', '        require(_erc20Addr.isContract());\n', '\n', '        (bool success, bytes memory returnValue) =\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        _erc20Addr.call(abi.encodeWithSelector(TRANSFER_SELECTOR, _to, _value));\n', '        // call return false when something wrong\n', '        require(success);\n', '        //check return value\n', '        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\n', '    }\n', '\n', '    function safeTransferFrom(address _erc20Addr, address _from, address _to, uint256 _value) internal {\n', '\n', '        // Must be a contract addr first!\n', '        require(_erc20Addr.isContract());\n', '\n', '        (bool success, bytes memory returnValue) =\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        _erc20Addr.call(abi.encodeWithSelector(TRANSFERFROM_SELECTOR, _from, _to, _value));\n', '        // call return false when something wrong\n', '        require(success);\n', '        //check return value\n', '        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\n', '    }\n', '\n', '    function safeApprove(address _erc20Addr, address _spender, uint256 _value) internal {\n', '\n', '        // Must be a contract addr first!\n', '        require(_erc20Addr.isContract());\n', '\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero.\n', '        require((_value == 0) || (IERC20(_erc20Addr).allowance(address(this), _spender) == 0));\n', '\n', '        (bool success, bytes memory returnValue) =\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        _erc20Addr.call(abi.encodeWithSelector(APPROVE_SELECTOR, _spender, _value));\n', '        // call return false when something wrong\n', '        require(success);\n', '        //check return value\n', '        require(returnValue.length == 0 || (returnValue.length == 32 && (returnValue[31] != 0)));\n', '    }\n', '}\n', '\n', '// File: @daostack/arc/contracts/controller/Avatar.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title An Avatar holds tokens, reputation and ether for a controller\n', ' */\n', 'contract Avatar is Ownable {\n', '    using SafeERC20 for address;\n', '\n', '    string public orgName;\n', '    DAOToken public nativeToken;\n', '    Reputation public nativeReputation;\n', '\n', '    event GenericCall(address indexed _contract, bytes _data, uint _value, bool _success);\n', '    event SendEther(uint256 _amountInWei, address indexed _to);\n', '    event ExternalTokenTransfer(address indexed _externalToken, address indexed _to, uint256 _value);\n', '    event ExternalTokenTransferFrom(address indexed _externalToken, address _from, address _to, uint256 _value);\n', '    event ExternalTokenApproval(address indexed _externalToken, address _spender, uint256 _value);\n', '    event ReceiveEther(address indexed _sender, uint256 _value);\n', '    event MetaData(string _metaData);\n', '\n', '    /**\n', '    * @dev the constructor takes organization name, native token and reputation system\n', '    and creates an avatar for a controller\n', '    */\n', '    constructor(string memory _orgName, DAOToken _nativeToken, Reputation _nativeReputation) public {\n', '        orgName = _orgName;\n', '        nativeToken = _nativeToken;\n', '        nativeReputation = _nativeReputation;\n', '    }\n', '\n', '    /**\n', '    * @dev enables an avatar to receive ethers\n', '    */\n', '    function() external payable {\n', '        emit ReceiveEther(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '    * @dev perform a generic call to an arbitrary contract\n', "    * @param _contract  the contract's address to call\n", '    * @param _data ABI-encoded contract call to call `_contract` address.\n', '    * @param _value value (ETH) to transfer with the transaction\n', '    * @return bool    success or fail\n', "    *         bytes - the return bytes of the called contract's function.\n", '    */\n', '    function genericCall(address _contract, bytes memory _data, uint256 _value)\n', '    public\n', '    onlyOwner\n', '    returns(bool success, bytes memory returnValue) {\n', '      // solhint-disable-next-line avoid-call-value\n', '        (success, returnValue) = _contract.call.value(_value)(_data);\n', '        emit GenericCall(_contract, _data, _value, success);\n', '    }\n', '\n', '    /**\n', "    * @dev send ethers from the avatar's wallet\n", '    * @param _amountInWei amount to send in Wei units\n', '    * @param _to send the ethers to this address\n', '    * @return bool which represents success\n', '    */\n', '    function sendEther(uint256 _amountInWei, address payable _to) public onlyOwner returns(bool) {\n', '        _to.transfer(_amountInWei);\n', '        emit SendEther(_amountInWei, _to);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev external token transfer\n', '    * @param _externalToken the token contract\n', '    * @param _to the destination address\n', '    * @param _value the amount of tokens to transfer\n', '    * @return bool which represents success\n', '    */\n', '    function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value)\n', '    public onlyOwner returns(bool)\n', '    {\n', '        address(_externalToken).safeTransfer(_to, _value);\n', '        emit ExternalTokenTransfer(address(_externalToken), _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev external token transfer from a specific account\n', '    * @param _externalToken the token contract\n', '    * @param _from the account to spend token from\n', '    * @param _to the destination address\n', '    * @param _value the amount of tokens to transfer\n', '    * @return bool which represents success\n', '    */\n', '    function externalTokenTransferFrom(\n', '        IERC20 _externalToken,\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    )\n', '    public onlyOwner returns(bool)\n', '    {\n', '        address(_externalToken).safeTransferFrom(_from, _to, _value);\n', '        emit ExternalTokenTransferFrom(address(_externalToken), _from, _to, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev externalTokenApproval approve the spender address to spend a specified amount of tokens\n', '    *      on behalf of msg.sender.\n', '    * @param _externalToken the address of the Token Contract\n', '    * @param _spender address\n', '    * @param _value the amount of ether (in Wei) which the approval is referring to.\n', '    * @return bool which represents a success\n', '    */\n', '    function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value)\n', '    public onlyOwner returns(bool)\n', '    {\n', '        address(_externalToken).safeApprove(_spender, _value);\n', '        emit ExternalTokenApproval(address(_externalToken), _spender, _value);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev metaData emits an event with a string, should contain the hash of some meta data.\n', '    * @param _metaData a string representing a hash of the meta data\n', '    * @return bool which represents a success\n', '    */\n', '    function metaData(string memory _metaData) public onlyOwner returns(bool) {\n', '        emit MetaData(_metaData);\n', '        return true;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: @daostack/arc/contracts/globalConstraints/GlobalConstraintInterface.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', '\n', 'contract GlobalConstraintInterface {\n', '\n', '    enum CallPhase { Pre, Post, PreAndPost }\n', '\n', '    function pre( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);\n', '    function post( address _scheme, bytes32 _params, bytes32 _method ) public returns(bool);\n', '    /**\n', '     * @dev when return if this globalConstraints is pre, post or both.\n', '     * @return CallPhase enum indication  Pre, Post or PreAndPost.\n', '     */\n', '    function when() public returns(CallPhase);\n', '}\n', '\n', '// File: @daostack/arc/contracts/controller/Controller.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', '\n', '\n', '/**\n', ' * @title Controller contract\n', ' * @dev A controller controls the organizations tokens, reputation and avatar.\n', ' * It is subject to a set of schemes and constraints that determine its behavior.\n', ' * Each scheme has it own parameters and operation permissions.\n', ' */\n', 'contract Controller {\n', '\n', '    struct Scheme {\n', '        bytes32 paramsHash;  // a hash "configuration" of the scheme\n', '        bytes4  permissions; // A bitwise flags of permissions,\n', '                             // All 0: Not registered,\n', '                             // 1st bit: Flag if the scheme is registered,\n', '                             // 2nd bit: Scheme can register other schemes\n', '                             // 3rd bit: Scheme can add/remove global constraints\n', '                             // 4th bit: Scheme can upgrade the controller\n', '                             // 5th bit: Scheme can call genericCall on behalf of\n', '                             //          the organization avatar\n', '    }\n', '\n', '    struct GlobalConstraint {\n', '        address gcAddress;\n', '        bytes32 params;\n', '    }\n', '\n', '    struct GlobalConstraintRegister {\n', '        bool isRegistered; //is registered\n', '        uint256 index;    //index at globalConstraints\n', '    }\n', '\n', '    mapping(address=>Scheme) public schemes;\n', '\n', '    Avatar public avatar;\n', '    DAOToken public nativeToken;\n', '    Reputation public nativeReputation;\n', '  // newController will point to the new controller after the present controller is upgraded\n', '    address public newController;\n', '  // globalConstraintsPre that determine pre conditions for all actions on the controller\n', '\n', '    GlobalConstraint[] public globalConstraintsPre;\n', '  // globalConstraintsPost that determine post conditions for all actions on the controller\n', '    GlobalConstraint[] public globalConstraintsPost;\n', '  // globalConstraintsRegisterPre indicate if a globalConstraints is registered as a pre global constraint\n', '    mapping(address=>GlobalConstraintRegister) public globalConstraintsRegisterPre;\n', '  // globalConstraintsRegisterPost indicate if a globalConstraints is registered as a post global constraint\n', '    mapping(address=>GlobalConstraintRegister) public globalConstraintsRegisterPost;\n', '\n', '    event MintReputation (address indexed _sender, address indexed _to, uint256 _amount);\n', '    event BurnReputation (address indexed _sender, address indexed _from, uint256 _amount);\n', '    event MintTokens (address indexed _sender, address indexed _beneficiary, uint256 _amount);\n', '    event RegisterScheme (address indexed _sender, address indexed _scheme);\n', '    event UnregisterScheme (address indexed _sender, address indexed _scheme);\n', '    event UpgradeController(address indexed _oldController, address _newController);\n', '\n', '    event AddGlobalConstraint(\n', '        address indexed _globalConstraint,\n', '        bytes32 _params,\n', '        GlobalConstraintInterface.CallPhase _when);\n', '\n', '    event RemoveGlobalConstraint(address indexed _globalConstraint, uint256 _index, bool _isPre);\n', '\n', '    constructor( Avatar _avatar) public {\n', '        avatar = _avatar;\n', '        nativeToken = avatar.nativeToken();\n', '        nativeReputation = avatar.nativeReputation();\n', '        schemes[msg.sender] = Scheme({paramsHash: bytes32(0), permissions: bytes4(0x0000001F)});\n', '        emit RegisterScheme (msg.sender, msg.sender);\n', '    }\n', '\n', '  // Do not allow mistaken calls:\n', '   // solhint-disable-next-line payable-fallback\n', '    function() external {\n', '        revert();\n', '    }\n', '\n', '  // Modifiers:\n', '    modifier onlyRegisteredScheme() {\n', '        require(schemes[msg.sender].permissions&bytes4(0x00000001) == bytes4(0x00000001));\n', '        _;\n', '    }\n', '\n', '    modifier onlyRegisteringSchemes() {\n', '        require(schemes[msg.sender].permissions&bytes4(0x00000002) == bytes4(0x00000002));\n', '        _;\n', '    }\n', '\n', '    modifier onlyGlobalConstraintsScheme() {\n', '        require(schemes[msg.sender].permissions&bytes4(0x00000004) == bytes4(0x00000004));\n', '        _;\n', '    }\n', '\n', '    modifier onlyUpgradingScheme() {\n', '        require(schemes[msg.sender].permissions&bytes4(0x00000008) == bytes4(0x00000008));\n', '        _;\n', '    }\n', '\n', '    modifier onlyGenericCallScheme() {\n', '        require(schemes[msg.sender].permissions&bytes4(0x00000010) == bytes4(0x00000010));\n', '        _;\n', '    }\n', '\n', '    modifier onlyMetaDataScheme() {\n', '        require(schemes[msg.sender].permissions&bytes4(0x00000010) == bytes4(0x00000010));\n', '        _;\n', '    }\n', '\n', '    modifier onlySubjectToConstraint(bytes32 func) {\n', '        uint256 idx;\n', '        for (idx = 0; idx < globalConstraintsPre.length; idx++) {\n', '            require(\n', '            (GlobalConstraintInterface(globalConstraintsPre[idx].gcAddress))\n', '            .pre(msg.sender, globalConstraintsPre[idx].params, func));\n', '        }\n', '        _;\n', '        for (idx = 0; idx < globalConstraintsPost.length; idx++) {\n', '            require(\n', '            (GlobalConstraintInterface(globalConstraintsPost[idx].gcAddress))\n', '            .post(msg.sender, globalConstraintsPost[idx].params, func));\n', '        }\n', '    }\n', '\n', '    modifier isAvatarValid(address _avatar) {\n', '        require(_avatar == address(avatar));\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Mint `_amount` of reputation that are assigned to `_to` .\n', '     * @param  _amount amount of reputation to mint\n', '     * @param _to beneficiary address\n', '     * @return bool which represents a success\n', '     */\n', '    function mintReputation(uint256 _amount, address _to, address _avatar)\n', '    external\n', '    onlyRegisteredScheme\n', '    onlySubjectToConstraint("mintReputation")\n', '    isAvatarValid(_avatar)\n', '    returns(bool)\n', '    {\n', '        emit MintReputation(msg.sender, _to, _amount);\n', '        return nativeReputation.mint(_to, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Burns `_amount` of reputation from `_from`\n', '     * @param _amount amount of reputation to burn\n', '     * @param _from The address that will lose the reputation\n', '     * @return bool which represents a success\n', '     */\n', '    function burnReputation(uint256 _amount, address _from, address _avatar)\n', '    external\n', '    onlyRegisteredScheme\n', '    onlySubjectToConstraint("burnReputation")\n', '    isAvatarValid(_avatar)\n', '    returns(bool)\n', '    {\n', '        emit BurnReputation(msg.sender, _from, _amount);\n', '        return nativeReputation.burn(_from, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev mint tokens .\n', '     * @param  _amount amount of token to mint\n', '     * @param _beneficiary beneficiary address\n', '     * @return bool which represents a success\n', '     */\n', '    function mintTokens(uint256 _amount, address _beneficiary, address _avatar)\n', '    external\n', '    onlyRegisteredScheme\n', '    onlySubjectToConstraint("mintTokens")\n', '    isAvatarValid(_avatar)\n', '    returns(bool)\n', '    {\n', '        emit MintTokens(msg.sender, _beneficiary, _amount);\n', '        return nativeToken.mint(_beneficiary, _amount);\n', '    }\n', '\n', '  /**\n', '   * @dev register a scheme\n', '   * @param _scheme the address of the scheme\n', '   * @param _paramsHash a hashed configuration of the usage of the scheme\n', '   * @param _permissions the permissions the new scheme will have\n', '   * @return bool which represents a success\n', '   */\n', '    function registerScheme(address _scheme, bytes32 _paramsHash, bytes4 _permissions, address _avatar)\n', '    external\n', '    onlyRegisteringSchemes\n', '    onlySubjectToConstraint("registerScheme")\n', '    isAvatarValid(_avatar)\n', '    returns(bool)\n', '    {\n', '\n', '        Scheme memory scheme = schemes[_scheme];\n', '\n', '    // Check scheme has at least the permissions it is changing, and at least the current permissions:\n', '    // Implementation is a bit messy. One must recall logic-circuits ^^\n', '\n', '    // produces non-zero if sender does not have all of the perms that are changing between old and new\n', '        require(bytes4(0x0000001f)&(_permissions^scheme.permissions)&(~schemes[msg.sender].permissions) == bytes4(0));\n', '\n', '    // produces non-zero if sender does not have all of the perms in the old scheme\n', '        require(bytes4(0x0000001f)&(scheme.permissions&(~schemes[msg.sender].permissions)) == bytes4(0));\n', '\n', '    // Add or change the scheme:\n', '        schemes[_scheme].paramsHash = _paramsHash;\n', '        schemes[_scheme].permissions = _permissions|bytes4(0x00000001);\n', '        emit RegisterScheme(msg.sender, _scheme);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev unregister a scheme\n', '     * @param _scheme the address of the scheme\n', '     * @return bool which represents a success\n', '     */\n', '    function unregisterScheme( address _scheme, address _avatar)\n', '    external\n', '    onlyRegisteringSchemes\n', '    onlySubjectToConstraint("unregisterScheme")\n', '    isAvatarValid(_avatar)\n', '    returns(bool)\n', '    {\n', '    //check if the scheme is registered\n', '        if (_isSchemeRegistered(_scheme) == false) {\n', '            return false;\n', '        }\n', '    // Check the unregistering scheme has enough permissions:\n', '        require(bytes4(0x0000001f)&(schemes[_scheme].permissions&(~schemes[msg.sender].permissions)) == bytes4(0));\n', '\n', '    // Unregister:\n', '        emit UnregisterScheme(msg.sender, _scheme);\n', '        delete schemes[_scheme];\n', '        return true;\n', '    }\n', '\n', '    /**\n', "     * @dev unregister the caller's scheme\n", '     * @return bool which represents a success\n', '     */\n', '    function unregisterSelf(address _avatar) external isAvatarValid(_avatar) returns(bool) {\n', '        if (_isSchemeRegistered(msg.sender) == false) {\n', '            return false;\n', '        }\n', '        delete schemes[msg.sender];\n', '        emit UnregisterScheme(msg.sender, msg.sender);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev add or update Global Constraint\n', '     * @param _globalConstraint the address of the global constraint to be added.\n', '     * @param _params the constraint parameters hash.\n', '     * @return bool which represents a success\n', '     */\n', '    function addGlobalConstraint(address _globalConstraint, bytes32 _params, address _avatar)\n', '    external\n', '    onlyGlobalConstraintsScheme\n', '    isAvatarValid(_avatar)\n', '    returns(bool)\n', '    {\n', '        GlobalConstraintInterface.CallPhase when = GlobalConstraintInterface(_globalConstraint).when();\n', '        if ((when == GlobalConstraintInterface.CallPhase.Pre)||\n', '            (when == GlobalConstraintInterface.CallPhase.PreAndPost)) {\n', '            if (!globalConstraintsRegisterPre[_globalConstraint].isRegistered) {\n', '                globalConstraintsPre.push(GlobalConstraint(_globalConstraint, _params));\n', '                globalConstraintsRegisterPre[_globalConstraint] =\n', '                GlobalConstraintRegister(true, globalConstraintsPre.length-1);\n', '            }else {\n', '                globalConstraintsPre[globalConstraintsRegisterPre[_globalConstraint].index].params = _params;\n', '            }\n', '        }\n', '        if ((when == GlobalConstraintInterface.CallPhase.Post)||\n', '            (when == GlobalConstraintInterface.CallPhase.PreAndPost)) {\n', '            if (!globalConstraintsRegisterPost[_globalConstraint].isRegistered) {\n', '                globalConstraintsPost.push(GlobalConstraint(_globalConstraint, _params));\n', '                globalConstraintsRegisterPost[_globalConstraint] =\n', '                GlobalConstraintRegister(true, globalConstraintsPost.length-1);\n', '            }else {\n', '                globalConstraintsPost[globalConstraintsRegisterPost[_globalConstraint].index].params = _params;\n', '            }\n', '        }\n', '        emit AddGlobalConstraint(_globalConstraint, _params, when);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev remove Global Constraint\n', '     * @param _globalConstraint the address of the global constraint to be remove.\n', '     * @return bool which represents a success\n', '     */\n', '     // solhint-disable-next-line code-complexity\n', '    function removeGlobalConstraint (address _globalConstraint, address _avatar)\n', '    external\n', '    onlyGlobalConstraintsScheme\n', '    isAvatarValid(_avatar)\n', '    returns(bool)\n', '    {\n', '        GlobalConstraintRegister memory globalConstraintRegister;\n', '        GlobalConstraint memory globalConstraint;\n', '        GlobalConstraintInterface.CallPhase when = GlobalConstraintInterface(_globalConstraint).when();\n', '        bool retVal = false;\n', '\n', '        if ((when == GlobalConstraintInterface.CallPhase.Pre)||\n', '            (when == GlobalConstraintInterface.CallPhase.PreAndPost)) {\n', '            globalConstraintRegister = globalConstraintsRegisterPre[_globalConstraint];\n', '            if (globalConstraintRegister.isRegistered) {\n', '                if (globalConstraintRegister.index < globalConstraintsPre.length-1) {\n', '                    globalConstraint = globalConstraintsPre[globalConstraintsPre.length-1];\n', '                    globalConstraintsPre[globalConstraintRegister.index] = globalConstraint;\n', '                    globalConstraintsRegisterPre[globalConstraint.gcAddress].index = globalConstraintRegister.index;\n', '                }\n', '                globalConstraintsPre.length--;\n', '                delete globalConstraintsRegisterPre[_globalConstraint];\n', '                retVal = true;\n', '            }\n', '        }\n', '        if ((when == GlobalConstraintInterface.CallPhase.Post)||\n', '            (when == GlobalConstraintInterface.CallPhase.PreAndPost)) {\n', '            globalConstraintRegister = globalConstraintsRegisterPost[_globalConstraint];\n', '            if (globalConstraintRegister.isRegistered) {\n', '                if (globalConstraintRegister.index < globalConstraintsPost.length-1) {\n', '                    globalConstraint = globalConstraintsPost[globalConstraintsPost.length-1];\n', '                    globalConstraintsPost[globalConstraintRegister.index] = globalConstraint;\n', '                    globalConstraintsRegisterPost[globalConstraint.gcAddress].index = globalConstraintRegister.index;\n', '                }\n', '                globalConstraintsPost.length--;\n', '                delete globalConstraintsRegisterPost[_globalConstraint];\n', '                retVal = true;\n', '            }\n', '        }\n', '        if (retVal) {\n', '            emit RemoveGlobalConstraint(\n', '            _globalConstraint,\n', '            globalConstraintRegister.index,\n', '            when == GlobalConstraintInterface.CallPhase.Pre\n', '            );\n', '        }\n', '        return retVal;\n', '    }\n', '\n', '  /**\n', '    * @dev upgrade the Controller\n', "    *      The function will trigger an event 'UpgradeController'.\n", '    * @param  _newController the address of the new controller.\n', '    * @return bool which represents a success\n', '    */\n', '    function upgradeController(address _newController, Avatar _avatar)\n', '    external\n', '    onlyUpgradingScheme\n', '    isAvatarValid(address(_avatar))\n', '    returns(bool)\n', '    {\n', '        require(newController == address(0));   // so the upgrade could be done once for a contract.\n', '        require(_newController != address(0));\n', '        newController = _newController;\n', '        avatar.transferOwnership(_newController);\n', '        require(avatar.owner() == _newController);\n', '        if (nativeToken.owner() == address(this)) {\n', '            nativeToken.transferOwnership(_newController);\n', '            require(nativeToken.owner() == _newController);\n', '        }\n', '        if (nativeReputation.owner() == address(this)) {\n', '            nativeReputation.transferOwnership(_newController);\n', '            require(nativeReputation.owner() == _newController);\n', '        }\n', '        emit UpgradeController(address(this), newController);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '    * @dev perform a generic call to an arbitrary contract\n', "    * @param _contract  the contract's address to call\n", '    * @param _data ABI-encoded contract call to call `_contract` address.\n', "    * @param _avatar the controller's avatar address\n", '    * @param _value value (ETH) to transfer with the transaction\n', '    * @return bool -success\n', "    *         bytes  - the return value of the called _contract's function.\n", '    */\n', '    function genericCall(address _contract, bytes calldata _data, Avatar _avatar, uint256 _value)\n', '    external\n', '    onlyGenericCallScheme\n', '    onlySubjectToConstraint("genericCall")\n', '    isAvatarValid(address(_avatar))\n', '    returns (bool, bytes memory)\n', '    {\n', '        return avatar.genericCall(_contract, _data, _value);\n', '    }\n', '\n', '  /**\n', '   * @dev send some ether\n', '   * @param _amountInWei the amount of ether (in Wei) to send\n', '   * @param _to address of the beneficiary\n', '   * @return bool which represents a success\n', '   */\n', '    function sendEther(uint256 _amountInWei, address payable _to, Avatar _avatar)\n', '    external\n', '    onlyRegisteredScheme\n', '    onlySubjectToConstraint("sendEther")\n', '    isAvatarValid(address(_avatar))\n', '    returns(bool)\n', '    {\n', '        return avatar.sendEther(_amountInWei, _to);\n', '    }\n', '\n', '    /**\n', '    * @dev send some amount of arbitrary ERC20 Tokens\n', '    * @param _externalToken the address of the Token Contract\n', '    * @param _to address of the beneficiary\n', '    * @param _value the amount of ether (in Wei) to send\n', '    * @return bool which represents a success\n', '    */\n', '    function externalTokenTransfer(IERC20 _externalToken, address _to, uint256 _value, Avatar _avatar)\n', '    external\n', '    onlyRegisteredScheme\n', '    onlySubjectToConstraint("externalTokenTransfer")\n', '    isAvatarValid(address(_avatar))\n', '    returns(bool)\n', '    {\n', '        return avatar.externalTokenTransfer(_externalToken, _to, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev transfer token "from" address "to" address\n', '    *      One must to approve the amount of tokens which can be spend from the\n', '    *      "from" account.This can be done using externalTokenApprove.\n', '    * @param _externalToken the address of the Token Contract\n', '    * @param _from address of the account to send from\n', '    * @param _to address of the beneficiary\n', '    * @param _value the amount of ether (in Wei) to send\n', '    * @return bool which represents a success\n', '    */\n', '    function externalTokenTransferFrom(\n', '    IERC20 _externalToken,\n', '    address _from,\n', '    address _to,\n', '    uint256 _value,\n', '    Avatar _avatar)\n', '    external\n', '    onlyRegisteredScheme\n', '    onlySubjectToConstraint("externalTokenTransferFrom")\n', '    isAvatarValid(address(_avatar))\n', '    returns(bool)\n', '    {\n', '        return avatar.externalTokenTransferFrom(_externalToken, _from, _to, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev externalTokenApproval approve the spender address to spend a specified amount of tokens\n', '    *      on behalf of msg.sender.\n', '    * @param _externalToken the address of the Token Contract\n', '    * @param _spender address\n', '    * @param _value the amount of ether (in Wei) which the approval is referring to.\n', '    * @return bool which represents a success\n', '    */\n', '    function externalTokenApproval(IERC20 _externalToken, address _spender, uint256 _value, Avatar _avatar)\n', '    external\n', '    onlyRegisteredScheme\n', '    onlySubjectToConstraint("externalTokenIncreaseApproval")\n', '    isAvatarValid(address(_avatar))\n', '    returns(bool)\n', '    {\n', '        return avatar.externalTokenApproval(_externalToken, _spender, _value);\n', '    }\n', '\n', '    /**\n', '    * @dev metaData emits an event with a string, should contain the hash of some meta data.\n', '    * @param _metaData a string representing a hash of the meta data\n', '    * @param _avatar Avatar\n', '    * @return bool which represents a success\n', '    */\n', '    function metaData(string calldata _metaData, Avatar _avatar)\n', '        external\n', '        onlyMetaDataScheme\n', '        isAvatarValid(address(_avatar))\n', '        returns(bool)\n', '        {\n', '        return avatar.metaData(_metaData);\n', '    }\n', '\n', '    /**\n', '     * @dev getNativeReputation\n', '     * @param _avatar the organization avatar.\n', '     * @return organization native reputation\n', '     */\n', '    function getNativeReputation(address _avatar) external isAvatarValid(_avatar) view returns(address) {\n', '        return address(nativeReputation);\n', '    }\n', '\n', '    function isSchemeRegistered(address _scheme, address _avatar) external isAvatarValid(_avatar) view returns(bool) {\n', '        return _isSchemeRegistered(_scheme);\n', '    }\n', '\n', '    function getSchemeParameters(address _scheme, address _avatar)\n', '    external\n', '    isAvatarValid(_avatar)\n', '    view\n', '    returns(bytes32)\n', '    {\n', '        return schemes[_scheme].paramsHash;\n', '    }\n', '\n', '    function getSchemePermissions(address _scheme, address _avatar)\n', '    external\n', '    isAvatarValid(_avatar)\n', '    view\n', '    returns(bytes4)\n', '    {\n', '        return schemes[_scheme].permissions;\n', '    }\n', '\n', '    function getGlobalConstraintParameters(address _globalConstraint, address) external view returns(bytes32) {\n', '\n', '        GlobalConstraintRegister memory register = globalConstraintsRegisterPre[_globalConstraint];\n', '\n', '        if (register.isRegistered) {\n', '            return globalConstraintsPre[register.index].params;\n', '        }\n', '\n', '        register = globalConstraintsRegisterPost[_globalConstraint];\n', '\n', '        if (register.isRegistered) {\n', '            return globalConstraintsPost[register.index].params;\n', '        }\n', '    }\n', '\n', '   /**\n', '    * @dev globalConstraintsCount return the global constraint pre and post count\n', '    * @return uint256 globalConstraintsPre count.\n', '    * @return uint256 globalConstraintsPost count.\n', '    */\n', '    function globalConstraintsCount(address _avatar)\n', '        external\n', '        isAvatarValid(_avatar)\n', '        view\n', '        returns(uint, uint)\n', '        {\n', '        return (globalConstraintsPre.length, globalConstraintsPost.length);\n', '    }\n', '\n', '    function isGlobalConstraintRegistered(address _globalConstraint, address _avatar)\n', '        external\n', '        isAvatarValid(_avatar)\n', '        view\n', '        returns(bool)\n', '        {\n', '        return (globalConstraintsRegisterPre[_globalConstraint].isRegistered ||\n', '                globalConstraintsRegisterPost[_globalConstraint].isRegistered);\n', '    }\n', '\n', '    function _isSchemeRegistered(address _scheme) private view returns(bool) {\n', '        return (schemes[_scheme].permissions&bytes4(0x00000001) != bytes4(0));\n', '    }\n', '}\n', '\n', '// File: @daostack/arc/contracts/schemes/Agreement.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', '/**\n', ' * @title A scheme for conduct ERC20 Tokens auction for reputation\n', ' */\n', '\n', '\n', 'contract Agreement {\n', '\n', '    bytes32 private agreementHash;\n', '\n', '    modifier onlyAgree(bytes32 _agreementHash) {\n', '        require(_agreementHash == agreementHash, "Sender must send the right agreementHash");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev getAgreementHash\n', '     * @return bytes32 agreementHash\n', '     */\n', '    function getAgreementHash() external  view returns(bytes32)\n', '    {\n', '        return agreementHash;\n', '    }\n', '\n', '    /**\n', '     * @dev setAgreementHash\n', '     * @param _agreementHash is a hash of agreement required to be added to the TX by participants\n', '     */\n', '    function setAgreementHash(bytes32 _agreementHash) internal\n', '    {\n', '        require(agreementHash == bytes32(0), "Can not set agreement twice");\n', '        agreementHash = _agreementHash;\n', '    }\n', '\n', '\n', '}\n', '\n', '// File: @daostack/arc/contracts/schemes/Locking4Reputation.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', '\n', '\n', '/**\n', ' * @title A locker contract\n', ' */\n', '\n', 'contract Locking4Reputation is Agreement {\n', '    using SafeMath for uint256;\n', '\n', '    event Redeem(address indexed _beneficiary, uint256 _amount);\n', '    event Release(bytes32 indexed _lockingId, address indexed _beneficiary, uint256 _amount);\n', '    event Lock(address indexed _locker, bytes32 indexed _lockingId, uint256 _amount, uint256 _period);\n', '\n', '    struct Locker {\n', '        uint256 amount;\n', '        uint256 releaseTime;\n', '    }\n', '\n', '    Avatar public avatar;\n', '\n', '    // A mapping from lockers addresses their lock balances.\n', '    mapping(address => mapping(bytes32=>Locker)) public lockers;\n', '    // A mapping from lockers addresses to their scores.\n', '    mapping(address => uint) public scores;\n', '\n', '    uint256 public totalLocked;\n', '    uint256 public totalLockedLeft;\n', '    uint256 public totalScore;\n', '    uint256 public lockingsCounter; // Total number of lockings\n', '    uint256 public reputationReward;\n', '    uint256 public reputationRewardLeft;\n', '    uint256 public lockingEndTime;\n', '    uint256 public maxLockingPeriod;\n', '    uint256 public lockingStartTime;\n', '    uint256 public redeemEnableTime;\n', '\n', '    /**\n', '     * @dev redeem reputation function\n', '     * @param _beneficiary the beneficiary for the release\n', '     * @return uint256 reputation rewarded\n', '     */\n', '    function redeem(address _beneficiary) public returns(uint256 reputation) {\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(block.timestamp > redeemEnableTime, "now > redeemEnableTime");\n', '        require(scores[_beneficiary] > 0, "score should be > 0");\n', '        uint256 score = scores[_beneficiary];\n', '        scores[_beneficiary] = 0;\n', '        uint256 repRelation = score.mul(reputationReward);\n', '        reputation = repRelation.div(totalScore);\n', '\n', '        //check that the reputation is sum zero\n', '        reputationRewardLeft = reputationRewardLeft.sub(reputation);\n', '        require(\n', '        Controller(\n', '        avatar.owner())\n', '        .mintReputation(reputation, _beneficiary, address(avatar)), "mint reputation should succeed");\n', '\n', '        emit Redeem(_beneficiary, reputation);\n', '    }\n', '\n', '    /**\n', '     * @dev release function\n', '     * @param _beneficiary the beneficiary for the release\n', '     * @param _lockingId the locking id to release\n', '     * @return bool\n', '     */\n', '    function _release(address _beneficiary, bytes32 _lockingId) internal returns(uint256 amount) {\n', '        Locker storage locker = lockers[_beneficiary][_lockingId];\n', '        require(locker.amount > 0, "amount should be > 0");\n', '        amount = locker.amount;\n', '        locker.amount = 0;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(block.timestamp > locker.releaseTime, "check the lock period pass");\n', '        totalLockedLeft = totalLockedLeft.sub(amount);\n', '\n', '        emit Release(_lockingId, _beneficiary, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev lock function\n', '     * @param _amount the amount to lock\n', '     * @param _period the locking period\n', '     * @param _locker the locker\n', '     * @param _numerator price numerator\n', '     * @param _denominator price denominator\n', '     * @return lockingId\n', '     */\n', '    function _lock(\n', '        uint256 _amount,\n', '        uint256 _period,\n', '        address _locker,\n', '        uint256 _numerator,\n', '        uint256 _denominator,\n', '        bytes32 _agreementHash)\n', '        internal\n', '        onlyAgree(_agreementHash)\n', '        returns(bytes32 lockingId)\n', '        {\n', '        require(_amount > 0, "locking amount should be > 0");\n', '        require(_period <= maxLockingPeriod, "locking period should be <= maxLockingPeriod");\n', '        require(_period > 0, "locking period should be > 0");\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now <= lockingEndTime, "lock should be within the allowed locking period");\n', '        // solhint-disable-next-line not-rely-on-time\n', '        require(now >= lockingStartTime, "lock should start after lockingStartTime");\n', '\n', '        lockingId = keccak256(abi.encodePacked(address(this), lockingsCounter));\n', '        lockingsCounter = lockingsCounter.add(1);\n', '\n', '        Locker storage locker = lockers[_locker][lockingId];\n', '        locker.amount = _amount;\n', '        // solhint-disable-next-line not-rely-on-time\n', '        locker.releaseTime = now + _period;\n', '        totalLocked = totalLocked.add(_amount);\n', '        totalLockedLeft = totalLockedLeft.add(_amount);\n', '        uint256 score = _period.mul(_amount).mul(_numerator).div(_denominator);\n', '        require(score > 0, "score must me > 0");\n', '        scores[_locker] = scores[_locker].add(score);\n', '        //verify that redeem will not overflow for this locker\n', '        require((scores[_locker] * reputationReward)/scores[_locker] == reputationReward,\n', '        "score is too high");\n', '        totalScore = totalScore.add(score);\n', '\n', '        emit Lock(_locker, lockingId, _amount, _period);\n', '    }\n', '\n', '    /**\n', '     * @dev _initialize\n', '     * @param _avatar the avatar to mint reputation from\n', '     * @param _reputationReward the total reputation this contract will reward\n', '     *        for eth/token locking\n', '     * @param _lockingStartTime the locking start time.\n', '     * @param _lockingEndTime the locking end time.\n', '     *        locking is disable after this time.\n', '     * @param _redeemEnableTime redeem enable time .\n', '     *        redeem reputation can be done after this time.\n', '     * @param _maxLockingPeriod maximum locking period allowed.\n', '     */\n', '    function _initialize(\n', '        Avatar _avatar,\n', '        uint256 _reputationReward,\n', '        uint256 _lockingStartTime,\n', '        uint256 _lockingEndTime,\n', '        uint256 _redeemEnableTime,\n', '        uint256 _maxLockingPeriod,\n', '        bytes32 _agreementHash )\n', '    internal\n', '    {\n', '        require(avatar == Avatar(0), "can be called only one time");\n', '        require(_avatar != Avatar(0), "avatar cannot be zero");\n', '        require(_lockingEndTime > _lockingStartTime, "locking end time should be greater than locking start time");\n', '        require(_redeemEnableTime >= _lockingEndTime, "redeemEnableTime >= lockingEndTime");\n', '\n', '        reputationReward = _reputationReward;\n', '        reputationRewardLeft = _reputationReward;\n', '        lockingEndTime = _lockingEndTime;\n', '        maxLockingPeriod = _maxLockingPeriod;\n', '        avatar = _avatar;\n', '        lockingStartTime = _lockingStartTime;\n', '        redeemEnableTime = _redeemEnableTime;\n', '        super.setAgreementHash(_agreementHash);\n', '    }\n', '\n', '}\n', '\n', '// File: @daostack/arc/contracts/schemes/PriceOracleInterface.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', 'interface PriceOracleInterface {\n', '\n', '    function getPrice(address token) external view returns (uint, uint);\n', '\n', '}\n', '\n', '// File: @daostack/arc/contracts/schemes/LockingToken4Reputation.sol\n', '\n', 'pragma solidity 0.5.13;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title A scheme for locking ERC20 Tokens for reputation\n', ' */\n', '\n', 'contract LockingToken4Reputation is Locking4Reputation {\n', '    using SafeERC20 for address;\n', '\n', '    PriceOracleInterface public priceOracleContract;\n', '    //      lockingId => token\n', '    mapping(bytes32   => address) public lockedTokens;\n', '\n', '    event LockToken(bytes32 indexed _lockingId, address indexed _token, uint256 _numerator, uint256 _denominator);\n', '\n', '    /**\n', '     * @dev initialize\n', '     * @param _avatar the avatar to mint reputation from\n', '     * @param _reputationReward the total reputation this contract will reward\n', '     *        for the token locking\n', '     * @param _lockingStartTime locking starting period time.\n', '     * @param _lockingEndTime the locking end time.\n', '     *        locking is disable after this time.\n', '     * @param _redeemEnableTime redeem enable time .\n', '     *        redeem reputation can be done after this time.\n', '     * @param _maxLockingPeriod maximum locking period allowed.\n', '     * @param _priceOracleContract the price oracle contract which the locked token will be\n', '     *        validated against\n', '     */\n', '    function initialize(\n', '        Avatar _avatar,\n', '        uint256 _reputationReward,\n', '        uint256 _lockingStartTime,\n', '        uint256 _lockingEndTime,\n', '        uint256 _redeemEnableTime,\n', '        uint256 _maxLockingPeriod,\n', '        PriceOracleInterface _priceOracleContract,\n', '        bytes32 _agreementHash)\n', '    external\n', '    {\n', '        priceOracleContract = _priceOracleContract;\n', '        super._initialize(\n', '        _avatar,\n', '        _reputationReward,\n', '        _lockingStartTime,\n', '        _lockingEndTime,\n', '        _redeemEnableTime,\n', '        _maxLockingPeriod,\n', '        _agreementHash);\n', '    }\n', '\n', '    /**\n', '     * @dev release locked tokens\n', '     * @param _beneficiary the release _beneficiary\n', '     * @param _lockingId the locking id\n', '     * @return bool\n', '     */\n', '    function release(address _beneficiary, bytes32 _lockingId) public returns(bool) {\n', '        uint256 amount = super._release(_beneficiary, _lockingId);\n', '        lockedTokens[_lockingId].safeTransfer(_beneficiary, amount);\n', '\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev lock function\n', '     * @param _amount the amount to lock\n', '     * @param _period the locking period\n', '     * @param _token the token to lock - this should be whitelisted at the priceOracleContract\n', '     * @return lockingId\n', '     */\n', '    function lock(uint256 _amount,\n', '        uint256 _period,\n', '        address _token,\n', '        bytes32 _agreementHash)\n', '    public returns(bytes32 lockingId) {\n', '\n', '        uint256 numerator;\n', '        uint256 denominator;\n', '\n', '        (numerator, denominator) = priceOracleContract.getPrice(_token);\n', '\n', '        require(numerator > 0, "numerator should be > 0");\n', '        require(denominator > 0, "denominator should be > 0");\n', '\n', '        _token.safeTransferFrom(msg.sender, address(this), _amount);\n', '\n', '        lockingId = super._lock(_amount, _period, msg.sender, numerator, denominator, _agreementHash);\n', '\n', '        lockedTokens[lockingId] = _token;\n', '\n', '        emit LockToken(lockingId, _token, numerator, denominator);\n', '    }\n', '}']