['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-14\n', '*/\n', '\n', 'pragma solidity ^0.5.17;\n', '\n', 'contract CloneFactory {\n', '\n', '  function createClone(address target) internal returns (address result) {\n', '    bytes20 targetBytes = bytes20(target);\n', '    assembly {\n', '      let clone := mload(0x40)\n', '      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '      mstore(add(clone, 0x14), targetBytes)\n', '      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '      result := create(0, clone, 0x37)\n', '    }\n', '  }\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor () internal { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '    \n', '    function initOwnable() internal{\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return _msgSender() == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev Give an account access to this role.\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(!has(role, account), "Roles: account already has role");\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev Remove an account's access to this role.\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(has(role, account), "Roles: account does not have role");\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev Check if an account has this role.\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0), "Roles: account is the zero address");\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', 'contract MinterRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event MinterAdded(address indexed account);\n', '    event MinterRemoved(address indexed account);\n', '\n', '    Roles.Role private _minters;\n', '\n', '    function initMinter() internal{\n', '        _addMinter(_msgSender());\n', '    }\n', '\n', '    constructor () internal {\n', '        _addMinter(_msgSender());\n', '    }\n', '\n', '    modifier onlyMinter() {\n', '        require(isMinter(_msgSender()), "MinterRole: caller does not have the Minter role");\n', '        _;\n', '    }\n', '\n', '    function isMinter(address account) public view returns (bool) {\n', '        return _minters.has(account);\n', '    }\n', '\n', '    function addMinter(address account) public onlyMinter {\n', '        _addMinter(account);\n', '    }\n', '\n', '    function renounceMinter() public {\n', '        _removeMinter(_msgSender());\n', '    }\n', '\n', '    function _addMinter(address account) internal {\n', '        _minters.add(account);\n', '        emit MinterAdded(account);\n', '    }\n', '\n', '    function _removeMinter(address account) internal {\n', '        _minters.remove(account);\n', '        emit MinterRemoved(account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title WhitelistAdminRole\n', ' * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.\n', ' */\n', 'contract WhitelistAdminRole is Context {\n', '    using Roles for Roles.Role;\n', '\n', '    event WhitelistAdminAdded(address indexed account);\n', '    event WhitelistAdminRemoved(address indexed account);\n', '\n', '    Roles.Role private _whitelistAdmins;\n', '\n', '    function initWhiteListAdmin() internal{\n', '        _addWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    constructor () internal {\n', '        _addWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    modifier onlyWhitelistAdmin() {\n', '        require(isWhitelistAdmin(_msgSender()), "WhitelistAdminRole: caller does not have the WhitelistAdmin role");\n', '        _;\n', '    }\n', '\n', '    function isWhitelistAdmin(address account) public view returns (bool) {\n', '        return _whitelistAdmins.has(account);\n', '    }\n', '\n', '    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {\n', '        _addWhitelistAdmin(account);\n', '    }\n', '\n', '    function renounceWhitelistAdmin() public {\n', '        _removeWhitelistAdmin(_msgSender());\n', '    }\n', '\n', '    function _addWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.add(account);\n', '        emit WhitelistAdminAdded(account);\n', '    }\n', '\n', '    function _removeWhitelistAdmin(address account) internal {\n', '        _whitelistAdmins.remove(account);\n', '        emit WhitelistAdminRemoved(account);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface IERC165 {\n', '\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas\n', '     * @param _interfaceId The interface identifier, as specified in ERC-165\n', '     */\n', '    function supportsInterface(bytes4 _interfaceId)\n', '    external\n', '    view\n', '    returns (bool);\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '\n', '  /**\n', '   * @dev Multiplies two unsigned integers, reverts on overflow.\n', '   */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath#mul: OVERFLOW");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '   */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Solidity only automatically asserts when dividing by 0\n', '    require(b > 0, "SafeMath#div: DIVISION_BY_ZERO");\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '   */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "SafeMath#sub: UNDERFLOW");\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Adds two unsigned integers, reverts on overflow.\n', '   */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath#add: OVERFLOW");\n', '\n', '    return c; \n', '  }\n', '\n', '  /**\n', '   * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '   * reverts when dividing by zero.\n', '   */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0, "SafeMath#mod: DIVISION_BY_ZERO");\n', '    return a % b;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @dev ERC-1155 interface for accepting safe transfers.\n', ' */\n', 'interface IERC1155TokenReceiver {\n', '\n', '  /**\n', '   * @notice Handle the receipt of a single ERC1155 token type\n', '   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated\n', '   * This function MAY throw to revert and reject the transfer\n', '   * Return of other amount than the magic value MUST result in the transaction being reverted\n', '   * Note: The token contract address is always the message sender\n', '   * @param _operator  The address which called the `safeTransferFrom` function\n', '   * @param _from      The address which previously owned the token\n', '   * @param _id        The id of the token being transferred\n', '   * @param _amount    The amount of tokens being transferred\n', '   * @param _data      Additional data with no specified format\n', '   * @return           `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '   */\n', '  function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _amount, bytes calldata _data) external returns(bytes4);\n', '\n', '  /**\n', '   * @notice Handle the receipt of multiple ERC1155 token types\n', '   * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated\n', '   * This function MAY throw to revert and reject the transfer\n', '   * Return of other amount than the magic value WILL result in the transaction being reverted\n', '   * Note: The token contract address is always the message sender\n', '   * @param _operator  The address which called the `safeBatchTransferFrom` function\n', '   * @param _from      The address which previously owned the token\n', '   * @param _ids       An array containing ids of each token being transferred\n', '   * @param _amounts   An array containing amounts of each token being transferred\n', '   * @param _data      Additional data with no specified format\n', '   * @return           `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '   */\n', '  function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external returns(bytes4);\n', '\n', '  /**\n', '   * @notice Indicates whether a contract implements the `ERC1155TokenReceiver` functions and so can accept ERC1155 token types.\n', '   * @param  interfaceID The ERC-165 interface ID that is queried for support.s\n', '   * @dev This function MUST return true if it implements the ERC1155TokenReceiver interface and ERC-165 interface.\n', '   *      This function MUST NOT consume more than 5,000 gas.\n', '   * @return Wheter ERC-165 or ERC1155TokenReceiver interfaces are supported.\n', '   */\n', '  function supportsInterface(bytes4 interfaceID) external view returns (bool);\n', '\n', '}\n', '\n', 'interface IERC1155 {\n', '  // Events\n', '\n', '  /**\n', '   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n', '   *   Operator MUST be msg.sender\n', '   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n', '   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n', '   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n', '   *   To broadcast the existence of a token ID with no initial balance, the contract SHOULD emit the TransferSingle event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n', '   */\n', '  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n', '\n', '  /**\n', '   * @dev Either TransferSingle or TransferBatch MUST emit when tokens are transferred, including zero amount transfers as well as minting or burning\n', '   *   Operator MUST be msg.sender\n', '   *   When minting/creating tokens, the `_from` field MUST be set to `0x0`\n', '   *   When burning/destroying tokens, the `_to` field MUST be set to `0x0`\n', '   *   The total amount transferred from address 0x0 minus the total amount transferred to 0x0 may be used by clients and exchanges to be added to the "circulating supply" for a given token ID\n', '   *   To broadcast the existence of multiple token IDs with no initial balance, this SHOULD emit the TransferBatch event from `0x0` to `0x0`, with the token creator as `_operator`, and a `_amount` of 0\n', '   */\n', '  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n', '\n', '  /**\n', '   * @dev MUST emit when an approval is updated\n', '   */\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '  /**\n', '   * @dev MUST emit when the URI is updated for a token ID\n', '   *   URIs are defined in RFC 3986\n', '   *   The URI MUST point a JSON file that conforms to the "ERC-1155 Metadata JSON Schema"\n', '   */\n', '  event URI(string _amount, uint256 indexed _id);\n', '\n', '  /**\n', '   * @notice Transfers amount of an _id from the _from address to the _to address specified\n', '   * @dev MUST emit TransferSingle event on success\n', "   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\n", '   * MUST throw if `_to` is the zero address\n', '   * MUST throw if balance of sender for token `_id` is lower than the `_amount` sent\n', '   * MUST throw on any other error\n', '   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155Received` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '   * @param _from    Source address\n', '   * @param _to      Target address\n', '   * @param _id      ID of the token type\n', '   * @param _amount  Transfered amount\n', '   * @param _data    Additional data with no specified format, sent in call to `_to`\n', '   */\n', '  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data) external;\n', '\n', '  /**\n', '   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n', '   * @dev MUST emit TransferBatch event on success\n', "   * Caller must be approved to manage the _from account's tokens (see isApprovedForAll)\n", '   * MUST throw if `_to` is the zero address\n', '   * MUST throw if length of `_ids` is not the same as length of `_amounts`\n', '   * MUST throw if any of the balance of sender for token `_ids` is lower than the respective `_amounts` sent\n', '   * MUST throw on any other error\n', '   * When transfer is complete, this function MUST check if `_to` is a smart contract (code size > 0). If so, it MUST call `onERC1155BatchReceived` on `_to` and revert if the return amount is not `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '   * Transfers and events MUST occur in the array order they were submitted (_ids[0] before _ids[1], etc)\n', '   * @param _from     Source addresses\n', '   * @param _to       Target addresses\n', '   * @param _ids      IDs of each token type\n', '   * @param _amounts  Transfer amounts per token type\n', '   * @param _data     Additional data with no specified format, sent in call to `_to`\n', '  */\n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data) external;\n', '  \n', '  /**\n', "   * @notice Get the balance of an account's Tokens\n", '   * @param _owner  The address of the token holder\n', '   * @param _id     ID of the Token\n', "   * @return        The _owner's balance of the Token type requested\n", '   */\n', '  function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n', '\n', '  /**\n', '   * @notice Get the balance of multiple account/token pairs\n', '   * @param _owners The addresses of the token holders\n', '   * @param _ids    ID of the Tokens\n', "   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n", '   */\n', '  function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n', '\n', '  /**\n', '   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n', '   * @dev MUST emit the ApprovalForAll event on success\n', '   * @param _operator  Address to add to the set of authorized operators\n', '   * @param _approved  True if the operator is approved, false to revoke approval\n', '   */\n', '  function setApprovalForAll(address _operator, bool _approved) external;\n', '\n', '  /**\n', '   * @notice Queries the approval status of an operator for a given owner\n', '   * @param _owner     The owner of the Tokens\n', '   * @param _operator  Address of authorized operator\n', '   * @return           True if the operator is approved, false if not\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator) external view returns (bool isOperator);\n', '\n', '}\n', '\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call.value(value)(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Implementation of Multi-Token Standard contract\n', ' */\n', 'contract ERC1155 is IERC165 {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '\n', '\n', '  /***********************************|\n', '  |        Variables and Events       |\n', '  |__________________________________*/\n', '\n', '  // onReceive function signatures\n', '  bytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\n', '  bytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\n', '\n', '  // Objects balances\n', '  mapping (address => mapping(uint256 => uint256)) internal balances;\n', '\n', '  // Operator Functions\n', '  mapping (address => mapping(address => bool)) internal operators;\n', '\n', '  // Events\n', '  event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _amount);\n', '  event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _amounts);\n', '  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '  event URI(string _uri, uint256 indexed _id);\n', '\n', '\n', '  /***********************************|\n', '  |     Public Transfer Functions     |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n', '   * @param _from    Source address\n', '   * @param _to      Target address\n', '   * @param _id      ID of the token type\n', '   * @param _amount  Transfered amount\n', '   * @param _data    Additional data with no specified format, sent in call to `_to`\n', '   */\n', '  function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n', '    public\n', '  {\n', '    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155#safeTransferFrom: INVALID_OPERATOR");\n', '    require(_to != address(0),"ERC1155#safeTransferFrom: INVALID_RECIPIENT");\n', '    // require(_amount >= balances[_from][_id]) is not necessary since checked with safemath operations\n', '\n', '    _safeTransferFrom(_from, _to, _id, _amount);\n', '    _callonERC1155Received(_from, _to, _id, _amount, _data);\n', '  }\n', '\n', '  /**\n', '   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n', '   * @param _from     Source addresses\n', '   * @param _to       Target addresses\n', '   * @param _ids      IDs of each token type\n', '   * @param _amounts  Transfer amounts per token type\n', '   * @param _data     Additional data with no specified format, sent in call to `_to`\n', '   */\n', '  function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n', '    public\n', '  {\n', '    // Requirements\n', '    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), "ERC1155#safeBatchTransferFrom: INVALID_OPERATOR");\n', '    require(_to != address(0), "ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT");\n', '\n', '    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n', '    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |    Internal Transfer Functions    |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Transfers amount amount of an _id from the _from address to the _to address specified\n', '   * @param _from    Source address\n', '   * @param _to      Target address\n', '   * @param _id      ID of the token type\n', '   * @param _amount  Transfered amount\n', '   */\n', '  function _safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount)\n', '    internal\n', '  {\n', '    // Update balances\n', '    balances[_from][_id] = balances[_from][_id].sub(_amount); // Subtract amount\n', '    balances[_to][_id] = balances[_to][_id].add(_amount);     // Add amount\n', '\n', '    // Emit event\n', '    emit TransferSingle(msg.sender, _from, _to, _id, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155Received(...)\n', '   */\n', '  function _callonERC1155Received(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n', '    internal\n', '  {\n', '    // Check if recipient is contract\n', '    if (_to.isContract()) {\n', '      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received(msg.sender, _from, _id, _amount, _data);\n', '      require(retval == ERC1155_RECEIVED_VALUE, "ERC1155#_callonERC1155Received: INVALID_ON_RECEIVE_MESSAGE");\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Send multiple types of Tokens from the _from address to the _to address (with safety call)\n', '   * @param _from     Source addresses\n', '   * @param _to       Target addresses\n', '   * @param _ids      IDs of each token type\n', '   * @param _amounts  Transfer amounts per token type\n', '   */\n', '  function _safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts)\n', '    internal\n', '  {\n', '    require(_ids.length == _amounts.length, "ERC1155#_safeBatchTransferFrom: INVALID_ARRAYS_LENGTH");\n', '\n', '    // Number of transfer to execute\n', '    uint256 nTransfer = _ids.length;\n', '\n', '    // Executing all transfers\n', '    for (uint256 i = 0; i < nTransfer; i++) {\n', '      // Update storage balance of previous bin\n', '      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\n', '      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\n', '    }\n', '\n', '    // Emit event\n', '    emit TransferBatch(msg.sender, _from, _to, _ids, _amounts);\n', '  }\n', '\n', '  /**\n', '   * @notice Verifies if receiver is contract and if so, calls (_to).onERC1155BatchReceived(...)\n', '   */\n', '  function _callonERC1155BatchReceived(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n', '    internal\n', '  {\n', '    // Pass data if recipient is contract\n', '    if (_to.isContract()) {\n', '      bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived(msg.sender, _from, _ids, _amounts, _data);\n', '      require(retval == ERC1155_BATCH_RECEIVED_VALUE, "ERC1155#_callonERC1155BatchReceived: INVALID_ON_RECEIVE_MESSAGE");\n', '    }\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |         Operator Functions        |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Enable or disable approval for a third party ("operator") to manage all of caller\'s tokens\n', '   * @param _operator  Address to add to the set of authorized operators\n', '   * @param _approved  True if the operator is approved, false to revoke approval\n', '   */\n', '  function setApprovalForAll(address _operator, bool _approved)\n', '    external\n', '  {\n', '    // Update operator status\n', '    operators[msg.sender][_operator] = _approved;\n', '    emit ApprovalForAll(msg.sender, _operator, _approved);\n', '  }\n', '\n', '  /**\n', '   * @notice Queries the approval status of an operator for a given owner\n', '   * @param _owner     The owner of the Tokens\n', '   * @param _operator  Address of authorized operator\n', '   * @return True if the operator is approved, false if not\n', '   */\n', '  function isApprovedForAll(address _owner, address _operator)\n', '    public view returns (bool isOperator)\n', '  {\n', '    return operators[_owner][_operator];\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |         Balance Functions         |\n', '  |__________________________________*/\n', '\n', '  /**\n', "   * @notice Get the balance of an account's Tokens\n", '   * @param _owner  The address of the token holder\n', '   * @param _id     ID of the Token\n', "   * @return The _owner's balance of the Token type requested\n", '   */\n', '  function balanceOf(address _owner, uint256 _id)\n', '    public view returns (uint256)\n', '  {\n', '    return balances[_owner][_id];\n', '  }\n', '\n', '  /**\n', '   * @notice Get the balance of multiple account/token pairs\n', '   * @param _owners The addresses of the token holders\n', '   * @param _ids    ID of the Tokens\n', "   * @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair)\n", '   */\n', '  function balanceOfBatch(address[] memory _owners, uint256[] memory _ids)\n', '    public view returns (uint256[] memory)\n', '  {\n', '    require(_owners.length == _ids.length, "ERC1155#balanceOfBatch: INVALID_ARRAY_LENGTH");\n', '\n', '    // Variables\n', '    uint256[] memory batchBalances = new uint256[](_owners.length);\n', '\n', '    // Iterate over each owner and token ID\n', '    for (uint256 i = 0; i < _owners.length; i++) {\n', '      batchBalances[i] = balances[_owners[i]][_ids[i]];\n', '    }\n', '\n', '    return batchBalances;\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |          ERC165 Functions         |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * INTERFACE_SIGNATURE_ERC165 = bytes4(keccak256("supportsInterface(bytes4)"));\n', '   */\n', '  bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\n', '\n', '  /**\n', '   * INTERFACE_SIGNATURE_ERC1155 =\n', '   * bytes4(keccak256("safeTransferFrom(address,address,uint256,uint256,bytes)")) ^\n', '   * bytes4(keccak256("safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)")) ^\n', '   * bytes4(keccak256("balanceOf(address,uint256)")) ^\n', '   * bytes4(keccak256("balanceOfBatch(address[],uint256[])")) ^\n', '   * bytes4(keccak256("setApprovalForAll(address,bool)")) ^\n', '   * bytes4(keccak256("isApprovedForAll(address,address)"));\n', '   */\n', '  bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n', '\n', '  /**\n', '   * @notice Query if a contract implements an interface\n', '   * @param _interfaceID  The interface identifier, as specified in ERC-165\n', '   * @return `true` if the contract implements `_interfaceID` and\n', '   */\n', '  function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n', '    if (_interfaceID == INTERFACE_SIGNATURE_ERC165 ||\n', '        _interfaceID == INTERFACE_SIGNATURE_ERC1155) {\n', '      return true;\n', '    }\n', '    return false;\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @notice Contract that handles metadata related methods.\n', ' * @dev Methods assume a deterministic generation of URI based on token IDs.\n', ' *      Methods also assume that URI uses hex representation of token IDs.\n', ' */\n', 'contract ERC1155Metadata {\n', '\n', "  // URI's default URI prefix\n", '  string internal baseMetadataURI;\n', '  event URI(string _uri, uint256 indexed _id);\n', '\n', '\n', '  /***********************************|\n', '  |     Metadata Public Function s    |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice A distinct Uniform Resource Identifier (URI) for a given token.\n', '   * @dev URIs are defined in RFC 3986.\n', '   *      URIs are assumed to be deterministically generated based on token ID\n', '   *      Token IDs are assumed to be represented in their hex format in URIs\n', '   * @return URI string\n', '   */\n', '  function uri(uint256 _id) public view returns (string memory) {\n', '    return string(abi.encodePacked(baseMetadataURI, _uint2str(_id), ".json"));\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |    Metadata Internal Functions    |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Will emit default URI log event for corresponding token _id\n', '   * @param _tokenIDs Array of IDs of tokens to log default URI\n', '   */\n', '  function _logURIs(uint256[] memory _tokenIDs) internal {\n', '    string memory baseURL = baseMetadataURI;\n', '    string memory tokenURI;\n', '\n', '    for (uint256 i = 0; i < _tokenIDs.length; i++) {\n', '      tokenURI = string(abi.encodePacked(baseURL, _uint2str(_tokenIDs[i]), ".json"));\n', '      emit URI(tokenURI, _tokenIDs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Will emit a specific URI log event for corresponding token\n', '   * @param _tokenIDs IDs of the token corresponding to the _uris logged\n', '   * @param _URIs    The URIs of the specified _tokenIDs\n', '   */\n', '  function _logURIs(uint256[] memory _tokenIDs, string[] memory _URIs) internal {\n', '    require(_tokenIDs.length == _URIs.length, "ERC1155Metadata#_logURIs: INVALID_ARRAYS_LENGTH");\n', '    for (uint256 i = 0; i < _tokenIDs.length; i++) {\n', '      emit URI(_URIs[i], _tokenIDs[i]);\n', '    }\n', '  }\n', '\n', '  /**\n', "   * @notice Will update the base URL of token's URI\n", "   * @param _newBaseMetadataURI New base URL of token's URI\n", '   */\n', '  function _setBaseMetadataURI(string memory _newBaseMetadataURI) internal {\n', '    baseMetadataURI = _newBaseMetadataURI;\n', '  }\n', '\n', '\n', '  /***********************************|\n', '  |    Utility Internal Functions     |\n', '  |__________________________________*/\n', '\n', '  /**\n', '   * @notice Convert uint256 to string\n', '   * @param _i Unsigned integer to convert to string\n', '   */\n', '  function _uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n', '    if (_i == 0) {\n', '      return "0";\n', '    }\n', '\n', '    uint256 j = _i;\n', '    uint256 ii = _i;\n', '    uint256 len;\n', '\n', '    // Get number of bytes\n', '    while (j != 0) {\n', '      len++;\n', '      j /= 10;\n', '    }\n', '\n', '    bytes memory bstr = new bytes(len);\n', '    uint256 k = len - 1;\n', '\n', '    // Get each individual ASCII\n', '    while (ii != 0) {\n', '      bstr[k--] = byte(uint8(48 + ii % 10));\n', '      ii /= 10;\n', '    }\n', '\n', '    // Convert to string\n', '    return string(bstr);\n', '  }\n', '\n', '}\n', '\n', '/**\n', ' * @dev Multi-Fungible Tokens with minting and burning methods. These methods assume\n', ' *      a parent contract to be executed as they are `internal` functions\n', ' */\n', 'contract ERC1155MintBurn is ERC1155 {\n', '\n', '\n', '  /****************************************|\n', '  |            Minting Functions           |\n', '  |_______________________________________*/\n', '\n', '  /**\n', '   * @notice Mint _amount of tokens of a given id\n', '   * @param _to      The address to mint tokens to\n', '   * @param _id      Token id to mint\n', '   * @param _amount  The amount to be minted\n', '   * @param _data    Data to pass if receiver is contract\n', '   */\n', '  function _mint(address _to, uint256 _id, uint256 _amount, bytes memory _data)\n', '    internal\n', '  {\n', '    // Add _amount\n', '    balances[_to][_id] = balances[_to][_id].add(_amount);\n', '\n', '    // Emit event\n', '    emit TransferSingle(msg.sender, address(0x0), _to, _id, _amount);\n', '\n', '    // Calling onReceive method if recipient is contract\n', '    _callonERC1155Received(address(0x0), _to, _id, _amount, _data);\n', '  }\n', '\n', '  /**\n', '   * @notice Mint tokens for each ids in _ids\n', '   * @param _to       The address to mint tokens to\n', '   * @param _ids      Array of ids to mint\n', '   * @param _amounts  Array of amount of tokens to mint per id\n', '   * @param _data    Data to pass if receiver is contract\n', '   */\n', '  function _batchMint(address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n', '    internal\n', '  {\n', '    require(_ids.length == _amounts.length, "ERC1155MintBurn#batchMint: INVALID_ARRAYS_LENGTH");\n', '\n', '    // Number of mints to execute\n', '    uint256 nMint = _ids.length;\n', '\n', '     // Executing all minting\n', '    for (uint256 i = 0; i < nMint; i++) {\n', '      // Update storage balance\n', '      balances[_to][_ids[i]] = balances[_to][_ids[i]].add(_amounts[i]);\n', '    }\n', '\n', '    // Emit batch mint event\n', '    emit TransferBatch(msg.sender, address(0x0), _to, _ids, _amounts);\n', '\n', '    // Calling onReceive method if recipient is contract\n', '    _callonERC1155BatchReceived(address(0x0), _to, _ids, _amounts, _data);\n', '  }\n', '\n', '\n', '  /****************************************|\n', '  |            Burning Functions           |\n', '  |_______________________________________*/\n', '\n', '  /**\n', '   * @notice Burn _amount of tokens of a given token id\n', '   * @param _from    The address to burn tokens from\n', '   * @param _id      Token id to burn\n', '   * @param _amount  The amount to be burned\n', '   */\n', '  function _burn(address _from, uint256 _id, uint256 _amount)\n', '    internal\n', '  {\n', '    //Substract _amount\n', '    balances[_from][_id] = balances[_from][_id].sub(_amount);\n', '\n', '    // Emit event\n', '    emit TransferSingle(msg.sender, _from, address(0x0), _id, _amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Burn tokens of given token id for each (_ids[i], _amounts[i]) pair\n', '   * @param _from     The address to burn tokens from\n', '   * @param _ids      Array of token ids to burn\n', '   * @param _amounts  Array of the amount to be burned\n', '   */\n', '  function _batchBurn(address _from, uint256[] memory _ids, uint256[] memory _amounts)\n', '    internal\n', '  {\n', '    require(_ids.length == _amounts.length, "ERC1155MintBurn#batchBurn: INVALID_ARRAYS_LENGTH");\n', '\n', '    // Number of mints to execute\n', '    uint256 nBurn = _ids.length;\n', '\n', '     // Executing all minting\n', '    for (uint256 i = 0; i < nBurn; i++) {\n', '      // Update storage balance\n', '      balances[_from][_ids[i]] = balances[_from][_ids[i]].sub(_amounts[i]);\n', '    }\n', '\n', '    // Emit batch mint event\n', '    emit TransferBatch(msg.sender, _from, address(0x0), _ids, _amounts);\n', '  }\n', '\n', '}\n', '\n', 'library Strings {\n', '\t// via https://github.com/oraclize/ethereum-api/blob/master/oraclizeAPI_0.5.sol\n', '\tfunction strConcat(\n', '\t\tstring memory _a,\n', '\t\tstring memory _b,\n', '\t\tstring memory _c,\n', '\t\tstring memory _d,\n', '\t\tstring memory _e\n', '\t) internal pure returns (string memory) {\n', '\t\tbytes memory _ba = bytes(_a);\n', '\t\tbytes memory _bb = bytes(_b);\n', '\t\tbytes memory _bc = bytes(_c);\n', '\t\tbytes memory _bd = bytes(_d);\n', '\t\tbytes memory _be = bytes(_e);\n', '\t\tstring memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n', '\t\tbytes memory babcde = bytes(abcde);\n', '\t\tuint256 k = 0;\n', '\t\tfor (uint256 i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n', '\t\tfor (uint256 i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n', '\t\tfor (uint256 i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n', '\t\tfor (uint256 i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n', '\t\tfor (uint256 i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n', '\t\treturn string(babcde);\n', '\t}\n', '\n', '\tfunction strConcat(\n', '\t\tstring memory _a,\n', '\t\tstring memory _b,\n', '\t\tstring memory _c,\n', '\t\tstring memory _d\n', '\t) internal pure returns (string memory) {\n', '\t\treturn strConcat(_a, _b, _c, _d, "");\n', '\t}\n', '\n', '\tfunction strConcat(\n', '\t\tstring memory _a,\n', '\t\tstring memory _b,\n', '\t\tstring memory _c\n', '\t) internal pure returns (string memory) {\n', '\t\treturn strConcat(_a, _b, _c, "", "");\n', '\t}\n', '\n', '\tfunction strConcat(string memory _a, string memory _b) internal pure returns (string memory) {\n', '\t\treturn strConcat(_a, _b, "", "", "");\n', '\t}\n', '\n', '\tfunction uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n', '\t\tif (_i == 0) {\n', '\t\t\treturn "0";\n', '\t\t}\n', '\t\tuint256 j = _i;\n', '\t\tuint256 len;\n', '\t\twhile (j != 0) {\n', '\t\t\tlen++;\n', '\t\t\tj /= 10;\n', '\t\t}\n', '\t\tbytes memory bstr = new bytes(len);\n', '\t\tuint256 k = len - 1;\n', '\t\twhile (_i != 0) {\n', '\t\t\tbstr[k--] = bytes1(uint8(48 + (_i % 10)));\n', '\t\t\t_i /= 10;\n', '\t\t}\n', '\t\treturn string(bstr);\n', '\t}\n', '}\n', '\n', 'contract OwnableDelegateProxy {}\n', '\n', 'contract ProxyRegistry {\n', '\tmapping(address => OwnableDelegateProxy) public proxies;\n', '}\n', '\n', '/**\n', ' * @title ERC1155Tradable\n', ' * ERC1155Tradable - ERC1155 contract that whitelists an operator address, \n', ' * has create and mint functionality, and supports useful standards from OpenZeppelin,\n', '  like _exists(), name(), symbol(), and totalSupply()\n', ' */\n', 'contract ERC1155Tradable is ERC1155, ERC1155MintBurn, ERC1155Metadata, Ownable, MinterRole, WhitelistAdminRole {\n', '\tusing Strings for string;\n', '\n', '    struct BridgedNft {\n', '        address _address;\n', '\t\tbytes _b_id;\n', '\t\tbytes _b_chainId;\n', '\t}\n', '\n', '\taddress proxyRegistryAddress;\n', '\tuint256 private _currentTokenID = 0;\n', '\tmapping(uint256 => address) public creators;\n', '\tmapping(uint256 => uint256) public tokenSupply;\n', '\tmapping(uint256 => uint256) public tokenMaxSupply;\n', '\t\n', '\t// chainId => collection address => nft id = this NFTs id\n', '\t// required to determine if creation or minting needs to be performed\n', '\tmapping(bytes => mapping ( address => mapping ( bytes => uint256 ) ) ) public bridged;\n', '\tmapping(bytes => BridgedNft) public bridgedMap;\n', '\t\n', '\t// Contract name\n', '\tstring public name;\n', '\t// Contract symbol\n', '\tstring public symbol;\n', '\n', '    mapping(uint256 => string) private uris;\n', '\n', '    bool private constructed = false;\n', '\n', '    function init(\n', '\t\tstring memory _name,\n', '\t\tstring memory _symbol,\n', '\t\taddress _proxyRegistryAddress\n', '\t) public {\n', '\t    \n', '\t    require(!constructed, "ERC155 Tradeable must not be constructed yet");\n', '\t    \n', '\t    constructed = true;\n', '\t    \n', '\t\tname = _name;\n', '\t\tsymbol = _symbol;\n', '\t\tproxyRegistryAddress = _proxyRegistryAddress;\n', '\t\t\n', '\t\tsuper.initOwnable();\n', '\t\tsuper.initMinter();\n', '\t\tsuper.initWhiteListAdmin();\n', '\t}\n', '\n', '\tconstructor(\n', '\t\tstring memory _name,\n', '\t\tstring memory _symbol,\n', '\t\taddress _proxyRegistryAddress\n', '\t) public {\n', '\t    constructed = true;\n', '\t\tname = _name;\n', '\t\tsymbol = _symbol;\n', '\t\tproxyRegistryAddress = _proxyRegistryAddress;\n', '\t}\n', '\t\n', '\tfunction isBridged(bytes calldata _chainId, address _erc1155Address, bytes calldata _id) external view returns(bool){\n', '\t    return bridged[_chainId][_erc1155Address][_id] > 0;\n', '\t}\n', '\t\n', '\tfunction getBridgedId(bytes calldata _chainId, address _erc1155Address, bytes calldata _id) external view returns(uint256){\n', '\t    return bridged[_chainId][_erc1155Address][_id];\n', '\t}\n', '\t\n', '\tfunction getBridgedSrc(uint256 _id) external view returns(address,bytes memory,bytes memory){\n', '\t    bytes memory _b_id = abi.encodePacked(_id);\n', '\t    return (bridgedMap[_b_id]._address,bridgedMap[_b_id]._b_id,bridgedMap[_b_id]._b_chainId);\n', '\t}\n', '\n', '\tfunction removeWhitelistAdmin(address account) public onlyOwner {\n', '\t\t_removeWhitelistAdmin(account);\n', '\t}\n', '\n', '\tfunction removeMinter(address account) public onlyOwner {\n', '\t\t_removeMinter(account);\n', '\t}\n', '\n', '\tfunction uri(uint256 _id) public view returns (string memory) {\n', '\t\trequire(_exists(_id), "ERC721Tradable#uri: NONEXISTENT_TOKEN");\n', '\t\t//return super.uri(_id);\n', '\t\t\n', '\t\tif(bytes(uris[_id]).length > 0){\n', '\t\t    return uris[_id];\n', '\t\t}\n', '\t\treturn Strings.strConcat(baseMetadataURI, Strings.uint2str(_id));\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the total quantity for a token ID\n', '\t * @param _id uint256 ID of the token to query\n', '\t * @return amount of token in existence\n', '\t */\n', '\tfunction totalSupply(uint256 _id) public view returns (uint256) {\n', '\t\treturn tokenSupply[_id];\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns the max quantity for a token ID\n', '\t * @param _id uint256 ID of the token to query\n', '\t * @return amount of token in existence\n', '\t */\n', '\tfunction maxSupply(uint256 _id) public view returns (uint256) {\n', '\t\treturn tokenMaxSupply[_id];\n', '\t}\n', '\n', '\t/**\n', "\t * @dev Will update the base URL of token's URI\n", "\t * @param _newBaseMetadataURI New base URL of token's URI\n", '\t */\n', '\tfunction setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyWhitelistAdmin {\n', '\t\t_setBaseMetadataURI(_newBaseMetadataURI);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Creates a new token type and assigns _initialSupply to an address\n', '\t * @param _maxSupply max supply allowed\n', '\t * @param _initialSupply Optional amount to supply the first owner\n', '\t * @param _uri Optional URI for this token type\n', '\t * @param _data Optional data to pass if receiver is contract\n', '\t * @return The newly created token ID\n', '\t */\n', '\tfunction create(\n', '\t    address _owner,\n', '\t\tuint256 _maxSupply,\n', '\t\tuint256 _initialSupply,\n', '\t\tuint256 _amount,\n', '\t\tstring calldata _uri,\n', '\t\tbytes calldata _data,\n', '\t\taddress _srcAddress,\n', '\t\tbytes calldata _srcId,\n', '\t\tbytes calldata _chainId\n', '\t) external onlyWhitelistAdmin returns (uint256 tokenId) {\n', '\t    require(bridged[_chainId][_srcAddress][_srcId] == 0, "Bridged already.");\n', '\t\trequire(_initialSupply <= _maxSupply, "Initial supply cannot be more than max supply");\n', '\t\tuint256 _id = _getNextTokenID();\n', '\t\t_incrementTokenTypeId();\n', '\t\tcreators[_id] = msg.sender;\n', '\n', '\t\tif (bytes(_uri).length > 0) {\n', '\t\t    uris[_id] = _uri;\n', '\t\t\temit URI(_uri, _id);\n', '\t\t}\n', '\t\telse{\n', '\t\t    emit URI(string(abi.encodePacked(baseMetadataURI, _uint2str(_id), ".json")), _id);\n', '\t\t}\n', '\n', '\t\tif (_amount != 0) _mint(_owner, _id, _amount, _data);\n', '\t\tbridged[_chainId][_srcAddress][_srcId] = _id;\n', '\t\tBridgedNft memory _bridged = BridgedNft({\n', '\t        _address : _srcAddress,\n', '\t        _b_id : _srcId,\n', '\t\t    _b_chainId : _chainId\n', '\t    });\n', '\t    bridgedMap[abi.encodePacked(_id)] = _bridged;\n', '\t\treturn _id;\n', '\t}\n', '\t\n', '\tfunction updateUri(uint256 _id, string calldata _uri) external onlyWhitelistAdmin{\n', '\t    if (bytes(_uri).length > 0) {\n', '\t\t    uris[_id] = _uri;\n', '\t\t\temit URI(_uri, _id);\n', '\t\t}\n', '\t\telse{\n', '\t\t    emit URI(string(abi.encodePacked(baseMetadataURI, _uint2str(_id), ".json")), _id);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction burn(address _address, uint256 _id, uint256 _amount) external {\n', '\t    require((msg.sender == _address) || isApprovedForAll(_address, msg.sender), "ERC1155#burn: INVALID_OPERATOR");\n', '\t    require(balances[_address][_id] >= _amount, "Trying to burn more tokens than you own");\n', '\t    _burn(_address, _id, _amount);\n', '\t}\n', '\t\n', '\tfunction updateProxyRegistryAddress(address _proxyRegistryAddress) external onlyWhitelistAdmin{\n', '\t    require(_proxyRegistryAddress != address(0), "No zero address");\n', '\t    proxyRegistryAddress = _proxyRegistryAddress;\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Mints some amount of tokens to an address\n', '\t * @param _id          Token ID to mint\n', '\t * @param _quantity    Amount of tokens to mint\n', '\t * @param _data        Data to pass if receiver is contract\n', '\t */\n', '\tfunction mint(\n', '\t    address _owner,\n', '\t\tuint256 _id,\n', '\t\tuint256 _quantity,\n', '\t\tbytes memory _data\n', '\t) public onlyMinter {\n', '\t\t_mint(_owner, _id, _quantity, _data);\n', '\t\ttokenSupply[_id] = tokenSupply[_id].add(_quantity);\n', '\t}\n', '\n', '\t/**\n', "\t * Override isApprovedForAll to whitelist user's OpenSea proxy accounts to enable gas-free listings.\n", '\t */\n', '\t \n', '\tfunction isApprovedForAll(address _owner, address _operator) public view returns (bool isOperator) {\n', '\t\t// Whitelist OpenSea proxy contract for easy trading.\n', '\t\tProxyRegistry proxyRegistry = ProxyRegistry(proxyRegistryAddress);\n', '\t\tif (address(proxyRegistry.proxies(_owner)) == _operator) {\n', '\t\t\treturn true;\n', '\t\t}\n', '\n', '\t\treturn ERC1155.isApprovedForAll(_owner, _operator);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev Returns whether the specified token exists by checking to see if it has a creator\n', '\t * @param _id uint256 ID of the token to query the existence of\n', '\t * @return bool whether the token exists\n', '\t */\n', '\tfunction _exists(uint256 _id) internal view returns (bool) {\n', '\t\treturn creators[_id] != address(0);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev calculates the next token ID based on value of _currentTokenID\n', '\t * @return uint256 for the next token ID\n', '\t */\n', '\tfunction _getNextTokenID() private view returns (uint256) {\n', '\t\treturn _currentTokenID.add(1);\n', '\t}\n', '\n', '\t/**\n', '\t * @dev increments the value of _currentTokenID\n', '\t */\n', '\tfunction _incrementTokenTypeId() private {\n', '\t\t_currentTokenID++;\n', '\t}\n', '}\n', '\n', '/**\n', ' * @title Unifty\n', ' * Unifty - NFT Tools\n', ' * \n', ' * Rinkeby Opensea: 0xf57b2c51ded3a29e6891aba85459d600256cf317 \n', ' * Mainnet Opensea: 0xa5409ec958c83c3f309868babaca7c86dcb077c1\n', ' */\n', 'contract Uniftyverse is ERC1155Tradable {\n', '    \n', '    string private _contractURI = "https://unifty.io/meta/uniftyverse.json";\n', '    \n', '\tconstructor(address _proxyRegistryAddress) public ERC1155Tradable("Uniftyverse", "UVERSE", _proxyRegistryAddress) {\n', '\t\t_setBaseMetadataURI("https://unifty.io/meta/");\n', '\t}\n', '\n', '\tfunction contractURI() public view returns (string memory) {\n', '\t\treturn _contractURI;\n', '\t}\n', '\t\n', '\tfunction setContractURI(string memory _uri) public onlyWhitelistAdmin{\n', '\t    _contractURI = _uri;\n', '\t}\n', '\t\n', '\tfunction version() external pure returns (uint256) {\n', '\t\treturn 1;\n', '\t}\n', '\t\n', '}']