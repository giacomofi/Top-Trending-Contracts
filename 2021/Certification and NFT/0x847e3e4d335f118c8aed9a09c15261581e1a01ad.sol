['pragma solidity ^0.4.24;\n', '\n', 'import "./Exponential.sol";\n', 'import "./InterestRateModel.sol";\n', 'import "./SafeToken.sol";\n', 'import "./ChainLink.sol";\n', 'import "./AlkemiWETH.sol";\n', '\n', 'contract AlkemiEarnVerified is Exponential, SafeToken {\n', '\n', '    uint internal initialInterestIndex;\n', '    uint internal defaultOriginationFee; \n', '    uint internal defaultCollateralRatio;\n', '    uint internal defaultLiquidationDiscount;\n', '\n', '    uint internal minimumCollateralRatioMantissa;\n', '    uint internal maximumLiquidationDiscountMantissa;\n', '    bool public initializationDone; // To make sure initializer is called only once\n', '\n', '    /**\n', '     * @notice `AlkemiEarnVerified` is the core contract\n', '     * @notice This contract uses Openzeppelin Upgrades plugin to make use of the upgradeability functionality using proxies\n', "     * @notice Hence this contract has an 'initializer' in place of a 'constructor'\n", '     * @notice Make sure to add new global variables only at the bottom of all the existing global variables i.e., line #344\n', '     * @notice Also make sure to do extensive testing while modifying any structs and enums during an upgrade\n', '     */\n', '    function initializer() public {\n', '        if(initializationDone == false) {\n', '            initializationDone = true;\n', '            admin = msg.sender;\n', '            initialInterestIndex = 10 ** 18;\n', '            defaultOriginationFee = (10 ** 15); // default is 0.1%\n', '            defaultCollateralRatio = 125 * (10 ** 16); // default is 125% or 1.25\n', '            defaultLiquidationDiscount = (10 ** 17); // default is 10% or 0.1\n', '            minimumCollateralRatioMantissa = 11 * (10 ** 17); // 1.1\n', '            maximumLiquidationDiscountMantissa = (10 ** 17); // 0.1\n', '            collateralRatio = Exp({mantissa: defaultCollateralRatio});\n', '            originationFee = Exp({mantissa: defaultOriginationFee});\n', '            liquidationDiscount = Exp({mantissa: defaultLiquidationDiscount});\n', '            // oracle must be configured via _setOracle\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Do not pay directly into AlkemiEarnVerified, please use `supply`.\n', '     */\n', '    function() payable public {\n', '        revert();\n', '    }\n', '\n', '    /**\n', '     * @dev pending Administrator for this contract.\n', '     */\n', '    address public pendingAdmin;\n', '\n', '    /**\n', '     * @dev Administrator for this contract. Initially set in constructor, but can\n', '     *      be changed by the admin itself.\n', '     */\n', '    address public admin;\n', '\n', '    /**\n', '     * @dev Managers for this contract with limited permissions. Can\n', '     *      be changed by the admin.\n', '     */\n', '    mapping (address => bool) public managers;\n', '\n', '    /**\n', '     * @dev Account allowed to set oracle prices for this contract. Initially set\n', '     *      in constructor, but can be changed by the admin.\n', '     */\n', '    address public oracle;\n', '\n', '    /**\n', '     * @dev Account allowed to fetch chainlink oracle prices for this contract. Can be changed by the admin.\n', '     */\n', '    ChainLink priceOracle;\n', '\n', '    /**\n', '     * @dev Container for customer balance information written to storage.\n', '     *\n', '     *      struct Balance {\n', "     *        principal = customer total balance with accrued interest after applying the customer's most recent balance-changing action\n", "     *        interestIndex = the total interestIndex as calculated after applying the customer's most recent balance-changing action\n", '     *      }\n', '     */\n', '    struct Balance {\n', '        uint principal;\n', '        uint interestIndex;\n', '    }\n', '\n', '    /**\n', '     * @dev 2-level map: customerAddress -> assetAddress -> balance for supplies\n', '     */\n', '    mapping(address => mapping(address => Balance)) public supplyBalances;\n', '\n', '\n', '    /**\n', '     * @dev 2-level map: customerAddress -> assetAddress -> balance for borrows\n', '     */\n', '    mapping(address => mapping(address => Balance)) public borrowBalances;\n', '\n', '\n', '    /**\n', '     * @dev Container for per-asset balance sheet and interest rate information written to storage, intended to be stored in a map where the asset address is the key\n', '     *\n', '     *      struct Market {\n', '     *         isSupported = Whether this market is supported or not (not to be confused with the list of collateral assets)\n', '     *         blockNumber = when the other values in this struct were calculated\n', '     *         totalSupply = total amount of this asset supplied (in asset wei)\n', '     *         supplyRateMantissa = the per-block interest rate for supplies of asset as of blockNumber, scaled by 10e18\n', '     *         supplyIndex = the interest index for supplies of asset as of blockNumber; initialized in _supportMarket\n', '     *         totalBorrows = total amount of this asset borrowed (in asset wei)\n', '     *         borrowRateMantissa = the per-block interest rate for borrows of asset as of blockNumber, scaled by 10e18\n', '     *         borrowIndex = the interest index for borrows of asset as of blockNumber; initialized in _supportMarket\n', '     *     }\n', '     */\n', '    struct Market {\n', '        bool isSupported;\n', '        uint blockNumber;\n', '        InterestRateModel interestRateModel;\n', '\n', '        uint totalSupply;\n', '        uint supplyRateMantissa;\n', '        uint supplyIndex;\n', '\n', '        uint totalBorrows;\n', '        uint borrowRateMantissa;\n', '        uint borrowIndex;\n', '    }\n', '\n', '    /**\n', '     * @dev wethAddress to hold the WETH token contract address\n', '     * set using setWethAddress function\n', '     */\n', '    address public wethAddress;\n', '\n', '    /**\n', '     * @dev Initiates the contract for supply and withdraw Ether and conversion to WETH\n', '     */\n', '    AlkemiWETH public WETHContract;\n', '\n', '    /**\n', '     * @dev map: assetAddress -> Market\n', '     */\n', '    mapping(address => Market) public markets;\n', '\n', '    /**\n', '     * @dev list: collateralMarkets\n', '     */\n', '    address[] public collateralMarkets;\n', '\n', '    /**\n', '     * @dev The collateral ratio that borrows must maintain (e.g. 2 implies 2:1). This\n', '     *      is initially set in the constructor, but can be changed by the admin.\n', '     */\n', '    Exp public collateralRatio;\n', '\n', '    /**\n', '     * @dev originationFee for new borrows.\n', '     *\n', '     */\n', '    Exp public originationFee;\n', '\n', '    /**\n', '     * @dev liquidationDiscount for collateral when liquidating borrows\n', '     *\n', '     */\n', '    Exp public liquidationDiscount;\n', '\n', '    /**\n', '     * @dev flag for whether or not contract is paused\n', '     *\n', '     */\n', '    bool public paused;\n', '\n', '    /**\n', '     * @dev Mapping to identify the list of KYC Admins\n', '     */\n', '    mapping(address=>bool) private KYCAdmins;\n', '    /**\n', '     * @dev Mapping to identify the list of customers with verified KYC\n', '     */\n', '    mapping(address=>bool) private customersWithKYC;\n', '\n', '    /**\n', '     * @dev Mapping to identify the list of customers with Liquidator roles\n', '     */\n', '    mapping(address=>bool) private liquidators;\n', '\n', '    /**\n', '     * The `SupplyLocalVars` struct is used internally in the `supply` function.\n', '     *\n', '     * To avoid solidity limits on the number of local variables we:\n', '     * 1. Use a struct to hold local computation localResults\n', '     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n', '     *    requires either both to be declared inline or both to be previously declared.\n', '     * 3. Re-use a boolean error-like return variable.\n', '     */\n', '    struct SupplyLocalVars {\n', '        uint startingBalance;\n', '        uint newSupplyIndex;\n', '        uint userSupplyCurrent;\n', '        uint userSupplyUpdated;\n', '        uint newTotalSupply;\n', '        uint currentCash;\n', '        uint updatedCash;\n', '        uint newSupplyRateMantissa;\n', '        uint newBorrowIndex;\n', '        uint newBorrowRateMantissa;\n', '    }\n', '\n', '    /**\n', '     * The `WithdrawLocalVars` struct is used internally in the `withdraw` function.\n', '     *\n', '     * To avoid solidity limits on the number of local variables we:\n', '     * 1. Use a struct to hold local computation localResults\n', '     * 2. Re-use a single variable for Error returns. (This is required with 1 because variable binding to tuple localResults\n', '     *    requires either both to be declared inline or both to be previously declared.\n', '     * 3. Re-use a boolean error-like return variable.\n', '     */\n', '\n', '    struct WithdrawLocalVars {\n', '        uint withdrawAmount;\n', '        uint startingBalance;\n', '        uint newSupplyIndex;\n', '        uint userSupplyCurrent;\n', '        uint userSupplyUpdated;\n', '        uint newTotalSupply;\n', '        uint currentCash;\n', '        uint updatedCash;\n', '        uint newSupplyRateMantissa;\n', '        uint newBorrowIndex;\n', '        uint newBorrowRateMantissa;\n', '        Exp accountLiquidity;\n', '        Exp accountShortfall;\n', '        Exp ethValueOfWithdrawal;\n', '        uint withdrawCapacity;\n', '    }\n', '\n', '    // The `AccountValueLocalVars` struct is used internally in the `CalculateAccountValuesInternal` function.\n', '    struct AccountValueLocalVars {\n', '        address assetAddress;\n', '        uint collateralMarketsLength;\n', '\n', '        uint newSupplyIndex;\n', '        uint userSupplyCurrent;\n', '        Exp supplyTotalValue;\n', '        Exp sumSupplies;\n', '\n', '        uint newBorrowIndex;\n', '        uint userBorrowCurrent;\n', '        Exp borrowTotalValue;\n', '        Exp sumBorrows;\n', '    }\n', '\n', '    // The `PayBorrowLocalVars` struct is used internally in the `repayBorrow` function.\n', '    struct PayBorrowLocalVars {\n', '        uint newBorrowIndex;\n', '        uint userBorrowCurrent;\n', '        uint repayAmount;\n', '\n', '        uint userBorrowUpdated;\n', '        uint newTotalBorrows;\n', '        uint currentCash;\n', '        uint updatedCash;\n', '\n', '        uint newSupplyIndex;\n', '        uint newSupplyRateMantissa;\n', '        uint newBorrowRateMantissa;\n', '\n', '        uint startingBalance;\n', '    }\n', '\n', '    // The `BorrowLocalVars` struct is used internally in the `borrow` function.\n', '    struct BorrowLocalVars {\n', '        uint newBorrowIndex;\n', '        uint userBorrowCurrent;\n', '        uint borrowAmountWithFee;\n', '\n', '        uint userBorrowUpdated;\n', '        uint newTotalBorrows;\n', '        uint currentCash;\n', '        uint updatedCash;\n', '\n', '        uint newSupplyIndex;\n', '        uint newSupplyRateMantissa;\n', '        uint newBorrowRateMantissa;\n', '\n', '        uint startingBalance;\n', '\n', '        Exp accountLiquidity;\n', '        Exp accountShortfall;\n', '        Exp ethValueOfBorrowAmountWithFee;\n', '    }\n', '\n', '    // The `LiquidateLocalVars` struct is used internally in the `liquidateBorrow` function.\n', '    struct LiquidateLocalVars {\n', '        // we need these addresses in the struct for use with `emitLiquidationEvent` to avoid `CompilerError: Stack too deep, try removing local variables.`\n', '        address targetAccount;\n', '        address assetBorrow;\n', '        address liquidator;\n', '        address assetCollateral;\n', '\n', '        // borrow index and supply index are global to the asset, not specific to the user\n', '        uint newBorrowIndex_UnderwaterAsset;\n', '        uint newSupplyIndex_UnderwaterAsset;\n', '        uint newBorrowIndex_CollateralAsset;\n', '        uint newSupplyIndex_CollateralAsset;\n', '\n', "        // the target borrow's full balance with accumulated interest\n", '        uint currentBorrowBalance_TargetUnderwaterAsset;\n', '        // currentBorrowBalance_TargetUnderwaterAsset minus whatever gets repaid as part of the liquidation\n', '        uint updatedBorrowBalance_TargetUnderwaterAsset;\n', '\n', '        uint newTotalBorrows_ProtocolUnderwaterAsset;\n', '\n', '        uint startingBorrowBalance_TargetUnderwaterAsset;\n', '        uint startingSupplyBalance_TargetCollateralAsset;\n', '        uint startingSupplyBalance_LiquidatorCollateralAsset;\n', '\n', '        uint currentSupplyBalance_TargetCollateralAsset;\n', '        uint updatedSupplyBalance_TargetCollateralAsset;\n', '\n', '        // If liquidator already has a balance of collateralAsset, we will accumulate\n', '        // interest on it before transferring seized collateral from the borrower.\n', '        uint currentSupplyBalance_LiquidatorCollateralAsset;\n', "        // This will be the liquidator's accumulated balance of collateral asset before the liquidation (if any)\n", '        // plus the amount seized from the borrower.\n', '        uint updatedSupplyBalance_LiquidatorCollateralAsset;\n', '\n', '        uint newTotalSupply_ProtocolCollateralAsset;\n', '        uint currentCash_ProtocolUnderwaterAsset;\n', '        uint updatedCash_ProtocolUnderwaterAsset;\n', '\n', '        // cash does not change for collateral asset\n', '\n', '        uint newSupplyRateMantissa_ProtocolUnderwaterAsset;\n', '        uint newBorrowRateMantissa_ProtocolUnderwaterAsset;\n', '\n', '        // Why no variables for the interest rates for the collateral asset?\n', "        // We don't need to calculate new rates for the collateral asset since neither cash nor borrows change\n", '\n', '        uint discountedRepayToEvenAmount;\n', '\n', '        //[supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow) (discountedBorrowDenominatedCollateral)\n', '        uint discountedBorrowDenominatedCollateral;\n', '\n', '        uint maxCloseableBorrowAmount_TargetUnderwaterAsset;\n', '        uint closeBorrowAmount_TargetUnderwaterAsset;\n', '        uint seizeSupplyAmount_TargetCollateralAsset;\n', '\n', '        Exp collateralPrice;\n', '        Exp underwaterAssetPrice;\n', '\n', '        uint reimburseAmount;\n', '    }\n', '\n', '    /**\n', '     * @dev 2-level map: customerAddress -> assetAddress -> originationFeeBalance for borrows\n', '     */\n', '    mapping(address => mapping(address => uint)) public originationFeeBalance;\n', '\n', '    /**\n', '     * @dev Event emitted on successful addition of Weth Address\n', '     */\n', '    event WETHAddressSet(address wethAddress);\n', '\n', '    /**\n', '     * @dev Events to notify the frontend of all the functions below\n', '     */\n', '    event LiquidatorAdded(address Liquidator);\n', '    event LiquidatorRemoved(address Liquidator);\n', '\n', '    /**\n', '     * @dev emitted when a supply is received\n', '     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n', '     */\n', '    event SupplyReceived(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n', '\n', '    /**\n', '     * @dev emitted when a origination fee supply is received as admin\n', '     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n', '     */\n', '    event SupplyOrgFeeAsAdmin(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n', '    /**\n', '     * @dev emitted when a supply is withdrawn\n', '     *      Note: startingBalance - amount - startingBalance = interest accumulated since last change\n', '     */\n', '    event SupplyWithdrawn(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n', '\n', '    /**\n', '     * @dev emitted when a new borrow is taken\n', '     *      Note: newBalance - borrowAmountWithFee - startingBalance = interest accumulated since last change\n', '     */\n', '    event BorrowTaken(address account, address asset, uint amount, uint startingBalance, uint borrowAmountWithFee, uint newBalance);\n', '\n', '    /**\n', '     * @dev emitted when a borrow is repaid\n', '     *      Note: newBalance - amount - startingBalance = interest accumulated since last change\n', '     */\n', '    event BorrowRepaid(address account, address asset, uint amount, uint startingBalance, uint newBalance);\n', '\n', '    /**\n', '     * @dev emitted when a borrow is liquidated\n', '     *      targetAccount = user whose borrow was liquidated\n', '     *      assetBorrow = asset borrowed\n', '     *      borrowBalanceBefore = borrowBalance as most recently stored before the liquidation\n', '     *      borrowBalanceAccumulated = borroBalanceBefore + accumulated interest as of immediately prior to the liquidation\n', '     *      amountRepaid = amount of borrow repaid\n', '     *      liquidator = account requesting the liquidation\n', '     *      assetCollateral = asset taken from targetUser and given to liquidator in exchange for liquidated loan\n', '     *      borrowBalanceAfter = new stored borrow balance (should equal borrowBalanceAccumulated - amountRepaid)\n', '     *      collateralBalanceBefore = collateral balance as most recently stored before the liquidation\n', '     *      collateralBalanceAccumulated = collateralBalanceBefore + accumulated interest as of immediately prior to the liquidation\n', '     *      amountSeized = amount of collateral seized by liquidator\n', '     *      collateralBalanceAfter = new stored collateral balance (should equal collateralBalanceAccumulated - amountSeized)\n', '     */\n', '    event BorrowLiquidated(address targetAccount,\n', '        address assetBorrow,\n', '        uint borrowBalanceBefore,\n', '        uint borrowBalanceAccumulated,\n', '        uint amountRepaid,\n', '        uint borrowBalanceAfter,\n', '        address liquidator,\n', '        address assetCollateral,\n', '        uint collateralBalanceBefore,\n', '        uint collateralBalanceAccumulated,\n', '        uint amountSeized,\n', '        uint collateralBalanceAfter);\n', '\n', '    /**\n', '     * @dev emitted when pendingAdmin is changed\n', '     */\n', '    event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n', '\n', '    /**\n', '     * @dev emitted when pendingAdmin is accepted, which means admin is updated\n', '     */\n', '    event NewAdmin(address oldAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev newOracle - address of new oracle\n', '     */\n', '    event NewOracle(address oldOracle, address newOracle);\n', '\n', '    /**\n', '     * @dev emitted when new market is supported by admin\n', '     */\n', '    event SupportedMarket(address asset, address interestRateModel);\n', '\n', '    /**\n', '     * @dev emitted when risk parameters are changed by admin\n', '     */\n', '    event NewRiskParameters(uint oldCollateralRatioMantissa, uint newCollateralRatioMantissa, uint oldLiquidationDiscountMantissa, uint newLiquidationDiscountMantissa, uint NewMinimumCollateralRatioMantissa, uint newMaximumLiquidationDiscountMantissa);\n', '\n', '    /**\n', '     * @dev emitted when origination fee is changed by admin\n', '     */\n', '    event NewOriginationFee(uint oldOriginationFeeMantissa, uint newOriginationFeeMantissa);\n', '\n', '    /**\n', '     * @dev emitted when market has new interest rate model set\n', '     */\n', '    event SetMarketInterestRateModel(address asset, address interestRateModel);\n', '\n', '    /**\n', '     * @dev emitted when admin withdraws equity\n', '     * Note that `equityAvailableBefore` indicates equity before `amount` was removed.\n', '     */\n', '    event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner);\n', '\n', '    /**\n', '     * @dev emitted when a supported market is suspended by admin\n', '     */\n', '    event SuspendedMarket(address asset);\n', '\n', '    /**\n', '     * @dev emitted when admin either pauses or resumes the contract; newState is the resulting state\n', '     */\n', '    event SetPaused(bool newState);\n', '\n', '    /**\n', '     * @dev KYC Integration\n', '     */\n', '\n', '    /**\n', '     * @dev Events to notify the frontend of all the functions below\n', '     */\n', '    event KYCAdminAdded(address KYCAdmin);\n', '    event KYCAdminRemoved(address KYCAdmin);\n', '    event KYCCustomerAdded(address KYCCustomer);\n', '    event KYCCustomerRemoved(address KYCCustomer);\n', '\n', '    /**\n', '     * @dev Modifier to check if the caller of the function is a manager or owner\n', '     */\n', '    modifier onlyAdminOrManager {\n', '        // Check caller = KYCadmin\n', '        require(msg.sender == admin || managers[msg.sender],"Only owner or manager can perform operation");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to emit fail event to frontend\n', '     */\n', '    function emitError(Error error, FailureInfo failure) private returns(uint) {\n', '        return fail(error, failure);\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to check if the caller of the function is a KYC Admin\n', '     */\n', '    modifier isKYCAdmin {\n', '        // Check caller = KYCadmin\n', '        if (!KYCAdmins[msg.sender]) {\n', '            emitError(Error.KYC_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_CHECK_FAILED);\n', '        } else {\n', '            require(KYCAdmins[msg.sender],"Operation can only be performed by a KYC Admin");\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier to check if the caller of the function is KYC verified\n', '     */\n', '    modifier isKYCVerifiedCustomer {\n', '        // Check caller = KYCVerifiedCustomer\n', '        if (!customersWithKYC[msg.sender]) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            emitError(Error.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED, FailureInfo.KYC_CUSTOMER_VERIFICATION_CHECK_FAILED);\n', '        } else {\n', '            require(customersWithKYC[msg.sender],"Customer is not KYC Verified");\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function for use by the admin of the contract to add KYC Admins\n', '     */\n', '    function addKYCAdmin(address KYCAdmin) public returns(uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n', '        }\n', '        KYCAdmins[KYCAdmin] = true;\n', '        emit KYCAdminAdded(KYCAdmin);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @dev Function for use by the admin of the contract to remove KYC Admins\n', '     */\n', '    function removeKYCAdmin(address KYCAdmin) public returns(uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.KYC_ADMIN_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n', '        }\n', '        KYCAdmins[KYCAdmin] = false;\n', '        emit KYCAdminRemoved(KYCAdmin);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @dev Function for use by the KYC admins to add KYC Customers\n', '     */\n', '    function addCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n', '        customersWithKYC[customer] = true;\n', '        emit KYCCustomerAdded(customer);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @dev Function for use by the KYC admins to remove KYC Customers\n', '     */\n', '    function removeCustomerKYC(address customer) public isKYCAdmin returns(uint) {\n', '        customersWithKYC[customer] = false;\n', '        emit KYCCustomerRemoved(customer);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to fetch KYC verification status of a customer\n', '     */\n', '    function verifyKYC(address customer) public view returns(bool) {\n', '        return customersWithKYC[customer];\n', '    }\n', '\n', '    /**\n', '     * @dev Function to fetch KYC Admin status of an admin\n', '     */\n', '    function checkKYCAdmin(address _KYCAdmin) public view returns(bool) {\n', '        return KYCAdmins[_KYCAdmin];\n', '    }\n', '\n', '    /**\n', '     * @dev Liquidator Integration\n', '     */\n', '\n', '    /**\n', '     * @dev Modifier to check if the caller of the function is a Liquidator\n', '     */\n', '    modifier isLiquidator {\n', '        // Check caller = Liquidator\n', '        if (!liquidators[msg.sender]) {\n', '            emitError(Error.LIQUIDATOR_CHECK_FAILED, FailureInfo.LIQUIDATOR_CHECK_FAILED);\n', '        } else {\n', '            require(liquidators[msg.sender],"Customer is not a Liquidator");\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function for use by the admin of the contract to add Liquidators\n', '     */\n', '    function addLiquidator(address liquidator) public returns(uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n', '        }\n', '        liquidators[liquidator] = true;\n', '        emit LiquidatorAdded(liquidator);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @dev Function for use by the admin of the contract to remove Liquidators\n', '     */\n', '    function removeLiquidator(address liquidator) public returns(uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED, FailureInfo.LIQUIDATOR_ADD_OR_DELETE_ADMIN_CHECK_FAILED);\n', '        }\n', '        liquidators[liquidator] = false;\n', '        emit LiquidatorRemoved(liquidator);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to fetch Liquidator status of a customer\n', '     */\n', '    function verifyLiquidator(address liquidator) public view returns(bool) {\n', '        return liquidators[liquidator];\n', '    }\n', '\n', '    /**\n', '     * @dev Simple function to calculate min between two numbers.\n', '     */\n', '    function min(uint a, uint b) pure internal returns (uint) {\n', '        if (a < b) {\n', '            return a;\n', '        } else {\n', '            return b;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function to simply retrieve block number\n', '     *      This exists mainly for inheriting test contracts to stub this result.\n', '     */\n', '    function getBlockNumber() internal view returns (uint) {\n', '        return block.number;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds a given asset to the list of collateral markets. This operation is impossible to reverse.\n', '     *      Note: this will not add the asset if it already exists.\n', '     */\n', '    function addCollateralMarket(address asset) internal {\n', '        for (uint i = 0; i < collateralMarkets.length; i++) {\n', '            if (collateralMarkets[i] == asset) {\n', '                return;\n', '            }\n', '        }\n', '\n', '        collateralMarkets.push(asset);\n', '    }\n', '\n', '    /**\n', '     * @notice return the number of elements in `collateralMarkets`\n', '     * @dev you can then externally call `collateralMarkets(uint)` to pull each market address\n', '     * @return the length of `collateralMarkets`\n', '     */\n', '    function getCollateralMarketsLength() public view returns (uint) {\n', '        return collateralMarkets.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates a new supply index based on the prevailing interest rates applied over time\n', '     *      This is defined as `we multiply the most recent supply index by (1 + blocks times rate)`\n', '     */\n', '    function calculateInterestIndex(uint startingInterestIndex, uint interestRateMantissa, uint blockStart, uint blockEnd) pure internal returns (Error, uint) {\n', '\n', '        // Get the block delta\n', '        (Error err0, uint blockDelta) = sub(blockEnd, blockStart);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        // Scale the interest rate times number of blocks\n', '        // Note: Doing Exp construction inline to avoid `CompilerError: Stack too deep, try removing local variables.`\n', '        (Error err1, Exp memory blocksTimesRate) = mulScalar(Exp({mantissa: interestRateMantissa}), blockDelta);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (err1, 0);\n', '        }\n', '\n', '        // Add one to that result (which is really Exp({mantissa: expScale}) which equals 1.0)\n', '        (Error err2, Exp memory onePlusBlocksTimesRate) = addExp(blocksTimesRate, Exp({mantissa: mantissaOne}));\n', '        if (err2 != Error.NO_ERROR) {\n', '            return (err2, 0);\n', '        }\n', '\n', '        // Then scale that accumulated interest by the old interest index to get the new interest index\n', '        (Error err3, Exp memory newInterestIndexExp) = mulScalar(onePlusBlocksTimesRate, startingInterestIndex);\n', '        if (err3 != Error.NO_ERROR) {\n', '            return (err3, 0);\n', '        }\n', '\n', '        // Finally, truncate the interest index. This works only if interest index starts large enough\n', '        // that is can be accurately represented with a whole number.\n', '        return (Error.NO_ERROR, truncate(newInterestIndexExp));\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates a new balance based on a previous balance and a pair of interest indices\n', "     *      This is defined as: `The user's last balance checkpoint is multiplied by the currentSupplyIndex\n", "     *      value and divided by the user's checkpoint index value`\n", '     *\n', '     *      TODO: Is there a way to handle this that is less likely to overflow?\n', '     */\n', '    function calculateBalance(uint startingBalance, uint interestIndexStart, uint interestIndexEnd) pure internal returns (Error, uint) {\n', '        if (startingBalance == 0) {\n', "            // We are accumulating interest on any previous balance; if there's no previous balance, then there is\n", '            // nothing to accumulate.\n', '            return (Error.NO_ERROR, 0);\n', '        }\n', '        (Error err0, uint balanceTimesIndex) = mul(startingBalance, interestIndexEnd);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        return div(balanceTimesIndex, interestIndexStart);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the price for the amount specified of the given asset.\n', '     */\n', '    function getPriceForAssetAmount(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n', '        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, Exp({mantissa: 0}));\n', '        }\n', '\n', '        if (isZeroExp(assetPrice)) {\n', '            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n', '        }\n', '\n', '        return mulScalar(assetPrice, assetAmount); // assetAmountWei * oraclePrice = assetValueInEth\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the price for the amount specified of the given asset multiplied by the current\n', '     *      collateral ratio (i.e., assetAmountWei * collateralRatio * oraclePrice = totalValueInEth).\n', '     *      We will group this as `(oraclePrice * collateralRatio) * assetAmountWei`\n', '     */\n', '    function getPriceForAssetAmountMulCollatRatio(address asset, uint assetAmount) internal view returns (Error, Exp memory)  {\n', '        Error err;\n', '        Exp memory assetPrice;\n', '        Exp memory scaledPrice;\n', '        (err, assetPrice) = fetchAssetPrice(asset);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, Exp({mantissa: 0}));\n', '        }\n', '\n', '        if (isZeroExp(assetPrice)) {\n', '            return (Error.MISSING_ASSET_PRICE, Exp({mantissa: 0}));\n', '        }\n', '\n', '        // Now, multiply the assetValue by the collateral ratio\n', '        (err, scaledPrice) = mulExp(collateralRatio, assetPrice);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, Exp({mantissa: 0}));\n', '        }\n', '\n', '        // Get the price for the given asset amount\n', '        return mulScalar(scaledPrice, assetAmount);\n', '    }\n', '\n', '    /**\n', '     * @dev Calculates the origination fee added to a given borrowAmount\n', '     *      This is simply `(1 + originationFee) * borrowAmount`\n', '     *\n', '     *      TODO: Track at what magnitude this fee rounds down to zero?\n', '     */\n', '    function calculateBorrowAmountWithFee(uint borrowAmount) view internal returns (Error, uint) {\n', '        // When origination fee is zero, the amount with fee is simply equal to the amount\n', '        if (isZeroExp(originationFee)) {\n', '            return (Error.NO_ERROR, borrowAmount);\n', '        }\n', '\n', '        (Error err0, Exp memory originationFeeFactor) = addExp(originationFee, Exp({mantissa: mantissaOne}));\n', '        if (err0 != Error.NO_ERROR) {\n', '            return (err0, 0);\n', '        }\n', '\n', '        (Error err1, Exp memory borrowAmountWithFee) = mulScalar(originationFeeFactor, borrowAmount);\n', '        if (err1 != Error.NO_ERROR) {\n', '            return (err1, 0);\n', '        }\n', '\n', '        return (Error.NO_ERROR, truncate(borrowAmountWithFee));\n', '    }\n', '\n', '    /**\n', '     * @dev fetches the price of asset from the PriceOracle and converts it to Exp\n', '     * @param asset asset whose price should be fetched\n', '     */\n', '    function fetchAssetPrice(address asset) internal view returns (Error, Exp memory) {\n', '        if (oracle == address(0)) {\n', '            return (Error.ZERO_ORACLE_ADDRESS, Exp({mantissa: 0}));\n', '        }\n', '\n', '        uint priceMantissa = priceOracle.getAssetPrice(asset);\n', '\n', '        return (Error.NO_ERROR, Exp({mantissa: priceMantissa}));\n', '    }\n', '\n', '    /**\n', '     * @notice Reads scaled price of specified asset from the price oracle\n', '     * @dev Reads scaled price of specified asset from the price oracle.\n', '     *      The plural name is to match a previous storage mapping that this function replaced.\n', '     * @param asset Asset whose price should be retrieved\n', '     * @return 0 on an error or missing price, the price scaled by 1e18 otherwise\n', '     */\n', '    function assetPrices(address asset) public view returns (uint) {\n', '        (Error err, Exp memory result) = fetchAssetPrice(asset);\n', '        if (err != Error.NO_ERROR) {\n', '            return 0;\n', '        }\n', '        return result.mantissa;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the amount of the specified asset given the specified Eth value\n', '     *      ethValue / oraclePrice = assetAmountWei\n', "     *      If there's no oraclePrice, this returns (Error.DIVISION_BY_ZERO, 0)\n", '     */\n', '    function getAssetAmountForValue(address asset, Exp ethValue) internal view returns (Error, uint) {\n', '        Error err;\n', '        Exp memory assetPrice;\n', '        Exp memory assetAmount;\n', '\n', '        (err, assetPrice) = fetchAssetPrice(asset);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, assetAmount) = divExp(ethValue, assetPrice);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (Error.NO_ERROR, truncate(assetAmount));\n', '    }\n', '\n', '    /**\n', '     * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n', '     * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n', '     * @param newPendingAdmin New pending admin.\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     *\n', '     * TODO: Should we add a second arg to verify, like a checksum of `newAdmin` address?\n', '     */\n', '    function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n', '        }\n', '\n', '        // save current value, if any, for inclusion in log\n', '        address oldPendingAdmin = pendingAdmin;\n', '        // Store pendingAdmin = newPendingAdmin\n', '        pendingAdmin = newPendingAdmin;\n', '\n', '        emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n', '     * @dev Admin function for pending admin to accept role and update admin\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _acceptAdmin() public returns (uint) {\n', '        // Check caller = pendingAdmin\n', "        // msg.sender can't be zero\n", '        if (msg.sender != pendingAdmin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n', '        }\n', '\n', '        // Save current value for inclusion in log\n', '        address oldAdmin = admin;\n', '        // Store admin = pendingAdmin\n', '        admin = pendingAdmin;\n', '        // Clear the pending value\n', '        pendingAdmin = 0;\n', '\n', '        emit NewAdmin(oldAdmin, msg.sender);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Set new oracle, who can set asset prices\n', '     * @dev Admin function to change oracle\n', '     * @param newOracle New oracle address\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _setOracle(address newOracle) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORACLE_OWNER_CHECK);\n', '        }\n', '\n', '        // Verify contract at newOracle address supports assetPrices call.\n', "        // This will revert if it doesn't.\n", '        // ChainLink priceOracleTemp = ChainLink(newOracle);\n', '        // priceOracleTemp.getAssetPrice(address(0));\n', '\n', '        address oldOracle = oracle;\n', '\n', '        // Store oracle = newOracle\n', '        oracle = newOracle;\n', '        // Initialize the Chainlink contract in priceOracle\n', '        priceOracle = ChainLink(newOracle);\n', '\n', '        emit NewOracle(oldOracle, newOracle);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice set `paused` to the specified state\n', '     * @dev Admin function to pause or resume the market\n', '     * @param requestedState value to assign to `paused`\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _setPaused(bool requestedState) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSED_OWNER_CHECK);\n', '        }\n', '\n', '        paused = requestedState;\n', '        emit SetPaused(requestedState);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice returns the liquidity for given account.\n', '     *         a positive result indicates ability to borrow, whereas\n', '     *         a negative result indicates a shortfall which may be liquidated\n', '     * @dev returns account liquidity in terms of eth-wei value, scaled by 1e18\n', '     *      note: this includes interest trued up on all balances\n', '     * @param account the account to examine\n', '     * @return signed integer in terms of eth-wei (negative indicates a shortfall)\n', '     */\n', '    function getAccountLiquidity(address account) public view returns (int) {\n', '        (Error err, Exp memory accountLiquidity, Exp memory accountShortfall) = calculateAccountLiquidity(account);\n', '        require(err == Error.NO_ERROR);\n', '\n', '        if (isZeroExp(accountLiquidity)) {\n', '            return -1 * int(truncate(accountShortfall));\n', '        } else {\n', '            return int(truncate(accountLiquidity));\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice return supply balance with any accumulated interest for `asset` belonging to `account`\n', '     * @dev returns supply balance with any accumulated interest for `asset` belonging to `account`\n', '     * @param account the account to examine\n', '     * @param asset the market asset whose supply balance belonging to `account` should be checked\n', '     * @return uint supply balance on success, throws on failed assertion otherwise\n', '     */\n', '    function getSupplyBalance(address account, address asset) view public returns (uint) {\n', '        Error err;\n', '        uint newSupplyIndex;\n', '        uint userSupplyCurrent;\n', '\n', '        Market storage market = markets[asset];\n', '        Balance storage supplyBalance = supplyBalances[account][asset];\n', '\n', "        // Calculate the newSupplyIndex, needed to calculate user's supplyCurrent\n", '        (err, newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n', '        require(err == Error.NO_ERROR);\n', '\n', '        // Use newSupplyIndex and stored principal to calculate the accumulated balance\n', '        (err, userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, newSupplyIndex);\n', '        require(err == Error.NO_ERROR);\n', '\n', '        return userSupplyCurrent;\n', '    }\n', '\n', '    /**\n', '     * @notice return borrow balance with any accumulated interest for `asset` belonging to `account`\n', '     * @dev returns borrow balance with any accumulated interest for `asset` belonging to `account`\n', '     * @param account the account to examine\n', '     * @param asset the market asset whose borrow balance belonging to `account` should be checked\n', '     * @return uint borrow balance on success, throws on failed assertion otherwise\n', '     */\n', '    function getBorrowBalance(address account, address asset) view public returns (uint) {\n', '        Error err;\n', '        uint newBorrowIndex;\n', '        uint userBorrowCurrent;\n', '\n', '        Market storage market = markets[asset];\n', '        Balance storage borrowBalance = borrowBalances[account][asset];\n', '\n', "        // Calculate the newBorrowIndex, needed to calculate user's borrowCurrent\n", '        (err, newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n', '        require(err == Error.NO_ERROR);\n', '\n', '        // Use newBorrowIndex and stored principal to calculate the accumulated balance\n', '        (err, userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, newBorrowIndex);\n', '        require(err == Error.NO_ERROR);\n', '\n', '        return userBorrowCurrent;\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Supports a given market (asset) for use\n', '     * @dev Admin function to add support for a market\n', '     * @param asset Asset to support; MUST already have a non-zero price set\n', '     * @param interestRateModel InterestRateModel to use for the asset\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _supportMarket(address asset, InterestRateModel interestRateModel) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n', '        }\n', '\n', '        (Error err, Exp memory assetPrice) = fetchAssetPrice(asset);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.SUPPORT_MARKET_FETCH_PRICE_FAILED);\n', '        }\n', '\n', '        if (isZeroExp(assetPrice)) {\n', '            return fail(Error.ASSET_NOT_PRICED, FailureInfo.SUPPORT_MARKET_PRICE_CHECK);\n', '        }\n', '\n', '        // Set the interest rate model to `modelAddress`\n', '        markets[asset].interestRateModel = interestRateModel;\n', '\n', '        // Append asset to collateralAssets if not set\n', '        addCollateralMarket(asset);\n', '\n', '        // Set market isSupported to true\n', '        markets[asset].isSupported = true;\n', '\n', '        // Default supply and borrow index to 1e18\n', '        if (markets[asset].supplyIndex == 0) {\n', '            markets[asset].supplyIndex = initialInterestIndex;\n', '        }\n', '\n', '        if (markets[asset].borrowIndex == 0) {\n', '            markets[asset].borrowIndex = initialInterestIndex;\n', '        }\n', '\n', '        emit SupportedMarket(asset, interestRateModel);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Suspends a given *supported* market (asset) from use.\n', '     *         Assets in this state do count for collateral, but users may only withdraw, payBorrow,\n', '     *         and liquidate the asset. The liquidate function no longer checks collateralization.\n', '     * @dev Admin function to suspend a market\n', '     * @param asset Asset to suspend\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _suspendMarket(address asset) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SUSPEND_MARKET_OWNER_CHECK);\n', '        }\n', '\n', "        // If the market is not configured at all, we don't want to add any configuration for it.\n", '        // If we find !markets[asset].isSupported then either the market is not configured at all, or it\n', '        // has already been marked as unsupported. We can just return without doing anything.\n', '        // Caller is responsible for knowing the difference between not-configured and already unsupported.\n', '        if (!markets[asset].isSupported) {\n', '            return uint(Error.NO_ERROR);\n', '        }\n', '\n', '        // If we get here, we know market is configured and is supported, so set isSupported to false\n', '        markets[asset].isSupported = false;\n', '\n', '        emit SuspendedMarket(asset);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the risk parameters: collateral ratio and liquidation discount\n', '     * @dev Owner function to set the risk parameters\n', '     * @param collateralRatioMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be >= 1.1\n', '     * @param liquidationDiscountMantissa rational liquidation discount, scaled by 1e18. The de-scaled value must be <= 0.1 and must be less than (descaled collateral ratio minus 1)\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _setRiskParameters(uint collateralRatioMantissa, uint liquidationDiscountMantissa, uint _minimumCollateralRatioMantissa, uint _maximumLiquidationDiscountMantissa) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_RISK_PARAMETERS_OWNER_CHECK);\n', '        }\n', '\n', '        minimumCollateralRatioMantissa =  _minimumCollateralRatioMantissa;\n', '        maximumLiquidationDiscountMantissa =  _maximumLiquidationDiscountMantissa;\n', '        Exp memory newCollateralRatio = Exp({mantissa: collateralRatioMantissa});\n', '        Exp memory newLiquidationDiscount = Exp({mantissa: liquidationDiscountMantissa});\n', '        Exp memory minimumCollateralRatio = Exp({mantissa: minimumCollateralRatioMantissa});\n', '        Exp memory maximumLiquidationDiscount = Exp({mantissa: maximumLiquidationDiscountMantissa});\n', '\n', '        Error err;\n', '        Exp memory newLiquidationDiscountPlusOne;\n', '\n', '        // Make sure new collateral ratio value is not below minimum value\n', '        if (lessThanExp(newCollateralRatio, minimumCollateralRatio)) {\n', '            return fail(Error.INVALID_COLLATERAL_RATIO, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n', '        }\n', '\n', '        // Make sure new liquidation discount does not exceed the maximum value, but reverse operands so we can use the\n', '        // existing `lessThanExp` function rather than adding a `greaterThan` function to Exponential.\n', '        if (lessThanExp(maximumLiquidationDiscount, newLiquidationDiscount)) {\n', '            return fail(Error.INVALID_LIQUIDATION_DISCOUNT, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n', '        }\n', '\n', '        // C = L+1 is not allowed because it would cause division by zero error in `calculateDiscountedRepayToEvenAmount`\n', '        // C < L+1 is not allowed because it would cause integer underflow error in `calculateDiscountedRepayToEvenAmount`\n', '        (err, newLiquidationDiscountPlusOne) = addExp(newLiquidationDiscount, Exp({mantissa: mantissaOne}));\n', '        assert(err == Error.NO_ERROR); // We already validated that newLiquidationDiscount does not approach overflow size\n', '\n', '        if (lessThanOrEqualExp(newCollateralRatio, newLiquidationDiscountPlusOne)) {\n', '            return fail(Error.INVALID_COMBINED_RISK_PARAMETERS, FailureInfo.SET_RISK_PARAMETERS_VALIDATION);\n', '        }\n', '\n', '        // Save current values so we can emit them in log.\n', '        Exp memory oldCollateralRatio = collateralRatio;\n', '        Exp memory oldLiquidationDiscount = liquidationDiscount;\n', '\n', '        // Store new values\n', '        collateralRatio = newCollateralRatio;\n', '        liquidationDiscount = newLiquidationDiscount;\n', '\n', '        emit NewRiskParameters(oldCollateralRatio.mantissa, collateralRatioMantissa, oldLiquidationDiscount.mantissa, liquidationDiscountMantissa, minimumCollateralRatioMantissa, maximumLiquidationDiscountMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the origination fee (which is a multiplier on new borrows)\n', '     * @dev Owner function to set the origination fee\n', '     * @param originationFeeMantissa rational collateral ratio, scaled by 1e18. The de-scaled value must be >= 1.1\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _setOriginationFee(uint originationFeeMantissa) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_ORIGINATION_FEE_OWNER_CHECK);\n', '        }\n', '\n', '        // Save current value so we can emit it in log.\n', '        Exp memory oldOriginationFee = originationFee;\n', '\n', '        originationFee = Exp({mantissa: originationFeeMantissa});\n', '\n', '        emit NewOriginationFee(oldOriginationFee.mantissa, originationFeeMantissa);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice Sets the interest rate model for a given market\n', '     * @dev Admin function to set interest rate model\n', '     * @param asset Asset to support\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _setMarketInterestRateModel(address asset, InterestRateModel interestRateModel) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SET_MARKET_INTEREST_RATE_MODEL_OWNER_CHECK);\n', '        }\n', '\n', '        // Set the interest rate model to `modelAddress`\n', '        markets[asset].interestRateModel = interestRateModel;\n', '\n', '        emit SetMarketInterestRateModel(asset, interestRateModel);\n', '\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice withdraws `amount` of `asset` from equity for asset, as long as `amount` <= equity. Equity= cash - (supply + borrows)\n', '     * @dev withdraws `amount` of `asset` from equity  for asset, enforcing amount <= cash - (supply + borrows)\n', '     * @param asset asset whose equity should be withdrawn\n', '     * @param amount amount of equity to withdraw; must not exceed equity available\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function _withdrawEquity(address asset, uint amount) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.EQUITY_WITHDRAWAL_MODEL_OWNER_CHECK);\n', '        }\n', '\n', '        // Check that amount is less than cash (from ERC-20 of self) plus borrows minus supply.\n', '        uint cash = getCash(asset);\n', '        (Error err0, uint equity) = addThenSub(cash, markets[asset].totalBorrows, markets[asset].totalSupply);\n', '        if (err0 != Error.NO_ERROR) {\n', '            return fail(err0, FailureInfo.EQUITY_WITHDRAWAL_CALCULATE_EQUITY);\n', '        }\n', '\n', '        if (amount > equity) {\n', '            return fail(Error.EQUITY_INSUFFICIENT_BALANCE, FailureInfo.EQUITY_WITHDRAWAL_AMOUNT_VALIDATION);\n', '        }\n', '\n', '        /////////////////////////\n', '        // EFFECTS & INTERACTIONS\n', '        // (No safe failures beyond this point)\n', '\n', '        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n', '            // We ERC-20 transfer the asset out of the protocol to the admin\n', '            Error err2 = doTransferOut(asset, admin, amount);\n', '            if (err2 != Error.NO_ERROR) {\n', "                // This is safe since it's our first interaction and it didn't do anything if it failed\n", '                return fail(err2, FailureInfo.EQUITY_WITHDRAWAL_TRANSFER_OUT_FAILED);\n', '            }\n', '        } else {\n', '            uint withdrawalerr = withdrawEther(admin,amount); // send Ether to user\n', '            if(withdrawalerr != 0){\n', '                return uint(withdrawalerr); // success\n', '            }\n', '        }\n', '\n', '        //event EquityWithdrawn(address asset, uint equityAvailableBefore, uint amount, address owner)\n', '        emit EquityWithdrawn(asset, equity, amount, admin);\n', '\n', '        return uint(Error.NO_ERROR); // success\n', '    }\n', '\n', '    /**\n', '     * @dev Set WETH token contract address\n', '     * @param wethContractAddress Enter the WETH token address\n', '     */\n', '    function setWethAddress(address wethContractAddress) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED, FailureInfo.SET_WETH_ADDRESS_ADMIN_CHECK_FAILED);\n', '        }\n', '        wethAddress = wethContractAddress;\n', '        WETHContract = AlkemiWETH(wethAddress);\n', '        emit WETHAddressSet(wethContractAddress);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @dev Convert Ether supplied by user into WETH tokens and then supply corresponding WETH to user\n', '     * @return errors if any\n', '     * @param etherAmount Amount of ether to be converted to WETH\n', '     * @param user User account address\n', '     */\n', '    function supplyEther(address user, uint etherAmount) internal returns (uint) {\n', '        user; // To silence the warning of unused local variable\n', '        if(wethAddress != address(0)){\n', '            WETHContract.deposit.value(etherAmount)();\n', '            return uint(Error.NO_ERROR);\n', '        }\n', '        else {\n', '            return uint(Error.WETH_ADDRESS_NOT_SET_ERROR);\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @dev Revert Ether paid by user back to user's account in case transaction fails due to some other reason\n", '     * @param etherAmount Amount of ether to be sent back to user\n', '     * @param user User account address\n', '     */\n', '    function revertEtherToUser(address user, uint etherAmount) internal {\n', '        if(etherAmount > 0){\n', '            user.transfer(etherAmount);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice supply `amount` of `asset` (which must be supported) to `msg.sender` in the protocol\n', "     * @dev add amount of supported asset to msg.sender's account\n", '     * @param asset The market asset to supply\n', '     * @param amount The amount to supply\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function supply(address asset, uint amount) public payable isKYCVerifiedCustomer returns (uint) {\n', '        if (paused) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(Error.CONTRACT_PAUSED, FailureInfo.SUPPLY_CONTRACT_PAUSED);\n', '        }\n', '\n', '        Market storage market = markets[asset];\n', '        Balance storage balance = supplyBalances[msg.sender][asset];\n', '\n', '        SupplyLocalVars memory localResults; // Holds all our uint calculation results\n', '        Error err; // Re-used for every function call that includes an Error in its return value(s).\n', '        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n', '\n', '        // Fail if market not supported\n', '        if (!market.isSupported) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.SUPPLY_MARKET_NOT_SUPPORTED);\n', '        }\n', '        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n', '            // Fail gracefully if asset is not approved or has insufficient balance\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            err = checkTransferIn(asset, msg.sender, amount);\n', '            if (err != Error.NO_ERROR) {\n', '                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_NOT_POSSIBLE);\n', '            }\n', '        }\n', '\n', "        // We calculate the newSupplyIndex, user's supplyCurrent and supplyUpdated for the asset\n", '        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.SUPPLY_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n', '        }\n', '\n', '        (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, localResults.newSupplyIndex);\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.SUPPLY_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', '        (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, amount);\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', "        // We calculate the protocol's totalSupply by subtracting the user's prior checkpointed balance, adding user's updated supply\n", '        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, balance.principal);\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n', '        }\n', '\n', '        // We need to calculate what the updated cash will be after we transfer in from user\n', '        localResults.currentCash = getCash(asset);\n', '\n', '        (err, localResults.updatedCash) = add(localResults.currentCash, amount);\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.SUPPLY_NEW_TOTAL_CASH_CALCULATION_FAILED);\n', '        }\n', '\n', '        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n', '        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n', '        if (rateCalculationResultCode != 0) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return failOpaque(FailureInfo.SUPPLY_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n', '        }\n', '\n', '        // We calculate the newBorrowIndex (we already had newSupplyIndex)\n', '        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.SUPPLY_NEW_BORROW_INDEX_CALCULATION_FAILED);\n', '        }\n', '\n', '        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n', '        if (rateCalculationResultCode != 0) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return failOpaque(FailureInfo.SUPPLY_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n', '        }\n', '\n', '        /////////////////////////\n', '        // EFFECTS & INTERACTIONS\n', '        // (No safe failures beyond this point)\n', '        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n', '            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            err = doTransferIn(asset, msg.sender, amount);\n', '            if (err != Error.NO_ERROR) {\n', "                // This is safe since it's our first interaction and it didn't do anything if it failed\n", '                return fail(err, FailureInfo.SUPPLY_TRANSFER_IN_FAILED);\n', '            }\n', '        } else {\n', '            if (msg.value == amount){\n', '                uint supplyError = supplyEther(msg.sender,msg.value);\n', '                if(supplyError !=0 ){\n', '                    revertEtherToUser(msg.sender,msg.value);\n', '                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n', '                }\n', '            }\n', '            else {\n', '                revertEtherToUser(msg.sender,msg.value);\n', '                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n', '            }\n', '        }\n', '\n', '        // Save market updates\n', '        market.blockNumber = getBlockNumber();\n', '        market.totalSupply =  localResults.newTotalSupply;\n', '        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n', '        market.supplyIndex = localResults.newSupplyIndex;\n', '        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n', '        market.borrowIndex = localResults.newBorrowIndex;\n', '\n', '        // Save user updates\n', '        localResults.startingBalance = balance.principal; // save for use in `SupplyReceived` event\n', '        balance.principal = localResults.userSupplyUpdated;\n', '        balance.interestIndex = localResults.newSupplyIndex;\n', '\n', '        emit SupplyReceived(msg.sender, asset, amount, localResults.startingBalance, localResults.userSupplyUpdated);\n', '\n', '        return uint(Error.NO_ERROR); // success\n', '    }\n', '\n', '    /**\n', "     * @notice withdraw `amount` of `ether` from sender's account to sender's address\n", "     * @dev withdraw `amount` of `ether` from msg.sender's account to msg.sender\n", '     * @param etherAmount Amount of ether to be converted to WETH\n', '     * @param user User account address\n', '     */\n', '    function withdrawEther(address user, uint etherAmount) internal returns (uint) {\n', '            WETHContract.withdraw(user,etherAmount);\n', '            return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', '     * @notice send Ether from contract to a user\n', '     * @dev Fail safe plan to send Ether stuck in contract in case there is a problem with withdraw\n', '     */\n', '    function sendEtherToUser(address user, uint amount) public returns (uint) {\n', '        // Check caller = admin\n', '        if (msg.sender != admin) {\n', '            return fail(Error.UNAUTHORIZED, FailureInfo.SEND_ETHER_ADMIN_CHECK_FAILED);\n', '        }\n', '        user.transfer(amount);\n', '        return uint(Error.NO_ERROR);\n', '    }\n', '\n', '    /**\n', "     * @notice withdraw `amount` of `asset` from sender's account to sender's address\n", "     * @dev withdraw `amount` of `asset` from msg.sender's account to msg.sender\n", '     * @param asset The market asset to withdraw\n', '     * @param requestedAmount The amount to withdraw (or -1 for max)\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function withdraw(address asset, uint requestedAmount) public returns (uint) {\n', '        if (paused) {\n', '            return fail(Error.CONTRACT_PAUSED, FailureInfo.WITHDRAW_CONTRACT_PAUSED);\n', '        }\n', '\n', '        Market storage market = markets[asset];\n', '        Balance storage supplyBalance = supplyBalances[msg.sender][asset];\n', '\n', '        WithdrawLocalVars memory localResults; // Holds all our calculation results\n', '        Error err; // Re-used for every function call that includes an Error in its return value(s).\n', '        uint rateCalculationResultCode; // Used for 2 interest rate calculation calls\n', '\n', "        // We calculate the user's accountLiquidity and accountShortfall.\n", '        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.WITHDRAW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n', '        }\n', '\n', "        // We calculate the newSupplyIndex, user's supplyCurrent and supplyUpdated for the asset\n", '        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.WITHDRAW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n', '        }\n', '\n', '        (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.WITHDRAW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', '        // If the user specifies -1 amount to withdraw ("max"),  withdrawAmount => the lesser of withdrawCapacity and supplyCurrent\n', '        if (requestedAmount == uint(-1)) {\n', '            (err, localResults.withdrawCapacity) = getAssetAmountForValue(asset, localResults.accountLiquidity);\n', '            if (err != Error.NO_ERROR) {\n', '                return fail(err, FailureInfo.WITHDRAW_CAPACITY_CALCULATION_FAILED);\n', '            }\n', '            localResults.withdrawAmount = min(localResults.withdrawCapacity, localResults.userSupplyCurrent);\n', '        } else {\n', '            localResults.withdrawAmount = requestedAmount;\n', '        }\n', '\n', '        // From here on we should NOT use requestedAmount.\n', '\n', '        // Fail gracefully if protocol has insufficient cash\n', '        // If protocol has insufficient cash, the sub operation will underflow.\n', '        localResults.currentCash = getCash(asset);\n', '        (err, localResults.updatedCash) = sub(localResults.currentCash, localResults.withdrawAmount);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.WITHDRAW_TRANSFER_OUT_NOT_POSSIBLE);\n', '        }\n', '\n', '        // We check that the amount is less than or equal to supplyCurrent\n', '        // If amount is greater than supplyCurrent, this will fail with Error.INTEGER_UNDERFLOW\n', '        (err, localResults.userSupplyUpdated) = sub(localResults.userSupplyCurrent, localResults.withdrawAmount);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(Error.INSUFFICIENT_BALANCE, FailureInfo.WITHDRAW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', '        // Fail if customer already has a shortfall\n', '        if (!isZeroExp(localResults.accountShortfall)) {\n', '            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_ACCOUNT_SHORTFALL_PRESENT);\n', '        }\n', '\n', "        // We want to know the user's withdrawCapacity, denominated in the asset\n", "        // Customer's withdrawCapacity of asset is (accountLiquidity in Eth)/ (price of asset in Eth)\n", '        // Equivalently, we calculate the eth value of the withdrawal amount and compare it directly to the accountLiquidity in Eth\n', '        (err, localResults.ethValueOfWithdrawal) = getPriceForAssetAmount(asset, localResults.withdrawAmount); // amount * oraclePrice = ethValueOfWithdrawal\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.WITHDRAW_AMOUNT_VALUE_CALCULATION_FAILED);\n', '        }\n', '\n', '        // We check that the amount is less than withdrawCapacity (here), and less than or equal to supplyCurrent (below)\n', '        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfWithdrawal) ) {\n', '            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.WITHDRAW_AMOUNT_LIQUIDITY_SHORTFALL);\n', '        }\n', '\n', "        // We calculate the protocol's totalSupply by subtracting the user's prior checkpointed balance, adding user's updated supply.\n", "        // Note that, even though the customer is withdrawing, if they've accumulated a lot of interest since their last\n", '        // action, the updated balance *could* be higher than the prior checkpointed balance.\n', '        (err, localResults.newTotalSupply) = addThenSub(market.totalSupply, localResults.userSupplyUpdated, supplyBalance.principal);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.WITHDRAW_NEW_TOTAL_SUPPLY_CALCULATION_FAILED);\n', '        }\n', '\n', '        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n', '        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, market.totalBorrows);\n', '        if (rateCalculationResultCode != 0) {\n', '            return failOpaque(FailureInfo.WITHDRAW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n', '        }\n', '\n', '        // We calculate the newBorrowIndex\n', '        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.WITHDRAW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n', '        }\n', '\n', '        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, market.totalBorrows);\n', '        if (rateCalculationResultCode != 0) {\n', '            return failOpaque(FailureInfo.WITHDRAW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n', '        }\n', '\n', '        /////////////////////////\n', '        // EFFECTS & INTERACTIONS\n', '        // (No safe failures beyond this point)\n', '\n', '        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n', '            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n', '            err = doTransferOut(asset, msg.sender, localResults.withdrawAmount);\n', '            if (err != Error.NO_ERROR) {\n', "                // This is safe since it's our first interaction and it didn't do anything if it failed\n", '                return fail(err, FailureInfo.WITHDRAW_TRANSFER_OUT_FAILED);\n', '            }\n', '        } else {\n', '            uint withdrawalerr = withdrawEther(msg.sender,localResults.withdrawAmount); // send Ether to user\n', '            if(withdrawalerr != 0){\n', '                return uint(withdrawalerr); // failure\n', '            }\n', '        }\n', '\n', '        // Save market updates\n', '        market.blockNumber = getBlockNumber();\n', '        market.totalSupply =  localResults.newTotalSupply;\n', '        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n', '        market.supplyIndex = localResults.newSupplyIndex;\n', '        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n', '        market.borrowIndex = localResults.newBorrowIndex;\n', '\n', '        // Save user updates\n', '        localResults.startingBalance = supplyBalance.principal; // save for use in `SupplyWithdrawn` event\n', '        supplyBalance.principal = localResults.userSupplyUpdated;\n', '        supplyBalance.interestIndex = localResults.newSupplyIndex;\n', '\n', '        emit SupplyWithdrawn(msg.sender, asset, localResults.withdrawAmount, localResults.startingBalance, localResults.userSupplyUpdated);\n', '        \n', '        return uint(Error.NO_ERROR); // success\n', '    }\n', '\n', '    /**\n', "     * @dev Gets the user's account liquidity and account shortfall balances. This includes\n", '     *      any accumulated interest thus far but does NOT actually update anything in\n', '     *      storage, it simply calculates the account liquidity and shortfall with liquidity being\n', '     *      returned as the first Exp, ie (Error, accountLiquidity, accountShortfall).\n', '     */\n', '    function calculateAccountLiquidity(address userAddress) internal view returns (Error, Exp memory, Exp memory) {\n', '        Error err;\n', '        uint sumSupplyValuesMantissa;\n', '        uint sumBorrowValuesMantissa;\n', '        (err, sumSupplyValuesMantissa, sumBorrowValuesMantissa) = calculateAccountValuesInternal(userAddress);\n', '        if (err != Error.NO_ERROR) {\n', '            return(err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n', '        }\n', '\n', '        Exp memory result;\n', '\n', '        Exp memory sumSupplyValuesFinal = Exp({mantissa: sumSupplyValuesMantissa});\n', '        Exp memory sumBorrowValuesFinal; // need to apply collateral ratio\n', '\n', '        (err, sumBorrowValuesFinal) = mulExp(collateralRatio, Exp({mantissa: sumBorrowValuesMantissa}));\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, Exp({mantissa: 0}), Exp({mantissa: 0}));\n', '        }\n', '\n', '        // if sumSupplies < sumBorrows, then the user is under collateralized and has account shortfall.\n', '        // else the user meets the collateral ratio and has account liquidity.\n', '        if (lessThanExp(sumSupplyValuesFinal, sumBorrowValuesFinal)) {\n', '            // accountShortfall = borrows - supplies\n', '            (err, result) = subExp(sumBorrowValuesFinal, sumSupplyValuesFinal);\n', '            assert(err == Error.NO_ERROR); // Note: we have checked that sumBorrows is greater than sumSupplies directly above, therefore `subExp` cannot fail.\n', '\n', '            return (Error.NO_ERROR, Exp({mantissa: 0}), result);\n', '        } else {\n', '            // accountLiquidity = supplies - borrows\n', '            (err, result) = subExp(sumSupplyValuesFinal, sumBorrowValuesFinal);\n', '            assert(err == Error.NO_ERROR); // Note: we have checked that sumSupplies is greater than sumBorrows directly above, therefore `subExp` cannot fail.\n', '\n', '            return (Error.NO_ERROR, result, Exp({mantissa: 0}));\n', '        }\n', '    }\n', '\n', '    /**\n', "     * @notice Gets the ETH values of the user's accumulated supply and borrow balances, scaled by 10e18.\n", '     *         This includes any accumulated interest thus far but does NOT actually update anything in\n', '     *         storage\n', '     * @dev Gets ETH values of accumulated supply and borrow balances\n', '     * @param userAddress account for which to sum values\n', '     * @return (error code, sum ETH value of supplies scaled by 10e18, sum ETH value of borrows scaled by 10e18)\n', '     * TODO: Possibly should add a Min(500, collateralMarkets.length) for extra safety\n', '     * TODO: To help save gas we could think about using the current Market.interestIndex\n', '     *       accumulate interest rather than calculating it\n', '     */\n', '    function calculateAccountValuesInternal(address userAddress) internal view returns (Error, uint, uint) {\n', '\n', "        /** By definition, all collateralMarkets are those that contribute to the user's\n", '         * liquidity and shortfall so we need only loop through those markets.\n', "         * To handle avoiding intermediate negative results, we will sum all the user's\n", '         * supply balances and borrow balances (with collateral ratio) separately and then\n', '         * subtract the sums at the end.\n', '         */\n', '\n', '        AccountValueLocalVars memory localResults; // Re-used for all intermediate results\n', '        localResults.sumSupplies = Exp({mantissa: 0});\n', '        localResults.sumBorrows = Exp({mantissa: 0});\n', '        Error err; // Re-used for all intermediate errors\n', '        localResults.collateralMarketsLength = collateralMarkets.length;\n', '\n', '        for (uint i = 0; i < localResults.collateralMarketsLength; i++) {\n', '            localResults.assetAddress = collateralMarkets[i];\n', '            Market storage currentMarket = markets[localResults.assetAddress];\n', '            Balance storage supplyBalance = supplyBalances[userAddress][localResults.assetAddress];\n', '            Balance storage borrowBalance = borrowBalances[userAddress][localResults.assetAddress];\n', '\n', '            if (supplyBalance.principal > 0) {\n', '                // We calculate the newSupplyIndex and user’s supplyCurrent (includes interest)\n', '                (err, localResults.newSupplyIndex) = calculateInterestIndex(currentMarket.supplyIndex, currentMarket.supplyRateMantissa, currentMarket.blockNumber, getBlockNumber());\n', '                if (err != Error.NO_ERROR) {\n', '                    return (err, 0, 0);\n', '                }\n', '\n', '                (err, localResults.userSupplyCurrent) = calculateBalance(supplyBalance.principal, supplyBalance.interestIndex, localResults.newSupplyIndex);\n', '                if (err != Error.NO_ERROR) {\n', '                    return (err, 0, 0);\n', '                }\n', '\n', "                // We have the user's supply balance with interest so let's multiply by the asset price to get the total value\n", '                (err, localResults.supplyTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userSupplyCurrent); // supplyCurrent * oraclePrice = supplyValueInEth\n', '                if (err != Error.NO_ERROR) {\n', '                    return (err, 0, 0);\n', '                }\n', '\n', '                // Add this to our running sum of supplies\n', '                (err, localResults.sumSupplies) = addExp(localResults.supplyTotalValue, localResults.sumSupplies);\n', '                if (err != Error.NO_ERROR) {\n', '                    return (err, 0, 0);\n', '                }\n', '            }\n', '\n', '            if (borrowBalance.principal > 0) {\n', "                // We perform a similar actions to get the user's borrow balance\n", '                (err, localResults.newBorrowIndex) = calculateInterestIndex(currentMarket.borrowIndex, currentMarket.borrowRateMantissa, currentMarket.blockNumber, getBlockNumber());\n', '                if (err != Error.NO_ERROR) {\n', '                    return (err, 0, 0);\n', '                }\n', '\n', '                (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n', '                if (err != Error.NO_ERROR) {\n', '                    return (err, 0, 0);\n', '                }\n', '\n', '                // In the case of borrow, we multiply the borrow value by the collateral ratio\n', '                (err, localResults.borrowTotalValue) = getPriceForAssetAmount(localResults.assetAddress, localResults.userBorrowCurrent); // ( borrowCurrent* oraclePrice * collateralRatio) = borrowTotalValueInEth\n', '                if (err != Error.NO_ERROR) {\n', '                    return (err, 0, 0);\n', '                }\n', '\n', '                // Add this to our running sum of borrows\n', '                (err, localResults.sumBorrows) = addExp(localResults.borrowTotalValue, localResults.sumBorrows);\n', '                if (err != Error.NO_ERROR) {\n', '                    return (err, 0, 0);\n', '                }\n', '            }\n', '        }\n', '\n', '        return (Error.NO_ERROR, localResults.sumSupplies.mantissa, localResults.sumBorrows.mantissa);\n', '    }\n', '\n', '    /**\n', "     * @notice Gets the ETH values of the user's accumulated supply and borrow balances, scaled by 10e18.\n", '     *         This includes any accumulated interest thus far but does NOT actually update anything in\n', '     *         storage\n', '     * @dev Gets ETH values of accumulated supply and borrow balances\n', '     * @param userAddress account for which to sum values\n', '     * @return (uint 0=success; otherwise a failure (see ErrorReporter.sol for details),\n', '     *          sum ETH value of supplies scaled by 10e18,\n', '     *          sum ETH value of borrows scaled by 10e18)\n', '     */\n', '    function calculateAccountValues(address userAddress) public view returns (uint, uint, uint) {\n', '        (Error err, uint supplyValue, uint borrowValue) = calculateAccountValuesInternal(userAddress);\n', '        if (err != Error.NO_ERROR) {\n', '\n', '            return (uint(err), 0, 0);\n', '        }\n', '\n', '        return (0, supplyValue, borrowValue);\n', '    }\n', '\n', '    /**\n', '     * @notice Users repay borrowed assets from their own address to the protocol.\n', '     * @param asset The market asset to repay\n', '     * @param amount The amount to repay (or -1 for max)\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function repayBorrow(address asset, uint amount) public payable returns (uint) {\n', '        if (paused) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(Error.CONTRACT_PAUSED, FailureInfo.REPAY_BORROW_CONTRACT_PAUSED);\n', '        }\n', '        PayBorrowLocalVars memory localResults;\n', '        Market storage market = markets[asset];\n', '        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n', '        Error err;\n', '        uint rateCalculationResultCode;\n', '\n', "        // We calculate the newBorrowIndex, user's borrowCurrent and borrowUpdated for the asset\n", '        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.REPAY_BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n', '        }\n', '\n', '        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', '        uint reimburseAmount;\n', '        // If the user specifies -1 amount to repay (“max”), repayAmount =>\n', '        // the lesser of the senders ERC-20 balance and borrowCurrent\n', '        if (asset != wethAddress) {\n', '            if (amount == uint(-1)) {\n', '                localResults.repayAmount = min(getBalanceOf(asset, msg.sender), localResults.userBorrowCurrent);\n', '            } else {\n', '                localResults.repayAmount = amount;\n', '            }\n', '        } else {\n', '            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n', '            if (amount > localResults.userBorrowCurrent) {\n', '                localResults.repayAmount = localResults.userBorrowCurrent;\n', '                (err, reimburseAmount) = sub(amount,localResults.userBorrowCurrent); // reimbursement called at the end to make sure function does not have any other errors\n', '                if (err != Error.NO_ERROR) {\n', '                    revertEtherToUser(msg.sender,msg.value);\n', '                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n', '                }\n', '            } else {\n', '                localResults.repayAmount = amount;\n', '            }\n', '        }\n', '\n', '        // Subtract the `repayAmount` from the `userBorrowCurrent` to get `userBorrowUpdated`\n', '        // Note: this checks that repayAmount is less than borrowCurrent\n', '        (err, localResults.userBorrowUpdated) = sub(localResults.userBorrowCurrent, localResults.repayAmount);\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', '        // Fail gracefully if asset is not approved or has insufficient balance\n', '        // Note: this checks that repayAmount is less than or equal to their ERC-20 balance\n', '        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            err = checkTransferIn(asset, msg.sender, localResults.repayAmount);\n', '            if (err != Error.NO_ERROR) {\n', '                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_NOT_POSSIBLE);\n', '            }\n', '        }\n', '\n', "        // We calculate the protocol's totalBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow\n", "        // Note that, even though the customer is paying some of their borrow, if they've accumulated a lot of interest since their last\n", '        // action, the updated balance *could* be higher than the prior checkpointed balance.\n', '        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n', '        }\n', '\n', '        // We need to calculate what the updated cash will be after we transfer in from user\n', '        localResults.currentCash = getCash(asset);\n', '\n', '        (err, localResults.updatedCash) = add(localResults.currentCash, localResults.repayAmount);\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n', '        }\n', '\n', '        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n', '\n', '        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n', '        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return fail(err, FailureInfo.REPAY_BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n', '        }\n', '\n', '        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n', '        if (rateCalculationResultCode != 0) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return failOpaque(FailureInfo.REPAY_BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n', '        }\n', '\n', '        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n', '        if (rateCalculationResultCode != 0) {\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            return failOpaque(FailureInfo.REPAY_BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n', '        }\n', '\n', '        /////////////////////////\n', '        // EFFECTS & INTERACTIONS\n', '        // (No safe failures beyond this point)\n', '        if(asset != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n', '            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            err = doTransferIn(asset, msg.sender, localResults.repayAmount);\n', '            if (err != Error.NO_ERROR) {\n', "                // This is safe since it's our first interaction and it didn't do anything if it failed\n", '                return fail(err, FailureInfo.REPAY_BORROW_TRANSFER_IN_FAILED);\n', '            }\n', '        } else {\n', '            if (msg.value == amount){\n', '                uint supplyError = supplyEther(msg.sender,localResults.repayAmount);\n', '                //Repay excess funds\n', '                if(reimburseAmount > 0){\n', '                    revertEtherToUser(msg.sender,reimburseAmount);\n', '                }\n', '                if(supplyError != 0 ){\n', '                    revertEtherToUser(msg.sender,msg.value);\n', '                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n', '                } \n', '            }\n', '            else {\n', '                revertEtherToUser(msg.sender,msg.value);\n', '                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n', '            }\n', '        }\n', '\n', '        // Save market updates\n', '        market.blockNumber = getBlockNumber();\n', '        market.totalBorrows =  localResults.newTotalBorrows;\n', '        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n', '        market.supplyIndex = localResults.newSupplyIndex;\n', '        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n', '        market.borrowIndex = localResults.newBorrowIndex;\n', '\n', '        // Save user updates\n', '        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowRepaid` event\n', '        borrowBalance.principal = localResults.userBorrowUpdated;\n', '        borrowBalance.interestIndex = localResults.newBorrowIndex;\n', '        \n', '        supplyOriginationFeeAsAdmin(asset,msg.sender, localResults.repayAmount,localResults.newSupplyIndex);\n', '\n', '        emit BorrowRepaid(msg.sender, asset, localResults.repayAmount, localResults.startingBalance, localResults.userBorrowUpdated);\n', '\n', '        return uint(Error.NO_ERROR); // success\n', '    }\n', '\n', '    /**\n', '     * @notice users repay all or some of an underwater borrow and receive collateral\n', '     * @param targetAccount The account whose borrow should be liquidated\n', '     * @param assetBorrow The market asset to repay\n', "     * @param assetCollateral The borrower's market asset to receive in exchange\n", '     * @param requestedAmountClose The amount to repay (or -1 for max)\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function liquidateBorrow(address targetAccount, address assetBorrow, address assetCollateral, uint requestedAmountClose) payable public isLiquidator returns (uint) {\n', '        if (paused) {\n', '            return fail(Error.CONTRACT_PAUSED, FailureInfo.LIQUIDATE_CONTRACT_PAUSED);\n', '        }\n', '        LiquidateLocalVars memory localResults;\n', '        // Copy these addresses into the struct for use with `emitLiquidationEvent`\n', "        // We'll use localResults.liquidator inside this function for clarity vs using msg.sender.\n", '        localResults.targetAccount = targetAccount;\n', '        localResults.assetBorrow = assetBorrow;\n', '        localResults.liquidator = msg.sender;\n', '        localResults.assetCollateral = assetCollateral;\n', '\n', '        Market storage borrowMarket = markets[assetBorrow];\n', '        Market storage collateralMarket = markets[assetCollateral];\n', '        Balance storage borrowBalance_TargeUnderwaterAsset = borrowBalances[targetAccount][assetBorrow];\n', '        Balance storage supplyBalance_TargetCollateralAsset = supplyBalances[targetAccount][assetCollateral];\n', '\n', '        // Liquidator might already hold some of the collateral asset\n', '        Balance storage supplyBalance_LiquidatorCollateralAsset = supplyBalances[localResults.liquidator][assetCollateral];\n', '\n', '        uint rateCalculationResultCode; // Used for multiple interest rate calculation calls\n', '        Error err; // re-used for all intermediate errors\n', '\n', '        (err, localResults.collateralPrice) = fetchAssetPrice(assetCollateral);\n', '        if(err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_FETCH_ASSET_PRICE_FAILED);\n', '        }\n', '\n', '        (err, localResults.underwaterAssetPrice) = fetchAssetPrice(assetBorrow);\n', '        // If the price oracle is not set, then we would have failed on the first call to fetchAssetPrice\n', '        assert(err == Error.NO_ERROR);\n', '\n', '        // We calculate newBorrowIndex_UnderwaterAsset and then use it to help calculate currentBorrowBalance_TargetUnderwaterAsset\n', '        (err, localResults.newBorrowIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.borrowIndex, borrowMarket.borrowRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n', '        }\n', '\n', '        (err, localResults.currentBorrowBalance_TargetUnderwaterAsset) = calculateBalance(borrowBalance_TargeUnderwaterAsset.principal, borrowBalance_TargeUnderwaterAsset.interestIndex, localResults.newBorrowIndex_UnderwaterAsset);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_BORROW_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', '        // We calculate newSupplyIndex_CollateralAsset and then use it to help calculate currentSupplyBalance_TargetCollateralAsset\n', '        (err, localResults.newSupplyIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.supplyIndex, collateralMarket.supplyRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n', '        }\n', '\n', '        (err, localResults.currentSupplyBalance_TargetCollateralAsset) = calculateBalance(supplyBalance_TargetCollateralAsset.principal, supplyBalance_TargetCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n', '        }\n', '\n', '        // Liquidator may or may not already have some collateral asset.\n', '        // If they do, we need to accumulate interest on it before adding the seized collateral to it.\n', '        // We re-use newSupplyIndex_CollateralAsset calculated above to help calculate currentSupplyBalance_LiquidatorCollateralAsset\n', '        (err, localResults.currentSupplyBalance_LiquidatorCollateralAsset) = calculateBalance(supplyBalance_LiquidatorCollateralAsset.principal, supplyBalance_LiquidatorCollateralAsset.interestIndex, localResults.newSupplyIndex_CollateralAsset);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_ACCUMULATED_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n', '        }\n', '\n', "        // We update the protocol's totalSupply for assetCollateral in 2 steps, first by adding target user's accumulated\n", "        // interest and then by adding the liquidator's accumulated interest.\n", '\n', "        // Step 1 of 2: We add the target user's supplyCurrent and subtract their checkpointedBalance\n", '        // (which has the desired effect of adding accrued interest from the target user)\n', '        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(collateralMarket.totalSupply, localResults.currentSupplyBalance_TargetCollateralAsset, supplyBalance_TargetCollateralAsset.principal);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_BORROWER_COLLATERAL_ASSET);\n', '        }\n', '\n', "        // Step 2 of 2: We add the liquidator's supplyCurrent of collateral asset and subtract their checkpointedBalance\n", '        // (which has the desired effect of adding accrued interest from the calling user)\n', '        (err, localResults.newTotalSupply_ProtocolCollateralAsset) = addThenSub(localResults.newTotalSupply_ProtocolCollateralAsset, localResults.currentSupplyBalance_LiquidatorCollateralAsset, supplyBalance_LiquidatorCollateralAsset.principal);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET);\n', '        }\n', '\n', '        // We calculate maxCloseableBorrowAmount_TargetUnderwaterAsset, the amount of borrow that can be closed from the target user\n', '        // This is equal to the lesser of\n', '        // 1. borrowCurrent; (already calculated)\n', '        // 2. ONLY IF MARKET SUPPORTED: discountedRepayToEvenAmount:\n', '        // discountedRepayToEvenAmount=\n', '        //      shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n', '        // 3. discountedBorrowDenominatedCollateral\n', '        //      [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n', '\n', '        // Here we calculate item 3. discountedBorrowDenominatedCollateral =\n', '        // [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n', '        (err, localResults.discountedBorrowDenominatedCollateral) =\n', '        calculateDiscountedBorrowDenominatedCollateral(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.currentSupplyBalance_TargetCollateralAsset);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_BORROW_DENOMINATED_COLLATERAL_CALCULATION_FAILED);\n', '        }\n', '\n', '        if (borrowMarket.isSupported) {\n', '            // Market is supported, so we calculate item 2 from above.\n', '            (err, localResults.discountedRepayToEvenAmount) =\n', '            calculateDiscountedRepayToEvenAmount(targetAccount, localResults.underwaterAssetPrice);\n', '            if (err != Error.NO_ERROR) {\n', '                return fail(err, FailureInfo.LIQUIDATE_DISCOUNTED_REPAY_TO_EVEN_AMOUNT_CALCULATION_FAILED);\n', '            }\n', '\n', '            // We need to do a two-step min to select from all 3 values\n', '            // min1&3 = min(item 1, item 3)\n', '            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n', '\n', '            // min1&3&2 = min(min1&3, 2)\n', '            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset, localResults.discountedRepayToEvenAmount);\n', '        } else {\n', "            // Market is not supported, so we don't need to calculate item 2.\n", '            localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset = min(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.discountedBorrowDenominatedCollateral);\n', '        }\n', '\n', '        // If liquidateBorrowAmount = -1, then closeBorrowAmount_TargetUnderwaterAsset = maxCloseableBorrowAmount_TargetUnderwaterAsset\n', '        if (assetBorrow != wethAddress) {\n', '            if (requestedAmountClose == uint(-1)) {\n', '                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n', '            } else {\n', '                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n', '            }\n', '        } else {\n', '            // To calculate the actual repay use has to do and reimburse the excess amount of ETH collected\n', '            if (requestedAmountClose > localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n', '                localResults.closeBorrowAmount_TargetUnderwaterAsset = localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset;\n', '                (err, localResults.reimburseAmount) = sub(requestedAmountClose,localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset); // reimbursement called at the end to make sure function does not have any other errors\n', '                if (err != Error.NO_ERROR) {\n', '                    return fail(err, FailureInfo.REPAY_BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n', '                }\n', '            } else {\n', '                localResults.closeBorrowAmount_TargetUnderwaterAsset = requestedAmountClose;\n', '            }\n', '        }\n', '\n', '        // From here on, no more use of `requestedAmountClose`\n', '\n', '        // Verify closeBorrowAmount_TargetUnderwaterAsset <= maxCloseableBorrowAmount_TargetUnderwaterAsset\n', '        if (localResults.closeBorrowAmount_TargetUnderwaterAsset > localResults.maxCloseableBorrowAmount_TargetUnderwaterAsset) {\n', '            return fail(Error.INVALID_CLOSE_AMOUNT_REQUESTED, FailureInfo.LIQUIDATE_CLOSE_AMOUNT_TOO_HIGH);\n', '        }\n', '\n', '        // seizeSupplyAmount_TargetCollateralAsset = closeBorrowAmount_TargetUnderwaterAsset * priceBorrow/priceCollateral *(1+liquidationDiscount)\n', '        (err, localResults.seizeSupplyAmount_TargetCollateralAsset) = calculateAmountSeize(localResults.underwaterAssetPrice, localResults.collateralPrice, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_AMOUNT_SEIZE_CALCULATION_FAILED);\n', '        }\n', '\n', '        // We are going to ERC-20 transfer closeBorrowAmount_TargetUnderwaterAsset of assetBorrow into protocol\n', '        // Fail gracefully if asset is not approved or has insufficient balance\n', '        if(assetBorrow != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n', '            err = checkTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n', '            if (err != Error.NO_ERROR) {\n', '                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_NOT_POSSIBLE);\n', '            }\n', '        }\n', '\n', "        // We are going to repay the target user's borrow using the calling user's funds\n", "        // We update the protocol's totalBorrow for assetBorrow, by subtracting the target user's prior checkpointed balance,\n", '        // adding borrowCurrent, and subtracting closeBorrowAmount_TargetUnderwaterAsset.\n', '\n', '        // Subtract the `closeBorrowAmount_TargetUnderwaterAsset` from the `currentBorrowBalance_TargetUnderwaterAsset` to get `updatedBorrowBalance_TargetUnderwaterAsset`\n', '        (err, localResults.updatedBorrowBalance_TargetUnderwaterAsset) = sub(localResults.currentBorrowBalance_TargetUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n', "        // We have ensured above that localResults.closeBorrowAmount_TargetUnderwaterAsset <= localResults.currentBorrowBalance_TargetUnderwaterAsset, so the sub can't underflow\n", '        assert(err == Error.NO_ERROR);\n', '\n', "        // We calculate the protocol's totalBorrow for assetBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow\n", '        // Note that, even though the liquidator is paying some of the borrow, if the borrow has accumulated a lot of interest since the last\n', '        // action, the updated balance *could* be higher than the prior checkpointed balance.\n', '        (err, localResults.newTotalBorrows_ProtocolUnderwaterAsset) = addThenSub(borrowMarket.totalBorrows, localResults.updatedBorrowBalance_TargetUnderwaterAsset, borrowBalance_TargeUnderwaterAsset.principal);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_BORROW_CALCULATION_FAILED_BORROWED_ASSET);\n', '        }\n', '\n', '        // We need to calculate what the updated cash will be after we transfer in from liquidator\n', '        localResults.currentCash_ProtocolUnderwaterAsset = getCash(assetBorrow);\n', '        (err, localResults.updatedCash_ProtocolUnderwaterAsset) = add(localResults.currentCash_ProtocolUnderwaterAsset, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_NEW_TOTAL_CASH_CALCULATION_FAILED_BORROWED_ASSET);\n', '        }\n', '\n', '        // The utilization rate has changed! We calculate a new supply index, borrow index, supply rate, and borrow rate for assetBorrow\n', "        // (Please note that we don't need to do the same thing for assetCollateral because neither cash nor borrows of assetCollateral happen in this process.)\n", '\n', "        // We calculate the newSupplyIndex_UnderwaterAsset, but we already have newBorrowIndex_UnderwaterAsset so don't recalculate it.\n", '        (err, localResults.newSupplyIndex_UnderwaterAsset) = calculateInterestIndex(borrowMarket.supplyIndex, borrowMarket.supplyRateMantissa, borrowMarket.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_NEW_SUPPLY_INDEX_CALCULATION_FAILED_BORROWED_ASSET);\n', '        }\n', '\n', '        (rateCalculationResultCode, localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getSupplyRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n', '        if (rateCalculationResultCode != 0) {\n', '            return failOpaque(FailureInfo.LIQUIDATE_NEW_SUPPLY_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n', '        }\n', '\n', '        (rateCalculationResultCode, localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset) = borrowMarket.interestRateModel.getBorrowRate(assetBorrow, localResults.updatedCash_ProtocolUnderwaterAsset, localResults.newTotalBorrows_ProtocolUnderwaterAsset);\n', '        if (rateCalculationResultCode != 0) {\n', '            return failOpaque(FailureInfo.LIQUIDATE_NEW_BORROW_RATE_CALCULATION_FAILED_BORROWED_ASSET, rateCalculationResultCode);\n', '        }\n', '\n', "        // Now we look at collateral. We calculated target user's accumulated supply balance and the supply index above.\n", '        // Now we need to calculate the borrow index.\n', "        // We don't need to calculate new rates for the collateral asset because we have not changed utilization:\n", "        //  - accumulating interest on the target user's collateral does not change cash or borrows\n", '        //  - transferring seized amount of collateral internally from the target user to the liquidator does not change cash or borrows.\n', '        (err, localResults.newBorrowIndex_CollateralAsset) = calculateInterestIndex(collateralMarket.borrowIndex, collateralMarket.borrowRateMantissa, collateralMarket.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.LIQUIDATE_NEW_BORROW_INDEX_CALCULATION_FAILED_COLLATERAL_ASSET);\n', '        }\n', '\n', "        // We checkpoint the target user's assetCollateral supply balance, supplyCurrent - seizeSupplyAmount_TargetCollateralAsset at the updated index\n", '        (err, localResults.updatedSupplyBalance_TargetCollateralAsset) = sub(localResults.currentSupplyBalance_TargetCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n', "        // The sub won't underflow because because seizeSupplyAmount_TargetCollateralAsset <= target user's collateral balance\n", '        // maxCloseableBorrowAmount_TargetUnderwaterAsset is limited by the discounted borrow denominated collateral. That limits closeBorrowAmount_TargetUnderwaterAsset\n', '        // which in turn limits seizeSupplyAmount_TargetCollateralAsset.\n', '        assert (err == Error.NO_ERROR);\n', '\n', "        // We checkpoint the liquidating user's assetCollateral supply balance, supplyCurrent + seizeSupplyAmount_TargetCollateralAsset at the updated index\n", '        (err, localResults.updatedSupplyBalance_LiquidatorCollateralAsset) = add(localResults.currentSupplyBalance_LiquidatorCollateralAsset, localResults.seizeSupplyAmount_TargetCollateralAsset);\n', "        // We can't overflow here because if this would overflow, then we would have already overflowed above and failed\n", '        // with LIQUIDATE_NEW_TOTAL_SUPPLY_BALANCE_CALCULATION_FAILED_LIQUIDATOR_COLLATERAL_ASSET\n', '        assert (err == Error.NO_ERROR);\n', '\n', '        /////////////////////////\n', '        // EFFECTS & INTERACTIONS\n', '        // (No safe failures beyond this point)\n', '\n', '        // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n', '        if(assetBorrow != wethAddress) { // WETH is supplied to AlkemiEarnVerified contract in case of ETH automatically\n', '            revertEtherToUser(msg.sender,msg.value);\n', '            err = doTransferIn(assetBorrow, localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n', '            if (err != Error.NO_ERROR) {\n', "                // This is safe since it's our first interaction and it didn't do anything if it failed\n", '                return fail(err, FailureInfo.LIQUIDATE_TRANSFER_IN_FAILED);\n', '            }\n', '        } else {\n', '            if (msg.value == requestedAmountClose){\n', '                uint supplyError = supplyEther(localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset);\n', '                //Repay excess funds\n', '                if(localResults.reimburseAmount > 0){\n', '                    revertEtherToUser(localResults.liquidator,localResults.reimburseAmount);\n', '                }\n', '                if(supplyError !=0 ){\n', '                    revertEtherToUser(msg.sender,msg.value);\n', '                    return fail(Error.WETH_ADDRESS_NOT_SET_ERROR, FailureInfo.WETH_ADDRESS_NOT_SET_ERROR);\n', '                }\n', '            }   \n', '            else {\n', '                revertEtherToUser(msg.sender,msg.value);\n', '                return fail(Error.ETHER_AMOUNT_MISMATCH_ERROR, FailureInfo.ETHER_AMOUNT_MISMATCH_ERROR);\n', '            }\n', '        }\n', '\n', '        // Save borrow market updates\n', '        borrowMarket.blockNumber = getBlockNumber();\n', '        borrowMarket.totalBorrows = localResults.newTotalBorrows_ProtocolUnderwaterAsset;\n', '        // borrowMarket.totalSupply does not need to be updated\n', '        borrowMarket.supplyRateMantissa = localResults.newSupplyRateMantissa_ProtocolUnderwaterAsset;\n', '        borrowMarket.supplyIndex = localResults.newSupplyIndex_UnderwaterAsset;\n', '        borrowMarket.borrowRateMantissa = localResults.newBorrowRateMantissa_ProtocolUnderwaterAsset;\n', '        borrowMarket.borrowIndex = localResults.newBorrowIndex_UnderwaterAsset;\n', '\n', '        // Save collateral market updates\n', "        // We didn't calculate new rates for collateralMarket (because neither cash nor borrows changed), just new indexes and total supply.\n", '        collateralMarket.blockNumber = getBlockNumber();\n', '        collateralMarket.totalSupply = localResults.newTotalSupply_ProtocolCollateralAsset;\n', '        collateralMarket.supplyIndex = localResults.newSupplyIndex_CollateralAsset;\n', '        collateralMarket.borrowIndex = localResults.newBorrowIndex_CollateralAsset;\n', '\n', '        // Save user updates\n', '\n', '        localResults.startingBorrowBalance_TargetUnderwaterAsset = borrowBalance_TargeUnderwaterAsset.principal; // save for use in event\n', '        borrowBalance_TargeUnderwaterAsset.principal = localResults.updatedBorrowBalance_TargetUnderwaterAsset;\n', '        borrowBalance_TargeUnderwaterAsset.interestIndex = localResults.newBorrowIndex_UnderwaterAsset;\n', '\n', '        localResults.startingSupplyBalance_TargetCollateralAsset = supplyBalance_TargetCollateralAsset.principal; // save for use in event\n', '        supplyBalance_TargetCollateralAsset.principal = localResults.updatedSupplyBalance_TargetCollateralAsset;\n', '        supplyBalance_TargetCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n', '\n', '        localResults.startingSupplyBalance_LiquidatorCollateralAsset = supplyBalance_LiquidatorCollateralAsset.principal; // save for use in event\n', '        supplyBalance_LiquidatorCollateralAsset.principal = localResults.updatedSupplyBalance_LiquidatorCollateralAsset;\n', '        supplyBalance_LiquidatorCollateralAsset.interestIndex = localResults.newSupplyIndex_CollateralAsset;\n', '        \n', '        supplyOriginationFeeAsAdmin(assetBorrow,localResults.liquidator, localResults.closeBorrowAmount_TargetUnderwaterAsset, localResults.newSupplyIndex_UnderwaterAsset);\n', '\n', '        emitLiquidationEvent(localResults);\n', '\n', '        return uint(Error.NO_ERROR); // success\n', '    }\n', '\n', '    /**\n', '     * @dev this function exists to avoid error `CompilerError: Stack too deep, try removing local variables.` in `liquidateBorrow`\n', '     */\n', '    function emitLiquidationEvent(LiquidateLocalVars memory localResults) internal {\n', '        // event BorrowLiquidated(address targetAccount, address assetBorrow, uint borrowBalanceBefore, uint borrowBalanceAccumulated, uint amountRepaid, uint borrowBalanceAfter,\n', '        // address liquidator, address assetCollateral, uint collateralBalanceBefore, uint collateralBalanceAccumulated, uint amountSeized, uint collateralBalanceAfter);\n', '        emit BorrowLiquidated(localResults.targetAccount,\n', '            localResults.assetBorrow,\n', '            localResults.startingBorrowBalance_TargetUnderwaterAsset,\n', '            localResults.currentBorrowBalance_TargetUnderwaterAsset,\n', '            localResults.closeBorrowAmount_TargetUnderwaterAsset,\n', '            localResults.updatedBorrowBalance_TargetUnderwaterAsset,\n', '            localResults.liquidator,\n', '            localResults.assetCollateral,\n', '            localResults.startingSupplyBalance_TargetCollateralAsset,\n', '            localResults.currentSupplyBalance_TargetCollateralAsset,\n', '            localResults.seizeSupplyAmount_TargetCollateralAsset,\n', '            localResults.updatedSupplyBalance_TargetCollateralAsset);\n', '    }\n', '\n', '    /**\n', '     * @dev This should ONLY be called if market is supported. It returns shortfall / [Oracle price for the borrow * (collateralRatio - liquidationDiscount - 1)]\n', "     *      If the market isn't supported, we support liquidation of asset regardless of shortfall because we want borrows of the unsupported asset to be closed.\n", '     *      Note that if collateralRatio = liquidationDiscount + 1, then the denominator will be zero and the function will fail with DIVISION_BY_ZERO.\n', '     */\n', '    function calculateDiscountedRepayToEvenAmount(address targetAccount, Exp memory underwaterAssetPrice) internal view returns (Error, uint) {\n', '        Error err;\n', '        Exp memory _accountLiquidity; // unused return value from calculateAccountLiquidity\n', '        Exp memory accountShortfall_TargetUser;\n', '        Exp memory collateralRatioMinusLiquidationDiscount; // collateralRatio - liquidationDiscount\n', '        Exp memory discountedCollateralRatioMinusOne; // collateralRatioMinusLiquidationDiscount - 1, aka collateralRatio - liquidationDiscount - 1\n', '        Exp memory discountedPrice_UnderwaterAsset;\n', '        Exp memory rawResult;\n', '\n', "        // we calculate the target user's shortfall, denominated in Ether, that the user is below the collateral ratio\n", '        (err, _accountLiquidity, accountShortfall_TargetUser) = calculateAccountLiquidity(targetAccount);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, collateralRatioMinusLiquidationDiscount) = subExp(collateralRatio, liquidationDiscount);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, discountedCollateralRatioMinusOne) = subExp(collateralRatioMinusLiquidationDiscount, Exp({mantissa: mantissaOne}));\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, discountedPrice_UnderwaterAsset) = mulExp(underwaterAssetPrice, discountedCollateralRatioMinusOne);\n', '        // calculateAccountLiquidity multiplies underwaterAssetPrice by collateralRatio\n', '        // discountedCollateralRatioMinusOne < collateralRatio\n', '        // so if underwaterAssetPrice * collateralRatio did not overflow then\n', "        // underwaterAssetPrice * discountedCollateralRatioMinusOne can't overflow either\n", '        assert(err == Error.NO_ERROR);\n', '\n', '        (err, rawResult) = divExp(accountShortfall_TargetUser, discountedPrice_UnderwaterAsset);\n', "        // It's theoretically possible an asset could have such a low price that it truncates to zero when discounted.\n", '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (Error.NO_ERROR, truncate(rawResult));\n', '    }\n', '\n', '    /**\n', '     * @dev discountedBorrowDenominatedCollateral = [supplyCurrent / (1 + liquidationDiscount)] * (Oracle price for the collateral / Oracle price for the borrow)\n', '     */\n', '    function calculateDiscountedBorrowDenominatedCollateral(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint supplyCurrent_TargetCollateralAsset) view internal returns (Error, uint) {\n', '        // To avoid rounding issues, we re-order and group the operations so we do 1 division and only at the end\n', '        // [supplyCurrent * (Oracle price for the collateral)] / [ (1 + liquidationDiscount) * (Oracle price for the borrow) ]\n', '        Error err;\n', '        Exp memory onePlusLiquidationDiscount; // (1 + liquidationDiscount)\n', '        Exp memory supplyCurrentTimesOracleCollateral; // supplyCurrent * Oracle price for the collateral\n', '        Exp memory onePlusLiquidationDiscountTimesOracleBorrow; // (1 + liquidationDiscount) * Oracle price for the borrow\n', '        Exp memory rawResult;\n', '\n', '        (err, onePlusLiquidationDiscount) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, supplyCurrentTimesOracleCollateral) = mulScalar(collateralPrice, supplyCurrent_TargetCollateralAsset);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, onePlusLiquidationDiscountTimesOracleBorrow) = mulExp(onePlusLiquidationDiscount, underwaterAssetPrice);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, rawResult) = divExp(supplyCurrentTimesOracleCollateral, onePlusLiquidationDiscountTimesOracleBorrow);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (Error.NO_ERROR, truncate(rawResult));\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev returns closeBorrowAmount_TargetUnderwaterAsset * (1+liquidationDiscount) * priceBorrow/priceCollateral\n', '     */\n', '    function calculateAmountSeize(Exp memory underwaterAssetPrice, Exp memory collateralPrice, uint closeBorrowAmount_TargetUnderwaterAsset) internal view returns (Error, uint) {\n', '        // To avoid rounding issues, we re-order and group the operations to move the division to the end, rather than just taking the ratio of the 2 prices:\n', '        // underwaterAssetPrice * (1+liquidationDiscount) *closeBorrowAmount_TargetUnderwaterAsset) / collateralPrice\n', '\n', '        // re-used for all intermediate errors\n', '        Error err;\n', '\n', '        // (1+liquidationDiscount)\n', '        Exp memory liquidationMultiplier;\n', '\n', '        // assetPrice-of-underwaterAsset * (1+liquidationDiscount)\n', '        Exp memory priceUnderwaterAssetTimesLiquidationMultiplier;\n', '\n', '        // priceUnderwaterAssetTimesLiquidationMultiplier * closeBorrowAmount_TargetUnderwaterAsset\n', '        // or, expanded:\n', '        // underwaterAssetPrice * (1+liquidationDiscount) * closeBorrowAmount_TargetUnderwaterAsset\n', '        Exp memory finalNumerator;\n', '\n', '        // finalNumerator / priceCollateral\n', '        Exp memory rawResult;\n', '\n', '        (err, liquidationMultiplier) = addExp(Exp({mantissa: mantissaOne}), liquidationDiscount);\n', "        // liquidation discount will be enforced < 1, so 1 + liquidationDiscount can't overflow.\n", '        assert(err == Error.NO_ERROR);\n', '\n', '        (err, priceUnderwaterAssetTimesLiquidationMultiplier) = mulExp(underwaterAssetPrice, liquidationMultiplier);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, finalNumerator) = mulScalar(priceUnderwaterAssetTimesLiquidationMultiplier, closeBorrowAmount_TargetUnderwaterAsset);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        (err, rawResult) = divExp(finalNumerator, collateralPrice);\n', '        if (err != Error.NO_ERROR) {\n', '            return (err, 0);\n', '        }\n', '\n', '        return (Error.NO_ERROR, truncate(rawResult));\n', '    }\n', '\n', '\n', '    /**\n', '     * @notice Users borrow assets from the protocol to their own address\n', '     * @param asset The market asset to borrow\n', '     * @param amount The amount to borrow\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function borrow(address asset, uint amount) public isKYCVerifiedCustomer returns (uint) {\n', '        if (paused) {\n', '            return fail(Error.CONTRACT_PAUSED, FailureInfo.BORROW_CONTRACT_PAUSED);\n', '        }\n', '        BorrowLocalVars memory localResults;\n', '        Market storage market = markets[asset];\n', '        Balance storage borrowBalance = borrowBalances[msg.sender][asset];\n', '\n', '        Error err;\n', '        uint rateCalculationResultCode;\n', '\n', '        // Fail if market not supported\n', '        if (!market.isSupported) {\n', '            return fail(Error.MARKET_NOT_SUPPORTED, FailureInfo.BORROW_MARKET_NOT_SUPPORTED);\n', '        }\n', '\n', "        // We calculate the newBorrowIndex, user's borrowCurrent and borrowUpdated for the asset\n", '        (err, localResults.newBorrowIndex) = calculateInterestIndex(market.borrowIndex, market.borrowRateMantissa, market.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.BORROW_NEW_BORROW_INDEX_CALCULATION_FAILED);\n', '        }\n', '\n', '        (err, localResults.userBorrowCurrent) = calculateBalance(borrowBalance.principal, borrowBalance.interestIndex, localResults.newBorrowIndex);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', '        // Calculate origination fee.\n', '        (err, localResults.borrowAmountWithFee) = calculateBorrowAmountWithFee(amount);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.BORROW_ORIGINATION_FEE_CALCULATION_FAILED);\n', '        }\n', '        uint orgFeeBalance = localResults.borrowAmountWithFee - amount;\n', '\n', '        // Add the `borrowAmountWithFee` to the `userBorrowCurrent` to get `userBorrowUpdated`\n', '        (err, localResults.userBorrowUpdated) = add(localResults.userBorrowCurrent, localResults.borrowAmountWithFee);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BALANCE_CALCULATION_FAILED);\n', '        }\n', '\n', "        // We calculate the protocol's totalBorrow by subtracting the user's prior checkpointed balance, adding user's updated borrow with fee\n", '        (err, localResults.newTotalBorrows) = addThenSub(market.totalBorrows, localResults.userBorrowUpdated, borrowBalance.principal);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.BORROW_NEW_TOTAL_BORROW_CALCULATION_FAILED);\n', '        }\n', '\n', '        // Check customer liquidity\n', '        (err, localResults.accountLiquidity, localResults.accountShortfall) = calculateAccountLiquidity(msg.sender);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.BORROW_ACCOUNT_LIQUIDITY_CALCULATION_FAILED);\n', '        }\n', '\n', '        // Fail if customer already has a shortfall\n', '        if (!isZeroExp(localResults.accountShortfall)) {\n', '            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_ACCOUNT_SHORTFALL_PRESENT);\n', '        }\n', '\n', '        // Would the customer have a shortfall after this borrow (including origination fee)?\n', '        // We calculate the eth-equivalent value of (borrow amount + fee) of asset and fail if it exceeds accountLiquidity.\n', '        // This implements: `[(collateralRatio*oraclea*borrowAmount)*(1+borrowFee)] > accountLiquidity`\n', '        (err, localResults.ethValueOfBorrowAmountWithFee) = getPriceForAssetAmountMulCollatRatio(asset, localResults.borrowAmountWithFee);\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.BORROW_AMOUNT_VALUE_CALCULATION_FAILED);\n', '        }\n', '        if (lessThanExp(localResults.accountLiquidity, localResults.ethValueOfBorrowAmountWithFee)) {\n', '            return fail(Error.INSUFFICIENT_LIQUIDITY, FailureInfo.BORROW_AMOUNT_LIQUIDITY_SHORTFALL);\n', '        }\n', '\n', '        // Fail gracefully if protocol has insufficient cash\n', '        localResults.currentCash = getCash(asset);\n', '        // We need to calculate what the updated cash will be after we transfer out to the user\n', '        (err, localResults.updatedCash) = sub(localResults.currentCash, amount);\n', '        if (err != Error.NO_ERROR) {\n', '            // Note: we ignore error here and call this token insufficient cash\n', '            return fail(Error.TOKEN_INSUFFICIENT_CASH, FailureInfo.BORROW_NEW_TOTAL_CASH_CALCULATION_FAILED);\n', '        }\n', '\n', '        // The utilization rate has changed! We calculate a new supply index and borrow index for the asset, and save it.\n', '\n', '        // We calculate the newSupplyIndex, but we have newBorrowIndex already\n', '        (err, localResults.newSupplyIndex) = calculateInterestIndex(market.supplyIndex, market.supplyRateMantissa, market.blockNumber, getBlockNumber());\n', '        if (err != Error.NO_ERROR) {\n', '            return fail(err, FailureInfo.BORROW_NEW_SUPPLY_INDEX_CALCULATION_FAILED);\n', '        }\n', '\n', '        (rateCalculationResultCode, localResults.newSupplyRateMantissa) = market.interestRateModel.getSupplyRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n', '        if (rateCalculationResultCode != 0) {\n', '            return failOpaque(FailureInfo.BORROW_NEW_SUPPLY_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n', '        }\n', '\n', '        (rateCalculationResultCode, localResults.newBorrowRateMantissa) = market.interestRateModel.getBorrowRate(asset, localResults.updatedCash, localResults.newTotalBorrows);\n', '        if (rateCalculationResultCode != 0) {\n', '            return failOpaque(FailureInfo.BORROW_NEW_BORROW_RATE_CALCULATION_FAILED, rateCalculationResultCode);\n', '        }\n', '\n', '        /////////////////////////\n', '        // EFFECTS & INTERACTIONS\n', '        // (No safe failures beyond this point)\n', '\n', '        if(asset != wethAddress) { // Withdrawal should happen as Ether directly\n', '            // We ERC-20 transfer the asset into the protocol (note: pre-conditions already checked above)\n', '            err = doTransferOut(asset, msg.sender, amount);\n', '            if (err != Error.NO_ERROR) {\n', "                // This is safe since it's our first interaction and it didn't do anything if it failed\n", '                return fail(err, FailureInfo.BORROW_TRANSFER_OUT_FAILED);\n', '            }\n', '        } else {\n', '            uint withdrawalerr = withdrawEther(msg.sender,amount); // send Ether to user\n', '            if(withdrawalerr != 0){\n', '                return uint(withdrawalerr); // success\n', '            }\n', '        }\n', '\n', '        // Save market updates\n', '        market.blockNumber = getBlockNumber();\n', '        market.totalBorrows =  localResults.newTotalBorrows;\n', '        market.supplyRateMantissa = localResults.newSupplyRateMantissa;\n', '        market.supplyIndex = localResults.newSupplyIndex;\n', '        market.borrowRateMantissa = localResults.newBorrowRateMantissa;\n', '        market.borrowIndex = localResults.newBorrowIndex;\n', '\n', '        // Save user updates\n', '        localResults.startingBalance = borrowBalance.principal; // save for use in `BorrowTaken` event\n', '        borrowBalance.principal = localResults.userBorrowUpdated;\n', '        borrowBalance.interestIndex = localResults.newBorrowIndex;\n', '\n', '        originationFeeBalance[msg.sender][asset] += orgFeeBalance;\n', '\n', '        emit BorrowTaken(msg.sender, asset, amount, localResults.startingBalance, localResults.borrowAmountWithFee, localResults.userBorrowUpdated);\n', '\n', '        return uint(Error.NO_ERROR); // success\n', '    }\n', '\n', '    function supplyOriginationFeeAsAdmin(address asset, address user, uint amount, uint newSupplyIndex) private {\n', '        uint originationFeeRepaid = 0;\n', '        if (originationFeeBalance[user][asset] != 0){\n', '            if (amount < originationFeeBalance[user][asset]) {\n', '                originationFeeRepaid = amount;\n', '            } else {\n', '                originationFeeRepaid = originationFeeBalance[user][asset];\n', '            }\n', '            Balance storage balance = supplyBalances[admin][asset];\n', '\n', '            SupplyLocalVars memory localResults; // Holds all our uint calculation results\n', '            Error err; // Re-used for every function call that includes an Error in its return value(s).\n', '\n', '            originationFeeBalance[user][asset] -= originationFeeRepaid;\n', '\n', '            (err, localResults.userSupplyCurrent) = calculateBalance(balance.principal, balance.interestIndex, newSupplyIndex);\n', '\n', '            (err, localResults.userSupplyUpdated) = add(localResults.userSupplyCurrent, originationFeeRepaid);\n', '\n', "            // We calculate the protocol's totalSupply by subtracting the user's prior checkpointed balance, adding user's updated supply\n", '            (err, localResults.newTotalSupply) = addThenSub(markets[asset].totalSupply, localResults.userSupplyUpdated, balance.principal);\n', '\n', '            // Save market updates\n', '            markets[asset].totalSupply =  localResults.newTotalSupply;\n', '\n', '            // Save user updates\n', '            localResults.startingBalance = balance.principal;\n', '            balance.principal = localResults.userSupplyUpdated;\n', '            balance.interestIndex = newSupplyIndex;\n', '\n', '            emit SupplyOrgFeeAsAdmin(admin, asset, originationFeeRepaid, localResults.startingBalance, localResults.userSupplyUpdated);\n', '        }\n', '    }\n', '}']