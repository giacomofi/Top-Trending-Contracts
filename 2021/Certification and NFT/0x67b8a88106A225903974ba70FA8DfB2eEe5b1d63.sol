['// "SPDX-License-Identifier: MIT"\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../vendors/contracts/access/Whitelist.sol";\n', 'import "../vendors/contracts/TxStorage.sol";\n', 'import "../vendors/interfaces/IUniswapOracle.sol";\n', 'import "../vendors/interfaces/IERC20.sol";\n', 'import "../vendors/libraries/SafeMath.sol";\n', 'import "../vendors/libraries/SafeERC20.sol";\n', 'import "../vendors/libraries/TransferHelper.sol";\n', '\n', '\n', 'contract PactBasePool is Whitelist, TxStorage {\n', '    \n', '    using SafeMath for uint;\n', '    using SafeERC20 for IERC20;\n', '\n', '    address public _oracleAddress;\n', '    address public _PACT;\n', '\n', '    uint public _minBuy;\n', '    uint public _price;\n', '\n', '    event Deposit(uint amount, uint price);\n', '    event Withdraw(uint tokensAmount, uint price);\n', '    \n', '    constructor (\n', '        address governanceAddress,\n', '        address oracleAddress,\n', '        address PACT,\n', '        uint minBuy\n', '\n', '    ) public GovernanceOwnable(governanceAddress) {\n', '        require (oracleAddress != address(0), "ORACLE ADDRESS SHOULD BE NOT NULL");\n', '        require (PACT != address(0), "PACT ADDRESS SHOULD BE NOT NULL");\n', '\n', '        _oracleAddress = oracleAddress;\n', '        _PACT = PACT;\n', '        \n', '        _minBuy = minBuy == 0 ? 10000e18 : minBuy;\n', '    }\n', '    \n', '    \n', '    function buylimitsUpdate( uint minLimit) public onlyGovernance {\n', '        _minBuy = minLimit;\n', '    }\n', '    \n', '    \n', '    function changeOracleAddress (address oracleAddress) \n', '      public \n', '      onlyGovernance {\n', '        require (oracleAddress != address(0), "NEW ORACLE ADDRESS SHOULD BE NOT NULL");\n', '\n', '        _oracleAddress = oracleAddress;\n', '    }\n', '\n', '\n', '\tfunction calcPriceEthPact(uint amountInEth) public view returns (uint) {\n', '        uint price = IUniswapOracle(_oracleAddress).consultAB(1e18);\n', '        if (price > 1e18){\n', '            return amountInEth.mul(price.div(1e18));\n', '        }\n', '        return amountInEth.mul(uint(1e18).div(price));\n', '\t}\n', '\n', '\tfunction calcPricePactEth(uint amountInPact) public view returns (uint) {\n', '        uint price = IUniswapOracle(_oracleAddress).consultAB(1e18);\n', '        if (price > 1e18){\n', '            return amountInPact.div(price.div(1e18));\n', '        }\n', '        return amountInPact.div(uint(1e18).div(price));\n', '\t}\n', '\n', '\n', '    function changeEthToToken() public onlyWhitelisted payable {\n', '        uint amountIn = msg.value;\n', '        IUniswapOracle(_oracleAddress).update();\n', '        uint tokensAmount = calcPriceEthPact(amountIn);\n', '        IERC20 PACT = IERC20(_PACT);\n', '\n', '        require(tokensAmount >= _minBuy, "BUY LIMIT");\n', '        require(tokensAmount <= PACT.balanceOf(address(this)), "NOT ENOUGH PACT TOKENS ON BASEPOOl CONTRACT BALANCE");\n', '\n', '        PACT.safeTransfer(msg.sender, tokensAmount);\n', '        transactionAdd(tokensAmount,amountIn);\n', '\n', '        emit Deposit(tokensAmount, amountIn);\n', '    }\n', '    \n', '\n', '    function returnToken(uint index) external onlyWhitelisted {\n', '        IERC20 PACT = IERC20(_PACT);\n', '        checkTrransaction(msg.sender , index);\n', '        (uint amount, uint price,,,) = getTransaction(msg.sender , index);\n', '        \n', '        require(address(this).balance >= price, "NOT ENOUGH ETH ON BASEPOOl CONTRACT BALANCE");\n', '        require(PACT.allowance(msg.sender, address(this)) >= amount, "NOT ENOUGH DELEGATED PACT TOKENS ON DESTINATION BALANCE");\n', '\n', '        closedTransaction(msg.sender, index);\n', '        PACT.safeTransferFrom(msg.sender, amount);\n', '        TransferHelper.safeTransferETH(msg.sender, price);\n', '\n', '        emit Withdraw(amount, price);\n', '    }\n', '\n', '\n', '    function withdrawEthForExpiredTransaction(address to) public onlyGovernance{\n', '        uint actualBalanceOfTransactions = amountOfActualTransactions();\n', '        uint balance = address(this).balance;\n', '        require(balance > actualBalanceOfTransactions,"");\n', '        TransferHelper.safeTransferETH(to,balance.sub(actualBalanceOfTransactions));   \n', '    }\n', '    \n', '}\n', '\n', '// "SPDX-License-Identifier: MIT"\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "../libraries/SafeMath.sol";\n', 'import "./access/GovernanceOwnable.sol";\n', '\n', 'abstract contract TxStorage is GovernanceOwnable{\n', '\tusing SafeMath for uint;\n', '\n', '    uint private expirePeriod = 7776000;\n', '\n', '    struct Transaction {\n', '\t\tuint ammount;\t\t\n', '\t\tuint price;\t\n', '        uint timestamp;\n', '        uint expireTimeStamp;\n', '        bool closed;\n', '\t}\n', '\n', '\n', '    mapping(address => mapping (uint => Transaction)) internal transactionsHistory;\n', '    mapping(address => uint) internal index;\n', '    address [] public userList;\n', '\n', '    function setExparePeriud(uint _epirePeriod) external onlyGovernance payable{\n', '        expirePeriod = _epirePeriod;\n', '    }\n', '\n', '    function transactionAdd(uint ammount, uint price) internal{\n', '       uint timestamp = block.timestamp;\n', '       _transactionAdd(msg.sender, ammount, price, timestamp, timestamp.add(expirePeriod));\n', '    }\n', '\n', '    function closedTransaction(address to, uint _index) internal {\n', '         transactionsHistory[to][_index].closed = true;\n', '    }\n', '\n', '    function _transactionAdd(address to, uint ammount, uint price, uint timestamp, uint expireTimeStamp) internal {\n', '        if (index[to]==0){\n', '            userList.push(to);\n', '        }\n', '        index[to] +=1;\n', '        transactionsHistory[to][index[to]] = Transaction(ammount, price, timestamp, expireTimeStamp, false);\n', '    }\n', '\n', '\n', '    function amountOfActualTransactions() public view returns (uint result) {\n', '        for (uint i = 0; i < userList.length; i++) {\n', '            for (uint a = 0; a <= index[userList[i]]; a++) {\n', '               if (transactionsHistory[userList[i]][a].expireTimeStamp > block.timestamp){\n', '                   result += transactionsHistory[userList[i]][a].price;\n', '               }\n', '            }           \n', '        }\n', '        return result;\n', '    }\n', '\n', '    function getTransaction(address to, uint _index) public view returns (uint ammount, uint price, uint timestamp, uint expireTimeStamp, bool closed) {\n', '       require(transactionsHistory[to][_index].timestamp != 0 , "INDEX OUT OF RANGE");\n', '       ammount = transactionsHistory[to][_index].ammount;\n', '       price =transactionsHistory[to][_index].price;\n', '       timestamp = transactionsHistory[to][_index].timestamp;\n', '       expireTimeStamp = transactionsHistory[to][_index].expireTimeStamp;\n', '       closed = transactionsHistory[to][_index].closed;\n', '    }\n', '\n', '\n', '    function checkTrransaction(address to, uint _index) internal view{\n', '       Transaction memory transaction = transactionsHistory[to][_index];\n', '       require(transaction.timestamp != 0 , "INDEX OUT OF RANGE");\n', '       require(!transaction.closed , "THE TRANSACTION IS CLOSED");\n', '       require(block.timestamp <= transaction.expireTimeStamp, "TRANSACTION TIME EXPIRED");\n', '    }\n', '\n', '\n', '    function getTransactionlastIndex(address to) external view returns (uint ) {\n', '        return index[to];\n', '    }\n', '\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "../../interfaces/IGovernanceOwnable.sol";\n', '\n', 'abstract contract GovernanceOwnable is IGovernanceOwnable {\n', '    address private _governanceAddress;\n', '\n', '    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\n', '\n', '    constructor (address governance_) public {\n', '        require(governance_ != address(0), "Governance address should be not null");\n', '        _governanceAddress = governance_;\n', '        emit GovernanceSetTransferred(address(0), governance_);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current governanceAddress.\n', '     */\n', '    function governance() public view override returns (address) {\n', '        return _governanceAddress;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the governanceAddress.\n', '     */\n', '    modifier onlyGovernance() {\n', '        require(_governanceAddress == msg.sender, "Governance: caller is not the governance");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev SetGovernance of the contract to a new account (`newGovernance`).\n', '     * Can only be called by the current onlyGovernance.\n', '     */\n', '    function setGovernance(address newGovernance) public virtual override onlyGovernance {\n', '        require(newGovernance != address(0), "GovernanceOwnable: new governance is the zero address");\n', '        emit GovernanceSetTransferred(_governanceAddress, newGovernance);\n', '        _governanceAddress = newGovernance;\n', '    }\n', '\n', '}\n', '\n', '// "SPDX-License-Identifier: MIT"\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'import "./GovernanceOwnable.sol";\n', '\n', 'abstract contract Whitelist is GovernanceOwnable {\n', '    mapping(address => bool) whitelist;\n', '    event AddedToWhitelist(address indexed account);\n', '    event RemovedFromWhitelist(address indexed account);\n', '\n', '    modifier onlyWhitelisted() {\n', '        require(isWhitelisted(msg.sender));\n', '        _;\n', '    }\n', '\n', '    function whitelistAdd(address _address) public onlyGovernance {\n', '        whitelist[_address] = true;\n', '        emit AddedToWhitelist(_address);\n', '    }\n', '\n', '    function whitelistRemove(address _address) public onlyGovernance {\n', '        whitelist[_address] = false;\n', '        emit RemovedFromWhitelist(_address);\n', '    }\n', '\n', '    function isWhitelisted(address _address) public view returns(bool) {\n', '        return whitelist[_address];\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '\n', '    function balanceOf(address tokenOwner) external view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) external view returns (uint remaining);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transfer(address to, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface IGovernanceOwnable {\n', '    event GovernanceSetTransferred(address indexed previousGovernance, address indexed newGovernance);\n', '\n', '    function governance() external view returns (address);\n', '    function setGovernance(address newGovernance) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IUniswapOracle {\n', '\tfunction getPair() external view returns (address);\n', '\tfunction update() external;\n', '\tfunction getTimeElapsed(address tokenIn, address tokenOut) external view returns (uint);\n', '    function consultAB(uint amountIn) external view  returns (uint amountOut);\n', '    function consultBA(uint amountIn) external view  returns (uint amountOut);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'import "../interfaces/IERC20.sol";\n', '\n', 'library SafeERC20 {\n', '    function safeSymbol(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeName(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeDecimals(IERC20 token) public view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: Transfer failed");\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return add(a, b, "SafeMath: Add Overflow");\n', '    }\n', '    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, errorMessage);// "SafeMath: Add Overflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: Underflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;// "SafeMath: Underflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mul(a, b, "SafeMath: Mul Overflow");\n', '    }\n', '    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, errorMessage);// "SafeMath: Mul Overflow"\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n", '    }\n', '\n', '    function safeTransfer(address token, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n", '    }\n', '\n', '    function safeTransferFrom(address token, address from, address to, uint value) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', "        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n", '    }\n', '\n', '    function safeTransferETH(address to, uint value) internal {\n', '        (bool success,) = to.call{value:value}(new bytes(0));\n', "        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n", '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']