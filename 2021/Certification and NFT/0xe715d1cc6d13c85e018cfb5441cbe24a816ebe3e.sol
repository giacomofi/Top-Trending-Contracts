['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-20\n', '*/\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts\\AssetInterface.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', 'contract AssetInterface {\n', '    function _performTransferWithReference(\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public returns(bool);\n', '\n', '    function _performTransferToICAPWithReference(\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public returns(bool);\n', '\n', '    function _performApprove(address _spender, uint _value, address _sender)\n', '    public returns(bool);\n', '\n', '    function _performTransferFromWithReference(\n', '        address _from,\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public returns(bool);\n', '\n', '    function _performTransferFromToICAPWithReference(\n', '        address _from,\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public returns(bool);\n', '\n', '    function _performGeneric(bytes memory, address) public payable {\n', '        revert();\n', '    }\n', '}\n', '\n', '// File: contracts\\ERC20Interface.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', 'contract ERC20Interface {\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed from, address indexed spender, uint256 value);\n', '\n', '    function totalSupply() public view returns(uint256 supply);\n', '    function balanceOf(address _owner) public view returns(uint256 balance);\n', '    // solhint-disable-next-line no-simple-event-func-name\n', '    function transfer(address _to, uint256 _value) public returns(bool success);\n', '    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success);\n', '    function approve(address _spender, uint256 _value) public returns(bool success);\n', '    function allowance(address _owner, address _spender) public view returns(uint256 remaining);\n', '\n', '    // function symbol() constant returns(string);\n', '    function decimals() public view returns(uint8);\n', '    // function name() constant returns(string);\n', '}\n', '\n', '// File: contracts\\AssetProxyInterface.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', '\n', 'contract AssetProxyInterface is ERC20Interface {\n', '    function _forwardApprove(address _spender, uint _value, address _sender)\n', '    public returns(bool);\n', '\n', '    function _forwardTransferFromWithReference(\n', '        address _from,\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public returns(bool);\n', '\n', '    function _forwardTransferFromToICAPWithReference(\n', '        address _from,\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public returns(bool);\n', '\n', '    function recoverTokens(ERC20Interface _asset, address _receiver, uint _value)\n', '    public returns(bool);\n', '\n', '    function etoken2() external view returns(address); // To be replaced by the implicit getter;\n', '\n', '    // To be replaced by the implicit getter;\n', '    function etoken2Symbol() external view returns(bytes32);\n', '}\n', '\n', '// File: @orderbook\\smart-contracts-common\\contracts\\Bytes32.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', 'contract Bytes32 {\n', '    function _bytes32(string memory _input) internal pure returns(bytes32 result) {\n', '        assembly {\n', '            result := mload(add(_input, 32))\n', '        }\n', '    }\n', '}\n', '\n', '// File: @orderbook\\smart-contracts-common\\contracts\\ReturnData.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', 'contract ReturnData {\n', '    function _returnReturnData(bool _success) internal pure {\n', '        assembly {\n', '            let returndatastart := 0\n', '            returndatacopy(returndatastart, 0, returndatasize)\n', '            switch _success case 0 { revert(returndatastart, returndatasize) }\n', '                default { return(returndatastart, returndatasize) }\n', '        }\n', '    }\n', '\n', '    function _assemblyCall(address _destination, uint _value, bytes memory _data)\n', '    internal returns(bool success) {\n', '        assembly {\n', '            success := call(gas, _destination, _value, add(_data, 32), mload(_data), 0, 0)\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\Asset.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title EToken2 Asset implementation contract.\n', ' *\n', ' * Basic asset implementation contract, without any additional logic.\n', ' * Every other asset implementation contracts should derive from this one.\n', ' * Receives calls from the proxy, and calls back immediately without arguments modification.\n', ' *\n', ' * Note: all the non constant functions return false instead of throwing in case if state change\n', " * didn't happen yet.\n", ' */\n', 'contract Asset is AssetInterface, Bytes32, ReturnData {\n', '    // Assigned asset proxy contract, immutable.\n', '    AssetProxyInterface public proxy;\n', '\n', '    /**\n', '     * Only assigned proxy is allowed to call.\n', '     */\n', '    modifier onlyProxy() {\n', '        if (address(proxy) == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * Sets asset proxy address.\n', '     *\n', '     * Can be set only once.\n', '     *\n', '     * @param _proxy asset proxy contract address.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function init(AssetProxyInterface _proxy) public returns(bool) {\n', '        if (address(proxy) != address(0)) {\n', '            return false;\n', '        }\n', '        proxy = _proxy;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function _performTransferWithReference(\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public onlyProxy() returns(bool) {\n', '        if (isICAP(_to)) {\n', '            return _transferToICAPWithReference(\n', '                bytes20(_to), _value, _reference, _sender);\n', '        }\n', '        return _transferWithReference(_to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _transferWithReference(\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    internal returns(bool) {\n', '        return proxy._forwardTransferFromWithReference(\n', '            _sender, _to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function _performTransferToICAPWithReference(\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public onlyProxy() returns(bool) {\n', '        return _transferToICAPWithReference(_icap, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _transferToICAPWithReference(\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    internal returns(bool) {\n', '        return proxy._forwardTransferFromToICAPWithReference(\n', '            _sender, _icap, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function _performTransferFromWithReference(\n', '        address _from,\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public onlyProxy() returns(bool) {\n', '        if (isICAP(_to)) {\n', '            return _transferFromToICAPWithReference(\n', '                _from, bytes20(_to), _value, _reference, _sender);\n', '        }\n', '        return _transferFromWithReference(_from, _to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _transferFromWithReference(\n', '        address _from,\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    internal returns(bool) {\n', '        return proxy._forwardTransferFromWithReference(\n', '            _from, _to, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function _performTransferFromToICAPWithReference(\n', '        address _from,\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    public onlyProxy() returns(bool) {\n', '        return _transferFromToICAPWithReference(\n', '            _from, _icap, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _transferFromToICAPWithReference(\n', '        address _from,\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    internal returns(bool) {\n', '        return proxy._forwardTransferFromToICAPWithReference(\n', '            _from, _icap, _value, _reference, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return success.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function _performApprove(address _spender, uint _value, address _sender)\n', '    public onlyProxy() returns(bool) {\n', '        return _approve(_spender, _value, _sender);\n', '    }\n', '\n', '    /**\n', '     * Calls back without modifications.\n', '     *\n', '     * @return success.\n', '     * @dev function is virtual, and meant to be overridden.\n', '     */\n', '    function _approve(address _spender, uint _value, address _sender)\n', '    internal returns(bool) {\n', '        return proxy._forwardApprove(_spender, _value, _sender);\n', '    }\n', '\n', '    /**\n', '     * Passes execution into virtual function.\n', '     *\n', '     * Can only be called by assigned asset proxy.\n', '     *\n', '     * @return bytes32 result.\n', '     * @dev function is final, and must not be overridden.\n', '     */\n', '    function _performGeneric(bytes memory _data, address _sender)\n', '    public payable onlyProxy() {\n', '        _generic(_data, msg.value, _sender);\n', '    }\n', '\n', '    modifier onlyMe() {\n', '        if (address(this) == msg.sender) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    // Most probably the following should never be redefined in child contracts.\n', '    address public genericSender;\n', '\n', '    function _generic(bytes memory _data, uint _value, address _msgSender) internal {\n', '        // Restrict reentrancy.\n', '        require(genericSender == address(0));\n', '        genericSender = _msgSender;\n', '        bool success = _assemblyCall(address(this), _value, _data);\n', '        delete genericSender;\n', '        _returnReturnData(success);\n', '    }\n', '\n', '    // Decsendants should use _sender() instead of msg.sender to properly process proxied calls.\n', '    function _sender() internal view returns(address) {\n', '        return address(this) == msg.sender ? genericSender : msg.sender;\n', '    }\n', '\n', '    // Interface functions to allow specifying ICAP addresses as strings.\n', '    function transferToICAP(string memory _icap, uint _value) public returns(bool) {\n', "        return transferToICAPWithReference(_icap, _value, '');\n", '    }\n', '\n', '    function transferToICAPWithReference(string memory _icap, uint _value, string memory _reference)\n', '    public returns(bool) {\n', '        return _transferToICAPWithReference(\n', '            _bytes32(_icap), _value, _reference, _sender());\n', '    }\n', '\n', '    function transferFromToICAP(address _from, string memory _icap, uint _value)\n', '    public returns(bool) {\n', "        return transferFromToICAPWithReference(_from, _icap, _value, '');\n", '    }\n', '\n', '    function transferFromToICAPWithReference(\n', '        address _from,\n', '        string memory _icap,\n', '        uint _value,\n', '        string memory _reference)\n', '    public returns(bool) {\n', '        return _transferFromToICAPWithReference(\n', '            _from, _bytes32(_icap), _value, _reference, _sender());\n', '    }\n', '\n', '    function isICAP(address _address) public pure returns(bool) {\n', '        bytes20 a = bytes20(_address);\n', "        if (a[0] != 'X' || a[1] != 'E') {\n", '            return false;\n', '        }\n', '        if (uint8(a[2]) < 48 || uint8(a[2]) > 57 || uint8(a[3]) < 48 || uint8(a[3]) > 57) {\n', '            return false;\n', '        }\n', '        for (uint i = 4; i < 20; i++) {\n', '            uint char = uint8(a[i]);\n', '            if (char < 48 || char > 90 || (char > 57 && char < 65)) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts\\Ambi2Enabled.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', 'contract Ambi2 {\n', '    function claimFor(address _address, address _owner) public returns(bool);\n', '    function hasRole(address _from, bytes32 _role, address _to) public view returns(bool);\n', '    function isOwner(address _node, address _owner) public view returns(bool);\n', '}\n', '\n', '\n', 'contract Ambi2Enabled {\n', '    Ambi2 public ambi2;\n', '\n', '    modifier onlyRole(bytes32 _role) {\n', '        if (address(ambi2) != address(0) && ambi2.hasRole(address(this), _role, msg.sender)) {\n', '            _;\n', '        }\n', '    }\n', '\n', '    // Perform only after claiming the node, or claim in the same tx.\n', '    function setupAmbi2(Ambi2 _ambi2) public returns(bool) {\n', '        if (address(ambi2) != address(0)) {\n', '            return false;\n', '        }\n', '\n', '        ambi2 = _ambi2;\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts\\Ambi2EnabledFull.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', '\n', 'contract Ambi2EnabledFull is Ambi2Enabled {\n', '    // Setup and claim atomically.\n', '    function setupAmbi2(Ambi2 _ambi2) public returns(bool) {\n', '        if (address(ambi2) != address(0)) {\n', '            return false;\n', '        }\n', '        if (!_ambi2.claimFor(address(this), msg.sender) &&\n', '            !_ambi2.isOwner(address(this), msg.sender)) {\n', '            return false;\n', '        }\n', '\n', '        ambi2 = _ambi2;\n', '        return true;\n', '    }\n', '}\n', '\n', '// File: contracts\\AssetWithAmbi.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', '\n', '\n', 'contract AssetWithAmbi is Asset, Ambi2EnabledFull {\n', '    modifier onlyRole(bytes32 _role) {\n', '        if (address(ambi2) != address(0) && (ambi2.hasRole(address(this), _role, _sender()))) {\n', '            _;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\AssetWithWhitelist.sol\n', '\n', 'pragma solidity 0.5.8;\n', '\n', '\n', '\n', 'interface INUXAsset {\n', '    function availableBalanceOf(address _holder) external view returns(uint);\n', '    function scheduleReleaseStart() external;\n', '    function transferLock(address _to, uint _value) external;\n', '}\n', '\n', 'contract NUXConstants {\n', '    uint constant NUX = 10**18;\n', '}\n', '\n', 'contract Readable {\n', '    function since(uint _timestamp) internal view returns(uint) {\n', '        if (not(passed(_timestamp))) {\n', '            return 0;\n', '        }\n', '        return block.timestamp - _timestamp;\n', '    }\n', '\n', '    function passed(uint _timestamp) internal view returns(bool) {\n', '        return _timestamp < block.timestamp;\n', '    }\n', '\n', '    function not(bool _condition) internal pure returns(bool) {\n', '        return !_condition;\n', '    }\n', '}\n', '\n', 'library ExtraMath {\n', '    function toUInt64(uint _a) internal pure returns(uint64) {\n', "        require(_a <= uint64(-1), 'uint64 overflow');\n", '        return uint64(_a);\n', '    }\n', '\n', '    function toUInt128(uint _a) internal pure returns(uint128) {\n', "        require(_a <= uint128(-1), 'uint128 overflow');\n", '        return uint128(_a);\n', '    }\n', '}\n', '\n', 'contract EToken2Interface {\n', '    function revokeAsset(bytes32 _symbol, uint _value) public returns(bool);\n', '}\n', '\n', 'contract NUXAsset is AssetWithAmbi, NUXConstants, Readable {\n', '    using SafeMath for uint;\n', '    using ExtraMath for uint;\n', '\n', '    uint public constant PRESALE_RELEASE_PERIOD = 760 days; // ~25 months\n', '    uint64 constant UNSET = uint64(-1);\n', '\n', '    struct ReleaseConfig {\n', '        uint64 preSale;\n', '        uint64 publicSale;\n', '        uint64 publicSaleReleasePeriod;\n', '    }\n', '\n', '    ReleaseConfig private _releaseConfig = ReleaseConfig(UNSET, UNSET, UNSET);\n', '    \n', '    struct Lock {\n', '        uint128 preSale;\n', '        uint128 publicSale;\n', '    }\n', '\n', '    mapping(address => Lock) private _locked;\n', '\n', '    event PreSaleLockTransfer(address _from, address _to, uint _value);\n', '    event PublicSaleLockTransfer(address _from, address _to, uint _value);\n', '    event PreSaleReleaseScheduled(uint _releaseStart);\n', '    event PublicSaleReleaseScheduled(uint _releaseStart, uint _releasePeriod);\n', '    event Unlocked(address _holder);\n', '\n', '    modifier onlyRole(bytes32 _role) {\n', '        require(address(ambi2) != address(0) && (ambi2.hasRole(address(this), _role, _sender())),\n', "            'Access denied');\n", '        _;\n', '    }\n', '\n', '    modifier validateAvailableBalance(address _sender, uint _value) {\n', "        require(availableBalanceOf(_sender) >= _value, 'Insufficient available balance');\n", '        _;\n', '    }\n', '\n', '    modifier validateAllowance(address _from, address _spender, uint _value) {\n', "        require(proxy.allowance(_from, _spender) >= _value, 'Insufficient allowance');\n", '        _;\n', '    }\n', '\n', '    function _migrate(address _holder, uint _lock) private {\n', '        uint128 preSale = uint128(_lock >> 128);\n', '        uint128 publicSale = uint128(_lock);\n', '        _locked[_holder] = Lock(preSale, publicSale);\n', '        if (preSale > 0) {\n', '            emit PreSaleLockTransfer(address(0), _holder, preSale);\n', '        }\n', '        if (publicSale > 0) {\n', '            emit PublicSaleLockTransfer(address(0), _holder, publicSale);\n', '        }\n', '    }\n', '\n', "    function migrate(address[] calldata _holders, uint[] calldata _locks) external onlyRole('admin') {\n", "        require(not(passed(_releaseConfig.preSale)), 'Migration finished');\n", '        uint len = _holders.length;\n', "        require(len == _locks.length, 'Length mismatch');\n", '        for (uint i = 0; i < len; i++) {\n', '            _migrate(_holders[i], _locks[i]);\n', '        }\n', '    }\n', '\n', '    function releaseConfig() public view returns(uint, uint, uint) {\n', '        ReleaseConfig memory config = _releaseConfig;\n', '        return (config.preSale, config.publicSale, config.publicSaleReleasePeriod);\n', '    }\n', '\n', '    function locked(address _holder) public view returns(uint, uint) {\n', '        Lock memory lock = _locked[_holder];\n', '        return (lock.preSale, lock.publicSale);\n', '    }\n', '\n', '    function _calcualteLocked(uint _lock, uint _releaseStart, uint _releasePeriod) private view returns(uint) {\n', '        uint released = (_lock.mul(since(_releaseStart))) / _releasePeriod;\n', '        if (_lock <= released) {\n', '            return 0;\n', '        }\n', '        return _lock - released;\n', '    }\n', '\n', '    function availableBalanceOf(address _holder) public view returns(uint) {\n', '        uint totalBalance = proxy.balanceOf(_holder);\n', '        uint preSaleLock;\n', '        uint publicSaleLock;\n', '        (preSaleLock, publicSaleLock) = locked(_holder);\n', '        uint preSaleReleaseStart;\n', '        uint publicSaleReleaseStart;\n', '        uint publicSaleReleasePeriod;\n', '        (preSaleReleaseStart, publicSaleReleaseStart, publicSaleReleasePeriod) = releaseConfig();\n', '        preSaleLock = _calcualteLocked(preSaleLock, preSaleReleaseStart, PRESALE_RELEASE_PERIOD);\n', '        publicSaleLock = _calcualteLocked(publicSaleLock, publicSaleReleaseStart, publicSaleReleasePeriod);\n', '        uint stillLocked = preSaleLock.add(publicSaleLock);\n', '        if (totalBalance <= stillLocked) {\n', '            return 0;\n', '        }\n', '        return totalBalance - stillLocked;\n', '    }\n', '\n', "    function preSaleScheduleReleaseStart(uint _releaseStart) public onlyRole('admin') {\n", "        require(_releaseConfig.preSale == UNSET, 'Already scheduled');\n", '        uint64 releaseStart = _releaseStart.toUInt64();\n', '        _releaseConfig.preSale = releaseStart;\n', '        emit PreSaleReleaseScheduled(releaseStart);\n', '    }\n', '\n', "    function publicSaleScheduleReleaseStart(uint _releaseStart, uint _releasePeriod) public onlyRole('admin') {\n", "        require(_releaseConfig.publicSale == UNSET, 'Already scheduled');\n", "        require(_releaseConfig.publicSaleReleasePeriod == UNSET, 'Already scheduled');\n", '        _releaseConfig.publicSale = _releaseStart.toUInt64();\n', '        _releaseConfig.publicSaleReleasePeriod = _releasePeriod.toUInt64();\n', '        emit PublicSaleReleaseScheduled(_releaseStart, _releasePeriod);\n', '    }\n', '\n', "    function preSaleTransferLock(address _to, uint _value) public onlyRole('distributor') {\n", '        address _from = _sender();\n', '        uint preSaleLock;\n', '        uint publicSaleLock;\n', '        (preSaleLock, publicSaleLock) = locked(_from);\n', "        require(preSaleLock >= _value, 'Not enough locked');\n", "        require(proxy.balanceOf(_from) >= publicSaleLock.add(preSaleLock), 'Cannot transfer released');\n", '        _locked[_from].preSale = (preSaleLock - _value).toUInt128();\n', '        if (_to == address(0)) {\n', '            _burn(_from, _value);\n', '        } else {\n', '            _locked[_to].preSale = uint(_locked[_to].preSale).add(_value).toUInt128();\n', "            require(super._transferWithReference(_to, _value, '', _from), 'Transfer failed');\n", '        }\n', '        emit PreSaleLockTransfer(_from, _to, _value);\n', '    }\n', '\n', "    function publicSaleTransferLock(address _to, uint _value) public onlyRole('distributor') {\n", '        address _from = _sender();\n', '        uint preSaleLock;\n', '        uint publicSaleLock;\n', '        (preSaleLock, publicSaleLock) = locked(_from);\n', "        require(publicSaleLock >= _value, 'Not enough locked');\n", "        require(proxy.balanceOf(_from) >= publicSaleLock.add(preSaleLock), 'Cannot transfer released');\n", '        _locked[_from].publicSale = (publicSaleLock - _value).toUInt128();\n', '        if (_to == address(0)) {\n', '            _burn(_from, _value);\n', '        } else {\n', '            _locked[_to].publicSale = uint(_locked[_to].publicSale).add(_value).toUInt128();\n', "            require(super._transferWithReference(_to, _value, '', _from), 'Transfer failed');\n", '        }\n', '        emit PublicSaleLockTransfer(_from, _to, _value);\n', '    }\n', '\n', "    function unlock(address _holder) public onlyRole('unlocker') {\n", '        delete _locked[_holder];\n', '        emit Unlocked(_holder);\n', '    }\n', '\n', '    function preSaleTransferLockFrom(address _from, address _to, uint _value)\n', '    public\n', "    onlyRole('distributor')\n", '    validateAllowance(_from, _sender(), _value) {\n', '        uint preSaleLock;\n', '        uint publicSaleLock;\n', '        (preSaleLock, publicSaleLock) = locked(_from);\n', "        require(preSaleLock >= _value, 'Not enough locked');\n", "        require(proxy.balanceOf(_from) >= publicSaleLock.add(preSaleLock), 'Cannot transfer released');\n", '        _locked[_from].preSale = (preSaleLock - _value).toUInt128();\n', '        _locked[_to].preSale = uint(_locked[_to].preSale).add(_value).toUInt128();\n', "        require(super._transferFromWithReference(_from, _to, _value, '', _sender()), 'Transfer failed');\n", '        emit PreSaleLockTransfer(_from, _to, _value);\n', '    }\n', '\n', '    function publicSaleTransferLockFrom(address _from, address _to, uint _value)\n', '    public\n', "    onlyRole('distributor')\n", '    validateAllowance(_from, _sender(), _value) {\n', '        uint preSaleLock;\n', '        uint publicSaleLock;\n', '        (preSaleLock, publicSaleLock) = locked(_from);\n', "        require(publicSaleLock >= _value, 'Not enough locked');\n", "        require(proxy.balanceOf(_from) >= publicSaleLock.add(preSaleLock), 'Cannot transfer released');\n", '        _locked[_from].publicSale = (publicSaleLock - _value).toUInt128();\n', '        _locked[_to].publicSale = uint(_locked[_to].publicSale).add(_value).toUInt128();\n', "        require(super._transferFromWithReference(_from, _to, _value, '', _sender()), 'Transfer failed');\n", '        emit PublicSaleLockTransfer(_from, _to, _value);\n', '    }\n', '\n', '    function _burn(address _from, uint _value) private {\n', "        require(super._transferWithReference(address(this), _value, '', _from), 'Burn transfer failed');\n", "        require(EToken2Interface(proxy.etoken2()).revokeAsset(proxy.etoken2Symbol(), _value), 'Burn failed');\n", '    }\n', '\n', '    function _transferWithReference(\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    internal validateAvailableBalance(_sender, _value) returns(bool) {\n', '        return super._transferWithReference(_to, _value, _reference, _sender);\n', '    }\n', '\n', '    function _transferFromWithReference(\n', '        address _from,\n', '        address _to,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    internal\n', '    validateAvailableBalance(_from, _value)\n', '    validateAllowance(_from, _sender, _value)\n', '    returns(bool) {\n', '        return super._transferFromWithReference(_from, _to, _value, _reference, _sender);\n', '    }\n', '\n', '    function _transferToICAPWithReference(\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    internal validateAvailableBalance(_sender, _value) returns(bool) {\n', '        return super._transferToICAPWithReference(_icap, _value, _reference, _sender);\n', '    }\n', '\n', '    function _transferFromToICAPWithReference(\n', '        address _from,\n', '        bytes32 _icap,\n', '        uint _value,\n', '        string memory _reference,\n', '        address _sender)\n', '    internal\n', '    validateAvailableBalance(_from, _value)\n', '    validateAllowance(_from, _sender, _value)\n', '    returns(bool) {\n', '        return super._transferFromToICAPWithReference(_from, _icap, _value, _reference, _sender);\n', '    }\n', '}']