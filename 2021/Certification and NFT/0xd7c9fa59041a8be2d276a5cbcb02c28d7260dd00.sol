['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '// SPDX-License-Identifier: FIZZ\n', '\n', '\n', 'pragma solidity =0.8.4;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract SafeMath {\n', '    \n', '    \n', '        function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '    \n', '    \n', '       function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '\n', '       function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '            require(b <= a, errorMessage);\n', '            uint256 c = a - b;\n', '            return c;\n', '        }\n', '\n', '\n', '        function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '\n', '    \n', '      function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '            return div(a, b, "SafeMath: division by zero");\n', '        }\n', '        \n', '    \n', '    \n', '    \n', '        function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '}\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'contract Context {\n', '    // Empty internal constructor, to prevent people from mistakenly deploying\n', '    // an instance of this contract, which should be used via inheritance.\n', '    constructor ()  { }\n', '    // solhint-disable-previous-line no-empty-blocks\n', '\n', '    function _msgSender() internal view returns (address ) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '\n', 'abstract contract ERC20Interface {\n', '    function owner() public view  virtual returns (address);\n', '    function totalSupply() public view virtual returns (uint);\n', '    function soldtokensvalue()  public view virtual returns (uint);\n', '    function balanceOf(address tokenOwner) public view virtual returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public view virtual returns (uint remaining);\n', '    function transfer(address to, uint tokens) public virtual returns (bool success);\n', '    function approve(address spender, uint tokens) public virtual returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\n', '\n', '    // event Transfer(address indexed from, address indexed to, uint tokens);\n', '    // event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '\n', 'contract Ownable  {\n', '  address public _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  constructor ()  {\n', '   \n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), msg.sender);\n', '  }\n', '\n', '\n', '  modifier onlyOwner() {\n', '    require(_owner == msg.sender, "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  \n', '  function renounceOwnership() public onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '\n', '  function transferOwnership(address newOwner) public onlyOwner {\n', '    _transferOwnership(newOwner);\n', '  }\n', '\n', '\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', 'contract FIZZ is ERC20Interface, SafeMath ,Ownable,Context{\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '    uint  soldtokens;\n', '    bool lock;\n', '    \n', '    \n', '\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '    \n', '    // Triggered whenever approve(address _spender, uint256 _value) is called.\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '    // Triggered when tokens are transferred.\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    \n', '    constructor ()  {\n', '        symbol = "FIZZ";\n', '        name = "FIZZ COIN";\n', '        decimals = 18;\n', '        _totalSupply = 1000000000 *1e18;\n', '        balances[msg.sender] = _totalSupply; \n', '      \n', '        \n', '    }\n', '         /**\n', '   * @dev can act as protection for reentracy style attacks \n', '   * .\n', '   */\n', '\n', '      /**\n', '   * @dev can view soldtokens \n', '   * Can only be called by the current owner.\n', '   */\n', '    \n', '    function soldtokensvalue()public  override view returns(uint){\n', '        return soldtokens;\n', '    }\n', '    \n', '         /**\n', '   * @dev can view totalSupply of tokens \n', '   */\n', '    \n', '    function totalSupply() public override view returns (uint256) {\n', '      return _totalSupply;\n', '    }\n', '\n', '  function owner() public override  view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '\n', '         /**\n', '   * @dev can transfer tokens to specific address \n', '   * function reverts back if sender addresss is invalid or address is zero\n', '   */\n', '    function transfer(address to, uint tokens) public  override returns (bool success) {\n', '        require(to != address(0), "invalid reciever address");\n', '        require(balances[msg.sender] >= tokens && safeAdd (balances[to],tokens) >= balances[to]);\n', '        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n', '        balances[to] = safeAdd(balances[to], tokens);\n', '         if(msg.sender==_owner){\n', '            soldtokens=safeAdd(soldtokens,tokens);\n', '        }\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '    \n', '             /**\n', '   * @dev can approve tokens for another account to sell\n', '   * function reverts back if sender addresss is invalid or address is zero\n', '   */\n', '\n', '    function approve(address spender, uint tokens) public override returns (bool success) {\n', '         require(spender != address(0), "invalid spender address");\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // function balanceOf(address _user) public override view returns (uint256 balance) {\n', '    //     return balances[owner];\n', '    // }\n', '    \n', '    \n', '      function balanceOf(address user) public override view returns (uint256 balance) {\n', '        return balances[user];\n', '    }\n', '\n', '             /**\n', '   * @dev can transfer tokens from specific address to specific address if having enough token allowances\n', '   * function reverts back if sender addresss is invalid or address is zero\n', '   */\n', '    function transferFrom(address from, address to, uint tokens) public  override returns (bool success) {\n', '         require(from != address(0), "invalid sender address");\n', '         require(to != address(0), "invalid reciever address");\n', '          require(balances[from] >= tokens &&  safeAdd( balances[to],tokens) >= balances[to],"insufficient funds");\n', '           allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n', '           balances[from] = safeSub(balances[from], tokens);\n', '           balances[to] = safeAdd(balances[to], tokens);\n', '               if(from==_owner){\n', '                soldtokens=safeAdd(soldtokens,tokens);\n', '            }\n', '        emit Transfer(from, to, tokens);\n', '           \n', '        return true;\n', '    }\n', '    \n', '     //to check owner ether balance \n', '     function getOwneretherBalance()public  view returns (uint) {\n', '        return _owner.balance;\n', '    }\n', '    \n', '    //to check the user etherbalance\n', '     function etherbalance(address _account)public  view returns (uint) {\n', '        return _account.balance;\n', '    }\n', '\n', '\n', '    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '}']