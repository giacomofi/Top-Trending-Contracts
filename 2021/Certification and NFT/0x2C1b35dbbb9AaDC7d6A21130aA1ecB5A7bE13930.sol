['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-01\n', '*/\n', '\n', 'pragma solidity ^0.4.24;\n', 'interface IExchangeFormula {\n', '    function calculatePurchaseReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _depositAmount) external view returns (uint256);\n', '    function calculateSaleReturn(uint256 _supply, uint256 _connectorBalance, uint32 _connectorWeight, uint256 _sellAmount) external view returns (uint256);\n', '}\n', '\n', 'interface ITradeableAsset {\n', '    function totalSupply() external view returns (uint256);\n', '    function approve(address spender, uint tokens) external returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) external returns (bool success);\n', '    function decimals() external view returns (uint256);\n', '    function transfer(address _to, uint256 _value) external;\n', '    function balanceOf(address _address) external view returns (uint256);\n', '}\n', '\n', 'interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n', '\n', 'contract Administered {\n', '    address public creator;\n', '\n', '    mapping (address => bool) public admins;\n', '\n', '    constructor() public {\n', '        creator = msg.sender;\n', '        admins[creator] = true;\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(creator == msg.sender);\n', '        _;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(admins[msg.sender] || creator == msg.sender);\n', '        _;\n', '    }\n', '\n', '    function grantAdmin(address newAdmin) onlyOwner  public {\n', '        _grantAdmin(newAdmin);\n', '    }\n', '\n', '    function _grantAdmin(address newAdmin) internal\n', '    {\n', '        admins[newAdmin] = true;\n', '    }\n', '\n', '    function changeOwner(address newOwner) onlyOwner public {\n', '        creator = newOwner;\n', '    }\n', '\n', '    function revokeAdminStatus(address user) onlyOwner public {\n', '        admins[user] = false;\n', '    }\n', '}\n', '\n', 'contract ExchangerV4 is Administered, tokenRecipient {\n', '    bool public enabled = false;\n', '\n', '    ITradeableAsset public tokenContract;\n', '    IExchangeFormula public formulaContract;\n', '    \n', '    uint32 public weight;\n', '    uint32 public fee=5000; //0.5%\n', '    uint256 public uncirculatedSupplyCount=0;\n', '    uint256 public collectedFees=0;\n', '    uint256 public virtualReserveBalance=0;\n', '\n', '    uint public thresholdSendToSafeWallet = 100000000000000000; \n', '    uint public sendToSafeWalletPercentage = 10; \n', '\n', '    constructor(address _token,\n', '                uint32 _weight,\n', '                address _formulaContract) {\n', '        require (_weight > 0 && weight <= 1000000);\n', '\n', '        weight = _weight;\n', '        tokenContract = ITradeableAsset(_token);\n', '        formulaContract = IExchangeFormula(_formulaContract);\n', '    }\n', '\n', '    event Buy(address indexed purchaser, uint256 amountInWei, uint256 amountInToken);\n', '    event Sell(address indexed seller, uint256 amountInToken, uint256 amountInWei);\n', '\n', '    function depositTokens(uint amount) onlyOwner public {\n', '        tokenContract.transferFrom(msg.sender, this, amount);\n', '    }\n', '\n', '    function depositEther() onlyOwner public payable {\n', '    //return getQuotePrice();\n', '    }\n', '\n', '    function withdrawTokens(uint amount) onlyOwner public {\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '\n', '    function withdrawEther(uint amountInWei) onlyOwner public {\n', '        msg.sender.transfer(amountInWei); //Transfers in wei\n', '    }\n', '\n', '    function extractFees(uint amountInWei) onlyAdmin public {\n', '        require (amountInWei <= collectedFees);\n', '        msg.sender.transfer(amountInWei);\n', '    }\n', '\n', '    function enable() onlyAdmin public {\n', '        enabled = true;\n', '    }\n', '\n', '    function disable() onlyAdmin public {\n', '        enabled = false;\n', '    }\n', '\n', '    function setReserveWeight(uint ppm) onlyAdmin public {\n', '        require (ppm>0 && ppm<=1000000);\n', '        weight = uint32(ppm);\n', '    }\n', '\n', '    function setFee(uint ppm) onlyAdmin public {\n', '        require (ppm >= 0 && ppm <= 1000000);\n', '        fee = uint32(ppm);\n', '    }\n', '\n', '    function setUncirculatedSupplyCount(uint newValue) onlyAdmin public {\n', '        require (newValue > 0);\n', '        uncirculatedSupplyCount = uint256(newValue);\n', '    }\n', '\n', '    function setVirtualReserveBalance(uint256 amountInWei) onlyAdmin public {\n', '        virtualReserveBalance = amountInWei;\n', '    }\n', '\n', '    function getReserveBalances() public view returns (uint256, uint256) {\n', '        return (tokenContract.balanceOf(this), address(this).balance+virtualReserveBalance);\n', '    }\n', '\n', '    function getPurchasePrice(uint256 amountInWei) public view returns(uint) {\n', '        uint256 purchaseReturn = formulaContract.calculatePurchaseReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            address(this).balance + virtualReserveBalance,\n', '            weight,\n', '            amountInWei\n', '        );\n', '\n', '        purchaseReturn = (purchaseReturn - ((purchaseReturn * fee) / 1000000));\n', '\n', '        if (purchaseReturn > tokenContract.balanceOf(this)){\n', '            return tokenContract.balanceOf(this);\n', '        }\n', '        return purchaseReturn;\n', '    }\n', '\n', '    function getSalePrice(uint256 tokensToSell) public view returns(uint) {\n', '        uint256 saleReturn = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            address(this).balance + virtualReserveBalance,\n', '            weight,\n', '            tokensToSell\n', '        );\n', '        saleReturn = (saleReturn - ((saleReturn * fee) / 1000000));\n', '        if (saleReturn > address(this).balance) {\n', '            return address(this).balance;\n', '        }\n', '        return saleReturn;\n', '    }\n', '\n', '    function buy(uint minPurchaseReturn) public payable {\n', '        uint amount = formulaContract.calculatePurchaseReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '            (address(this).balance + virtualReserveBalance) - msg.value,\n', '            weight,\n', '            msg.value);\n', '        amount = (amount - ((amount * fee) / 1000000));\n', '\n', '        require (enabled);\n', '        require (amount >= minPurchaseReturn);\n', '        require (tokenContract.balanceOf(this) >= amount);\n', '\n', '        if(msg.value > thresholdSendToSafeWallet){\n', '            uint transferToSafeWallet = msg.value * sendToSafeWalletPercentage / 100;\n', '            creator.transfer(transferToSafeWallet);\n', '            virtualReserveBalance += transferToSafeWallet;\n', '        }\n', '\n', '        collectedFees += (msg.value * fee) / 1000000;\n', '\n', '        emit Buy(msg.sender, msg.value, amount);\n', '        tokenContract.transfer(msg.sender, amount);\n', '    }\n', '\n', '    function sell(uint quantity, uint minSaleReturn) public {\n', '        uint amountInWei = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply()- uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '             address(this).balance + virtualReserveBalance,\n', '             weight,\n', '             quantity\n', '        );\n', '        amountInWei = (amountInWei - ((amountInWei * fee) / 1000000));\n', '\n', '        require (enabled);\n', '        require (amountInWei >= minSaleReturn);\n', '        require (amountInWei <= address(this).balance);\n', '        require (tokenContract.transferFrom(msg.sender, this, quantity));\n', '\n', '        collectedFees += (amountInWei * fee) / 1000000;\n', '\n', '        emit Sell(msg.sender, quantity, amountInWei);\n', '        msg.sender.transfer(amountInWei);\n', '    }\n', '\n', '    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external {\n', '        sellOneStep(_value, 0, _from);\n', '    }\n', '\n', '    function sellOneStep(uint quantity, uint minSaleReturn, address seller) public {\n', '        uint amountInWei = formulaContract.calculateSaleReturn(\n', '            (tokenContract.totalSupply() - uncirculatedSupplyCount) - tokenContract.balanceOf(this),\n', '             address(this).balance + virtualReserveBalance,\n', '             weight,\n', '             quantity\n', '        );\n', '        amountInWei = (amountInWei - ((amountInWei * fee) / 1000000));\n', '\n', '        require (enabled);\n', '        require (amountInWei >= minSaleReturn);\n', '        require (amountInWei <= address(this).balance);\n', '        require (tokenContract.transferFrom(seller, this, quantity));\n', '\n', '        collectedFees += (amountInWei * fee) / 1000000;\n', '\n', '        emit Sell(seller, quantity, amountInWei);\n', '        seller.transfer(amountInWei);\n', '    }\n', '\n', '    function setSendToSafeWalletPercentage(uint newValue) onlyOwner public {\n', '        require (newValue > 0);\n', '        sendToSafeWalletPercentage = uint(newValue);\n', '    }\n', '\n', '    function setThresholdSendToSafeWallet(uint256 amountInWei) onlyOwner public {\n', '        thresholdSendToSafeWallet = amountInWei;\n', '    }\n', '\n', '}']