['pragma solidity ^0.6.6;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./IACOToken.sol";\n', 'import "./IWETH.sol";\n', 'import "./ACOAssetHelper.sol";\n', '\n', 'contract ACOWriterV2 {\n', '    \n', '    address immutable public weth;\n', '    address immutable public zrxExchange;\n', '    \n', '    bool internal _notEntered;\n', '\n', '    modifier nonReentrant() {\n', '        require(_notEntered, "ACOWriter::Reentry");\n', '        _notEntered = false;\n', '        _;\n', '        _notEntered = true;\n', '    }\n', '    \n', '    constructor(address _weth, address _zrxExchange) public {\n', '        weth = _weth;\n', '        zrxExchange = _zrxExchange;\n', '        _notEntered = true;\n', '    }\n', '    \n', '    receive() external payable {\n', '        require(tx.origin != msg.sender, "ACOWriter:: Not allowed");\n', '    }\n', '    \n', '    function write(\n', '        address acoToken, \n', '        uint256 collateralAmount, \n', '        bytes memory zrxExchangeData\n', '    ) \n', '        nonReentrant \n', '        public \n', '        payable \n', '    {\n', '        require(msg.value > 0,  "ACOWriter::write: Invalid msg value");\n', '        require(collateralAmount > 0,  "ACOWriter::write: Invalid collateral amount");\n', '        \n', '        address _collateral = IACOToken(acoToken).collateral();\n', '        if (ACOAssetHelper._isEther(_collateral)) {\n', '            IACOToken(acoToken).mintToPayable{value: collateralAmount}(msg.sender);\n', '        } else {\n', '            ACOAssetHelper._callTransferFromERC20(_collateral, msg.sender, address(this), collateralAmount);\n', '            ACOAssetHelper._setAssetInfinityApprove(_collateral, address(this), acoToken, collateralAmount);\n', '            IACOToken(acoToken).mintTo(msg.sender, collateralAmount);\n', '        }\n', '        \n', '        _sellACOTokens(acoToken, zrxExchangeData);\n', '    }\n', '    \n', '    function _sellACOTokens(address acoToken, bytes memory exchangeData) internal {\n', '        uint256 acoBalance = ACOAssetHelper._getAssetBalanceOf(acoToken, address(this));\n', '        ACOAssetHelper._setAssetInfinityApprove(acoToken, address(this), zrxExchange, acoBalance);\n', '        (bool success,) = zrxExchange.call{value: address(this).balance}(exchangeData);\n', '        require(success, "ACOWriter::_sellACOTokens: Error on call the exchange");\n', '        \n', '        address token = IACOToken(acoToken).strikeAsset();\n', '        if(ACOAssetHelper._isEther(token)) {\n', '            uint256 wethBalance = ACOAssetHelper._getAssetBalanceOf(weth, address(this));\n', '            if (wethBalance > 0) {\n', '                IWETH(weth).withdraw(wethBalance);\n', '            }\n', '        } else {\n', '            uint256 remaining = ACOAssetHelper._getAssetBalanceOf(token, address(this));\n', '            if (remaining > 0) {\n', '                ACOAssetHelper._callTransferERC20(token, msg.sender, remaining);\n', '            }\n', '        }\n', '        \n', '        if (address(this).balance > 0) {\n', '            msg.sender.transfer(address(this).balance);\n', '        }\n', '    }\n', '}']