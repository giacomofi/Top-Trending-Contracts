['// SPDX-License-Identifier: MIT\n', '\n', 'import "./Context.sol";\n', 'import "./SafeMath.sol";\n', 'import "./Ownable.sol";\n', 'import "./IERC20.sol";\n', 'import "./IERC1155.sol";\n', 'import "./ReentrancyGuard.sol";\n', 'import "./ERC1155Holder.sol";\n', 'import "./INFTSale.sol";\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'contract FlatPriceSale is Context, Ownable, ReentrancyGuard, ERC1155Holder, INFTSale {\n', '    using SafeMath for uint256;\n', '\n', '    constructor(address nftToken, address payable _authAddress) {\n', '        NFT_TOKEN = IERC1155(nftToken);\n', '        nftAddress = nftToken;\n', '        authAddress = _authAddress;\n', '    }\n', '\n', '    event Buy(\n', '        uint256 indexed saleId,\n', '        uint256 nftID,\n', '        uint256 quantity,\n', '        address indexed account\n', '    );\n', '\n', '    address payable public authAddress;\n', '    address public nftAddress;\n', '    IERC1155 private NFT_TOKEN;\n', '\n', '    struct NFTSetSale {\n', '        uint32 saleId;\n', '        uint256 timestamp;\n', '        address buyer;\n', '    }\n', '\n', '    mapping(uint32 => NFTSetSale) public sales;\n', '    uint32 public totalSales;\n', '\n', '    struct NFTSet {\n', '        address payable artist;\n', '        uint256 startTime;\n', '        uint32 quantity;\n', '        uint32 sold;\n', '        uint32 feePercent;\n', '        uint256 price;\n', '        bool isPaused;\n', '    }\n', '\n', '    mapping(uint256 => NFTSet) public sets;\n', '\n', '    function stake(\n', '        uint256 nftID,\n', '        address payable artist,\n', '        uint32 quantity,\n', '        uint256 price,\n', '        uint256 startTime,\n', '        bytes calldata data\n', '    ) override public nonReentrant {\n', '        require(\n', '            _msgSender() == nftAddress,\n', '            "Can only stake via NFT_FM contract."\n', '        );\n', '        require(\n', '            sets[nftID].artist == address(0),\n', '            "Sale already exists for that NFT."\n', '        );\n', '        uint32 feePercent;\n', '        (feePercent) = abi.decode(data, (uint32));\n', '        sets[nftID] = NFTSet(artist, startTime, quantity, 0, feePercent, price, false);\n', '    }\n', '\n', '    function buyNFT(uint256 nftID, uint32 quantity) public payable nonReentrant {\n', '        NFTSet memory set = sets[nftID];\n', '        require(set.artist != address(0), "Sale does not exist.");\n', '        require(quantity > 0, "Must select an quantity of tokens");\n', '        require(block.timestamp > set.startTime, "Sale has not started yet.");\n', '        require(!set.isPaused, "Sale is paused.");\n', '        require(set.sold + quantity >= quantity, "Addition overflow");\n', '        require(set.sold + quantity <= set.quantity, "Insufficient stock.");\n', '\n', '        totalSales++;\n', '        sales[totalSales] = NFTSetSale(\n', '            totalSales,\n', '            block.timestamp,\n', '            _msgSender()\n', '        );\n', '\n', '        uint256 cost = set.price.mul(quantity);\n', '        uint256 fee = cost.mul(set.feePercent).div(100);\n', '        uint256 artistCut = cost.mul(100 - set.feePercent).div(100);\n', '        require(artistCut + fee == msg.value, "Exact change required.");\n', '        sets[nftID].sold = set.sold + quantity;\n', '        sets[nftID].artist.transfer(artistCut);\n', '        authAddress.transfer(fee);\n', '        NFT_TOKEN.safeTransferFrom(\n', '            address(this),\n', '            _msgSender(),\n', '            nftID,\n', '            quantity,\n', '            ""\n', '        );\n', '        emit Buy(totalSales, nftID, quantity, _msgSender());\n', '    }\n', '\n', '    function setAuthAddress(address payable _address) public onlyOwner {\n', '        authAddress = _address;\n', '    }\n', '\n', '    function setSetPrice(uint256 nftID, uint256 price) public {\n', '        require(sets[nftID].artist == _msgSender(), "You are not the artist.");\n', '        sets[nftID].price = price;\n', '    }\n', '\n', '    function pauseSale(uint256 nftID) public {\n', '        require(sets[nftID].artist == _msgSender(), "You are not the artist.");\n', '        sets[nftID].isPaused = true;\n', '    }\n', '\n', '    function unpauseSale(uint256 nftID) public {\n', '        require(sets[nftID].artist == _msgSender(), "You are not the artist.");\n', '        sets[nftID].isPaused = false;\n', '    }\n', '}']