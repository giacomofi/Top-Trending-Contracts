['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-08\n', '*/\n', '\n', '// Sources flattened with hardhat v2.4.0 https://hardhat.org\n', '\n', '// File contracts/auxiliary/interfaces/v0.8.4/IERC20Aux.sol\n', '\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20Aux {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// File contracts/auxiliary/interfaces/v0.8.4/IApi3Token.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IApi3Token is IERC20Aux {\n', '    event MinterStatusUpdated(\n', '        address indexed minterAddress,\n', '        bool minterStatus\n', '        );\n', '\n', '    event BurnerStatusUpdated(\n', '        address indexed burnerAddress,\n', '        bool burnerStatus\n', '        );\n', '\n', '    function updateMinterStatus(\n', '        address minterAddress,\n', '        bool minterStatus\n', '        )\n', '        external;\n', '\n', '    function updateBurnerStatus(bool burnerStatus)\n', '        external;\n', '\n', '    function mint(\n', '        address account,\n', '        uint256 amount\n', '        )\n', '        external;\n', '\n', '    function burn(uint256 amount)\n', '        external;\n', '\n', '    function getMinterStatus(address minterAddress)\n', '        external\n', '        view\n', '        returns (bool minterStatus);\n', '\n', '    function getBurnerStatus(address burnerAddress)\n', '        external\n', '        view\n', '        returns (bool burnerStatus);\n', '}\n', '\n', '\n', '// File contracts/interfaces/IStateUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IStateUtils {\n', '    event SetDaoApps(\n', '        address agentAppPrimary,\n', '        address agentAppSecondary,\n', '        address votingAppPrimary,\n', '        address votingAppSecondary\n', '        );\n', '\n', '    event SetClaimsManagerStatus(\n', '        address indexed claimsManager,\n', '        bool indexed status\n', '        );\n', '\n', '    event SetStakeTarget(uint256 stakeTarget);\n', '\n', '    event SetMaxApr(uint256 maxApr);\n', '\n', '    event SetMinApr(uint256 minApr);\n', '\n', '    event SetUnstakeWaitPeriod(uint256 unstakeWaitPeriod);\n', '\n', '    event SetAprUpdateStep(uint256 aprUpdateStep);\n', '\n', '    event SetProposalVotingPowerThreshold(uint256 proposalVotingPowerThreshold);\n', '\n', '    event UpdatedLastProposalTimestamp(\n', '        address indexed user,\n', '        uint256 lastProposalTimestamp,\n', '        address votingApp\n', '        );\n', '\n', '    function setDaoApps(\n', '        address _agentAppPrimary,\n', '        address _agentAppSecondary,\n', '        address _votingAppPrimary,\n', '        address _votingAppSecondary\n', '        )\n', '        external;\n', '\n', '    function setClaimsManagerStatus(\n', '        address claimsManager,\n', '        bool status\n', '        )\n', '        external;\n', '\n', '    function setStakeTarget(uint256 _stakeTarget)\n', '        external;\n', '\n', '    function setMaxApr(uint256 _maxApr)\n', '        external;\n', '\n', '    function setMinApr(uint256 _minApr)\n', '        external;\n', '\n', '    function setUnstakeWaitPeriod(uint256 _unstakeWaitPeriod)\n', '        external;\n', '\n', '    function setAprUpdateStep(uint256 _aprUpdateStep)\n', '        external;\n', '\n', '    function setProposalVotingPowerThreshold(uint256 _proposalVotingPowerThreshold)\n', '        external;\n', '\n', '    function updateLastProposalTimestamp(address userAddress)\n', '        external;\n', '\n', '    function isGenesisEpoch()\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '\n', '// File contracts/StateUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title Contract that keeps state variables\n', 'contract StateUtils is IStateUtils {\n', '    struct Checkpoint {\n', '        uint32 fromBlock;\n', '        uint224 value;\n', '    }\n', '\n', '    struct AddressCheckpoint {\n', '        uint32 fromBlock;\n', '        address _address;\n', '    }\n', '\n', '    struct Reward {\n', '        uint32 atBlock;\n', '        uint224 amount;\n', '        uint256 totalSharesThen;\n', '        uint256 totalStakeThen;\n', '    }\n', '\n', '    struct User {\n', '        Checkpoint[] shares;\n', '        Checkpoint[] delegatedTo;\n', '        AddressCheckpoint[] delegates;\n', '        uint256 unstaked;\n', '        uint256 vesting;\n', '        uint256 unstakeAmount;\n', '        uint256 unstakeShares;\n', '        uint256 unstakeScheduledFor;\n', '        uint256 lastDelegationUpdateTimestamp;\n', '        uint256 lastProposalTimestamp;\n', '    }\n', '\n', '    struct LockedCalculation {\n', '        uint256 initialIndEpoch;\n', '        uint256 nextIndEpoch;\n', '        uint256 locked;\n', '    }\n', '\n', '    /// @notice Length of the epoch in which the staking reward is paid out\n', '    /// once. It is hardcoded as 7 days.\n', '    /// @dev In addition to regulating reward payments, this variable is used\n', '    /// for two additional things:\n', '    /// (1) After a user makes a proposal, they cannot make a second one\n', '    /// before `EPOCH_LENGTH` has passed\n', '    /// (2) After a user updates their delegation status, they have to wait\n', '    /// `EPOCH_LENGTH` before updating it again\n', '    uint256 public constant EPOCH_LENGTH = 1 weeks;\n', '\n', '    /// @notice Number of epochs before the staking rewards get unlocked.\n', '    /// Hardcoded as 52 epochs, which approximately corresponds to a year with\n', '    /// an `EPOCH_LENGTH` of 1 week.\n', '    uint256 public constant REWARD_VESTING_PERIOD = 52;\n', '\n', '    // All percentage values are represented as 1e18 = 100%\n', '    uint256 internal constant ONE_PERCENT = 1e18 / 100;\n', '    uint256 internal constant HUNDRED_PERCENT = 1e18;\n', '\n', '    // To assert that typecasts do not overflow\n', '    uint256 internal constant MAX_UINT32 = 2**32 - 1;\n', '    uint256 internal constant MAX_UINT224 = 2**224 - 1;\n', '\n', '    /// @notice Epochs are indexed as `block.timestamp / EPOCH_LENGTH`.\n', '    /// `genesisEpoch` is the index of the epoch in which the pool is deployed.\n', '    /// @dev No reward gets paid and proposals are not allowed in the genesis\n', '    /// epoch\n', '    uint256 public immutable genesisEpoch;\n', '\n', '    /// @notice API3 token contract\n', '    IApi3Token public immutable api3Token;\n', '\n', '    /// @notice TimelockManager contract\n', '    address public immutable timelockManager;\n', '\n', '    /// @notice Address of the primary Agent app of the API3 DAO\n', '    /// @dev Primary Agent can be operated through the primary Api3Voting app.\n', '    /// The primary Api3Voting app requires a higher quorum by default, and the\n', '    /// primary Agent is more privileged.\n', '    address public agentAppPrimary;\n', '\n', '    /// @notice Address of the secondary Agent app of the API3 DAO\n', '    /// @dev Secondary Agent can be operated through the secondary Api3Voting\n', '    /// app. The secondary Api3Voting app requires a lower quorum by default,\n', '    /// and the primary Agent is less privileged.\n', '    address public agentAppSecondary;\n', '\n', '    /// @notice Address of the primary Api3Voting app of the API3 DAO\n', '    /// @dev Used to operate the primary Agent\n', '    address public votingAppPrimary;\n', '\n', '    /// @notice Address of the secondary Api3Voting app of the API3 DAO\n', '    /// @dev Used to operate the secondary Agent\n', '    address public votingAppSecondary;\n', '\n', '    /// @notice Mapping that keeps the claims manager statuses of addresses\n', '    /// @dev A claims manager is a contract that is authorized to pay out\n', '    /// claims from the staking pool, effectively slashing the stakers. The\n', '    /// statuses are kept as a mapping to support multiple claims managers.\n', '    mapping(address => bool) public claimsManagerStatus;\n', '\n', '    /// @notice Records of rewards paid in each epoch\n', "    /// @dev `.atBlock` of a past epoch's reward record being `0` means no\n", '    /// reward was paid for that epoch\n', '    mapping(uint256 => Reward) public epochIndexToReward;\n', '\n', '    /// @notice Epoch index of the most recent reward\n', '    uint256 public epochIndexOfLastReward;\n', '\n', '    /// @notice Total number of tokens staked at the pool\n', '    uint256 public totalStake;\n', '\n', '    /// @notice Stake target the pool will aim to meet in percentages of the\n', '    /// total token supply. The staking rewards increase if the total staked\n', '    /// amount is below this, and vice versa.\n', '    /// @dev Default value is 50% of the total API3 token supply. This\n', '    /// parameter is governable by the DAO.\n', '    uint256 public stakeTarget = ONE_PERCENT * 50;\n', '\n', '    /// @notice Minimum APR (annual percentage rate) the pool will pay as\n', '    /// staking rewards in percentages\n', '    /// @dev Default value is 2.5%. This parameter is governable by the DAO.\n', '    uint256 public minApr = ONE_PERCENT * 25 / 10;\n', '\n', '    /// @notice Maximum APR (annual percentage rate) the pool will pay as\n', '    /// staking rewards in percentages\n', '    /// @dev Default value is 75%. This parameter is governable by the DAO.\n', '    uint256 public maxApr = ONE_PERCENT * 75;\n', '\n', '    /// @notice Steps in which APR will be updated in percentages\n', '    /// @dev Default value is 1%. This parameter is governable by the DAO.\n', '    uint256 public aprUpdateStep = ONE_PERCENT;\n', '\n', '    /// @notice Users need to schedule an unstake and wait for\n', '    /// `unstakeWaitPeriod` before being able to unstake. This is to prevent\n', '    /// the stakers from frontrunning insurance claims by unstaking to evade\n', '    /// them, or repeatedly unstake/stake to work around the proposal spam\n', '    /// protection. The tokens awaiting to be unstaked during this period do\n', '    /// not grant voting power or rewards.\n', '    /// @dev This parameter is governable by the DAO, and the DAO is expected\n', '    /// to set this to a value that is large enough to allow insurance claims\n', '    /// to be resolved.\n', '    uint256 public unstakeWaitPeriod = EPOCH_LENGTH;\n', '\n', '    /// @notice Minimum voting power the users must have to be able to make\n', '    /// proposals (in percentages)\n', '    /// @dev Delegations count towards voting power.\n', '    /// Default value is 0.1%. This parameter is governable by the DAO.\n', '    uint256 public proposalVotingPowerThreshold = ONE_PERCENT / 10;\n', '\n', '    /// @notice APR that will be paid next epoch\n', '    /// @dev This value will reach an equilibrium based on the stake target.\n', '    /// Every epoch (week), APR/52 of the total staked tokens will be added to\n', '    /// the pool, effectively distributing them to the stakers.\n', '    uint256 public apr = (maxApr + minApr) / 2;\n', '\n', '    /// @notice User records\n', '    mapping(address => User) public users;\n', '\n', '    // Keeps the total number of shares of the pool\n', '    Checkpoint[] public poolShares;\n', '\n', '    // Keeps user states used in `withdrawPrecalculated()` calls\n', '    mapping(address => LockedCalculation) public userToLockedCalculation;\n', '\n', '    // Kept to prevent third parties from frontrunning the initialization\n', '    // `setDaoApps()` call and grief the deployment\n', '    address private deployer;\n', '\n', '    /// @dev Reverts if the caller is not an API3 DAO Agent\n', '    modifier onlyAgentApp() {\n', '        require(\n', '            msg.sender == agentAppPrimary || msg.sender == agentAppSecondary,\n', '            "Pool: Caller not agent"\n', '            );\n', '        _;\n', '    }\n', '\n', '    /// @dev Reverts if the caller is not the primary API3 DAO Agent\n', '    modifier onlyAgentAppPrimary() {\n', '        require(\n', '            msg.sender == agentAppPrimary,\n', '            "Pool: Caller not primary agent"\n', '            );\n', '        _;\n', '    }\n', '\n', '    /// @dev Reverts if the caller is not an API3 DAO Api3Voting app\n', '    modifier onlyVotingApp() {\n', '        require(\n', '            msg.sender == votingAppPrimary || msg.sender == votingAppSecondary,\n', '            "Pool: Caller not voting app"\n', '            );\n', '        _;\n', '    }\n', '\n', '    /// @param api3TokenAddress API3 token contract address\n', '    /// @param timelockManagerAddress Timelock manager contract address\n', '    constructor(\n', '        address api3TokenAddress,\n', '        address timelockManagerAddress\n', '        )\n', '    {\n', '        require(\n', '            api3TokenAddress != address(0),\n', '            "Pool: Invalid Api3Token"\n', '            );\n', '        require(\n', '            timelockManagerAddress != address(0),\n', '            "Pool: Invalid TimelockManager"\n', '            );\n', '        deployer = msg.sender;\n', '        api3Token = IApi3Token(api3TokenAddress);\n', '        timelockManager = timelockManagerAddress;\n', '        // Initialize the share price at 1\n', '        updateCheckpointArray(poolShares, 1);\n', '        totalStake = 1;\n', '        // Set the current epoch as the genesis epoch and skip its reward\n', '        // payment\n', '        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n', '        genesisEpoch = currentEpoch;\n', '        epochIndexOfLastReward = currentEpoch;\n', '    }\n', '\n', '    /// @notice Called after deployment to set the addresses of the DAO apps\n', '    /// @dev This can also be called later on by the primary Agent to update\n', '    /// all app addresses as a means of an upgrade\n', '    /// @param _agentAppPrimary Address of the primary Agent\n', '    /// @param _agentAppSecondary Address of the secondary Agent\n', '    /// @param _votingAppPrimary Address of the primary Api3Voting app\n', '    /// @param _votingAppSecondary Address of the secondary Api3Voting app\n', '    function setDaoApps(\n', '        address _agentAppPrimary,\n', '        address _agentAppSecondary,\n', '        address _votingAppPrimary,\n', '        address _votingAppSecondary\n', '        )\n', '        external\n', '        override\n', '    {\n', '        // solhint-disable-next-line reason-string\n', '        require(\n', '            msg.sender == agentAppPrimary\n', '                || (agentAppPrimary == address(0) && msg.sender == deployer),\n', '            "Pool: Caller not primary agent or deployer initializing values"\n', '            );\n', '        require(\n', '            _agentAppPrimary != address(0)\n', '                && _agentAppSecondary != address(0)\n', '                && _votingAppPrimary != address(0)\n', '                && _votingAppSecondary != address(0),\n', '            "Pool: Invalid DAO apps"\n', '            );\n', '        agentAppPrimary = _agentAppPrimary;\n', '        agentAppSecondary = _agentAppSecondary;\n', '        votingAppPrimary = _votingAppPrimary;\n', '        votingAppSecondary = _votingAppSecondary;\n', '        emit SetDaoApps(\n', '            agentAppPrimary,\n', '            agentAppSecondary,\n', '            votingAppPrimary,\n', '            votingAppSecondary\n', '            );\n', '    }\n', '\n', '    /// @notice Called by the primary DAO Agent to set the authorization status\n', '    /// of a claims manager contract\n', '    /// @dev The claims manager is a trusted contract that is allowed to\n', '    /// withdraw as many tokens as it wants from the pool to pay out insurance\n', '    /// claims.\n', '    /// Only the primary Agent can do this because it is a critical operation.\n', '    /// WARNING: A compromised contract being given claims manager status may\n', '    /// result in loss of staked funds. If a proposal has been made to call\n', '    /// this method to set a contract as a claims manager, you are recommended\n', '    /// to review the contract yourself and/or refer to the audit reports to\n', '    /// understand the implications.\n', '    /// @param claimsManager Claims manager contract address\n', '    /// @param status Authorization status\n', '    function setClaimsManagerStatus(\n', '        address claimsManager,\n', '        bool status\n', '        )\n', '        external\n', '        override\n', '        onlyAgentAppPrimary()\n', '    {\n', '        claimsManagerStatus[claimsManager] = status;\n', '        emit SetClaimsManagerStatus(\n', '            claimsManager,\n', '            status\n', '            );\n', '    }\n', '\n', '    /// @notice Called by the DAO Agent to set the stake target\n', '    /// @param _stakeTarget Stake target\n', '    function setStakeTarget(uint256 _stakeTarget)\n', '        external\n', '        override\n', '        onlyAgentApp()\n', '    {\n', '        require(\n', '            _stakeTarget <= HUNDRED_PERCENT,\n', '            "Pool: Invalid percentage value"\n', '            );\n', '        stakeTarget = _stakeTarget;\n', '        emit SetStakeTarget(_stakeTarget);\n', '    }\n', '\n', '    /// @notice Called by the DAO Agent to set the maximum APR\n', '    /// @param _maxApr Maximum APR\n', '    function setMaxApr(uint256 _maxApr)\n', '        external\n', '        override\n', '        onlyAgentApp()\n', '    {\n', '        require(\n', '            _maxApr >= minApr,\n', '            "Pool: Max APR smaller than min"\n', '            );\n', '        maxApr = _maxApr;\n', '        emit SetMaxApr(_maxApr);\n', '    }\n', '\n', '    /// @notice Called by the DAO Agent to set the minimum APR\n', '    /// @param _minApr Minimum APR\n', '    function setMinApr(uint256 _minApr)\n', '        external\n', '        override\n', '        onlyAgentApp()\n', '    {\n', '        require(\n', '            _minApr <= maxApr,\n', '            "Pool: Min APR larger than max"\n', '            );\n', '        minApr = _minApr;\n', '        emit SetMinApr(_minApr);\n', '    }\n', '\n', '    /// @notice Called by the primary DAO Agent to set the unstake waiting\n', '    /// period\n', '    /// @dev This may want to be increased to provide more time for insurance\n', '    /// claims to be resolved.\n', '    /// Even when the insurance functionality is not implemented, the minimum\n', '    /// valid value is `EPOCH_LENGTH` to prevent users from unstaking,\n', '    /// withdrawing and staking with another address to work around the\n', '    /// proposal spam protection.\n', '    /// Only the primary Agent can do this because it is a critical operation.\n', '    /// @param _unstakeWaitPeriod Unstake waiting period\n', '    function setUnstakeWaitPeriod(uint256 _unstakeWaitPeriod)\n', '        external\n', '        override\n', '        onlyAgentAppPrimary()\n', '    {\n', '        require(\n', '            _unstakeWaitPeriod >= EPOCH_LENGTH,\n', '            "Pool: Period shorter than epoch"\n', '            );\n', '        unstakeWaitPeriod = _unstakeWaitPeriod;\n', '        emit SetUnstakeWaitPeriod(_unstakeWaitPeriod);\n', '    }\n', '\n', '    /// @notice Called by the primary DAO Agent to set the APR update steps\n', '    /// @dev aprUpdateStep can be 0% or 100%+.\n', '    /// Only the primary Agent can do this because it is a critical operation.\n', '    /// @param _aprUpdateStep APR update steps\n', '    function setAprUpdateStep(uint256 _aprUpdateStep)\n', '        external\n', '        override\n', '        onlyAgentAppPrimary()\n', '    {\n', '        aprUpdateStep = _aprUpdateStep;\n', '        emit SetAprUpdateStep(_aprUpdateStep);\n', '    }\n', '\n', '    /// @notice Called by the primary DAO Agent to set the voting power\n', '    /// threshold for proposals\n', '    /// @dev Only the primary Agent can do this because it is a critical\n', '    /// operation.\n', '    /// @param _proposalVotingPowerThreshold Voting power threshold for\n', '    /// proposals\n', '    function setProposalVotingPowerThreshold(uint256 _proposalVotingPowerThreshold)\n', '        external\n', '        override\n', '        onlyAgentAppPrimary()\n', '    {\n', '        require(\n', '            _proposalVotingPowerThreshold >= ONE_PERCENT / 10\n', '                && _proposalVotingPowerThreshold <= ONE_PERCENT * 10,\n', '            "Pool: Threshold outside limits");\n', '        proposalVotingPowerThreshold = _proposalVotingPowerThreshold;\n', '        emit SetProposalVotingPowerThreshold(_proposalVotingPowerThreshold);\n', '    }\n', '\n', '    /// @notice Called by a DAO Api3Voting app at proposal creation-time to\n', "    /// update the timestamp of the user's last proposal\n", '    /// @param userAddress User address\n', '    function updateLastProposalTimestamp(address userAddress)\n', '        external\n', '        override\n', '        onlyVotingApp()\n', '    {\n', '        users[userAddress].lastProposalTimestamp = block.timestamp;\n', '        emit UpdatedLastProposalTimestamp(\n', '            userAddress,\n', '            block.timestamp,\n', '            msg.sender\n', '            );\n', '    }\n', '\n', '    /// @notice Called to check if we are in the genesis epoch\n', '    /// @dev Voting apps use this to prevent proposals from being made in the\n', '    /// genesis epoch\n', '    /// @return If the current epoch is the genesis epoch\n', '    function isGenesisEpoch()\n', '        external\n', '        view\n', '        override\n', '        returns (bool)\n', '    {\n', '        return block.timestamp / EPOCH_LENGTH == genesisEpoch;\n', '    }\n', '\n', '    /// @notice Called internally to update a checkpoint array by pushing a new\n', '    /// checkpoint\n', '    /// @dev We assume `block.number` will always fit in a uint32 and `value`\n', '    /// will always fit in a uint224. `value` will either be a raw token amount\n', '    /// or a raw pool share amount so this assumption will be correct in\n', '    /// practice with a token with 18 decimals, 1e8 initial total supply and no\n', '    /// hyperinflation.\n', '    /// @param checkpointArray Checkpoint array\n', '    /// @param value Value to be used to create the new checkpoint\n', '    function updateCheckpointArray(\n', '        Checkpoint[] storage checkpointArray,\n', '        uint256 value\n', '        )\n', '        internal\n', '    {\n', '        assert(block.number <= MAX_UINT32);\n', '        assert(value <= MAX_UINT224);\n', '        checkpointArray.push(Checkpoint({\n', '            fromBlock: uint32(block.number),\n', '            value: uint224(value)\n', '            }));\n', '    }\n', '\n', '    /// @notice Called internally to update an address-checkpoint array by\n', '    /// pushing a new checkpoint\n', '    /// @dev We assume `block.number` will always fit in a uint32\n', '    /// @param addressCheckpointArray Address-checkpoint array\n', '    /// @param _address Address to be used to create the new checkpoint\n', '    function updateAddressCheckpointArray(\n', '        AddressCheckpoint[] storage addressCheckpointArray,\n', '        address _address\n', '        )\n', '        internal\n', '    {\n', '        assert(block.number <= MAX_UINT32);\n', '        addressCheckpointArray.push(AddressCheckpoint({\n', '            fromBlock: uint32(block.number),\n', '            _address: _address\n', '            }));\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/IGetterUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IGetterUtils is IStateUtils {\n', '    function userVotingPowerAt(\n', '        address userAddress,\n', '        uint256 _block\n', '        )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function userVotingPower(address userAddress)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function totalSharesAt(uint256 _block)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function totalShares()\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function userSharesAt(\n', '        address userAddress,\n', '        uint256 _block\n', '        )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function userShares(address userAddress)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function userStake(address userAddress)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function delegatedToUserAt(\n', '        address userAddress,\n', '        uint256 _block\n', '        )\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function delegatedToUser(address userAddress)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function userDelegateAt(\n', '        address userAddress,\n', '        uint256 _block\n', '        )\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    function userDelegate(address userAddress)\n', '        external\n', '        view\n', '        returns (address);\n', '\n', '    function userLocked(address userAddress)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function getUser(address userAddress)\n', '        external\n', '        view\n', '        returns (\n', '            uint256 unstaked,\n', '            uint256 vesting,\n', '            uint256 unstakeShares,\n', '            uint256 unstakeAmount,\n', '            uint256 unstakeScheduledFor,\n', '            uint256 lastDelegationUpdateTimestamp,\n', '            uint256 lastProposalTimestamp\n', '            );\n', '}\n', '\n', '\n', '// File contracts/GetterUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title Contract that implements getters\n', 'abstract contract GetterUtils is StateUtils, IGetterUtils {\n', '    /// @notice Called to get the voting power of a user at a specific block\n', '    /// @param userAddress User address\n', '    /// @param _block Block number for which the query is being made for\n', '    /// @return Voting power of the user at the block\n', '    function userVotingPowerAt(\n', '        address userAddress,\n', '        uint256 _block\n', '        )\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        // Users that have a delegate have no voting power\n', '        if (userDelegateAt(userAddress, _block) != address(0))\n', '        {\n', '            return 0;\n', '        }\n', '        return userSharesAt(userAddress, _block)\n', '            + delegatedToUserAt(userAddress, _block);\n', '    }\n', '\n', '    /// @notice Called to get the current voting power of a user\n', '    /// @param userAddress User address\n', '    /// @return Current voting power of the user\n', '    function userVotingPower(address userAddress)\n', '        external\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return userVotingPowerAt(userAddress, block.number);\n', '    }\n', '\n', '    /// @notice Called to get the total pool shares at a specific block\n', '    /// @dev Total pool shares also corresponds to total voting power\n', '    /// @param _block Block number for which the query is being made for\n', '    /// @return Total pool shares at the block\n', '    function totalSharesAt(uint256 _block)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return getValueAt(poolShares, _block);\n', '    }\n', '\n', '    /// @notice Called to get the current total pool shares\n', '    /// @dev Total pool shares also corresponds to total voting power\n', '    /// @return Current total pool shares\n', '    function totalShares()\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return totalSharesAt(block.number);\n', '    }\n', '\n', '    /// @notice Called to get the pool shares of a user at a specific block\n', '    /// @param userAddress User address\n', '    /// @param _block Block number for which the query is being made for\n', '    /// @return Pool shares of the user at the block\n', '    function userSharesAt(\n', '        address userAddress,\n', '        uint256 _block\n', '        )\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return getValueAt(users[userAddress].shares, _block);\n', '    }\n', '\n', '    /// @notice Called to get the current pool shares of a user\n', '    /// @param userAddress User address\n', '    /// @return Current pool shares of the user\n', '    function userShares(address userAddress)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return userSharesAt(userAddress, block.number);\n', '    }\n', '\n', '    /// @notice Called to get the current staked tokens of the user\n', '    /// @param userAddress User address\n', '    /// @return Current staked tokens of the user\n', '    function userStake(address userAddress)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return userShares(userAddress) * totalStake / totalShares();\n', '    }\n', '\n', '    /// @notice Called to get the voting power delegated to a user at a\n', '    /// specific block\n', '    /// @param userAddress User address\n', '    /// @param _block Block number for which the query is being made for\n', '    /// @return Voting power delegated to the user at the block\n', '    function delegatedToUserAt(\n', '        address userAddress,\n', '        uint256 _block\n', '        )\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return getValueAt(users[userAddress].delegatedTo, _block);\n', '    }\n', '\n', '    /// @notice Called to get the current voting power delegated to a user\n', '    /// @param userAddress User address\n', '    /// @return Current voting power delegated to the user\n', '    function delegatedToUser(address userAddress)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256)\n', '    {\n', '        return delegatedToUserAt(userAddress, block.number);\n', '    }\n', '\n', '    /// @notice Called to get the delegate of the user at a specific block\n', '    /// @param userAddress User address\n', '    /// @param _block Block number\n', '    /// @return Delegate of the user at the specific block\n', '    function userDelegateAt(\n', '        address userAddress,\n', '        uint256 _block\n', '        )\n', '        public\n', '        view\n', '        override\n', '        returns (address)\n', '    {\n', '        return getAddressAt(users[userAddress].delegates, _block);\n', '    }\n', '\n', '    /// @notice Called to get the current delegate of the user\n', '    /// @param userAddress User address\n', '    /// @return Current delegate of the user\n', '    function userDelegate(address userAddress)\n', '        public\n', '        view\n', '        override\n', '        returns (address)\n', '    {\n', '        return userDelegateAt(userAddress, block.number);\n', '    }\n', '\n', '    /// @notice Called to get the current locked tokens of the user\n', '    /// @param userAddress User address\n', '    /// @return locked Current locked tokens of the user\n', '    function userLocked(address userAddress)\n', '        public\n', '        view\n', '        override\n', '        returns (uint256 locked)\n', '    {\n', '        Checkpoint[] storage _userShares = users[userAddress].shares;\n', '        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n', '        uint256 oldestLockedEpoch = getOldestLockedEpoch();\n', '        uint256 indUserShares = _userShares.length;\n', '        for (\n', '                uint256 indEpoch = currentEpoch;\n', '                indEpoch >= oldestLockedEpoch;\n', '                indEpoch--\n', '            )\n', '        {\n', '            // The user has never staked at this point, we can exit early\n', '            if (indUserShares == 0)\n', '            {\n', '                break;\n', '            }\n', '            Reward storage lockedReward = epochIndexToReward[indEpoch];\n', '            if (lockedReward.atBlock != 0)\n', '            {\n', '                for (; indUserShares > 0; indUserShares--)\n', '                {\n', '                    Checkpoint storage userShare = _userShares[indUserShares - 1];\n', '                    if (userShare.fromBlock <= lockedReward.atBlock)\n', '                    {\n', '                        locked += lockedReward.amount * userShare.value / lockedReward.totalSharesThen;\n', '                        break;\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Called to get the details of a user\n', '    /// @param userAddress User address\n', '    /// @return unstaked Amount of unstaked API3 tokens\n', '    /// @return vesting Amount of API3 tokens locked by vesting\n', '    /// @return unstakeAmount Amount scheduled to unstake\n', '    /// @return unstakeShares Shares revoked to unstake\n', '    /// @return unstakeScheduledFor Time unstaking is scheduled for\n', '    /// @return lastDelegationUpdateTimestamp Time of last delegation update\n', '    /// @return lastProposalTimestamp Time when the user made their most\n', '    /// recent proposal\n', '    function getUser(address userAddress)\n', '        external\n', '        view\n', '        override\n', '        returns (\n', '            uint256 unstaked,\n', '            uint256 vesting,\n', '            uint256 unstakeAmount,\n', '            uint256 unstakeShares,\n', '            uint256 unstakeScheduledFor,\n', '            uint256 lastDelegationUpdateTimestamp,\n', '            uint256 lastProposalTimestamp\n', '            )\n', '    {\n', '        User storage user = users[userAddress];\n', '        unstaked = user.unstaked;\n', '        vesting = user.vesting;\n', '        unstakeAmount = user.unstakeAmount;\n', '        unstakeShares = user.unstakeShares;\n', '        unstakeScheduledFor = user.unstakeScheduledFor;\n', '        lastDelegationUpdateTimestamp = user.lastDelegationUpdateTimestamp;\n', '        lastProposalTimestamp = user.lastProposalTimestamp;\n', '    }\n', '\n', '    /// @notice Called to get the value of a checkpoint array at a specific\n', '    /// block using binary search\n', '    /// @dev Adapted from\n', '    /// https://github.com/aragon/minime/blob/1d5251fc88eee5024ff318d95bc9f4c5de130430/contracts/MiniMeToken.sol#L431\n', '    /// @param checkpoints Checkpoints array\n', '    /// @param _block Block number for which the query is being made\n', '    /// @return Value of the checkpoint array at the block\n', '    function getValueAt(\n', '        Checkpoint[] storage checkpoints,\n', '        uint256 _block\n', '        )\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        if (checkpoints.length == 0)\n', '            return 0;\n', '\n', '        // Shortcut for the actual value\n', '        if (_block >= checkpoints[checkpoints.length -1].fromBlock)\n', '            return checkpoints[checkpoints.length - 1].value;\n', '        if (_block < checkpoints[0].fromBlock)\n', '            return 0;\n', '\n', '        // Limit the search to the last 1024 elements if the value being\n', '        // searched falls within that window\n', '        uint min = 0;\n', '        if (\n', '            checkpoints.length > 1024\n', '                && checkpoints[checkpoints.length - 1024].fromBlock < _block\n', '            )\n', '        {\n', '            min = checkpoints.length - 1024;\n', '        }\n', '\n', '        // Binary search of the value in the array\n', '        uint max = checkpoints.length - 1;\n', '        while (max > min) {\n', '            uint mid = (max + min + 1) / 2;\n', '            if (checkpoints[mid].fromBlock <= _block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid - 1;\n', '            }\n', '        }\n', '        return checkpoints[min].value;\n', '    }\n', '\n', '    /// @notice Called to get the value of an address-checkpoint array at a\n', '    /// specific block using binary search\n', '    /// @dev Adapted from\n', '    /// https://github.com/aragon/minime/blob/1d5251fc88eee5024ff318d95bc9f4c5de130430/contracts/MiniMeToken.sol#L431\n', '    /// @param checkpoints Address-checkpoint array\n', '    /// @param _block Block number for which the query is being made\n', '    /// @return Value of the address-checkpoint array at the block\n', '    function getAddressAt(\n', '        AddressCheckpoint[] storage checkpoints,\n', '        uint256 _block\n', '        )\n', '        private\n', '        view\n', '        returns (address)\n', '    {\n', '        if (checkpoints.length == 0)\n', '            return address(0);\n', '\n', '        // Shortcut for the actual value\n', '        if (_block >= checkpoints[checkpoints.length -1].fromBlock)\n', '            return checkpoints[checkpoints.length - 1]._address;\n', '        if (_block < checkpoints[0].fromBlock)\n', '            return address(0);\n', '\n', '        // Limit the search to the last 1024 elements if the value being\n', '        // searched falls within that window\n', '        uint min = 0;\n', '        if (\n', '            checkpoints.length > 1024\n', '                && checkpoints[checkpoints.length - 1024].fromBlock < _block\n', '            )\n', '        {\n', '            min = checkpoints.length - 1024;\n', '        }\n', '\n', '        // Binary search of the value in the array\n', '        uint max = checkpoints.length - 1;\n', '        while (max > min) {\n', '            uint mid = (max + min + 1) / 2;\n', '            if (checkpoints[mid].fromBlock <= _block) {\n', '                min = mid;\n', '            } else {\n', '                max = mid - 1;\n', '            }\n', '        }\n', '        return checkpoints[min]._address;\n', '    }\n', '\n', '    /// @notice Called internally to get the index of the oldest epoch whose\n', '    /// reward should be locked in the current epoch\n', '    /// @return oldestLockedEpoch Index of the oldest epoch with locked rewards\n', '    function getOldestLockedEpoch()\n', '        internal\n', '        view\n', '        returns (uint256 oldestLockedEpoch)\n', '    {\n', '        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n', '        oldestLockedEpoch = currentEpoch - REWARD_VESTING_PERIOD + 1;\n', '        if (oldestLockedEpoch < genesisEpoch + 1)\n', '        {\n', '            oldestLockedEpoch = genesisEpoch + 1;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/IRewardUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IRewardUtils is IGetterUtils {\n', '    event MintedReward(\n', '        uint256 indexed epochIndex,\n', '        uint256 amount,\n', '        uint256 newApr,\n', '        uint256 totalStake\n', '        );\n', '\n', '    function mintReward()\n', '        external;\n', '}\n', '\n', '\n', '// File contracts/RewardUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title Contract that implements reward payments\n', 'abstract contract RewardUtils is GetterUtils, IRewardUtils {\n', '    /// @notice Called to mint the staking reward\n', '    /// @dev Skips past epochs for which rewards have not been paid for.\n', '    /// Skips the reward payment if the pool is not authorized to mint tokens.\n', '    /// Neither of these conditions will occur in practice.\n', '    function mintReward()\n', '        public\n', '        override\n', '    {\n', '        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n', '        // This will be skipped in most cases because someone else will have\n', '        // triggered the payment for this epoch\n', '        if (epochIndexOfLastReward < currentEpoch)\n', '        {\n', '            if (api3Token.getMinterStatus(address(this)))\n', '            {\n', '                uint256 rewardAmount = totalStake * apr * EPOCH_LENGTH / 365 days / HUNDRED_PERCENT;\n', '                assert(block.number <= MAX_UINT32);\n', '                assert(rewardAmount <= MAX_UINT224);\n', '                epochIndexToReward[currentEpoch] = Reward({\n', '                    atBlock: uint32(block.number),\n', '                    amount: uint224(rewardAmount),\n', '                    totalSharesThen: totalShares(),\n', '                    totalStakeThen: totalStake\n', '                    });\n', '                api3Token.mint(address(this), rewardAmount);\n', '                totalStake += rewardAmount;\n', '                updateCurrentApr();\n', '                emit MintedReward(\n', '                    currentEpoch,\n', '                    rewardAmount,\n', '                    apr,\n', '                    totalStake\n', '                    );\n', '            }\n', '            epochIndexOfLastReward = currentEpoch;\n', '        }\n', '    }\n', '\n', '    /// @notice Updates the current APR\n', '    /// @dev Called internally after paying out the reward\n', '    function updateCurrentApr()\n', '        internal\n', '    {\n', '        uint256 totalStakePercentage = totalStake\n', '            * HUNDRED_PERCENT\n', '            / api3Token.totalSupply();\n', '        if (totalStakePercentage > stakeTarget)\n', '        {\n', '            apr = apr > aprUpdateStep ? apr - aprUpdateStep : 0;\n', '        }\n', '        else\n', '        {\n', '            apr += aprUpdateStep;\n', '        }\n', '        if (apr > maxApr) {\n', '            apr = maxApr;\n', '        }\n', '        else if (apr < minApr) {\n', '            apr = minApr;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/IDelegationUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IDelegationUtils is IRewardUtils {\n', '    event Delegated(\n', '        address indexed user,\n', '        address indexed delegate,\n', '        uint256 shares,\n', '        uint256 totalDelegatedTo\n', '        );\n', '\n', '    event Undelegated(\n', '        address indexed user,\n', '        address indexed delegate,\n', '        uint256 shares,\n', '        uint256 totalDelegatedTo\n', '        );\n', '\n', '    event UpdatedDelegation(\n', '        address indexed user,\n', '        address indexed delegate,\n', '        bool delta,\n', '        uint256 shares,\n', '        uint256 totalDelegatedTo\n', '        );\n', '\n', '    function delegateVotingPower(address delegate) \n', '        external;\n', '\n', '    function undelegateVotingPower()\n', '        external;\n', '\n', '    \n', '}\n', '\n', '\n', '// File contracts/DelegationUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title Contract that implements voting power delegation\n', 'abstract contract DelegationUtils is RewardUtils, IDelegationUtils {\n', '    /// @notice Called by the user to delegate voting power\n', '    /// @param delegate User address the voting power will be delegated to\n', '    function delegateVotingPower(address delegate) \n', '        external\n', '        override\n', '    {\n', '        mintReward();\n', '        require(\n', '            delegate != address(0) && delegate != msg.sender,\n', '            "Pool: Invalid delegate"\n', '            );\n', '        // Delegating users cannot use their voting power, so we are\n', '        // verifying that the delegate is not currently delegating. However,\n', '        // the delegate may delegate after they have been delegated to.\n', '        require(\n', '            userDelegate(delegate) == address(0),\n', '            "Pool: Delegate is delegating"\n', '            );\n', '        User storage user = users[msg.sender];\n', '        // Do not allow frequent delegation updates as that can be used to spam\n', '        // proposals\n', '        require(\n', '            user.lastDelegationUpdateTimestamp + EPOCH_LENGTH < block.timestamp,\n', '            "Pool: Updated delegate recently"\n', '            );\n', '        user.lastDelegationUpdateTimestamp = block.timestamp;\n', '\n', '        uint256 userShares = userShares(msg.sender);\n', '        require(\n', '            userShares != 0,\n', '            "Pool: Have no shares to delegate"\n', '            );\n', '\n', '        address previousDelegate = userDelegate(msg.sender);\n', '        require(\n', '            previousDelegate != delegate,\n', '            "Pool: Already delegated"\n', '            );\n', '        if (previousDelegate != address(0)) {\n', '            // Need to revoke previous delegation\n', '            updateCheckpointArray(\n', '                users[previousDelegate].delegatedTo,\n', '                delegatedToUser(previousDelegate) - userShares\n', '                );\n', '        }\n', '\n', '        // Assign the new delegation\n', '        uint256 delegatedToUpdate = delegatedToUser(delegate) + userShares;\n', '        updateCheckpointArray(\n', '            users[delegate].delegatedTo,\n', '            delegatedToUpdate\n', '            );\n', '\n', '        // Record the new delegate for the user\n', '        updateAddressCheckpointArray(\n', '            user.delegates,\n', '            delegate\n', '            );\n', '        emit Delegated(\n', '            msg.sender,\n', '            delegate,\n', '            userShares,\n', '            delegatedToUpdate\n', '            );\n', '    }\n', '\n', '    /// @notice Called by the user to undelegate voting power\n', '    function undelegateVotingPower()\n', '        external\n', '        override\n', '    {\n', '        mintReward();\n', '        User storage user = users[msg.sender];\n', '        address previousDelegate = userDelegate(msg.sender);\n', '        require(\n', '            previousDelegate != address(0),\n', '            "Pool: Not delegated"\n', '            );\n', '        require(\n', '            user.lastDelegationUpdateTimestamp + EPOCH_LENGTH < block.timestamp,\n', '            "Pool: Updated delegate recently"\n', '            );\n', '        user.lastDelegationUpdateTimestamp = block.timestamp;\n', '\n', '        uint256 userShares = userShares(msg.sender);\n', '        uint256 delegatedToUpdate = delegatedToUser(previousDelegate) - userShares;\n', '        updateCheckpointArray(\n', '            users[previousDelegate].delegatedTo,\n', '            delegatedToUpdate\n', '            );\n', '        updateAddressCheckpointArray(\n', '            user.delegates,\n', '            address(0)\n', '            );\n', '        emit Undelegated(\n', '            msg.sender,\n', '            previousDelegate,\n', '            userShares,\n', '            delegatedToUpdate\n', '            );\n', '    }\n', '\n', '    /// @notice Called internally when the user shares are updated to update\n', '    /// the delegated voting power\n', '    /// @dev User shares only get updated while staking or scheduling unstaking\n', '    /// @param shares Amount of shares that will be added/removed\n', '    /// @param delta Whether the shares will be added/removed (add for `true`,\n', '    /// and vice versa)\n', '    function updateDelegatedVotingPower(\n', '        uint256 shares,\n', '        bool delta\n', '        )\n', '        internal\n', '    {\n', '        address delegate = userDelegate(msg.sender);\n', '        if (delegate == address(0))\n', '        {\n', '            return;\n', '        }\n', '        uint256 currentDelegatedTo = delegatedToUser(delegate);\n', '        uint256 delegatedToUpdate = delta\n', '            ? currentDelegatedTo + shares\n', '            : currentDelegatedTo - shares;\n', '        updateCheckpointArray(\n', '            users[delegate].delegatedTo,\n', '            delegatedToUpdate\n', '            );\n', '        emit UpdatedDelegation(\n', '            msg.sender,\n', '            delegate,\n', '            delta,\n', '            shares,\n', '            delegatedToUpdate\n', '            );\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/ITransferUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface ITransferUtils is IDelegationUtils{\n', '    event Deposited(\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 userUnstaked\n', '        );\n', '\n', '    event Withdrawn(\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 userUnstaked\n', '        );\n', '\n', '    event CalculatingUserLocked(\n', '        address indexed user,\n', '        uint256 nextIndEpoch,\n', '        uint256 oldestLockedEpoch\n', '        );\n', '\n', '    event CalculatedUserLocked(\n', '        address indexed user,\n', '        uint256 amount\n', '        );\n', '\n', '    function depositRegular(uint256 amount)\n', '        external;\n', '\n', '    function withdrawRegular(uint256 amount)\n', '        external;\n', '\n', '    function precalculateUserLocked(\n', '        address userAddress,\n', '        uint256 noEpochsPerIteration\n', '        )\n', '        external\n', '        returns (bool finished);\n', '\n', '    function withdrawPrecalculated(uint256 amount)\n', '        external;\n', '}\n', '\n', '\n', '// File contracts/TransferUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title Contract that implements token transfer functionality\n', 'abstract contract TransferUtils is DelegationUtils, ITransferUtils {\n', '    /// @notice Called by the user to deposit tokens\n', '    /// @dev The user should approve the pool to spend at least `amount` tokens\n', '    /// before calling this.\n', '    /// The method is named `depositRegular()` to prevent potential confusion.\n', '    /// See `deposit()` for more context.\n', '    /// @param amount Amount to be deposited\n', '    function depositRegular(uint256 amount)\n', '        public\n', '        override\n', '    {\n', '        mintReward();\n', '        uint256 unstakedUpdate = users[msg.sender].unstaked + amount;\n', '        users[msg.sender].unstaked = unstakedUpdate;\n', '        // Should never return false because the API3 token uses the\n', '        // OpenZeppelin implementation\n', '        assert(api3Token.transferFrom(msg.sender, address(this), amount));\n', '        emit Deposited(\n', '            msg.sender,\n', '            amount,\n', '            unstakedUpdate\n', '            );\n', '    }\n', '\n', '    /// @notice Called by the user to withdraw tokens to their wallet\n', '    /// @dev The user should call `userLocked()` beforehand to ensure that\n', '    /// they have at least `amount` unlocked tokens to withdraw.\n', '    /// The method is named `withdrawRegular()` to be consistent with the name\n', '    /// `depositRegular()`. See `depositRegular()` for more context.\n', '    /// @param amount Amount to be withdrawn\n', '    function withdrawRegular(uint256 amount)\n', '        public\n', '        override\n', '    {\n', '        mintReward();\n', '        withdraw(amount, userLocked(msg.sender));\n', '    }\n', '\n', '    /// @notice Called to calculate the locked tokens of a user by making\n', '    /// multiple transactions\n', '    /// @dev If the user updates their `user.shares` by staking/unstaking too\n', '    /// frequently (50+/week) in the last `REWARD_VESTING_PERIOD`, the\n', '    /// `userLocked()` call gas cost may exceed the block gas limit. In that\n', '    /// case, the user may call this method multiple times to have their locked\n', '    /// tokens calculated and use `withdrawPrecalculated()` to withdraw.\n', '    /// @param userAddress User address\n', '    /// @param noEpochsPerIteration Number of epochs per iteration\n', '    /// @return finished Calculation has finished in this call\n', '    function precalculateUserLocked(\n', '        address userAddress,\n', '        uint256 noEpochsPerIteration\n', '        )\n', '        external\n', '        override\n', '        returns (bool finished)\n', '    {\n', '        mintReward();\n', '        require(\n', '            noEpochsPerIteration > 0,\n', '            "Pool: Zero iteration window"\n', '            );\n', '        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n', '        LockedCalculation storage lockedCalculation = userToLockedCalculation[userAddress];\n', '        // Reset the state if there was no calculation made in this epoch\n', '        if (lockedCalculation.initialIndEpoch != currentEpoch)\n', '        {\n', '            lockedCalculation.initialIndEpoch = currentEpoch;\n', '            lockedCalculation.nextIndEpoch = currentEpoch;\n', '            lockedCalculation.locked = 0;\n', '        }\n', '        uint256 indEpoch = lockedCalculation.nextIndEpoch;\n', '        uint256 locked = lockedCalculation.locked;\n', '        uint256 oldestLockedEpoch = getOldestLockedEpoch();\n', '        for (; indEpoch >= oldestLockedEpoch; indEpoch--)\n', '        {\n', '            if (lockedCalculation.nextIndEpoch >= indEpoch + noEpochsPerIteration)\n', '            {\n', '                lockedCalculation.nextIndEpoch = indEpoch;\n', '                lockedCalculation.locked = locked;\n', '                emit CalculatingUserLocked(\n', '                    userAddress,\n', '                    indEpoch,\n', '                    oldestLockedEpoch\n', '                    );\n', '                return false;\n', '            }\n', '            Reward storage lockedReward = epochIndexToReward[indEpoch];\n', '            if (lockedReward.atBlock != 0)\n', '            {\n', '                uint256 userSharesThen = userSharesAt(userAddress, lockedReward.atBlock);\n', '                locked += lockedReward.amount * userSharesThen / lockedReward.totalSharesThen;\n', '            }\n', '        }\n', '        lockedCalculation.nextIndEpoch = indEpoch;\n', '        lockedCalculation.locked = locked;\n', '        emit CalculatedUserLocked(userAddress, locked);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Called by the user to withdraw after their locked token amount\n', '    /// is calculated with repeated calls to `precalculateUserLocked()`\n', '    /// @dev Only use `precalculateUserLocked()` and this method if\n', '    /// `withdrawRegular()` hits the block gas limit\n', '    /// @param amount Amount to be withdrawn\n', '    function withdrawPrecalculated(uint256 amount)\n', '        external\n', '        override\n', '    {\n', '        mintReward();\n', '        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n', '        LockedCalculation storage lockedCalculation = userToLockedCalculation[msg.sender];\n', '        require(\n', '            lockedCalculation.initialIndEpoch == currentEpoch,\n', '            "Pool: Calculation not up to date"\n', '            );\n', '        require(\n', '            lockedCalculation.nextIndEpoch < getOldestLockedEpoch(),\n', '            "Pool: Calculation not complete"\n', '            );\n', '        withdraw(amount, lockedCalculation.locked);\n', '    }\n', '\n', '    /// @notice Called internally after the amount of locked tokens of the user\n', '    /// is determined\n', '    /// @param amount Amount to be withdrawn\n', '    /// @param userLocked Amount of locked tokens of the user\n', '    function withdraw(\n', '        uint256 amount,\n', '        uint256 userLocked\n', '        )\n', '        private\n', '    {\n', '        User storage user = users[msg.sender];\n', '        // Check if the user has `amount` unlocked tokens to withdraw\n', '        uint256 lockedAndVesting = userLocked + user.vesting;\n', '        uint256 userTotalFunds = user.unstaked + userStake(msg.sender);\n', '        require(\n', '            userTotalFunds >= lockedAndVesting + amount,\n', '            "Pool: Not enough unlocked funds"\n', '            );\n', '        require(\n', '            user.unstaked >= amount,\n', '            "Pool: Not enough unstaked funds"\n', '            );\n', '        // Carry on with the withdrawal\n', '        uint256 unstakedUpdate = user.unstaked - amount;\n', '        user.unstaked = unstakedUpdate;\n', '        // Should never return false because the API3 token uses the\n', '        // OpenZeppelin implementation\n', '        assert(api3Token.transfer(msg.sender, amount));\n', '        emit Withdrawn(\n', '            msg.sender,\n', '            amount,\n', '            unstakedUpdate\n', '            );\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/IStakeUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IStakeUtils is ITransferUtils{\n', '    event Staked(\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 mintedShares,\n', '        uint256 userUnstaked,\n', '        uint256 userShares,\n', '        uint256 totalShares,\n', '        uint256 totalStake\n', '        );\n', '\n', '    event ScheduledUnstake(\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 shares,\n', '        uint256 scheduledFor,\n', '        uint256 userShares\n', '        );\n', '\n', '    event Unstaked(\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 userUnstaked,\n', '        uint256 totalShares,\n', '        uint256 totalStake\n', '        );\n', '\n', '    function stake(uint256 amount)\n', '        external;\n', '\n', '    function depositAndStake(uint256 amount)\n', '        external;\n', '\n', '    function scheduleUnstake(uint256 amount)\n', '        external;\n', '\n', '    function unstake(address userAddress)\n', '        external\n', '        returns (uint256);\n', '\n', '    function unstakeAndWithdraw()\n', '        external;\n', '}\n', '\n', '\n', '// File contracts/StakeUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title Contract that implements staking functionality\n', 'abstract contract StakeUtils is TransferUtils, IStakeUtils {\n', '    /// @notice Called to stake tokens to receive pools in the share\n', '    /// @param amount Amount of tokens to stake\n', '    function stake(uint256 amount)\n', '        public\n', '        override\n', '    {\n', '        mintReward();\n', '        User storage user = users[msg.sender];\n', '        require(\n', '            user.unstaked >= amount,\n', '            "Pool: Amount exceeds unstaked"\n', '            );\n', '        uint256 userUnstakedUpdate = user.unstaked - amount;\n', '        user.unstaked = userUnstakedUpdate;\n', '        uint256 totalSharesNow = totalShares();\n', '        uint256 sharesToMint = amount * totalSharesNow / totalStake;\n', '        uint256 userSharesUpdate = userShares(msg.sender) + sharesToMint;\n', '        updateCheckpointArray(\n', '            user.shares,\n', '            userSharesUpdate\n', '            );\n', '        uint256 totalSharesUpdate = totalSharesNow + sharesToMint;\n', '        updateCheckpointArray(\n', '            poolShares,\n', '            totalSharesUpdate\n', '            );\n', '        totalStake += amount;\n', '        updateDelegatedVotingPower(sharesToMint, true);\n', '        emit Staked(\n', '            msg.sender,\n', '            amount,\n', '            sharesToMint,\n', '            userUnstakedUpdate,\n', '            userSharesUpdate,\n', '            totalSharesUpdate,\n', '            totalStake\n', '            );\n', '    }\n', '\n', '    /// @notice Convenience method to deposit and stake in a single transaction\n', '    /// @param amount Amount to be deposited and staked\n', '    function depositAndStake(uint256 amount)\n', '        external\n', '        override\n', '    {\n', '        depositRegular(amount);\n', '        stake(amount);\n', '    }\n', '\n', '    /// @notice Called by the user to schedule unstaking of their tokens\n', '    /// @dev While scheduling an unstake, `shares` get deducted from the user,\n', '    /// meaning that they will not receive rewards or voting power for them any\n', '    /// longer.\n', '    /// At unstaking-time, the user unstakes either the amount of tokens\n', '    /// scheduled to unstake, or the amount of tokens `shares` corresponds to\n', '    /// at unstaking-time, whichever is smaller. This corresponds to tokens\n', '    /// being scheduled to be unstaked not receiving any rewards, but being\n', '    /// subject to claim payouts.\n', '    /// In the instance that a claim has been paid out before an unstaking is\n', '    /// executed, the user may potentially receive rewards during\n', '    /// `unstakeWaitPeriod` (but not if there has not been a claim payout) but\n', '    /// the amount of tokens that they can unstake will not be able to exceed\n', '    /// the amount they scheduled the unstaking for.\n', '    /// @param amount Amount of tokens scheduled to unstake\n', '    function scheduleUnstake(uint256 amount)\n', '        external\n', '        override\n', '    {\n', '        mintReward();\n', '        uint256 userSharesNow = userShares(msg.sender);\n', '        uint256 totalSharesNow = totalShares();\n', '        uint256 userStaked = userSharesNow * totalStake / totalSharesNow;\n', '        require(\n', '            userStaked >= amount,\n', '            "Pool: Amount exceeds staked"\n', '            );\n', '\n', '        User storage user = users[msg.sender];\n', '        require(\n', '            user.unstakeScheduledFor == 0,\n', '            "Pool: Unexecuted unstake exists"\n', '            );\n', '\n', '        uint256 sharesToUnstake = amount * totalSharesNow / totalStake;\n', '        // This will only happen if the user wants to schedule an unstake for a\n', '        // few Wei\n', '        require(sharesToUnstake > 0, "Pool: Unstake amount too small");\n', '        uint256 unstakeScheduledFor = block.timestamp + unstakeWaitPeriod;\n', '        user.unstakeScheduledFor = unstakeScheduledFor;\n', '        user.unstakeAmount = amount;\n', '        user.unstakeShares = sharesToUnstake;\n', '        uint256 userSharesUpdate = userSharesNow - sharesToUnstake;\n', '        updateCheckpointArray(\n', '            user.shares,\n', '            userSharesUpdate\n', '            );\n', '        updateDelegatedVotingPower(sharesToUnstake, false);\n', '        emit ScheduledUnstake(\n', '            msg.sender,\n', '            amount,\n', '            sharesToUnstake,\n', '            unstakeScheduledFor,\n', '            userSharesUpdate\n', '            );\n', '    }\n', '\n', '    /// @notice Called to execute a pre-scheduled unstake\n', '    /// @dev Anyone can execute a matured unstake. This is to allow the user to\n', '    /// use bots, etc. to execute their unstaking as soon as possible.\n', '    /// @param userAddress User address\n', '    /// @return Amount of tokens that are unstaked\n', '    function unstake(address userAddress)\n', '        public\n', '        override\n', '        returns (uint256)\n', '    {\n', '        mintReward();\n', '        User storage user = users[userAddress];\n', '        require(\n', '            user.unstakeScheduledFor != 0,\n', '            "Pool: No unstake scheduled"\n', '            );\n', '        require(\n', '            user.unstakeScheduledFor < block.timestamp,\n', '            "Pool: Unstake not mature yet"\n', '            );\n', '        uint256 totalShares = totalShares();\n', '        uint256 unstakeAmount = user.unstakeAmount;\n', '        uint256 unstakeAmountByShares = user.unstakeShares * totalStake / totalShares;\n', '        // If there was a claim payout in between the scheduling and the actual\n', '        // unstake then the amount might be lower than expected at scheduling\n', '        // time\n', '        if (unstakeAmount > unstakeAmountByShares)\n', '        {\n', '            unstakeAmount = unstakeAmountByShares;\n', '        }\n', '        uint256 userUnstakedUpdate = user.unstaked + unstakeAmount;\n', '        user.unstaked = userUnstakedUpdate;\n', '\n', '        uint256 totalSharesUpdate = totalShares - user.unstakeShares;\n', '        updateCheckpointArray(\n', '            poolShares,\n', '            totalSharesUpdate\n', '            );\n', '        totalStake -= unstakeAmount;\n', '\n', '        user.unstakeAmount = 0;\n', '        user.unstakeShares = 0;\n', '        user.unstakeScheduledFor = 0;\n', '        emit Unstaked(\n', '            userAddress,\n', '            unstakeAmount,\n', '            userUnstakedUpdate,\n', '            totalSharesUpdate,\n', '            totalStake\n', '            );\n', '        return unstakeAmount;\n', '    }\n', '\n', '    /// @notice Convenience method to execute an unstake and withdraw to the\n', "    /// user's wallet in a single transaction\n", '    /// @dev The withdrawal will revert if the user has less than\n', '    /// `unstakeAmount` tokens that are withdrawable\n', '    function unstakeAndWithdraw()\n', '        external\n', '        override\n', '    {\n', '        withdrawRegular(unstake(msg.sender));\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/IClaimUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IClaimUtils is IStakeUtils {\n', '    event PaidOutClaim(\n', '        address indexed recipient,\n', '        uint256 amount,\n', '        uint256 totalStake\n', '        );\n', '\n', '    function payOutClaim(\n', '        address recipient,\n', '        uint256 amount\n', '        )\n', '        external;\n', '}\n', '\n', '\n', '// File contracts/ClaimUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title Contract that implements the insurance claim payout functionality\n', 'abstract contract ClaimUtils is StakeUtils, IClaimUtils {\n', '    /// @dev Reverts if the caller is not a claims manager\n', '    modifier onlyClaimsManager() {\n', '        require(\n', '            claimsManagerStatus[msg.sender],\n', '            "Pool: Caller not claims manager"\n', '            );\n', '        _;\n', '    }\n', '\n', '    /// @notice Called by a claims manager to pay out an insurance claim\n', '    /// @dev The claims manager is a trusted contract that is allowed to\n', '    /// withdraw as many tokens as it wants from the pool to pay out insurance\n', '    /// claims. Any kind of limiting logic (e.g., maximum amount of tokens that\n', '    /// can be withdrawn) is implemented at its end and is out of the scope of\n', '    /// this contract.\n', '    /// This will revert if the pool does not have enough staked funds.\n', '    /// @param recipient Recipient of the claim\n', '    /// @param amount Amount of tokens that will be paid out\n', '    function payOutClaim(\n', '        address recipient,\n', '        uint256 amount\n', '        )\n', '        external\n', '        override\n', '        onlyClaimsManager()\n', '    {\n', '        mintReward();\n', '        // totalStake should not go lower than 1\n', '        require(\n', '            totalStake > amount,\n', '            "Pool: Amount exceeds total stake"\n', '            );\n', '        totalStake -= amount;\n', '        // Should never return false because the API3 token uses the\n', '        // OpenZeppelin implementation\n', '        assert(api3Token.transfer(recipient, amount));\n', '        emit PaidOutClaim(\n', '            recipient,\n', '            amount,\n', '            totalStake\n', '            );\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/ITimelockUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface ITimelockUtils is IClaimUtils {\n', '    event DepositedByTimelockManager(\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 userUnstaked\n', '        );\n', '\n', '    event DepositedVesting(\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 start,\n', '        uint256 end,\n', '        uint256 userUnstaked,\n', '        uint256 userVesting\n', '        );\n', '\n', '    event VestedTimelock(\n', '        address indexed user,\n', '        uint256 amount,\n', '        uint256 userVesting\n', '        );\n', '\n', '    function deposit(\n', '        address source,\n', '        uint256 amount,\n', '        address userAddress\n', '        )\n', '        external;\n', '\n', '    function depositWithVesting(\n', '        address source,\n', '        uint256 amount,\n', '        address userAddress,\n', '        uint256 releaseStart,\n', '        uint256 releaseEnd\n', '        )\n', '        external;\n', '\n', '    function updateTimelockStatus(address userAddress)\n', '        external;\n', '}\n', '\n', '\n', '// File contracts/TimelockUtils.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title Contract that implements vesting functionality\n', '/// @dev The TimelockManager contract interfaces with this contract to transfer\n', '/// API3 tokens that are locked under a vesting schedule.\n', '/// This contract keeps its own type definitions, event declarations and state\n', '/// variables for them to be easier to remove for a subDAO where they will\n', '/// likely not be used.\n', 'abstract contract TimelockUtils is ClaimUtils, ITimelockUtils {\n', '    struct Timelock {\n', '        uint256 totalAmount;\n', '        uint256 remainingAmount;\n', '        uint256 releaseStart;\n', '        uint256 releaseEnd;\n', '    }\n', '\n', '    /// @notice Maps user addresses to timelocks\n', '    /// @dev This implies that a user cannot have multiple timelocks\n', '    /// transferred from the TimelockManager contract. This is acceptable\n', '    /// because TimelockManager is implemented in a way to not allow multiple\n', '    /// timelocks per user.\n', '    mapping(address => Timelock) public userToTimelock;\n', '\n', '    /// @notice Called by the TimelockManager contract to deposit tokens on\n', '    /// behalf of a user\n', '    /// @dev This method is only usable by `TimelockManager.sol`.\n', '    /// It is named as `deposit()` and not `depositAsTimelockManager()` for\n', '    /// example, because the TimelockManager is already deployed and expects\n', '    /// the `deposit(address,uint256,address)` interface.\n', '    /// @param source Token transfer source\n', '    /// @param amount Amount to be deposited\n', '    /// @param userAddress User that the tokens will be deposited for\n', '    function deposit(\n', '        address source,\n', '        uint256 amount,\n', '        address userAddress\n', '        )\n', '        external\n', '        override\n', '    {\n', '        require(\n', '            msg.sender == timelockManager,\n', '            "Pool: Caller not TimelockManager"\n', '            );\n', '        uint256 unstakedUpdate = users[userAddress].unstaked + amount;\n', '        users[userAddress].unstaked = unstakedUpdate;\n', '        // Should never return false because the API3 token uses the\n', '        // OpenZeppelin implementation\n', '        assert(api3Token.transferFrom(source, address(this), amount));\n', '        emit DepositedByTimelockManager(\n', '            userAddress,\n', '            amount,\n', '            unstakedUpdate\n', '            );\n', '    }\n', '\n', '    /// @notice Called by the TimelockManager contract to deposit tokens on\n', '    /// behalf of a user on a linear vesting schedule\n', '    /// @dev Refer to `TimelockManager.sol` to see how this is used\n', '    /// @param source Token source\n', '    /// @param amount Token amount\n', '    /// @param userAddress Address of the user who will receive the tokens\n', '    /// @param releaseStart Vesting schedule starting time\n', '    /// @param releaseEnd Vesting schedule ending time\n', '    function depositWithVesting(\n', '        address source,\n', '        uint256 amount,\n', '        address userAddress,\n', '        uint256 releaseStart,\n', '        uint256 releaseEnd\n', '        )\n', '        external\n', '        override\n', '    {\n', '        require(\n', '            msg.sender == timelockManager,\n', '            "Pool: Caller not TimelockManager"\n', '            );\n', '        require(\n', '            userToTimelock[userAddress].remainingAmount == 0,\n', '            "Pool: User has active timelock"\n', '            );\n', '        require(\n', '            releaseEnd > releaseStart,\n', '            "Pool: Timelock start after end"\n', '            );\n', '        require(\n', '            amount != 0,\n', '            "Pool: Timelock amount zero"\n', '            );\n', '        uint256 unstakedUpdate = users[userAddress].unstaked + amount;\n', '        users[userAddress].unstaked = unstakedUpdate;\n', '        uint256 vestingUpdate = users[userAddress].vesting + amount;\n', '        users[userAddress].vesting = vestingUpdate;\n', '        userToTimelock[userAddress] = Timelock({\n', '            totalAmount: amount,\n', '            remainingAmount: amount,\n', '            releaseStart: releaseStart,\n', '            releaseEnd: releaseEnd\n', '            });\n', '        // Should never return false because the API3 token uses the\n', '        // OpenZeppelin implementation\n', '        assert(api3Token.transferFrom(source, address(this), amount));\n', '        emit DepositedVesting(\n', '            userAddress,\n', '            amount,\n', '            releaseStart,\n', '            releaseEnd,\n', '            unstakedUpdate,\n', '            vestingUpdate\n', '            );\n', '    }\n', '\n', '    /// @notice Called to release tokens vested by the timelock\n', '    /// @param userAddress Address of the user whose timelock status will be\n', '    /// updated\n', '    function updateTimelockStatus(address userAddress)\n', '        external\n', '        override\n', '    {\n', '        Timelock storage timelock = userToTimelock[userAddress];\n', '        require(\n', '            block.timestamp > timelock.releaseStart,\n', '            "Pool: Release not started yet"\n', '            );\n', '        require(\n', '            timelock.remainingAmount > 0,\n', '            "Pool: Timelock already released"\n', '            );\n', '        uint256 totalUnlocked;\n', '        if (block.timestamp >= timelock.releaseEnd)\n', '        {\n', '            totalUnlocked = timelock.totalAmount;\n', '        }\n', '        else\n', '        {\n', '            uint256 passedTime = block.timestamp - timelock.releaseStart;\n', '            uint256 totalTime = timelock.releaseEnd - timelock.releaseStart;\n', '            totalUnlocked = timelock.totalAmount * passedTime / totalTime;\n', '        }\n', '        uint256 previouslyUnlocked = timelock.totalAmount - timelock.remainingAmount;\n', '        uint256 newlyUnlocked = totalUnlocked - previouslyUnlocked;\n', '        User storage user = users[userAddress];\n', '        uint256 vestingUpdate = user.vesting - newlyUnlocked;\n', '        user.vesting = vestingUpdate;\n', '        timelock.remainingAmount -= newlyUnlocked;\n', '        emit VestedTimelock(\n', '            userAddress,\n', '            newlyUnlocked,\n', '            vestingUpdate\n', '            );\n', '    }\n', '}\n', '\n', '\n', '// File contracts/interfaces/IApi3Pool.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', 'interface IApi3Pool is ITimelockUtils {\n', '}\n', '\n', '\n', '// File contracts/Api3Pool.sol\n', '\n', 'pragma solidity 0.8.4;\n', '\n', '\n', '/// @title API3 pool contract\n', '/// @notice Users can stake API3 tokens at the pool contract to be granted\n', '/// shares. These shares are exposed to the Aragon-based DAO, giving the user\n', '/// voting power at the DAO. Staking pays out weekly rewards that get unlocked\n', '/// after a year, and staked funds are used to collateralize an insurance\n', '/// product that is outside the scope of this contract.\n', '/// @dev Functionalities of the contract are distributed to files that form a\n', '/// chain of inheritance:\n', '/// (1) Api3Pool.sol\n', '/// (2) TimelockUtils.sol\n', '/// (3) ClaimUtils.sol\n', '/// (4) StakeUtils.sol\n', '/// (5) TransferUtils.sol\n', '/// (6) DelegationUtils.sol\n', '/// (7) RewardUtils.sol\n', '/// (8) GetterUtils.sol\n', '/// (9) StateUtils.sol\n', 'contract Api3Pool is TimelockUtils, IApi3Pool {\n', '    /// @param api3TokenAddress API3 token contract address\n', '    /// @param timelockManagerAddress Timelock manager contract address\n', '    constructor(\n', '        address api3TokenAddress,\n', '        address timelockManagerAddress\n', '        )\n', '        StateUtils(\n', '            api3TokenAddress,\n', '            timelockManagerAddress\n', '            )\n', '    {}\n', '}']