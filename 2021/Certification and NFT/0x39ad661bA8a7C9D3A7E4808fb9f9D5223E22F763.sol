['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-11\n', '*/\n', '\n', '// File: contracts\\modules\\Ownable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract Ownable {\n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor() internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns true if the caller is the current owner.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts\\modules\\Managerable.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Managerable is Ownable {\n', '\n', '    address private _managerAddress;\n', '    /**\n', '     * @dev modifier, Only manager can be granted exclusive access to specific functions. \n', '     *\n', '     */\n', '    modifier onlyManager() {\n', '        require(_managerAddress == msg.sender,"Managerable: caller is not the Manager");\n', '        _;\n', '    }\n', '    /**\n', '     * @dev set manager by owner. \n', '     *\n', '     */\n', '    function setManager(address managerAddress)\n', '    public\n', '    onlyOwner\n', '    {\n', '        _managerAddress = managerAddress;\n', '    }\n', '    /**\n', '     * @dev get manager address. \n', '     *\n', '     */\n', '    function getManager()public view returns (address) {\n', '        return _managerAddress;\n', '    }\n', '}\n', '\n', '// File: contracts\\FNXMinePool\\IFNXMinePool.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface IFNXMinePool {\n', '    function transferMinerCoin(address account,address recieptor,uint256 amount)external;\n', '    function mintMinerCoin(address account,uint256 amount) external;\n', '    function burnMinerCoin(address account,uint256 amount) external;\n', '    function addMinerBalance(address account,uint256 amount) external;\n', '}\n', 'contract ImportFNXMinePool is Ownable{\n', '    IFNXMinePool internal _FnxMinePool;\n', '    function getFNXMinePoolAddress() public view returns(address){\n', '        return address(_FnxMinePool);\n', '    }\n', '    function setFNXMinePoolAddress(address fnxMinePool)public onlyOwner{\n', '        _FnxMinePool = IFNXMinePool(fnxMinePool);\n', '    }\n', '}\n', '\n', '// File: contracts\\ERC20\\Erc20Data.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'contract Erc20Data is Ownable{\n', '    string public name;\n', '    string public symbol;\n', '    uint8 public decimals = 18;\n', '    \n', '\n', '    mapping (address => uint256) internal balances;\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '    uint256 internal _totalSupply;\n', '    \n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: contracts\\modules\\timeLimitation.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', 'contract timeLimitation is Ownable {\n', '    \n', '    /**\n', "     * @dev FPT has burn time limit. When user's balance is moved in som coins, he will wait `timeLimited` to burn FPT. \n", "     * latestTransferIn is user's latest time when his balance is moved in.\n", '     */\n', '    mapping(uint256=>uint256) internal itemTimeMap;\n', '    uint256 internal limitation = 1 hours;\n', '    /**\n', '     * @dev set time limitation, only owner can invoke. \n', '     * @param _limitation new time limitation.\n', '     */ \n', '    function setTimeLimitation(uint256 _limitation) public onlyOwner {\n', '        limitation = _limitation;\n', '    }\n', '    function setItemTimeLimitation(uint256 item) internal{\n', '        itemTimeMap[item] = now;\n', '    }\n', '    function getTimeLimitation() public view returns (uint256){\n', '        return limitation;\n', '    }\n', '    /**\n', "     * @dev Retrieve user's start time for burning. \n", '     * @param item item key.\n', '     */ \n', '    function getItemTimeLimitation(uint256 item) public view returns (uint256){\n', '        return itemTimeMap[item]+limitation;\n', '    }\n', '    modifier OutLimitation(uint256 item) {\n', '        require(itemTimeMap[item]+limitation<now,"Time limitation is not expired!");\n', '        _;\n', '    }    \n', '}\n', '\n', '// File: contracts\\FPTCoin\\FPTData.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', 'contract FPTData is Erc20Data,ImportFNXMinePool,Managerable,timeLimitation{\n', '    /**\n', '    * @dev lock mechanism is used when user redeem collateral and left collateral is insufficient.\n', '    * _totalLockedWorth stores total locked worth, priced in USD.\n', "    * lockedBalances stores user's locked FPTCoin.\n", "    * lockedTotalWorth stores user's locked worth, priced in USD. For locked FPTCoin's net worth is constant when It was locked.\n", '    */\n', '    uint256 internal _totalLockedWorth;\n', '    mapping (address => uint256) internal lockedBalances;\n', '    mapping (address => uint256) internal lockedTotalWorth;\n', '    /**\n', '     * @dev Emitted when `owner` locked  `amount` FPT, which net worth is  `worth` in USD. \n', '     */\n', '    event AddLocked(address indexed owner, uint256 amount,uint256 worth);\n', '    /**\n', '     * @dev Emitted when `owner` burned locked  `amount` FPT, which net worth is  `worth` in USD. \n', '     */\n', '    event BurnLocked(address indexed owner, uint256 amount,uint256 worth);\n', '\n', '}\n', '\n', '// File: contracts\\Proxy\\baseProxy.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '/**\n', ' * @title  baseProxy Contract\n', '\n', ' */\n', 'contract baseProxy is Ownable {\n', '    address public implementation;\n', '    constructor(address implementation_) public {\n', '        // Creator of the contract is admin during initialization\n', '        implementation = implementation_; \n', '        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature("initialize()"));\n', '        require(success);\n', '    }\n', '    function getImplementation()public view returns(address){\n', '        return implementation;\n', '    }\n', '    function setImplementation(address implementation_)public onlyOwner{\n', '        implementation = implementation_; \n', '        (bool success,) = implementation_.delegatecall(abi.encodeWithSignature("update()"));\n', '        require(success);\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to the implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n', '        (bool success, bytes memory returnData) = implementation.delegatecall(data);\n', '        assembly {\n', '            if eq(success, 0) {\n', '                revert(add(returnData, 0x20), returndatasize)\n', '            }\n', '        }\n', '        return returnData;\n', '    }\n', '\n', '    /**\n', '     * @notice Delegates execution to an implementation contract\n', '     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n', '     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n', '     * @param data The raw data to delegatecall\n', '     * @return The returned bytes from the delegatecall\n', '     */\n', '    function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n', '        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature("delegateToImplementation(bytes)", data));\n', '        assembly {\n', '            if eq(success, 0) {\n', '                revert(add(returnData, 0x20), returndatasize)\n', '            }\n', '        }\n', '        return abi.decode(returnData, (bytes));\n', '    }\n', '\n', '    function delegateToViewAndReturn() internal view returns (bytes memory) {\n', '        (bool success, ) = address(this).staticcall(abi.encodeWithSignature("delegateToImplementation(bytes)", msg.data));\n', '\n', '        assembly {\n', '            let free_mem_ptr := mload(0x40)\n', '            returndatacopy(free_mem_ptr, 0, returndatasize)\n', '\n', '            switch success\n', '            case 0 { revert(free_mem_ptr, returndatasize) }\n', '            default { return(add(free_mem_ptr, 0x40), returndatasize) }\n', '        }\n', '    }\n', '\n', '    function delegateAndReturn() internal returns (bytes memory) {\n', '        (bool success, ) = implementation.delegatecall(msg.data);\n', '\n', '        assembly {\n', '            let free_mem_ptr := mload(0x40)\n', '            returndatacopy(free_mem_ptr, 0, returndatasize)\n', '\n', '            switch success\n', '            case 0 { revert(free_mem_ptr, returndatasize) }\n', '            default { return(free_mem_ptr, returndatasize) }\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts\\ERC20\\Erc20BaseProxy.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '/**\n', ' * @title  Erc20Delegator Contract\n', '\n', ' */\n', 'contract Erc20BaseProxy is baseProxy{\n', '    constructor(address implementation_) baseProxy(implementation_) public  {\n', '    }\n', '    /**\n', '     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n', '     *  dst  The address of the destination account\n', '     *  amount  The number of tokens to transfer\n', '     * @return Whether or not the transfer succeeded\n', '     */\n', '     function totalSupply() external view returns (uint256){\n', '         delegateToViewAndReturn();\n', '     }\n', '    function transfer(address /*dst*/, uint /*amount*/) external returns (bool) {\n', '        delegateAndReturn();\n', '    }\n', '\n', '    /**\n', '     * @notice Transfer `amount` tokens from `src` to `dst`\n', '     */\n', '    function transferFrom(address /*src*/, address /*dst*/, uint256 /*amount*/) external returns (bool) {\n', '        delegateAndReturn();\n', '    }\n', '\n', '    /**\n', '     * @notice Approve `spender` to transfer up to `amount` from `src`\n', '     * @dev This will overwrite the approval amount for `spender`\n', '     * @return Whether or not the approval succeeded\n', '     */\n', '    function approve(address /*spender*/, uint256 /*amount*/) external returns (bool) {\n', '        delegateAndReturn();\n', '    }\n', '\n', '    /**\n', '     * @notice Get the current allowance from `owner` for `spender`\n', '     * owner The address of the account which owns the tokens to be spent\n', '     * spender The address of the account which may transfer tokens\n', '     * @return The number of tokens allowed to be spent (-1 means infinite)\n', '     */\n', '    function allowance(address /*owner*/, address /*spender*/) external view returns (uint) {\n', '        delegateToViewAndReturn();\n', '    }\n', '\n', '    /**\n', '     * @notice Get the token balance of the `owner`\n', '     * owner The address of the account to query\n', '     * @return The number of tokens owned by `owner`\n', '     */\n', '    function balanceOf(address /*owner*/) external view returns (uint) {\n', '        delegateToViewAndReturn();\n', '    }\n', '}\n', '\n', '// File: contracts\\FPTCoin\\FPTProxy.sol\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '\n', ' * @title FPTCoin is finnexus collateral Pool token, implement ERC20 interface.\n', '\n', ' * @dev ERC20 token. Its inside value is collatral pool net worth.\n', '\n', ' *\n', '\n', ' */\n', '\n', 'contract FPTProxy is FPTData,Erc20BaseProxy {\n', '\n', '    constructor (address implementation_,address minePoolAddr,string memory tokenName) Erc20BaseProxy(implementation_) public{\n', '\n', '        _FnxMinePool = IFNXMinePool(minePoolAddr);\n', '\n', '        name = tokenName;\n', '\n', '        symbol = tokenName;\n', '\n', '    }\n', '\n', '    /**\n', '\n', "     * @dev Retrieve user's start time for burning. \n", '\n', "     *  user user's account.\n", '\n', '     */ \n', '\n', '    function getUserBurnTimeLimite(address /*user*/) public view returns (uint256){\n', '\n', '        delegateToViewAndReturn();\n', '\n', '    }\n', '\n', '    /**\n', '\n', '     * @dev Retrieve total locked worth. \n', '\n', '     */ \n', '\n', '    function getTotalLockedWorth() public view returns (uint256) {\n', '\n', '        delegateToViewAndReturn();\n', '\n', '    }\n', '\n', '    /**\n', '\n', "     * @dev Retrieve user's locked balance. \n", '\n', "     *  account user's account.\n", '\n', '     */ \n', '\n', '    function lockedBalanceOf(address /*account*/) public view returns (uint256) {\n', '\n', '        delegateToViewAndReturn();\n', '\n', '    }\n', '\n', '    /**\n', '\n', "     * @dev Retrieve user's locked net worth. \n", '\n', "     *  account user's account.\n", '\n', '     */ \n', '\n', '    function lockedWorthOf(address /*account*/) public view returns (uint256) {\n', '\n', '        delegateToViewAndReturn();\n', '\n', '    }\n', '\n', '    /**\n', '\n', "     * @dev Retrieve user's locked balance and locked net worth. \n", '\n', "     *  account user's account.\n", '\n', '     */ \n', '\n', '    function getLockedBalance(address /*account*/) public view returns (uint256,uint256) {\n', '\n', '        delegateToViewAndReturn();\n', '\n', '    }\n', '\n', '    /**\n', '\n', '     * @dev Interface to manager FNX mine pool contract, add miner balance when user has bought some options. \n', '\n', "     *  account user's account.\n", '\n', "     *  amount user's pay for buying options, priced in USD.\n", '\n', '     */ \n', '\n', '    function addMinerBalance(address /*account*/,uint256 /*amount*/) public{\n', '\n', '        delegateAndReturn();\n', '\n', '    }\n', '\n', '    /**\n', '\n', "     * @dev Move user's FPT to locked balance, when user redeem collateral. \n", '\n', "     *  account user's account.\n", '\n', '     *  amount amount of locked FPT.\n', '\n', '     *  lockedWorth net worth of locked FPT.\n', '\n', '     */ \n', '\n', '    function addlockBalance(address /*account*/, uint256 /*amount*/,uint256 /*lockedWorth*/)public {\n', '\n', '        delegateAndReturn();\n', '\n', '    }\n', '\n', '\n', '\n', '    /**\n', '\n', "     * @dev burn user's FPT when user redeem FPTCoin. \n", '\n', "     *  account user's account.\n", '\n', '     *  amount amount of FPT.\n', '\n', '     */ \n', '\n', '    function burn(address /*account*/, uint256 /*amount*/) public {\n', '\n', '        delegateAndReturn();\n', '\n', '    }\n', '\n', '    /**\n', '\n', "     * @dev mint user's FPT when user add collateral. \n", '\n', "     *  account user's account.\n", '\n', '     *  amount amount of FPT.\n', '\n', '     */ \n', '\n', '    function mint(address /*account*/, uint256 /*amount*/) public {\n', '\n', '        delegateAndReturn();\n', '\n', '    }\n', '\n', '    /**\n', '\n', '     * @dev An interface of redeem locked FPT, when user redeem collateral, only manager contract can invoke. \n', '\n', "     *  account user's account.\n", '\n', '     *  tokenAmount amount of FPT.\n', '\n', '     *  leftCollateral left available collateral in collateral pool, priced in USD.\n', '\n', '     */ \n', '\n', '    function redeemLockedCollateral(address /*account*/,uint256 /*tokenAmount*/,uint256 /*leftCollateral*/)\n', '\n', '            public returns (uint256,uint256){\n', '\n', '        delegateAndReturn();\n', '\n', '    }\n', '\n', '}']