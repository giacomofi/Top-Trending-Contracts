['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title IDerivativePriceFeed Interface\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Simple interface for derivative price source oracle implementations\n', 'interface IDerivativePriceFeed {\n', '    function calcUnderlyingValues(address, uint256)\n', '        external\n', '        returns (address[] memory, uint256[] memory);\n', '\n', '    function isSupportedAsset(address) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import "../../../../interfaces/IChainlinkAggregator.sol";\n', 'import "../../../../utils/MakerDaoMath.sol";\n', 'import "../IDerivativePriceFeed.sol";\n', '\n', '/// @title WdgldPriceFeed Contract\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Price source oracle for WDGLD <https://dgld.ch/>\n', 'contract WdgldPriceFeed is IDerivativePriceFeed, MakerDaoMath {\n', '    using SafeMath for uint256;\n', '\n', '    address private immutable XAU_AGGREGATOR;\n', '    address private immutable ETH_AGGREGATOR;\n', '\n', '    address private immutable WDGLD;\n', '    address private immutable WETH;\n', '\n', '    // GTR_CONSTANT aggregates all the invariants in the GTR formula to save gas\n', '    uint256 private constant GTR_CONSTANT = 999990821653213975346065101;\n', '    uint256 private constant GTR_PRECISION = 10**27;\n', '    uint256 private constant WDGLD_GENESIS_TIMESTAMP = 1568700000;\n', '\n', '    constructor(\n', '        address _wdgld,\n', '        address _weth,\n', '        address _ethAggregator,\n', '        address _xauAggregator\n', '    ) public {\n', '        WDGLD = _wdgld;\n', '        WETH = _weth;\n', '        ETH_AGGREGATOR = _ethAggregator;\n', '        XAU_AGGREGATOR = _xauAggregator;\n', '    }\n', '\n', '    /// @notice Converts a given amount of a derivative to its underlying asset values\n', '    /// @param _derivative The derivative to convert\n', '    /// @param _derivativeAmount The amount of the derivative to convert\n', '    /// @return underlyings_ The underlying assets for the _derivative\n', '    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n', '    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n', '        external\n', '        override\n', '        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n', '    {\n', '        require(isSupportedAsset(_derivative), "calcUnderlyingValues: Only WDGLD is supported");\n', '\n', '        underlyings_ = new address[](1);\n', '        underlyings_[0] = WETH;\n', '        underlyingAmounts_ = new uint256[](1);\n', '\n', '        // Get price rates from xau and eth aggregators\n', '        int256 xauToUsdRate = IChainlinkAggregator(XAU_AGGREGATOR).latestAnswer();\n', '        int256 ethToUsdRate = IChainlinkAggregator(ETH_AGGREGATOR).latestAnswer();\n', '        require(xauToUsdRate > 0 && ethToUsdRate > 0, "calcUnderlyingValues: rate invalid");\n', '\n', '        uint256 wdgldToXauRate = calcWdgldToXauRate();\n', '\n', '        // 10**17 is a combination of ETH_UNIT / WDGLD_UNIT * GTR_PRECISION\n', '        underlyingAmounts_[0] = _derivativeAmount\n', '            .mul(wdgldToXauRate)\n', '            .mul(uint256(xauToUsdRate))\n', '            .div(uint256(ethToUsdRate))\n', '            .div(10**17);\n', '\n', '        return (underlyings_, underlyingAmounts_);\n', '    }\n', '\n', '    /// @notice Calculates the rate of WDGLD to XAU.\n', '    /// @return wdgldToXauRate_ The current rate of WDGLD to XAU\n', '    /// @dev Full formula available <https://dgld.ch/assets/documents/dgld-whitepaper.pdf>\n', '    function calcWdgldToXauRate() public view returns (uint256 wdgldToXauRate_) {\n', '        return\n', '            __rpow(\n', '                GTR_CONSTANT,\n', '                ((block.timestamp).sub(WDGLD_GENESIS_TIMESTAMP)).div(28800), // 60 * 60 * 8 (8 hour periods)\n', '                GTR_PRECISION\n', '            )\n', '                .div(10);\n', '    }\n', '\n', '    /// @notice Checks if an asset is supported by this price feed\n', '    /// @param _asset The asset to check\n', '    /// @return isSupported_ True if supported\n', '    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\n', '        return _asset == WDGLD;\n', '    }\n', '\n', '    ///////////////////\n', '    // STATE GETTERS //\n', '    ///////////////////\n', '\n', '    /// @notice Gets the `ETH_AGGREGATOR` address\n', '    /// @return ethAggregatorAddress_ The `ETH_AGGREGATOR` address\n', '    function getEthAggregator() external view returns (address ethAggregatorAddress_) {\n', '        return ETH_AGGREGATOR;\n', '    }\n', '\n', '    /// @notice Gets the `WDGLD` token address\n', '    /// @return wdgld_ The `WDGLD` token address\n', '    function getWdgld() external view returns (address wdgld_) {\n', '        return WDGLD;\n', '    }\n', '\n', '    /// @notice Gets the `WETH` token address\n', '    /// @return weth_ The `WETH` token address\n', '    function getWeth() external view returns (address weth_) {\n', '        return WETH;\n', '    }\n', '\n', '    /// @notice Gets the `XAU_AGGREGATOR` address\n', '    /// @return xauAggregatorAddress_ The `XAU_AGGREGATOR` address\n', '    function getXauAggregator() external view returns (address xauAggregatorAddress_) {\n', '        return XAU_AGGREGATOR;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title IChainlinkAggregator Interface\n', '/// @author Enzyme Council <[email\xa0protected]>\n', 'interface IChainlinkAggregator {\n', '    function latestAnswer() external view returns (int256);\n', '\n', '    function latestTimestamp() external view returns (uint256);\n', '}\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', '\n', '// Copyright (C) 2018 Rain <[email\xa0protected]>\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title MakerDaoMath Contract\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Helper functions for math operations adapted from MakerDao contracts\n', 'abstract contract MakerDaoMath {\n', '    /// @dev Performs scaled, fixed-point exponentiation.\n', '    /// Verbatim code, adapted to our style guide for variable naming only, see:\n', '    /// https://github.com/makerdao/dss/blob/master/src/pot.sol#L83-L105\n', '    // prettier-ignore\n', '    function __rpow(uint256 _x, uint256 _n, uint256 _base) internal pure returns (uint256 z_) {\n', '        assembly {\n', '            switch _x case 0 {switch _n case 0 {z_ := _base} default {z_ := 0}}\n', '            default {\n', '                switch mod(_n, 2) case 0 { z_ := _base } default { z_ := _x }\n', '                let half := div(_base, 2)\n', '                for { _n := div(_n, 2) } _n { _n := div(_n,2) } {\n', '                    let xx := mul(_x, _x)\n', '                    if iszero(eq(div(xx, _x), _x)) { revert(0,0) }\n', '                    let xxRound := add(xx, half)\n', '                    if lt(xxRound, xx) { revert(0,0) }\n', '                    _x := div(xxRound, _base)\n', '                    if mod(_n,2) {\n', '                        let zx := mul(z_, _x)\n', '                        if and(iszero(iszero(_x)), iszero(eq(div(zx, _x), z_))) { revert(0,0) }\n', '                        let zxRound := add(zx, half)\n', '                        if lt(zxRound, zx) { revert(0,0) }\n', '                        z_ := div(zxRound, _base)\n', '                    }\n', '                }\n', '            }\n', '        }\n', '\n', '        return z_;\n', '    }\n', '}\n', '\n', '{\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "metadata": {\n', '    "bytecodeHash": "ipfs",\n', '    "useLiteralContent": true\n', '  },\n', '  "optimizer": {\n', '    "details": {\n', '      "constantOptimizer": true,\n', '      "cse": true,\n', '      "deduplicate": true,\n', '      "jumpdestRemover": true,\n', '      "orderLiterals": true,\n', '      "peephole": true,\n', '      "yul": false\n', '    },\n', '    "runs": 200\n', '  },\n', '  "remappings": [],\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']