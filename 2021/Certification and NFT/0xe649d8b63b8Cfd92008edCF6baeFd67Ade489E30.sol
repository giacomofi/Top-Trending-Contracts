['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.0;\n', '\n', 'import "./libraries/SafeERC20.sol";\n', 'import "./interfaces/IUniswapV2Pair.sol";\n', 'import "./interfaces/IWeth.sol";\n', '\n', 'contract StableConverter {\n', '    using SafeERC20 for IERC20;\n', '\n', '    /**\n', '     * @notice admin\n', '     */\n', '    address public admin;\n', '\n', '    /**\n', '     * @notice WETH token\n', '     */\n', '    address public immutable weth;\n', '\n', '    /*** Events ***/\n', '\n', '    /**\n', '     * @notice Emitted when a conversion occured\n', '     */\n', '    event Convert(address indexed server, address indexed fromToken, address indexed toToken, uint fromAmount, uint toAmount);\n', '\n', '    /**\n', '     * @notice Emitted when a new admin is set\n', '     */\n', '    event AdminSet(address indexed admin);\n', '\n', '    /**\n', '     * @notice Emitted when admin seize tokens\n', '     */\n', '    event Seize(address indexed token, uint indexed amount);\n', '\n', '    constructor(\n', '        address _admin,\n', '        address _weth\n', '    ) {\n', '        admin = _admin;\n', '        weth = _weth;\n', '    }\n', '\n', '    modifier isAdmin() {\n', '        require(msg.sender == admin, "only admin could perform the action");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice Execute a series of tokens conversion according to the specified contract address.\n', '     * @param token The token address list\n', '     * @param token The contract address list\n', '     * @param amount The conversion amount list\n', '     */\n', '    function convertMultiple(address[] calldata token, address[] calldata pair, uint[] calldata amount) external isAdmin() {\n', '        require(token.length == amount.length, "invalid data");\n', '        require(token.length == pair.length, "invalid data");\n', '\n', '        for (uint i = 0; i < token.length; i++) {\n', '             // if contract address not specified, no conversion\n', '            if (pair[i] == address(0)) continue;\n', '            // if contract is WETH and token is ETH, then convert to WETH\n', '            if (pair[i] == weth && token[i] == address(0)) {\n', '                convertEthToWeth(amount[i]);\n', '            }\n', '            convertWithPair(token[i], pair[i], amount[i]);\n', '        }\n', '    }\n', '\n', '    /*** Internal functions ***/\n', '\n', '    /**\n', '     * @notice Convert token with the specified Swap V2 (Uni/Sushi) contract\n', '     * @param token The input token address\n', '     * @param pair The conversion contract address\n', '     * @param amount The amount needs to be converted\n', '     */\n', '    function convertWithPair(address token, address pair, uint amount) internal {\n', '        uint convertAmount = amount;\n', '        // if maximum amount is specified, swap the balance only\n', '        if (amount == type(uint).max) {\n', '            convertAmount = IERC20(token).balanceOf(address(this));\n', '        }\n', '        swap(token, pair, convertAmount, address(this));\n', '    }\n', '\n', '    /**\n', '     * @notice Calculate swap output amount based on input amount and reserves\n', '     * @param amountIn The token amount to swap\n', '     * @param reserveIn Reserve of input token in the pair\n', '     * @param reserveOut Reserve of output token in the pair\n', '     * @return amountOut Calculated swap output token amount\n', '     */\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', '        uint amountInWithFee = amountIn * 997;\n', '        uint numerator = amountInWithFee * reserveOut;\n', '        uint denominator = reserveIn * 1000 + amountInWithFee;\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    /**\n', '     * @notice Convert ETH to WETH\n', '     * @param amount The amount of ETH to be converted\n', '     */\n', '    function convertEthToWeth(uint amount) internal {\n', '        IWeth(weth).deposit{value: amount}();\n', '        emit Convert(msg.sender, address(0), weth, amount, amount);\n', '    }\n', '\n', '    /**\n', '     * @notice Swap fromToken using the given pairAddress\n', '     * @param fromToken The from token\n', '     * @param pairAddress The swap contract address to swap with\n', '     * @param amountIn The amount of fromToken needs to be swapped\n', '     * @param to The receiver after the swap\n', '     * @return amountOut The amount of toToken that will be sent to the receiver\n', '     */\n', '    function swap(address fromToken, address pairAddress, uint amountIn, address to) internal returns (uint amountOut) {\n', '        address toToken;\n', '        IUniswapV2Pair pair = IUniswapV2Pair(pairAddress);\n', '        require(address(pair) != address(0), "invalid pair");\n', '\n', '        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n', '\n', '        if (fromToken == pair.token0()) {\n', '            toToken = pair.token1();\n', '            amountOut = getAmountOut(amountIn, reserve0, reserve1);\n', '            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n', '            pair.swap(0, amountOut, address(this), new bytes(0));\n', '        } else {\n', '            toToken = pair.token0();\n', '            amountOut = getAmountOut(amountIn, reserve1, reserve0);\n', '            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n', '            pair.swap(amountOut, 0, address(this), new bytes(0));\n', '        }\n', '        emit Convert(msg.sender, fromToken, toToken, amountIn, amountOut);\n', '    }\n', '\n', '    /*** Admin functions ***/\n', '\n', '    /**\n', '     * @notice Set the new admin.\n', '     * @param newAdmin The new admin\n', '     */\n', '    function setAdmin(address newAdmin) external isAdmin() {\n', '        admin = newAdmin;\n', '        emit AdminSet(admin);\n', '    }\n', '\n', '    /**\n', '     * @notice Seize token to admin.\n', '     * @param token The token address. Empty address for Ether.\n', '     * @param amount The amount to seize\n', '     */\n', '    function seize(address token, uint amount) external isAdmin() {\n', '        if (token == address(0)) {\n', '            payable(admin).transfer(amount);\n', '        } else {\n', '            IERC20(token).safeTransfer(admin, amount);\n', '        }\n', '        emit Seize(token, amount);\n', '    }\n', '\n', '    receive() external payable {}\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.0;\n', '\n', 'import "../interfaces/IERC20.sol";\n', '\n', 'library SafeERC20 {\n', '    function safeSymbol(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeName(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeDecimals(IERC20 token) public view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: Transfer failed");\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// SPDX-License-Identifier: GNU\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IWeth {\n', '    function deposit() external payable;\n', '    function withdraw(uint wad) external;\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    // EIP 2612\n', '    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 200\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']