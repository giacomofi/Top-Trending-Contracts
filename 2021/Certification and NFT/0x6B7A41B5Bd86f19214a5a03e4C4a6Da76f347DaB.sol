['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.9;\n', '\n', 'import "IInterestManager.sol";\n', 'import "Ownable.sol";\n', 'import "ICToken.sol";\n', 'import "IComptroller.sol";\n', 'import "IERC20.sol";\n', 'import "Initializable.sol";\n', 'import "SafeMath.sol";\n', '\n', '/**\n', ' * @title InterestManagerCompound\n', ' * @author Alexander Schlindwein\n', ' * \n', ' * Invests DAI into Compound to generate interest\n', ' * Sits behind an AdminUpgradabilityProxy \n', ' */\n', 'contract InterestManagerCompound is Ownable, Initializable {\n', '\n', '    using SafeMath for uint;\n', '\n', '    // Dai contract\n', '    IERC20 private _dai;\n', '    // cDai contract\n', '    ICToken private _cDai;\n', '    // COMP contract\n', '    IERC20 private _comp;\n', '    // Address which is allowed to withdraw accrued COMP tokens\n', '    address private _compRecipient;\n', '\n', '    /**\n', '     * Initializes the contract with all required values\n', '     *\n', '     * @param owner The owner of the contract\n', '     * @param dai The Dai token address\n', '     * @param cDai The cDai token address\n', '     * @param comp The Comp token address\n', '     * @param compRecipient The address of the recipient of the Comp tokens\n', '     */\n', '    function initialize(address owner, address dai, address cDai, address comp, address compRecipient) external initializer {\n', '        require(dai != address(0) &&\n', '                cDai != address(0) && \n', '                comp != address(0) &&\n', '                compRecipient != address(0),\n', '                "invalid-params");\n', '\n', '        setOwnerInternal(owner); // Checks owner to be non-zero\n', '        _dai = IERC20(dai);\n', '        _cDai = ICToken(cDai);\n', '        _comp = IERC20(comp);\n', '        _compRecipient = compRecipient;\n', '    }\n', '\n', '    /**\n', '     * Invests a given amount of Dai into Compound\n', '     * The Dai have to be transfered to this contract before this function is called\n', '     *\n', '     * @param amount The amount of Dai to invest\n', '     *\n', '     * @return The amount of minted cDai\n', '     */\n', '    function invest(uint amount) external onlyOwner returns (uint) {\n', '        uint balanceBefore = _cDai.balanceOf(address(this));\n', '        require(_dai.balanceOf(address(this)) >= amount, "insufficient-dai");\n', '        require(_dai.approve(address(_cDai), amount), "dai-cdai-approve");\n', '        require(_cDai.mint(amount) == 0, "cdai-mint");\n', '        uint balanceAfter = _cDai.balanceOf(address(this));\n', '        return balanceAfter.sub(balanceBefore);\n', '    }\n', '\n', '    /**\n', '     * Redeems a given amount of Dai from Compound and sends it to the recipient\n', '     *\n', '     * @param recipient The recipient of the redeemed Dai\n', '     * @param amount The amount of Dai to redeem\n', '     *\n', '     * @return The amount of burned cDai\n', '     */\n', '    function redeem(address recipient, uint amount) external onlyOwner returns (uint) {\n', '        uint balanceBefore = _cDai.balanceOf(address(this));\n', '        require(_cDai.redeemUnderlying(amount) == 0, "redeem");\n', '        uint balanceAfter = _cDai.balanceOf(address(this));\n', '        require(_dai.transfer(recipient, amount), "dai-transfer");\n', '        return balanceBefore.sub(balanceAfter);\n', '    }\n', '\n', '    /**\n', '     * Redeems a given amount of cDai from Compound and sends Dai to the recipient\n', '     *\n', '     * @param recipient The recipient of the redeemed Dai\n', '     * @param amount The amount of cDai to redeem\n', '     *\n', '     * @return The amount of redeemed Dai\n', '     */\n', '    function redeemInvestmentToken(address recipient, uint amount) external onlyOwner returns (uint) {\n', '        uint balanceBefore = _dai.balanceOf(address(this));\n', '        require(_cDai.redeem(amount) == 0, "redeem");\n', '        uint redeemed = _dai.balanceOf(address(this)).sub(balanceBefore);\n', '        require(_dai.transfer(recipient, redeemed), "dai-transfer");\n', '        return redeemed;\n', '    }\n', '\n', '    /**\n', '     * Updates accrued interest on the invested Dai\n', '     */\n', '    function accrueInterest() external {\n', '        require(_cDai.accrueInterest() == 0, "accrue");\n', '    }\n', '\n', '    /**\n', '     * Withdraws the generated Comp tokens to the Comp recipient\n', '     */\n', '    function withdrawComp() external {\n', '        address addr = address(this);\n', '        IComptroller(_cDai.comptroller()).claimComp(addr);\n', '        require(_comp.transfer(_compRecipient, _comp.balanceOf(addr)), "comp-transfer");\n', '    }\n', '\n', '    /**\n', '     * Converts an amount of underlying tokens to an amount of investment tokens\n', '     *\n', '     * @param underlyingAmount The amount of underlying tokens\n', '     *\n', '     * @return The amount of investment tokens\n', '     */\n', '    function underlyingToInvestmentToken(uint underlyingAmount) external view returns (uint) {\n', '        return divScalarByExpTruncate(underlyingAmount, _cDai.exchangeRateStored());\n', '    }\n', '\n', '    /**\n', '     * Converts an amount of investment tokens to an amount of underlying tokens\n', '     *\n', '     * @param investmentTokenAmount The amount of investment tokens\n', '     *\n', '     * @return The amount of underlying tokens\n', '     */\n', '    function investmentTokenToUnderlying(uint investmentTokenAmount) external view returns (uint) {\n', '        return mulScalarTruncate(investmentTokenAmount, _cDai.exchangeRateStored());\n', '    }\n', '\n', '    // ====================================== COMPOUND MATH ======================================\n', '    // https://github.com/compound-finance/compound-protocol/blob/master/contracts/Exponential.sol\n', '    //\n', '    // Modified to revert instead of returning an error code\n', '\n', '    function mulScalarTruncate(uint a, uint scalar) pure internal returns (uint) {\n', '        uint product = mulScalar(a, scalar);\n', '        return truncate(product);\n', '    }\n', '\n', '    function mulScalar(uint a, uint scalar) pure internal returns (uint) {\n', '        return a.mul(scalar);\n', '    }\n', '\n', '    function divScalarByExpTruncate(uint scalar, uint divisor) pure internal returns (uint) {\n', '        uint fraction = divScalarByExp(scalar, divisor);\n', '        return truncate(fraction);\n', '    }\n', '\n', '    function divScalarByExp(uint scalar, uint divisor) pure internal returns (uint) {\n', '        uint numerator = uint(10**18).mul(scalar);\n', '        return getExp(numerator, divisor);\n', '    }\n', '\n', '    function getExp(uint num, uint denom) pure internal returns (uint) {\n', '        uint scaledNumerator = num.mul(10**18);\n', '        return scaledNumerator.div(denom);\n', '    }\n', '\n', '    function truncate(uint num) pure internal returns (uint) {\n', '        return num / 10**18;\n', '    }\n', '\n', '}']