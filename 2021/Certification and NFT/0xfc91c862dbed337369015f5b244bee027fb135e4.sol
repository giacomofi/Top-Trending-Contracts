['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-26\n', '*/\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.3;\n', 'pragma experimental SMTChecker;\n', '\n', '\n', 'interface ERC20If {\n', '  function balanceOf(address _who) external view returns (uint256);\n', '  function transfer(address _to, uint256 _value) external returns (bool);\n', '}\n', '\n', 'contract MultiSig{\n', '    receive() external payable {}\n', '\n', '    uint256 public nonce = 0;\n', '\n', '    int private withdrawFlag1 = 0;\n', '    int private withdrawFlag2 = 0;\n', '    int private withdrawFlag3 = 0;\n', '\n', '    int private closeFlag1 = 0;\n', '    int private closeFlag2 = 0;\n', '    int private closeFlag3 = 0;\n', '\n', '    address[] private owners=new address[](3);\n', '\n', '    constructor(address _owner1,address _owner2,address _owner3)\n', '    {\n', '        require(_owner1!=_owner2);\n', '        require(_owner1!=_owner3);\n', '        require(_owner2!=_owner3);\n', '\n', '        owners[0] = _owner1;\n', '        owners[1] = _owner2;\n', '        owners[2] = _owner3;\n', '    }\n', '\n', '    fallback() external payable {}\n', '\n', '    function getMessageToSignature(address payable[] memory dests, uint256[] memory values) private view returns (bytes memory) {\n', '        return abi.encode(nonce, dests, values, this);\n', '    }\n', '\n', '//测试使用\n', '//    function testABIEncode(address[] memory dests, uint256[] memory values,\n', '  //                  uint8 v1, bytes32 r1, bytes32 s1,\n', '    //                uint8 v2, bytes32 r2, bytes32 s2) public view returns (bytes memory) {\n', '      //  return abi.encode(dests, values,v1,r1, s1, v2, r2, s2);\n', '    //}\n', '\n', '    function recoverAddress(bytes32 message, uint8 v, bytes32 r, bytes32 s) private pure returns (address) {\n', '        return ecrecover(message, v, r, s);\n', '    }\n', '\n', '    function hash(bytes memory data) private pure returns (bytes32) {\n', '        return sha256(data);\n', '    }\n', '\n', '    function _validAddress(address addr) private view returns (bool) {\n', '        return owners[0] == addr || owners[1] == addr || owners[2] == addr;\n', '    }\n', '\n', '    function spend(address payable[] memory dests, uint256[] memory values,\n', '                    uint8 v1, bytes32 r1, bytes32 s1,\n', '                    uint8 v2, bytes32 r2, bytes32 s2) public payable {\n', '        require(dests.length > 0 && dests.length == values.length);\n', '        uint256  value;\n', '        for (uint i = 0; i < values.length; ++i){\n', '            value += values[i];\n', '            assert(value >= values[i]);\n', '        }\n', '        require(address(this).balance >= value, "insufficient funds");\n', '\n', '        bytes32 h=hash((getMessageToSignature(dests, values)));\n', '        address addr1=recoverAddress(h, v1, r1, s1);\n', '        address addr2=recoverAddress(h, v2, r2, s2);\n', '        require(addr1 != addr2, "failed to recover address");\n', '        require(_validAddress(addr1), "invalid address");\n', '        require(_validAddress(addr2), "invalid address");\n', '        nonce = nonce + 1;\n', '\n', '        for (uint i = 0; i < dests.length; ++i) {\n', '            // dests[i].transfer(values[i]);\n', '            (bool success, ) =dests[i].call{value:values[i]}("");\n', '            require(success, "transfer failed.");\n', '        }\n', '    }\n', '\n', '    function withdrawAll() public payable {\n', '        require(_validAddress(msg.sender), "invalid address");\n', '        if (msg.sender == owners[0]) {\n', '            withdrawFlag1 = 1;\n', '        }\n', '        else if (msg.sender == owners[1]) {\n', '            withdrawFlag2 = 1;\n', '        }\n', '        else if (msg.sender == owners[2]) {\n', '            withdrawFlag3 = 1;\n', '        }\n', '        else {\n', '                assert(false);\n', '        }\n', '\n', '        if ((withdrawFlag1+withdrawFlag2+withdrawFlag3)>=2) {\n', '            withdrawFlag1 = 0;\n', '            withdrawFlag2 = 0;\n', '            withdrawFlag3 = 0;\n', '            (bool success, ) = msg.sender.call{value:address(this).balance}("");\n', '            if (!success) {\n', '               revert("withdraw all failed");\n', '            }\n', '        }\n', '    }\n', '\n', '    function close() public payable {\n', '        require(_validAddress(msg.sender), "invalid address");\n', '        if (msg.sender == owners[0]) {\n', '            closeFlag1 = 1;\n', '        }\n', '        else if (msg.sender == owners[1]) {\n', '            closeFlag2 = 1;\n', '        }\n', '        else if (msg.sender == owners[2]) {\n', '            closeFlag3 = 1;\n', '        }\n', '        else {\n', '                assert(false);\n', '            }\n', '\n', '        if ((closeFlag1+closeFlag2+closeFlag3)>=2){\n', '            selfdestruct(msg.sender);\n', '        }\n', '    }\n', '\n', '    function transferERC20(address payable[] memory dests, uint256[] memory values,\n', '                    uint8 v1, bytes32 r1, bytes32 s1,\n', '                    uint8 v2, bytes32 r2, bytes32 s2, address erc20Token) public  {\n', '        require(dests.length > 0 && dests.length == values.length);\n', '        uint256  value;\n', '        for (uint i = 0; i < values.length; ++i){\n', '            value += values[i];\n', '            assert(value >= values[i]);\n', '        }\n', '        ERC20If _erc20=(ERC20If)(erc20Token);\n', '        require(_erc20.balanceOf(address(this)) >= value, "insufficient ERC20 funds");\n', '\n', '        require(\n', '            verifySignature4ERC20Token(dests,values,v1,r1,s1,v2,r2,s2,erc20Token),\n', '            "invalid signature.");\n', '\n', '        nonce = nonce + 1;\n', '\n', '        for (uint i = 0; i < dests.length; ++i) {\n', '            require(\n', '                (_erc20).transfer(dests[i],values[i]),\n', '                 "transfer erc20Token failed");\n', '        }\n', '    }\n', '\n', '    function verifySignature4ERC20Token(address payable[] memory dests, uint256[] memory values,\n', '                    uint8 v1, bytes32 r1, bytes32 s1,\n', '                    uint8 v2, bytes32 r2, bytes32 s2, address erc20) private view returns (bool) {\n', '        bytes32 h=hash(getMessageToSignature4ERC20Token(dests, values,erc20));\n', '        address addr1=recoverAddress(h, v1, r1, s1);\n', '        address addr2=recoverAddress(h, v2, r2, s2);\n', '        require(addr1 != addr2, "failed to recover address");\n', '        require(_validAddress(addr1), "invalid address");\n', '        require(_validAddress(addr2), "invalid address");\n', '        return true;\n', '    }\n', '\n', '    function getMessageToSignature4ERC20Token(address payable[] memory dests,\n', '    uint256[] memory values, address erc20) public view returns (bytes memory) {\n', '        return abi.encode(nonce, dests, values, erc20);\n', '    }\n', '}']