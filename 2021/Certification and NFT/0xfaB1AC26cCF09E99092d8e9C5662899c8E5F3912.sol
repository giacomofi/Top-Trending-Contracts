['// SPDX-License-Identifier: MIT\n', 'pragma solidity >=0.4.22 <0.9.0;\n', '\n', 'import "@openzeppelin/contracts/token/ERC721/ERC721Holder.sol";\n', 'import "@openzeppelin/contracts/token/ERC1155/ERC1155Holder.sol";\n', '\n', 'contract OurAdmin is ERC721Holder, ERC1155Holder {\n', '\n', '    event Execution(bytes32 hash);\n', '    event ExecutionFailure(bytes32 hash);\n', '    event LogSetWhiteList(address indexed sender, address indexed whiteList, bool isAdd);\n', '    event LogDropSelf(address indexed sender);\n', '    event LogTransferOwnership(address indexed sender, address indexed newOwner);\n', '    event LogClaimOwner(address indexed sender);\n', '\n', '    mapping (bytes32 => bool) executed;\n', '    mapping (address => bool) whiteList;\n', '    address owner;\n', '    address newOwner;\n', '    //bool suspend = false;\n', '\n', '    constructor () public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '    modifier onlyWhiteList() {\n', '        require (whiteList[msg.sender] || msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require (msg.sender == owner);\n', '        _;\n', '    }\n', '\n', '    function execute(\n', '        address _destination,\n', '        bytes memory _data,\n', '        uint256 _nonce) external onlyWhiteList returns (bool)\n', '    {\n', '        //require(!suspend);\n', '        bytes32 hash = keccak256(abi.encodePacked(this, _destination, _nonce, _data));\n', '        require(!executed[hash]);\n', '        (bool success, ) = _destination.call{value: 0}(_data);\n', '        if (success) {\n', '            executed[hash] = true;\n', '            emit Execution(hash);\n', '            return true;\n', '        } else {\n', '            emit ExecutionFailure(hash);\n', '            return false;\n', '        }\n', '    }\n', '\n', '    function setWhiteList(address _whiteList, bool _isAdd) external onlyOwner returns (bool) {\n', '        //require(!suspend);\n', '        whiteList[_whiteList] = _isAdd;\n', '        emit LogSetWhiteList(msg.sender, _whiteList, _isAdd);\n', '        return true;\n', '    }\n', '\n', '    //function dropSelf() external onlyOwner returns (bool) {\n', '    //    suspend = true;\n', '    //    emit LogDropSelf(msg.sender);\n', '    //    return true;\n', '    //}\n', '\n', '    function transferOwnership(address _newOwner) external onlyOwner returns (bool) {\n', '        newOwner = _newOwner;\n', '        emit LogTransferOwnership(msg.sender, _newOwner);\n', '        return true;\n', '    }\n', '\n', '    function claimOwner() external returns (bool) {\n', '        require (msg.sender == newOwner);\n', '        owner = newOwner;\n', '        emit LogClaimOwner(msg.sender);\n', '        return true;\n', '    }\n', '\n', '    function isInWhiteList(address _whiteList) public view returns (bool) {\n', '        return whiteList[_whiteList];\n', '    }\n', '\n', '    function getOwner() public view returns (address) {\n', '        return owner;\n', '    }\n', '\n', '    function getNewOwner() public view returns (address) {\n', '        return newOwner;\n', '    }\n', '\n', '    //function isSuspend() public view returns (bool) {\n', '    //    return suspend;\n', '    //}\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./IERC165.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC165} interface.\n', ' *\n', ' * Contracts may inherit from this and call {_registerInterface} to declare\n', ' * their support of an interface.\n', ' */\n', 'abstract contract ERC165 is IERC165 {\n', '    /*\n', "     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\n", '     */\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    /**\n', "     * @dev Mapping of interface ids to whether or not it's supported.\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor () internal {\n', '        // Derived contracts need only register support for their own interfaces,\n', '        // we register support for ERC165 itself here\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     *\n', '     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev Registers the contract as an implementer of the interface defined by\n', '     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n', '     * registering its interface id is not required.\n', '     *\n', '     * See {IERC165-supportsInterface}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal virtual {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./ERC1155Receiver.sol";\n', '\n', '/**\n', ' * @dev _Available since v3.1._\n', ' */\n', 'contract ERC1155Holder is ERC1155Receiver {\n', '    function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./IERC1155Receiver.sol";\n', 'import "../../introspection/ERC165.sol";\n', '\n', '/**\n', ' * @dev _Available since v3.1._\n', ' */\n', 'abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n', '    constructor() internal {\n', '        _registerInterface(\n', '            ERC1155Receiver(address(0)).onERC1155Received.selector ^\n', '            ERC1155Receiver(address(0)).onERC1155BatchReceived.selector\n', '        );\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "../../introspection/IERC165.sol";\n', '\n', '/**\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155Receiver is IERC165 {\n', '\n', '    /**\n', '        @dev Handles the receipt of a single ERC1155 token type. This function is\n', '        called at the end of a `safeTransferFrom` after the balance has been updated.\n', '        To accept the transfer, this must return\n', '        `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))`\n', '        (i.e. 0xf23a6e61, or its own function selector).\n', '        @param operator The address which initiated the transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param id The ID of the token being transferred\n', '        @param value The amount of tokens being transferred\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '\n', '    /**\n', '        @dev Handles the receipt of a multiple ERC1155 token types. This function\n', '        is called at the end of a `safeBatchTransferFrom` after the balances have\n', '        been updated. To accept the transfer(s), this must return\n', '        `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))`\n', '        (i.e. 0xbc197c81, or its own function selector).\n', '        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n', '        @param from The address which previously owned the token\n', '        @param ids An array containing ids of each token being transferred (order and length must match values array)\n', '        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n', '        @param data Additional data with no specified format\n', '        @return `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` if transfer is allowed\n', '    */\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        returns(bytes4);\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', 'import "./IERC721Receiver.sol";\n', '\n', '  /**\n', '   * @dev Implementation of the {IERC721Receiver} interface.\n', '   *\n', '   * Accepts all token transfers. \n', '   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n', '   */\n', 'contract ERC721Holder is IERC721Receiver {\n', '\n', '    /**\n', '     * @dev See {IERC721Receiver-onERC721Received}.\n', '     *\n', '     * Always returns `IERC721Receiver.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n', '        return this.onERC721Received.selector;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n', '     * by `operator` from `from`, this function is called.\n', '     *\n', '     * It must return its Solidity selector to confirm the token transfer.\n', '     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n', '     *\n', '     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": false,\n', '    "runs": 200\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']