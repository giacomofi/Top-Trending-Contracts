['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-14\n', '*/\n', '\n', '/***\n', ' *   _____                  _          __  __       _ _   _                    _           \n', ' *  / ____|                | |        |  \\/  |     | | | (_)                  | |          \n', ' * | |     _ __ _   _ _ __ | |_ ___   | \\  / |_   _| | |_ _ ___  ___ _ __   __| | ___ _ __ \n', " * | |    | '__| | | | '_ \\| __/ _ \\  | |\\/| | | | | | __| / __|/ _ \\ '_ \\ / _` |/ _ \\ '__|\n", ' * | |____| |  | |_| | |_) | || (_) | | |  | | |_| | | |_| \\__ \\  __/ | | | (_| |  __/ |   \n', ' *  \\_____|_|   \\__, | .__/ \\__\\___/  |_|  |_|\\__,_|_|\\__|_|___/\\___|_| |_|\\__,_|\\___|_|   \n', ' *               __/ | |                                                                   \n', ' *             |___/|_|                                                                   \n', ' *        \n', ' * \n', ' * @author Zenos Pavlakou\n', ' */\n', ' \n', ' \n', 'pragma solidity ^0.6.0;\n', '\n', 'library SafeMath {\n', '    \n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', "        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        \n', '        c = a * b;\n', '        assert(c / a == b);\n', '        return c;\n', '    }\n', '    \n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        assert(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        assert(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', '\n', '\n', 'contract Ownable {\n', '    \n', '    address public owner;\n', '    \n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '    \n', '    \n', '    /**\n', '     * Constructor assigns ownership to the address used to deploy the contract.\n', '     * */\n', '    constructor() public {\n', '        owner = msg.sender;\n', '    }\n', '\n', '\n', '    function getOwner() public view returns(address) {\n', '        return owner;\n', '    }\n', '\n', '\n', '    /**\n', '     * Any function with this modifier in its method signature can only be executed by\n', '     * the owner of the contract. Any attempt made by any other account to invoke the \n', "     * functions with this modifier will result in a loss of gas and the contract's state\n", '     * will remain untampered.\n', '     * */\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Function restricted to owner of contract");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * Allows for the transfer of ownership to another address;\n', '     * \n', '     * @param _newOwner The address to be assigned new ownership.\n', '     * */\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(\n', '            _newOwner != address(0)\n', '            && _newOwner != owner \n', '        );\n', '        emit OwnershipTransferred(owner, _newOwner);\n', '        owner = _newOwner;\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * Contract acts as an interface between the DappleAirdrops contract and all ERC20 compliant\n', ' * tokens. \n', ' * */\n', 'abstract contract ERCInterface {\n', '    function transferFrom(address _from, address _to, uint256 _value) public virtual;\n', '    function balanceOf(address who)  public virtual returns (uint256);\n', '    function allowance(address owner, address spender)  public view virtual returns (uint256);\n', '    function transfer(address to, uint256 value) public virtual returns(bool);\n', '}\n', '\n', '\n', '\n', 'contract CryptoMultisender is Ownable {\n', '    \n', '    using SafeMath for uint256;\n', ' \n', '    mapping (address => uint256) public tokenTrialDrops;\n', '\n', '    mapping (address => bool) public isPremiumMember;\n', '    mapping (address => bool) public isAffiliate;\n', '    mapping (string => address) public affiliateCodeToAddr;\n', '    mapping (string => bool) public affiliateCodeExists;\n', '    mapping (address => string) public affiliateCodeOfAddr;\n', '    mapping (address => string) public isAffiliatedWith;\n', '        \n', '    uint256 public premiumMemberFee;\n', '    uint256 public rate;\n', '    uint256 public dropUnitPrice;\n', '\n', '\n', '    event TokenAirdrop(address indexed by, address indexed tokenAddress, uint256 totalTransfers);\n', '    event EthAirdrop(address indexed by, uint256 totalTransfers, uint256 ethValue);\n', '\n', '\n', '   \n', '    event RateChanged(uint256 from, uint256 to);\n', '    event RefundIssued(address indexed to, uint256 totalWei);\n', '    event ERC20TokensWithdrawn(address token, address sentTo, uint256 value);\n', '    event CommissionPaid(address indexed to, uint256 value);\n', '    event NewPremiumMembership(address indexed premiumMember);\n', '    event NewAffiliatePartnership(address indexed newAffiliate, string indexed affiliateCode);\n', '    event AffiliatePartnershipRevoked(address indexed affiliate, string indexed affiliateCode);\n', '    event PremiumMemberFeeUpdated(uint256 newFee);\n', '\n', '    \n', '    constructor() public {\n', '        rate = 10000;\n', '        dropUnitPrice = 1e14; \n', '        premiumMemberFee = 25e16;\n', '    }\n', '    \n', '\n', '    /**\n', '     * Allows the owner of this contract to change the fee for users to become premium members.\n', '     * \n', '     * @param _fee The new fee.\n', '     * \n', '     * @return True if the fee is changed successfully. False otherwise.\n', '     * */\n', '    function setPremiumMemberFee(uint256 _fee) public onlyOwner returns(bool) {\n', '        require(_fee > 0 && _fee != premiumMemberFee);\n', '        premiumMemberFee = _fee;\n', '        emit PremiumMemberFeeUpdated(_fee);\n', '        return true;\n', '    }\n', '    \n', '\n', '    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\n', '        if (_i == 0) {\n', '            return "0";\n', '        }\n', '        uint j = _i;\n', '        uint len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len;\n', '        while (_i != 0) {\n', '            k = k-1;\n', '            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n', '            bytes1 b1 = bytes1(temp);\n', '            bstr[k] = b1;\n', '            _i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '\n', '\n', '    /**\n', '    * Used to give change to users who accidentally send too much ETH to payable functions. \n', '    *\n', '    * @param _price The service fee the user has to pay for function execution. \n', '    **/\n', '    function giveChange(uint256 _price) internal {\n', '        if(msg.value > _price) {\n', '            uint256 change = msg.value.sub(_price);\n', '            payable(msg.sender).transfer(change);\n', '        }\n', '    }\n', '\n', '    \n', '    /**\n', '    * Ensures that the correct affiliate code is used and also ensures that affiliate partners\n', "    * are not able to 'jack' commissions from existing users who they are not affiliated with. \n", '    *\n', '    * @param _afCode The affiliate code provided by the user.\n', '    *\n', '    * @return The correct affiliate code or void.\n', '    **/\n', '    function processAffiliateCode(string memory _afCode) internal returns(string memory) {\n', '        \n', '        if(stringsAreEqual(isAffiliatedWith[msg.sender], "void") || !isAffiliate[affiliateCodeToAddr[_afCode]]) {\n', '            isAffiliatedWith[msg.sender] = "void";\n', '            return "void";\n', '        }\n', '        \n', '        if(!stringsAreEqual(_afCode, "") && stringsAreEqual(isAffiliatedWith[msg.sender],"") \n', '                                                                && affiliateCodeExists[_afCode]) {\n', '            if(affiliateCodeToAddr[_afCode] == msg.sender) {\n', '                return "void";\n', '            }\n', '            isAffiliatedWith[msg.sender] = _afCode;\n', '        }\n', '\n', '        if(stringsAreEqual(_afCode,"") && !stringsAreEqual(isAffiliatedWith[msg.sender],"")) {\n', '            _afCode = isAffiliatedWith[msg.sender];\n', '        } \n', '        \n', '        if(stringsAreEqual(_afCode,"") || !affiliateCodeExists[_afCode]) {\n', '            isAffiliatedWith[msg.sender] = "void";\n', '            _afCode = "void";\n', '        }\n', '        \n', '        return _afCode;\n', '    }\n', '\n', '\n', '    /**\n', '    * Allows the owner of this contract to grant users with premium membership.\n', '    *\n', '    * @param _addr The address of the user who is being granted premium membership.\n', '    *\n', '    * @return True if premium membership is granted successfully. False otherwise. \n', '    **/\n', '    function grantPremiumMembership(address _addr) public onlyOwner returns(bool) {\n', '        require(!isPremiumMember[_addr], "Is already premiumMember member");\n', '        isPremiumMember[_addr] = true;\n', '        emit NewPremiumMembership(_addr);\n', '        return true; \n', '    }\n', '\n', '\n', '    /**\n', '    * Allows users to become premium members.\n', '    *\n', '    * @param _afCode If a user has been refferred by an affiliate partner, they can provide \n', '    * an affiliate code so the partner gets commission.\n', '    *\n', '    * @return True if user successfully becomes premium member. False otherwise. \n', '    **/\n', '    function becomePremiumMember(string memory _afCode) public payable returns(bool) {\n', '        require(!isPremiumMember[msg.sender], "Is already premiumMember member");\n', '        require(\n', '            msg.value >= premiumMemberFee,\n', '            string(abi.encodePacked(\n', '                "premiumMember fee is: ", uint2str(premiumMemberFee), ". Not enough ETH sent. ", uint2str(msg.value)\n', '            ))\n', '        );\n', '        \n', '        isPremiumMember[msg.sender] = true;\n', '        \n', '        _afCode = processAffiliateCode(_afCode);\n', '\n', '        giveChange(premiumMemberFee);\n', '        \n', '        if(!stringsAreEqual(_afCode,"void") && isAffiliate[affiliateCodeToAddr[_afCode]]) {\n', '            payable(owner).transfer(premiumMemberFee.mul(80).div(100));\n', '            uint256 commission = premiumMemberFee.mul(20).div(100);\n', '            payable(affiliateCodeToAddr[_afCode]).transfer(commission);\n', '            emit CommissionPaid(affiliateCodeToAddr[_afCode], commission);\n', '        } else {\n', '            payable(owner).transfer(premiumMemberFee);\n', '        }\n', '        emit NewPremiumMembership(msg.sender);\n', '        return true; \n', '    }\n', '    \n', '    \n', '    /**\n', '    * Allows the owner of this contract to add an affiliate partner.\n', '    *\n', '    * @param _addr The address of the new affiliate partner.\n', '    * @param _code The affiliate code.\n', '    * \n', '    * @return True if the affiliate has been added successfully. False otherwise. \n', '    **/\n', '    function addAffiliate(address _addr, string memory _code) public onlyOwner returns(bool) {\n', '        require(!isAffiliate[_addr], "Address is already an affiliate.");\n', '        require(_addr != address(0));\n', '        require(!affiliateCodeExists[_code]);\n', '        affiliateCodeExists[_code] = true;\n', '        isAffiliate[_addr] = true;\n', '        affiliateCodeToAddr[_code] = _addr;\n', '        affiliateCodeOfAddr[_addr] = _code;\n', '        emit NewAffiliatePartnership(_addr,_code);\n', '        return true;\n', '    }\n', '    \n', '\n', '    /**\n', '    * Allows the owner of this contract to remove an affiliate partner. \n', '    *\n', '    * @param _addr The address of the affiliate partner.\n', '    *\n', '    * @return True if affiliate partner is removed successfully. False otherwise. \n', '    **/\n', '    function removeAffiliate(address _addr) public onlyOwner returns(bool) {\n', '        require(isAffiliate[_addr]);\n', '        isAffiliate[_addr] = false;\n', '        affiliateCodeToAddr[affiliateCodeOfAddr[_addr]] = address(0);\n', '        emit AffiliatePartnershipRevoked(_addr, affiliateCodeOfAddr[_addr]);\n', '        affiliateCodeOfAddr[_addr] = "No longer an affiliate partner";\n', '        return true;\n', '    }\n', '    \n', '\n', '    \n', '    /**\n', '     * Checks whether or not an ERC20 token has used its free trial of 100 drops. This is a constant \n', '     * function which does not alter the state of the contract and therefore does not require any gas \n', '     * or a signature to be executed. \n', '     * \n', '     * @param _addressOfToken The address of the token being queried.\n', '     * \n', '     * @return true if the token being queried has not used its 100 first free trial drops, false\n', '     * otherwise.\n', '     * */\n', '    function tokenHasFreeTrial(address _addressOfToken) public view returns(bool) {\n', '        return tokenTrialDrops[_addressOfToken] < 100;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Checks how many remaining free trial drops a token has.\n', '     * \n', '     * @param _addressOfToken the address of the token being queried.\n', '     * \n', '     * @return the total remaining free trial drops of a token.\n', '     * */\n', '    function getRemainingTrialDrops(address _addressOfToken) public view returns(uint256) {\n', '        if(tokenHasFreeTrial(_addressOfToken)) {\n', '            uint256 maxTrialDrops =  100;\n', '            return maxTrialDrops.sub(tokenTrialDrops[_addressOfToken]);\n', '        } \n', '        return 0;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Allows for the price of drops to be changed by the owner of the contract. Any attempt made by \n', '     * any other account to invoke the function will result in a loss of gas and the price will remain \n', '     * untampered.\n', '     * \n', '     * @return true if function executes successfully, false otherwise.\n', '     * */\n', '    function setRate(uint256 _newRate) public onlyOwner returns(bool) {\n', '        require(\n', '            _newRate != rate \n', '            && _newRate > 0\n', '        );\n', '        emit RateChanged(rate, _newRate);\n', '        rate = _newRate;\n', '        uint256 eth = 1 ether;\n', '        dropUnitPrice = eth.div(rate);\n', '        return true;\n', '    }\n', '    \n', '    \n', '\n', '    /**\n', '     * Allows for the allowance of a token from its owner to this contract to be queried. \n', '     * \n', '     * As part of the ERC20 standard all tokens which fall under this category have an allowance \n', '     * function which enables owners of tokens to allow (or give permission) to another address \n', '     * to spend tokens on behalf of the owner. This contract uses this as part of its protocol.\n', '     * Users must first give permission to the contract to transfer tokens on their behalf, however,\n', '     * this does not mean that the tokens will ever be transferrable without the permission of the \n', '     * owner. This is a security feature which was implemented on this contract. It is not possible\n', '     * for the owner of this contract or anyone else to transfer the tokens which belong to others. \n', '     * \n', "     * @param _addr The address of the token's owner.\n", '     * @param _addressOfToken The contract address of the ERC20 token.\n', '     * \n', '     * @return The ERC20 token allowance from token owner to this contract. \n', '     * */\n', '    function getTokenAllowance(address _addr, address _addressOfToken) public view returns(uint256) {\n', '        ERCInterface token = ERCInterface(_addressOfToken);\n', '        return token.allowance(_addr, address(this));\n', '    }\n', '    \n', '    \n', '    fallback() external payable {\n', '        revert();\n', '    }\n', '\n', '\n', '    receive() external payable {\n', '        revert();\n', '    }\n', '    \n', '    \n', '    /**\n', '    * Checks if two strings are the same.\n', '    *\n', '    * @param _a String 1\n', '    * @param _b String 2\n', '    *\n', '    * @return True if both strings are the same. False otherwise. \n', '    **/\n', '    function stringsAreEqual(string memory _a, string memory _b) internal pure returns(bool) {\n', '        bytes32 hashA = keccak256(abi.encodePacked(_a));\n', '        bytes32 hashB = keccak256(abi.encodePacked(_b));\n', '        return hashA == hashB;\n', '    }\n', ' \n', '    \n', '    /**\n', '     * Allows for the distribution of Ether to be transferred to multiple recipients at \n', '     * a time. This function only facilitates batch transfers of constant values (i.e., all recipients\n', '     * will receive the same amount of tokens).\n', '     * \n', '     * @param _recipients The list of addresses which will receive tokens. \n', '     * @param _value The amount of tokens all addresses will receive. \n', '     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \n', '     * the parter is paid commission.\n', '     * \n', '     * @return true if function executes successfully, false otherwise.\n', '     * */\n', '    function singleValueEthAirrop(address[] memory _recipients, uint256 _value, string memory _afCode) public payable returns(bool) {\n', '        \n', '        uint256 price = _recipients.length.mul(dropUnitPrice);\n', '        uint256 totalCost = _value.mul(_recipients.length).add(price);\n', '\n', '        require(\n', '            msg.value >= totalCost|| isPremiumMember[msg.sender],\n', '            "Not enough ETH sent with transaction!"\n', '        );\n', '\n', '        \n', '        _afCode = processAffiliateCode(_afCode);\n', '        \n', '        \n', '        if(!isPremiumMember[msg.sender]) {\n', '            distributeCommission(_recipients.length, _afCode);\n', '        }\n', '\n', '        giveChange(totalCost);\n', '        \n', '        for(uint i=0; i<_recipients.length; i++) {\n', '            if(_recipients[i] != address(0)) {\n', '                payable(_recipients[i]).transfer(_value);\n', '            }\n', '        }\n', '\n', '        emit EthAirdrop(msg.sender, _recipients.length, _value.mul(_recipients.length));\n', '        \n', '        return true;\n', '    }\n', '    \n', '\n', '    \n', '    function _getTotalEthValue(uint256[] memory _values) internal pure returns(uint256) {\n', '        uint256 totalVal = 0;\n', '        for(uint i = 0; i < _values.length; i++) {\n', '            totalVal = totalVal.add(_values[i]);\n', '        }\n', '        return totalVal;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Allows for the distribution of Ether to be transferred to multiple recipients at \n', '     * a time. \n', '     * \n', '     * @param _recipients The list of addresses which will receive tokens. \n', '     * @param _values The corresponding amounts that the recipients will receive \n', '     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \n', '     * the parter is paid commission.\n', '     * \n', '     * @return true if function executes successfully, false otherwise.\n', '     * */\n', '    function multiValueEthAirdrop(address[] memory _recipients, uint256[] memory _values, string memory _afCode) public payable returns(bool) {\n', '        require(_recipients.length == _values.length, "Total number of recipients and values are not equal");\n', '\n', '        uint256 totalEthValue = _getTotalEthValue(_values);\n', '        uint256 price = _recipients.length.mul(dropUnitPrice);\n', '        uint256 totalCost = totalEthValue.add(price);\n', '\n', '        require(\n', '            msg.value >= totalCost || isPremiumMember[msg.sender], \n', '            "Not enough ETH sent with transaction!"\n', '        );\n', '        \n', '        \n', '        _afCode = processAffiliateCode(_afCode);\n', '        \n', '        if(!isPremiumMember[msg.sender]) {\n', '            distributeCommission(_recipients.length, _afCode);\n', '        }\n', '\n', '        giveChange(totalCost);\n', '        \n', '        for(uint i = 0; i < _recipients.length; i++) {\n', '            if(_recipients[i] != address(0) && _values[i] > 0) {\n', '                payable(_recipients[i]).transfer(_values[i]);\n', '            }\n', '        }\n', '        \n', '        emit EthAirdrop(msg.sender, _recipients.length, totalEthValue);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Allows for the distribution of an ERC20 token to be transferred to multiple recipients at \n', '     * a time. This function only facilitates batch transfers of constant values (i.e., all recipients\n', '     * will receive the same amount of tokens).\n', '     * \n', '     * @param _addressOfToken The contract address of an ERC20 token.\n', '     * @param _recipients The list of addresses which will receive tokens. \n', '     * @param _value The amount of tokens all addresses will receive. \n', '     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \n', '     * the parter is paid commission.\n', '     * \n', '     * @return true if function executes successfully, false otherwise.\n', '     * */\n', '    function singleValueTokenAirdrop(address _addressOfToken,  address[] memory _recipients, uint256 _value, string memory _afCode) public payable returns(bool) {\n', '        ERCInterface token = ERCInterface(_addressOfToken);\n', '\n', '        uint256 price = _recipients.length.mul(dropUnitPrice);\n', '\n', '        require(\n', '            msg.value >= price || tokenHasFreeTrial(_addressOfToken) || isPremiumMember[msg.sender],\n', '            "Not enough ETH sent with transaction!"\n', '        );\n', '\n', '        giveChange(price);\n', '\n', '        _afCode = processAffiliateCode(_afCode);\n', '        \n', '        for(uint i = 0; i < _recipients.length; i++) {\n', '            if(_recipients[i] != address(0)) {\n', '                token.transferFrom(msg.sender, _recipients[i], _value);\n', '            }\n', '        }\n', '        if(tokenHasFreeTrial(_addressOfToken)) {\n', '            tokenTrialDrops[_addressOfToken] = tokenTrialDrops[_addressOfToken].add(_recipients.length);\n', '        } else {\n', '            if(!isPremiumMember[msg.sender]) {\n', '                distributeCommission(_recipients.length, _afCode);\n', '            }\n', '            \n', '        }\n', '\n', '        emit TokenAirdrop(msg.sender, _addressOfToken, _recipients.length);\n', '        return true;\n', '    }\n', '    \n', '    \n', '    /**\n', '     * Allows for the distribution of an ERC20 token to be transferred to multiple recipients at \n', '     * a time. This function facilitates batch transfers of differing values (i.e., all recipients\n', '     * can receive different amounts of tokens).\n', '     * \n', '     * @param _addressOfToken The contract address of an ERC20 token.\n', '     * @param _recipients The list of addresses which will receive tokens. \n', '     * @param _values The corresponding values of tokens which each address will receive.\n', '     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \n', '     * the parter is paid commission.\n', '     * \n', '     * @return true if function executes successfully, false otherwise.\n', '     * */    \n', '    function multiValueTokenAirdrop(address _addressOfToken,  address[] memory _recipients, uint256[] memory _values, string memory _afCode) public payable returns(bool) {\n', '        ERCInterface token = ERCInterface(_addressOfToken);\n', '        require(_recipients.length == _values.length, "Total number of recipients and values are not equal");\n', '\n', '        uint256 price = _recipients.length.mul(dropUnitPrice);\n', '\n', '        require(\n', '            msg.value >= price || tokenHasFreeTrial(_addressOfToken) || isPremiumMember[msg.sender],\n', '            "Not enough ETH sent with transaction!"\n', '        );\n', '\n', '        giveChange(price);\n', '        \n', '        _afCode = processAffiliateCode(_afCode);\n', '        \n', '        for(uint i = 0; i < _recipients.length; i++) {\n', '            if(_recipients[i] != address(0) && _values[i] > 0) {\n', '                token.transferFrom(msg.sender, _recipients[i], _values[i]);\n', '            }\n', '        }\n', '        if(tokenHasFreeTrial(_addressOfToken)) {\n', '            tokenTrialDrops[_addressOfToken] = tokenTrialDrops[_addressOfToken].add(_recipients.length);\n', '        } else {\n', '            if(!isPremiumMember[msg.sender]) {\n', '                distributeCommission(_recipients.length, _afCode);\n', '            }\n', '        }\n', '        emit TokenAirdrop(msg.sender, _addressOfToken, _recipients.length);\n', '        return true;\n', '    }\n', '        \n', '\n', '    /**\n', '    * Send the owner and affiliates commissions.\n', '    **/\n', '    function distributeCommission(uint256 _drops, string memory _afCode) internal {\n', '        if(!stringsAreEqual(_afCode,"void") && isAffiliate[affiliateCodeToAddr[_afCode]]) {\n', '            uint256 profitSplit = _drops.mul(dropUnitPrice).div(2);\n', '            payable(owner).transfer(profitSplit);\n', '            payable(affiliateCodeToAddr[_afCode]).transfer(profitSplit);\n', '            emit CommissionPaid(affiliateCodeToAddr[_afCode], profitSplit);\n', '        } else {\n', '            payable(owner).transfer(_drops.mul(dropUnitPrice));\n', '        }\n', '    }\n', '    \n', '    \n', '    \n', '\n', '    /**\n', '     * Allows for any ERC20 tokens which have been mistakenly  sent to this contract to be returned \n', '     * to the original sender by the owner of the contract. Any attempt made by any other account \n', '     * to invoke the function will result in a loss of gas and no tokens will be transferred out.\n', '     * \n', '     * @param _addressOfToken The contract address of an ERC20 token.\n', '     * @param _recipient The address which will receive tokens. \n', '     * @param _value The amount of tokens to refund.\n', '     * \n', '     * @return true if function executes successfully, false otherwise.\n', '     * */  \n', '    function withdrawERC20Tokens(address _addressOfToken,  address _recipient, uint256 _value) public onlyOwner returns(bool){\n', '        require(\n', '            _addressOfToken != address(0)\n', '            && _recipient != address(0)\n', '            && _value > 0\n', '        );\n', '        ERCInterface token = ERCInterface(_addressOfToken);\n', '        token.transfer(_recipient, _value);\n', '        emit ERC20TokensWithdrawn(_addressOfToken, _recipient, _value);\n', '        return true;\n', '    }\n', '}']