['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-03\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at BscScan.com on 2021-04-05\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-26\n', '*/\n', '\n', 'pragma solidity 0.5.9;\n', '\n', 'library Math {\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);//changes (a+b )/2\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '        return c;\n', '    }\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Ownable {\n', '    address  payable  _owner;\n', '    address payable internal newOwner;\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '    modifier onlyOwner {\n', '        require(msg.sender == _owner);\n', '        _;\n', '    }\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '    function _transferOwnership(address payable _newOwner) internal {\n', '          newOwner = _newOwner;\n', '    }\n', '    //this flow is to prevent transferring ownership to wrong wallet by mistake\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '\n', '\n', '\n', 'interface Executor {\n', '    function execute(uint, uint, uint, uint) external;\n', '}\n', '\n', '\n', 'contract UnitiDex_Governance is Ownable  {\n', '    mapping(address=>bool) public owners;\n', '\n', ' \n', '   \n', '\n', '    bool public breaker = false;\n', '    uint256 deadlineIndex = 0;\n', '    uint256 public MinTokenForVote=0;\n', '    address public RYIPToken=address(0);\n', '    uint256 public tokenFreezeDuration=86400;// default 1 day or 24 hours\n', '\n', '    //mapping(address=> mapping(uint256=> uint256)) public deadline;\n', '    \n', '     mapping(address => bool) public voters;\n', '\n', '    struct stake{\n', '        uint time;\n', '        uint amount;\n', '    }\n', '    mapping(address=>stake[]) public details;\n', '\n', '\n', '    function setBreaker(bool _breaker) external {\n', '        require(msg.sender == governance, "!governance");\n', '        breaker = _breaker;\n', '    }\n', '\n', '    mapping(address => uint) public voteLock;\n', '\n', '    struct Proposal {\n', '        uint id;\n', '        address proposer;\n', '        mapping(address => uint) forVotes;\n', '        mapping(address => uint) againstVotes;\n', '        uint totalForVotes;\n', '        uint totalAgainstVotes;\n', '        uint start; // block start;\n', '        uint end; // start + period\n', '        address executor;\n', '        string hash;\n', '        uint totalVotesAvailable;\n', '        uint quorum;\n', '        uint quorumRequired;\n', '        bool open;\n', '        uint categoryID;\n', '    }\n', '\n', '    mapping (uint => Proposal) public proposals;\n', '    uint public proposalCount=0;\n', '    uint public lock = 17280;\n', '    uint public minimum = 1e18;\n', '    uint public quorum = 2000;\n', '    bool public config = true;\n', '\n', '    address public governance;\n', '\n', '  constructor(uint256 _MinTokenForVote,address _RYIPToken) public{\n', '        //sending all the tokens to Owner\n', '        MinTokenForVote=_MinTokenForVote;\n', '        RYIPToken=_RYIPToken;\n', '    }\n', '\n', '\n', '    function setGovernance(address _governance) public {\n', '        require(msg.sender == governance, "!governance");\n', '        governance = _governance;\n', '    }\n', '\n', '    function setQuorum(uint _quorum) public {\n', '        require(msg.sender == governance, "!governance");\n', '        quorum = _quorum;\n', '    }\n', '\n', '    function setMinimum(uint _minimum) public {\n', '        require(msg.sender == governance, "!governance");\n', '        minimum = _minimum;\n', '    }\n', '\n', '    function setPeriod(uint _proposeId, uint _endtime) public returns(bool){\n', '        require(proposals[_proposeId].executor==msg.sender || owners[msg.sender]==true);\n', '        require(proposals[_proposeId].end!=0);\n', '\n', '         proposals[_proposeId].end=_endtime;\n', '         return true;\n', '    }\n', '\n', '    function setLock(uint _lock) public {\n', '        require(msg.sender == governance, "!governance");\n', '        lock = _lock;\n', '    }\n', '\n', '    function initialize(uint id) public {\n', '        require(config == true, "!config");\n', '        config = false;\n', '        proposalCount = id;\n', '        governance = 0xFEB4acf3df3cDEA7399794D0869ef76A6EfAff52;\n', '    }\n', '\n', '\n', '    event NewProposal(string _hash, uint id, address creator, uint start, uint duration, address executor, uint _categoryID);\n', '    event Vote(uint indexed id, address indexed voter, bool vote, uint weight);\n', '\n', '    function propose(address executor, string memory hash, uint _categoryID, uint _startTime, uint _endTime) public returns(bool){\n', '\n', '\n', '        if(_startTime==0)\n', '        {\n', '           _startTime=block.timestamp;\n', '        }\n', '\n', '         proposalCount=proposalCount+1;\n', '        proposals[proposalCount] = Proposal({\n', '            id: proposalCount,\n', '            proposer: msg.sender,\n', '            totalForVotes: 0,\n', '            totalAgainstVotes: 0,\n', '            start: _startTime,\n', '            end: _endTime,\n', '            executor: executor,\n', '            hash: hash,\n', '            totalVotesAvailable: totalVotes,\n', '            quorum: 0,\n', '            quorumRequired: quorum,\n', '            open: true,\n', '            categoryID: _categoryID\n', '        });\n', '\n', '        emit NewProposal(hash, proposalCount, msg.sender, _startTime, _endTime, executor, _categoryID);\n', '        return true;\n', '    }\n', '\n', '    event RemoveProposal(uint indexed id, address indexed remover, uint indexed time);\n', '\n', '\n', '    function removePropose(uint _proposeId) public returns(bool){\n', '        require(proposals[_proposeId].executor==msg.sender || owners[msg.sender]==true);\n', '        delete proposals[_proposeId];\n', '        emit RemoveProposal(_proposeId,msg.sender,block.timestamp);\n', '        return true;\n', '    }\n', '\n', '    function execute(uint id) public {\n', '        (uint _for, uint _against, uint _quorum) = getStats(id);\n', '        require(proposals[id].quorumRequired < _quorum, "!quorum");\n', '        require(proposals[id].end < block.timestamp , "!end");\n', '        if (proposals[id].open == true) {\n', '            tallyVotes(id);\n', '        }\n', '        Executor(proposals[id].executor).execute(id, _for, _against, _quorum);\n', '    }\n', '\n', '    function getStats(uint id) public view returns (uint _for, uint _against, uint _quorum) {\n', '        _for = proposals[id].totalForVotes;\n', '        _against = proposals[id].totalAgainstVotes;\n', '        _quorum = proposals[id].quorum;\n', '    }\n', '\n', '    event ProposalFinished(uint indexed id, uint _for, uint _against, bool quorumReached);\n', '\n', '    function tallyVotes(uint id) public {\n', '        require(proposals[id].open == true, "!open");\n', '        require(proposals[id].end < block.timestamp, "!end");\n', '\n', '        (uint _for, uint _against,) = getStats(id);\n', '        bool _quorum = false;\n', '        if (proposals[id].quorum >= proposals[id].quorumRequired) {\n', '            _quorum = true;\n', '        }\n', '        proposals[id].open = false;\n', '        emit ProposalFinished(id, _for, _against, _quorum);\n', '    }\n', '\n', '    function votesOf(address voter) public view returns (uint) {\n', '        return votes[voter];\n', '    }\n', '    function checkVoted(uint id) public view returns(bool) {\n', '        if(proposals[id].forVotes[msg.sender]==1 || proposals[id].againstVotes[msg.sender]==1)\n', '        {\n', '          return true;\n', '        }\n', '        else\n', '        {\n', '          return false;\n', '        }\n', '    }\n', '    uint public totalVotes;\n', '    mapping(address => uint) public votes;\n', '    event RevokeVoter(address voter, uint votes, uint totalVotes);\n', '\n', '\n', '    function revoke() public {\n', '        require(voters[msg.sender] == true, "!voter");\n', '        voters[msg.sender] = false;\n', '        if (totalVotes < votes[msg.sender]) {\n', '            totalVotes = 0;\n', '        } else {\n', '            totalVotes = votes[msg.sender];\n', '        }\n', '        emit RevokeVoter(msg.sender, votes[msg.sender], totalVotes);\n', '        votes[msg.sender] = 0;\n', '    }\n', '\n', '\n', '    function voteFor(uint id) public returns(bool){\n', '        require(proposals[id].start < block.timestamp , "<start");\n', '        require(proposals[id].end > block.timestamp , ">end");\n', '        require(proposals[id].forVotes[msg.sender]==0 && proposals[id].againstVotes[msg.sender]==0,"Already Voted");\n', '        //require(msg.value==500000,"Invalid Amount");\n', '       // require(_amount==MinTokenForVote,"Invalid Amount");\n', '        IERC20(RYIPToken).transferFrom(msg.sender,address(this),MinTokenForVote);\n', '        // freezeToken[msg.sender] += MinTokenForVote;\n', '        \n', '        proposals[id].forVotes[msg.sender] = 1;\n', '        proposals[id].totalVotesAvailable = totalVotes;\n', '        proposals[id].totalForVotes= proposals[id].totalForVotes + 1;\n', '\n', '        stake memory st=stake(now+tokenFreezeDuration,MinTokenForVote);\n', '\n', '        details[msg.sender].push(st);\n', '\n', '        emit Vote(id, msg.sender, true, 1);\n', '        return true;\n', '    }\n', '    function NumberOfVotes(address _add) public view returns(uint256){\n', '        return details[_add].length;\n', '    }\n', '    function voteAgainst(uint id) public returns(bool) {\n', '        require(proposals[id].start < block.timestamp , "<start");\n', '        require(proposals[id].end > block.timestamp , ">end");\n', '        require(proposals[id].forVotes[msg.sender]==0 && proposals[id].againstVotes[msg.sender]==0,"Already Voted");\n', '       // require(_amount==MinTokenForVote,"Invalid Amount");\n', '        IERC20(RYIPToken).transferFrom(msg.sender,address(this),MinTokenForVote);\n', '        //freezeToken[msg.sender] += MinTokenForVote;\n', '        proposals[id].againstVotes[msg.sender] = 1;\n', '        proposals[id].totalVotesAvailable = totalVotes;\n', '        proposals[id].totalAgainstVotes= proposals[id].totalAgainstVotes + 1;\n', '\n', '\n', '        stake memory st=stake(now+tokenFreezeDuration,MinTokenForVote);\n', '        details[msg.sender].push(st);\n', '\n', '        emit Vote(id, msg.sender, false, 1);\n', '        return true;\n', '    }\n', '    function changeMinTokenForVote(uint256 _amount) public onlyOwner returns(bool){\n', '        require(_amount>0,"invalid Amount");\n', '        MinTokenForVote=_amount;\n', '        return true;\n', '\n', '    }\n', '\n', '\n', '    function ClaimToken() public returns(bool) {\n', '        uint256 _tokenAmount= 0;\n', '        uint256 _tmpAmount =0;\n', '        uint256 _tmpDeadline =0;\n', '        \n', '        for (uint256 i=0;i<details[msg.sender].length;){\n', '            \n', '            if (now>details[msg.sender][i].time && details[msg.sender][i].amount>0){ // if deadline time is over.\n', '            \n', '                    //vreturn= vreturn.add(details[msg.sender][i].amount);\n', '                    _tokenAmount= _tokenAmount+details[msg.sender][i].amount;\n', '                    if (details[msg.sender].length>1) // if element is less than 2 no need to swap \n', '                        \n', '                        {\n', '\n', '                            // storing last index element in temp variable for swaping\n', '                            _tmpAmount = details[msg.sender][details[msg.sender].length-1].amount;\n', '                            _tmpDeadline = details[msg.sender][details[msg.sender].length-1].time;\n', '                    \n', '                            // storing current element on last index \n', '                            details[msg.sender][details[msg.sender].length-1].amount = details[msg.sender][i].amount;\n', '                            details[msg.sender][details[msg.sender].length-1].time = details[msg.sender][i].time;  \n', '                    \n', '                            //storing last index element on current index\n', '                    \n', '                            details[msg.sender][i].amount= _tmpAmount;\n', '                            details[msg.sender][i].time = _tmpDeadline;\n', '                        }\n', '                     // removing item on array\n', '                     details[msg.sender].pop();\n', '                        \n', '            }\n', '            \n', '            else{\n', '                \n', '                // it increment value only when array lenght is not decreasing\n', '                i++;\n', '            }\n', '        }\n', "        require(_tokenAmount>0,'invalid balance');\n", "        require(IERC20(RYIPToken).transfer(msg.sender,_tokenAmount),'transfer sending fail');\n", '        return true;\n', '\n', '    }\n', '    \n', '\n', '    function showFreezeToken(address _address) public view returns(uint256){\n', "         require(_address!=address(0),'invalid address');\n", '        uint256 vreturn=0;\n', '        //for (uint256 i=deadlineStarIndex[msg.sender];i<=deadlineLastIndex[msg.sender] ;i++){\n', '        for (uint256 i=0;i<details[_address].length ;i++){\n', '\n', '            if (now<details[_address][i].time && details[_address][i].amount>0){ // if deadline time is over.\n', '                    //vreturn= vreturn.add(details[msg.sender][i].amount);\n', '                    vreturn= vreturn+details[_address][i].amount;\n', '            }\n', '        }\n', '        return vreturn;\n', '\n', '    }\n', '\n', '\n', '    function showUnFreezeToken(address _address) public view  returns(uint256){\n', "       require(_address!=address(0),'invalid address');\n", '      uint256 vreturn=0;\n', '\n', '        //for (uint256 i=deadlineStarIndex[msg.sender];i<=deadlineLastIndex[msg.sender] ;i++){\n', '        for (uint256 i=0;i<details[_address].length ;i++){\n', '\n', '            if (now>details[_address][i].time && details[_address][i].amount>0){ // if deadline time is over.\n', '                    //vreturn= vreturn.add(details[msg.sender][i].amount);\n', '                    vreturn= vreturn+details[_address][i].amount;\n', '                    \n', '            }\n', '        }\n', '        return vreturn;\n', '    }\n', '    \n', '    \n', '\n', '\n', '    function changeTokenDuration (uint256 _timePeriod) public onlyOwner returns(bool){\n', '        tokenFreezeDuration= _timePeriod;\n', '        return true;\n', '    }\n', '\n', '    function changeToken(address _RYIPToken) public onlyOwner returns(bool){\n', '        RYIPToken=_RYIPToken;\n', '        return true;\n', '    }\n', '\n', '}']