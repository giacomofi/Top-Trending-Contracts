['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-13\n', '*/\n', '\n', '// File: contracts/XConst.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'contract XConst {\n', '    uint256 public constant BONE = 10**18;\n', '\n', '    uint256 public constant MIN_BOUND_TOKENS = 2;\n', '    uint256 public constant MAX_BOUND_TOKENS = 8;\n', '\n', '    uint256 public constant EXIT_ZERO_FEE = 0;\n', '\n', '    uint256 public constant MIN_WEIGHT = BONE;\n', '    uint256 public constant MAX_WEIGHT = BONE * 50;\n', '    uint256 public constant MAX_TOTAL_WEIGHT = BONE * 50;\n', '\n', '    // min effective value: 0.000001 TOKEN\n', '    uint256 public constant MIN_BALANCE = 10**6;\n', '\n', '    // BONE/(10**10) XPT\n', '    uint256 public constant MIN_POOL_AMOUNT = 10**8;\n', '\n', '    uint256 public constant INIT_POOL_SUPPLY = BONE * 100;\n', '\n', '    uint256 public constant MAX_IN_RATIO = BONE / 2;\n', '    uint256 public constant MAX_OUT_RATIO = (BONE / 3) + 1 wei;\n', '}\n', '\n', '// File: contracts/interface/IXPool.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'interface IXPool {\n', '    // XPToken\n', '    event Approval(address indexed src, address indexed dst, uint256 amt);\n', '    event Transfer(address indexed src, address indexed dst, uint256 amt);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address whom) external view returns (uint256);\n', '\n', '    function allowance(address src, address dst)\n', '        external\n', '        view\n', '        returns (uint256);\n', '\n', '    function approve(address dst, uint256 amt) external returns (bool);\n', '\n', '    function transfer(address dst, uint256 amt) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address src,\n', '        address dst,\n', '        uint256 amt\n', '    ) external returns (bool);\n', '\n', '    // Swap\n', '    function swapExactAmountIn(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        address tokenOut,\n', '        uint256 minAmountOut,\n', '        uint256 maxPrice\n', '    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n', '\n', '    function swapExactAmountOut(\n', '        address tokenIn,\n', '        uint256 maxAmountIn,\n', '        address tokenOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 maxPrice\n', '    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n', '\n', '    // Referral\n', '    function swapExactAmountInRefer(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        address tokenOut,\n', '        uint256 minAmountOut,\n', '        uint256 maxPrice,\n', '        address referrer\n', '    ) external returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\n', '\n', '    function swapExactAmountOutRefer(\n', '        address tokenIn,\n', '        uint256 maxAmountIn,\n', '        address tokenOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 maxPrice,\n', '        address referrer\n', '    ) external returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\n', '\n', '    // Pool Data\n', '    function isBound(address token) external view returns (bool);\n', '\n', '    function getFinalTokens() external view returns (address[] memory tokens);\n', '\n', '    function getBalance(address token) external view returns (uint256);\n', '\n', '    function swapFee() external view returns (uint256);\n', '\n', '    function exitFee() external view returns (uint256);\n', '\n', '    function finalized() external view returns (uint256);\n', '\n', '    function controller() external view returns (uint256);\n', '\n', '    function isFarmPool() external view returns (uint256);\n', '\n', '    function xconfig() external view returns (uint256);\n', '\n', '    function getDenormalizedWeight(address) external view returns (uint256);\n', '\n', '    function getTotalDenormalizedWeight() external view returns (uint256);\n', '\n', '    function getVersion() external view returns (bytes32);\n', '\n', '    function calcInGivenOut(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 tokenAmountOut,\n', '        uint256 _swapFee\n', '    ) external pure returns (uint256 tokenAmountIn);\n', '\n', '    function calcOutGivenIn(\n', '        uint256 tokenBalanceIn,\n', '        uint256 tokenWeightIn,\n', '        uint256 tokenBalanceOut,\n', '        uint256 tokenWeightOut,\n', '        uint256 tokenAmountIn,\n', '        uint256 _swapFee\n', '    ) external pure returns (uint256 tokenAmountOut);\n', '\n', '    // Pool Managment\n', '    function setController(address _controller) external;\n', '\n', '    function setExitFee(uint256 newFee) external;\n', '\n', '    function finalize(uint256 _swapFee) external;\n', '\n', '    function bind(address token, uint256 denorm) external;\n', '\n', '    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\n', '        external;\n', '\n', '    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\n', '        external;\n', '\n', '    function joinswapExternAmountIn(\n', '        address tokenIn,\n', '        uint256 tokenAmountIn,\n', '        uint256 minPoolAmountOut\n', '    ) external returns (uint256 poolAmountOut);\n', '\n', '    function exitswapPoolAmountIn(\n', '        address tokenOut,\n', '        uint256 poolAmountIn,\n', '        uint256 minAmountOut\n', '    ) external returns (uint256 tokenAmountOut);\n', '\n', '    // Pool Governance\n', '    function updateSafu(address safu, uint256 fee) external;\n', '\n', '    function updateFarm(bool isFarm) external;\n', '}\n', '\n', '// File: contracts/interface/IERC20.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'interface IERC20 {\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address _owner) external view returns (uint256 balance);\n', '\n', '    function transfer(address _to, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _value\n', '    ) external returns (bool success);\n', '\n', '    function approve(address _spender, uint256 _value)\n', '        external\n', '        returns (bool success);\n', '\n', '    function allowance(address _owner, address _spender)\n', '        external\n', '        view\n', '        returns (uint256 remaining);\n', '}\n', '\n', '// File: contracts/lib/Address.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/utils/Address.sol\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash =\n', '            0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            codehash := extcodehash(account)\n', '        }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account)\n', '        internal\n', '        pure\n', '        returns (address payable)\n', '    {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(\n', '            address(this).balance >= amount,\n', '            "Address: insufficient balance"\n', '        );\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount).gas(9100)("");\n', '        require(\n', '            success,\n', '            "Address: unable to send value, recipient may have reverted"\n', '        );\n', '    }\n', '}\n', '\n', '// File: contracts/lib/SafeERC20.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '//https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v2.5.0/contracts/token/ERC20/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using Address for address;\n', '\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transfer.selector, to, value)\n', '        );\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n', '        );\n', '    }\n', '\n', '    function safeApprove(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require(\n', '            (value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.approve.selector, spender, value)\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(\n', '                abi.decode(returndata, (bool)),\n', '                "SafeERC20: ERC20 operation did not succeed"\n', '            );\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/XNum.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', 'library XNum {\n', '    uint256 public constant BONE = 10**18;\n', '    uint256 public constant MIN_BPOW_BASE = 1 wei;\n', '    uint256 public constant MAX_BPOW_BASE = (2 * BONE) - 1 wei;\n', '    uint256 public constant BPOW_PRECISION = BONE / 10**10;\n', '\n', '    function btoi(uint256 a) internal pure returns (uint256) {\n', '        return a / BONE;\n', '    }\n', '\n', '    function bfloor(uint256 a) internal pure returns (uint256) {\n', '        return btoi(a) * BONE;\n', '    }\n', '\n', '    function badd(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ERR_ADD_OVERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        (uint256 c, bool flag) = bsubSign(a, b);\n', '        require(!flag, "ERR_SUB_UNDERFLOW");\n', '        return c;\n', '    }\n', '\n', '    function bsubSign(uint256 a, uint256 b)\n', '        internal\n', '        pure\n', '        returns (uint256, bool)\n', '    {\n', '        if (a >= b) {\n', '            return (a - b, false);\n', '        } else {\n', '            return (b - a, true);\n', '        }\n', '    }\n', '\n', '    function bmul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c0 = a * b;\n', '        require(a == 0 || c0 / a == b, "ERR_MUL_OVERFLOW");\n', '        uint256 c1 = c0 + (BONE / 2);\n', '        require(c1 >= c0, "ERR_MUL_OVERFLOW");\n', '        uint256 c2 = c1 / BONE;\n', '        return c2;\n', '    }\n', '\n', '    function bdiv(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "ERR_DIV_ZERO");\n', '        uint256 c0 = a * BONE;\n', '        require(a == 0 || c0 / a == BONE, "ERR_DIV_INTERNAL"); // bmul overflow\n', '        uint256 c1 = c0 + (b / 2);\n', '        require(c1 >= c0, "ERR_DIV_INTERNAL"); //  badd require\n', '        uint256 c2 = c1 / b;\n', '        return c2;\n', '    }\n', '\n', '    // DSMath.wpow\n', '    function bpowi(uint256 a, uint256 n) internal pure returns (uint256) {\n', '        uint256 z = n % 2 != 0 ? a : BONE;\n', '\n', '        for (n /= 2; n != 0; n /= 2) {\n', '            a = bmul(a, a);\n', '\n', '            if (n % 2 != 0) {\n', '                z = bmul(z, a);\n', '            }\n', '        }\n', '        return z;\n', '    }\n', '\n', '    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\n', '    // Use `bpowi` for `b^e` and `bpowK` for k iterations\n', '    // of approximation of b^0.w\n', '    function bpow(uint256 base, uint256 exp) internal pure returns (uint256) {\n', '        require(base >= MIN_BPOW_BASE, "ERR_BPOW_BASE_TOO_LOW");\n', '        require(base <= MAX_BPOW_BASE, "ERR_BPOW_BASE_TOO_HIGH");\n', '\n', '        uint256 whole = bfloor(exp);\n', '        uint256 remain = bsub(exp, whole);\n', '\n', '        uint256 wholePow = bpowi(base, btoi(whole));\n', '\n', '        if (remain == 0) {\n', '            return wholePow;\n', '        }\n', '\n', '        uint256 partialResult = bpowApprox(base, remain, BPOW_PRECISION);\n', '        return bmul(wholePow, partialResult);\n', '    }\n', '\n', '    function bpowApprox(\n', '        uint256 base,\n', '        uint256 exp,\n', '        uint256 precision\n', '    ) internal pure returns (uint256) {\n', '        // term 0:\n', '        uint256 a = exp;\n', '        (uint256 x, bool xneg) = bsubSign(base, BONE);\n', '        uint256 term = BONE;\n', '        uint256 sum = term;\n', '        bool negative = false;\n', '\n', '        // term(k) = numer / denom\n', '        //         = (product(a - i + 1, i=1-->k) * x^k) / (k!)\n', '        // each iteration, multiply previous term by (a-(k-1)) * x / k\n', '        // continue until term is less than precision\n', '        for (uint256 i = 1; term >= precision; i++) {\n', '            uint256 bigK = i * BONE;\n', '            (uint256 c, bool cneg) = bsubSign(a, bsub(bigK, BONE));\n', '            term = bmul(term, bmul(c, x));\n', '            term = bdiv(term, bigK);\n', '            if (term == 0) break;\n', '\n', '            if (xneg) negative = !negative;\n', '            if (cneg) negative = !negative;\n', '            if (negative) {\n', '                sum = bsub(sum, term);\n', '            } else {\n', '                sum = badd(sum, term);\n', '            }\n', '        }\n', '\n', '        return sum;\n', '    }\n', '}\n', '\n', '// File: contracts/XConfig.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', '1. SAFU is a multi-sig account\n', '2. SAFU is the core of XConfig contract instance\n', '3. DEV firstly deploys XConfig contract, then setups the xconfig.core and xconfig.safu to SAFU with setSAFU() and setCore() \n', '*/\n', 'contract XConfig is XConst {\n', '    using XNum for uint256;\n', '    using Address for address;\n', '    using SafeERC20 for IERC20;\n', '\n', '    address private core;\n', '\n', '    // Secure Asset Fund for Users(SAFU) address\n', '    address private safu;\n', '    uint256 public SAFU_FEE = (5 * BONE) / 10000; // 0.05%\n', '\n', '    // Swap Proxy Address\n', '    address private swapProxy;\n', '\n', '    // ETH and WETH address\n', '    address public constant ETH_ADDR =\n', '        address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n', '    address public weth;\n', '\n', '    // pool sigs for pool deduplication\n', '    // key: keccak256(tokens[i], norms[i]), value: pool_address\n', '    mapping(bytes32 => address) public poolSigs;\n', '    uint256 public poolSigCount;\n', '    // empty pool: if XPT totalSupply <= MIN_EFFECTIVE_XPT\n', '    uint256 public minEffeciveXPT = 10**14; //0.0001 XPT\n', '\n', '    uint256 public maxExitFee = BONE / 1000; // 0.1%\n', '\n', '    event INIT_SAFU(address indexed addr);\n', '    event SET_CORE(address indexed core, address indexed coreNew);\n', '\n', '    event SET_SAFU(address indexed safu, address indexed safuNew);\n', '    event SET_SAFU_FEE(uint256 indexed fee, uint256 indexed feeNew);\n', '\n', '    event SET_PROXY(address indexed proxy, address indexed proxyNew);\n', '\n', '    event ADD_POOL_SIG(\n', '        address indexed caller,\n', '        address indexed pool,\n', '        bytes32 sig\n', '    );\n', '    event RM_POOL_SIG(\n', '        address indexed caller,\n', '        address indexed pool,\n', '        bytes32 sig\n', '    );\n', '\n', '    event ADD_FARM_POOL(address indexed pool);\n', '    event RM_FARM_POOL(address indexed pool);\n', '    event SET_MFXPT(uint256 amount);\n', '\n', '    event COLLECT(address indexed token, uint256 amount);\n', '\n', '    modifier onlyCore() {\n', '        require(msg.sender == core, "ERR_CORE_AUTH");\n', '        _;\n', '    }\n', '\n', '    constructor(address _weth) public {\n', '        require(_weth != address(0), "ERR_ZERO_ADDR");\n', '        weth = _weth;\n', '        core = msg.sender;\n', '        safu = address(this);\n', '        emit INIT_SAFU(address(this));\n', '    }\n', '\n', '    function getCore() external view returns (address) {\n', '        return core;\n', '    }\n', '\n', '    function getSAFU() external view returns (address) {\n', '        return safu;\n', '    }\n', '\n', '    function getMaxExitFee() external view returns (uint256) {\n', '        return maxExitFee;\n', '    }\n', '\n', '    function getSafuFee() external view returns (uint256) {\n', '        return SAFU_FEE;\n', '    }\n', '\n', '    function getSwapProxy() external view returns (address) {\n', '        return swapProxy;\n', '    }\n', '\n', '    /**\n', '     * pool deduplication\n', '     * @dev check pool existence which has the same tokens(sorted by address) and weights\n', '     * the denorms will allways between [10**18, 50 * 10**18]\n', '     * @notice if pool is address(0), means not created yet\n', '     * @return pool exists and pool sig\n', '     */\n', '    function dedupPool(address[] calldata tokens, uint256[] calldata denorms)\n', '        external\n', '        returns (bool exist, bytes32 sig)\n', '    {\n', '        require(msg.sender == swapProxy, "ERR_NOT_SWAPPROXY");\n', '        require(tokens.length == denorms.length, "ERR_LENGTH_MISMATCH");\n', '        require(tokens.length >= MIN_BOUND_TOKENS, "ERR_MIN_TOKENS");\n', '        require(tokens.length <= MAX_BOUND_TOKENS, "ERR_MAX_TOKENS");\n', '\n', '        uint256 totalWeight = 0;\n', '        address[] memory finalTokens = new address[](tokens.length);\n', '        for (uint8 i = 0; i < tokens.length; i++) {\n', '            if (i > 0) {\n', '                //token address must bt sorted\n', '                require(tokens[i] > tokens[i - 1], "ERR_TOKENS_NOT_SORTED");\n', '            }\n', '\n', '            finalTokens[i] = tokens[i];\n', '            if (tokens[i] == ETH_ADDR) {\n', '                finalTokens[i] = weth;\n', '            }\n', '            totalWeight = totalWeight.badd(denorms[i]);\n', '        }\n', '\n', '        //pool sig generated\n', '        bytes memory poolInfo;\n', '        for (uint8 i = 0; i < finalTokens.length; i++) {\n', '            //normalized weight (multiplied by 100)\n', '            uint256 nWeight = denorms[i].bmul(100).bdiv(totalWeight);\n', '            poolInfo = abi.encodePacked(poolInfo, finalTokens[i], nWeight);\n', '        }\n', '        sig = keccak256(poolInfo);\n', '\n', '        //check empty pool\n', '        address pool = poolSigs[sig];\n', '        if (pool != address(0)) {\n', '            IERC20 TP = IERC20(pool);\n', '\n', '            if (TP.totalSupply() > minEffeciveXPT) {\n', '                return (true, sig);\n', '            } else {\n', '                //remove sig\n', '                removePoolSig(sig);\n', '            }\n', '        }\n', '        exist = false;\n', '    }\n', '\n', "    // add pool's sig\n", '    // only allow called by swapProxy\n', '    function addPoolSig(bytes32 sig, address pool) external {\n', '        require(msg.sender == swapProxy, "ERR_NOT_SWAPPROXY");\n', '        require(pool != address(0), "ERR_ZERO_ADDR");\n', '        require(sig != 0, "ERR_NOT_SIG");\n', '\n', '        if (poolSigs[sig] == address(0)) {\n', '            //add new sig\n', '            poolSigCount = poolSigCount.badd(1);\n', '        }\n', '\n', '        poolSigs[sig] = pool;\n', '        emit ADD_POOL_SIG(msg.sender, pool, sig);\n', '    }\n', '\n', "    // remove pool's sig\n", '    function removePoolSig(bytes32 sig) internal {\n', '        require(sig != 0, "ERR_NOT_SIG");\n', '\n', '        if (poolSigs[sig] != address(0)) {\n', '            emit RM_POOL_SIG(msg.sender, poolSigs[sig], sig);\n', '            delete poolSigs[sig];\n', '            poolSigCount = poolSigCount.bsub(1);\n', '        }\n', '    }\n', '\n', '    // manually batch update poolSig, called by core\n', '    function updatePoolSigs(bytes32[] calldata sigs, address[] calldata pools)\n', '        external\n', '        onlyCore\n', '    {\n', '        require(sigs.length == pools.length, "ERR_LENGTH_MISMATCH");\n', '        require(pools.length > 0 && pools.length <= 30, "ERR_BATCH_COUNT");\n', '\n', '        for (uint8 i = 0; i < sigs.length; i++) {\n', '            bytes32 sig = sigs[i];\n', '            address pool = pools[i];\n', '            require(sig != 0, "ERR_NOT_SIG");\n', '\n', '            //remove\n', '            if (pool == address(0)) {\n', '                removePoolSig(sig);\n', '                continue;\n', '            }\n', '\n', '            //update\n', '            if (poolSigs[sig] != address(0)) {\n', '                //over write\n', '                poolSigs[sig] = pool;\n', '            } else {\n', '                //add new\n', '                poolSigs[sig] = pool;\n', '                poolSigCount = poolSigCount.badd(1);\n', '                emit ADD_POOL_SIG(msg.sender, pool, sig);\n', '            }\n', '        }\n', '    }\n', '\n', '    function setCore(address _core) external onlyCore {\n', '        require(_core != address(0), "ERR_ZERO_ADDR");\n', '        emit SET_CORE(core, _core);\n', '        core = _core;\n', '    }\n', '\n', '    function setSAFU(address _safu) external onlyCore {\n', '        require(_safu != address(0), "ERR_ZERO_ADDR");\n', '        emit SET_SAFU(safu, _safu);\n', '        safu = _safu;\n', '    }\n', '\n', '    function setMaxExitFee(uint256 _fee) external onlyCore {\n', '        require(_fee <= (BONE / 10), "INVALID_EXIT_FEE");\n', '        maxExitFee = _fee;\n', '    }\n', '\n', '    function setSafuFee(uint256 _fee) external onlyCore {\n', '        require(_fee <= (BONE / 10), "INVALID_SAFU_FEE");\n', '        emit SET_SAFU_FEE(SAFU_FEE, _fee);\n', '        SAFU_FEE = _fee;\n', '    }\n', '\n', '    function setMinEffeciveXPT(uint256 _mfxpt) external onlyCore {\n', '        minEffeciveXPT = _mfxpt;\n', '        emit SET_MFXPT(_mfxpt);\n', '    }\n', '\n', '    function setSwapProxy(address _proxy) external onlyCore {\n', '        require(_proxy != address(0), "ERR_ZERO_ADDR");\n', '        emit SET_PROXY(swapProxy, _proxy);\n', '        swapProxy = _proxy;\n', '    }\n', '\n', '    // update SAFU address and SAFE_FEE to pools\n', '    function updateSafu(address[] calldata pools) external onlyCore {\n', '        require(pools.length > 0 && pools.length <= 30, "ERR_BATCH_COUNT");\n', '\n', '        for (uint8 i = 0; i < pools.length; i++) {\n', '            require(Address.isContract(pools[i]), "ERR_NOT_CONTRACT");\n', '\n', '            IXPool pool = IXPool(pools[i]);\n', '            pool.updateSafu(safu, SAFU_FEE);\n', '        }\n', '    }\n', '\n', '    // update isFarmPool status to pools\n', '    function updateFarm(address[] calldata pools, bool isFarm)\n', '        external\n', '        onlyCore\n', '    {\n', '        require(pools.length > 0 && pools.length <= 30, "ERR_BATCH_COUNT");\n', '\n', '        for (uint8 i = 0; i < pools.length; i++) {\n', '            require(Address.isContract(pools[i]), "ERR_NOT_CONTRACT");\n', '\n', '            IXPool pool = IXPool(pools[i]);\n', '            pool.updateFarm(isFarm);\n', '\n', '            if (isFarm) {\n', '                emit ADD_FARM_POOL(pools[i]);\n', '            } else {\n', '                emit RM_FARM_POOL(pools[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    // collect any tokens in this contract to safu\n', '    function collect(address token) external onlyCore {\n', '        IERC20 TI = IERC20(token);\n', '\n', '        uint256 collected = TI.balanceOf(address(this));\n', '        TI.safeTransfer(safu, collected);\n', '\n', '        emit COLLECT(token, collected);\n', '    }\n', '}']