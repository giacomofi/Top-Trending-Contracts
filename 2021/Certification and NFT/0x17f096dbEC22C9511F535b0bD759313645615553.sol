['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-27\n', '*/\n', '\n', 'pragma solidity =0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Math {\n', '\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in construction, \n', '        // since the code is only stored at the end of the constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { \n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '}\n', '\n', 'interface IStakingRewards {\n', '    function earned(address account) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function stake(uint256 amount) external;\n', '    function stakeFor(uint256 amount, address user) external;\n', '    function getReward() external;\n', '    function withdraw(uint256 amount) external;\n', '    function withdrawAndGetReward(uint256 amount) external;\n', '    function exit() external;\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), owner);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Ownable: Caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address transferOwner) public onlyOwner {\n', '        require(transferOwner != newOwner);\n', '        newOwner = transferOwner;\n', '    }\n', '\n', '    function acceptOwnership() virtual public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'interface IERC20Permit {\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', 'contract StakingRewardsSameTokenFixedAPY is IStakingRewards, ReentrancyGuard, Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    IERC20 public token;\n', '    uint256 public rewardRate; \n', '    uint256 public constant rewardDuration = 365 days; \n', '\n', '    mapping(address => uint256) public weightedStakeDate;\n', '\n', '    uint256 private _totalSupply;\n', '    mapping(address => uint256) private _balances;\n', '\n', '    event RewardUpdated(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '    event Rescue(address to, uint amount);\n', '    event RescueToken(address to, address token, uint amount);\n', '\n', '    constructor(\n', '        address _token,\n', '        uint _rewardRate\n', '    ) {\n', '        token = IERC20(_token);\n', '        rewardRate = _rewardRate;\n', '    }\n', '\n', '    function totalSupply() external view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) external view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function earned(address account) public view override returns (uint256) {\n', '        return (_balances[account].mul(block.timestamp.sub(weightedStakeDate[account])).mul(rewardRate)) / (100 * rewardDuration);\n', '    }\n', '\n', '    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external nonReentrant {\n', '        require(amount > 0, "StakingRewardsSameTokenFixedAPY: Cannot stake 0");\n', '        _totalSupply = _totalSupply.add(amount);\n', '        uint previousAmount = _balances[msg.sender];\n', '        uint newAmount = previousAmount.add(amount);\n', '        weightedStakeDate[msg.sender] = (weightedStakeDate[msg.sender].mul(previousAmount) / newAmount).add(block.timestamp.mul(amount) / newAmount);\n', '        _balances[msg.sender] = newAmount;\n', '\n', '        // permit\n', '        IERC20Permit(address(token)).permit(msg.sender, address(this), amount, deadline, v, r, s);\n', '        \n', '        token.safeTransferFrom(msg.sender, address(this), amount);\n', '        emit Staked(msg.sender, amount);\n', '    }\n', '\n', '    function stake(uint256 amount) external override nonReentrant {\n', '        require(amount > 0, "StakingRewardsSameTokenFixedAPY: Cannot stake 0");\n', '        _totalSupply = _totalSupply.add(amount);\n', '        uint previousAmount = _balances[msg.sender];\n', '        uint newAmount = previousAmount.add(amount);\n', '        weightedStakeDate[msg.sender] = (weightedStakeDate[msg.sender].mul(previousAmount) / newAmount).add(block.timestamp.mul(amount) / newAmount);\n', '        _balances[msg.sender] = newAmount;\n', '        token.safeTransferFrom(msg.sender, address(this), amount);\n', '        emit Staked(msg.sender, amount);\n', '    }\n', '\n', '    function stakeFor(uint256 amount, address user) external override nonReentrant {\n', '        require(amount > 0, "StakingRewardsSameTokenFixedAPY: Cannot stake 0");\n', '        _totalSupply = _totalSupply.add(amount);\n', '        uint previousAmount = _balances[user];\n', '        uint newAmount = previousAmount.add(amount);\n', '        weightedStakeDate[user] = (weightedStakeDate[user].mul(previousAmount) / newAmount).add(block.timestamp.mul(amount) / newAmount);\n', '        _balances[user] = newAmount;\n', '        token.safeTransferFrom(msg.sender, address(this), amount);\n', '        emit Staked(user, amount);\n', '    }\n', '\n', '    //A user can withdraw its staking tokens even if there is no rewards tokens on the contract account\n', '    function withdraw(uint256 amount) public override nonReentrant {\n', '        require(amount > 0, "StakingRewardsSameTokenFixedAPY: Cannot withdraw 0");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '        token.safeTransfer(msg.sender, amount);\n', '        emit Withdrawn(msg.sender, amount);\n', '    }\n', '\n', '    function getReward() public override nonReentrant {\n', '        uint256 reward = earned(msg.sender);\n', '        if (reward > 0) {\n', '            weightedStakeDate[msg.sender] = block.timestamp;\n', '            token.safeTransfer(msg.sender, reward);\n', '            emit RewardPaid(msg.sender, reward);\n', '        }\n', '    }\n', '\n', '    function withdrawAndGetReward(uint256 amount) external override {\n', '        getReward();\n', '        withdraw(amount);\n', '    }\n', '\n', '    function exit() external override {\n', '        getReward();\n', '        withdraw(_balances[msg.sender]);\n', '    }\n', '\n', '    function updateRewardAmount(uint256 reward) external onlyOwner {\n', '        rewardRate = reward;\n', '        emit RewardUpdated(reward);\n', '    }\n', '\n', '    function rescue(address to, IERC20 tokenAddress, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "StakingRewardsSameTokenFixedAPY: Cannot rescue to the zero address");\n', '        require(amount > 0, "StakingRewardsSameTokenFixedAPY: Cannot rescue 0");\n', '        require(tokenAddress != token, "StakingRewardsSameTokenFixedAPY: Cannot rescue staking/reward token");\n', '\n', '        tokenAddress.safeTransfer(to, amount);\n', '        emit RescueToken(to, address(tokenAddress), amount);\n', '    }\n', '\n', '    function rescue(address payable to, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "StakingRewardsSameTokenFixedAPY: Cannot rescue to the zero address");\n', '        require(amount > 0, "StakingRewardsSameTokenFixedAPY: Cannot rescue 0");\n', '\n', '        to.transfer(amount);\n', '        emit Rescue(to, amount);\n', '    }\n', '}']