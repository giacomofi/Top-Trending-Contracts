['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-31\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity ^0.8.4;\n', '\n', 'interface Structs {\n', '    struct Val {\n', '        uint256 value;\n', '    }\n', '\n', '    enum ActionType {\n', '      Deposit,   // supply tokens\n', '      Withdraw,  // borrow tokens\n', '      Transfer,  // transfer balance between accounts\n', '      Buy,       // buy an amount of some token (externally)\n', '      Sell,      // sell an amount of some token (externally)\n', '      Trade,     // trade tokens against another account\n', '      Liquidate, // liquidate an undercollateralized or expiring account\n', '      Vaporize,  // use excnt is denominated in wei\n', '      Call       // send arbitrary data to an address\n', '    }\n', '\n', '    enum AssetReference {\n', '        Delta // the amount is given as a delta from the current value\n', '    }\n', '\n', '    struct AssetAmount {\n', '        bool sign;\n', '        AssetDenomination denomination;\n', '        AssetReference ref;\n', '        uint256 value;\n', '    }\n', '\n', '    enum AssetDenomination { Wei, Par }\n', '\n', '    struct ActionArgs {\n', '        ActionType actionType;\n', '        uint256 accountId;\n', '        AssetAmount amount;\n', '        uint256 primaryMarketId;\n', '        uint256 secondaryMarketId;\n', '        address otherAddress;\n', '        uint256 otherAccountId;\n', '        bytes data;\n', '    }\n', '\n', '    struct Info {\n', '        address owner;  // The address that owns the account\n', '        uint256 number; // A nonce that allows a single address to control many accounts\n', '    }\n', '\n', '    struct Wei {\n', '        bool sign; // true if positive\n', '        uint256 value;\n', '    }\n', '}\n', '\n', 'interface ERC20 {\n', '  function liquidateBorrow ( address borrower, uint256 repayAmount, address cTokenCollateral ) external returns ( uint256 );\n', '  function approve ( address spender, uint256 amount ) external returns ( bool );\n', '  function balanceOf ( address owner ) external view returns ( uint256 );\n', '  function balanceOfUnderlying ( address owner ) external returns ( uint256 );\n', '  function decimals (  ) external view returns ( uint256 );\n', '  function mint ( uint256 mintAmount ) external returns ( uint256 );\n', '  function symbol (  ) external view returns ( string memory );\n', '  function totalSupply ( ) external view returns (uint256 supply);\n', '  function transfer ( address dst, uint256 amount ) external returns ( bool );\n', '  function transferFrom ( address src, address dst, uint256 amount ) external returns ( bool );\n', '  function underlying (  ) external view returns ( address );\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface ICorWETH {\n', '  function liquidateBorrow ( address borrower, address cTokenCollateral ) external payable;\n', '  function approve ( address spender, uint256 amount ) external returns ( bool );\n', '  function balanceOf ( address owner ) external view returns ( uint256 );\n', '  function balanceOfUnderlying ( address owner ) external returns ( uint256 );\n', '  function decimals (  ) external view returns ( uint256 );\n', '  function symbol (  ) external view returns ( string memory );\n', '  function totalSupply( ) external view returns (uint256 supply);\n', '  function transfer ( address dst, uint256 amount ) external returns ( bool );\n', '  function transferFrom ( address src, address dst, uint256 amount ) external returns ( bool );\n', '  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '}\n', '\n', 'interface Comptroller {\n', '\n', '    /**\n', '     * @notice Returns whether the given account is entered in the given asset\n', '     * @param account The address of the account to check\n', '     * @param cToken The cToken to check\n', '     * @return True if the account is in the asset, otherwise false.\n', '     */\n', '  function checkMembership ( address account, address cToken ) external view returns ( bool );\n', '  \n', '    /**\n', '     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n', '     */\n', '  function closeFactorMantissa (  ) external view returns ( uint256 );\n', '\n', '  function enterMarkets ( address[] memory cTokens ) external returns ( uint256[] memory );\n', '\n', '  function exitMarket ( address cTokenAddress ) external returns ( uint256 );\n', '\n', '    /**\n', '     * @notice Determine the current account liquidity wrt collateral requirements\n', '     * @return (possible error code (semi-opaque),\n', '                account liquidity in excess of collateral requirements,\n', '     *          account shortfall below collateral requirements)\n', '     */\n', '  function getAccountLiquidity ( address account ) external view returns ( uint256, uint256, uint256 );\n', '\n', '  function getAllMarkets (  ) external view returns ( address[] memory );\n', '\n', '    /**\n', '     * @notice Returns the assets an account has entered\n', '     * @param account The address of the account to pull assets for\n', '     * @return A dynamic list with the assets the account has entered\n', '     */\n', '  function getAssetsIn ( address account ) external view returns ( address[] memory );\n', '\n', '  function liquidateBorrowAllowed ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 repayAmount ) external returns ( uint256 );\n', '\n', '  function liquidateBorrowVerify ( address cTokenBorrowed, address cTokenCollateral, address liquidator, address borrower, uint256 actualRepayAmount, uint256 seizeTokens ) external;\n', '\n', '    /**\n', '     * @notice Multiplier representing the discount on collateral that a liquidator receives\n', '     */\n', '  function liquidationIncentiveMantissa (  ) external view returns ( uint256 );\n', '}\n', '\n', 'interface IKyberNetworkProxy {\n', '\n', '    event ExecuteTrade(\n', '        address indexed trader,\n', '        ERC20 src,\n', '        ERC20 dest,\n', '        address destAddress,\n', '        uint256 actualSrcAmount,\n', '        uint256 actualDestAmount,\n', '        address platformWallet,\n', '        uint256 platformFeeBps\n', '    );\n', '\n', '    /// @notice Backward compatible function\n', '    /// @notice Use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev Trade from src to dest token and sends dest token to destAddress\n', '    /// @param src Source token\n', '    /// @param srcAmount Amount of src tokens in twei\n', '    /// @param dest Destination token\n', '    /// @param destAddress Address to send tokens to\n', '    /// @param maxDestAmount A limit on the amount of dest tokens in twei\n', '    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade reverts\n', '    /// @param walletId Platform wallet address for receiving fees\n', '    /// @param hint Advanced instructions for running the trade \n', '    /// @return Amount of actual dest tokens in twei\n', '    function tradeWithHint(\n', '        ERC20 src,\n', '        uint256 srcAmount,\n', '        ERC20 dest,\n', '        address payable destAddress,\n', '        uint256 maxDestAmount,\n', '        uint256 minConversionRate,\n', '        address payable walletId,\n', '        bytes calldata hint\n', '    ) external payable returns (uint256);\n', '\n', '    /// @notice Use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev Trade from src to dest token and sends dest token to destAddress\n', '    /// @param src Source token\n', '    /// @param srcAmount Amount of src tokens in twei\n', '    /// @param dest Destination token\n', '    /// @param destAddress Address to send tokens to\n', '    /// @param maxDestAmount A limit on the amount of dest tokens in twei\n', '    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade reverts\n', '    /// @param platformWallet Platform wallet address for receiving fees\n', '    /// @param platformFeeBps Part of the trade that is allocated as fee to platform wallet. Ex: 10000 = 100%, 100 = 1%\n', '    /// @param hint Advanced instructions for running the trade \n', '    /// @return destAmount Amount of actual dest tokens in twei\n', '    function tradeWithHintAndFee(\n', '        ERC20 src,\n', '        uint256 srcAmount,\n', '        ERC20 dest,\n', '        address payable destAddress,\n', '        uint256 maxDestAmount,\n', '        uint256 minConversionRate,\n', '        address payable platformWallet,\n', '        uint256 platformFeeBps,\n', '        bytes calldata hint\n', '    ) external payable returns (uint256 destAmount);\n', '\n', '    /// @notice Backward compatible function\n', '    /// @notice Use token address ETH_TOKEN_ADDRESS for ether\n', '    /// @dev Trade from src to dest token and sends dest token to destAddress\n', '    /// @param src Source token\n', '    /// @param srcAmount Amount of src tokens in twei\n', '    /// @param dest Destination token\n', '    /// @param destAddress Address to send tokens to\n', '    /// @param maxDestAmount A limit on the amount of dest tokens in twei\n', '    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade reverts\n', '    /// @param platformWallet Platform wallet address for receiving fees\n', '    /// @return Amount of actual dest tokens in twei\n', '    function trade(\n', '        ERC20 src,\n', '        uint256 srcAmount,\n', '        ERC20 dest,\n', '        address payable destAddress,\n', '        uint256 maxDestAmount,\n', '        uint256 minConversionRate,\n', '        address payable platformWallet\n', '    ) external payable returns (uint256);\n', '\n', '    /// @notice backward compatible\n', '    /// @notice Rate units (10 ** 18) => destQty (twei) / srcQty (twei) * 10 ** 18\n', '    function getExpectedRate(\n', '        ERC20 src,\n', '        ERC20 dest,\n', '        uint256 srcQty\n', '    ) external view returns (uint256 expectedRate, uint256 worstRate);\n', '\n', '    function getExpectedRateAfterFee(\n', '        ERC20 src,\n', '        ERC20 dest,\n', '        uint256 srcQty,\n', '        uint256 platformFeeBps,\n', '        bytes calldata hint\n', '    ) external view returns (uint256 expectedRate);\n', '}\n', '\n', '// dYdX flash loan contract\n', 'interface ISoloMargin {\n', '    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\n', '}\n', '\n', 'abstract contract DyDxPool is Structs {\n', '    function getAccountWei(Info memory account, uint256 marketId) public virtual view returns (Wei memory);\n', '    function operate(Info[] memory, ActionArgs[] memory) public virtual;\n', '}\n', '\n', '\n', 'address constant kETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '// Compound.Finance Comptroller constants\n', '// Note:To call Comptroller functions, use the Comptroller ABI on the Unitroller address.\n', 'address constant kUnitroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n', 'address constant kComptroller = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\n', 'address constant kcUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\n', 'address constant kcETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n', '\n', '// KyberSwap Proxy contract \n', 'address constant kKyberProxy = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\n', '// KyberHintHandler (KyberMatchingEngine)\n', 'address constant kKybeHint = 0xa1C0Fa73c39CFBcC11ec9Eb1Afc665aba9996E2C;\n', '\n', '// dYdX loan currencies\n', 'address constant kWETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', 'address constant kSAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n', 'address constant kUSDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', 'address constant kDAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '\n', '/**********************************************************\n', ' * Main Contract: PreachersCompFiLqdt v1.0.4\n', ' **********************************************************/\n', 'contract PreachersCompFiLqdt is Structs {\n', '    IKyberNetworkProxy internal cKyberProxy = IKyberNetworkProxy(kKyberProxy);\n', '    DyDxPool internal kDyDxPool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n', '\n', '    // Contract owner\n', '    address payable public owner;\n', '\n', '    // Modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "caller is not the owner!");\n', '        _;\n', '    }\n', '\n', '    constructor() payable {\n', '\n', '        // Track the contract owner\n', '        owner = payable(msg.sender);\n', '        \n', '    }\n', '    \n', '    receive() external payable {\n', '        emit Received(msg.sender, msg.value);\n', '    }\n', '\n', '    // dYdX loan Currencies\n', '    mapping(address => uint256) public currencies;\n', '    \n', '    function tokenToMarketId(address token) internal view returns (uint256 ) {\n', '        \n', '        require(currencies[token] != 0, "FlashLoan: Unsupported token");\n', '        \n', '        return currencies[token] - 1;\n', '    }\n', '\n', '\n', '    /***************************************************************************\n', '     * the DyDx will call `callFunction(address sender, Info memory accountInfo,\n', '     * bytes memory data) public` after during `operate` call\n', '     ***************************************************************************/\n', '    function flashloan(address token, uint256 amount, bytes memory data)\n', '        internal\n', '    {\n', '        ERC20(token).approve(address(kDyDxPool), amount + 1);\n', '\n', '        Info[] memory infos = new Info[](1);\n', '\n', '        ActionArgs[] memory args = new ActionArgs[](3);\n', '\n', '        infos[0] = Info(address(this), 0);\n', '\n', '        AssetAmount memory wamt = AssetAmount(\n', '            false,\n', '            AssetDenomination.Wei,\n', '            AssetReference.Delta,\n', '            amount\n', '        );\n', '        \n', '        ActionArgs memory withdraw;\n', '        withdraw.actionType = ActionType.Withdraw;\n', '        withdraw.accountId = 0;\n', '        withdraw.amount = wamt;\n', '        withdraw.primaryMarketId = tokenToMarketId(token);\n', '        withdraw.otherAddress = address(this);\n', '\n', '        args[0] = withdraw;\n', '\n', '        ActionArgs memory call;\n', '        call.actionType = ActionType.Call;\n', '        call.accountId = 0;\n', '        call.otherAddress = address(this);\n', '        call.data = data;\n', '\n', '        args[1] = call;\n', '\n', '        ActionArgs memory deposit;\n', '        AssetAmount memory damt = AssetAmount(\n', '            true,\n', '            AssetDenomination.Wei,\n', '            AssetReference.Delta,\n', '            amount + 1\n', '        );\n', '        deposit.actionType = ActionType.Deposit;\n', '        deposit.accountId = 0;\n', '        deposit.amount = damt;\n', '        deposit.primaryMarketId = tokenToMarketId(token);\n', '        deposit.otherAddress = address(this);\n', '\n', '        args[2] = deposit;\n', '\n', '        kDyDxPool.operate(infos, args);\n', '    }\n', '\n', '    /*************************************************************************************************************\n', '     * Call this contract function from the external \n', '     * remote job to perform the liquidation.\n', '     ************************************************************************************************************/\n', '    function doCompFiLiquidate(\n', '        //loan information\n', '        address flashToken, \n', '        uint256 flashAmount,\n', '        // Borrow Account to be liquidated\n', '        address targetAccount, \n', '        address targetToken, \n', '        uint256 liquidateAmount,\n', '        // liquidation reimbursement and Reward Token\n', '        address collateralToken\n', '        ) external returns(bool) {\n', '        \n', '        emit PassThru( liquidateAmount );\n', '        \n', '        currencies[kWETH] = 1;\n', '        currencies[kSAI] = 2;\n', '        currencies[kUSDC] = 3;\n', '        currencies[kDAI] = 4;\n', '    \n', '        // Populate the passthru data structure, which will be used\n', "        // by 'callFunction'\n", '        bytes memory data = abi.encode(\n', '            flashToken, \n', '            flashAmount,\n', '            targetAccount, \n', '            targetToken, \n', '            liquidateAmount, \n', '            collateralToken);\n', '        \n', '        // execution goes to `callFunction`\n', '        // STEP 1\n', '        flashloan(flashToken, flashAmount, data);\n', '        emit Liquidated( targetAccount, targetToken, liquidateAmount );\n', '        return true;\n', '    }\n', '    \n', '    /**************************************************************************************\n', "     * Preacher's Method II\n", '     * \n', '     * 1. Obtain Flash Loan in USDC from dYdX in the amount of equal value in the \n', '     * liquidation amount.\n', '     * 2. If the liquidate token is cUSDC, skip to step (3). Otherwise, swap (Kyber) the \n', '     * USDC for an equal value of the liquidate tokens.\n', '     * 3. Pay down the liquidate amount, liquidateBorrow(). CompFi will award an equal \n', "     * value from the unsafe account's collateral + incentive reward.\n", '     * 4. Swap the received collateral tokens for USDC.\n', '     * 5. Repay the flash loan with the USDC.\n', '     * 6. Transfer what is left of the USDC to the Msg.sender.\n', '     * \n', '     **************************************************************************************/\n', '    function callFunction(\n', '        address, /* sender */\n', '        Info calldata, /* accountInfo */\n', '        bytes calldata data\n', '    ) external {\n', '\t\n', '\t    // Decode the parameters in "calldata" as passed by doCompFiLiquidate.\n', '        (address flashToken, \n', '         uint256 flashAmount, \n', '         address targetAccount, \n', '         address targetToken, \n', '         uint256 liquidateAmount,\n', '         address collateralToken) = \n', '\t\t\tabi.decode(data, (address, uint256, address, address, uint256, address));\n', '\t\t\n', '\t\tERC20 cFlashToken = ERC20(flashToken);\n', '\n', '\t\temit Borrowed(flashToken, cFlashToken.balanceOf(address(this)));\n', '\n', '\t\trequire(cFlashToken.balanceOf(address(this)) >= flashAmount ,"Contract did not get the loan");\n', '\t\t\n', '        // function approve(address _spender, uint256 _value) public returns (bool success)\n', '\t\tERC20 underlying = ERC20(cFlashToken.underlying( )); // get a handle for the underlying asset contract\n', '\t\trequire(underlying.approve(address(cFlashToken), flashAmount) == true, \n', '\t\t    "01 approval failed"); // approve the transfer\n', '\t\trequire(cFlashToken.mint(flashAmount) > 0, "01 Mint failed");    // mint the cTokens and assert there is no error\n', '\t\t\n', '\t\tERC20 cTargetToken = ERC20(targetToken);\n', '        // Step 2. Swap USDC for targetToken\n', '        if (targetToken != kcUSDC) {\n', '    \t   require( executeKyberSwap(cFlashToken, flashAmount,\n', '\t            cTargetToken, payable(address(this)), \n', '\t            liquidateAmount) > 0, "02 First Token swap failed");\n', '        }\n', '        \n', '        require(cTargetToken.approve(address(this), liquidateAmount) == true,\n', '            "02 approval failed.");\n', '        \n', '        // Step 3. Pay down the amount borrowed by the unsafe account\n', '\t\t// -- Enter the market for the token to be liquidated\n', '\t\tComptroller ctroll = Comptroller(kUnitroller);\n', '\n', '\t\taddress[] memory cTokens = new address[](1);\n', '\t\tcTokens[0] = targetToken;\n', '\t\tuint[] memory Errors = ctroll.enterMarkets(cTokens);\n', '\t\tif (Errors[0] != 0) {\n', '            revert("01 Comptroller enter Markets for target token failed. ");\n', '\t\t}\n', '\t\t\n', '\t\tif (targetToken == kcETH){\n', '\t\t    ICorWETH ceTargetToken = ICorWETH(targetToken);\n', '\t\t    ceTargetToken.liquidateBorrow{value: flashAmount}\n', '\t\t        (targetAccount, collateralToken);\n', '\t\t} else {\n', '\t\t    cTargetToken.liquidateBorrow(targetAccount, flashAmount, collateralToken);\n', '\t\t}\n', '\t\trequire(ctroll.exitMarket(targetToken) == 0, \n', '\t\t    "Exit Market of target token failed. ");\n', '\t\t \n', '\t\t// 4. Swap the received collateral tokens back to USDC to repay the flash loan.\n', '\t\tcTokens[0] = collateralToken;\n', '\t\tErrors = ctroll.enterMarkets(cTokens);\n', '\t\trequire(Errors[0] == 0, "02 Comptroller.enter Markets for collateral Token failed.");\n', '\n', '\t\tERC20 cCollateralToken = ERC20(collateralToken);\n', '\t\trequire(cCollateralToken.approve(address(this), cCollateralToken.balanceOf(address(this))) == true,\n', '\t\t    "03 Collateral Token approval failed.");\n', '\t\t    \n', '\t\tif (collateralToken != kcUSDC) {\n', '    \t   require( executeKyberSwap(cCollateralToken, \n', '    \t        cCollateralToken.balanceOf(address(this)),\n', '\t            cTargetToken, payable(address(this)), \n', '\t            899999999999999999) > 0, "02 First Token swap failed");\n', '        }\n', '        \n', '    \t// -- Liquidation is completed in flashloan()\n', '    }\n', '    \n', '    function AccountsAssets ( address LAccount ) external view returns ( address[] memory ){\n', '        Comptroller troll = Comptroller(kUnitroller);\n', '        return troll.getAssetsIn( LAccount );\n', '    }\n', '    \n', '    function changeOwner(address payable newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '        emit ChangedOwner(owner, newOwner);\n', '    }\n', '\n', '    function getTokenBalance(address tokenAddress) external view returns(uint256) {\n', '        ERC20 theToken = ERC20(tokenAddress);\n', '        return theToken.balanceOf(address(this));\n', '    }\n', '    \n', '    function getETHBalance( ) external view returns(uint256) {\n', '        ICorWETH theToken = ICorWETH( 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE );\n', '        return theToken.balanceOf(address(this));\n', '    }\n', '    \n', '    function getCloseFactor() external view returns (uint256)  {\n', '        Comptroller troll = Comptroller(kUnitroller);\n', '        return troll.closeFactorMantissa();\n', '\n', '    }\n', '    \n', '    function VerifyAccountLiquidity( address laccount ) external view \n', '        returns ( uint256, uint256, uint256 ) {\n', '        \n', '        Comptroller troll = Comptroller(kUnitroller);\n', '        \n', '        return troll.getAccountLiquidity(laccount);\n', '    }\n', '    \n', '    function fWithdraw(address token) public onlyOwner returns(bool) {\n', '        uint256 tokenBalance;\n', '        // withdrawing Ether\n', '        if (address(token) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n', '            if (address(this).balance > 0){\n', '                tokenBalance = address(this).balance;\n', '                payable(msg.sender).transfer(address(this).balance);\n', '            }\n', '\n', '        } else {\n', '            ERC20 withdrawToken = ERC20(token);\n', '            if (withdrawToken.balanceOf(address(this)) > 0){\n', '                tokenBalance = withdrawToken.balanceOf(address(this));\n', '                require(withdrawToken.transfer(msg.sender, \n', '                    (withdrawToken.balanceOf(address(this)))));\n', '            }\n', '        }\n', '        emit Withdrawn(token, tokenBalance);\n', '        return true;\n', '    }\n', '\n', '    // All events for this contract\n', '    event Borrowed(address tokenborrowed, uint256 amount);\n', '    event ChangedOwner(address payable owner, address payable newOwner);\n', '    event Liquidated(address account, address token, uint256 amount );\n', '    event PassThru( uint256 liquidateampount );\n', '    event Received(address, uint);\n', '    event Swapped(address fromtoken, uint256 fromamount, address totoken, uint256 toamount);\n', '    event Transfer(address from, address to, uint256 value);\n', '    event Withdrawn(address token, uint256 amount);\n', '\n', '    /***************************************************************************\n', '     * KyberSwap functions\n', '    ****************************************************************************/\n', '    /// Swap from srcToken to destToken (including ether)\n', '    function executeKyberSwap( ERC20 cSrcToken, uint256 srcQty, ERC20 cDestToken, \n', '        address payable destAddress, uint256 maxDestAmount\n', '    ) internal returns ( uint256 ) {\n', '        \n', '        // if not Ethereum\n', '        if (address(cSrcToken) != kETH) {\n', '\n', '            // mitigate ERC20 Approve front-running attack, by initially setting\n', '            // allowance to 0\n', '            require(cSrcToken.approve(address(cKyberProxy), 0), "approval to 0 failed");\n', '\n', "            // set the spender's token allowance to tokenQty\n", '            require(cSrcToken.approve(address(cKyberProxy), srcQty), "approval to srcQty failed");\n', '        }\n', '\n', '        // Get the minimum conversion rate\n', '        uint256 platformFeeBps = 25;    // using the Kyber example https://developer.kyber.network/docs/Integrations-SmartContractGuide/#fetching-rates\n', '        \n', '        uint256 minConversionRate = cKyberProxy.getExpectedRateAfterFee(\n', '            cSrcToken,\n', '            cDestToken,\n', '            srcQty,\n', '            platformFeeBps,\n', '            "" // empty hint\n', '        );\n', '        \n', '        \n', '        /*********************************************************************************\n', '         * function trade(ERC20 src, uint256 srcAmount,\n', '         *  ERC20 dest, address payable destAddress,\n', '         *  uint256 maxDestAmount,    // wei\n', '         * \n', '         *  uint256 minConversionRate,\n', '         *      Minimum conversion rate (in wei). Trade is canceled if actual rate is lower\n', '         *      Should match makerAssetAmount/takerAssetAmount\n', '         *      This rate means for every 1 srcAmount, a Minimum\n', '         *      of X target Tokens are expected. \n', '         *      (Source token value / Target Token value) * 10**18 \n', '         * \n', '         *  address payable platformWallet ) external payable returns (uint256);\n', '        **********************************************************************************/\n', '        // Execute the trade and send to this contract to use to pay down the unsafe account\n', '        uint256 destAmount = cKyberProxy.trade(cSrcToken, srcQty, \n', '            cDestToken, payable(address(this)), \n', '            maxDestAmount, \n', '            minConversionRate,\n', '            // this contract\n', '            destAddress);\n', '          \n', '        emit Swapped(address(cSrcToken), srcQty, address(cDestToken), destAmount);\n', '        return destAmount;\n', '    }\n', '}\n', '\n', '// These definitions are taken from across multiple dydx contracts, and are\n', '// limited to just the bare minimum necessary to make flash loans work.\n', 'library Types {\n', '    enum AssetDenomination { Wei, Par }\n', '    enum AssetReference { Delta, Target }\n', '    struct AssetAmount {\n', '        bool sign;\n', '        AssetDenomination denomination;\n', '        AssetReference ref;\n', '        uint256 value;\n', '    }\n', '}\n', '\n', 'library Account {\n', '    struct Info {\n', '        address owner;\n', '        uint256 number;\n', '    }\n', '}\n', '\n', 'library Actions {\n', '    enum ActionType {\n', '        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\n', '    }\n', '    struct ActionArgs {\n', '        ActionType actionType;\n', '        uint256 accountId;\n', '        Types.AssetAmount amount;\n', '        uint256 primaryMarketId;\n', '        uint256 secondaryMarketId;\n', '        address otherAddress;\n', '        uint256 otherAccountId;\n', '        bytes data;\n', '    }\n', '}']