['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-22\n', '*/\n', '\n', '/// SPDX-License-Identifier: GPL-3.0-or-later\n', 'pragma solidity 0.6.12;\n', '\n', '/// @dev brief interface for moloch dao v2 erc20 token txs\n', 'interface IERC20 { \n', '    function balanceOf(address account) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transfer(address to, uint256 amount) external returns (bool);\n', '    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n', '}\n', '\n', '/// @dev brief interface for moloch dao v2 \n', 'interface IMOLOCH { \n', '    function submitProposal(\n', '        address applicant,\n', '        uint256 sharesRequested,\n', '        uint256 lootRequested,\n', '        uint256 tributeOffered,\n', '        address tributeToken,\n', '        uint256 paymentRequested,\n', '        address paymentToken,\n', '        string calldata details\n', '    ) external returns (uint256);\n', '    \n', '    function getProposalFlags(uint256 proposalId) external view returns (bool[6] memory);\n', '    \n', '    function withdrawBalance(address token, uint256 amount) external;\n', '}\n', '\n', '/// @dev brief interface for sushi bar (`xSUSHI`) entry\n', 'interface ISushiBar { \n', '   function enter(uint256 _amount) external;\n', '}\n', '\n', '/// @dev helper for address type\n', 'library Address { \n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '/// @dev helper for non-standard token\n', 'library SafeERC20 { \n', '    using Address for address;\n', '    \n', '    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\n', '    }\n', '    \n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 amount) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\n', '    }\n', '    \n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '        (bool success, bytes memory returnData) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returnData.length > 0) { // return data is optional\n', '            require(abi.decode(returnData, (bool)), "SafeERC20: erc20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '/// @dev helper for under/overflow check\n', 'library SafeMath { \n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '    \n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '    \n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '    \n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '}\n', '\n', '/// @dev call wrapper for reentrancy check\n', 'contract ReentrancyGuard {\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '    uint256 private _status;\n', '\n', '    constructor() internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '        _status = _ENTERED;\n', '        _;\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '/// @dev low-level caller, ETH holder, separate bank for moloch dao v2 - based on raid guild `Minion`\n', 'contract SushiMinion is ReentrancyGuard {\n', '    address immutable sushiToken; // internal sushi token contract reference\n', '    IMOLOCH public moloch; // parent moloch contract reference \n', '\n', '    mapping(uint256 => Action) public actions; // proposalId => Action\n', '\n', '    struct Action {\n', '        uint256 value;\n', '        address to;\n', '        address proposer;\n', '        bool executed;\n', '        bytes data;\n', '    }\n', '\n', '    event ProposeAction(uint256 proposalId, address proposer);\n', '    event ExecuteAction(uint256 proposalId, address executor);\n', '\n', '    constructor(address _moloch, address _sushiToken, address _xSushiToken, address _aave) public {\n', '        moloch = IMOLOCH(_moloch);\n', '        sushiToken = _sushiToken;\n', '        IERC20(_sushiToken).approve(_xSushiToken, uint256(-1)); // max approve sushi bar for sushi token staking into xSushi\n', '        IERC20(_xSushiToken).approve(_aave, uint256(-1)); // max approve aave for deposit into aToken from underlying xSushi\n', '    }\n', '\n', '    function doWithdraw(address token, uint256 amount) external nonReentrant {\n', '        moloch.withdrawBalance(token, amount); // withdraw funds from parent moloch into minion\n', '    }\n', '\n', '    function proposeAction(\n', '        address actionTo,\n', '        uint256 actionValue,\n', '        bytes calldata actionData,\n', '        string calldata details\n', '    ) external nonReentrant returns (uint256) {\n', '        // No calls to zero address allows us to check that proxy submitted\n', '        // the proposal without getting the proposal struct from parent moloch\n', '        require(actionTo != address(0), "invalid actionTo");\n', '\n', '        uint256 proposalId = moloch.submitProposal(\n', '            address(this),\n', '            0,\n', '            0,\n', '            0,\n', '            sushiToken,\n', '            0,\n', '            sushiToken,\n', '            details\n', '        );\n', '\n', '        Action memory action = Action({\n', '            value: actionValue,\n', '            to: actionTo,\n', '            proposer: msg.sender,\n', '            executed: false,\n', '            data: actionData\n', '        });\n', '\n', '        actions[proposalId] = action;\n', '\n', '        emit ProposeAction(proposalId, msg.sender);\n', '        return proposalId;\n', '    }\n', '\n', '    function executeAction(uint256 proposalId) external nonReentrant returns (bytes memory) {\n', '        Action memory action = actions[proposalId];\n', '        bool[6] memory flags = moloch.getProposalFlags(proposalId);\n', '\n', '        require(action.to != address(0), "invalid proposalId");\n', '        require(!action.executed, "action executed");\n', '        require(address(this).balance >= action.value, "insufficient ETH");\n', '        require(flags[2], "proposal not passed");\n', '\n', '        // execute call\n', '        actions[proposalId].executed = true;\n', '        (bool success, bytes memory retData) = action.to.call{value: action.value}(action.data);\n', '        require(success, "call failure");\n', '        emit ExecuteAction(proposalId, msg.sender);\n', '        return retData;\n', '    }\n', '\n', '    receive() external payable {}\n', '}']