['pragma solidity ^0.6.6;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./IACOPoolStrategy.sol";\n', 'import "./IACOFactory.sol";\n', 'import "./IACOToken.sol";\n', 'import "./ILendingPool.sol";\n', 'import "./IACOPool2.sol";\n', '\n', 'library ACOPoolLib {\n', '\tusing SafeMath for uint256;\n', '\t\n', '\tstruct OpenPositionData {\n', '\t    bool isDeposit;\n', '\t    bool isCall;\n', '\t    uint256 underlyingPrice;\n', '\t    uint256 baseVolatility;\n', '\t    uint256 underlyingPriceAdjustPercentage;\n', '\t    uint256 withdrawOpenPositionPenalty;\n', '\t    uint256 fee;\n', '\t    uint256 underlyingPrecision;\n', '\t    address underlying;\n', '\t    address strikeAsset;\n', '\t    address strategy;\n', '\t    address acoFactory;\n', '\t    address lendingToken;\n', '\t}\n', '\t\n', '\tstruct QuoteData {\n', '\t\taddress lendingToken;\n', '\t\taddress strategy;\n', '\t\tuint256 baseVolatility;\n', '\t\tuint256 fee;\n', '\t\tuint256 underlyingPrice;\n', '\t\tuint256 underlyingPrecision;\n', '\t\tAcoData acoData;\n', '\t\tIACOPool2.PoolAcoPermissionConfig acoPermissionConfig;\n', '\t}\n', '\t\n', '\tstruct AcoData {\n', '        bool isCall;\n', '        uint256 strikePrice; \n', '        uint256 expiryTime;\n', '        uint256 tokenAmount;\n', '\t    address underlying;\n', '        address strikeAsset; \n', '\t}\n', '\t\n', '\tuint256 public constant PERCENTAGE_PRECISION = 100000;\n', '\t\n', '\tfunction name(address underlying, address strikeAsset, bool isCall) public view returns(string memory) {\n', '        return string(abi.encodePacked(\n', '            "ACO POOL WRITE ",\n', '            _getAssetSymbol(underlying),\n', '            "-",\n', '            _getAssetSymbol(strikeAsset),\n', '            "-",\n', '            (isCall ? "CALL" : "PUT")\n', '        ));\n', '    }\n', '    \n', '    function acoStrikeAndExpirationIsValid(\n', '\t\tuint256 strikePrice, \n', '        uint256 acoExpiryTime, \n', '\t\tuint256 underlyingPrice,\n', '        IACOPool2.PoolAcoPermissionConfig memory acoPermissionConfig\n', '    ) public view returns(bool) {\n', '        return _acoExpirationIsValid(acoExpiryTime, acoPermissionConfig) && _acoStrikePriceIsValid(strikePrice, underlyingPrice, acoPermissionConfig);\n', '    }\n', '\n', '    function getBaseAssetsWithdrawWithLocked(\n', '        uint256 shares,\n', '        address underlying,\n', '        address strikeAsset,\n', '        bool isCall,\n', '        uint256 totalSupply,\n', '        address lendingToken\n', '    ) public view returns(\n', '        uint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn\n', '    ) {\n', '\t\tuint256 underlyingBalance = _getPoolBalanceOf(underlying);\n', '\t\tuint256 strikeAssetBalance;\n', '\t\tif (isCall) {\n', '\t\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\n', '\t\t} else {\n', '\t\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\n', '\t\t}\n', '\t\t\n', '\t\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\n', '\t\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\n', '    }\n', '    \n', '    function getBaseWithdrawNoLockedData(\n', '        uint256 shares,\n', '        uint256 totalSupply,\n', '        bool isCall,\n', '        uint256 underlyingBalance, \n', '        uint256 strikeAssetBalance, \n', '        uint256 collateralBalance, \n', '        uint256 collateralLockedRedeemable\n', '    ) public pure returns(\n', '        uint256 underlyingWithdrawn,\n', '\t\tuint256 strikeAssetWithdrawn,\n', '\t\tbool isPossible\n', '    ) {\n', '\t\tuint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);\n', '\t\t\n', '\t\tif (isCall) {\n', '\t\t\tunderlyingWithdrawn = collateralAmount;\n', '\t\t\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\n', '\t\t\tisPossible = (collateralAmount <= underlyingBalance.add(collateralLockedRedeemable));\n', '\t\t} else {\n', '\t\t\tstrikeAssetWithdrawn = collateralAmount;\n', '\t\t\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\n', '\t\t\tisPossible = (collateralAmount <= strikeAssetBalance.add(collateralLockedRedeemable));\n', '\t\t}\n', '    }\n', '    \n', '    function getAmountToLockedWithdraw(\n', '        uint256 shares, \n', '        uint256 totalSupply, \n', '        address lendingToken,\n', '        address underlying, \n', '        address strikeAsset, \n', '        bool isCall\n', '    ) public view returns(\n', '        uint256 underlyingWithdrawn, \n', '        uint256 strikeAssetWithdrawn\n', '    ) {\n', '\t\tuint256 underlyingBalance = _getPoolBalanceOf(underlying);\n', '\t\tuint256 strikeAssetBalance;\n', '\t\tif (isCall) {\n', '\t\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\n', '\t\t} else {\n', '\t\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\n', '\t\t}\n', '\t\t\n', '\t\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\n', '\t\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\n', '    }\n', '    \n', '    function getAmountToNoLockedWithdraw(\n', '        uint256 shares, \n', '        uint256 totalSupply,\n', '        uint256 underlyingBalance, \n', '        uint256 strikeAssetBalance,\n', '        uint256 collateralBalance,\n', '        uint256 minCollateral,\n', '        bool isCall\n', '    ) public pure returns(\n', '        uint256 underlyingWithdrawn, \n', '        uint256 strikeAssetWithdrawn\n', '    ) {\n', '\t\tuint256 collateralAmount = shares.mul(collateralBalance).div(totalSupply);\n', '\t\trequire(collateralAmount >= minCollateral, "ACOPoolLib: The minimum collateral was not satisfied");\n', '\n', '        if (isCall) {\n', '\t\t\trequire(collateralAmount <= underlyingBalance, "ACOPoolLib: Collateral balance is not sufficient");\n', '\t\t\tunderlyingWithdrawn = collateralAmount;\n', '\t\t\tstrikeAssetWithdrawn = strikeAssetBalance.mul(shares).div(totalSupply);\n', '        } else {\n', '\t\t\trequire(collateralAmount <= strikeAssetBalance, "ACOPoolLib: Collateral balance is not sufficient");\n', '\t\t\tstrikeAssetWithdrawn = collateralAmount;\n', '\t\t\tunderlyingWithdrawn = underlyingBalance.mul(shares).div(totalSupply);\n', '\t\t}\n', '    }\n', '    \n', '    function quote(QuoteData memory data) public view returns(\n', '        uint256 swapPrice, \n', '        uint256 protocolFee, \n', '        uint256 volatility, \n', '        uint256 collateralAmount\n', '    ) {\n', '        AcoData memory acoData = data.acoData;\n', '        require(_acoExpirationIsValid(acoData.expiryTime, data.acoPermissionConfig), "ACOPoolLib: Invalid ACO token expiration");\n', '\t\trequire(_acoStrikePriceIsValid(acoData.strikePrice, data.underlyingPrice, data.acoPermissionConfig), "ACOPoolLib: Invalid ACO token strike price");\n', '\n', '        uint256 collateralAvailable;\n', '        (collateralAmount, collateralAvailable) = _getOrderSizeData(data.lendingToken, data.underlyingPrecision, acoData);\n', '        uint256 calcPrice;\n', '        (calcPrice, volatility) = _strategyQuote(data.strategy, data.underlyingPrice, data.baseVolatility, collateralAmount, collateralAvailable, acoData);\n', '        (swapPrice, protocolFee) = _setSwapPriceAndFee(calcPrice, acoData.tokenAmount, data.fee, data.underlyingPrecision);\n', '    }\n', '\n', '\tfunction getCollateralData(OpenPositionData memory data, address[] memory openAcos) public view returns(\n', '        uint256 underlyingBalance, \n', '        uint256 strikeAssetBalance, \n', '        uint256 collateralBalance,\n', '        uint256 collateralLocked,\n', '        uint256 collateralOnOpenPosition,\n', '        uint256 collateralLockedRedeemable\n', '    ) {\n', '\t\t(underlyingBalance, strikeAssetBalance, collateralBalance) = _getBaseCollateralData(\n', '            data.isDeposit, \n', '            data.underlying,\n', '            data.strikeAsset,\n', '            data.isCall,\n', '            data.underlyingPrice,\n', '            data.lendingToken,\n', '            data.underlyingPriceAdjustPercentage,\n', '            data.underlyingPrecision);\n', '            \n', '\t\t(collateralLocked, collateralOnOpenPosition, collateralLockedRedeemable) = _poolOpenPositionCollateralBalance(data, openAcos);\n', '\t}\n', '\t\n', '\tfunction _getBaseCollateralData(\n', '\t    bool isDeposit,\n', '\t    address underlying,\n', '\t    address strikeAsset,\n', '\t    bool isCall,\n', '\t    uint256 underlyingPrice,\n', '\t    address lendingToken,\n', '\t    uint256 underlyingPriceAdjustPercentage,\n', '\t    uint256 underlyingPrecision\n', '\t) internal view returns(\n', '        uint256 underlyingBalance, \n', '        uint256 strikeAssetBalance, \n', '        uint256 collateralBalance\n', '    ) {\n', '\t\tunderlyingBalance = _getPoolBalanceOf(underlying);\n', '\t\t\n', '\t\tif (isCall) {\n', '\t\t    strikeAssetBalance = _getPoolBalanceOf(strikeAsset);\n', '\t\t\tcollateralBalance = underlyingBalance;\n', '\t\t\tif (isDeposit && strikeAssetBalance > 0) {\n', '\t\t\t\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, false); \n', '\t\t\t\tcollateralBalance = collateralBalance.add(strikeAssetBalance.mul(underlyingPrecision).div(priceAdjusted));\n', '\t\t\t}\n', '\t\t} else {\n', '\t\t    strikeAssetBalance = _getPoolBalanceOf(lendingToken);\n', '\t\t\tcollateralBalance = strikeAssetBalance;\n', '\t\t\tif (isDeposit && underlyingBalance > 0) {\n', '\t\t\t\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(underlyingPrice, underlyingPriceAdjustPercentage, true); \n', '\t\t\t\tcollateralBalance = collateralBalance.add(underlyingBalance.mul(priceAdjusted).div(underlyingPrecision));\n', '\t\t\t}\n', '\t\t}\n', '\t}\n', '\n', '\tfunction _poolOpenPositionCollateralBalance(OpenPositionData memory data, address[] memory openAcos) internal view returns(\n', '        uint256 collateralLocked, \n', '        uint256 collateralOnOpenPosition,\n', '        uint256 collateralLockedRedeemable\n', '    ) {\n', '\t\tfor (uint256 i = 0; i < openAcos.length; ++i) {\n', '\t\t\taddress acoToken = openAcos[i];\n', '            \n', '            (uint256 locked, uint256 openPosition, uint256 lockedRedeemable) = _getOpenPositionCollateralBalance(acoToken, data);\n', '            \n', '            collateralLocked = collateralLocked.add(locked);\n', '            collateralOnOpenPosition = collateralOnOpenPosition.add(openPosition);\n', '            collateralLockedRedeemable = collateralLockedRedeemable.add(lockedRedeemable);\n', '\t\t}\n', '\t\tif (!data.isDeposit) {\n', '\t\t\tcollateralOnOpenPosition = collateralOnOpenPosition.mul(PERCENTAGE_PRECISION.add(data.withdrawOpenPositionPenalty)).div(PERCENTAGE_PRECISION);\n', '\t\t}\n', '\t}\n', '\t\n', '\tfunction _getOpenPositionCollateralBalance(address acoToken, OpenPositionData memory data) internal view returns(\n', '        uint256 collateralLocked, \n', '        uint256 collateralOnOpenPosition,\n', '        uint256 collateralLockedRedeemable\n', '    ) {\n', '        AcoData memory acoData = _getOpenPositionCollateralExtraData(acoToken, data.acoFactory);\n', '        collateralLocked = _getCollateralAmount(acoData.tokenAmount, acoData.strikePrice, acoData.isCall, data.underlyingPrecision);\n', '        \n', '        if (acoData.expiryTime > block.timestamp) {\n', '    \t\t(uint256 price,) = _strategyQuote(data.strategy, data.underlyingPrice, data.baseVolatility, 0, 1, acoData);\n', '    \t\tif (data.fee > 0) {\n', '    \t\t    price = price.mul(PERCENTAGE_PRECISION.add(data.fee)).div(PERCENTAGE_PRECISION);\n', '    \t\t}\n', '    \t\tif (acoData.isCall) {\n', '    \t\t\tuint256 priceAdjusted = _getUnderlyingPriceAdjusted(data.underlyingPrice, data.underlyingPriceAdjustPercentage, false); \n', '    \t\t\tcollateralOnOpenPosition = price.mul(acoData.tokenAmount).div(priceAdjusted);\n', '    \t\t} else {\n', '    \t\t\tcollateralOnOpenPosition = price.mul(acoData.tokenAmount).div(data.underlyingPrecision);\n', '    \t\t}\n', '        } else {\n', '            collateralLockedRedeemable = collateralLocked;\n', '        }\n', '    }\n', '    \n', '\tfunction _acoStrikePriceIsValid(\n', '\t\tuint256 strikePrice, \n', '\t\tuint256 underlyingPrice,\n', '\t\tIACOPool2.PoolAcoPermissionConfig memory acoPermissionConfig\n', '\t) internal pure returns(bool) {\n', '\t    return (\n', '\t        (acoPermissionConfig.tolerancePriceBelowMin == 0 || strikePrice <= underlyingPrice.mul(PERCENTAGE_PRECISION.sub(acoPermissionConfig.tolerancePriceBelowMin)).div(PERCENTAGE_PRECISION))\n', '\t        && (acoPermissionConfig.tolerancePriceBelowMax == 0 || strikePrice >= underlyingPrice.mul(PERCENTAGE_PRECISION.sub(acoPermissionConfig.tolerancePriceBelowMax)).div(PERCENTAGE_PRECISION))\n', '\t        && (acoPermissionConfig.tolerancePriceAboveMin == 0 || strikePrice >= underlyingPrice.mul(PERCENTAGE_PRECISION.add(acoPermissionConfig.tolerancePriceAboveMin)).div(PERCENTAGE_PRECISION))\n', '\t        && (acoPermissionConfig.tolerancePriceAboveMax == 0 || strikePrice <= underlyingPrice.mul(PERCENTAGE_PRECISION.add(acoPermissionConfig.tolerancePriceAboveMax)).div(PERCENTAGE_PRECISION))\n', '        );\n', '\t}\n', '\n', '\tfunction _acoExpirationIsValid(uint256 acoExpiryTime, IACOPool2.PoolAcoPermissionConfig memory acoPermissionConfig) internal view returns(bool) {\n', '\t\treturn acoExpiryTime >= block.timestamp.add(acoPermissionConfig.minExpiration) && acoExpiryTime <= block.timestamp.add(acoPermissionConfig.maxExpiration);\n', '\t}\n', '    \n', '    function _getCollateralAmount(\n', '\t\tuint256 tokenAmount,\n', '\t\tuint256 strikePrice,\n', '\t\tbool isCall,\n', '\t\tuint256 underlyingPrecision\n', '\t) private pure returns(uint256) {\n', '        if (isCall) {\n', '            return tokenAmount;\n', '        } else if (tokenAmount > 0) {\n', '            return tokenAmount.mul(strikePrice).div(underlyingPrecision);\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '    \n', '    function _getOrderSizeData(\n', '        address lendingToken,\n', '        uint256 underlyingPrecision,\n', '        AcoData memory acoData\n', '    ) private view returns(\n', '        uint256 collateralAmount, \n', '        uint256 collateralAvailable\n', '    ) {\n', '        if (acoData.isCall) {\n', '            collateralAvailable = _getPoolBalanceOf(acoData.underlying);\n', '            collateralAmount = acoData.tokenAmount; \n', '        } else {\n', '            collateralAvailable = _getPoolBalanceOf(lendingToken);\n', '            collateralAmount = _getCollateralAmount(acoData.tokenAmount, acoData.strikePrice, acoData.isCall, underlyingPrecision);\n', '            require(collateralAmount > 0, "ACOPoolLib: The token amount is too small");\n', '        }\n', '        require(collateralAmount <= collateralAvailable, "ACOPoolLib: Insufficient liquidity");\n', '    }\n', '    \n', '\tfunction _strategyQuote(\n', '        address strategy,\n', '        uint256 underlyingPrice,\n', '\t\tuint256 baseVolatility,\n', '        uint256 collateralAmount,\n', '        uint256 collateralAvailable,\n', '        AcoData memory acoData\n', '    ) private view returns(uint256 swapPrice, uint256 volatility) {\n', '        (swapPrice, volatility) = IACOPoolStrategy(strategy).quote(IACOPoolStrategy.OptionQuote(\n', '\t\t\tunderlyingPrice,\n', '            acoData.underlying, \n', '            acoData.strikeAsset, \n', '            acoData.isCall, \n', '            acoData.strikePrice, \n', '            acoData.expiryTime, \n', '            baseVolatility, \n', '            collateralAmount, \n', '            collateralAvailable\n', '        ));\n', '    }\n', '    \n', '    function _setSwapPriceAndFee(\n', '        uint256 calcPrice, \n', '        uint256 tokenAmount, \n', '        uint256 fee,\n', '        uint256 underlyingPrecision\n', '    ) private pure returns(uint256 swapPrice, uint256 protocolFee) {\n', '        \n', '        swapPrice = calcPrice.mul(tokenAmount).div(underlyingPrecision);\n', '        \n', '        if (fee > 0) {\n', '            protocolFee = swapPrice.mul(fee).div(PERCENTAGE_PRECISION);\n', '\t\t\tswapPrice = swapPrice.add(protocolFee);\n', '        }\n', '        require(swapPrice > 0, "ACOPoolLib: Invalid quoted price");\n', '    }\n', '    \n', '    function _getOpenPositionCollateralExtraData(address acoToken, address acoFactory) private view returns(AcoData memory acoData) {\n', '        (address underlying, address strikeAsset, bool isCall, uint256 strikePrice, uint256 expiryTime) = IACOFactory(acoFactory).acoTokenData(acoToken);\n', '        uint256 tokenAmount = IACOToken(acoToken).currentCollateralizedTokens(address(this));\n', '        acoData = AcoData(isCall, strikePrice, expiryTime, tokenAmount, underlying, strikeAsset);\n', '    }\n', '    \n', '\tfunction _getUnderlyingPriceAdjusted(uint256 underlyingPrice, uint256 underlyingPriceAdjustPercentage, bool isMaximum) private pure returns(uint256) {\n', '\t\tif (isMaximum) {\n', '\t\t\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.add(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\n', '\t\t} else {\n', '\t\t\treturn underlyingPrice.mul(PERCENTAGE_PRECISION.sub(underlyingPriceAdjustPercentage)).div(PERCENTAGE_PRECISION);\n', '\t\t}\n', '    }\n', '    \n', '    function _getPoolBalanceOf(address asset) private view returns(uint256) {\n', '        if (asset == address(0)) {\n', '            return address(this).balance;\n', '        } else {\n', '            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x70a08231, address(this)));\n', '            require(success, "ACOPoolLib::_getAssetBalanceOf");\n', '            return abi.decode(returndata, (uint256));\n', '        }\n', '    }\n', '    \n', '    function _getAssetSymbol(address asset) private view returns(string memory) {\n', '        if (asset == address(0)) {\n', '            return "ETH";\n', '        } else {\n', '            (bool success, bytes memory returndata) = asset.staticcall(abi.encodeWithSelector(0x95d89b41));\n', '            require(success, "ACOPoolLib::_getAssetSymbol");\n', '            return abi.decode(returndata, (string));\n', '        }\n', '    }\n', '}']