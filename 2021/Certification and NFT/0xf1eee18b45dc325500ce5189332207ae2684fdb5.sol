['# \xa0@version ^0.2.12\n', 'from vyper.interfaces import ERC20\n', '\n', 'PRICE: constant(uint256) = 200 #\xa01 ETH is worth X\n', '\n', '\n', 'event CharityChange:\n', '    charity: indexed(address)\n', '    status: bool\n', '\n', '\n', 'event AdminChange:\n', '    admin: indexed(address)\n', '\n', '\n', 'event Purchase:\n', '    buyer: indexed(address)\n', '    liquidity: uint256\n', '    value: uint256\n', '\n', '\n', 'interface IUniswapRouter:\n', '    def addLiquidityETH(\n', '        token: address,\n', '        amountTokenDesired: uint256,\n', '        amountTokenMin: uint256,\n', '        amountETHMin: uint256,\n', '        to: address,\n', '        deadline: uint256,\n', '    ) -> (uint256, uint256, uint256):\n', '        payable\n', '\n', '\n', 'uniswap: public(IUniswapRouter)\n', 'saleToken: public(ERC20)\n', '\n', 'admin: public(address)\n', 'charity: public(HashMap[address, bool])\n', '\n', 'expires: public(uint256)\n', 'raised: public(uint256)\n', '\n', '\n', '@external\n', 'def __init__(_uniswap: address, _saleToken: address, _admin: address, _expires: uint256):\n', '    self.uniswap = IUniswapRouter(_uniswap)\n', '    self.saleToken = ERC20(_saleToken)\n', '    self.saleToken.approve(_uniswap, MAX_UINT256)\n', '    self.admin = _admin\n', '    self.expires = _expires\n', '\n', '\n', '@internal\n', '@view\n', 'def _estimate(_value: uint256) -> (uint256, uint256, uint256, uint256):\n', '    token: uint256 = _value * PRICE #\xa0(in token)\n', '    liquidity: uint256 = token / 5 #\xa020% of tokens (in token)\n', '    charity: uint256 = _value / 3 #\xa0(in ETH)\n', '    founder: uint256 = _value - (charity + _value / 2) #\xa0(in ETH)\n', '    return (token, liquidity, charity, founder)\n', '\n', '\n', '@external\n', 'def updateCharity(_charity: address, status: bool):\n', '    """\n', '    @notice\n', '        Update charity status\n', '    @param _charity\n', '        Charity to update\n', '    @param status\n', '        True if charity can be donated\n', '    """\n', '    assert msg.sender == self.admin\n', '    self.charity[_charity] = status\n', '    log CharityChange(_charity, status)\n', '\n', '\n', '@external\n', 'def updateAdmin(_to: address):\n', '    """\n', '    @notice\n', '        Change admin\n', '    @param _to\n', '        Address of new admin\n', '    """\n', '    assert msg.sender == self.admin\n', '    self.admin = _to\n', '    log AdminChange(_to)\n', '\n', '\n', '@external\n', 'def recover(token: address):\n', '    assert msg.sender == self.admin\n', '    assert block.timestamp > self.expires + 86400 * 180\n', '    assert token != self.saleToken.address, "Sale: Cannot recover sale tokens"\n', '    ERC20(token).transfer(msg.sender, ERC20(token).balanceOf(self))\n', '\n', '\n', '@external\n', '@payable\n', 'def purchase(_min: uint256, _charity: address) -> uint256:\n', '    """\n', '    @notice\n', '        Purchase tokens through sale\n', '    @param _min\n', '        Minimum output for saleToken\n', '    @param _charity\n', '        Address of charity to donate\n', '    @return\n', '        Amount sent in saleToken\n', '    """\n', '    assert self.charity[_charity], "Sale: Unknown charity"\n', '    assert self.expires > block.timestamp, "Sale: Sale expired"\n', '    self.raised += msg.value\n', '    token: uint256 = 0\n', '    liquidity: uint256 = 0\n', '    charity: uint256 = 0\n', '    founder: uint256 = 0\n', '    (token, liquidity, charity, founder) = self._estimate(msg.value)\n', '    if liquidity > 0:\n', '        #\xa0Remaining from liquidity and value\n', '        #\xa0will be refunded to the contract and\n', '        #\xa0admin will receive these tokens.\n', '        self.uniswap.addLiquidityETH(\n', '            self.saleToken.address,\n', '            liquidity,\n', '            0,\n', '            0,\n', '            self,\n', '            block.timestamp,\n', '            value=msg.value/2,\n', '        )\n', '    token = min(token, self.saleToken.balanceOf(self))\n', '    assert token >= _min, "Sale: Token amount below user set minimum"\n', '    self.saleToken.transfer(msg.sender, token)\n', '    send(_charity, min(charity, self.balance))\n', '    send(self.admin, self.balance)\n', '    log Purchase(msg.sender, liquidity, token)\n', '    return token\n', '\n', '\n', '@external\n', 'def burn():\n', '    """\n', '    @notice\n', '        Burn tokens\n', '    @dev\n', '        Only after sale is expired\n', '    """\n', '    assert block.timestamp > self.expires\n', '    self.saleToken.transfer(ZERO_ADDRESS, self.saleToken.balanceOf(self))\n', '\n', '\n', '@external\n', '@view\n', 'def estimate(_value: uint256) -> (uint256, uint256, uint256, uint256):\n', '    """\n', '    @notice\n', '        Estimate tokens to receive for specific value\n', '    @param _value\n', '        Amount in ETH to purchase tokens\n', '    @return\n', '        Amount in sale token to receive\n', '        Amount in ETH for liquidity\n', '        Amount in ETH for charity\n', '        Amount in ETH for founders\n', '    """\n', '    return self._estimate(_value)']