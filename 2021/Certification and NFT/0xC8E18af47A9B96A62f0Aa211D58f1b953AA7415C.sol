['// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', 'pragma solidity ^0.8.3;\n', '\n', 'interface IAuthoriser {\n', '    function isAuthorised(address _sender, address _spender, address _to, bytes calldata _data) external view returns (bool);\n', '    function areAuthorised(\n', '        address _spender,\n', '        address[] calldata _spenders,\n', '        address[] calldata _to,\n', '        bytes[] calldata _data\n', '    )\n', '        external\n', '        view\n', '        returns (bool);\n', '}\n', '\n', '// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', 'pragma solidity ^0.8.3;\n', '\n', 'import "./IFilter.sol";\n', '\n', 'abstract contract BaseFilter is IFilter {\n', '    function getMethod(bytes memory _data) internal pure returns (bytes4 method) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            method := mload(add(_data, 0x20))\n', '        }\n', '    }\n', '}\n', '\n', '// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', 'pragma solidity ^0.8.3;\n', '\n', 'interface IFilter {\n', '    function isValid(address _wallet, address _spender, address _to, bytes calldata _data) external view returns (bool valid);\n', '}\n', '\n', '// Copyright (C) 2021  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', 'pragma solidity ^0.8.3;\n', '\n', 'import "./BaseFilter.sol";\n', 'import "../IAuthoriser.sol";\n', 'import "../../modules/common/Utils.sol";\n', '\n', 'interface IUniswapV1Factory {\n', '    function getExchange(address token) external view returns (address);\n', '}\n', '\n', 'interface IParaswapUniswapProxy {\n', '    function UNISWAP_FACTORY() external view returns (address);\n', '    function UNISWAP_INIT_CODE() external view returns (bytes32);\n', '    function WETH() external view returns (address);\n', '}\n', '\n', 'interface IParaswap {\n', '    struct Route {\n', '        address payable exchange;\n', '        address targetExchange;\n', '        uint256 percent;\n', '        bytes payload;\n', '        uint256 networkFee;\n', '    }\n', '\n', '    struct Path {\n', '        address to;\n', '        uint256 totalNetworkFee;\n', '        Route[] routes;\n', '    }\n', '\n', '    struct SellData {\n', '        address fromToken;\n', '        uint256 fromAmount;\n', '        uint256 toAmount;\n', '        uint256 expectedAmount;\n', '        address payable beneficiary;\n', '        string referrer;\n', '        bool useReduxToken;\n', '        Path[] path;\n', '    }\n', '\n', '    struct MegaSwapPath {\n', '        uint256 fromAmountPercent;\n', '        Path[] path;\n', '    }\n', '\n', '    struct MegaSwapSellData {\n', '        address fromToken;\n', '        uint256 fromAmount;\n', '        uint256 toAmount;\n', '        uint256 expectedAmount;\n', '        address payable beneficiary;\n', '        string referrer;\n', '        bool useReduxToken;\n', '        MegaSwapPath[] path;\n', '    }\n', '\n', '    struct UniswapV2Data {\n', '        address[] path;\n', '    }\n', '\n', '    struct ZeroExV2Order {\n', '        address makerAddress;\n', '        address takerAddress;\n', '        address feeRecipientAddress;\n', '        address senderAddress;\n', '        uint256 makerAssetAmount;\n', '        uint256 takerAssetAmount;\n', '        uint256 makerFee;\n', '        uint256 takerFee;\n', '        uint256 expirationTimeSeconds;\n', '        uint256 salt;\n', '        bytes makerAssetData;\n', '        bytes takerAssetData;\n', '    }\n', '\n', '    struct ZeroExV2Data {\n', '        ZeroExV2Order[] orders;\n', '        bytes[] signatures;\n', '    }\n', '\n', '    struct ZeroExV4Order {\n', '        address makerToken;\n', '        address takerToken;\n', '        uint128 makerAmount;\n', '        uint128 takerAmount;\n', '        address maker;\n', '        address taker;\n', '        address txOrigin;\n', '        bytes32 pool;\n', '        uint64 expiry;\n', '        uint256 salt;\n', '    }\n', '\n', '    enum ZeroExV4SignatureType {\n', '        ILLEGAL,\n', '        INVALID,\n', '        EIP712,\n', '        ETHSIGN\n', '    }\n', '\n', '    struct ZeroExV4Signature {\n', '        ZeroExV4SignatureType signatureType;\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '    }\n', '\n', '    struct ZeroExV4Data {\n', '        ZeroExV4Order order;\n', '        ZeroExV4Signature signature;\n', '    }\n', '\n', '    function getUniswapProxy() external view returns (address);\n', '}\n', '\n', 'contract ParaswapFilter is BaseFilter {\n', '\n', '    bytes4 constant internal MULTISWAP = bytes4(keccak256(\n', '        "multiSwap((address,uint256,uint256,uint256,address,string,bool,(address,uint256,(address,address,uint256,bytes,uint256)[])[]))"\n', '    ));\n', '    bytes4 constant internal SIMPLESWAP = bytes4(keccak256(\n', '        "simpleSwap(address,address,uint256,uint256,uint256,address[],bytes,uint256[],uint256[],address,string,bool)"\n', '    ));\n', '    bytes4 constant internal SWAP_ON_UNI = bytes4(keccak256(\n', '        "swapOnUniswap(uint256,uint256,address[],uint8)"\n', '    ));\n', '    bytes4 constant internal SWAP_ON_UNI_FORK = bytes4(keccak256(\n', '        "swapOnUniswapFork(address,bytes32,uint256,uint256,address[],uint8)"\n', '    ));\n', '    bytes4 constant internal MEGASWAP = bytes4(keccak256(\n', '        "megaSwap((address,uint256,uint256,uint256,address,string,bool,(uint256,(address,uint256,(address,address,uint256,bytes,uint256)[])[])[]))"\n', '    ));\n', '\n', '    address constant internal ETH_TOKEN = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '\n', '    // The token price registry\n', '    address public immutable tokenRegistry;\n', '    // Paraswap entrypoint\n', '    address public immutable augustus;\n', '    // Supported Paraswap targetExchanges\n', '    mapping(address => bool) public targetExchanges;\n', '    // Supported ParaswapPool market makers\n', '    mapping(address => bool) public marketMakers;\n', '    // The supported adapters\n', '    address public immutable uniV1Adapter;\n', '    address public immutable uniV2Adapter;\n', '    address public immutable sushiswapAdapter;\n', '    address public immutable linkswapAdapter;\n', '    address public immutable defiswapAdapter;\n', '    address public immutable zeroExV2Adapter;\n', '    address public immutable zeroExV4Adapter;\n', '    // The Dapp registry (used to authorise simpleSwap())\n', '    IAuthoriser public immutable authoriser;\n', "    // Uniswap Proxy used by Paraswap's AugustusSwapper contract\n", '    address public immutable uniswapProxy;\n', '    // Whether the uniswap proxy has been changed -> needs manual update\n', '    bool public isValidUniswapProxy = true;\n', '    // WETH address\n', '    address public immutable weth;\n', '\n', '    // Supported Uniswap Fork (factory, initcode) couples.\n', '    // Note that a `mapping(address => bytes32) public supportedInitCodes;` would be cleaner\n', '    // but would cost one storage read to authorise each uni fork swap.\n', '    address public immutable uniFactory; // uniswap\n', '    address public immutable uniForkFactory1; // sushiswap\n', '    address public immutable uniForkFactory2; // linkswap\n', '    address public immutable uniForkFactory3; // defiswap\n', '    bytes32 public immutable uniInitCode; // uniswap\n', '    bytes32 public immutable uniForkInitCode1; // sushiswap\n', '    bytes32 public immutable uniForkInitCode2; // linkswap\n', '    bytes32 public immutable uniForkInitCode3; // defiswap\n', '\n', '    constructor(\n', '        address _tokenRegistry,\n', '        IAuthoriser _authoriser,\n', '        address _augustus,\n', '        address _uniswapProxy,\n', '        address[3] memory _uniFactories,\n', '        bytes32[3] memory _uniInitCodes,\n', '        address[7] memory _adapters,\n', '        address[] memory _targetExchanges,\n', '        address[] memory _marketMakers\n', '    ) {\n', '        tokenRegistry = _tokenRegistry;\n', '        authoriser = _authoriser;\n', '        augustus = _augustus;\n', '        uniswapProxy = _uniswapProxy;\n', '        weth = IParaswapUniswapProxy(_uniswapProxy).WETH();\n', '        uniFactory = IParaswapUniswapProxy(_uniswapProxy).UNISWAP_FACTORY();\n', '        uniInitCode = IParaswapUniswapProxy(_uniswapProxy).UNISWAP_INIT_CODE();\n', '        uniForkFactory1 = _uniFactories[0];\n', '        uniForkFactory2 = _uniFactories[1];\n', '        uniForkFactory3 = _uniFactories[2];\n', '        uniForkInitCode1 = _uniInitCodes[0];\n', '        uniForkInitCode2 = _uniInitCodes[1];\n', '        uniForkInitCode3 = _uniInitCodes[2];\n', '        uniV1Adapter = _adapters[0];\n', '        uniV2Adapter = _adapters[1];\n', '        sushiswapAdapter = _adapters[2];\n', '        linkswapAdapter = _adapters[3];\n', '        defiswapAdapter = _adapters[4];\n', '        zeroExV2Adapter = _adapters[5];\n', '        zeroExV4Adapter = _adapters[6];\n', '        for(uint i = 0; i < _targetExchanges.length; i++) {\n', '            targetExchanges[_targetExchanges[i]] = true;\n', '        }\n', '        for(uint i = 0; i < _marketMakers.length; i++) {\n', '            marketMakers[_marketMakers[i]] = true;\n', '        }\n', '    }\n', '\n', '    function updateIsValidUniswapProxy() external {\n', '        isValidUniswapProxy = (uniswapProxy == IParaswap(augustus).getUniswapProxy());\n', '    }\n', '\n', '    function isValid(address _wallet, address /*_spender*/, address _to, bytes calldata _data) external view override returns (bool valid) {\n', '        // disable ETH transfer & unsupported Paraswap entrypoints\n', '        if (_data.length < 4 || _to != augustus) {\n', '            return false;\n', '        }\n', '        bytes4 methodId = getMethod(_data);\n', '        if(methodId == MULTISWAP) {\n', '            return isValidMultiSwap(_wallet, _data);\n', '        } \n', '        if(methodId == SIMPLESWAP) {\n', '            return isValidSimpleSwap(_wallet, _to, _data);\n', '        }\n', '        if(methodId == SWAP_ON_UNI) {\n', '            return isValidUniSwap(_data);\n', '        }\n', '        if(methodId == SWAP_ON_UNI_FORK) {\n', '            return isValidUniForkSwap(_data);\n', '        }\n', '        if(methodId == MEGASWAP) {\n', '            return isValidMegaSwap(_wallet, _data);\n', '        }\n', '        return false;\n', '    }\n', '\n', '    function isValidMultiSwap(address _wallet, bytes calldata _data) internal view returns (bool) {\n', '        (IParaswap.SellData memory sell) = abi.decode(_data[4:], (IParaswap.SellData));\n', '        return hasValidBeneficiary(_wallet, sell.beneficiary) && hasValidPath(sell.fromToken, sell.path);\n', '    }\n', '\n', '    function isValidSimpleSwap(address _wallet, address _augustus, bytes calldata _data) internal view returns (bool) {\n', '        (,address toToken,, address[] memory callees,, uint256[] memory startIndexes,, address beneficiary) \n', '            = abi.decode(_data[4:], (address, address, uint256[3],address[],bytes,uint256[],uint256[],address));\n', '        return hasValidBeneficiary(_wallet, beneficiary) &&\n', '            hasTradableToken(toToken) &&\n', '            hasAuthorisedCallees(_augustus, callees, startIndexes, _data);\n', '    }\n', '\n', '    function isValidUniSwap(bytes calldata _data) internal view returns (bool) {\n', '        if(!isValidUniswapProxy) {\n', '            return false;\n', '        }\n', '        (, address[] memory path) = abi.decode(_data[4:], (uint256[2], address[]));\n', '        return hasValidUniV2Path(path, uniFactory, uniInitCode);\n', '    }\n', '\n', '    function isValidUniForkSwap(bytes calldata _data) internal view returns (bool) {\n', '        if(!isValidUniswapProxy) {\n', '            return false;\n', '        }\n', '        (address factory, bytes32 initCode,, address[] memory path) = abi.decode(_data[4:], (address, bytes32, uint256[2], address[]));\n', '        return factory != address(0) && initCode != bytes32(0) && (\n', '            (factory == uniForkFactory1 && initCode == uniForkInitCode1 && hasValidUniV2Path(path, uniForkFactory1, uniForkInitCode1)) ||\n', '            (factory == uniForkFactory2 && initCode == uniForkInitCode2 && hasValidUniV2Path(path, uniForkFactory2, uniForkInitCode2)) ||\n', '            (factory == uniForkFactory3 && initCode == uniForkInitCode3 && hasValidUniV2Path(path, uniForkFactory3, uniForkInitCode3))\n', '        );\n', '    }\n', '\n', '    function isValidMegaSwap(address _wallet, bytes calldata _data) internal view returns (bool) {\n', '        (IParaswap.MegaSwapSellData memory sell) = abi.decode(_data[4:], (IParaswap.MegaSwapSellData));\n', '        return hasValidBeneficiary(_wallet, sell.beneficiary) && hasValidMegaPath(sell.fromToken, sell.path);\n', '    }\n', '\n', '    function hasAuthorisedCallees(\n', '        address _augustus,\n', '        address[] memory _callees,\n', '        uint256[] memory _startIndexes,\n', '        bytes calldata _data\n', '    )\n', '        internal\n', '        view\n', '        returns (bool)\n', '    {\n', '        // _data = {sig:4}{six params:192}{exchangeDataOffset:32}{...}\n', '        // we add 4+32=36 to the offset to skip the method sig and the size of the exchangeData array\n', '        uint256 exchangeDataOffset = 36 + abi.decode(_data[196:228], (uint256)); \n', '        address[] memory spenders = new address[](_callees.length);\n', '        bytes[] memory allData = new bytes[](_callees.length);\n', '        for(uint256 i = 0; i < _callees.length; i++) {\n', '            bytes calldata slicedExchangeData = _data[exchangeDataOffset+_startIndexes[i] : exchangeDataOffset+_startIndexes[i+1]];\n', '            allData[i] = slicedExchangeData;\n', '            spenders[i] = Utils.recoverSpender(_callees[i], slicedExchangeData);\n', '        }\n', '        return authoriser.areAuthorised(_augustus, spenders, _callees, allData);\n', '    }\n', '\n', '    function hasValidBeneficiary(address _wallet, address _beneficiary) internal pure returns (bool) {\n', '        return (_beneficiary == address(0) || _beneficiary == _wallet);\n', '    }\n', '\n', '    function hasValidUniV2Path(address[] memory _path, address _factory, bytes32 _initCode) internal view returns (bool) {\n', '        address[] memory lpTokens = new address[](_path.length - 1);\n', '        for(uint i = 0; i < lpTokens.length; i++) {\n', '            lpTokens[i] = pairFor(_path[i], _path[i+1], _factory, _initCode);\n', '        }\n', '        return hasTradableTokens(lpTokens);\n', '    }\n', '\n', '    function pairFor(address _tokenA, address _tokenB, address _factory, bytes32 _initCode) internal view returns (address) {\n', '        (address tokenA, address tokenB) = (_tokenA == ETH_TOKEN ? weth : _tokenA, _tokenB == ETH_TOKEN ? weth : _tokenB);\n', '        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', '        return(address(uint160(uint(keccak256(abi.encodePacked(\n', '            hex"ff",\n', '            _factory,\n', '            keccak256(abi.encodePacked(token0, token1)),\n', '            _initCode\n', '        ))))));\n', '    }\n', '\n', '    function hasTradableToken(address _destToken) internal view returns (bool) {\n', '        if(_destToken == ETH_TOKEN) {\n', '            return true;\n', '        }\n', '        (bool success, bytes memory res) = tokenRegistry.staticcall(abi.encodeWithSignature("isTokenTradable(address)", _destToken));\n', '        return success && abi.decode(res, (bool));\n', '    }\n', '\n', '    function hasTradableTokens(address[] memory _tokens) internal view returns (bool) {\n', '        (bool success, bytes memory res) = tokenRegistry.staticcall(abi.encodeWithSignature("areTokensTradable(address[])", _tokens));\n', '        return success && abi.decode(res, (bool));\n', '    }\n', '\n', '    function hasValidPath(address _fromToken, IParaswap.Path[] memory _path) internal view returns (bool) {\n', '        for (uint i = 0; i < _path.length; i++) {\n', '            for (uint j = 0; j < _path[i].routes.length; j++) {\n', '                if(!hasValidRoute(_path[i].routes[j], (i == 0) ? _fromToken : _path[i-1].to, _path[i].to)) {\n', '                    return false;\n', '                }\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function hasValidRoute(IParaswap.Route memory _route, address _fromToken, address _toToken) internal view returns (bool) {\n', '        if(_route.targetExchange != address(0) && !targetExchanges[_route.targetExchange]) {\n', '            return false;\n', '        }\n', '        if(_route.exchange == uniV2Adapter) { \n', '            return hasValidUniV2Route(_route.payload, uniFactory, uniInitCode);\n', '        } \n', '        if(_route.exchange == sushiswapAdapter) { \n', '            return hasValidUniV2Route(_route.payload, uniForkFactory1, uniForkInitCode1);\n', '        }\n', '        if(_route.exchange == zeroExV4Adapter) { \n', '            return hasValidZeroExV4Route(_route.payload);\n', '        }\n', '        if(_route.exchange == zeroExV2Adapter) { \n', '            return hasValidZeroExV2Route(_route.payload);\n', '        }\n', '        if(_route.exchange == linkswapAdapter) { \n', '            return hasValidUniV2Route(_route.payload, uniForkFactory2, uniForkInitCode2);\n', '        }\n', '        if(_route.exchange == defiswapAdapter) { \n', '            return hasValidUniV2Route(_route.payload, uniForkFactory3, uniForkInitCode3);\n', '        }\n', '        if(_route.exchange == uniV1Adapter) { \n', '            return hasValidUniV1Route(_route.targetExchange, _fromToken, _toToken);\n', '        }\n', '        return false;  \n', '    }\n', '\n', '    function hasValidUniV2Route(bytes memory _payload, address _factory, bytes32 _initCode) internal view returns (bool) {\n', '        IParaswap.UniswapV2Data memory data = abi.decode(_payload, (IParaswap.UniswapV2Data));\n', '        return hasValidUniV2Path(data.path, _factory, _initCode);\n', '    }\n', '\n', '    function hasValidUniV1Route(address _uniV1Factory, address _fromToken, address _toToken) internal view returns (bool) {\n', '        address pool = IUniswapV1Factory(_uniV1Factory).getExchange(_fromToken == ETH_TOKEN ? _toToken : _fromToken);\n', '        return hasTradableToken(pool);\n', '    }\n', '\n', '    function hasValidZeroExV4Route(bytes memory _payload) internal view returns (bool) {\n', '        IParaswap.ZeroExV4Data memory data = abi.decode(_payload, (IParaswap.ZeroExV4Data));\n', '        return marketMakers[data.order.maker];\n', '    }\n', '\n', '    function hasValidZeroExV2Route(bytes memory _payload) internal view returns (bool) {\n', '        IParaswap.ZeroExV2Data memory data = abi.decode(_payload, (IParaswap.ZeroExV2Data));\n', '        for(uint i = 0; i < data.orders.length; i++) {\n', '            if(!marketMakers[data.orders[i].makerAddress]) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function hasValidMegaPath(address _fromToken, IParaswap.MegaSwapPath[] memory _megaPath) internal view returns (bool) {\n', '        for(uint i = 0; i < _megaPath.length; i++) {\n', '            if(!hasValidPath(_fromToken, _megaPath[i].path)) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '}\n', '\n', '// Copyright (C) 2020  Argent Labs Ltd. <https://argent.xyz>\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '// SPDX-License-Identifier: GPL-3.0-only\n', 'pragma solidity ^0.8.3;\n', '\n', '/**\n', ' * @title Utils\n', ' * @notice Common utility methods used by modules.\n', ' */\n', 'library Utils {\n', '\n', '    // ERC20, ERC721 & ERC1155 transfers & approvals\n', '    bytes4 private constant ERC20_TRANSFER = bytes4(keccak256("transfer(address,uint256)"));\n', '    bytes4 private constant ERC20_APPROVE = bytes4(keccak256("approve(address,uint256)"));\n', '    bytes4 private constant ERC721_SET_APPROVAL_FOR_ALL = bytes4(keccak256("setApprovalForAll(address,bool)"));\n', '    bytes4 private constant ERC721_TRANSFER_FROM = bytes4(keccak256("transferFrom(address,address,uint256)"));\n', '    bytes4 private constant ERC721_SAFE_TRANSFER_FROM = bytes4(keccak256("safeTransferFrom(address,address,uint256)"));\n', '    bytes4 private constant ERC721_SAFE_TRANSFER_FROM_BYTES = bytes4(keccak256("safeTransferFrom(address,address,uint256,bytes)"));\n', '    bytes4 private constant ERC1155_SAFE_TRANSFER_FROM = bytes4(keccak256("safeTransferFrom(address,address,uint256,uint256,bytes)"));\n', '\n', '    bytes4 private constant OWNER_SIG = 0x8da5cb5b;\n', '    /**\n', '    * @notice Helper method to recover the signer at a given position from a list of concatenated signatures.\n', '    * @param _signedHash The signed hash\n', '    * @param _signatures The concatenated signatures.\n', '    * @param _index The index of the signature to recover.\n', '    */\n', '    function recoverSigner(bytes32 _signedHash, bytes memory _signatures, uint _index) internal pure returns (address) {\n', '        uint8 v;\n', '        bytes32 r;\n', '        bytes32 s;\n', '        // we jump 32 (0x20) as the first slot of bytes contains the length\n', '        // we jump 65 (0x41) per signature\n', '        // for v we load 32 bytes ending with v (the first 31 come from s) then apply a mask\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            r := mload(add(_signatures, add(0x20,mul(0x41,_index))))\n', '            s := mload(add(_signatures, add(0x40,mul(0x41,_index))))\n', '            v := and(mload(add(_signatures, add(0x41,mul(0x41,_index)))), 0xff)\n', '        }\n', '        require(v == 27 || v == 28, "Utils: bad v value in signature");\n', '\n', '        address recoveredAddress = ecrecover(_signedHash, v, r, s);\n', '        require(recoveredAddress != address(0), "Utils: ecrecover returned 0");\n', '        return recoveredAddress;\n', '    }\n', '\n', '    /**\n', '    * @notice Helper method to recover the spender from a contract call. \n', '    * The method returns the contract unless the call is to a standard method of a ERC20/ERC721/ERC1155 token\n', '    * in which case the spender is recovered from the data.\n', '    * @param _to The target contract.\n', '    * @param _data The data payload.\n', '    */\n', '    function recoverSpender(address _to, bytes memory _data) internal pure returns (address spender) {\n', '        if(_data.length >= 68) {\n', '            bytes4 methodId;\n', '            // solhint-disable-next-line no-inline-assembly\n', '            assembly {\n', '                methodId := mload(add(_data, 0x20))\n', '            }\n', '            if(\n', '                methodId == ERC20_TRANSFER ||\n', '                methodId == ERC20_APPROVE ||\n', '                methodId == ERC721_SET_APPROVAL_FOR_ALL) \n', '            {\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    spender := mload(add(_data, 0x24))\n', '                }\n', '                return spender;\n', '            }\n', '            if(\n', '                methodId == ERC721_TRANSFER_FROM ||\n', '                methodId == ERC721_SAFE_TRANSFER_FROM ||\n', '                methodId == ERC721_SAFE_TRANSFER_FROM_BYTES ||\n', '                methodId == ERC1155_SAFE_TRANSFER_FROM)\n', '            {\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    spender := mload(add(_data, 0x44))\n', '                }\n', '                return spender;\n', '            }\n', '        }\n', '\n', '        spender = _to;\n', '    }\n', '\n', '    /**\n', '    * @notice Helper method to parse data and extract the method signature.\n', '    */\n', '    function functionPrefix(bytes memory _data) internal pure returns (bytes4 prefix) {\n', '        require(_data.length >= 4, "Utils: Invalid functionPrefix");\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            prefix := mload(add(_data, 0x20))\n', '        }\n', '    }\n', '\n', '    /**\n', '    * @notice Checks if an address is a contract.\n', '    * @param _addr The address.\n', '    */\n', '    function isContract(address _addr) internal view returns (bool) {\n', '        uint32 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            size := extcodesize(_addr)\n', '        }\n', '        return (size > 0);\n', '    }\n', '\n', '    /**\n', '    * @notice Checks if an address is a guardian or an account authorised to sign on behalf of a smart-contract guardian\n', '    * given a list of guardians.\n', '    * @param _guardians the list of guardians\n', '    * @param _guardian the address to test\n', '    * @return true and the list of guardians minus the found guardian upon success, false and the original list of guardians if not found.\n', '    */\n', '    function isGuardianOrGuardianSigner(address[] memory _guardians, address _guardian) internal view returns (bool, address[] memory) {\n', '        if (_guardians.length == 0 || _guardian == address(0)) {\n', '            return (false, _guardians);\n', '        }\n', '        bool isFound = false;\n', '        address[] memory updatedGuardians = new address[](_guardians.length - 1);\n', '        uint256 index = 0;\n', '        for (uint256 i = 0; i < _guardians.length; i++) {\n', '            if (!isFound) {\n', '                // check if _guardian is an account guardian\n', '                if (_guardian == _guardians[i]) {\n', '                    isFound = true;\n', '                    continue;\n', '                }\n', '                // check if _guardian is the owner of a smart contract guardian\n', '                if (isContract(_guardians[i]) && isGuardianOwner(_guardians[i], _guardian)) {\n', '                    isFound = true;\n', '                    continue;\n', '                }\n', '            }\n', '            if (index < updatedGuardians.length) {\n', '                updatedGuardians[index] = _guardians[i];\n', '                index++;\n', '            }\n', '        }\n', '        return isFound ? (true, updatedGuardians) : (false, _guardians);\n', '    }\n', '\n', '    /**\n', '    * @notice Checks if an address is the owner of a guardian contract.\n', '    * The method does not revert if the call to the owner() method consumes more then 25000 gas.\n', '    * @param _guardian The guardian contract\n', '    * @param _owner The owner to verify.\n', '    */\n', '    function isGuardianOwner(address _guardian, address _owner) internal view returns (bool) {\n', '        address owner = address(0);\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr,OWNER_SIG)\n', '            let result := staticcall(25000, _guardian, ptr, 0x20, ptr, 0x20)\n', '            if eq(result, 1) {\n', '                owner := mload(ptr)\n', '            }\n', '        }\n', '        return owner == _owner;\n', '    }\n', '\n', '    /**\n', '    * @notice Returns ceil(a / b).\n', '    */\n', '    function ceil(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a / b;\n', '        if (a % b == 0) {\n', '            return c;\n', '        } else {\n', '            return c + 1;\n', '        }\n', '    }\n', '}\n', '\n', '{\n', '  "remappings": [],\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 999\n', '  },\n', '  "evmVersion": "istanbul",\n', '  "libraries": {\n', '    "": {}\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']