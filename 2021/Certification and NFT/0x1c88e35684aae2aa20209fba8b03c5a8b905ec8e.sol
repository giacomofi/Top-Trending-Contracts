['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-06\n', '*/\n', '\n', '// File: contracts/Utils/SafeMath.sol\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: contracts/Gov/GovCoordinator.sol\n', '\n', 'contract GovCoordinator {\n', '    using SafeMath for uint256;\n', "    /// @notice The EIP-712 typehash for the contract's domain\n", '    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n', '    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n', '    bytes32 public constant BALLOT_TYPEHASH = keccak256("Ballot(uint256 proposalId,bool support)");\n', '    /// @notice The name of this contract\n', '    string public constant name = "Governance Coordinator";\n', '    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n', '    uint256 public quorumVotes;\n', '    /// @notice The number of votes required in order for a voter to become a proposer\n', '    uint256 public proposalThreshold;\n', '    /// @notice The duration of voting on a proposal, in blocks\n', '    uint256 public votingPeriod;\n', '    /// @notice The address of the Voice token\n', '    IVoiceContract public voice;\n', '    /// @notice The total number of proposals\n', '    uint256 public proposalCount;\n', '\n', '    struct Proposal {\n', '        /// @notice Unique id for looking up a proposal\n', '        uint256 id;\n', '        /// @notice Creator of the proposal\n', '        address proposer;\n', '        /// @notice The target to execute the proposal data\n', '        address target;\n', '        /// @notice The ordered list of calldata to be passed to each call\n', '        bytes data;\n', '        /// @notice The block at which voting begins: holders must delegate their votes prior to this block\n', '        uint256 startBlock;\n', '        /// @notice The block at which voting ends: votes must be cast prior to this block\n', '        uint256 endBlock;\n', '        /// @notice Current number of votes in favor of this proposal\n', '        uint256 forVotes;\n', '        /// @notice Current number of votes in opposition to this proposal\n', '        uint256 againstVotes;\n', '        /// @notice Flag marking whether the proposal has been executed\n', '        bool executed;\n', '        /// @notice Receipts of ballots for the entire set of voters\n', '        mapping (address => Receipt) receipts;\n', '    }\n', '    /// @notice Ballot receipt record for a voter\n', '    struct Receipt {\n', '        /// @notice Whether or not a vote has been cast\n', '        bool hasVoted;\n', '        /// @notice Whether or not the voter supports the proposal\n', '        bool support;\n', '        /// @notice The number of votes the voter had, which were cast\n', '        uint96 votes;\n', '    }\n', '    /// @notice Possible states that a proposal may be in\n', '    enum ProposalState {\n', '        Pending,\n', '        Active,\n', '        Defeated,\n', '        Succeeded,\n', '        Expired,\n', '        Executed\n', '    }\n', '\n', '    /// @notice The official record of all proposals ever proposed\n', '    mapping (uint256 => Proposal) public proposals;\n', '    /// @notice The latest proposal for each proposer\n', '    mapping (address => uint) public latestProposalIds;\n', '\n', '    /// @notice An event emitted when a new proposal is created\n', '    event ProposalCreated(uint256 id, address proposer, address target, bytes data, uint256 startBlock, uint256 endBlock, string description);\n', '    /// @notice An event emitted when a vote has been cast on a proposal\n', '    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n', '    /// @notice An event emitted when a proposal has been executed in the Timelock\n', '    event ProposalExecuted(uint256 id);\n', '\n', '    event ChangeQuorumVotes(uint256 _quorumVotes);\n', '    event ChangeProposalThreshold(uint256 _proposalThreshold);\n', '    event ChangeVotingPeriod(uint256 _votingPeriod);\n', '\n', '    constructor(address _voice, uint256 _votingPeriod) public {\n', '        quorumVotes = 4000e18; //  (~10% of circ)\n', '        proposalThreshold = 500e18; // 500 voice\n', '        votingPeriod = _votingPeriod; //17280; // ~3 days in blocks (assuming 15s blocks)\n', '\n', '        voice = IVoiceContract(_voice);\n', '    }\n', '\n', '    // should only be called by itself through a proposal\n', '    function changeQuorumVotes(uint256 _quorumVotes) public {\n', '        require(msg.sender == address(this), "GovCoordinator::changeQuorumVotes: caller is not this contract");\n', '        quorumVotes = _quorumVotes;\n', '        emit ChangeQuorumVotes(_quorumVotes);\n', '    }\n', '\n', '    // should only be called by itself through a proposal\n', '    function changeProposalThreshold(uint256 _proposalThreshold) public {\n', '        require(msg.sender == address(this), "GovCoordinator::changeProposalThreshold: caller is not this contract");\n', '        proposalThreshold = _proposalThreshold;\n', '        emit ChangeProposalThreshold(_proposalThreshold);\n', '    }\n', '\n', '    // should only be called by itself through a proposal\n', '    function changeVotingPeriod(uint256 _votingPeriod) public {\n', '        require(msg.sender == address(this), "GovCoordinator::changeVotingPeriod: caller is not this contract");\n', '        votingPeriod = _votingPeriod;\n', '        emit ChangeVotingPeriod(_votingPeriod);\n', '    }\n', '\n', '    function propose(address target, bytes memory data, string memory description) public returns (uint) {\n', '        require(voice.getPriorVotes(msg.sender, block.number.sub(1)) > proposalThreshold, "GovCoordinator::propose: proposer votes below proposal threshold");\n', '\n', '        uint256 latestProposalId = latestProposalIds[msg.sender];\n', '        if (latestProposalId != 0) {\n', '          ProposalState proposersLatestProposalState = state(latestProposalId);\n', '          require(proposersLatestProposalState != ProposalState.Active, "GovCoordinator::propose: one live proposal per proposer, found an already active proposal");\n', '          require(proposersLatestProposalState != ProposalState.Pending, "GovCoordinator::propose: one live proposal per proposer, found an already pending proposal");\n', '        }\n', '\n', '        uint256 startBlock = block.number.add(1);\n', '        uint256 endBlock = startBlock.add(votingPeriod);\n', '\n', '        proposalCount++;\n', '        Proposal memory newProposal = Proposal({\n', '            id: proposalCount,\n', '            proposer: msg.sender,\n', '            target: target,\n', '            data: data,\n', '            startBlock: startBlock,\n', '            endBlock: endBlock,\n', '            forVotes: 0,\n', '            againstVotes: 0,\n', '            executed: false\n', '        });\n', '\n', '        proposals[newProposal.id] = newProposal;\n', '        latestProposalIds[newProposal.proposer] = newProposal.id;\n', '\n', '        emit ProposalCreated(newProposal.id, msg.sender, target, data, startBlock, endBlock, description);\n', '        return newProposal.id;\n', '    }\n', '\n', '    function execute(uint256 proposalId) public payable {\n', '        require(state(proposalId) == ProposalState.Succeeded, "GovCoordinator::execute: proposal can only be succeeded to execute");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        proposal.executed = true;\n', '        (bool result, ) = address(proposal.target).call(proposal.data);\n', '\n', '        require(result, "GovCoordinator::execute: transaction Failed");\n', '\n', '        // return any eth in this contract\n', '        if(address(this).balance > 0){\n', '          address payable _sender = msg.sender;\n', '          _sender.transfer(address(this).balance);\n', '        }\n', '\n', '        emit ProposalExecuted(proposalId);\n', '    }\n', '\n', '    function getAction(uint256 proposalId) public view returns (bytes memory data) {\n', '        Proposal storage p = proposals[proposalId];\n', '        return p.data;\n', '    }\n', '\n', '    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n', '        return proposals[proposalId].receipts[voter];\n', '    }\n', '\n', '    function state(uint256 proposalId) public view returns (ProposalState) {\n', '        require(proposalCount >= proposalId && proposalId > 0, "GovCoordinator::state: invalid proposal id");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        if (block.number <= proposal.startBlock) {\n', '            return ProposalState.Pending;\n', '        } else if (block.number <= proposal.endBlock) {\n', '            return ProposalState.Active;\n', '        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes.add(proposal.againstVotes) < quorumVotes) {\n', '            return ProposalState.Defeated;\n', '        } else if (!proposal.executed) {\n', '            return ProposalState.Succeeded;\n', '        } else if (proposal.executed) {\n', '            return ProposalState.Executed;\n', '        } else {\n', '            return ProposalState.Expired;\n', '        }\n', '    }\n', '\n', '    function castVote(uint256 proposalId, bool support) public {\n', '        return _castVote(msg.sender, proposalId, support);\n', '    }\n', '\n', '    function castVoteBySig(uint256 proposalId, bool support, uint8 v, bytes32 r, bytes32 s) public {\n', '        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n', '        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n', '        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n', '        address signatory = ecrecover(digest, v, r, s);\n', '        require(signatory != address(0), "GovCoordinator::castVoteBySig: invalid signature");\n', '        return _castVote(signatory, proposalId, support);\n', '    }\n', '\n', '    function _castVote(address voter, uint256 proposalId, bool support) internal {\n', '        require(state(proposalId) == ProposalState.Active, "GovCoordinator::_castVote: voting is closed");\n', '        Proposal storage proposal = proposals[proposalId];\n', '        Receipt storage receipt = proposal.receipts[voter];\n', '        require(!receipt.hasVoted, "GovCoordinator::_castVote: voter already voted");\n', '        uint96 votes = voice.getPriorVotes(voter, proposal.startBlock);\n', '\n', '        if (support) {\n', '            proposal.forVotes = proposal.forVotes.add(votes);\n', '        } else {\n', '            proposal.againstVotes = proposal.againstVotes.add(votes);\n', '        }\n', '\n', '        receipt.hasVoted = true;\n', '        receipt.support = support;\n', '        receipt.votes = votes;\n', '\n', '        emit VoteCast(voter, proposalId, support, votes);\n', '    }\n', '\n', '    function getChainId() internal pure returns (uint) {\n', '        uint256 chainId;\n', '        assembly { chainId := chainid() }\n', '        return chainId;\n', '    }\n', '}\n', '\n', 'interface IVoiceContract {\n', '    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n', '}']