['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-25\n', '*/\n', '\n', '// SPDX-License-Identifier: MIXED\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/// @notice A library for performing overflow-/underflow-safe math,\n', '/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '\n', '    function to128(uint256 a) internal pure returns (uint128 c) {\n', '        require(a <= uint128(-1), "BoringMath: uint128 Overflow");\n', '        c = uint128(a);\n', '    }\n', '\n', '    function to64(uint256 a) internal pure returns (uint64 c) {\n', '        require(a <= uint64(-1), "BoringMath: uint64 Overflow");\n', '        c = uint64(a);\n', '    }\n', '\n', '    function to32(uint256 a) internal pure returns (uint32 c) {\n', '        require(a <= uint32(-1), "BoringMath: uint32 Overflow");\n', '        c = uint32(a);\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\n', 'library BoringMath128 {\n', '    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\n', 'library BoringMath64 {\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\n', 'library BoringMath32 {\n', '    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/interfaces/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /// @notice EIP 2612\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', '// solhint-disable avoid-low-level-calls\n', '\n', 'library BoringERC20 {\n', '    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()\n', '    bytes4 private constant SIG_NAME = 0x06fdde03; // name()\n', '    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()\n', '    bytes4 private constant SIG_TRANSFER = 0xa9059cbb; // transfer(address,uint256)\n', '    bytes4 private constant SIG_TRANSFER_FROM = 0x23b872dd; // transferFrom(address,address,uint256)\n', '\n', '    function returnDataToString(bytes memory data) internal pure returns (string memory) {\n', '        if (data.length >= 64) {\n', '            return abi.decode(data, (string));\n', '        } else if (data.length == 32) {\n', '            uint8 i = 0;\n', '            while(i < 32 && data[i] != 0) {\n', '                i++;\n', '            }\n', '            bytes memory bytesArray = new bytes(i);\n', '            for (i = 0; i < 32 && data[i] != 0; i++) {\n', '                bytesArray[i] = data[i];\n', '            }\n', '            return string(bytesArray);\n', '        } else {\n', '            return "???";\n', '        }\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (string) Token symbol.\n', '    function safeSymbol(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));\n', '        return success ? returnDataToString(data) : "???";\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (string) Token name.\n', '    function safeName(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));\n', '        return success ? returnDataToString(data) : "???";\n', '    }\n', '\n', "    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n", '    /// @param token The address of the ERC-20 token contract.\n', '    /// @return (uint8) Token decimals.\n', '    function safeDecimals(IERC20 token) internal view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '\n', '    /// @notice Provides a safe ERC20.transfer version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: Transfer failed");\n', '    }\n', '\n', '    /// @notice Provides a safe ERC20.transferFrom version for different ERC-20 implementations.\n', '    /// Reverts on a failed transfer.\n', '    /// @param token The address of the ERC-20 token.\n', '    /// @param from Transfer tokens from.\n', '    /// @param to Transfer tokens to.\n', '    /// @param amount The token amount.\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(SIG_TRANSFER_FROM, from, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "BoringERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', '// Based on code and smartness by Ross Campbell and Keno\n', '// Uses immutable to store the domain separator to reduce gas usage\n', '// If the chain id changes due to a fork, the forked chain will calculate on the fly.\n', '\n', '// solhint-disable no-inline-assembly\n', '\n', 'contract Domain {\n', '    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256("EIP712Domain(uint256 chainId,address verifyingContract)");\n', '    // See https://eips.ethereum.org/EIPS/eip-191\n', '    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = "\\x19\\x01";\n', '\n', '    // solhint-disable var-name-mixedcase\n', '    bytes32 private immutable _DOMAIN_SEPARATOR;\n', '    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;    \n', '\n', '    /// @dev Calculate the DOMAIN_SEPARATOR\n', '    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n', '        return keccak256(\n', '            abi.encode(\n', '                DOMAIN_SEPARATOR_SIGNATURE_HASH,\n', '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    constructor() public {\n', '        uint256 chainId; assembly {chainId := chainid()}\n', '        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n', '    }\n', '\n', '    /// @dev Return the DOMAIN_SEPARATOR\n', "    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n", '    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function _domainSeparator() internal view returns (bytes32) {\n', '        uint256 chainId; assembly {chainId := chainid()}\n', '        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n', '    }\n', '\n', '    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n', '        digest =\n', '            keccak256(\n', '                abi.encodePacked(\n', '                    EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA,\n', '                    _domainSeparator(),\n', '                    dataHash\n', '                )\n', '            );\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', '// solhint-disable no-inline-assembly\n', '// solhint-disable not-rely-on-time\n', '\n', '// Data part taken out for building of contracts that receive delegate calls\n', 'contract ERC20Data {\n', '    /// @notice owner > balance mapping.\n', '    mapping(address => uint256) public balanceOf;\n', '    /// @notice owner > spender > allowance mapping.\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    /// @notice owner > nonce mapping. Used in `permit`.\n', '    mapping(address => uint256) public nonces;\n', '}\n', '\n', 'abstract contract ERC20 is IERC20, Domain {\n', '    /// @notice owner > balance mapping.\n', '    mapping(address => uint256) public override balanceOf;\n', '    /// @notice owner > spender > allowance mapping.\n', '    mapping(address => mapping(address => uint256)) public override allowance;\n', '    /// @notice owner > nonce mapping. Used in `permit`.\n', '    mapping(address => uint256) public nonces;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n', '    /// @param to The address to move the tokens.\n', '    /// @param amount of the tokens to move.\n', '    /// @return (bool) Returns True if succeeded.\n', '    function transfer(address to, uint256 amount) public returns (bool) {\n', '        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n', '        if (amount != 0 || msg.sender == to) {\n', '            uint256 srcBalance = balanceOf[msg.sender];\n', '            require(srcBalance >= amount, "ERC20: balance too low");\n', '            if (msg.sender != to) {\n', '                require(to != address(0), "ERC20: no zero address"); // Moved down so low balance calls safe some gas\n', '\n', '                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n', '                balanceOf[to] += amount;\n', '            }\n', '        }\n', '        emit Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n', '    /// @param from Address to draw tokens from.\n', '    /// @param to The address to move the tokens.\n', '    /// @param amount The token amount to move.\n', '    /// @return (bool) Returns True if succeeded.\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        // If `amount` is 0, or `from` is `to` nothing happens\n', '        if (amount != 0) {\n', '            uint256 srcBalance = balanceOf[from];\n', '            require(srcBalance >= amount, "ERC20: balance too low");\n', '\n', '            if (from != to) {\n', '                uint256 spenderAllowance = allowance[from][msg.sender];\n', "                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n", '                if (spenderAllowance != type(uint256).max) {\n', '                    require(spenderAllowance >= amount, "ERC20: allowance too low");\n', '                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n', '                }\n', '                require(to != address(0), "ERC20: no zero address"); // Moved down so other failed calls safe some gas\n', '\n', '                balanceOf[from] = srcBalance - amount; // Underflow is checked\n', '                balanceOf[to] += amount;\n', '            }\n', '        }\n', '        emit Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Approves `amount` from sender to be spend by `spender`.\n', "    /// @param spender Address of the party that can draw from msg.sender's account.\n", '    /// @param amount The maximum collective amount that `spender` can draw.\n', '    /// @return (bool) Returns True if approved.\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n', '        return _domainSeparator();\n', '    }\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n', '    /// @param owner_ Address of the owner.\n', '    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n', '    /// @param value The maximum collective amount that `spender` can draw.\n', '    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n', '    function permit(\n', '        address owner_,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external override {\n', '        require(owner_ != address(0), "ERC20: Owner cannot be 0");\n', '        require(block.timestamp < deadline, "ERC20: Expired");\n', '        require(\n', '            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n', '                owner_,\n', '            "ERC20: Invalid Signature"\n', '        );\n', '        allowance[owner_][spender] = value;\n', '        emit Approval(owner_, spender, value);\n', '    }\n', '}\n', '\n', 'contract ERC20WithSupply is IERC20, ERC20 {\n', '    uint256 public override totalSupply;\n', '\n', '    function _mint(address user, uint256 amount) private {\n', '        uint256 newTotalSupply = totalSupply + amount;\n', '        require(newTotalSupply >= totalSupply, "Mint overflow");\n', '        totalSupply = newTotalSupply;\n', '        balanceOf[user] += amount;\n', '    }\n', '\n', '    function _burn(address user, uint256 amount) private {\n', '        require(balanceOf[user] >= amount, "Burn too much");\n', '        totalSupply -= amount;\n', '        balanceOf[user] -= amount;\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', '\n', '// solhint-disable avoid-low-level-calls\n', '// solhint-disable no-inline-assembly\n', '\n', '// Audit on 5-Jan-2021 by Keno and BoringCrypto\n', '\n', 'contract BaseBoringBatchable {\n', '    /// @dev Helper function to extract a useful revert message from a failed call.\n', '    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n', '    function _getRevertMsg(bytes memory _returnData) internal pure returns (string memory) {\n', '        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n', '        if (_returnData.length < 68) return "Transaction reverted silently";\n', '\n', '        assembly {\n', '            // Slice the sighash.\n', '            _returnData := add(_returnData, 0x04)\n', '        }\n', '        return abi.decode(_returnData, (string)); // All that remains is the revert string\n', '    }\n', '\n', '    /// @notice Allows batched call to self (this contract).\n', '    /// @param calls An array of inputs for each call.\n', '    /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n', '    // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n', '    // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n', "    // C3: The length of the loop is fully under user control, so can't be exploited\n", "    // C7: Delegatecall is only used on the same contract, so it's safe\n", '    function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n', '        for (uint256 i = 0; i < calls.length; i++) {\n', '            (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n', '            if (!success && revertOnFail) {\n', '                revert(_getRevertMsg(result));\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'contract BoringBatchable is BaseBoringBatchable {\n', '    /// @notice Call wrapper that performs `ERC20.permit` on `token`.\n', '    /// Lookup `IERC20.permit`.\n', "    // F6: Parameters can be used front-run the permit and the user's permit will fail (due to nonce or other revert)\n", '    //     if part of a batch this could be used to grief once as the second call would not need the permit\n', '    function permitToken(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public {\n', '        token.permit(from, to, amount, deadline, v, r, s);\n', '    }\n', '}\n', '\n', '// File contracts/sSpell.sol\n', '//License-Identifier: MIT\n', '\n', "// Staking in sSpell inspired by Chef Nomi's SushiBar - MIT license (originally WTFPL)\n", '// modified by BoringCrypto for DictatorDAO\n', '\n', 'contract sSpellV1 is IERC20, Domain {\n', '    using BoringMath for uint256;\n', '    using BoringMath128 for uint128;\n', '    using BoringERC20 for IERC20;\n', '\n', '    string public constant symbol = "sSPELL";\n', '    string public constant name = "Staked Spell Tokens";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public override totalSupply;\n', '    uint256 private constant LOCK_TIME = 24 hours;\n', '\n', '    IERC20 public immutable token;\n', '\n', '    constructor(IERC20 _token) public {\n', '        token = _token;\n', '    }\n', '\n', '    struct User {\n', '        uint128 balance;\n', '        uint128 lockedUntil;\n', '    }\n', '\n', '    /// @notice owner > balance mapping.\n', '    mapping(address => User) public users;\n', '    /// @notice owner > spender > allowance mapping.\n', '    mapping(address => mapping(address => uint256)) public override allowance;\n', '    /// @notice owner > nonce mapping. Used in `permit`.\n', '    mapping(address => uint256) public nonces;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    function balanceOf(address user) public view override returns (uint256 balance) {\n', '        return users[user].balance;\n', '    }\n', '\n', '    function _transfer(\n', '        address from,\n', '        address to,\n', '        uint256 shares\n', '    ) internal {\n', '        User memory fromUser = users[from];\n', '        require(block.timestamp >= fromUser.lockedUntil, "Locked");\n', '        if (shares != 0) {\n', '            require(fromUser.balance >= shares, "Low balance");\n', '            if (from != to) {\n', '                require(to != address(0), "Zero address"); // Moved down so other failed calls safe some gas\n', '                User memory toUser = users[to];\n', '                users[from].balance = fromUser.balance - shares.to128(); // Underflow is checked\n', "                users[to].balance = toUser.balance + shares.to128(); // Can't overflow because totalSupply would be greater than 2^128-1;\n", '            }\n', '        }\n', '        emit Transfer(from, to, shares);\n', '    }\n', '\n', '    function _useAllowance(address from, uint256 shares) internal {\n', '        if (msg.sender == from) {\n', '            return;\n', '        }\n', '        uint256 spenderAllowance = allowance[from][msg.sender];\n', "        // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n", '        if (spenderAllowance != type(uint256).max) {\n', '            require(spenderAllowance >= shares, "Low allowance");\n', '            allowance[from][msg.sender] = spenderAllowance - shares; // Underflow is checked\n', '        }\n', '    }\n', '\n', '    /// @notice Transfers `shares` tokens from `msg.sender` to `to`.\n', '    /// @param to The address to move the tokens.\n', '    /// @param shares of the tokens to move.\n', '    /// @return (bool) Returns True if succeeded.\n', '    function transfer(address to, uint256 shares) public returns (bool) {\n', '        _transfer(msg.sender, to, shares);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfers `shares` tokens from `from` to `to`. Caller needs approval for `from`.\n', '    /// @param from Address to draw tokens from.\n', '    /// @param to The address to move the tokens.\n', '    /// @param shares The token shares to move.\n', '    /// @return (bool) Returns True if succeeded.\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 shares\n', '    ) public returns (bool) {\n', '        _useAllowance(from, shares);\n', '        _transfer(from, to, shares);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Approves `amount` from sender to be spend by `spender`.\n', "    /// @param spender Address of the party that can draw from msg.sender's account.\n", '    /// @param amount The maximum collective amount that `spender` can draw.\n', '    /// @return (bool) Returns True if approved.\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n', '        return _domainSeparator();\n', '    }\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n', '    /// @param owner_ Address of the owner.\n', '    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n', '    /// @param value The maximum collective amount that `spender` can draw.\n', '    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n', '    function permit(\n', '        address owner_,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external override {\n', '        require(owner_ != address(0), "Zero owner");\n', '        require(block.timestamp < deadline, "Expired");\n', '        require(\n', '            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n', '                owner_,\n', '            "Invalid Sig"\n', '        );\n', '        allowance[owner_][spender] = value;\n', '        emit Approval(owner_, spender, value);\n', '    }\n', '\n', '    /// math is ok, because amount, totalSupply and shares is always 0 <= amount <= 100.000.000 * 10^18\n', "    /// theoretically you can grow the amount/share ratio, but it's not practical and useless\n", '    function mint(uint256 amount) public returns (bool) {\n', '        require(msg.sender != address(0), "Zero address");\n', '        User memory user = users[msg.sender];\n', '\n', '        uint256 totalTokens = token.balanceOf(address(this));\n', '        uint256 shares = totalSupply == 0 ? amount : (amount * totalSupply) / totalTokens;\n', '        user.balance += shares.to128();\n', '        user.lockedUntil = (block.timestamp + LOCK_TIME).to128();\n', '        users[msg.sender] = user;\n', '        totalSupply += shares;\n', '\n', '        token.safeTransferFrom(msg.sender, address(this), amount);\n', '\n', '        emit Transfer(address(0), msg.sender, shares);\n', '        return true;\n', '    }\n', '\n', '    function _burn(\n', '        address from,\n', '        address to,\n', '        uint256 shares\n', '    ) internal {\n', '        require(to != address(0), "Zero address");\n', '        User memory user = users[from];\n', '        require(block.timestamp >= user.lockedUntil, "Locked");\n', '        uint256 amount = (shares * token.balanceOf(address(this))) / totalSupply;\n', '        users[from].balance = user.balance.sub(shares.to128()); // Must check underflow\n', '        totalSupply -= shares;\n', '\n', '        token.safeTransfer(to, amount);\n', '\n', '        emit Transfer(from, address(0), shares);\n', '    }\n', '\n', '    function burn(address to, uint256 shares) public returns (bool) {\n', '        _burn(msg.sender, to, shares);\n', '        return true;\n', '    }\n', '\n', '    function burnFrom(\n', '        address from,\n', '        address to,\n', '        uint256 shares\n', '    ) public returns (bool) {\n', '        _useAllowance(from, shares);\n', '        _burn(from, to, shares);\n', '        return true;\n', '    }\n', '}']