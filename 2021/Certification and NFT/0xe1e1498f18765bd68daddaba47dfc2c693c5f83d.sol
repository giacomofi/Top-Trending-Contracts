['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-25\n', '*/\n', '\n', '//SPDX-License-Identifier: UNLICENSED\n', 'pragma solidity ^0.8.6;\n', '//+commit.4cb486ee;\n', '\n', 'struct File{\n', '    uint256 timestamp;\n', '    bool set;\n', '    bool deleted;\n', '    bool closed;\n', '    uint256 size;\n', '    bytes32[][] data;\n', '}\n', '\n', 'struct FileTransfer{\n', '    string name;\n', '    address sender;\n', '    uint256 transferTimestamp;\n', '    uint256 timestamp;\n', '    bool closed;\n', '    uint256 size;\n', '    bytes32[] data;\n', '}\n', '\n', 'contract ethFS {\n', '    // Events \n', '    // File modification events\n', '    event FileSaved (\n', '        address indexed user,\n', '        string indexed name,\n', '        uint256 timestamp,\n', '        uint256 size,\n', '        bool appended,\n', '        bytes32 dataHash\n', '    );\n', '    event FileClosed (\n', '        address indexed user,\n', '        string indexed name\n', '    );\n', '    event FileDeleted (\n', '        address indexed user,\n', '        string indexed name\n', '    );\n', '    // File transfer events\n', '    event InboxCleared (\n', '        address indexed user\n', '    );\n', '    event InboxWhitelistStatusChange (\n', '        address indexed user,\n', '        bool enabled\n', '    );\n', '    event InboxWhitelistUserStatusChange (\n', '        address indexed user,\n', '        address indexed sender,\n', '        bool enabled\n', '    );\n', '    \n', '    event FileTransfered (\n', '        address indexed user,\n', '        address indexed receiver,\n', '        string indexed name,\n', '        uint256 transferTimestamp\n', '    );\n', '    \n', '    event FileTransferAccepted (\n', '        address indexed user,\n', '        address indexed sender,\n', '        string indexed name,\n', '        uint256 transferTimestamp\n', '    );\n', '    \n', '    // Ownership\n', '    address owner;\n', '    address nextOwner;\n', '    address beneficiary;\n', '    \n', '    // Constraints\n', '    uint256 minNameLenth = 1;\n', '    uint256 maxNameLength = 1024;\n', '    \n', '    // Fees\n', '    uint256 feePerFile = 0;\n', '    uint256 feePerByte = 0;\n', '    uint256 deletionFee = 0;\n', '    uint256 closingFee = 0;\n', '    uint256 transferSendFeePerFile = 0;\n', '    uint256 transferSendFeePerByte = 0;\n', '    uint256 transferAcceptFeePerFile = 0;\n', '    uint256 transferAcceptFeePerByte = 0;\n', '    \n', '    // Active flags\n', '    bool enabled = true;\n', '    \n', '    bool deletionAllowed = false;\n', '    bool deletionEnabled = false;\n', '    bool transferEnabled = true;\n', '    \n', '    // Statistics\n', '    // Files\n', '    uint256 totalSizeWritten = 0;\n', '    uint256 totalSize = 0;\n', '    uint256 totalSizeDeleted = 0;\n', '    uint256 numberOfFiles = 0; // Increased when file is written that has not been set\n', '    uint256 numberOfWrites = 0; // Increased whenever a file is written (created, overwritten, appended, transfers accepted)\n', '    uint256 numberOfTrueAppends = 0; // Increased whenever a file is appended\n', '    uint256 numberOfDeletedFiles = 0; // Number of times the delete bit has been set on a file\n', '    // File transfers\n', '    uint256 numberOfInboxClearings = 0;\n', '    uint256 numberOfWhitelistedUsers = 0;\n', '    uint256 numberOfUsersWithDisabledInboxWhitelist = 0;\n', '    uint256 numberOfTransferRequests = 0;\n', '    uint256 numberOfAcceptedFileTransfers = 0;\n', '    \n', '    \n', '    // Operations\n', '    uint256 defaultNumberOfNewestNames = 100;\n', '\n', '    // Data store\n', '    mapping(bytes32 => bytes) store;\n', '    mapping(address => mapping(string => File)) nodes;\n', '    mapping(address => string[]) index;\n', '    \n', '    // Inbox\n', '    mapping(address => FileTransfer[][]) inbox;\n', '    mapping(address => bool) inboxWhitelistDisabled;\n', '    mapping(address => mapping(address => bool)) inboxWhitelist;\n', '    \n', '    // Ownership\n', '    constructor() payable {\n', '        owner = msg.sender;\n', '        beneficiary = msg.sender;\n', '    }\n', '    function transferOwnership(address newOwner) external {\n', '        require(msg.sender == owner, "Only owner can transfer ownership");\n', '        nextOwner = newOwner;\n', '    }\n', '    function confirmOwnership() external {\n', '        require(msg.sender == nextOwner, "Only next owner can confirm owner");\n', '        owner = nextOwner;\n', '    }\n', '    function setBeneficiary(address b) external {\n', '        require(msg.sender == owner, "Only owner can set the beneficiary");\n', '        beneficiary = b;\n', '    }\n', '    function withdraw(uint256 amount) external {\n', '        require(msg.sender == beneficiary, "Only the beneficiary can withdraw");\n', '        payable(msg.sender).transfer(amount);\n', '    }\n', '    \n', '    // Activity flags\n', '    function setEnabled(bool flag) external {\n', '        require(msg.sender == owner, "Only owner can enable/disable");\n', '        enabled = flag;\n', '    }\n', '    function setDeletionFlags(bool enabledFlag, bool allowedFlag) external {\n', '        require(msg.sender == owner, "Only the owner can allow/disallow / enable/disable deletion");\n', '        deletionAllowed = allowedFlag;\n', '        deletionEnabled = enabledFlag;\n', '    }\n', '    function setTransferEnabled(bool flag) external {\n', '        require(msg.sender == owner, "Only the owner can set the transfer enabled flag");\n', '        transferEnabled = flag;\n', '    }\n', '    function setFilenameLimits(uint256 minLen, uint256 maxLen) external {\n', '        require(msg.sender == owner, "Only the owner can set the max name length");\n', '        require(minLen > 0, "Minimal filename length needs to be greater than 0");\n', '        minNameLenth = minLen;\n', '        maxNameLength = maxLen;\n', '    }\n', '    \n', '    // Operations \n', '    function setOperationParameters(uint256 nNewest) external {\n', '        require(msg.sender == owner, "Only the owner can set operation parameters");\n', '        defaultNumberOfNewestNames = nNewest;\n', '    }\n', '    \n', '    // Fees\n', '    function setFileOperationFees(uint256 perFile, uint256 perByte, uint256 perDeletion, uint256 perClose) external {\n', '        require(msg.sender == owner, "Only the owner can set the per file fee");\n', '        feePerFile = perFile;\n', '        feePerByte = perByte;\n', '        deletionFee = perDeletion;\n', '        closingFee = perClose;\n', '    }\n', '    function setTransferFees(uint256 sendPerFile, uint256 sendPerByte, uint256 acceptPerFile, uint256 acceptPerByte) external {\n', '        require(msg.sender == owner, "Only the owner can set the transfer fees");\n', '        transferSendFeePerFile = sendPerFile;\n', '        transferSendFeePerByte = sendPerByte;\n', '        transferAcceptFeePerFile = acceptPerFile;\n', '        transferAcceptFeePerByte = acceptPerByte;\n', '    }\n', '    \n', '    // Filesystem operations\n', '    function calculateSaveFee(bytes memory data) view public returns (uint256) {\n', '        return data.length * feePerByte + feePerFile;\n', '    }\n', '    function save(string memory name, bytes memory data) public payable {\n', '        save(name, data, false);\n', '    }\n', '    function save(string memory name, bytes memory data, bool append) public payable {\n', '        require(enabled == true, "ethFS disabled");\n', '        require(bytes(name).length >= minNameLenth, "Name shorter than min filename length");\n', '        require(bytes(name).length <= maxNameLength, "Name longer than max filename length");\n', '        require(!containsNewline(name), "Filename should not contain newline");\n', '        require(msg.value >= calculateSaveFee(data), "Not enough ether provided for saving fee");\n', '        require(!append || !nodes[msg.sender][name].closed, "Trying to append but file is closed");\n', '        require(!deletionEnabled || !append || !nodes[msg.sender][name].deleted, "Trying to append to deleted file");\n', '        \n', '        bool trueAppend = nodes[msg.sender][name].set && append;\n', '        \n', '        if(!nodes[msg.sender][name].set) {\n', '            index[msg.sender].push(name);\n', '            numberOfFiles++;\n', '            assert(nodes[msg.sender][name].data.length == 0); // Data store for file that is not set should be empty\n', '            nodes[msg.sender][name].data.push();\n', '        } else {\n', '            // If file is already set and operation is not append (=> overwrite)\n', '            if(!append) {\n', '                nodes[msg.sender][name].data.push();\n', '                totalSize -= nodes[msg.sender][name].size;\n', '                nodes[msg.sender][name].size = 0;\n', '            }\n', '            if(nodes[msg.sender][name].deleted){\n', '                totalSizeDeleted -= nodes[msg.sender][name].size;\n', '                numberOfDeletedFiles--;\n', '            }\n', '        }\n', '        \n', '        bytes32 dataHash = keccak256(data);\n', '        store[dataHash] = data;\n', '        nodes[msg.sender][name].set = true;\n', '        nodes[msg.sender][name].deleted = false;\n', '        nodes[msg.sender][name].closed = false;\n', '        nodes[msg.sender][name].timestamp = block.timestamp;\n', '        nodes[msg.sender][name].size += data.length;\n', '        nodes[msg.sender][name].data[nodes[msg.sender][name].data.length - 1].push(dataHash);\n', '        \n', '        \n', '        totalSizeWritten += data.length;\n', '        totalSize += data.length;\n', '        numberOfWrites++;\n', '        if(trueAppend) {\n', '            numberOfTrueAppends++;\n', '        }\n', '        emit FileSaved(msg.sender, name, block.timestamp, data.length, trueAppend, dataHash);\n', '    }\n', '    function close(string calldata name) external payable {\n', '        require(enabled == true, "ethFS disabled");\n', '        require(nodes[msg.sender][name].set = true, "Trying to close file that is not set");\n', '        require(msg.value >= closingFee, "Not enough ether provided for closing fee");\n', '        nodes[msg.sender][name].closed = true;\n', '        \n', '        emit FileClosed(msg.sender, name);\n', '    }\n', '    function remove(string calldata name) external payable {\n', '        require(enabled == true, "ethFS disabled");\n', '        require(deletionAllowed, "Deletion not allowed");\n', '        require(deletionEnabled, "Deletion disabled");\n', '        require(nodes[msg.sender][name].set, "File not found");\n', '        require(msg.value >= deletionFee, "Not enough ether provided for deletion fee");\n', '        \n', '        bool trueDelete = !nodes[msg.sender][name].deleted;\n', '        nodes[msg.sender][name].deleted = true;\n', '        \n', '        if(trueDelete){\n', '            numberOfDeletedFiles++;\n', '            totalSizeDeleted += nodes[msg.sender][name].size;\n', '        }\n', '        emit FileDeleted(msg.sender, name);\n', '    }\n', '    \n', '    // Data chunk helpers\n', '    function getFileData(bytes32[] memory data) private view returns (bytes memory) {\n', '        bytes memory res;\n', '        for(uint256 i=0; i<data.length; i++){\n', '            res = abi.encodePacked(res, store[data[i]]);\n', '        }\n', '        return res;\n', '    }\n', '    \n', '    // Transfer operations\n', '    function clearInbox() external {\n', '        inbox[msg.sender].push();\n', '        \n', '        numberOfInboxClearings++;\n', '        emit InboxCleared(msg.sender);\n', '    }\n', '    function setInboxWhitelistEnabled(bool flag) external {\n', '        bool previousState = !inboxWhitelistDisabled[msg.sender];\n', '        inboxWhitelistDisabled[msg.sender] = !flag;\n', '        \n', '        if(previousState != flag){\n', '            if(!flag){\n', '                numberOfUsersWithDisabledInboxWhitelist++;\n', '            } else {\n', '                numberOfUsersWithDisabledInboxWhitelist--;\n', '            }\n', '        }\n', '        emit InboxWhitelistStatusChange(msg.sender, flag);\n', '    }\n', '    function setInboxWhitelist(address sender, bool flag) external {\n', '        bool previousState = inboxWhitelist[msg.sender][sender];\n', '        inboxWhitelist[msg.sender][sender] = flag;\n', '        \n', '        if(previousState != flag) {\n', '            if(flag){\n', '                numberOfWhitelistedUsers++;\n', '            } else {\n', '                numberOfWhitelistedUsers--;\n', '            }\n', '        }\n', '        emit InboxWhitelistUserStatusChange(msg.sender, sender, flag);\n', '    }\n', '    function calculateTransferSendingFee(string memory name) public view returns (uint256) {\n', '        require(nodes[msg.sender][name].set, "File does not exist");\n', '        require(!nodes[msg.sender][name].deleted || !deletionEnabled, "File has been deleted");\n', '        return nodes[msg.sender][name].size * transferSendFeePerByte + transferSendFeePerFile;\n', '    }\n', '    function transfer(string calldata name, address receiver) external payable {\n', '        require(enabled == true, "ethFS disabled");\n', '        require(transferEnabled, "Transfer is not enabled");\n', '        require(nodes[msg.sender][name].set, "File does not exist");\n', '        require(!nodes[msg.sender][name].deleted || !deletionEnabled, "File has been deleted");\n', '        require(inboxWhitelistDisabled[receiver] || inboxWhitelist[receiver][msg.sender], "Inbox whitelist enabled by receiver and sender not whitelisted");\n', '        require(msg.value >= calculateTransferSendingFee(name), "Not enough ether provided for transfer fee");\n', '        \n', '        FileTransfer memory ft;\n', '        ft.sender = msg.sender;\n', '        ft.name = name;\n', '        ft.transferTimestamp = block.timestamp;\n', '        ft.timestamp = nodes[msg.sender][name].timestamp;\n', '        ft.closed = nodes[msg.sender][name].closed;\n', '        ft.size = nodes[msg.sender][name].size;\n', '        ft.data = nodes[msg.sender][name].data[nodes[msg.sender][name].data.length - 1];\n', '        if(inbox[receiver].length == 0){\n', '            inbox[receiver].push();\n', '        }\n', '        inbox[receiver][inbox[receiver].length - 1].push(ft);\n', '        \n', '        numberOfTransferRequests++;\n', '        emit FileTransfered(msg.sender, receiver, name, ft.transferTimestamp);\n', '    }\n', '    \n', '    // returns (index of last FileTransfer, fee)\n', '    function calculateLastFileTransferAcceptanceFee() public view returns (uint256, uint256) {\n', '        require(inbox[msg.sender].length > 0, "Inbox not yet existing");\n', '        require(inbox[msg.sender][inbox[msg.sender].length - 1].length > 0, "Inbox empty");\n', '        \n', '        uint256 i = inbox[msg.sender][inbox[msg.sender].length - 1].length - 1;\n', '        return (i, inbox[msg.sender][inbox[msg.sender].length - 1][i].size * transferAcceptFeePerByte + transferAcceptFeePerFile);\n', '    }\n', '    function acceptLastFileTransfer(uint256 i) external payable {\n', '        require(enabled == true, "ethFS disabled");\n', '        require(transferEnabled, "Transfer is not enabled");\n', '        require(inbox[msg.sender].length > 0, "Inbox not yet existing");\n', '        require(inbox[msg.sender][inbox[msg.sender].length - 1].length > 0, "Inbox empty");\n', '        require(i == inbox[msg.sender][inbox[msg.sender].length - 1].length - 1, "Requested transfer index not the last file in inbox (inbox)");\n', '        (, uint256 fee) = calculateLastFileTransferAcceptanceFee();\n', '        require(msg.value >= fee, "Not enough ether provided for transfer fee");\n', '        \n', '        FileTransfer storage ft = inbox[msg.sender][inbox[msg.sender].length - 1][i];\n', '        inbox[msg.sender][inbox[msg.sender].length - 1].pop();\n', '        \n', '        if(!nodes[msg.sender][ft.name].set) {\n', '            index[msg.sender].push(ft.name);\n', '            numberOfFiles++;\n', '            assert(nodes[msg.sender][ft.name].data.length == 0); // Data store for file that is not set should be empty\n', '        } else {\n', '            // If file is already set => overwrite\n', '            totalSize -= nodes[msg.sender][ft.name].size;\n', '            if(nodes[msg.sender][ft.name].deleted){\n', '                totalSizeDeleted -= nodes[msg.sender][ft.name].size;\n', '                numberOfDeletedFiles--;\n', '            }\n', '        }\n', '        \n', '        nodes[msg.sender][ft.name].set = true;\n', '        nodes[msg.sender][ft.name].deleted = false;\n', '        nodes[msg.sender][ft.name].timestamp = ft.timestamp;\n', '        nodes[msg.sender][ft.name].closed = ft.closed;\n', '        nodes[msg.sender][ft.name].size = ft.size;\n', '        nodes[msg.sender][ft.name].data.push(ft.data);\n', '        \n', '        numberOfAcceptedFileTransfers++;\n', '        totalSize += ft.size;\n', '        numberOfWrites++;\n', '        emit FileTransferAccepted(msg.sender, ft.sender, ft.name, ft.transferTimestamp);\n', '    }\n', '    \n', '    // Getters\n', '    \n', '    // Filesystem \n', '    function count(address user, bool excludeDeleted) public view returns (uint256){\n', '        uint256 c = 0;\n', '        for(uint256 i=0; i<index[user].length; i++){\n', '            c += (deletionEnabled && excludeDeleted && nodes[user][index[user][i]].deleted) ? 0 : 1;\n', '        }\n', '        return c;\n', '    }    \n', '    function count() public view returns (uint256){\n', '        return count(msg.sender, true);\n', '    }\n', '    function getName(address user, uint256 i) public view returns (string memory) {\n', '        return index[user][i];\n', '    }\n', '    function getName(uint256 i) public view returns (string memory) {\n', '        return getName(msg.sender, i);\n', '    }\n', '    function getAllNames(address user, uint256 n, bool excludeDeleted) public view returns (string memory){\n', '        string[] memory nameIndex = index[user];\n', '        bytes memory res;\n', '        uint256 nAdded = 0;\n', '        for(uint256 i=0; i<nameIndex.length; i++){\n', '            if(n == 0 || nAdded < n){\n', '                uint256 current = nameIndex.length - i - 1;\n', '                if(!deletionEnabled || !excludeDeleted || !nodes[user][nameIndex[current]].deleted) {\n', "                    res = abi.encodePacked(res, nameIndex[current], '\\n');\n", '                    nAdded++;\n', '                }\n', '            }\n', '        }\n', '        return string(res);\n', '    }\n', '    function getAllNames(address user) public view returns (string memory){\n', '        return getAllNames(user, 0, true);\n', '    }\n', '    function getAllNames() public view returns (string memory){\n', '        return getAllNames(msg.sender, 0, true);\n', '    }\n', '    function getNewestNames(address user, uint256 n) public view returns (string memory){\n', '        return getAllNames(user, n, true);\n', '    }\n', '    function getNewestNames(uint256 n) public view returns (string memory){\n', '        return getAllNames(msg.sender, n, true);\n', '    }\n', '    function getNewestNames() public view returns (string memory){\n', '        return getAllNames(msg.sender, defaultNumberOfNewestNames, true);\n', '    }\n', '    function exists(string memory name) public view returns (bool) {\n', '        return exists(msg.sender, name);\n', '    }\n', '    function exists(address user, string memory name) public view returns (bool) {\n', '        return nodes[user][name].set && (!nodes[msg.sender][name].deleted || !deletionEnabled);\n', '    }\n', '\n', '    function retrieve(address user, string memory name) public view returns (bytes memory){\n', '        require(nodes[user][name].set, "File does not exist");\n', '        require(!nodes[user][name].deleted || !deletionEnabled, "File has been deleted");\n', '        return getFileData(nodes[user][name].data[nodes[msg.sender][name].data.length - 1]);\n', '        \n', '    }\n', '    function retrieve(string memory name) public view returns (bytes memory){\n', '        return retrieve(msg.sender, name);\n', '    }\n', '\n', '    function getTimestamp(address user, string memory name) public view returns (uint256){\n', '        require(nodes[user][name].set, "File does not exist");\n', '        require(!nodes[user][name].deleted || !deletionEnabled, "File has been deleted");\n', '        return nodes[user][name].timestamp;\n', '    }\n', '    function getTimestamp(string calldata name) external view returns (uint256){\n', '        return getTimestamp(msg.sender, name);\n', '    }\n', '    \n', '    function getSize(address user, string memory name) public view returns (uint256){\n', '        require(nodes[user][name].set, "File does not exist");\n', '        require(!nodes[user][name].deleted || !deletionEnabled, "File has been deleted");\n', '        return nodes[user][name].size;\n', '    }\n', '    function getSize(string calldata name) external view returns (uint256){\n', '        return getSize(msg.sender, name);\n', '    }\n', '    \n', '    // Inbox\n', '    // returns index, name, sender, transferTimestamp, timestamp, dataHash\n', '    function getLastFileFromInbox() external view returns (uint256, string memory, address, uint256, uint256, bytes memory) {\n', '        require(inbox[msg.sender].length > 0, "Inbox not yet existing");\n', '        require(inbox[msg.sender][inbox[msg.sender].length - 1].length > 0, "Inbox empty");\n', '        uint256 i = inbox[msg.sender][inbox[msg.sender].length - 1].length - 1;\n', '        (string memory name, address sender, uint256 transferTimestamp, uint256 timestamp, bytes memory data) = getFileFromInbox(i);\n', '        return (i, name, sender, transferTimestamp, timestamp, data);\n', '        \n', '    }\n', '    // returns name, sender, transferTimestamp, timestamp, dataHash\n', '    function getFileFromInbox(uint256 i) public view returns (string memory, address, uint256, uint256, bytes memory) {\n', '        require(inbox[msg.sender].length > 0, "Inbox not yet existing");\n', '        require(i >= 0 && i < inbox[msg.sender][inbox[msg.sender].length - 1].length, "Index out of range");\n', '        FileTransfer memory ft = inbox[msg.sender][inbox[msg.sender].length - 1][i];\n', '        return (ft.name, ft.sender, ft.transferTimestamp, ft.timestamp, getFileData(ft.data));\n', '    }\n', '    \n', '    // Helpers\n', '    function containsNewline(string memory s) public pure returns (bool) {\n', '        bytes memory stringBytes = bytes(s);\n', '        for(uint256 i=0; i<stringBytes.length; i++){\n', "            if (stringBytes[i] == '\\n') {\n", '                return true;\n', '            }\n', '        }\n', '        return false;\n', '    }\n', '    \n', '}']