['// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'import "./IStructs.sol";\n', '\n', '// for CompFi Interfaces\n', 'import "./IERC20.sol";\n', 'import "./Ic_or_w_ETH.sol";\n', 'import "./IComptroller.sol";\n', '\n', '// KyberSwap\n', 'import "./IKyberNetworkProxy.sol";\n', '\n', '\n', '// dYdX flash loan contract\n', 'interface ISoloMargin {\n', '    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\n', '}\n', '\n', 'address constant kETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n', '// Compound.Finance Comptroller constants\n', '// Note:To call Comptroller functions, use the Comptroller ABI on the Unitroller address.\n', 'address constant kUnitroller = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n', 'address constant kComptroller = 0xd513d22422a3062Bd342Ae374b4b9c20E0a9a074;\n', 'address constant kcUSDC = 0x39AA39c021dfbaE8faC545936693aC917d5E7563;\n', 'address constant kcETH = 0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5;\n', '\n', '// KyberSwap Proxy contract \n', 'address constant kKyberProxy = 0x9AAb3f75489902f3a48495025729a0AF77d4b11e;\n', '// KyberHintHandler (KyberMatchingEngine)\n', 'address constant kKybeHint = 0xa1C0Fa73c39CFBcC11ec9Eb1Afc665aba9996E2C;\n', '\n', '// dYdX loan currencies\n', 'address constant kWETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', 'address constant kSAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n', 'address constant kUSDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', 'address constant kDAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '\n', 'abstract contract DyDxPool is Structs {\n', '    function getAccountWei(Info memory account, uint256 marketId) public virtual view returns (Wei memory);\n', '    function operate(Info[] memory, ActionArgs[] memory) public virtual;\n', '}\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', 'contract DyDxFlashLoan is Structs {\n', '    DyDxPool kDyDxPool = DyDxPool(0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e);\n', '\n', '    // address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n', '    // address public SAI = 0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359;\n', '    // address public USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '    // address public DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '    mapping(address => uint256) public currencies;\n', '    \n', '    constructor() {\n', '        currencies[kWETH] = 1;\n', '        currencies[kSAI] = 2;\n', '        currencies[kUSDC] = 3;\n', '        currencies[kDAI] = 4;\n', '    }\n', '\n', '    modifier onlyPool() {\n', '        require(msg.sender == address(kDyDxPool), "FlashLoan: could be called by DyDx pool only");\n', '        _;\n', '    }\n', '\n', '    function tokenToMarketId(address token) public view returns (uint256 ) {\n', '        \n', '        require(currencies[token] != 0, "FlashLoan: Unsupported token");\n', '        \n', '        return currencies[token] - 1;\n', '    }\n', '\n', '\n', '    /***************************************************************************\n', '     * the DyDx will call `callFunction(address sender, Info memory accountInfo,\n', '     * bytes memory data) public` after during `operate` call\n', '     ***************************************************************************/\n', '    function flashloan(address token, uint256 amount, bytes memory data)\n', '        internal\n', '    {\n', '        ERC20(token).approve(address(kDyDxPool), amount + 1);\n', '        Info[] memory infos = new Info[](1);\n', '        ActionArgs[] memory args = new ActionArgs[](3);\n', '\n', '        infos[0] = Info(address(this), 0);\n', '\n', '        AssetAmount memory wamt = AssetAmount(\n', '            false,\n', '            AssetDenomination.Wei,\n', '            AssetReference.Delta,\n', '            amount\n', '        );\n', '        \n', '        ActionArgs memory withdraw;\n', '        withdraw.actionType = ActionType.Withdraw;\n', '        withdraw.accountId = 0;\n', '        withdraw.amount = wamt;\n', '        withdraw.primaryMarketId = tokenToMarketId(token);\n', '        withdraw.otherAddress = address(this);\n', '\n', '        args[0] = withdraw;\n', '\n', '        ActionArgs memory call;\n', '        call.actionType = ActionType.Call;\n', '        call.accountId = 0;\n', '        call.otherAddress = address(this);\n', '        call.data = data;\n', '\n', '        args[1] = call;\n', '\n', '        ActionArgs memory deposit;\n', '        AssetAmount memory damt = AssetAmount(\n', '            true,\n', '            AssetDenomination.Wei,\n', '            AssetReference.Delta,\n', '            amount + 1\n', '        );\n', '        deposit.actionType = ActionType.Deposit;\n', '        deposit.accountId = 0;\n', '        deposit.amount = damt;\n', '        deposit.primaryMarketId = tokenToMarketId(token);\n', '        deposit.otherAddress = address(this);\n', '\n', '        args[2] = deposit;\n', '\n', '        kDyDxPool.operate(infos, args);\n', '    }\n', '}\n', '\n', '\n', '/**********************************************************\n', ' * Main Contract: PreachersCompFiLqdt\n', ' **********************************************************/\n', 'pragma solidity ^0.8.0;\n', '\n', 'contract PreachersCompFiLqdt is DyDxFlashLoan {\n', '    uint256 public loan;\n', '    IKyberNetworkProxy cKyberProxy = IKyberNetworkProxy(kKyberProxy);\n', '\n', '    // Contract owner\n', '    address payable owner;\n', '\n', '    // Modifiers\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "caller is not the owner!");\n', '        _;\n', '    }\n', '\n', '    constructor() payable {\n', '\n', '        // Track the contract owner\n', '        owner = payable(msg.sender);\n', '        \n', '    }\n', '    \n', '    event Received(address, uint);\n', '    receive() external payable {\n', '        emit Received(msg.sender, msg.value);\n', '    }\n', '\n', '    /*************************************************************************************************************\n', '     * Call this contract function from the external \n', '     * remote job to perform the liquidation.\n', '     * \n', '     ************************************************************************************************************/\n', '    function doCompFiLiquidate(\n', '        //loan information\n', '        address flashToken, \n', '        uint256 flashAmount,\n', '        // Borrow Account to be liquidated\n', '        address targetAccount, \n', '        address targetToken, \n', '        uint256 liquidateAmount,\n', '        // liquidation reimbursement and Reward Token\n', '        address collateralToken\n', '        ) external returns(bool) {\n', '        \n', '        emit PassThru( liquidateAmount );\n', '        // Populate the passthru data structure, which will be used\n', "        // by 'callFunction'\n", '        bytes memory data = abi.encode(\n', '            flashToken, \n', '            flashAmount,\n', '            targetAccount, \n', '            targetToken, \n', '            liquidateAmount, \n', '            collateralToken);\n', '        \n', '        // execution goes to `callFunction`\n', '        // STEP 1\n', '        flashloan(flashToken, flashAmount, data);\n', '        emit Liquidated( targetAccount, targetToken, liquidateAmount );\n', '        return true;\n', '    }\n', '    \n', '    /**************************************************************************************\n', "     * Preacher's Method II\n", '     * \n', '     * 1. Obtain Flash Loan in USDC from dYdX in the amount of equal value in the \n', '     * liquidation amount.\n', '     * 2. If the liquidate token is cUSDC, skip to step (3). Otherwise, swap (Kyber) the \n', '     * USDC for an equal value of the liquidate tokens.\n', '     * 3. Pay down the liquidate amount, liquidateBorrow(). CompFi will award an equal \n', "     * value from the unsafe account's collateral + incentive reward.\n", '     * 4. Swap the received collateral tokens for USDC.\n', '     * 5. Repay the flash loan with the USDC.\n', '     * 6. Transfer what is left of the USDC to the Msg.sender.\n', '     * \n', '     **************************************************************************************/\n', '    function callFunction(\n', '        address, /* sender */\n', '        Info calldata, /* accountInfo */\n', '        bytes calldata data\n', '    ) external onlyPool {\n', '\t\n', '\t    // Decode the parameters in "calldata" as passed by doCompFiLiquidate.\n', '        (address flashToken, \n', '        uint256 flashAmount, \n', '        address targetAccount, \n', '        address targetToken, \n', '        uint256 liquidateAmount,\n', '        address collateralToken) = \n', '\t\t\tabi.decode(data, (address, uint256, address, address, uint256, address));\n', '\t\t\n', '\t\tERC20 cFlashToken = ERC20(flashToken);\n', '\n', '\t\temit Borrowed(flashToken, cFlashToken.balanceOf(address(this)));\n', '\n', '\t\trequire(cFlashToken.balanceOf(address(this)) >= flashAmount ,"Contract did not get the loan");\n', '\t\t\n', '        // function approve(address _spender, uint256 _value) public returns (bool success)\n', '\t\tERC20 underlying = ERC20(cFlashToken.underlying( )); // get a handle for the underlying asset contract\n', '\t\trequire(underlying.approve(address(cFlashToken), flashAmount) == true, \n', '\t\t    "01 approval failed"); // approve the transfer\n', '\t\trequire(cFlashToken.mint(flashAmount) > 0, "01 Mint failed");    // mint the cTokens and assert there is no error\n', '\t\t\n', '\t\tERC20 cTargetToken = ERC20(targetToken);\n', '        // Step 2. Swap USDC for targetToken\n', '        if (targetToken != kcUSDC) {\n', '    \t   require( executeKyberSwap(cFlashToken, flashAmount,\n', '\t            cTargetToken, payable(address(this)), \n', '\t            liquidateAmount) > 0, "02 First Token swap failed");\n', '        }\n', '        \n', '        require(cTargetToken.approve(address(this), liquidateAmount) == true,\n', '            "02 approval failed.");\n', '        \n', '        // Step 3. Pay down the amount borrowed by the unsafe account\n', '\t\t// -- Enter the market for the token to be liquidated\n', '\t\tComptroller ctroll = Comptroller(kUnitroller);\n', '\n', '\t\taddress[] memory cTokens = new address[](1);\n', '\t\tcTokens[0] = targetToken;\n', '\t\tuint[] memory ERRORS = ctroll.enterMarkets(cTokens);\n', '\t\tif (ERRORS[0] != 0) {\n', '            revert("01 Comptroller enter Markets for target token failed. ");\n', '\t\t}\n', '\t\t\n', '\t\tif (targetToken == kcETH){\n', '\t\t    c_or_w_ETH ceTargetToken = c_or_w_ETH(targetToken);\n', '\t\t    ceTargetToken.liquidateBorrow{value: flashAmount}\n', '\t\t        (targetAccount, collateralToken);\n', '\t\t} else {\n', '\t\t    cTargetToken.liquidateBorrow(targetAccount, flashAmount, collateralToken);\n', '\t\t}\n', '\t\trequire(ctroll.exitMarket(targetToken) == 0, \n', '\t\t    "Exit Market of target token failed. ");\n', '\t\t \n', '\t\t// 4. Swap the received collateral tokens back to USDC to repay the flash loan.\n', '\t\tcTokens[0] = collateralToken;\n', '\t\tERRORS = ctroll.enterMarkets(cTokens);\n', '\t\trequire(ERRORS[0] == 0, "02 Comptroller.enter Markets for collateral Token failed.");\n', '\n', '\t\tERC20 cCollateralToken = ERC20(collateralToken);\n', '\t\trequire(cCollateralToken.approve(address(this), cCollateralToken.balanceOf(address(this))) == true,\n', '\t\t    "03 Collateral Token approval failed.");\n', '\t\t    \n', '\t\tif (collateralToken != kcUSDC) {\n', '    \t   require( executeKyberSwap(cCollateralToken, \n', '    \t        cCollateralToken.balanceOf(address(this)),\n', '\t            cTargetToken, payable(address(this)), \n', '\t            899999999999999999) > 0, "02 First Token swap failed");\n', '        }\n', '        \n', '    \t// -- Liquidation is completed in flashloan()\n', '    }\n', '    \n', '    function AccountsAssets ( address LAccount ) external view returns ( address[] memory ){\n', '        Comptroller troll = Comptroller(kUnitroller);\n', '        return troll.getAssetsIn( LAccount );\n', '    }\n', '    \n', '    function changeOwner(address payable newOwner) public onlyOwner {\n', '        owner = newOwner;\n', '        emit ChangedOwner(owner, newOwner);\n', '    }\n', '\n', '    function getTokenBalance(address tokenAddress) external view returns(uint256) {\n', '        ERC20 theToken = ERC20(tokenAddress);\n', '        return theToken.balanceOf(address(this));\n', '    }\n', '    \n', '    function getETHBalance( ) external view returns(uint256) {\n', '        c_or_w_ETH theToken = c_or_w_ETH( 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE );\n', '        return theToken.balanceOf(address(this));\n', '    }\n', '    \n', '    function getCloseFactor() external view returns (uint256)  {\n', '        Comptroller troll = Comptroller(kUnitroller);\n', '        return troll.closeFactorMantissa();\n', '\n', '    }\n', '    \n', '    function VerifyAccountLiquidity( address LAccount ) external view \n', '        returns ( uint256, uint256, uint256 ) {\n', '        \n', '        Comptroller troll = Comptroller(kUnitroller);\n', '        \n', '        return troll.getAccountLiquidity(LAccount);\n', '    }\n', '    \n', '    function withdraw(address token) public onlyOwner returns(bool) {\n', '        uint256 tokenBalance;\n', '        // withdrawing Ether\n', '        if (address(token) == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE) {\n', '            if (address(this).balance > 0){\n', '                tokenBalance = address(this).balance;\n', '                payable(msg.sender).transfer(address(this).balance);\n', '            }\n', '\n', '        } else {\n', '            ERC20 withdrawToken = ERC20(token);\n', '            if (withdrawToken.balanceOf(address(this)) > 0){\n', '                tokenBalance = withdrawToken.balanceOf(address(this));\n', '                require(withdrawToken.transfer(msg.sender, \n', '                    (withdrawToken.balanceOf(address(this)))));\n', '            }\n', '        }\n', '        emit Withdrawn(token, tokenBalance);\n', '        return true;\n', '    }\n', '\n', '    event Borrowed(address tokenborrowed, uint256 amount);\n', '    event ChangedOwner(address payable owner, address payable newOwner);\n', '    event Liquidated(address account, address token, uint256 amount );\n', '    event PassThru( uint256 liquidateampount );\n', '    event Swapped(address fromtoken, uint256 fromamount, address totoken, uint256 toamount);\n', '    event Transfer(address from, address to, uint256 value);\n', '    event Withdrawn(address token, uint256 amount);\n', '\n', '    /***************************************************************************\n', '     * KyberSwap functions\n', '    ****************************************************************************/\n', '    /// Swap from srcToken to destToken (including ether)\n', '    function executeKyberSwap( ERC20 cSrcToken, uint256 srcQty, ERC20 cDestToken, \n', '        address payable destAddress, uint256 maxDestAmount\n', '    ) internal returns ( uint256 ) {\n', '        \n', '        // if not Ethereum\n', '        if (address(cSrcToken) != kETH) {\n', '\n', '            // mitigate ERC20 Approve front-running attack, by initially setting\n', '            // allowance to 0\n', '            require(cSrcToken.approve(address(cKyberProxy), 0), "approval to 0 failed");\n', '\n', "            // set the spender's token allowance to tokenQty\n", '            require(cSrcToken.approve(address(cKyberProxy), srcQty), "approval to srcQty failed");\n', '        }\n', '\n', '        // Get the minimum conversion rate\n', '        uint256 platformFeeBps = 25;    // using the Kyber example https://developer.kyber.network/docs/Integrations-SmartContractGuide/#fetching-rates\n', '        \n', '        uint256 minConversionRate = cKyberProxy.getExpectedRateAfterFee(\n', '            cSrcToken,\n', '            cDestToken,\n', '            srcQty,\n', '            platformFeeBps,\n', "            '' // empty hint\n", '        );\n', '        \n', '        \n', '        /*********************************************************************************\n', '         * function trade(ERC20 src, uint256 srcAmount,\n', '         *  ERC20 dest, address payable destAddress,\n', '         *  uint256 maxDestAmount,    // wei\n', '         * \n', '         *  uint256 minConversionRate,\n', '         *      Minimum conversion rate (in wei). Trade is canceled if actual rate is lower\n', '         *      Should match makerAssetAmount/takerAssetAmount\n', '         *      This rate means for every 1 srcAmount, a Minimum\n', '         *      of X target Tokens are expected. \n', '         *      (Source token value / Target Token value) * 10**18 \n', '         * \n', '         *  address payable platformWallet ) external payable returns (uint256);\n', '        **********************************************************************************/\n', '        // Execute the trade and send to this contract to use to pay down the unsafe account\n', '        uint256 destAmount = cKyberProxy.trade(cSrcToken, srcQty, \n', '            cDestToken, payable(address(this)), \n', '            maxDestAmount, \n', '            minConversionRate,\n', '            // this contract\n', '            destAddress);\n', '          \n', '        emit Swapped(address(cSrcToken), srcQty, address(cDestToken), destAmount);\n', '        return destAmount;\n', '    }\n', '}\n', '\n', '// These definitions are taken from across multiple dydx contracts, and are\n', '// limited to just the bare minimum necessary to make flash loans work.\n', 'library Types {\n', '    enum AssetDenomination { Wei, Par }\n', '    enum AssetReference { Delta, Target }\n', '    struct AssetAmount {\n', '        bool sign;\n', '        AssetDenomination denomination;\n', '        AssetReference ref;\n', '        uint256 value;\n', '    }\n', '}\n', '\n', 'library Account {\n', '    struct Info {\n', '        address owner;\n', '        uint256 number;\n', '    }\n', '}\n', '\n', 'library Actions {\n', '    enum ActionType {\n', '        Deposit, Withdraw, Transfer, Buy, Sell, Trade, Liquidate, Vaporize, Call\n', '    }\n', '    struct ActionArgs {\n', '        ActionType actionType;\n', '        uint256 accountId;\n', '        Types.AssetAmount amount;\n', '        uint256 primaryMarketId;\n', '        uint256 secondaryMarketId;\n', '        address otherAddress;\n', '        uint256 otherAccountId;\n', '        bytes data;\n', '    }\n', '}']