['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-05\n', '*/\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '/**\n', ' *  __  __           _     _ _\n', ' * |  \\/  |         | |   (_) |\n', ' * | \\  / | ___  ___| |__  _| |_ ___\n', " * | |\\/| |/ _ \\/ _ \\ '_ \\| | __/ __|\n", ' * | |  | |  __/  __/ |_) | | |_\\__ \\\n', ' * |_|  |_|\\___|\\___|_.__/|_|\\__|___/\n', ' *\n', ' * An NFT project from Larva Labs.\n', ' *\n', ' */\n', 'interface IERC165 {\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', 'interface IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n', '    function transferFrom(address from, address to, uint256 tokenId) external;\n', '    function approve(address to, uint256 tokenId) external;\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '    function setApprovalForAll(address operator, bool _approved) external;\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n', '}\n', '\n', '/**\n', ' * Minimal interface to Cryptopunks for verifying ownership during Community Grant.\n', ' */\n', 'interface Cryptopunks {\n', '    function punkIndexToAddress(uint index) external view returns(address);\n', '}\n', '\n', 'interface ERC721TokenReceiver\n', '{\n', '    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    /**\n', '    * @dev Multiplies two numbers, throws on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '        c = a * b;\n', '        require(c / a == b);\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two numbers, truncating the quotient.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // assert(b > 0); // Solidity automatically throws when dividing by 0\n', '        // uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '        return a / b;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two numbers, throws on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '        return c;\n', '    }\n', '}\n', '\n', 'contract Meebits is IERC721 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    /**\n', '     * Event emitted when minting a new NFT. "createdVia" is the index of the Cryptopunk/Autoglyph that was used to mint, or 0 if not applicable.\n', '     */\n', '    event Mint(uint indexed index, address indexed minter, uint createdVia);\n', '\n', '    /**\n', '     * Event emitted when a trade is executed.\n', '     */\n', '    event Trade(bytes32 indexed hash, address indexed maker, address taker, uint makerWei, uint[] makerIds, uint takerWei, uint[] takerIds);\n', '\n', '    /**\n', '     * Event emitted when ETH is deposited into the contract.\n', '     */\n', '    event Deposit(address indexed account, uint amount);\n', '\n', '    /**\n', '     * Event emitted when ETH is withdrawn from the contract.\n', '     */\n', '    event Withdraw(address indexed account, uint amount);\n', '\n', '    /**\n', '     * Event emitted when a trade offer is cancelled.\n', '     */\n', '    event OfferCancelled(bytes32 hash);\n', '\n', '    /**\n', '     * Event emitted when the public sale begins.\n', '     */\n', '    event SaleBegins();\n', '\n', '    /**\n', '     * Event emitted when the community grant period ends.\n', '     */\n', '    event CommunityGrantEnds();\n', '\n', '    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    // IPFS Hash to the NFT content\n', '    string public contentHash = "QmfXYgfX1qNfzQ6NRyFnupniZusasFPMeiWn5aaDnx7YXo";\n', '\n', '    uint public constant TOKEN_LIMIT = 20000;\n', '    uint public constant SALE_LIMIT = 9000;\n', '\n', '    mapping(bytes4 => bool) internal supportedInterfaces;\n', '\n', '    mapping (uint256 => address) internal idToOwner;\n', '\n', '    mapping (uint256 => uint256) public creatorNftMints;\n', '\n', '    mapping (uint256 => address) internal idToApproval;\n', '\n', '    mapping (address => mapping (address => bool)) internal ownerToOperators;\n', '\n', '    mapping(address => uint256[]) internal ownerToIds;\n', '\n', '    mapping(uint256 => uint256) internal idToOwnerIndex;\n', '\n', '    string internal nftName = "Meebits";\n', '    string internal nftSymbol = unicode"âš‡";\n', '\n', '    uint internal numTokens = 0;\n', '    uint internal numSales = 0;\n', '\n', '    // Cryptopunks contract\n', '    address internal punks;\n', '\n', '    // Autoglyphs contract\n', '    address internal glyphs;\n', '\n', '    address payable internal deployer;\n', '    address payable internal beneficiary;\n', '    bool public communityGrant = true;\n', '    bool public publicSale = false;\n', '    uint private price;\n', '    uint public saleStartTime;\n', '    uint public saleDuration;\n', '\n', '    //// Random index assignment\n', '    uint internal nonce = 0;\n', '    uint[TOKEN_LIMIT] internal indices;\n', '\n', '    //// Market\n', '    bool public marketPaused;\n', '    bool public contractSealed;\n', '    mapping (address => uint256) public ethBalance;\n', '    mapping (bytes32 => bool) public cancelledOffers;\n', '\n', '    modifier onlyDeployer() {\n', '        require(msg.sender == deployer, "Only deployer.");\n', '        _;\n', '    }\n', '\n', '    bool private reentrancyLock = false;\n', '\n', '    /* Prevent a contract function from being reentrant-called. */\n', '    modifier reentrancyGuard {\n', '        if (reentrancyLock) {\n', '            revert();\n', '        }\n', '        reentrancyLock = true;\n', '        _;\n', '        reentrancyLock = false;\n', '    }\n', '\n', '    modifier canOperate(uint256 _tokenId) {\n', '        address tokenOwner = idToOwner[_tokenId];\n', '        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], "Cannot operate.");\n', '        _;\n', '    }\n', '\n', '    modifier canTransfer(uint256 _tokenId) {\n', '        address tokenOwner = idToOwner[_tokenId];\n', '        require(\n', '            tokenOwner == msg.sender\n', '            || idToApproval[_tokenId] == msg.sender\n', '            || ownerToOperators[tokenOwner][msg.sender], "Cannot transfer."\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier validNFToken(uint256 _tokenId) {\n', '        require(idToOwner[_tokenId] != address(0), "Invalid token.");\n', '        _;\n', '    }\n', '\n', '    constructor(address _punks, address _glyphs, address payable _beneficiary) {\n', '        supportedInterfaces[0x01ffc9a7] = true; // ERC165\n', '        supportedInterfaces[0x80ac58cd] = true; // ERC721\n', '        supportedInterfaces[0x780e9d63] = true; // ERC721 Enumerable\n', '        supportedInterfaces[0x5b5e139f] = true; // ERC721 Metadata\n', '        deployer = msg.sender;\n', '        punks = _punks;\n', '        glyphs = _glyphs;\n', '        beneficiary = _beneficiary;\n', '    }\n', '\n', '    function startSale(uint _price, uint _saleDuration) external onlyDeployer {\n', '        require(!publicSale);\n', '        price = _price;\n', '        saleDuration = _saleDuration;\n', '        saleStartTime = block.timestamp;\n', '        publicSale = true;\n', '        emit SaleBegins();\n', '    }\n', '\n', '    function endCommunityGrant() external onlyDeployer {\n', '        require(communityGrant);\n', '        communityGrant = false;\n', '        emit CommunityGrantEnds();\n', '    }\n', '\n', '    function pauseMarket(bool _paused) external onlyDeployer {\n', '        require(!contractSealed, "Contract sealed.");\n', '        marketPaused = _paused;\n', '    }\n', '\n', '    function sealContract() external onlyDeployer {\n', '        contractSealed = true;\n', '    }\n', '\n', '    //////////////////////////\n', '    //// ERC 721 and 165  ////\n', '    //////////////////////////\n', '\n', '    function isContract(address _addr) internal view returns (bool addressCheck) {\n', '        uint256 size;\n', '        assembly { size := extcodesize(_addr) } // solhint-disable-line\n', '        addressCheck = size > 0;\n', '    }\n', '\n', '    function supportsInterface(bytes4 _interfaceID) external view override returns (bool) {\n', '        return supportedInterfaces[_interfaceID];\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external override {\n', '        _safeTransferFrom(_from, _to, _tokenId, _data);\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external override {\n', '        _safeTransferFrom(_from, _to, _tokenId, "");\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external override canTransfer(_tokenId) validNFToken(_tokenId) {\n', '        address tokenOwner = idToOwner[_tokenId];\n', '        require(tokenOwner == _from, "Wrong from address.");\n', '        require(_to != address(0), "Cannot send to 0x0.");\n', '        _transfer(_to, _tokenId);\n', '    }\n', '\n', '    function approve(address _approved, uint256 _tokenId) external override canOperate(_tokenId) validNFToken(_tokenId) {\n', '        address tokenOwner = idToOwner[_tokenId];\n', '        require(_approved != tokenOwner);\n', '        idToApproval[_tokenId] = _approved;\n', '        emit Approval(tokenOwner, _approved, _tokenId);\n', '    }\n', '\n', '    function setApprovalForAll(address _operator, bool _approved) external override {\n', '        ownerToOperators[msg.sender][_operator] = _approved;\n', '        emit ApprovalForAll(msg.sender, _operator, _approved);\n', '    }\n', '\n', '    function balanceOf(address _owner) external view override returns (uint256) {\n', '        require(_owner != address(0));\n', '        return _getOwnerNFTCount(_owner);\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) external view override returns (address _owner) {\n', '        require(idToOwner[_tokenId] != address(0));\n', '        _owner = idToOwner[_tokenId];\n', '    }\n', '\n', '    function getApproved(uint256 _tokenId) external view override validNFToken(_tokenId) returns (address) {\n', '        return idToApproval[_tokenId];\n', '    }\n', '\n', '    function isApprovedForAll(address _owner, address _operator) external override view returns (bool) {\n', '        return ownerToOperators[_owner][_operator];\n', '    }\n', '\n', '    function _transfer(address _to, uint256 _tokenId) internal {\n', '        address from = idToOwner[_tokenId];\n', '        _clearApproval(_tokenId);\n', '\n', '        _removeNFToken(from, _tokenId);\n', '        _addNFToken(_to, _tokenId);\n', '\n', '        emit Transfer(from, _to, _tokenId);\n', '    }\n', '\n', '    function randomIndex() internal returns (uint) {\n', '        uint totalSize = TOKEN_LIMIT - numTokens;\n', '        uint index = uint(keccak256(abi.encodePacked(nonce, msg.sender, block.difficulty, block.timestamp))) % totalSize;\n', '        uint value = 0;\n', '        if (indices[index] != 0) {\n', '            value = indices[index];\n', '        } else {\n', '            value = index;\n', '        }\n', '\n', '        // Move last value to selected position\n', '        if (indices[totalSize - 1] == 0) {\n', '            // Array position not initialized, so use position\n', '            indices[index] = totalSize - 1;\n', '        } else {\n', '            // Array position holds a value so use that\n', '            indices[index] = indices[totalSize - 1];\n', '        }\n', '        nonce++;\n', "        // Don't allow a zero index, start counting at 1\n", '        return value.add(1);\n', '    }\n', '\n', '    // Calculate the mint price\n', '    function getPrice() public view returns (uint) {\n', '        require(publicSale, "Sale not started.");\n', '        uint elapsed = block.timestamp.sub(saleStartTime);\n', '        if (elapsed >= saleDuration) {\n', '            return 0;\n', '        } else {\n', '            return saleDuration.sub(elapsed).mul(price).div(saleDuration);\n', '        }\n', '    }\n', '\n', '    // The deployer can mint in bulk without paying\n', '    function devMint(uint quantity, address recipient) external onlyDeployer {\n', '        for (uint i = 0; i < quantity; i++) {\n', '            _mint(recipient, 0);\n', '        }\n', '    }\n', '\n', '    function mintsRemaining() external view returns (uint) {\n', '        return SALE_LIMIT.sub(numSales);\n', '    }\n', '\n', '    /**\n', '     * Community grant minting.\n', '     */\n', '    function mintWithPunkOrGlyph(uint _createVia) external reentrancyGuard returns (uint) {\n', '        require(communityGrant);\n', '        require(!marketPaused);\n', '        require(_createVia > 0 && _createVia <= 10512, "Invalid punk/glyph index.");\n', '        require(creatorNftMints[_createVia] == 0, "Already minted with this punk/glyph");\n', '        if (_createVia > 10000) {\n', "            // It's a glyph\n", '            // Compute the glyph ID\n', '            uint glyphId = _createVia.sub(10000);\n', '            // Make sure the sender owns the glyph\n', '            require(IERC721(glyphs).ownerOf(glyphId) == msg.sender, "Not the owner of this glyph.");\n', '        } else {\n', "            // It's a punk\n", '            // Compute the punk ID\n', '            uint punkId = _createVia.sub(1);\n', '            // Make sure the sender owns the punk\n', '            require(Cryptopunks(punks).punkIndexToAddress(punkId) == msg.sender, "Not the owner of this punk.");\n', '        }\n', '        creatorNftMints[_createVia]++;\n', '        return _mint(msg.sender, _createVia);\n', '    }\n', '\n', '    /**\n', '     * Public sale minting.\n', '     */\n', '    function mint() external payable reentrancyGuard returns (uint) {\n', '        require(publicSale, "Sale not started.");\n', '        require(!marketPaused);\n', '        require(numSales < SALE_LIMIT, "Sale limit reached.");\n', '        uint salePrice = getPrice();\n', '        require(msg.value >= salePrice, "Insufficient funds to purchase.");\n', '        if (msg.value > salePrice) {\n', '            msg.sender.transfer(msg.value.sub(salePrice));\n', '        }\n', '        beneficiary.transfer(salePrice);\n', '        numSales++;\n', '        return _mint(msg.sender, 0);\n', '    }\n', '\n', '    function _mint(address _to, uint createdVia) internal returns (uint) {\n', '        require(_to != address(0), "Cannot mint to 0x0.");\n', '        require(numTokens < TOKEN_LIMIT, "Token limit reached.");\n', '        uint id = randomIndex();\n', '\n', '        numTokens = numTokens + 1;\n', '        _addNFToken(_to, id);\n', '\n', '        emit Mint(id, _to, createdVia);\n', '        emit Transfer(address(0), _to, id);\n', '        return id;\n', '    }\n', '\n', '    function _addNFToken(address _to, uint256 _tokenId) internal {\n', '        require(idToOwner[_tokenId] == address(0), "Cannot add, already owned.");\n', '        idToOwner[_tokenId] = _to;\n', '\n', '        ownerToIds[_to].push(_tokenId);\n', '        idToOwnerIndex[_tokenId] = ownerToIds[_to].length.sub(1);\n', '    }\n', '\n', '    function _removeNFToken(address _from, uint256 _tokenId) internal {\n', '        require(idToOwner[_tokenId] == _from, "Incorrect owner.");\n', '        delete idToOwner[_tokenId];\n', '\n', '        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\n', '        uint256 lastTokenIndex = ownerToIds[_from].length.sub(1);\n', '\n', '        if (lastTokenIndex != tokenToRemoveIndex) {\n', '            uint256 lastToken = ownerToIds[_from][lastTokenIndex];\n', '            ownerToIds[_from][tokenToRemoveIndex] = lastToken;\n', '            idToOwnerIndex[lastToken] = tokenToRemoveIndex;\n', '        }\n', '\n', '        ownerToIds[_from].pop();\n', '    }\n', '\n', '    function _getOwnerNFTCount(address _owner) internal view returns (uint256) {\n', '        return ownerToIds[_owner].length;\n', '    }\n', '\n', '    function _safeTransferFrom(address _from,  address _to,  uint256 _tokenId,  bytes memory _data) private canTransfer(_tokenId) validNFToken(_tokenId) {\n', '        address tokenOwner = idToOwner[_tokenId];\n', '        require(tokenOwner == _from, "Incorrect owner.");\n', '        require(_to != address(0));\n', '\n', '        _transfer(_to, _tokenId);\n', '\n', '        if (isContract(_to)) {\n', '            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n', '            require(retval == MAGIC_ON_ERC721_RECEIVED);\n', '        }\n', '    }\n', '\n', '    function _clearApproval(uint256 _tokenId) private {\n', '        if (idToApproval[_tokenId] != address(0)) {\n', '            delete idToApproval[_tokenId];\n', '        }\n', '    }\n', '\n', '    //// Enumerable\n', '\n', '    function totalSupply() public view returns (uint256) {\n', '        return numTokens;\n', '    }\n', '\n', '    function tokenByIndex(uint256 index) public pure returns (uint256) {\n', '        require(index >= 0 && index < TOKEN_LIMIT);\n', '        return index + 1;\n', '    }\n', '\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\n', '        require(_index < ownerToIds[_owner].length);\n', '        return ownerToIds[_owner][_index];\n', '    }\n', '\n', '    //// Metadata\n', '\n', '    /**\n', '      * @dev Converts a `uint256` to its ASCII `string` representation.\n', '      */\n', '    function toString(uint256 value) internal pure returns (string memory) {\n', '        if (value == 0) {\n', '            return "0";\n', '        }\n', '        uint256 temp = value;\n', '        uint256 digits;\n', '        while (temp != 0) {\n', '            digits++;\n', '            temp /= 10;\n', '        }\n', '        bytes memory buffer = new bytes(digits);\n', '        uint256 index = digits - 1;\n', '        temp = value;\n', '        while (temp != 0) {\n', '            buffer[index--] = bytes1(uint8(48 + temp % 10));\n', '            temp /= 10;\n', '        }\n', '        return string(buffer);\n', '    }\n', '\n', '    /**\n', '      * @dev Returns a descriptive name for a collection of NFTokens.\n', '      * @return _name Representing name.\n', '      */\n', '    function name() external view returns (string memory _name) {\n', '        _name = nftName;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an abbreviated name for NFTokens.\n', '     * @return _symbol Representing symbol.\n', '     */\n', '    function symbol() external view returns (string memory _symbol) {\n', '        _symbol = nftSymbol;\n', '    }\n', '\n', '    /**\n', '     * @dev A distinct URI (RFC 3986) for a given NFT.\n', '     * @param _tokenId Id for which we want uri.\n', '     * @return _tokenId URI of _tokenId.\n', '     */\n', '    function tokenURI(uint256 _tokenId) external view validNFToken(_tokenId) returns (string memory) {\n', '        return string(abi.encodePacked("https://meebits.larvalabs.com/meebit/", toString(_tokenId)));\n', '    }\n', '\n', '    //// MARKET\n', '\n', '    struct Offer {\n', '        address maker;\n', '        address taker;\n', '        uint256 makerWei;\n', '        uint256[] makerIds;\n', '        uint256 takerWei;\n', '        uint256[] takerIds;\n', '        uint256 expiry;\n', '        uint256 salt;\n', '    }\n', '\n', '    function hashOffer(Offer memory offer) private pure returns (bytes32){\n', '        return keccak256(abi.encode(\n', '                    offer.maker,\n', '                    offer.taker,\n', '                    offer.makerWei,\n', '                    keccak256(abi.encodePacked(offer.makerIds)),\n', '                    offer.takerWei,\n', '                    keccak256(abi.encodePacked(offer.takerIds)),\n', '                    offer.expiry,\n', '                    offer.salt\n', '                ));\n', '    }\n', '\n', '    function hashToSign(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) public pure returns (bytes32) {\n', '        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n', '        return hashOffer(offer);\n', '    }\n', '\n', '    function hashToVerify(Offer memory offer) private pure returns (bytes32) {\n', '        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hashOffer(offer)));\n', '    }\n', '\n', '    function verify(address signer, bytes32 hash, bytes memory signature) internal pure returns (bool) {\n', '        require(signer != address(0));\n', '        require(signature.length == 65);\n', '\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '\n', '        assembly {\n', '            r := mload(add(signature, 32))\n', '            s := mload(add(signature, 64))\n', '            v := byte(0, mload(add(signature, 96)))\n', '        }\n', '\n', '        if (v < 27) {\n', '            v += 27;\n', '        }\n', '\n', '        require(v == 27 || v == 28);\n', '\n', '        return signer == ecrecover(hash, v, r, s);\n', '    }\n', '\n', '    function tradeValid(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) view public returns (bool) {\n', '        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n', '        // Check for cancellation\n', '        bytes32 hash = hashOffer(offer);\n', '        require(cancelledOffers[hash] == false, "Trade offer was cancelled.");\n', '        // Verify signature\n', '        bytes32 verifyHash = hashToVerify(offer);\n', '        require(verify(offer.maker, verifyHash, signature), "Signature not valid.");\n', '        // Check for expiry\n', '        require(block.timestamp < offer.expiry, "Trade offer expired.");\n', '        // Only one side should ever have to pay, not both\n', '        require(makerWei == 0 || takerWei == 0, "Only one side of trade must pay.");\n', '        // At least one side should offer tokens\n', '        require(makerIds.length > 0 || takerIds.length > 0, "One side must offer tokens.");\n', '        // Make sure the maker has funded the trade\n', '        require(ethBalance[offer.maker] >= offer.makerWei, "Maker does not have sufficient balance.");\n', '        // Ensure the maker owns the maker tokens\n', '        for (uint i = 0; i < offer.makerIds.length; i++) {\n', '            require(idToOwner[offer.makerIds[i]] == offer.maker, "At least one maker token doesn\'t belong to maker.");\n', '        }\n', '        // If the taker can be anybody, then there can be no taker tokens\n', '        if (offer.taker == address(0)) {\n', "            // If taker not specified, then can't specify IDs\n", '            require(offer.takerIds.length == 0, "If trade is offered to anybody, cannot specify tokens from taker.");\n', '        } else {\n', '            // Ensure the taker owns the taker tokens\n', '            for (uint i = 0; i < offer.takerIds.length; i++) {\n', '                require(idToOwner[offer.takerIds[i]] == offer.taker, "At least one taker token doesn\'t belong to taker.");\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    function cancelOffer(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) external {\n', '        require(maker == msg.sender, "Only the maker can cancel this offer.");\n', '        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n', '        bytes32 hash = hashOffer(offer);\n', '        cancelledOffers[hash] = true;\n', '        emit OfferCancelled(hash);\n', '    }\n', '\n', '    function acceptTrade(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) external payable reentrancyGuard {\n', '        require(!marketPaused, "Market is paused.");\n', '        require(msg.sender != maker, "Can\'t accept ones own trade.");\n', '        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n', '        if (msg.value > 0) {\n', '            ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);\n', '            emit Deposit(msg.sender, msg.value);\n', '        }\n', '        require(offer.taker == address(0) || offer.taker == msg.sender, "Not the recipient of this offer.");\n', '        require(tradeValid(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt, signature), "Trade not valid.");\n', '        require(ethBalance[msg.sender] >= offer.takerWei, "Insufficient funds to execute trade.");\n', '        // Transfer ETH\n', '        ethBalance[offer.maker] = ethBalance[offer.maker].sub(offer.makerWei);\n', '        ethBalance[msg.sender] = ethBalance[msg.sender].add(offer.makerWei);\n', '        ethBalance[msg.sender] = ethBalance[msg.sender].sub(offer.takerWei);\n', '        ethBalance[offer.maker] = ethBalance[offer.maker].add(offer.takerWei);\n', '        // Transfer maker ids to taker (msg.sender)\n', '        for (uint i = 0; i < makerIds.length; i++) {\n', '            _transfer(msg.sender, makerIds[i]);\n', '        }\n', '        // Transfer taker ids to maker\n', '        for (uint i = 0; i < takerIds.length; i++) {\n', '            _transfer(maker, takerIds[i]);\n', '        }\n', '        // Prevent a replay attack on this offer\n', '        bytes32 hash = hashOffer(offer);\n', '        cancelledOffers[hash] = true;\n', '        emit Trade(hash, offer.maker, msg.sender, offer.makerWei, offer.makerIds, offer.takerWei, offer.takerIds);\n', '    }\n', '\n', '    function withdraw(uint amount) external reentrancyGuard {\n', '        require(amount <= ethBalance[msg.sender]);\n', '        ethBalance[msg.sender] = ethBalance[msg.sender].sub(amount);\n', '        (bool success, ) = msg.sender.call{value:amount}("");\n', '        require(success);\n', '        emit Withdraw(msg.sender, amount);\n', '    }\n', '\n', '    function deposit() external payable {\n', '        ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '}']