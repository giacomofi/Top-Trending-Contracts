['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./IFeeManager.sol";\n', '\n', '/// @title Fee Interface\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Interface for all fees\n', 'interface IFee {\n', '    function activateForFund(address _comptrollerProxy, address _vaultProxy) external;\n', '\n', '    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData) external;\n', '\n', '    function identifier() external pure returns (string memory identifier_);\n', '\n', '    function implementedHooks()\n', '        external\n', '        view\n', '        returns (\n', '            IFeeManager.FeeHook[] memory implementedHooksForSettle_,\n', '            IFeeManager.FeeHook[] memory implementedHooksForUpdate_,\n', '            bool usesGavOnSettle_,\n', '            bool usesGavOnUpdate_\n', '        );\n', '\n', '    function payout(address _comptrollerProxy, address _vaultProxy)\n', '        external\n', '        returns (bool isPayable_);\n', '\n', '    function settle(\n', '        address _comptrollerProxy,\n', '        address _vaultProxy,\n', '        IFeeManager.FeeHook _hook,\n', '        bytes calldata _settlementData,\n', '        uint256 _gav\n', '    )\n', '        external\n', '        returns (\n', '            IFeeManager.SettlementType settlementType_,\n', '            address payer_,\n', '            uint256 sharesDue_\n', '        );\n', '\n', '    function update(\n', '        address _comptrollerProxy,\n', '        address _vaultProxy,\n', '        IFeeManager.FeeHook _hook,\n', '        bytes calldata _settlementData,\n', '        uint256 _gav\n', '    ) external;\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/// @title FeeManager Interface\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Interface for the FeeManager\n', 'interface IFeeManager {\n', '    // No fees for the current release are implemented post-redeemShares\n', '    enum FeeHook {\n', '        Continuous,\n', '        BuySharesSetup,\n', '        PreBuyShares,\n', '        PostBuyShares,\n', '        BuySharesCompleted,\n', '        PreRedeemShares\n', '    }\n', '    enum SettlementType {None, Direct, Mint, Burn, MintSharesOutstanding, BurnSharesOutstanding}\n', '\n', '    function invokeHook(\n', '        FeeHook,\n', '        bytes calldata,\n', '        uint256\n', '    ) external;\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "./utils/EntranceRateFeeBase.sol";\n', '\n', '/// @title EntranceRateDirectFee Contract\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice An EntranceRateFee that transfers the fee shares to the fund manager\n', 'contract EntranceRateDirectFee is EntranceRateFeeBase {\n', '    constructor(address _feeManager)\n', '        public\n', '        EntranceRateFeeBase(_feeManager, IFeeManager.SettlementType.Direct)\n', '    {}\n', '\n', '    /// @notice Provides a constant string identifier for a fee\n', '    /// @return identifier_ The identifier string\n', '    function identifier() external pure override returns (string memory identifier_) {\n', '        return "ENTRANCE_RATE_DIRECT";\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "@openzeppelin/contracts/math/SafeMath.sol";\n', 'import "./FeeBase.sol";\n', '\n', '/// @title EntranceRateFeeBase Contract\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Calculates a fee based on a rate to be charged to an investor upon entering a fund\n', 'abstract contract EntranceRateFeeBase is FeeBase {\n', '    using SafeMath for uint256;\n', '\n', '    event FundSettingsAdded(address indexed comptrollerProxy, uint256 rate);\n', '\n', '    event Settled(address indexed comptrollerProxy, address indexed payer, uint256 sharesQuantity);\n', '\n', '    uint256 private constant RATE_DIVISOR = 10**18;\n', '    IFeeManager.SettlementType private immutable SETTLEMENT_TYPE;\n', '\n', '    mapping(address => uint256) private comptrollerProxyToRate;\n', '\n', '    constructor(address _feeManager, IFeeManager.SettlementType _settlementType)\n', '        public\n', '        FeeBase(_feeManager)\n', '    {\n', '        require(\n', '            _settlementType == IFeeManager.SettlementType.Burn ||\n', '                _settlementType == IFeeManager.SettlementType.Direct,\n', '            "constructor: Invalid _settlementType"\n', '        );\n', '        SETTLEMENT_TYPE = _settlementType;\n', '    }\n', '\n', '    // EXTERNAL FUNCTIONS\n', '\n', '    /// @notice Add the fee settings for a fund\n', '    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n', '    /// @param _settingsData Encoded settings to apply to the policy for a fund\n', '    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\n', '        external\n', '        override\n', '        onlyFeeManager\n', '    {\n', '        uint256 rate = abi.decode(_settingsData, (uint256));\n', '        require(rate > 0, "addFundSettings: Fee rate must be >0");\n', '\n', '        comptrollerProxyToRate[_comptrollerProxy] = rate;\n', '\n', '        emit FundSettingsAdded(_comptrollerProxy, rate);\n', '    }\n', '\n', '    /// @notice Gets the hooks that are implemented by the fee\n', '    /// @return implementedHooksForSettle_ The hooks during which settle() is implemented\n', '    /// @return implementedHooksForUpdate_ The hooks during which update() is implemented\n', '    /// @return usesGavOnSettle_ True if GAV is used during the settle() implementation\n', '    /// @return usesGavOnUpdate_ True if GAV is used during the update() implementation\n', '    /// @dev Used only during fee registration\n', '    function implementedHooks()\n', '        external\n', '        view\n', '        override\n', '        returns (\n', '            IFeeManager.FeeHook[] memory implementedHooksForSettle_,\n', '            IFeeManager.FeeHook[] memory implementedHooksForUpdate_,\n', '            bool usesGavOnSettle_,\n', '            bool usesGavOnUpdate_\n', '        )\n', '    {\n', '        implementedHooksForSettle_ = new IFeeManager.FeeHook[](1);\n', '        implementedHooksForSettle_[0] = IFeeManager.FeeHook.PostBuyShares;\n', '\n', '        return (implementedHooksForSettle_, new IFeeManager.FeeHook[](0), false, false);\n', '    }\n', '\n', '    /// @notice Settles the fee\n', '    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n', '    /// @param _settlementData Encoded args to use in calculating the settlement\n', '    /// @return settlementType_ The type of settlement\n', '    /// @return payer_ The payer of shares due\n', '    /// @return sharesDue_ The amount of shares due\n', '    function settle(\n', '        address _comptrollerProxy,\n', '        address,\n', '        IFeeManager.FeeHook,\n', '        bytes calldata _settlementData,\n', '        uint256\n', '    )\n', '        external\n', '        override\n', '        onlyFeeManager\n', '        returns (\n', '            IFeeManager.SettlementType settlementType_,\n', '            address payer_,\n', '            uint256 sharesDue_\n', '        )\n', '    {\n', '        uint256 sharesBought;\n', '        (payer_, , sharesBought) = __decodePostBuySharesSettlementData(_settlementData);\n', '\n', '        uint256 rate = comptrollerProxyToRate[_comptrollerProxy];\n', '        sharesDue_ = sharesBought.mul(rate).div(RATE_DIVISOR.add(rate));\n', '\n', '        if (sharesDue_ == 0) {\n', '            return (IFeeManager.SettlementType.None, address(0), 0);\n', '        }\n', '\n', '        emit Settled(_comptrollerProxy, payer_, sharesDue_);\n', '\n', '        return (SETTLEMENT_TYPE, payer_, sharesDue_);\n', '    }\n', '\n', '    ///////////////////\n', '    // STATE GETTERS //\n', '    ///////////////////\n', '\n', '    /// @notice Gets the `rate` variable for a fund\n', '    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n', '    /// @return rate_ The `rate` variable value\n', '    function getRateForFund(address _comptrollerProxy) external view returns (uint256 rate_) {\n', '        return comptrollerProxyToRate[_comptrollerProxy];\n', '    }\n', '\n', '    /// @notice Gets the `SETTLEMENT_TYPE` variable\n', '    /// @return settlementType_ The `SETTLEMENT_TYPE` variable value\n', '    function getSettlementType()\n', '        external\n', '        view\n', '        returns (IFeeManager.SettlementType settlementType_)\n', '    {\n', '        return SETTLEMENT_TYPE;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '/*\n', '    This file is part of the Enzyme Protocol.\n', '\n', '    (c) Enzyme Council <[email\xa0protected]>\n', '\n', '    For the full license information, please view the LICENSE\n', '    file that was distributed with this source code.\n', '*/\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'import "../../IFee.sol";\n', '\n', '/// @title FeeBase Contract\n', '/// @author Enzyme Council <[email\xa0protected]>\n', '/// @notice Abstract base contract for all fees\n', 'abstract contract FeeBase is IFee {\n', '    address internal immutable FEE_MANAGER;\n', '\n', '    modifier onlyFeeManager {\n', '        require(msg.sender == FEE_MANAGER, "Only the FeeManger can make this call");\n', '        _;\n', '    }\n', '\n', '    constructor(address _feeManager) public {\n', '        FEE_MANAGER = _feeManager;\n', '    }\n', '\n', '    /// @notice Allows Fee to run logic during fund activation\n', '    /// @dev Unimplemented by default, may be overrode.\n', '    function activateForFund(address, address) external virtual override {\n', '        return;\n', '    }\n', '\n', '    /// @notice Runs payout logic for a fee that utilizes shares outstanding as its settlement type\n', '    /// @dev Returns false by default, can be overridden by fee\n', '    function payout(address, address) external virtual override returns (bool) {\n', '        return false;\n', '    }\n', '\n', '    /// @notice Update fee state after all settlement has occurred during a given fee hook\n', '    /// @dev Unimplemented by default, can be overridden by fee\n', '    function update(\n', '        address,\n', '        address,\n', '        IFeeManager.FeeHook,\n', '        bytes calldata,\n', '        uint256\n', '    ) external virtual override {\n', '        return;\n', '    }\n', '\n', '    /// @notice Helper to parse settlement arguments from encoded data for PreBuyShares fee hook\n', '    function __decodePreBuySharesSettlementData(bytes memory _settlementData)\n', '        internal\n', '        pure\n', '        returns (\n', '            address buyer_,\n', '            uint256 investmentAmount_,\n', '            uint256 minSharesQuantity_\n', '        )\n', '    {\n', '        return abi.decode(_settlementData, (address, uint256, uint256));\n', '    }\n', '\n', '    /// @notice Helper to parse settlement arguments from encoded data for PreRedeemShares fee hook\n', '    function __decodePreRedeemSharesSettlementData(bytes memory _settlementData)\n', '        internal\n', '        pure\n', '        returns (address redeemer_, uint256 sharesQuantity_)\n', '    {\n', '        return abi.decode(_settlementData, (address, uint256));\n', '    }\n', '\n', '    /// @notice Helper to parse settlement arguments from encoded data for PostBuyShares fee hook\n', '    function __decodePostBuySharesSettlementData(bytes memory _settlementData)\n', '        internal\n', '        pure\n', '        returns (\n', '            address buyer_,\n', '            uint256 investmentAmount_,\n', '            uint256 sharesBought_\n', '        )\n', '    {\n', '        return abi.decode(_settlementData, (address, uint256, uint256));\n', '    }\n', '\n', '    ///////////////////\n', '    // STATE GETTERS //\n', '    ///////////////////\n', '\n', '    /// @notice Gets the `FEE_MANAGER` variable\n', '    /// @return feeManager_ The `FEE_MANAGER` variable value\n', '    function getFeeManager() external view returns (address feeManager_) {\n', '        return FEE_MANAGER;\n', '    }\n', '}\n', '\n', '{\n', '  "evmVersion": "istanbul",\n', '  "libraries": {},\n', '  "metadata": {\n', '    "bytecodeHash": "ipfs",\n', '    "useLiteralContent": true\n', '  },\n', '  "optimizer": {\n', '    "details": {\n', '      "constantOptimizer": true,\n', '      "cse": true,\n', '      "deduplicate": true,\n', '      "jumpdestRemover": true,\n', '      "orderLiterals": true,\n', '      "peephole": true,\n', '      "yul": false\n', '    },\n', '    "runs": 200\n', '  },\n', '  "remappings": [],\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']