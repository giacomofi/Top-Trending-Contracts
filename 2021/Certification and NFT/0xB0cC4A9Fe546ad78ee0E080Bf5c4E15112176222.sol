['// SPDX-License-Identifier: U-U-U-UPPPPP!!!\n', 'pragma solidity ^0.7.4;\n', '\n', '/* ROOTKIT:\n', 'A floor calculator to use with ERC31337 AMM pairs\n', 'Ensures 100% of accessible funds are backed at all times\n', '*/\n', '\n', 'import "./IERC20.sol";\n', 'import "./SafeMath.sol";\n', 'import "./EnumerableSet.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./IUniswapV2Router02.sol";\n', 'import "./TokensRecoverable.sol";\n', 'import "./IFloorCalculator.sol";\n', '\n', 'contract ThreeStableCoinPoolsCalculator is IFloorCalculator, TokensRecoverable\n', '{\n', '    using SafeMath for uint256;\n', '    using EnumerableSet for EnumerableSet.AddressSet;\n', '\n', '    IERC20 immutable rootedToken;\n', '    IERC20 immutable fiatToken;\n', '    address immutable rootedElitePair;\n', '    address immutable rootedBasePair;\n', '    address immutable rootedFiatPair;\n', '    IUniswapV2Router02 immutable uniswapV2Router;\n', '    EnumerableSet.AddressSet ignoredAddresses;\n', '\n', '    constructor(IERC20 _rootedToken, IERC20 _eliteToken, IERC20 _baseToken, IERC20 _fiatToken, IUniswapV2Factory _uniswapV2Factory, IUniswapV2Router02 _uniswapV2Router)\n', '    {\n', '        rootedToken = _rootedToken;\n', '        fiatToken = _fiatToken;\n', '        uniswapV2Router = _uniswapV2Router;\n', '\n', '        address _rootedElitePair = _uniswapV2Factory.getPair(address(_eliteToken), address(_rootedToken));\n', '        rootedElitePair = _rootedElitePair;\n', '        address _rootedBasePair = _uniswapV2Factory.getPair(address(_baseToken), address(_rootedToken));\n', '        rootedBasePair = _rootedBasePair;\n', '        address _rootedFiatPair = _uniswapV2Factory.getPair(address(_fiatToken), address(_rootedToken));\n', '        rootedFiatPair = _rootedFiatPair;\n', '    }    \n', '\n', '    function setIgnoreAddresses(address ignoredAddress, bool add) public ownerOnly()\n', '    {\n', '        if (add) \n', '        { \n', '            ignoredAddresses.add(ignoredAddress); \n', '        } \n', '        else \n', '        { \n', '            ignoredAddresses.remove(ignoredAddress); \n', '        }\n', '    }\n', '\n', '    function isIgnoredAddress(address ignoredAddress) public view returns (bool)\n', '    {\n', '        return ignoredAddresses.contains(ignoredAddress);\n', '    }\n', '\n', '    function ignoredAddressCount() public view returns (uint256)\n', '    {\n', '        return ignoredAddresses.length();\n', '    }\n', '\n', '    function ignoredAddressAt(uint256 index) public view returns (address)\n', '    {\n', '        return ignoredAddresses.at(index);\n', '    }\n', '\n', '    function ignoredAddressesTotalBalance() public view returns (uint256)\n', '    {\n', '        uint256 total = 0;\n', '        for (uint i = 0; i < ignoredAddresses.length(); i++) \n', '        {\n', '            total = total.add(rootedToken.balanceOf(ignoredAddresses.at(i)));\n', '        }\n', '\n', '        return total;\n', '    }\n', '\n', '    function calculateSubFloor(IERC20 baseToken, IERC20 eliteToken) public override view returns (uint256)\n', '    {\n', '        uint256 totalRootedInPairs = rootedToken.balanceOf(rootedElitePair).add(rootedToken.balanceOf(rootedBasePair)).add(rootedToken.balanceOf(rootedFiatPair));\n', '        uint256 totalStableInPairs = eliteToken.balanceOf(rootedElitePair).add(baseToken.balanceOf(rootedBasePair)).add(fiatToken.balanceOf(rootedFiatPair).div(1e12));\n', '        uint256 rootedCirculatingSupply = rootedToken.totalSupply().sub(totalRootedInPairs).sub(ignoredAddressesTotalBalance());\n', '        uint256 amountUntilFloor = uniswapV2Router.getAmountOut(rootedCirculatingSupply, totalRootedInPairs, totalStableInPairs);\n', '\n', '        uint256 totalExcessInPools = totalStableInPairs.sub(amountUntilFloor);\n', '        uint256 previouslySwept = eliteToken.totalSupply().sub(baseToken.balanceOf(address(eliteToken)));\n', '        \n', '        if (previouslySwept >= totalExcessInPools) { return 0; }\n', '\n', '        return totalExcessInPools.sub(previouslySwept);\n', '    }\n', '}']