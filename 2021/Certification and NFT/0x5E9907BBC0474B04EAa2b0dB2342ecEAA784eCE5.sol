['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-28\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.3;\n', '\n', '\n', '/**\n', ' * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n', ' * deploying minimal proxy contracts, also known as "clones".\n', ' *\n', ' * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n', ' * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n', ' *\n', ' * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n', ' * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n', ' * deterministic method.\n', ' *\n', ' * _Available since v3.4._\n', ' */\n', 'library Clones {\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create opcode, which should never revert.\n', '     */\n', '    function clone(address implementation) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create(0, ptr, 0x37)\n', '        }\n', '        require(instance != address(0), "ERC1167: create failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n', '     *\n', '     * This function uses the create2 opcode and a `salt` to deterministically deploy\n', '     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n', '     * the clones cannot be deployed twice at the same address.\n', '     */\n', '    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n', '            instance := create2(0, ptr, 0x37, salt)\n', '        }\n', '        require(instance != address(0), "ERC1167: create2 failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n', '            mstore(add(ptr, 0x14), shl(0x60, implementation))\n', '            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n', '            mstore(add(ptr, 0x38), shl(0x60, deployer))\n', '            mstore(add(ptr, 0x4c), salt)\n', '            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n', '            predicted := keccak256(add(ptr, 0x37), 0x55)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n', '     */\n', '    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\n', '        return predictDeterministicAddress(implementation, salt, address(this));\n', '    }\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '\n', 'contract Governance is ReentrancyGuard {\n', '\n', '\tuint constant public governance_challenging_period = 10 days;\n', '\tuint constant public governance_freeze_period = 30 days;\n', '\n', '\taddress public votingTokenAddress;\n', '\taddress public governedContractAddress;\n', '\n', '\tmapping(address => uint) public balances;\n', '\n', '\tVotedValue[] public votedValues;\n', '\tmapping(string => VotedValue) public votedValuesMap;\n', '\n', '\n', '\tconstructor(address _governedContractAddress, address _votingTokenAddress){\n', '\t\tinit(_governedContractAddress, _votingTokenAddress);\n', '\t}\n', '\n', '\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\n', '\t\trequire(governedContractAddress == address(0), "governance already initialized");\n', '\t\tgovernedContractAddress = _governedContractAddress;\n', '\t\tvotingTokenAddress = _votingTokenAddress;\n', '\t}\n', '\n', '\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\n', '\t\tfor (uint i = 0; i < votedValues.length; i++)\n', '\t\t\tif (address(votedValues[i]) == addr)\n', '\t\t\t\treturn true;\n', '\t\treturn false;\n', '\t}\n', '\n', '\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\n', '\t\tfor (uint i = 0; i < votedValues.length; i++)\n', '\t\t\tif (votedValues[i].hasVote(addr))\n', '\t\t\t\treturn false;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\n', '\t\trequire(msg.sender == governedContractAddress, "not authorized");\n', '\t\tvotedValues.push(votedValue);\n', '\t\tvotedValuesMap[name] = votedValue;\n', '\t}\n', '\n', '\n', '\t// deposit\n', '\n', '\tfunction deposit(uint amount) payable external {\n', '\t\tdeposit(msg.sender, amount);\n', '\t}\n', '\n', '\tfunction deposit(address from, uint amount) nonReentrant payable public {\n', '\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), "not allowed");\n', '\t\tif (votingTokenAddress == address(0))\n', '\t\t\trequire(msg.value == amount, "wrong amount received");\n', '\t\telse {\n', '\t\t\trequire(msg.value == 0, "don\'t send ETH");\n', '\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), "failed to pull gov deposit");\n', '\t\t}\n', '\t\tbalances[from] += amount;\n', '\t}\n', '\n', '\n', '\t// withdrawal functions\n', '\n', '\tfunction withdraw() external {\n', '\t\twithdraw(balances[msg.sender]);\n', '\t}\n', '\n', '\tfunction withdraw(uint amount) nonReentrant public {\n', '\t\trequire(amount > 0, "zero withdrawal requested");\n', '\t\trequire(amount <= balances[msg.sender], "not enough balance");\n', '\t\trequire(isUntiedFromAllVotes(msg.sender), "some votes not removed yet");\n', '\t\tbalances[msg.sender] -= amount;\n', '\t\tif (votingTokenAddress == address(0))\n', '\t\t\tpayable(msg.sender).transfer(amount);\n', '\t\telse\n', '\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), "failed to withdraw gov deposit");\n', '\t}\n', '}\n', '\n', '\n', 'abstract contract VotedValue is ReentrancyGuard {\n', '\tGovernance public governance;\n', '\tuint public challenging_period_start_ts;\n', '\tmapping(address => bool) public hasVote;\n', '\n', '\tconstructor(Governance _governance){\n', '\t\tgovernance = _governance;\n', '\t}\n', '\n', '\tfunction checkVoteChangeLock() view public {\n', '\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, "you cannot change your vote yet");\n', '\t}\n', '\n', '\tfunction checkChallengingPeriodExpiry() view public {\n', '\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), "challenging period not expired yet");\n', '\t}\n', '}\n', '\n', '\n', 'contract VotedValueUint is VotedValue {\n', '\n', '\tfunction(uint) external validationCallback;\n', '\tfunction(uint) external commitCallback;\n', '\n', '\tuint public leader;\n', '\tuint public current_value;\n', '\n', '\tmapping(address => uint) public choices;\n', '\tmapping(uint => uint) public votesByValue;\n', '\tmapping(uint => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction vote(uint value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(uint value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(uint value) private {\n', '\t\tvalidationCallback(value);\n', '\t\tuint prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\n', '\t\t// first, remove votes from the previous choice\n', '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add them to the new choice\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[value] += balance;\n', '\t\tvotesByValueAddress[value][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[value] > votesByValue[leader]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\tuint prev_choice = choices[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(uint value) internal {\n', '\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\n', '\t\tvotesByValueAddress[value][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(leader != current_value, "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract VotedValueUintArray is VotedValue {\n', '\n', '\tfunction(uint[] memory) external validationCallback;\n', '\tfunction(uint[] memory) external commitCallback;\n', '\n', '\tuint[] public leader;\n', '\tuint[] public current_value;\n', '\n', '\tmapping(address => uint[]) public choices;\n', '\tmapping(bytes32 => uint) public votesByValue;\n', '\tmapping(bytes32 => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction equal(uint[] memory a1, uint[] memory a2) public pure returns (bool) {\n', '\t\tif (a1.length != a2.length)\n', '\t\t\treturn false;\n', '\t\tfor (uint i = 0; i < a1.length; i++)\n', '\t\t\tif (a1[i] != a2[i])\n', '\t\t\t\treturn false;\n', '\t\treturn true;\n', '\t}\n', '\n', '\tfunction getKey(uint[] memory a) public pure returns (bytes32){\n', '\t\treturn keccak256(abi.encodePacked(a));\n', '\t}\n', '\n', '\tfunction vote(uint[] memory value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(uint[] memory value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(uint[] memory value) private {\n', '\t\tvalidationCallback(value);\n', '\t\tuint[] storage prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (equal(prev_choice, leader))\n', '\t\t\tcheckVoteChangeLock();\n', '\n', "\t\t// remove one's vote from the previous choice first\n", '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add it to the new choice, if any\n', '\t\tbytes32 key = getKey(value);\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[key] += balance;\n', '\t\tvotesByValueAddress[key][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[key] > votesByValue[getKey(leader)]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\tuint[] storage prev_choice = choices[msg.sender];\n', '\t\tif (equal(prev_choice, leader))\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(uint[] memory value) internal {\n', '\t\tbytes32 key = getKey(value);\n', '\t\tvotesByValue[key] -= votesByValueAddress[key][msg.sender];\n', '\t\tvotesByValueAddress[key][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(!equal(leader, current_value), "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', '\n', 'contract VotedValueAddress is VotedValue {\n', '\n', '\tfunction(address) external validationCallback;\n', '\tfunction(address) external commitCallback;\n', '\n', '\taddress public leader;\n', '\taddress public current_value;\n', '\n', '\t// mapping(who => value)\n', '\tmapping(address => address) public choices;\n', '\n', '\t// mapping(value => votes)\n', '\tmapping(address => uint) public votesByValue;\n', '\n', '\t// mapping(value => mapping(who => votes))\n', '\tmapping(address => mapping(address => uint)) public votesByValueAddress;\n', '\n', '\tconstructor() VotedValue(Governance(address(0))) {}\n', '\n', '\t// constructor(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) VotedValue(_governance) {\n', '\t// \tleader = initial_value;\n', '\t// \tcurrent_value = initial_value;\n', '\t// \tvalidationCallback = _validationCallback;\n', '\t// \tcommitCallback = _commitCallback;\n', '\t// }\n', '\n', '\tfunction init(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) external {\n', '\t\trequire(address(governance) == address(0), "already initialized");\n', '\t\tgovernance = _governance;\n', '\t\tleader = initial_value;\n', '\t\tcurrent_value = initial_value;\n', '\t\tvalidationCallback = _validationCallback;\n', '\t\tcommitCallback = _commitCallback;\n', '\t}\n', '\n', '\tfunction vote(address value) nonReentrant external {\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction voteAndDeposit(address value, uint amount) nonReentrant payable external {\n', '\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\n', '\t\t_vote(value);\n', '\t}\n', '\n', '\tfunction _vote(address value) private {\n', '\t\tvalidationCallback(value);\n', '\t\taddress prev_choice = choices[msg.sender];\n', '\t\tbool hadVote = hasVote[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\n', '\t\t// first, remove votes from the previous choice\n', '\t\tif (hadVote)\n', '\t\t\tremoveVote(prev_choice);\n', '\n', '\t\t// then, add them to the new choice\n', '\t\tuint balance = governance.balances(msg.sender);\n', '\t\trequire(balance > 0, "no balance");\n', '\t\tvotesByValue[value] += balance;\n', '\t\tvotesByValueAddress[value][msg.sender] = balance;\n', '\t\tchoices[msg.sender] = value;\n', '\t\thasVote[msg.sender] = true;\n', '\n', '\t\t// check if the leader has just changed\n', '\t\tif (votesByValue[value] > votesByValue[leader]){\n', '\t\t\tleader = value;\n', '\t\t\tchallenging_period_start_ts = block.timestamp;\n', '\t\t}\n', '\t}\n', '\n', '\tfunction unvote() external {\n', '\t\tif (!hasVote[msg.sender])\n', '\t\t\treturn;\n', '\t\taddress prev_choice = choices[msg.sender];\n', '\t\tif (prev_choice == leader)\n', '\t\t\tcheckVoteChangeLock();\n', '\t\t\n', '\t\tremoveVote(prev_choice);\n', '\t\tdelete choices[msg.sender];\n', '\t\tdelete hasVote[msg.sender];\n', '\t}\n', '\n', '\tfunction removeVote(address value) internal {\n', '\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\n', '\t\tvotesByValueAddress[value][msg.sender] = 0;\n', '\t}\n', '\n', '\tfunction commit() nonReentrant external {\n', '\t\trequire(leader != current_value, "already equal to leader");\n', '\t\tcheckChallengingPeriodExpiry();\n', '\t\tcurrent_value = leader;\n', '\t\tcommitCallback(leader);\n', '\t}\n', '}\n', '\n', '\n', 'contract VotedValueFactory {\n', '\n', '\taddress public votedValueUintMaster;\n', '\taddress public votedValueUintArrayMaster;\n', '\taddress public votedValueAddressMaster;\n', '\n', '\tconstructor(address _votedValueUintMaster, address _votedValueUintArrayMaster, address _votedValueAddressMaster) {\n', '\t\tvotedValueUintMaster = _votedValueUintMaster;\n', '\t\tvotedValueUintArrayMaster = _votedValueUintArrayMaster;\n', '\t\tvotedValueAddressMaster = _votedValueAddressMaster;\n', '\t}\n', '\n', '\n', '\tfunction createVotedValueUint(Governance governance, uint initial_value, function(uint) external validationCallback, function(uint) external commitCallback) external returns (VotedValueUint) {\n', '\t\tVotedValueUint vv = VotedValueUint(Clones.clone(votedValueUintMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '\tfunction createVotedValueUintArray(Governance governance, uint[] memory initial_value, function(uint[] memory) external validationCallback, function(uint[] memory) external commitCallback) external returns (VotedValueUintArray) {\n', '\t\tVotedValueUintArray vv = VotedValueUintArray(Clones.clone(votedValueUintArrayMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '\tfunction createVotedValueAddress(Governance governance, address initial_value, function(address) external validationCallback, function(address) external commitCallback) external returns (VotedValueAddress) {\n', '\t\tVotedValueAddress vv = VotedValueAddress(Clones.clone(votedValueAddressMaster));\n', '\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\n', '\t\treturn vv;\n', '\t}\n', '\n', '}']