['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-19\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.4;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'struct PoolParams {\n', '    string poolTokenSymbol;\n', '    string poolTokenName;\n', '    address[] constituentTokens;\n', '    uint256[] tokenBalances;\n', '    uint256[] tokenWeights;\n', '    uint256 swapFee;\n', '}\n', '\n', 'struct Rights {\n', '    bool canPauseSwapping;\n', '    bool canChangeSwapFee;\n', '    bool canChangeWeights;\n', '    bool canAddRemoveTokens;\n', '    bool canWhitelistLPs;\n', '    bool canChangeCap;\n', '}\n', '\n', 'library BalancerConstants {\n', '    uint256 public constant BONE = 10**18;\n', '}\n', '\n', 'interface IConfigurableRightsPool is IERC20 {\n', '    function whitelistLiquidityProvider(address provider) external;\n', '\n', '    function setController(address newOwner) external;\n', '    function getController() external returns (address);\n', '\n', '    function createPool(\n', '        uint256 initialSupply,\n', '        uint256 minimumWeightChangeBlockPeriodParam,\n', '        uint256 addTokenTimeLockInBlocksParam\n', '    ) external;\n', '\n', '    function updateWeightsGradually(\n', '        uint256[] calldata newWeights,\n', '        uint256 startBlock,\n', '        uint256 endBlock\n', '    ) external;\n', '\n', '    function bPool() external view returns (address);\n', '    function pokeWeights() external;\n', '    function setPublicSwap(bool) external;\n', '}\n', '\n', 'interface ICRPFactory {\n', '    function newCrp(\n', '        address factoryAddress,\n', '        PoolParams calldata poolParams,\n', '        Rights calldata rights\n', '    ) external returns (IConfigurableRightsPool);\n', '}\n', '\n', 'interface IERC20Decimal is IERC20 {\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', 'contract RadicleLbp {\n', '    IERC20Decimal public immutable radToken;\n', '    IERC20Decimal public immutable usdcToken;\n', '    Sale public immutable sale;\n', '\n', '    uint256 public constant RAD_BALANCE = 3750000e18; // 3.75 million RAD\n', '    uint256 public constant USDC_BALANCE = 3500000e6; // 3.5 million USDC\n', '    uint256 public constant RAD_WEIGHT = 37;\n', '    uint256 public constant USDC_WEIGHT = 3;\n', '    uint256 public constant SWAP_FEE = 5e15; // 0.5%\n', '\n', '    constructor(\n', '        address bFactory,\n', '        address crpFactory,\n', '        IERC20Decimal _radToken,\n', '        IERC20Decimal _usdcToken,\n', '        address lp\n', '    ) {\n', '        ICRPFactory factory = ICRPFactory(crpFactory);\n', '\n', '        // RAD starting balance and weight.\n', '        uint256 radTokenWeight = RAD_WEIGHT * BalancerConstants.BONE;\n', '\n', '        // USDC starting balance and weight.\n', '        uint256 usdcTokenWeight = USDC_WEIGHT * BalancerConstants.BONE;\n', '\n', '        // Permissions on the pool.\n', '        Rights memory rights;\n', '        rights.canPauseSwapping = true;\n', '        rights.canChangeSwapFee = false;\n', '        rights.canChangeWeights = true;\n', '        rights.canAddRemoveTokens = false;\n', '        rights.canWhitelistLPs = true;\n', '        rights.canChangeCap = false;\n', '\n', '        // Pool parameters.\n', '        PoolParams memory params;\n', '        params.poolTokenSymbol = "RADP";\n', '        params.poolTokenName = "RAD Pool Token";\n', '\n', '        params.constituentTokens = new address[](2);\n', '        params.tokenBalances = new uint256[](2);\n', '        params.tokenWeights = new uint256[](2);\n', '\n', '        params.constituentTokens[0] = address(_radToken);\n', '        params.tokenBalances[0] = RAD_BALANCE;\n', '        params.tokenWeights[0] = radTokenWeight;\n', '\n', '        params.constituentTokens[1] = address(_usdcToken);\n', '        params.tokenBalances[1] = USDC_BALANCE;\n', '        params.tokenWeights[1] = usdcTokenWeight;\n', '        params.swapFee = SWAP_FEE;\n', '\n', '        IConfigurableRightsPool _crpPool = factory.newCrp(bFactory, params, rights);\n', '\n', '        // Create the sale contract and transfer ownership of the CRP to the sale contract.\n', '        Sale _sale = new Sale(_crpPool, _radToken, _usdcToken, RAD_BALANCE, USDC_BALANCE, lp);\n', '        _crpPool.setController(address(_sale));\n', '\n', '        sale = _sale;\n', '        radToken = _radToken;\n', '        usdcToken = _usdcToken;\n', '    }\n', '}\n', '\n', 'contract Sale {\n', '    IConfigurableRightsPool public immutable crpPool;\n', '\n', '    uint256 public immutable radTokenBalance;\n', '    uint256 public immutable usdcTokenBalance;\n', '\n', '    IERC20 public immutable radToken;\n', '    IERC20 public immutable usdcToken;\n', '\n', '    uint256 public constant RAD_END_WEIGHT = 20;\n', '    uint256 public constant USDC_END_WEIGHT = 20;\n', '\n', '    address lp;\n', '\n', '    constructor(\n', '        IConfigurableRightsPool _crpPool,\n', '        IERC20 _radToken,\n', '        IERC20 _usdcToken,\n', '        uint256 _radTokenBalance,\n', '        uint256 _usdcTokenBalance,\n', '        address _lp\n', '    ) {\n', '        crpPool = _crpPool;\n', '        radToken = _radToken;\n', '        usdcToken = _usdcToken;\n', '        radTokenBalance = _radTokenBalance;\n', '        usdcTokenBalance = _usdcTokenBalance;\n', '        lp = _lp;\n', '    }\n', '\n', '    /// Begin the sale. Transfers balances from the sender into the\n', '    /// Balancer pool, and transfers the pool tokens to the sender.\n', '    function begin(\n', '        uint256 minimumWeightChangeBlockPeriod,\n', '        uint256 weightChangeStartDelay,\n', '        address controller\n', '    ) public {\n', '        require(\n', '            msg.sender == lp,\n', '            "Sale::begin: only the LP can call this function"\n', '        );\n', '        require(\n', '            controller != address(0),\n', '            "Sale::begin: the controller must be set"\n', '        );\n', '        require(\n', '            radToken.transferFrom(msg.sender, address(this), radTokenBalance),\n', '            "Sale::begin: transfer of RAD must succeed"\n', '        );\n', '        require(\n', '            usdcToken.transferFrom(msg.sender, address(this), usdcTokenBalance),\n', '            "Sale::begin: transfer of USDC must succeed"\n', '        );\n', '        require(\n', '            crpPool.getController() == address(this),\n', '            "Sale::begin: sale must be controller"\n', '        );\n', '\n', '        radToken.approve(address(crpPool), radTokenBalance);\n', '        usdcToken.approve(address(crpPool), usdcTokenBalance);\n', '\n', '        // How many pool tokens to mint.\n', '        uint256 poolTokens = 100 * BalancerConstants.BONE;\n', '\n', '        crpPool.createPool(\n', '          poolTokens,\n', '          minimumWeightChangeBlockPeriod,\n', '          0\n', '        );\n', '\n', '        require(\n', '            crpPool.totalSupply() == poolTokens,\n', '            "Sale::begin: pool tokens must match total supply"\n', '        );\n', '\n', '        uint256[] memory endWeights = new uint256[](2);\n', '        endWeights[0] = RAD_END_WEIGHT * BalancerConstants.BONE;\n', '        endWeights[1] = USDC_END_WEIGHT * BalancerConstants.BONE;\n', '\n', '        // Start and end of the weight/price curve.\n', '        uint256 startBlock = block.number + weightChangeStartDelay;\n', '        uint256 endBlock = startBlock + minimumWeightChangeBlockPeriod;\n', '\n', '        // Kick-off the price curve.\n', '        crpPool.updateWeightsGradually(endWeights, startBlock, endBlock);\n', '        // Transfer ownership of the pool tokens to the sender.\n', '        crpPool.transfer(msg.sender, poolTokens);\n', '        // Set the pool controller, who can pause the sale.\n', '        crpPool.setController(controller);\n', '    }\n', '}']