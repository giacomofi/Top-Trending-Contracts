['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-03\n', '*/\n', '\n', '// SPDX-License-Identifier: SEE LICENSE IN LICENSE\n', '\n', 'pragma abicoder v2;\n', 'pragma solidity >=0.7.6;\n', '\n', 'interface IStakePoolCreator {\n', '    function version() external returns (uint256);\n', '\n', '    function create() external returns (address);\n', '\n', '    function initialize(\n', '        address poolAddress,\n', '        address pair,\n', '        address rewardToken,\n', '        address timelock,\n', '        address stakePoolRewardFund,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', 'interface IValueLiquidRouter {\n', '    struct Swap {\n', '        address pool;\n', '        address tokenIn;\n', '        address tokenOut;\n', '        uint256 swapAmount; // tokenInAmount / tokenOutAmount\n', '        uint256 limitReturnAmount; // minAmountOut / maxAmountIn\n', '        uint256 maxPrice;\n', '        bool isBPool;\n', '    }\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function controller() external view returns (address);\n', '\n', '    function formula() external view returns (address);\n', '\n', '    function WETH() external view returns (address);\n', '\n', '    function addLiquidity(\n', '        address pair,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addLiquidityETH(\n', '        address pair,\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function swapExactTokensForTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactETHForTokens(\n', '        address tokenOut,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapTokensForExactETH(\n', '        address tokenIn,\n', '        uint256 amountOut,\n', '        uint256 amountInMax,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForETH(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external returns (uint256[] memory amounts);\n', '\n', '    function swapETHForExactTokens(\n', '        address tokenOut,\n', '        uint256 amountOut,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256[] memory amounts);\n', '\n', '    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external;\n', '\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        address tokenOut,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable;\n', '\n', '    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n', '        address tokenIn,\n', '        uint256 amountIn,\n', '        uint256 amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external;\n', '\n', '    function addStakeLiquidity(\n', '        address stakePool,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountADesired,\n', '        uint256 amountBDesired,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        returns (\n', '            uint256 amountA,\n', '            uint256 amountB,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function addStakeLiquidityETH(\n', '        address stakePool,\n', '        address token,\n', '        uint256 amountTokenDesired,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        uint256 deadline\n', '    )\n', '        external\n', '        payable\n', '        returns (\n', '            uint256 amountToken,\n', '            uint256 amountETH,\n', '            uint256 liquidity\n', '        );\n', '\n', '    function multihopBatchSwapExactIn(\n', '        Swap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 totalAmountIn,\n', '        uint256 minTotalAmountOut,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256 totalAmountOut);\n', '\n', '    function multihopBatchSwapExactOut(\n', '        Swap[][] memory swapSequences,\n', '        address tokenIn,\n', '        address tokenOut,\n', '        uint256 maxTotalAmountIn,\n', '        uint256 deadline,\n', '        uint8 flag\n', '    ) external payable returns (uint256 totalAmountIn);\n', '\n', '    function createPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 amountA,\n', '        uint256 amountB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee,\n', '        address to,\n', '        uint8 flag\n', '    ) external returns (uint256 liquidity);\n', '\n', '    function createPairETH(\n', '        address token,\n', '        uint256 amountToken,\n', '        uint32 tokenWeight,\n', '        uint32 swapFee,\n', '        address to,\n', '        uint8 flag\n', '    ) external payable returns (uint256 liquidity);\n', '}\n', '\n', 'interface IValueLiquidFactory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint32 tokenWeight0, uint32 swapFee, uint256);\n', '\n', '    function feeTo() external view returns (address);\n', '\n', '    function formula() external view returns (address);\n', '\n', '    function protocolFee() external view returns (uint256);\n', '\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee\n', '    ) external view returns (address pair);\n', '\n', '    function allPairs(uint256) external view returns (address pair);\n', '\n', '    function isPair(address) external view returns (bool);\n', '\n', '    function allPairsLength() external view returns (uint256);\n', '\n', '    function createPair(\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee\n', '    ) external returns (address pair);\n', '\n', '    function getWeightsAndSwapFee(address pair)\n', '        external\n', '        view\n', '        returns (\n', '            uint32 tokenWeight0,\n', '            uint32 tokenWeight1,\n', '            uint32 swapFee\n', '        );\n', '\n', '    function setFeeTo(address) external;\n', '\n', '    function setFeeToSetter(address) external;\n', '\n', '    function setProtocolFee(uint256) external;\n', '}\n', '\n', '// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\n', 'library TransferHelper {\n', '    function safeApprove(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('approve(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: APPROVE_FAILED");\n', '    }\n', '\n', '    function safeTransfer(\n', '        address token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: TRANSFER_FAILED");\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        address token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', "        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n", '        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper: TRANSFER_FROM_FAILED");\n', '    }\n', '\n', '    function safeTransferETH(address to, uint256 value) internal {\n', '        (bool success, ) = to.call{value: value}(new bytes(0));\n', '        require(success, "TransferHelper: ETH_TRANSFER_FAILED");\n', '    }\n', '}\n', '\n', 'interface IValueLiquidPair {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external pure returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    event PaidProtocolFee(uint112 collectedFee0, uint112 collectedFee1);\n', '    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n', '    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n', '    event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to);\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n', '\n', '    function factory() external view returns (address);\n', '\n', '    function token0() external view returns (address);\n', '\n', '    function token1() external view returns (address);\n', '\n', '    function getReserves()\n', '        external\n', '        view\n', '        returns (\n', '            uint112 reserve0,\n', '            uint112 reserve1,\n', '            uint32 blockTimestampLast\n', '        );\n', '\n', '    function getCollectedFees() external view returns (uint112 _collectedFee0, uint112 _collectedFee1);\n', '\n', '    function getTokenWeights() external view returns (uint32 tokenWeight0, uint32 tokenWeight1);\n', '\n', '    function getSwapFee() external view returns (uint32);\n', '\n', '    function price0CumulativeLast() external view returns (uint256);\n', '\n', '    function price1CumulativeLast() external view returns (uint256);\n', '\n', '    function mint(address to) external returns (uint256 liquidity);\n', '\n', '    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n', '\n', '    function swap(\n', '        uint256 amount0Out,\n', '        uint256 amount1Out,\n', '        address to,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function skim(address to) external;\n', '\n', '    function sync() external;\n', '\n', '    function initialize(\n', '        address,\n', '        address,\n', '        uint32,\n', '        uint32\n', '    ) external;\n', '}\n', '\n', '// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n', 'library SafeMath {\n', '    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x + y) >= x, "ds-math-add-overflow");\n', '    }\n', '\n', '    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require((z = x - y) <= x, "ds-math-sub-underflow");\n', '    }\n', '\n', '    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n', '        require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b > 0, "ds-math-division-by-zero");\n', '        c = a / b;\n', '    }\n', '}\n', '\n', 'contract TimeLock {\n', '    using SafeMath for uint256;\n', '    event NewAdmin(address indexed newAdmin);\n', '    event NewPendingAdmin(address indexed newPendingAdmin);\n', '    event NewDelay(uint256 indexed newDelay);\n', '    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n', '\n', '    uint256 public constant GRACE_PERIOD = 14 days;\n', '    uint256 public constant MINIMUM_DELAY = 1 days;\n', '    uint256 public constant MAXIMUM_DELAY = 30 days;\n', '    bool private _initialized;\n', '    address public admin;\n', '    address public pendingAdmin;\n', '    uint256 public delay;\n', '    bool public admin_initialized;\n', '    mapping(bytes32 => bool) public queuedTransactions;\n', '\n', '    constructor() {\n', '        admin_initialized = false;\n', '        _initialized = false;\n', '    }\n', '\n', '    function initialize(address _admin, uint256 _delay) public {\n', '        require(_initialized == false, "Timelock::constructor: Initialized must be false.");\n', '        require(_delay >= MINIMUM_DELAY, "Timelock::setDelay: Delay must exceed minimum delay.");\n', '        require(_delay <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");\n', '        delay = _delay;\n', '        admin = _admin;\n', '        _initialized = true;\n', '        emit NewAdmin(admin);\n', '        emit NewDelay(delay);\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    function setDelay(uint256 _delay) public {\n', '        require(msg.sender == address(this), "Timelock::setDelay: Call must come from Timelock.");\n', '        require(_delay >= MINIMUM_DELAY, "Timelock::setDelay: Delay must exceed minimum delay.");\n', '        require(_delay <= MAXIMUM_DELAY, "Timelock::setDelay: Delay must not exceed maximum delay.");\n', '        delay = _delay;\n', '        emit NewDelay(delay);\n', '    }\n', '\n', '    function acceptAdmin() public {\n', '        require(msg.sender == pendingAdmin, "Timelock::acceptAdmin: Call must come from pendingAdmin.");\n', '        admin = msg.sender;\n', '        pendingAdmin = address(0);\n', '        emit NewAdmin(admin);\n', '    }\n', '\n', '    function setPendingAdmin(address _pendingAdmin) public {\n', '        // allows one time setting of admin for deployment purposes\n', '        if (admin_initialized) {\n', '            require(msg.sender == address(this), "Timelock::setPendingAdmin: Call must come from Timelock.");\n', '        } else {\n', '            require(msg.sender == admin, "Timelock::setPendingAdmin: First call must come from admin.");\n', '            admin_initialized = true;\n', '        }\n', '        pendingAdmin = _pendingAdmin;\n', '\n', '        emit NewPendingAdmin(pendingAdmin);\n', '    }\n', '\n', '    function queueTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public returns (bytes32) {\n', '        require(msg.sender == admin, "Timelock::queueTransaction: Call must come from admin.");\n', '        require(eta >= getBlockTimestamp().add(delay), "Timelock::queueTransaction: Estimated execution block must satisfy delay.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        queuedTransactions[txHash] = true;\n', '\n', '        emit QueueTransaction(txHash, target, value, signature, data, eta);\n', '        return txHash;\n', '    }\n', '\n', '    function cancelTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public {\n', '        require(msg.sender == admin, "Timelock::cancelTransaction: Call must come from admin.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        queuedTransactions[txHash] = false;\n', '\n', '        emit CancelTransaction(txHash, target, value, signature, data, eta);\n', '    }\n', '\n', '    function executeTransaction(\n', '        address target,\n', '        uint256 value,\n', '        string memory signature,\n', '        bytes memory data,\n', '        uint256 eta\n', '    ) public payable returns (bytes memory) {\n', '        require(msg.sender == admin, "Timelock::executeTransaction: Call must come from admin.");\n', '\n', '        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n', '        require(queuedTransactions[txHash], "Timelock::executeTransaction: Transaction hasn\'t been queued.");\n', '        require(getBlockTimestamp() >= eta, "Timelock::executeTransaction: Transaction hasn\'t surpassed time lock.");\n', '        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), "Timelock::executeTransaction: Transaction is stale.");\n', '\n', '        queuedTransactions[txHash] = false;\n', '\n', '        bytes memory callData;\n', '\n', '        if (bytes(signature).length == 0) {\n', '            callData = data;\n', '        } else {\n', '            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n', '        }\n', '\n', '        // solium-disable-next-line security/no-call-value\n', '        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n', '        require(success, "Timelock::executeTransaction: Transaction execution reverted.");\n', '\n', '        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n', '\n', '        return returnData;\n', '    }\n', '\n', '    function getBlockTimestamp() internal view returns (uint256) {\n', '        return block.timestamp;\n', '    }\n', '}\n', '\n', 'interface IEpochController {\n', '    function epoch() external view returns (uint256);\n', '\n', '    function nextEpochPoint() external view returns (uint256);\n', '\n', '    function nextEpochLength() external view returns (uint256);\n', '\n', '    function nextEpochAllocatedReward(address _pool) external view returns (uint256);\n', '}\n', '\n', 'interface IStakePoolEpochReward {\n', '    event AllocateReward(uint256 blocktime, uint256 amount);\n', '    event Deposit(address indexed account, uint256 amount);\n', '    event PayRewardPool(\n', '        uint256 indexed poolId,\n', '        address indexed rewardToken,\n', '        address indexed account,\n', '        uint256 pendingReward,\n', '        uint256 rebaseAmount,\n', '        uint256 paidReward\n', '    );\n', '    event Withdraw(address indexed account, uint256 amount);\n', '\n', '    function version() external view returns (uint256);\n', '\n', '    function pair() external view returns (address);\n', '\n', '    function rewardToken() external view returns (address);\n', '\n', '    function rewardFund() external view returns (address);\n', '\n', '    function epochController() external view returns (address);\n', '\n', '    function allowRecoverRewardToken(address _token) external view returns (bool);\n', '\n', '    function epoch() external view returns (uint256);\n', '\n', '    function nextEpochPoint() external view returns (uint256);\n', '\n', '    function nextEpochLength() external view returns (uint256);\n', '\n', '    function nextEpochAllocatedReward() external view returns (uint256);\n', '\n', '    function earned(address _account) external view returns (uint256);\n', '\n', '    function unlockWithdrawEpoch(address _account) external view returns (uint256);\n', '\n', '    function unlockRewardEpoch(address _account) external view returns (uint256);\n', '\n', '    function stake(uint256) external;\n', '\n', '    function stakeFor(address _account) external;\n', '\n', '    function withdraw(uint256) external;\n', '\n', '    function claimReward() external;\n', '\n', '    function emergencyWithdraw() external;\n', '\n', '    function setEpochController(address) external;\n', '\n', '    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) external;\n', '\n', '    function allocateReward(uint256 _amount) external;\n', '\n', '    function removeLiquidity(\n', '        address provider,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETH(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '}\n', '\n', 'interface IValueLiquidProvider {\n', '    function factory() external view returns (address);\n', '\n', '    function controller() external view returns (address);\n', '\n', '    function formula() external view returns (address);\n', '\n', '    function WETH() external view returns (address);\n', '\n', '    function removeLiquidity(\n', '        address pair,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETH(\n', '        address pair,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityWithPermit(\n', '        address pair,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountA, uint256 amountB);\n', '\n', '    function removeLiquidityETHWithPermit(\n', '        address pair,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountToken, uint256 amountETH);\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address pair,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n', '        address pair,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external returns (uint256 amountETH);\n', '\n', '    function stake(\n', '        address stakePool,\n', '        uint256 amount,\n', '        uint256 deadline\n', '    ) external;\n', '\n', '    function stakeWithPermit(\n', '        address stakePool,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        bool approveMax,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', 'interface IStakePoolController {\n', '    event MasterCreated(address indexed farm, address indexed pair, uint256 version, address timelock, address stakePoolRewardFund, uint256 totalStakePool);\n', '    event SetWhitelistStakingFor(address indexed contractAddress, bool value);\n', '    event SetWhitelistStakePool(address indexed contractAddress, int8 value);\n', '    event SetStakePoolCreator(address indexed contractAddress, uint256 verion);\n', '    event SetWhitelistRewardRebaser(address indexed contractAddress, bool value);\n', '    event SetWhitelistRewardMultiplier(address indexed contractAddress, bool value);\n', '    event SetStakePoolVerifier(address indexed contractAddress, bool value);\n', '    event ChangeGovernance(address indexed governance);\n', '    event SetFeeCollector(address indexed feeCollector);\n', '    event SetFeeToken(address indexed token);\n', '    event SetFeeAmount(uint256 indexed amount);\n', '\n', '    function allStakePools(uint256) external view returns (address stakePool);\n', '\n', '    function isStakePool(address contractAddress) external view returns (bool);\n', '\n', '    function isStakePoolVerifier(address contractAddress) external view returns (bool);\n', '\n', '    function isWhitelistStakingFor(address contractAddress) external view returns (bool);\n', '\n', '    function isWhitelistStakePool(address contractAddress) external view returns (int8);\n', '\n', '    function setStakePoolVerifier(address contractAddress, bool state) external;\n', '\n', '    function setWhitelistStakingFor(address contractAddress, bool state) external;\n', '\n', '    function setWhitelistStakePool(address contractAddress, int8 state) external;\n', '\n', '    function addStakePoolCreator(address contractAddress) external;\n', '\n', '    function isWhitelistRewardRebaser(address contractAddress) external view returns (bool);\n', '\n', '    function isAllowEmergencyWithdrawStakePool(address _address) external view returns (bool);\n', '\n', '    function setWhitelistRewardRebaser(address contractAddress, bool state) external;\n', '\n', '    function isWhitelistRewardMultiplier(address contractAddress) external view returns (bool);\n', '\n', '    function setAllowEmergencyWithdrawStakePool(address _address, bool state) external;\n', '\n', '    function setWhitelistRewardMultiplier(address contractAddress, bool state) external;\n', '\n', '    function setEnableWhitelistRewardRebaser(bool value) external;\n', '\n', '    function setEnableWhitelistRewardMultiplier(bool value) external;\n', '\n', '    function allStakePoolsLength() external view returns (uint256);\n', '\n', '    function create(\n', '        uint256 version,\n', '        address pair,\n', '        address rewardToken,\n', '        uint256 rewardFundAmount,\n', '        uint256 delayTimeLock,\n', '        bytes calldata data,\n', '        uint8 flag\n', '    ) external returns (address);\n', '\n', '    function createPair(\n', '        uint256 version,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint32 tokenWeightA,\n', '        uint32 swapFee,\n', '        address rewardToken,\n', '        uint256 rewardFundAmount,\n', '        uint256 delayTimeLock,\n', '        bytes calldata poolRewardInfo,\n', '        uint8 flag\n', '    ) external returns (address);\n', '\n', '    function setGovernance(address) external;\n', '\n', '    function setFeeCollector(address _address) external;\n', '\n', '    function setFeeToken(address _token) external;\n', '\n', '    function setFeeAmount(uint256 _token) external;\n', '}\n', '\n', 'interface IStakePoolRewardRebaser {\n', '    function getRebaseAmount(address rewardToken, uint256 baseAmount) external view returns (uint256);\n', '}\n', '\n', 'interface IStakePoolRewardMultiplier {\n', '    function getRewardMultiplier(\n', '        uint256 _start,\n', '        uint256 _end,\n', '        uint256 _from,\n', '        uint256 _to,\n', '        uint256 _rewardPerBlock\n', '    ) external view returns (uint256);\n', '}\n', '\n', 'interface IERC20 {\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) external returns (bool);\n', '}\n', '\n', 'interface IStakePoolRewardFund {\n', '    function initialize(address _stakePool, address _timelock) external;\n', '\n', '    function safeTransfer(\n', '        address _token,\n', '        address _to,\n', '        uint256 _value\n', '    ) external;\n', '}\n', '\n', '// This implements BPool contract, and allows for generalized staking, yield farming (by epoch), and token distribution.\n', 'contract StakePoolEpochReward is IStakePoolEpochReward {\n', '    using SafeMath for uint256;\n', '    uint256 public override version;\n', '\n', '    /* ========== DATA STRUCTURES ========== */\n', '\n', '    struct UserInfo {\n', '        uint256 amount;\n', '        uint256 lastSnapshotIndex;\n', '        uint256 rewardEarned;\n', '        uint256 epochTimerStart;\n', '    }\n', '\n', '    struct Snapshot {\n', '        uint256 time;\n', '        uint256 rewardReceived;\n', '        uint256 rewardPerShare;\n', '    }\n', '\n', '    /* ========== STATE VARIABLES ========== */\n', '\n', '    address public override epochController;\n', '    address public override rewardToken;\n', '\n', '    uint256 public withdrawLockupEpochs;\n', '    uint256 public rewardLockupEpochs;\n', '\n', '    mapping(address => UserInfo) public userInfo;\n', '    Snapshot[] public snapshotHistory;\n', '\n', '    address public override pair;\n', '    address public override rewardFund;\n', '    address public timelock;\n', '    address public controller;\n', '\n', '    uint256 public balance;\n', '    uint256 private _unlocked = 1;\n', '    bool private _initialized = false;\n', '    uint256 public constant BLOCKS_PER_DAY = 6528;\n', '\n', '    constructor(address _controller, uint256 _version) {\n', '        controller = _controller;\n', '        timelock = msg.sender;\n', '        version = _version;\n', '        Snapshot memory genesisSnapshot = Snapshot({time: block.number, rewardReceived: 0, rewardPerShare: 0});\n', '        snapshotHistory.push(genesisSnapshot);\n', '    }\n', '\n', '    modifier lock() {\n', '        require(_unlocked == 1, "StakePoolEpochReward: LOCKED");\n', '        _unlocked = 0;\n', '        _;\n', '        _unlocked = 1;\n', '    }\n', '\n', '    modifier onlyTimeLock() {\n', '        require(msg.sender == timelock, "StakePoolEpochReward: !timelock");\n', '        _;\n', '    }\n', '\n', '    modifier onlyEpochController() {\n', '        require(msg.sender == epochController, "StakePoolEpochReward: !epochController");\n', '        _;\n', '    }\n', '\n', '    modifier updateReward(address _account) {\n', '        if (_account != address(0)) {\n', '            UserInfo storage user = userInfo[_account];\n', '            user.rewardEarned = earned(_account);\n', '            user.lastSnapshotIndex = latestSnapshotIndex();\n', '        }\n', '        _;\n', '    }\n', '\n', '    // called once by the factory at time of deployment\n', '    function initialize(\n', '        address _pair,\n', '        address _rewardFund,\n', '        address _timelock,\n', '        address _epochController,\n', '        address _rewardToken,\n', '        uint256 _withdrawLockupEpochs,\n', '        uint256 _rewardLockupEpochs\n', '    ) external {\n', '        require(_initialized == false, "StakePoolEpochReward: Initialize must be false.");\n', '        pair = _pair;\n', '        rewardToken = _rewardToken;\n', '        rewardFund = _rewardFund;\n', '        setEpochController(_epochController);\n', '        setLockUp(_withdrawLockupEpochs, _rewardLockupEpochs);\n', '        timelock = _timelock;\n', '        _initialized = true;\n', '    }\n', '\n', '    /* ========== GOVERNANCE ========== */\n', '\n', '    function setEpochController(address _epochController) public override lock onlyTimeLock {\n', '        epochController = _epochController;\n', '        epoch();\n', '        nextEpochPoint();\n', '        nextEpochLength();\n', '        nextEpochAllocatedReward();\n', '    }\n', '\n', '    function setLockUp(uint256 _withdrawLockupEpochs, uint256 _rewardLockupEpochs) public override lock onlyTimeLock {\n', '        require(_withdrawLockupEpochs >= _rewardLockupEpochs && _withdrawLockupEpochs <= 56, "_withdrawLockupEpochs: out of range"); // <= 2 week\n', '        withdrawLockupEpochs = _withdrawLockupEpochs;\n', '        rewardLockupEpochs = _rewardLockupEpochs;\n', '    }\n', '\n', '    function allocateReward(uint256 _amount) external override lock onlyEpochController {\n', '        require(_amount > 0, "StakePoolEpochReward: Cannot allocate 0");\n', '        uint256 _before = IERC20(rewardToken).balanceOf(address(rewardFund));\n', '        TransferHelper.safeTransferFrom(rewardToken, msg.sender, rewardFund, _amount);\n', '        if (balance > 0) {\n', '            uint256 _after = IERC20(rewardToken).balanceOf(address(rewardFund));\n', '            _amount = _after.sub(_before);\n', '\n', '            // Create & add new snapshot\n', '            uint256 _prevRPS = getLatestSnapshot().rewardPerShare;\n', '            uint256 _nextRPS = _prevRPS.add(_amount.mul(1e18).div(balance));\n', '\n', '            Snapshot memory _newSnapshot = Snapshot({time: block.number, rewardReceived: _amount, rewardPerShare: _nextRPS});\n', '            emit AllocateReward(block.number, _amount);\n', '            snapshotHistory.push(_newSnapshot);\n', '        }\n', '    }\n', '\n', '    function allowRecoverRewardToken(address _token) external view override returns (bool) {\n', '        if (rewardToken == _token) {\n', '            // do not allow to drain reward token if less than 1 months after LatestSnapshot\n', '            if (block.number < (getLatestSnapshot().time + (BLOCKS_PER_DAY * 30))) {\n', '                return false;\n', '            }\n', '        }\n', '        return true;\n', '    }\n', '\n', '    // =========== Epoch getters\n', '\n', '    function epoch() public view override returns (uint256) {\n', '        return IEpochController(epochController).epoch();\n', '    }\n', '\n', '    function nextEpochPoint() public view override returns (uint256) {\n', '        return IEpochController(epochController).nextEpochPoint();\n', '    }\n', '\n', '    function nextEpochLength() public view override returns (uint256) {\n', '        return IEpochController(epochController).nextEpochLength();\n', '    }\n', '\n', '    function nextEpochAllocatedReward() public view override returns (uint256) {\n', '        return IEpochController(epochController).nextEpochAllocatedReward(address(this));\n', '    }\n', '\n', '    // =========== Snapshot getters\n', '\n', '    function latestSnapshotIndex() public view returns (uint256) {\n', '        return snapshotHistory.length.sub(1);\n', '    }\n', '\n', '    function getLatestSnapshot() internal view returns (Snapshot memory) {\n', '        return snapshotHistory[latestSnapshotIndex()];\n', '    }\n', '\n', '    function getLastSnapshotIndexOf(address _account) public view returns (uint256) {\n', '        return userInfo[_account].lastSnapshotIndex;\n', '    }\n', '\n', '    function getLastSnapshotOf(address _account) internal view returns (Snapshot memory) {\n', '        return snapshotHistory[getLastSnapshotIndexOf(_account)];\n', '    }\n', '\n', '    // =========== _account getters\n', '\n', '    function rewardPerShare() public view returns (uint256) {\n', '        return getLatestSnapshot().rewardPerShare;\n', '    }\n', '\n', '    function earned(address _account) public view override returns (uint256) {\n', '        uint256 latestRPS = getLatestSnapshot().rewardPerShare;\n', '        uint256 storedRPS = getLastSnapshotOf(_account).rewardPerShare;\n', '\n', '        UserInfo memory user = userInfo[_account];\n', '        return user.amount.mul(latestRPS.sub(storedRPS)).div(1e18).add(user.rewardEarned);\n', '    }\n', '\n', '    function canWithdraw(address _account) external view returns (bool) {\n', '        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs) <= epoch();\n', '    }\n', '\n', '    function canClaimReward(address _account) external view returns (bool) {\n', '        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs) <= epoch();\n', '    }\n', '\n', '    function unlockWithdrawEpoch(address _account) public view override returns (uint256) {\n', '        return userInfo[_account].epochTimerStart.add(withdrawLockupEpochs);\n', '    }\n', '\n', '    function unlockRewardEpoch(address _account) public view override returns (uint256) {\n', '        return userInfo[_account].epochTimerStart.add(rewardLockupEpochs);\n', '    }\n', '\n', '    /* ========== MUTATIVE FUNCTIONS ========== */\n', '\n', '    function stake(uint256 _amount) external override lock {\n', '        IValueLiquidPair(pair).transferFrom(msg.sender, address(this), _amount);\n', '        _stakeFor(msg.sender);\n', '    }\n', '\n', '    function stakeFor(address _account) external override lock {\n', '        require(IStakePoolController(controller).isWhitelistStakingFor(msg.sender), "StakePoolEpochReward: Invalid sender");\n', '        _stakeFor(_account);\n', '    }\n', '\n', '    function _stakeFor(address _account) internal {\n', '        uint256 _amount = IValueLiquidPair(pair).balanceOf(address(this)).sub(balance);\n', '        require(_amount > 0, "StakePoolEpochReward: Invalid balance");\n', '        balance = balance.add(_amount);\n', '        UserInfo storage user = userInfo[_account];\n', '        user.epochTimerStart = epoch(); // reset timer\n', '        user.amount = user.amount.add(_amount);\n', '        emit Deposit(_account, _amount);\n', '    }\n', '\n', '    function removeStakeInternal(uint256 _amount) internal {\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        uint256 _epoch = epoch();\n', '        require(user.epochTimerStart.add(withdrawLockupEpochs) <= _epoch, "StakePoolEpochReward: still in withdraw lockup");\n', '        require(user.amount >= _amount, "StakePoolEpochReward: invalid withdraw amount");\n', '        _claimReward(false);\n', '        balance = balance.sub(_amount);\n', '        user.epochTimerStart = _epoch; // reset timer\n', '        user.amount = user.amount.sub(_amount);\n', '    }\n', '\n', '    function withdraw(uint256 _amount) public override lock {\n', '        removeStakeInternal(_amount);\n', '        IValueLiquidPair(pair).transfer(msg.sender, _amount);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    function exit() external {\n', '        withdraw(userInfo[msg.sender].amount);\n', '    }\n', '\n', '    function _claimReward(bool _lockChecked) internal updateReward(msg.sender) {\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        uint256 _reward = user.rewardEarned;\n', '        if (_reward > 0) {\n', '            if (_lockChecked) {\n', '                uint256 _epoch = epoch();\n', '                require(user.epochTimerStart.add(rewardLockupEpochs) <= _epoch, "StakePoolEpochReward: still in reward lockup");\n', '                user.epochTimerStart = _epoch; // reset timer\n', '            }\n', '            user.rewardEarned = 0;\n', '            // Safe reward transfer, just in case if rounding error causes pool to not have enough reward amount\n', '            uint256 _rewardBalance = IERC20(rewardToken).balanceOf(rewardFund);\n', '            uint256 _paidAmount = _rewardBalance > _reward ? _reward : _rewardBalance;\n', '            IStakePoolRewardFund(rewardFund).safeTransfer(rewardToken, msg.sender, _paidAmount);\n', '            emit PayRewardPool(0, rewardToken, msg.sender, _reward, _reward, _paidAmount);\n', '        }\n', '    }\n', '\n', '    function claimReward() public override {\n', '        _claimReward(true);\n', '    }\n', '\n', '    // Withdraw without caring about rewards. EMERGENCY ONLY.\n', '    function emergencyWithdraw() external override lock {\n', '        require(IStakePoolController(controller).isAllowEmergencyWithdrawStakePool(address(this)), "StakePoolEpochReward: Not allow emergencyWithdraw");\n', '        UserInfo storage user = userInfo[msg.sender];\n', '        uint256 amount = user.amount;\n', '        balance = balance.sub(amount);\n', '        user.amount = 0;\n', '        IValueLiquidPair(pair).transfer(msg.sender, amount);\n', '    }\n', '\n', '    function removeLiquidity(\n', '        address provider,\n', '        address tokenA,\n', '        address tokenB,\n', '        uint256 liquidity,\n', '        uint256 amountAMin,\n', '        uint256 amountBMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) public override lock returns (uint256 amountA, uint256 amountB) {\n', '        require(IStakePoolController(controller).isWhitelistStakingFor(provider), "StakePoolEpochReward: Invalid provider");\n', '        removeStakeInternal(liquidity);\n', '        IValueLiquidPair(pair).approve(provider, liquidity);\n', '        emit Withdraw(msg.sender, liquidity);\n', '        (amountA, amountB) = IValueLiquidProvider(provider).removeLiquidity(address(pair), tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);\n', '    }\n', '\n', '    function removeLiquidityETH(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external override lock returns (uint256 amountToken, uint256 amountETH) {\n', '        require(IStakePoolController(controller).isWhitelistStakingFor(provider), "StakePoolEpochReward: Invalid provider");\n', '        removeStakeInternal(liquidity);\n', '        IValueLiquidPair(pair).approve(provider, liquidity);\n', '        emit Withdraw(msg.sender, liquidity);\n', '        (amountToken, amountETH) = IValueLiquidProvider(provider).removeLiquidityETH(\n', '            address(pair),\n', '            token,\n', '            liquidity,\n', '            amountTokenMin,\n', '            amountETHMin,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '\n', '    function removeLiquidityETHSupportingFeeOnTransferTokens(\n', '        address provider,\n', '        address token,\n', '        uint256 liquidity,\n', '        uint256 amountTokenMin,\n', '        uint256 amountETHMin,\n', '        address to,\n', '        uint256 deadline\n', '    ) external override lock returns (uint256 amountETH) {\n', '        require(IStakePoolController(controller).isWhitelistStakingFor(provider), "StakePoolEpochReward: Invalid provider");\n', '        removeStakeInternal(liquidity);\n', '        IValueLiquidPair(pair).approve(provider, liquidity);\n', '        emit Withdraw(msg.sender, liquidity);\n', '        amountETH = IValueLiquidProvider(provider).removeLiquidityETHSupportingFeeOnTransferTokens(\n', '            address(pair),\n', '            token,\n', '            liquidity,\n', '            amountTokenMin,\n', '            amountETHMin,\n', '            to,\n', '            deadline\n', '        );\n', '    }\n', '}\n', '\n', 'contract StakePoolEpochRewardCreator is IStakePoolCreator {\n', '    uint256 public override version = 4001;\n', '    struct PoolRewardInfo {\n', '        address epochController;\n', '        uint256 withdrawLockupEpochs;\n', '        uint256 rewardLockupEpochs;\n', '    }\n', '\n', '    function create() external override returns (address) {\n', '        StakePoolEpochReward pool = new StakePoolEpochReward(msg.sender, version);\n', '        return address(pool);\n', '    }\n', '\n', '    function initialize(\n', '        address poolAddress,\n', '        address pair,\n', '        address rewardToken,\n', '        address timelock,\n', '        address stakePoolRewardFund,\n', '        bytes calldata data\n', '    ) external override {\n', '        StakePoolEpochReward pool = StakePoolEpochReward(poolAddress);\n', '\n', '        PoolRewardInfo memory poolRewardInfo = abi.decode(data, (PoolRewardInfo));\n', '        pool.initialize(\n', '            pair,\n', '            address(stakePoolRewardFund),\n', '            address(timelock),\n', '            poolRewardInfo.epochController,\n', '            rewardToken,\n', '            poolRewardInfo.withdrawLockupEpochs,\n', '            poolRewardInfo.rewardLockupEpochs\n', '        );\n', '    }\n', '}']