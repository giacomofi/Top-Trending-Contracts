['// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.0;\n', '\n', 'import "./Fellowship.sol";\n', '\n', '/** \n', ' @author Tellor Inc.\n', ' @title Rivendell\n', ' @dev This contract holds the voting logic to be used in the Fellowship contract\n', '**/\n', 'contract Rivendell {\n', '    //Storage\n', '    struct Vote {\n', '        uint256 walkerCount; //Number of total votes by walkers\n', '        uint256 payeeCount; //Number of total votes by payees\n', '        uint256 TRBCount; //Number of total votes by TRB holders\n', '        uint256 walkerTally; //Number of yes votes by walkers\n', '        uint256 payeeTally; //token weighted tally of yes votes by payees\n', '        uint256 TRBTally; //token weighted tally of yes votes by TRB holders\n', '        uint256 tally; //total weighted tally (/1000) of the vote\n', '        uint256 startDate; //startDate of the vote\n', '        uint256 startBlock; //startingblock of the vote\n', '        bool executed; //bool whether the vote has been settled and action ran\n', '        bytes32 ActionHash; //hash of the action to run upon successful vote\n', '    }\n', '\n', '    /*\n', '        Initial Weighting\n', '        40% - Walker Vote\n', '        40% - Customers\n', '        20% - TRB Holders\n', '    */\n', '    struct Weightings {\n', '        uint256 trbWeight; //weight of TRB holders\n', '        uint256 walkerWeight; //weight of Walkers\n', '        uint256 userWeight; //weight of payees (users)\n', '    }\n', '\n', '    Weightings weights;\n', "    mapping(address => mapping(uint256 => bool)) public voted; //mapping of address to mapping of ID's and bool if voted on said ID\n", '    mapping(uint256 => Vote) public voteBreakdown; // mapping of ID to the details of the vote\n', '    uint256 public voteCount; //Total number of votes handled by Rivendell contract\n', '    address public fellowship; // address of the fellowship contract.\n', '\n', '    //Events\n', '    event NewVote(uint256 voteID, address destination, bytes data);\n', '    event Voted(uint256 tally, address user);\n', '    event VoteSettled(uint256 voteID, bool passed);\n', '\n', '    //Functions\n', '    /**\n', '     * @dev Constructor for setting initial variables\n', '     * @param _fellowship the address of the fellowshipContract\n', '     */\n', '    constructor(address _fellowship) {\n', '        fellowship = _fellowship;\n', '        _setWeights(200, 400, 400);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to open a vote\n', '     * @param _destination address to call if vote passes\n', '     * @param _function bytes of function to call if vote passes\n', '     */\n', '    function openVote(address _destination, bytes memory _function) external {\n', '        require(\n', '            ERC20Interface(Fellowship(fellowship).tellor()).transferFrom(\n', '                msg.sender,\n', '                fellowship,\n', '                1 ether\n', '            )\n', '        );\n', '        //increment vote count\n', '        voteCount += 1;\n', '        //set struct variables\n', '        voteBreakdown[voteCount].startBlock = block.number; //safe to index vote from voteBreakdown mapping with VoteCount?\n', '        voteBreakdown[voteCount].startDate = block.timestamp;\n', '        bytes32 actionHash =\n', '            keccak256(abi.encodePacked(_destination, _function));\n', '        voteBreakdown[voteCount].ActionHash = actionHash;\n', '        emit NewVote(voteCount, _destination, _function);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to settle a vote after a week has passed\n', '     * @param _id ID of vote settle\n', '     * @param _destination destination of function to call\n', '     * @param _data bytes of function / action to call if successful\n', '     */\n', '    function settleVote(\n', '        uint256 _id,\n', '        address _destination,\n', '        bytes calldata _data\n', '    ) external returns (bool _succ, bytes memory _res) {\n', '        require(\n', '            block.timestamp - voteBreakdown[_id].startDate > 7 days,\n', '            "vote has not been open long enough"\n', '        );\n', '        require(\n', '            block.timestamp - voteBreakdown[_id].startDate < 14 days,\n', '            "vote has failed / been too long"\n', '        );\n', '        require(\n', '            voteBreakdown[_id].ActionHash ==\n', '                keccak256(abi.encodePacked(_destination, _data)),\n', '            "Wrong action provided"\n', '        );\n', '        require(!voteBreakdown[_id].executed, "vote has already been settled");\n', '        uint256 denominator = 1000;\n', '        if (voteBreakdown[_id].TRBCount == 0) {\n', '            denominator -= weights.trbWeight;\n', '        }\n', '        if (voteBreakdown[_id].walkerCount == 0) {\n', '            denominator -= weights.walkerWeight;\n', '        }\n', '        if (voteBreakdown[_id].payeeCount == 0) {\n', '            denominator -= weights.userWeight;\n', '        }\n', '        voteBreakdown[_id].executed = true;\n', '        if (voteBreakdown[_id].tally > denominator / 2) {\n', '            (_succ, _res) = _destination.call(_data);\n', '        }\n', '        emit VoteSettled(_id, voteBreakdown[_id].tally > denominator / 2);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to vote\n', '     * @param _id uint256 id of the vote\n', '     * @param _supports bool if supports the action being run\n', '     */\n', '    function vote(uint256 _id, bool _supports) external {\n', '        require(!voted[msg.sender][_id], "address has already voted");\n', '        require(voteBreakdown[_id].startDate > 0, "vote must be started");\n', '        //Inherit Fellowship\n', '        Fellowship _fellowship = Fellowship(fellowship);\n', '        uint256[3] memory weightedVotes;\n', '        //If the sender is a supported Walker (voter)\n', '        if (_fellowship.isWalker(msg.sender)) {\n', "            //Increment this election's number of voters\n", '            voteBreakdown[_id].walkerCount++;\n', '            //If they vote yes, add to yes votes Tally\n', '            if (_supports) {\n', '                voteBreakdown[_id].walkerTally++;\n', '            }\n', '        }\n', '        if (voteBreakdown[_id].walkerCount > 0) {\n', '            weightedVotes[0] =\n', '                weights.walkerWeight *\n', '                (voteBreakdown[_id].walkerTally /\n', '                    voteBreakdown[_id].walkerCount);\n', '        }\n', "        //increment payee contribution total by voter's contribution\n", '        voteBreakdown[_id].payeeCount += _fellowship.payments(msg.sender);\n', '        //should we make this just "balanceOf" to make it ERC20 compliant\n', '        uint256 _bal =\n', '            ERC20Interface(_fellowship.tellor()).balanceOfAt(\n', '                msg.sender,\n', '                voteBreakdown[_id].startBlock\n', '            );\n', '        voteBreakdown[_id].TRBCount += _bal;\n', '        if (_supports) {\n', '            voteBreakdown[_id].payeeTally += _fellowship.payments(msg.sender);\n', '            voteBreakdown[_id].TRBTally += _bal;\n', '        }\n', '        if (voteBreakdown[_id].payeeCount > 0) {\n', '            weightedVotes[1] =\n', '                weights.userWeight *\n', '                (voteBreakdown[_id].payeeTally / voteBreakdown[_id].payeeCount);\n', '        }\n', '        if (voteBreakdown[_id].TRBCount > 0) {\n', '            weightedVotes[2] =\n', '                weights.trbWeight *\n', '                (voteBreakdown[_id].TRBTally / voteBreakdown[_id].TRBCount);\n', '        }\n', '        voteBreakdown[_id].tally =\n', '            weightedVotes[0] +\n', '            weightedVotes[1] +\n', '            weightedVotes[2];\n', '        voted[msg.sender][_id] = true;\n', '        emit Voted(voteBreakdown[_id].tally, msg.sender);\n', '    }\n', '\n', '    //View Functions\n', '    /**\n', '     * @dev function to get details of a given vote id\n', '     * @param _id uint256 id of vote\n', '     * @return all information in voteBreakdown mapping\n', '     */\n', '    function getVoteInfo(uint256 _id)\n', '        external\n', '        view\n', '        returns (\n', '            uint256[9] memory,\n', '            bool,\n', '            bytes32\n', '        )\n', '    {\n', '        return (\n', '            [\n', '                voteBreakdown[_id].walkerCount,\n', '                voteBreakdown[_id].payeeCount,\n', '                voteBreakdown[_id].TRBCount,\n', '                voteBreakdown[_id].walkerTally,\n', '                voteBreakdown[_id].payeeTally,\n', '                voteBreakdown[_id].TRBTally,\n', '                voteBreakdown[_id].tally,\n', '                voteBreakdown[_id].startDate,\n', '                voteBreakdown[_id].startBlock\n', '            ],\n', '            voteBreakdown[_id].executed,\n', '            voteBreakdown[_id].ActionHash\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check weights in system\n', '     * @return TRB weights\n', '     * @return weight set for users\n', '     * @return weight set for walkers\n', '     */\n', '    function getWeights()\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            uint256\n', '        )\n', '    {\n', '        return (weights.trbWeight, weights.userWeight, weights.walkerWeight);\n', '    }\n', '\n', '    //Internal Functions\n', '    /**\n', '     * @dev Internal Function to set weights in the contract\n', '     * @param _trb weight of TRB holders\n', '     * @param _walker weight of walkers\n', '     * @param _user weight of users of the Fellowship\n', '     **/\n', '    function _setWeights(\n', '        uint256 _trb,\n', '        uint256 _walker,\n', '        uint256 _user\n', '    ) internal {\n', '        require(_trb + _user + _walker == 1000, "weights must sum to 1000");\n', '        weights.trbWeight = _trb;\n', '        weights.userWeight = _user;\n', '        weights.walkerWeight = _walker;\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.8.0;\n', '\n', 'import "./interfaces/ERC20Interface.sol";\n', '\n', '/****\n', '\n', '████████╗██╗░░██╗███████╗\u2003\u2003███████╗███████╗██╗░░░░░██╗░░░░░░█████╗░░██╗░░░░░░░██╗░██████╗██╗░░██╗██╗██████╗░\n', '╚══██╔══╝██║░░██║██╔════╝\u2003\u2003██╔════╝██╔════╝██║░░░░░██║░░░░░██╔══██╗░██║░░██╗░░██║██╔════╝██║░░██║██║██╔══██╗\n', '░░░██║░░░███████║█████╗░░\u2003\u2003█████╗░░█████╗░░██║░░░░░██║░░░░░██║░░██║░╚██╗████╗██╔╝╚█████╗░███████║██║██████╔╝\n', '░░░██║░░░██╔══██║██╔══╝░░\u2003\u2003██╔══╝░░██╔══╝░░██║░░░░░██║░░░░░██║░░██║░░████╔═████║░░╚═══██╗██╔══██║██║██╔═══╝░\n', '░░░██║░░░██║░░██║███████╗\u2003\u2003██║░░░░░███████╗███████╗███████╗╚█████╔╝░░╚██╔╝░╚██╔╝░██████╔╝██║░░██║██║██║░░░░░\n', '░░░╚═╝░░░╚═╝░░╚═╝╚══════╝\u2003\u2003╚═╝░░░░░╚══════╝╚══════╝╚══════╝░╚════╝░░░░╚═╝░░░╚═╝░░╚═════╝░╚═╝░░╚═╝╚═╝╚═╝░░░░░\n', '\n', '*****/\n', '\n', '/** \n', ' @author Tellor Inc.\n', ' @title Fellowship\n', ' @dev This contract holds the selected few chosen as part of the Fellowship\n', '**/\n', 'contract Fellowship {\n', '    //Storage\n', '    enum Status {INACTIVE, ACTIVE, PENDING_WITHDRAW, UNFUNDED}\n', '\n', '    struct Walker {\n', '        Status status; //status of walker\n', '        uint256 date; //date the walker initally was chosen\n', '        uint256 fellowshipIndex; //index of walker in the fellowship array\n', '        uint256 balance; //TRB balance of walker (must be > stakeAmount to be ACTIVE)\n', '        uint256 rewardBalance; //balance of rewards they own\n', '        string name; //name of walker\n', '    }\n', '\n', '    uint256 public lastPayDate; //most recent date walkers were paid\n', '    uint256 public rewardPool; //sum of all payments for services in contract\n', '    uint256 public stakeAmount; //minimum amount each walker needs to stake\n', '    address public rivendell; //the address of the voting contract\n', '    address public tellor; //address of tellor (the token for staking and payments)\n', '\n', '    mapping(address => mapping(bytes32 => bytes)) information; //allows parties to store arbitrary information\n', '    mapping(address => Walker) public walkers; //a mapping of an address to their information as a Walker\n', "    mapping(address => uint256) public payments; //a mapping of an address to the payment amount they've given\n", '    //The Fellowship:\n', '    address[] public fellowship; //The array of chosen individuals who are part of the fellowship\n', '\n', '    //Events\n', '    event NewWalker(address walker);\n', '    event NewWalkerInformation(address walker, bytes32 input, bytes output);\n', '    event WalkerBanished(address walker);\n', '    event StakeWithdrawalRequestStarted(address walker);\n', '    event StakeWithdrawn(address walker);\n', '    event PaymentDeposited(address payee, uint256 amount);\n', '    event RewardsPaid(uint256 rewardPerWalker);\n', '\n', '    //Modifiers\n', '    /**\n', '     * @dev This modifier restricts the function to only the Rivendell contract\n', '     */\n', '    modifier onlyRivendell {\n', '        require(\n', '            msg.sender == rivendell,\n', '            "Only rivendell can call this function."\n', '        );\n', '        _;\n', '    }\n', '\n', '    //Functions\n', '    /**\n', '     * @dev Constructor for setting initial variables\n', '     * @param _tellor the address of the tellor contract\n', '     * @param _initialWalkers an array of three addresses to serve as the initial walkers\n', '     */\n', '    constructor(address _tellor, address[3] memory _initialWalkers) {\n', '        tellor = _tellor;\n', '        _newWalker(_initialWalkers[0], "Aragorn");\n', '        _newWalker(_initialWalkers[1], "Legolas");\n', '        _newWalker(_initialWalkers[2], "Gimli");\n', '        stakeAmount = 10 ether;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to banish a walker\n', '     * @param _oldWalker address of walker to be banished (removed from Fellowship)\n', '     **/\n', '    function banishWalker(address _oldWalker) external onlyRivendell {\n', '        require(\n', '            walkers[_oldWalker].status != Status.INACTIVE,\n', '            "walker is already banished"\n', '        );\n', '        _banishWalker(_oldWalker);\n', '        emit WalkerBanished(_oldWalker);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to deposit payment to use Fellowship\n', '     * @param _amount amount of TRB to be used as payment\n', '     **/\n', '    function depositPayment(uint256 _amount) external {\n', '        if (rewardPool > 0) {\n', '            payReward();\n', '        } else {\n', '            lastPayDate = block.timestamp;\n', '        }\n', '        ERC20Interface(tellor).transferFrom(msg.sender, address(this), _amount);\n', '        payments[msg.sender] += _amount;\n', '        rewardPool += _amount;\n', '        emit PaymentDeposited(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to deposit a stake for walkers\n', '     * @param _amount amount of TRB to deposit to account\n', '     **/\n', '    function depositStake(uint256 _amount) external {\n', '        ERC20Interface(tellor).transferFrom(msg.sender, address(this), _amount);\n', '        walkers[msg.sender].balance += _amount;\n', '        require(\n', '            walkers[msg.sender].status != Status.INACTIVE,\n', '            "Walker has wrong status"\n', '        );\n', '        require(\n', '            walkers[msg.sender].status != Status.PENDING_WITHDRAW,\n', '            "Walker has wrong status"\n', '        );\n', '        if (walkers[msg.sender].balance >= stakeAmount) {\n', '            walkers[msg.sender].status = Status.ACTIVE;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Change the rivendell (governance) contract\n', '     * @param _newRivendell address to act as owner of the Fellowship\n', '     **/\n', '    function newRivendell(address _newRivendell) external {\n', '        require(\n', '            msg.sender == rivendell || rivendell == address(0),\n', '            "Only rivendell can call this function."\n', '        );\n', '        rivendell = _newRivendell;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to add a new walker\n', '     * @param _walker address of walker to be banished (removed from Fellowship)\n', '     * @param _name name of walker\n', '     **/\n', '    function newWalker(address _walker, string memory _name)\n', '        external\n', '        onlyRivendell\n', '    {\n', '        _newWalker(_walker, _name);\n', '    }\n', '\n', '    /**\n', '     * @dev function to pay a reward to the walkers\n', '     **/\n', '    function payReward() public {\n', '        uint256 timeSinceLastPayment = block.timestamp - lastPayDate;\n', '        if (timeSinceLastPayment > 6 * 30 days) {\n', '            timeSinceLastPayment = 6 * 30 days;\n', '        }\n', '        uint256 reward =\n', '            (rewardPool * timeSinceLastPayment) /\n', '                6 /\n', '                30 days /\n', '                fellowship.length;\n', '        if (reward > 0) {\n', '            for (uint256 i = 0; i < fellowship.length; i++) {\n', '                if (walkers[fellowship[i]].status == Status.ACTIVE) {\n', '                    walkers[fellowship[i]].rewardBalance += reward;\n', '                    rewardPool -= reward;\n', '                }\n', '            }\n', '            lastPayDate = block.timestamp;\n', '            emit RewardsPaid(reward);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function lets walkers recieve their reward\n', '     **/\n', '    function recieveReward() external {\n', '        require(\n', '            walkers[msg.sender].status == Status.ACTIVE,\n', '            "Walker has wrong status"\n', '        );\n', '        ERC20Interface(tellor).transfer(\n', '            msg.sender,\n', '            walkers[msg.sender].rewardBalance\n', '        );\n', '        walkers[msg.sender].rewardBalance = 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Function for walkers to request to withdraw their stake\n', '     **/\n', '    function requestStakingWithdraw() external {\n', '        require(\n', '            walkers[msg.sender].status != Status.INACTIVE,\n', '            "Walker has wrong status"\n', '        );\n', '        walkers[msg.sender].status = Status.PENDING_WITHDRAW;\n', '        walkers[msg.sender].date = block.timestamp;\n', '        emit StakeWithdrawalRequestStarted(msg.sender);\n', '    }\n', '\n', '    /**\n', '     * @dev Function for rivendell to change the staking amount\n', '     * @param _amount the staking requirement in TRB\n', '     **/\n', '    function setStakeAmount(uint256 _amount) external onlyRivendell {\n', '        stakeAmount = _amount;\n', '        for (uint256 i = 0; i < fellowship.length; i++) {\n', '            if (walkers[fellowship[i]].status == Status.ACTIVE && walkers[fellowship[i]].balance < stakeAmount) {\n', '                walkers[fellowship[i]].status = Status.UNFUNDED;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function for walkers to store arbitrary information mapped to their account\n', '     * @param _input the key for the mapping\n', '     * @param _output the result for the mapping\n', '     **/\n', '    function setWalkerInformation(bytes32 _input, bytes memory _output) external {\n', '        require(\n', '            isWalker(msg.sender) || msg.sender == rivendell,\n', '            "must be a valid walker to use this function"\n', '        );\n', '        information[msg.sender][_input] = _output;\n', '        emit NewWalkerInformation(msg.sender, _input, _output);\n', '    }\n', '\n', '    /**\n', '     * @dev Function for rivendell to slash a walker\n', '     * @param _walker the address of the slashed walker\n', '     * @param _amount the amount to slash\n', '     * @param _banish a bool to say whether the walker is also banished\n', '     **/\n', '    function slashWalker(\n', '        address _walker,\n', '        uint256 _amount,\n', '        bool _banish\n', '    ) external onlyRivendell {\n', '        if (walkers[_walker].balance >= _amount) {\n', '            walkers[_walker].balance -= _amount;\n', '            rewardPool += _amount;\n', '        } else if (walkers[_walker].balance > 0) {\n', '            rewardPool += walkers[_walker].balance;\n', '            walkers[_walker].balance = 0;\n', '        }\n', '        if (_banish) {\n', '            if (walkers[_walker].status != Status.INACTIVE) {\n', '                _banishWalker(_walker);\n', '            }\n', '        } else if (walkers[_walker].balance < stakeAmount) {\n', '            walkers[_walker].status = Status.UNFUNDED;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function for walkers to withdraw stake two weeks after requesting a withdrawal\n', '     **/\n', '    function withdrawStake() external {\n', '        require(\n', '            walkers[msg.sender].status == Status.PENDING_WITHDRAW,\n', '            "walker has wrong status"\n', '        );\n', '        require(\n', '            block.timestamp - walkers[msg.sender].date > 14 days,\n', '            "has not been long enough to withdraw"\n', '        );\n', '        ERC20Interface(tellor).transfer(\n', '            msg.sender,\n', '            walkers[msg.sender].balance\n', '        );\n', '        walkers[msg.sender].balance = 0;\n', '        _banishWalker(msg.sender);\n', '        emit StakeWithdrawn(msg.sender);\n', '    }\n', '\n', '    //View Functions\n', '    /**\n', '     * @dev Function returns the current reward for each walker\n', '     * @return uint256 reward\n', '     **/\n', '    function checkReward() external view returns (uint256) {\n', '        uint256 timeSinceLastPayment = block.timestamp - lastPayDate;\n', '        if (timeSinceLastPayment > 6 * 30 days) {\n', '            timeSinceLastPayment = 6 * 30 days;\n', '        }\n', '        return ((rewardPool * timeSinceLastPayment) /\n', '            6 /\n', '            30 days /\n', '            fellowship.length);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to return the fellowship size\n', '     * @return uint256 size\n', '     **/\n', '    function getFellowshipSize() external view returns (uint256) {\n', '        return fellowship.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Function for walkers to withdraw stake two weeks after requesting a withdrawal\n', '     * @param _walker address of the walker of interest\n', '     * @return uint256 epoch timestamp of date walker started\n', '     * @return uint256 index in the fellowship array\n', '     * @return Status of the walker\n', '     * @return uint256 balance of the walker staked\n', '     * @return uint256 balance for withrawal by the walker\n', '     * @return string name of the walker\n', '     **/\n', '    function getWalkerDetails(address _walker)\n', '        external\n', '        view\n', '        returns (\n', '            uint256,\n', '            uint256,\n', '            Status,\n', '            uint256,\n', '            uint256,\n', '            string memory\n', '        )\n', '    {\n', '        return (\n', '            walkers[_walker].date,\n', '            walkers[_walker].fellowshipIndex,\n', '            walkers[_walker].status,\n', '            walkers[_walker].balance,\n', '            walkers[_walker].rewardBalance,\n', '            walkers[_walker].name\n', '        );\n', '    }\n', '\n', '    /**\n', '     * @dev Function to get arbitrary information set by the walker\n', '     * @param _walker address of walker\n', '     * @param _input mapping key for information mapping\n', '     * @return bytes output of mapping\n', '     **/\n', '    function getWalkerInformation(address _walker, bytes32 _input)\n', '        external\n', '        view\n', '        returns (bytes memory)\n', '    {\n', '        return information[_walker][_input];\n', '    }\n', '\n', '    /**\n', "     * @dev Function to check if walker's status is active\n", '     * @param _party address of walker\n', '     * @return bool if walker has Status.ACTIVE\n', '     **/\n', '    function isWalker(address _party) public view returns (bool) {\n', '        if (walkers[_party].status == Status.ACTIVE) {\n', '            return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    //Internal Functions\n', '    /**\n', '     * @dev Internal function to banish a given walker\n', '     * @param _oldWalker walker to banish\n', '     **/\n', '    function _banishWalker(address _oldWalker) internal {\n', '        fellowship[walkers[_oldWalker].fellowshipIndex] = fellowship[\n', '            fellowship.length - 1\n', '        ];\n', '        walkers[fellowship[fellowship.length - 1]].fellowshipIndex = walkers[\n', '            _oldWalker\n', '        ]\n', '            .fellowshipIndex;\n', '        fellowship.pop();\n', '        walkers[_oldWalker].fellowshipIndex = 0;\n', '        walkers[_oldWalker].status = Status.INACTIVE;\n', '        ERC20Interface(tellor).transfer(\n', '            _oldWalker,\n', '            walkers[_oldWalker].balance\n', '        );\n', '        walkers[_oldWalker].balance = 0;\n', '        rewardPool += walkers[_oldWalker].rewardBalance;\n', '        walkers[_oldWalker].rewardBalance = 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to add a new walker\n', '     * @param _walker address of new walker\n', '     * @param _name name of new walker\n', '     **/\n', '    function _newWalker(address _walker, string memory _name) internal {\n', '        require(walkers[_walker].date == 0, "cannot already be a walker");\n', '        fellowship.push(_walker);\n', '        walkers[_walker] = Walker({\n', '            date: block.timestamp,\n', '            name: _name,\n', '            status: Status.UNFUNDED,\n', '            fellowshipIndex: fellowship.length - 1,\n', '            balance: 0,\n', '            rewardBalance: 0\n', '        });\n', '        emit NewWalker(_walker);\n', '    }\n', '}\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.8.0;\n', '\n', 'interface ERC20Interface {\n', '    function transfer(address _to, uint256 _amount) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address _from,\n', '        address _to,\n', '        uint256 _amount\n', '    ) external returns (bool);\n', '\n', '    function balanceOf(address _addy) external returns (uint256);\n', '\n', '    function balanceOfAt(address _addy, uint256 _block)\n', '        external\n', '        returns (uint256);\n', '}\n', '\n', '{\n', '  "optimizer": {\n', '    "enabled": true,\n', '    "runs": 999999\n', '  },\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  },\n', '  "libraries": {}\n', '}']