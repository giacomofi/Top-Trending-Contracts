['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-25\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '// P1 - P3: OK\n', 'pragma solidity 0.6.12;\n', '\n', '// a library for performing overflow-safe math, updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math)\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a + b) >= b, "SafeMath: Add Overflow");}\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {require((c = a - b) <= a, "SafeMath: Underflow");}\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {require(b == 0 || (c = a * b)/b == a, "SafeMath: Mul Overflow");}\n', '    function to128(uint256 a) internal pure returns (uint128 c) {\n', '        require(a <= uint128(-1), "SafeMath: uint128 Overflow");\n', '        c = uint128(a);\n', '    }\n', '}\n', '\n', 'library SafeMath128 {\n', '    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a + b) >= b, "SafeMath: Add Overflow");}\n', '    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {require((c = a - b) <= a, "SafeMath: Underflow");}\n', '}\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    // EIP 2612\n', '    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', 'library SafeERC20 {\n', '    function safeSymbol(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeName(IERC20 token) internal view returns(string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function safeDecimals(IERC20 token) public view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: Transfer failed");\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, uint256 amount) internal {\n', '        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(0x23b872dd, from, address(this), amount));\n', '        require(success && (data.length == 0 || abi.decode(data, (bool))), "SafeERC20: TransferFrom failed");\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '    function migrator() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '    function setMigrator(address) external;\n', '}\n', '\n', '// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n', '// Edited by BoringCrypto\n', '\n', '// T1 - T4: OK\n', 'contract OwnableData {\n', '    // V1 - V5: OK\n', '    address public owner;\n', '    // V1 - V5: OK\n', '    address public pendingOwner;\n', '}\n', '\n', '// T1 - T4: OK\n', 'contract Ownable is OwnableData {\n', '    // E1: OK\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () internal {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    // F1 - F9: OK\n', '    // C1 - C21: OK\n', '    function transferOwnership(address newOwner, bool direct, bool renounce) public onlyOwner {\n', '        if (direct) {\n', '            // Checks\n', '            require(newOwner != address(0) || renounce, "Ownable: zero address");\n', '\n', '            // Effects\n', '            emit OwnershipTransferred(owner, newOwner);\n', '            owner = newOwner;\n', '        } else {\n', '            // Effects\n', '            pendingOwner = newOwner;\n', '        }\n', '    }\n', '\n', '    // F1 - F9: OK\n', '    // C1 - C21: OK\n', '    function claimOwnership() public {\n', '        address _pendingOwner = pendingOwner;\n', '\n', '        // Checks\n', '        require(msg.sender == _pendingOwner, "Ownable: caller != pending owner");\n', '\n', '        // Effects\n', '        emit OwnershipTransferred(owner, _pendingOwner);\n', '        owner = _pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '\n', '    // M1 - M5: OK\n', '    // C1 - C21: OK\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', '\n', 'interface IBentoBoxWithdraw {\n', '    function withdraw(\n', '        IERC20 token_,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 share\n', '    ) external returns (uint256 amountOut, uint256 shareOut);\n', '}\n', '\n', 'interface IKashiWithdrawFee {\n', '    function asset() external view returns (address);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function withdrawFees() external;\n', '    function removeAsset(address to, uint256 fraction) external returns (uint256 share);\n', '}\n', '\n', "// SushiMakerKashi is MasterChef's left hand and kinda a wizard. He can cook up Sushi from pretty much anything!\n", '// This contract handles "serving up" rewards for xSushi holders by trading tokens collected from Kashi fees for Sushi.\n', 'contract SushiMakerKashi is Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    IUniswapV2Factory private immutable factory;\n', '    //0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac\n', '    address private immutable bar;\n', '    //0x8798249c2E607446EfB7Ad49eC89dD1865Ff4272\n', '    IBentoBoxWithdraw private immutable bentoBox;\n', '    //0xF5BCE5077908a1b7370B9ae04AdC565EBd643966 \n', '    address private immutable sushi;\n', '    //0x6B3595068778DD592e39A122f4f5a5cF09C90fE2\n', '    address private immutable weth;\n', '    //0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n', '    bytes32 private immutable pairCodeHash;\n', '    //0xe18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\n', '\n', '    mapping(address => address) private _bridges;\n', '\n', '    event LogBridgeSet(address indexed token, address indexed bridge);\n', '    event LogConvert(\n', '        address indexed server,\n', '        address indexed token0,\n', '        uint256 amount0,\n', '        uint256 amountBENTO,\n', '        uint256 amountSUSHI\n', '    );\n', '\n', '    constructor(\n', '        IUniswapV2Factory _factory,\n', '        address _bar,\n', '        IBentoBoxWithdraw _bentoBox,\n', '        address _sushi,\n', '        address _weth,\n', '        bytes32 _pairCodeHash\n', '    ) public {\n', '        factory = _factory;\n', '        bar = _bar;\n', '        bentoBox = _bentoBox;\n', '        sushi = _sushi;\n', '        weth = _weth;\n', '        pairCodeHash = _pairCodeHash;\n', '    }\n', '\n', '    function setBridge(address token, address bridge) external onlyOwner {\n', '        // Checks\n', '        require(\n', '            token != sushi && token != weth && token != bridge,\n', '            "Maker: Invalid bridge"\n', '        );\n', '        // Effects\n', '        _bridges[token] = bridge;\n', '        emit LogBridgeSet(token, bridge);\n', '    }\n', '\n', '    modifier onlyEOA() {\n', '        // Try to make flash-loan exploit harder to do by only allowing externally-owned addresses.\n', '        require(msg.sender == tx.origin, "Maker: Must use EOA");\n', '        _;\n', '    }\n', '\n', '    function convert(IKashiWithdrawFee kashiPair) external onlyEOA {\n', '        _convert(kashiPair);\n', '    }\n', '\n', '    function convertMultiple(IKashiWithdrawFee[] calldata kashiPair) external onlyEOA {\n', '        for (uint256 i = 0; i < kashiPair.length; i++) {\n', '            _convert(kashiPair[i]);\n', '        }\n', '    }\n', '\n', '    function _convert(IKashiWithdrawFee kashiPair) private {\n', '        // update Kashi fees for this Maker contract (`feeTo`)\n', '        kashiPair.withdrawFees();\n', '\n', '        // convert updated Kashi balance to Bento shares\n', '        uint256 bentoShares = kashiPair.removeAsset(address(this), kashiPair.balanceOf(address(this)));\n', '\n', '        // convert Bento shares to underlying Kashi asset (`token0`) balance (`amount0`) for Maker\n', '        address token0 = kashiPair.asset();\n', '        (uint256 amount0, ) = bentoBox.withdraw(IERC20(token0), address(this), address(this), 0, bentoShares);\n', '\n', '        emit LogConvert(\n', '            msg.sender,\n', '            token0,\n', '            amount0,\n', '            bentoShares,\n', '            _convertStep(token0, amount0)\n', '        );\n', '    }\n', '\n', '    function _convertStep(address token0, uint256 amount0) private returns (uint256 sushiOut) {\n', '        if (token0 == sushi) {\n', '            IERC20(token0).safeTransfer(bar, amount0);\n', '            sushiOut = amount0;\n', '        } else if (token0 == weth) {\n', '            sushiOut = _swap(token0, sushi, amount0, bar);\n', '        } else {\n', '            address bridge = _bridges[token0];\n', '            if (bridge == address(0)) {\n', '                bridge = weth;\n', '            }\n', '            uint256 amountOut = _swap(token0, bridge, amount0, address(this));\n', '            sushiOut = _convertStep(bridge, amountOut);\n', '        }\n', '    }\n', '\n', '    function _swap(\n', '        address fromToken,\n', '        address toToken,\n', '        uint256 amountIn,\n', '        address to\n', '    ) private returns (uint256 amountOut) {\n', '        (address token0, address token1) = fromToken < toToken ? (fromToken, toToken) : (toToken, fromToken);\n', '        IUniswapV2Pair pair =\n', '            IUniswapV2Pair(\n', '                uint256(\n', '                    keccak256(abi.encodePacked(hex"ff", factory, keccak256(abi.encodePacked(token0, token1)), pairCodeHash))\n', '                )\n', '            );\n', '        \n', '        (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\n', '        uint256 amountInWithFee = amountIn.mul(997);\n', '        \n', '        if (toToken > fromToken) {\n', '            amountOut =\n', '                amountInWithFee.mul(reserve1) /\n', '                reserve0.mul(1000).add(amountInWithFee);\n', '            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n', '            pair.swap(0, amountOut, to, "");\n', '        } else {\n', '            amountOut =\n', '                amountInWithFee.mul(reserve0) /\n', '                reserve1.mul(1000).add(amountInWithFee);\n', '            IERC20(fromToken).safeTransfer(address(pair), amountIn);\n', '            pair.swap(amountOut, 0, to, "");\n', '        }\n', '    }\n', '}']