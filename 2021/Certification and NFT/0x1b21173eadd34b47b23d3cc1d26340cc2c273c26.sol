['//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', 'pragma experimental SMTChecker;\n', 'import "./Claimable.sol";\n', 'import "./CanReclaimToken.sol";\n', 'import "./MTokenDeSwap.sol";\n', 'import "./TransparentUpgradeableProxy.sol";\n', '\n', 'contract MTokenDeSwapFactory is Claimable, CanReclaimToken {\n', '    mapping(bytes32 => address) public deSwaps;\n', '\n', '    function getDeSwap(string memory _nativeCoinType)\n', '        public\n', '        view\n', '        returns (address)\n', '    {\n', '        bytes32 nativeCoinTypeHash =\n', '            keccak256(abi.encodePacked(_nativeCoinType));\n', '        return deSwaps[nativeCoinTypeHash];\n', '    }\n', '\n', '    function deployDeSwap(\n', '        address _mtoken,\n', '        string memory _nativeCoinType,\n', '        address _mtokenRepository,\n', '        address _operator\n', '    ) public onlyOwner returns (bool) {\n', '        bytes32 nativeCoinTypeHash =\n', '            keccak256(abi.encodePacked(_nativeCoinType));\n', '        require(_operator!=_owner(), "owner same as _operator");\n', '        require(deSwaps[nativeCoinTypeHash] == (address)(0), "deEx exists.");\n', '        MTokenDeSwap mtokenDeSwap = new MTokenDeSwap();\n', '        TransparentUpgradeableProxy proxy =\n', '            new TransparentUpgradeableProxy(\n', '                (address)(mtokenDeSwap),\n', '                (address)(this),\n', '                abi.encodeWithSignature(\n', '                    "setup(address,string,address,address)",\n', '                    _mtoken,\n', '                    _nativeCoinType,\n', '                    _mtokenRepository,\n', '                    _operator\n', '                )\n', '            );\n', '\n', '        proxy.changeAdmin(_owner());\n', '        deSwaps[nativeCoinTypeHash] = (address)(proxy);\n', '\n', '        return true;\n', '    }\n', '}']