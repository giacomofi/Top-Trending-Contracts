['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-22\n', '*/\n', '\n', '// File contracts/interfaces/IWhitelist.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * Source: https://raw.githubusercontent.com/simple-restricted-token/reference-implementation/master/contracts/token/ERC1404/ERC1404.sol\n', ' * With ERC-20 APIs removed (will be implemented as a separate contract).\n', ' * And adding authorizeTransfer.\n', ' */\n', 'interface IWhitelist {\n', '  /**\n', '   * @notice Detects if a transfer will be reverted and if so returns an appropriate reference code\n', '   * @param from Sending address\n', '   * @param to Receiving address\n', '   * @param value Amount of tokens being transferred\n', '   * @return Code by which to reference message for rejection reasoning\n', '   * @dev Overwrite with your custom transfer restriction logic\n', '   */\n', '  function detectTransferRestriction(\n', '    address from,\n', '    address to,\n', '    uint value\n', '  ) external view returns (uint8);\n', '\n', '  /**\n', '   * @notice Returns a human-readable message for a given restriction code\n', '   * @param restrictionCode Identifier for looking up a message\n', "   * @return Text showing the restriction's reasoning\n", '   * @dev Overwrite with your custom message and restrictionCode handling\n', '   */\n', '  function messageForTransferRestriction(uint8 restrictionCode)\n', '    external\n', '    pure\n', '    returns (string memory);\n', '\n', '  /**\n', '   * @notice Called by the DAT contract before a transfer occurs.\n', '   * @dev This call will revert when the transfer is not authorized.\n', '   * This is a mutable call to allow additional data to be recorded,\n', '   * such as when the user aquired their tokens.\n', '   */\n', '  function authorizeTransfer(\n', '    address _from,\n', '    address _to,\n', '    uint _value,\n', '    bool _isSell\n', '  ) external;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library AddressUpgradeable {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/proxy/utils/[email\xa0protected]\n', '\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' *\n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}.\n', ' *\n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/utils/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract ContextUpgradeable is Initializable {\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '    }\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '    uint256[50] private __gap;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts-upgradeable/access/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '    uint256[49] private __gap;\n', '}\n', '\n', '\n', '// File contracts/mixins/OperatorRole.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', "// Original source: openzeppelin's SignerRole\n", '\n', '/**\n', ' * @notice allows a single owner to manage a group of operators which may\n', ' * have some special permissions in the contract.\n', ' */\n', 'contract OperatorRole is OwnableUpgradeable {\n', '    mapping (address => bool) internal _operators;\n', '\n', '    event OperatorAdded(address indexed account);\n', '    event OperatorRemoved(address indexed account);\n', '\n', '    function _initializeOperatorRole() internal {\n', '        __Ownable_init();\n', '        _addOperator(msg.sender);\n', '    }\n', '\n', '    modifier onlyOperator() {\n', '        require(\n', '            isOperator(msg.sender),\n', '            "OperatorRole: caller does not have the Operator role"\n', '        );\n', '        _;\n', '    }\n', '\n', '    function isOperator(address account) public view returns (bool) {\n', '        return _operators[account];\n', '    }\n', '\n', '    function addOperator(address account) public onlyOwner {\n', '        _addOperator(account);\n', '    }\n', '\n', '    function removeOperator(address account) public onlyOwner {\n', '        _removeOperator(account);\n', '    }\n', '\n', '    function renounceOperator() public {\n', '        _removeOperator(msg.sender);\n', '    }\n', '\n', '    function _addOperator(address account) internal {\n', '        _operators[account] = true;\n', '        emit OperatorAdded(account);\n', '    }\n', '\n', '    function _removeOperator(address account) internal {\n', '        _operators[account] = false;\n', '        emit OperatorRemoved(account);\n', '    }\n', '\n', '    uint[50] private ______gap;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/token/ERC20/[email\xa0protected]\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '\n', '// File contracts/Whitelist.sol\n', '\n', 'pragma solidity 0.8.3;\n', '\n', '\n', '\n', '/**\n', ' * @notice whitelist which manages KYC approvals, token lockup, and transfer\n', ' * restrictions for a DAT token.\n', ' */\n', 'contract Whitelist is OwnableUpgradeable, OperatorRole {\n', '    // uint8 status codes as suggested by the ERC-1404 spec\n', '    enum ErrorMessage {\n', '        Success,\n', '        JurisdictionFlow,\n', '        LockUp,\n', '        UserUnknown,\n', '        JurisdictionHalt\n', '    }\n', '\n', '    event ConfigWhitelist(\n', '        uint _startDate,\n', '        uint _lockupGranularity,\n', '        address indexed _operator\n', '    );\n', '    event UpdateJurisdictionFlow(\n', '        uint indexed _fromJurisdictionId,\n', '        uint indexed _toJurisdictionId,\n', '        uint _lockupLength,\n', '        address indexed _operator\n', '    );\n', '    event ApproveNewUser(\n', '        address indexed _trader,\n', '        uint indexed _jurisdictionId,\n', '        address indexed _operator\n', '    );\n', '    event AddApprovedUserWallet(\n', '        address indexed _userId,\n', '        address indexed _newWallet,\n', '        address indexed _operator\n', '    );\n', '    event RevokeUserWallet(address indexed _wallet, address indexed _operator);\n', '    event UpdateJurisdictionForUserId(\n', '        address indexed _userId,\n', '        uint indexed _jurisdictionId,\n', '        address indexed _operator\n', '    );\n', '    event AddLockup(\n', '        address indexed _userId,\n', '        uint _lockupExpirationDate,\n', '        uint _numberOfTokensLocked,\n', '        address indexed _operator\n', '    );\n', '    event UnlockTokens(\n', '        address indexed _userId,\n', '        uint _tokensUnlocked,\n', '        address indexed _operator\n', '    );\n', '    event Halt(uint indexed _jurisdictionId, uint _until);\n', '    event Resume(uint indexed _jurisdictionId);\n', '    event MaxInvestorsChanged(uint _limit);\n', '    event MaxInvestorsByJurisdictionChanged(uint indexed _jurisdictionId, uint _limit);\n', '\n', '    /**\n', '     * @notice the address of the contract this whitelist manages.\n', '     * @dev this cannot change after initialization\n', '     */\n', '    IERC20 public callingContract;\n', '\n', '    /**\n', '     * @notice Merges lockup entries when the time delta between\n', '     * them is less than this value.\n', '     * @dev this can be changed by the owner at any time\n', '     */\n', '    struct Config {\n', '        uint64 startDate;\n', '        uint64 lockupGranularity;\n', '    }\n', '\n', '    Config internal config;\n', '\n', '    struct InvestorLimit {\n', '        uint128 max;\n', '        uint128 current;\n', '    }\n', '\n', '    InvestorLimit public globalInvestorLimit;\n', '\n', '    mapping(uint => InvestorLimit) public jurisdictionInvestorLimit;\n', '\n', '    /**\n', "     * @notice Maps Jurisdiction Id to it's halt due\n", '     */\n', '    mapping(uint => uint64) public jurisdictionHaltsUntil;\n', '\n', '    mapping(uint => mapping(uint => uint64)) internal jurisdictionFlows;\n', '\n', '    enum Status {\n', '        Unknown,\n', '        Activated,\n', '        Revoked,\n', '        Counted\n', '    }\n', '\n', '    struct UserInfo {\n', '        // to check if user is counted\n', '        Status status;\n', "        // The user's current jurisdictionId or 0 for unknown (the default)\n", '        uint8 jurisdictionId;\n', '        // The first applicable entry in userIdLockups\n', '        uint32 startIndex;\n', '        // The last applicable entry in userIdLockups + 1\n', '        uint32 endIndex;\n', '        // The number of tokens locked, with details tracked in userIdLockups\n', '        uint128 totalTokensLocked;\n', '        // The number of wallet in use\n', '        uint48 walletCount;\n', '    }\n', '\n', '    mapping(address => UserInfo) internal userInfo;\n', '\n', '    /**\n', '     * info stored for each token lockup.\n', '     */\n', '    struct Lockup {\n', '        // The date/time that this lockup entry has expired and the tokens may be transferred\n', '        uint64 lockupExpirationDate;\n', '        // How many tokens locked until the given expiration date.\n', '        uint128 numberOfTokensLocked;\n', '    }\n', '\n', '    mapping(address => mapping(uint => Lockup)) internal userIdLockups;\n', '\n', '    struct WalletInfo {\n', '        Status status;\n', '        address userId;\n', '    }\n', '\n', '    mapping(address => WalletInfo) public walletInfo;\n', '\n', '    bytes32 private constant BEACON_SLOT = keccak256(abi.encodePacked("fairmint.beaconproxy.beacon"));\n', '\n', '    modifier onlyBeaconOperator() {\n', '        bytes32 slot = BEACON_SLOT;\n', '        address beacon;\n', '        assembly {\n', '            beacon := sload(slot)\n', '        }\n', '        require(beacon == address(0) || OperatorRole(beacon).isOperator(msg.sender), "!BeaconOperator");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @notice checks for transfer restrictions between jurisdictions.\n', '     * @return lockupLength if transfers between these jurisdictions are allowed and if a\n', '     * token lockup should apply:\n', '     * - 0 means transfers between these jurisdictions is blocked (the default)\n', '     * - 1 is supported with no token lockup required\n', '     * - >1 is supported and this value defines the lockup length in seconds\n', '     */\n', '    function getJurisdictionFlow(\n', '        uint _fromJurisdictionId,\n', '        uint _toJurisdictionId\n', '    ) external view returns (uint lockupLength) {\n', '        return jurisdictionFlows[_fromJurisdictionId][_toJurisdictionId];\n', '    }\n', '\n', '    /**\n', '     * @notice checks details for a given userId.\n', '     */\n', '    function getAuthorizedUserIdInfo(address _userId)\n', '        external\n', '        view\n', '        returns (\n', '            uint jurisdictionId,\n', '            uint totalTokensLocked,\n', '            uint startIndex,\n', '            uint endIndex\n', '        )\n', '    {\n', '        UserInfo memory info = userInfo[_userId];\n', '        return (\n', '            info.jurisdictionId,\n', '            info.totalTokensLocked,\n', '            info.startIndex,\n', '            info.endIndex\n', '        );\n', '    }\n', '\n', '    function getInvestorInfo() external view returns(uint256 maxInvestor, uint256 currentInvestor) {\n', '        return (globalInvestorLimit.max, globalInvestorLimit.current);\n', '    }\n', '\n', '    function getJurisdictionInfo(uint256 _jurisdictionId) external view returns(uint256 halt, uint256 maxInvestor, uint256 currentInvestor){\n', '        InvestorLimit memory limit = jurisdictionInvestorLimit[_jurisdictionId];\n', '        return (jurisdictionHaltsUntil[_jurisdictionId], limit.max, limit.current);\n', '    }\n', '\n', '    /**\n', '     * @notice gets a specific lockup entry for a userId.\n', '     * @dev use `getAuthorizedUserIdInfo` to determine the range of applicable lockupIndex.\n', '     */\n', '    function getUserIdLockup(address _userId, uint _lockupIndex)\n', '        external\n', '        view\n', '        returns (uint lockupExpirationDate, uint numberOfTokensLocked)\n', '    {\n', '        Lockup memory lockup = userIdLockups[_userId][_lockupIndex];\n', '        return (lockup.lockupExpirationDate, lockup.numberOfTokensLocked);\n', '    }\n', '\n', '    /**\n', '     * @notice Returns the number of unlocked tokens a given userId has available.\n', '     * @dev this is a `view`-only way to determine how many tokens are still locked\n', '     * (info.totalTokensLocked is only accurate after processing lockups which changes state)\n', '     */\n', '    function getLockedTokenCount(address _userId)\n', '        external\n', '        view\n', '        returns (uint lockedTokens)\n', '    {\n', '        UserInfo memory info = userInfo[_userId];\n', '        lockedTokens = info.totalTokensLocked;\n', '        uint endIndex = info.endIndex;\n', '        for (uint i = info.startIndex; i < endIndex; i++) {\n', '            Lockup memory lockup = userIdLockups[_userId][i];\n', '            if (lockup.lockupExpirationDate > block.timestamp) {\n', '                // no more eligible entries\n', '                break;\n', '            }\n', '            // this lockup entry has expired and would be processed on the next tx\n', '            lockedTokens -= lockup.numberOfTokensLocked;\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks if there is a transfer restriction for the given addresses.\n', '     * Does not consider tokenLockup. Use `getLockedTokenCount` for that.\n', '     * @dev this function is from the erc-1404 standard and currently in use by the DAT\n', '     * for the `pay` feature.\n', '     */\n', '    function detectTransferRestriction(\n', '        address _from,\n', '        address _to,\n', '        uint /*_value*/\n', '    ) external view returns (uint8 status) {\n', '        WalletInfo memory from = walletInfo[_from];\n', '        WalletInfo memory to = walletInfo[_to];\n', '        if (\n', '            ((from.status == Status.Unknown || from.status == Status.Revoked) && _from != address(0)) ||\n', '            ((to.status == Status.Unknown || to.status == Status.Revoked) && _to != address(0))\n', '        ) {\n', '            return uint8(ErrorMessage.UserUnknown);\n', '        }\n', '        if (from.userId != to.userId) {\n', '            uint fromJurisdictionId = userInfo[from.userId]\n', '                .jurisdictionId;\n', '            uint toJurisdictionId = userInfo[to.userId].jurisdictionId;\n', '            if (_isJurisdictionHalted(fromJurisdictionId) || _isJurisdictionHalted(toJurisdictionId)){\n', '                return uint8(ErrorMessage.JurisdictionHalt);\n', '            }\n', '            if (jurisdictionFlows[fromJurisdictionId][toJurisdictionId] == 0) {\n', '                return uint8(ErrorMessage.JurisdictionFlow);\n', '            }\n', '        }\n', '\n', '        return uint8(ErrorMessage.Success);\n', '    }\n', '\n', '    function messageForTransferRestriction(uint8 _restrictionCode)\n', '        external\n', '        pure\n', '        returns (string memory)\n', '    {\n', '        if (_restrictionCode == uint8(ErrorMessage.Success)) {\n', '            return "SUCCESS";\n', '        }\n', '        if (_restrictionCode == uint8(ErrorMessage.JurisdictionFlow)) {\n', '            return "DENIED: JURISDICTION_FLOW";\n', '        }\n', '        if (_restrictionCode == uint8(ErrorMessage.LockUp)) {\n', '            return "DENIED: LOCKUP";\n', '        }\n', '        if (_restrictionCode == uint8(ErrorMessage.UserUnknown)) {\n', '            return "DENIED: USER_UNKNOWN";\n', '        }\n', '        if (_restrictionCode == uint8(ErrorMessage.JurisdictionHalt)){\n', '            return "DENIED: JURISDICTION_HALT";\n', '        }\n', '        return "DENIED: UNKNOWN_ERROR";\n', '    }\n', '\n', '    /**\n', '     * @notice Called once to complete configuration for this contract.\n', '     * @dev Done with `initialize` instead of a constructor in order to support\n', '     * using this contract via an Upgradable Proxy.\n', '     */\n', '    function initialize(address _callingContract) public onlyBeaconOperator{\n', '        _initializeOperatorRole();\n', '        callingContract = IERC20(_callingContract);\n', '    }\n', '\n', '    /**\n', '     * @notice Called by the owner to update the startDate or lockupGranularity.\n', '     */\n', '    function configWhitelist(uint _startDate, uint _lockupGranularity)\n', '        external\n', '        onlyOwner()\n', '    {\n', '        config = Config({\n', '            startDate: uint64(_startDate),\n', '            lockupGranularity: uint64(_lockupGranularity)\n', '        });\n', '        emit ConfigWhitelist(_startDate, _lockupGranularity, msg.sender);\n', '    }\n', '\n', '    function startDate() external view returns(uint256) {\n', '        return config.startDate;\n', '    }\n', '\n', '    function lockupGranularity() external view returns(uint256) {\n', '        return config.lockupGranularity;\n', '    }\n', '\n', '    function authorizedWalletToUserId(address wallet) external view returns(address userId) {\n', '        return walletInfo[wallet].userId;\n', '    }\n', '\n', '    /**\n', '     * @notice Called by the owner to define or update jurisdiction flows.\n', '     * @param _lockupLengths defines transfer restrictions where:\n', '     * - 0 is not supported (the default)\n', '     * - 1 is supported with no token lockup required\n', '     * - >1 is supported and this value defines the lockup length in seconds.\n', '     * @dev note that this can be called with a partial list, only including entries\n', '     * to be added or which have changed.\n', '     */\n', '    function updateJurisdictionFlows(\n', '        uint[] calldata _fromJurisdictionIds,\n', '        uint[] calldata _toJurisdictionIds,\n', '        uint[] calldata _lockupLengths\n', '    ) external onlyOwner() {\n', '        uint count = _fromJurisdictionIds.length;\n', '        for (uint i = 0; i < count; i++) {\n', '            uint fromJurisdictionId = _fromJurisdictionIds[i];\n', '            uint toJurisdictionId = _toJurisdictionIds[i];\n', '            require(\n', '                fromJurisdictionId > 0 && toJurisdictionId > 0,\n', '                "INVALID_JURISDICTION_ID"\n', '            );\n', '            jurisdictionFlows[fromJurisdictionId][toJurisdictionId] = uint64(_lockupLengths[i]);\n', '            emit UpdateJurisdictionFlow(\n', '                fromJurisdictionId,\n', '                toJurisdictionId,\n', '                _lockupLengths[i],\n', '                msg.sender\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Called by an operator to add new traders.\n', '     * @dev The trader will be assigned a userId equal to their wallet address.\n', '     */\n', '    function approveNewUsers(\n', '        address[] calldata _traders,\n', '        uint[] calldata _jurisdictionIds\n', '    ) external onlyOperator() {\n', '        uint length = _traders.length;\n', '        for (uint i = 0; i < length; i++) {\n', '            address trader = _traders[i];\n', '            require(\n', '                walletInfo[trader].userId == address(0),\n', '                "USER_WALLET_ALREADY_ADDED"\n', '            );\n', '\n', '            uint jurisdictionId = _jurisdictionIds[i];\n', '            require(jurisdictionId != 0, "INVALID_JURISDICTION_ID");\n', '\n', '            walletInfo[trader] = WalletInfo({\n', '                status: Status.Activated,\n', '                userId: trader\n', '            });\n', '            userInfo[trader] = UserInfo({\n', '                status: Status.Activated,\n', '                jurisdictionId : uint8(jurisdictionId),\n', '                startIndex : 0,\n', '                endIndex : 0,\n', '                totalTokensLocked: 0,\n', '                walletCount : 1\n', '            });\n', '            require(globalInvestorLimit.max == 0 || globalInvestorLimit.max < globalInvestorLimit.current, "EXCEEDING_MAX_INVESTORS");\n', '            InvestorLimit memory limit = jurisdictionInvestorLimit[jurisdictionId];\n', '            require(limit.max == 0 || limit.max < limit.current, "EXCEEDING_JURISDICTION_MAX_INVESTORS");\n', '            jurisdictionInvestorLimit[jurisdictionId].current++;\n', '            globalInvestorLimit.current++;\n', '            emit ApproveNewUser(trader, jurisdictionId, msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Called by an operator to add wallets to known userIds.\n', '     */\n', '    function addApprovedUserWallets(\n', '        address[] calldata _userIds,\n', '        address[] calldata _newWallets\n', '    ) external onlyOperator() {\n', '        uint length = _userIds.length;\n', '        for (uint i = 0; i < length; i++) {\n', '            address userId = _userIds[i];\n', '            require(\n', '                userInfo[userId].status != Status.Unknown,\n', '                "USER_ID_UNKNOWN"\n', '            );\n', '            address newWallet = _newWallets[i];\n', '            WalletInfo storage info = walletInfo[newWallet];\n', '            require(\n', '                info.status == Status.Unknown ||\n', '                (info.status == Status.Revoked && info.userId == userId),\n', '                "WALLET_ALREADY_ADDED"\n', '            );\n', '            walletInfo[newWallet] = WalletInfo({\n', '                status: Status.Activated,\n', '                userId: userId\n', '            });\n', '            if(userInfo[userId].walletCount == 0){\n', '                userInfo[userId].status = Status.Activated;\n', '                jurisdictionInvestorLimit[userInfo[userId].jurisdictionId].current++;\n', '                globalInvestorLimit.current++;\n', '            }\n', '            userInfo[userId].walletCount++;\n', '            emit AddApprovedUserWallet(userId, newWallet, msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Called by an operator to revoke approval for the given wallets.\n', '     * @dev If this is called in error, you can restore access with `addApprovedUserWallets`.\n', '     */\n', '    function revokeUserWallets(address[] calldata _wallets)\n', '        external\n', '        onlyOperator()\n', '    {\n', '        uint length = _wallets.length;\n', '        for (uint i = 0; i < length; i++) {\n', '            WalletInfo memory wallet = walletInfo[_wallets[i]];\n', '            require(\n', '                wallet.status != Status.Unknown,\n', '                "WALLET_NOT_FOUND"\n', '            );\n', '            userInfo[wallet.userId].walletCount--;\n', '            if(userInfo[wallet.userId].walletCount == 0){\n', '                userInfo[wallet.userId].status = Status.Revoked;\n', '                jurisdictionInvestorLimit[userInfo[wallet.userId].jurisdictionId].current--;\n', '                globalInvestorLimit.current--;\n', '            }\n', '            walletInfo[_wallets[i]].status = Status.Revoked;\n', '            emit RevokeUserWallet(_wallets[i], msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Called by an operator to change the jurisdiction\n', '     * for the given userIds.\n', '     */\n', '    function updateJurisdictionsForUserIds(\n', '        address[] calldata _userIds,\n', '        uint[] calldata _jurisdictionIds\n', '    ) external onlyOperator() {\n', '        uint length = _userIds.length;\n', '        for (uint i = 0; i < length; i++) {\n', '            address userId = _userIds[i];\n', '            require(\n', '                userInfo[userId].status != Status.Unknown,\n', '                "USER_ID_UNKNOWN"\n', '            );\n', '            uint jurisdictionId = _jurisdictionIds[i];\n', '            require(jurisdictionId != 0, "INVALID_JURISDICTION_ID");\n', '            jurisdictionInvestorLimit[userInfo[userId].jurisdictionId].current--;\n', '            userInfo[userId].jurisdictionId = uint8(jurisdictionId);\n', '            jurisdictionInvestorLimit[jurisdictionId].current++;\n', '            emit UpdateJurisdictionForUserId(userId, jurisdictionId, msg.sender);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Adds a tokenLockup for the userId.\n', '     * @dev A no-op if lockup is not required for this transfer.\n', '     * The lockup entry is merged with the most recent lockup for that user\n', '     * if the expiration date is <= `lockupGranularity` from the previous entry.\n', '     */\n', '    function _addLockup(\n', '        address _userId,\n', '        uint _lockupExpirationDate,\n', '        uint _numberOfTokensLocked\n', '    ) internal {\n', '        if (\n', '            _numberOfTokensLocked == 0 ||\n', '            _lockupExpirationDate <= block.timestamp\n', '        ) {\n', '            // This is a no-op\n', '            return;\n', '        }\n', '        emit AddLockup(\n', '            _userId,\n', '            _lockupExpirationDate,\n', '            _numberOfTokensLocked,\n', '            msg.sender\n', '        );\n', '        UserInfo storage info = userInfo[_userId];\n', '        require(info.status != Status.Unknown, "USER_ID_UNKNOWN");\n', '        require(info.totalTokensLocked + _numberOfTokensLocked >= _numberOfTokensLocked, "OVERFLOW");\n', '        info.totalTokensLocked = info.totalTokensLocked + uint128(_numberOfTokensLocked);\n', '        if (info.endIndex > 0) {\n', '            Lockup storage lockup = userIdLockups[_userId][info.endIndex - 1];\n', '            if (\n', '                lockup.lockupExpirationDate + config.lockupGranularity >= _lockupExpirationDate\n', '            ) {\n', '                // Merge with the previous entry\n', "                // if totalTokensLocked can't overflow then this value will not either\n", '                lockup.numberOfTokensLocked += uint128(_numberOfTokensLocked);\n', '                return;\n', '            }\n', '        }\n', '        // Add a new lockup entry\n', '        userIdLockups[_userId][info.endIndex] = Lockup(\n', '            uint64(_lockupExpirationDate),\n', '            uint128(_numberOfTokensLocked)\n', '        );\n', '        info.endIndex++;\n', '    }\n', '\n', '    /**\n', '     * @notice Operators can manually add lockups for userIds.\n', '     * This may be used by the organization before transfering tokens\n', '     * from the initial supply.\n', '     */\n', '    function addLockups(\n', '        address[] calldata _userIds,\n', '        uint[] calldata _lockupExpirationDates,\n', '        uint[] calldata _numberOfTokensLocked\n', '    ) external onlyOperator() {\n', '        uint length = _userIds.length;\n', '        for (uint i = 0; i < length; i++) {\n', '            _addLockup(\n', '                _userIds[i],\n', '                _lockupExpirationDates[i],\n', '                _numberOfTokensLocked[i]\n', '            );\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Checks the next lockup entry for a given user and unlocks\n', '     * those tokens if applicable.\n', '     * @param _ignoreExpiration bypasses the recorded expiration date and\n', '     * removes the lockup entry if there are any remaining for this user.\n', '     */\n', '    function _processLockup(\n', '        UserInfo storage info,\n', '        address _userId,\n', '        bool _ignoreExpiration\n', '    ) internal returns (bool isDone) {\n', '        if (info.startIndex >= info.endIndex) {\n', '            // no lockups for this user\n', '            return true;\n', '        }\n', '        Lockup storage lockup = userIdLockups[_userId][info.startIndex];\n', '        if (lockup.lockupExpirationDate > block.timestamp && !_ignoreExpiration) {\n', '            // no more eligable entries\n', '            return true;\n', '        }\n', '        emit UnlockTokens(_userId, lockup.numberOfTokensLocked, msg.sender);\n', '        info.totalTokensLocked -= lockup.numberOfTokensLocked;\n', '        info.startIndex++;\n', "        // Free up space we don't need anymore\n", '        lockup.lockupExpirationDate = 0;\n', '        lockup.numberOfTokensLocked = 0;\n', '        // There may be another entry\n', '        return false;\n', '    }\n', '\n', '    /**\n', '     * @notice Anyone can process lockups for a userId.\n', '     * This is generally unused but may be required if a given userId\n', '     * has a lot of individual lockup entries which are expired.\n', '     */\n', '    function processLockups(address _userId, uint _maxCount) external {\n', '        UserInfo storage info = userInfo[_userId];\n', '        require(info.status != Status.Unknown, "USER_ID_UNKNOWN");\n', '        for (uint i = 0; i < _maxCount; i++) {\n', '            if (_processLockup(info, _userId, false)) {\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Allows operators to remove lockup entries, bypassing the\n', '     * recorded expiration date.\n', '     * @dev This should generally remain unused. It could be used in combination with\n', '     * `addLockups` to fix an incorrect lockup expiration date or quantity.\n', '     */\n', '    function forceUnlockUpTo(address _userId, uint _maxLockupIndex)\n', '        external\n', '        onlyOperator()\n', '    {\n', '        UserInfo storage info = userInfo[_userId];\n', '        require(info.status != Status.Unknown, "USER_ID_UNKNOWN");\n', '        require(_maxLockupIndex > info.startIndex, "ALREADY_UNLOCKED");\n', '        uint maxCount = _maxLockupIndex - info.startIndex;\n', '        for (uint i = 0; i < maxCount; i++) {\n', '            if (_processLockup(info, _userId, true)) {\n', '                break;\n', '            }\n', '        }\n', '    }\n', '\n', '    function _isJurisdictionHalted(uint _jurisdictionId) internal view returns(bool){\n', '        uint until = jurisdictionHaltsUntil[_jurisdictionId];\n', '        return until != 0 && until > block.timestamp;\n', '    }\n', '\n', '    /**\n', '     * @notice halts jurisdictions of id `_jurisdictionIds` for `_duration` seconds\n', '     * @dev only owner can call this function\n', '     * @param _jurisdictionIds ids of the jurisdictions to halt\n', '     * @param _expirationTimestamps due when halt ends\n', '     **/\n', '    function halt(uint[] calldata _jurisdictionIds, uint[] calldata _expirationTimestamps) external onlyOwner {\n', '        uint length = _jurisdictionIds.length;\n', '        for(uint i = 0; i<length; i++){\n', '            _halt(_jurisdictionIds[i], _expirationTimestamps[i]);\n', '        }\n', '    }\n', '\n', '    function _halt(uint _jurisdictionId, uint _until) internal {\n', '        require(_until > block.timestamp, "HALT_DUE_SHOULD_BE_FUTURE");\n', '        jurisdictionHaltsUntil[_jurisdictionId] = uint64(_until);\n', '        emit Halt(_jurisdictionId, _until);\n', '    }\n', '\n', '    /**\n', '     * @notice resume halted jurisdiction\n', '     * @dev only owner can call this function\n', '     * @param _jurisdictionIds list of jurisdiction ids to resume\n', '     **/\n', '    function resume(uint[] calldata _jurisdictionIds) external onlyOwner{\n', '        uint length = _jurisdictionIds.length;\n', '        for(uint i = 0; i < length; i++){\n', '            _resume(_jurisdictionIds[i]);\n', '        }\n', '    }\n', '\n', '    function _resume(uint _jurisdictionId) internal {\n', '        require(jurisdictionHaltsUntil[_jurisdictionId] != 0, "ATTEMPT_TO_RESUME_NONE_HALTED_JURISDICATION");\n', '        jurisdictionHaltsUntil[_jurisdictionId] = 0;\n', '        emit Resume(_jurisdictionId);\n', '    }\n', '\n', '    /**\n', '     * @notice changes max investors limit of the contract to `_limit`\n', '     * @dev only owner can call this function\n', '     * @param _limit new investor limit for contract\n', '     */\n', '    function setInvestorLimit(uint _limit) external onlyOwner {\n', '        require(_limit >= globalInvestorLimit.current, "LIMIT_SHOULD_BE_LARGER_THAN_CURRENT_INVESTORS");\n', '        globalInvestorLimit.max = uint128(_limit);\n', '        emit MaxInvestorsChanged(_limit);\n', '    }\n', '\n', '    /**\n', '     * @notice changes max investors limit of the `_jurisdcitionId` to `_limit`\n', '     * @dev only owner can call this function\n', '     * @param _jurisdictionIds jurisdiction id to update\n', '     * @param _limits new investor limit for jurisdiction\n', '     */\n', '    function setInvestorLimitForJurisdiction(uint[] calldata _jurisdictionIds, uint[] calldata _limits) external onlyOwner {\n', '        for(uint i = 0; i<_jurisdictionIds.length; i++){\n', '            uint jurisdictionId = _jurisdictionIds[i];\n', '            uint limit = _limits[i];\n', '            require(limit >= jurisdictionInvestorLimit[jurisdictionId].current, "LIMIT_SHOULD_BE_LARGER_THAN_CURRENT_INVESTORS");\n', '            jurisdictionInvestorLimit[jurisdictionId].max = uint128(limit);\n', '            emit MaxInvestorsByJurisdictionChanged(jurisdictionId, limit);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @notice Called by the callingContract before a transfer occurs.\n', '     * @dev This call will revert when the transfer is not authorized.\n', '     * This is a mutable call to allow additional data to be recorded,\n', '     * such as when the user aquired their tokens.\n', '     **/\n', '    function authorizeTransfer(\n', '        address _from,\n', '        address _to,\n', '        uint _value,\n', '        bool _isSell\n', '    ) external {\n', '        require(address(callingContract) == msg.sender, "CALL_VIA_CONTRACT_ONLY");\n', '\n', '        if (_to == address(0) && !_isSell) {\n', '            // This is a burn, no authorization required\n', '            // You can burn locked tokens. Burning will effectively burn unlocked tokens,\n', '            // and then burn locked tokens starting with those that will be unlocked first.\n', '            return;\n', '        }\n', '        WalletInfo memory from = walletInfo[_from];\n', '        require(\n', '            (from.status != Status.Unknown && from.status != Status.Revoked) ||\n', '            _from == address(0),\n', '            "FROM_USER_UNKNOWN"\n', '        );\n', '        WalletInfo memory to = walletInfo[_to];\n', '        require(\n', '            (to.status != Status.Unknown && to.status != Status.Revoked) ||\n', '            _to == address(0),\n', '            "TO_USER_UNKNOWN"\n', '        );\n', '\n', '        // A single user can move funds between wallets they control without restriction\n', '        if (from.userId != to.userId) {\n', '            uint fromJurisdictionId = userInfo[from.userId]\n', '            .jurisdictionId;\n', '            uint toJurisdictionId = userInfo[to.userId].jurisdictionId;\n', '\n', '            require(!_isJurisdictionHalted(fromJurisdictionId), "FROM_JURISDICTION_HALTED");\n', '            require(!_isJurisdictionHalted(toJurisdictionId), "TO_JURISDICTION_HALTED");\n', '\n', '            uint lockupLength = jurisdictionFlows[fromJurisdictionId][toJurisdictionId];\n', '            require(lockupLength > 0, "DENIED: JURISDICTION_FLOW");\n', '\n', '            // If the lockupLength is 1 then we interpret this as approved without any lockup\n', '            // This means any token lockup period must be at least 2 seconds long in order to apply.\n', '            if (lockupLength > 1 && _to != address(0)) {\n', '                // Lockup may apply for any action other than burn/sell (e.g. buy/pay/transfer)\n', '                uint lockupExpirationDate = block.timestamp + lockupLength;\n', '                _addLockup(to.userId, lockupExpirationDate, _value);\n', '            }\n', '\n', '            if (_from == address(0)) {\n', '                // This is minting (buy or pay)\n', '                require(block.timestamp >= config.startDate, "WAIT_FOR_START_DATE");\n', '            } else {\n', '                // This is a transfer (or sell)\n', '                UserInfo storage info = userInfo[from.userId];\n', '                while (true) {\n', '                    if (_processLockup(info, from.userId, false)) {\n', '                        break;\n', '                    }\n', '                }\n', '                uint balance = callingContract.balanceOf(_from);\n', '                // This first require is redundant, but allows us to provide\n', '                // a more clear error message.\n', '                require(balance >= _value, "INSUFFICIENT_BALANCE");\n', '                require(\n', '                    _isSell ||\n', '                    balance >= info.totalTokensLocked + _value,\n', '                    "INSUFFICIENT_TRANSFERABLE_BALANCE"\n', '                );\n', '            }\n', '        }\n', '    }\n', '}']