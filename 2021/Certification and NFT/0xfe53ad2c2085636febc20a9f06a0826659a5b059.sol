['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-10\n', '*/\n', '\n', '/*\n', 'https://powerpool.finance/\n', '\n', '          wrrrw r wrr\n', '         ppwr rrr wppr0       prwwwrp                                 prwwwrp                   wr0\n', '        rr 0rrrwrrprpwp0      pp   pr  prrrr0 pp   0r  prrrr0  0rwrrr pp   pr  prrrr0  prrrr0    r0\n', '        rrp pr   wr00rrp      prwww0  pp   wr pp w00r prwwwpr  0rw    prwww0  pp   wr pp   wr    r0\n', '        r0rprprwrrrp pr0      pp      wr   pr pp rwwr wr       0r     pp      wr   pr wr   pr    r0\n', '         prwr wrr0wpwr        00        www0   0w0ww    www0   0w     00        www0    www0   0www0\n', '          wrr ww0rrrr\n', '\n', '*/\n', '// SPDX-License-Identifier: GPL-3.0\n', '\n', '// File: @openzeppelin/upgrades-core/contracts/Initializable.sol\n', '\n', 'pragma solidity >=0.4.24 <0.7.0;\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '\n', '  /**\n', '   * @dev Indicates that the contract has been initialized.\n', '   */\n', '  bool private initialized;\n', '\n', '  /**\n', '   * @dev Indicates that the contract is in the process of being initialized.\n', '   */\n', '  bool private initializing;\n', '\n', '  /**\n', '   * @dev Modifier to use in the initializer function of a contract.\n', '   */\n', '  modifier initializer() {\n', '    require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '    bool isTopLevelCall = !initializing;\n', '    if (isTopLevelCall) {\n', '      initializing = true;\n', '      initialized = true;\n', '    }\n', '\n', '    _;\n', '\n', '    if (isTopLevelCall) {\n', '      initializing = false;\n', '    }\n', '  }\n', '\n', '  /// @dev Returns true if and only if the function is running in the constructor\n', '  function isConstructor() private view returns (bool) {\n', '    // extcodesize checks the size of the code stored in an address, and\n', '    // address returns the current address. Since the code is still not\n', '    // deployed when running a constructor, any checks on its code size will\n', '    // yield zero, making it an effective way to detect if a contract is\n', '    // under construction or not.\n', '    address self = address(this);\n', '    uint256 cs;\n', '    assembly { cs := extcodesize(self) }\n', '    return cs == 0;\n', '  }\n', '\n', '  // Reserved storage space to allow for layout changes in the future.\n', '  uint256[50] private ______gap;\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Contract module that helps prevent reentrant calls to a function.\n', ' *\n', ' * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n', ' * available, which can be applied to functions to make sure there are no nested\n', ' * (reentrant) calls to them.\n', ' *\n', ' * Note that because there is a single `nonReentrant` guard, functions marked as\n', ' * `nonReentrant` may not call one another. This can be worked around by making\n', ' * those functions `private`, and then adding `external` `nonReentrant` entry\n', ' * points to them.\n', ' *\n', ' * TIP: If you would like to learn more about reentrancy and alternative ways\n', ' * to protect against it, check out our blog post\n', ' * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n', ' */\n', 'abstract contract ReentrancyGuard {\n', '    // Booleans are more expensive than uint256 or any type that takes up a full\n', '    // word because each write operation emits an extra SLOAD to first read the\n', "    // slot's contents, replace the bits taken up by the boolean, and then write\n", "    // back. This is the compiler's defense against contract upgrades and\n", '    // pointer aliasing, and it cannot be disabled.\n', '\n', '    // The values being non-zero value makes deployment a bit more expensive,\n', '    // but in exchange the refund on every call to nonReentrant will be lower in\n', '    // amount. Since refunds are capped to a percentage of the total\n', "    // transaction's gas, it is best to keep them low in cases like this one, to\n", '    // increase the likelihood of the full refund coming into effect.\n', '    uint256 private constant _NOT_ENTERED = 1;\n', '    uint256 private constant _ENTERED = 2;\n', '\n', '    uint256 private _status;\n', '\n', '    constructor () internal {\n', '        _status = _NOT_ENTERED;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _status = _ENTERED;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _status = _NOT_ENTERED;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/Math.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Standard math utilities missing in the Solidity language.\n', ' */\n', 'library Math {\n', '    /**\n', '     * @dev Returns the largest of two numbers.\n', '     */\n', '    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a >= b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the average of two numbers. The result is rounded towards\n', '     * zero.\n', '     */\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '}\n', '\n', '// File: contracts/interfaces/IPowerOracle.sol\n', '\n', 'pragma solidity ^0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IPowerOracle {\n', '  enum ReportInterval { LESS_THAN_MIN, OK, GREATER_THAN_MAX }\n', '\n', '  function pokeFromReporter(\n', '    uint256 reporterId_,\n', '    string[] memory symbols_,\n', '    bytes calldata rewardOpts\n', '  ) external;\n', '\n', '  function pokeFromSlasher(\n', '    uint256 slasherId_,\n', '    string[] memory symbols_,\n', '    bytes calldata rewardOpts\n', '  ) external;\n', '\n', '  function poke(string[] memory symbols_) external;\n', '\n', '  function slasherHeartbeat(uint256 slasherId) external;\n', '\n', '  /*** Owner Interface ***/\n', '  function setPowerPoke(address powerOracleStaking) external;\n', '\n', '  function pause() external;\n', '\n', '  function unpause() external;\n', '\n', '  /*** Viewers ***/\n', '  function getPriceByAsset(address token) external view returns (uint256);\n', '\n', '  function getPriceBySymbol(string calldata symbol) external view returns (uint256);\n', '\n', '  function getPriceBySymbolHash(bytes32 symbolHash) external view returns (uint256);\n', '\n', '  function getUnderlyingPrice(address cToken) external view returns (uint256);\n', '\n', '  function assetPrices(address token) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/interfaces/IUniswapV2Router02.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IUniswapV2Router02 {\n', '  function swapExactTokensForETH(\n', '    uint256 amountIn,\n', '    uint256 amountOutMin,\n', '    address[] calldata path,\n', '    address to,\n', '    uint256 deadline\n', '  ) external returns (uint256[] memory amounts);\n', '}\n', '\n', '// File: contracts/interfaces/IEACAggregatorProxy.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IEACAggregatorProxy {\n', '  function latestAnswer() external view returns (int256);\n', '}\n', '\n', '// File: contracts/interfaces/IPowerPoke.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IPowerPoke {\n', "  /*** CLIENT'S CONTRACT INTERFACE ***/\n", '  function authorizeReporter(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizeNonReporter(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizeNonReporterWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinDeposit_\n', '  ) external view;\n', '\n', '  function authorizePoker(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizePokerWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinStake_\n', '  ) external view;\n', '\n', '  function slashReporter(uint256 slasherId_, uint256 times_) external;\n', '\n', '  function reward(\n', '    uint256 userId_,\n', '    uint256 gasUsed_,\n', '    uint256 compensationPlan_,\n', '    bytes calldata pokeOptions_\n', '  ) external;\n', '\n', '  /*** CLIENT OWNER INTERFACE ***/\n', '  function transferClientOwnership(address client_, address to_) external;\n', '\n', '  function addCredit(address client_, uint256 amount_) external;\n', '\n', '  function withdrawCredit(\n', '    address client_,\n', '    address to_,\n', '    uint256 amount_\n', '  ) external;\n', '\n', '  function setReportIntervals(\n', '    address client_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external;\n', '\n', '  function setSlasherHeartbeat(address client_, uint256 slasherHeartbeat_) external;\n', '\n', '  function setGasPriceLimit(address client_, uint256 gasPriceLimit_) external;\n', '\n', '  function setFixedCompensations(\n', '    address client_,\n', '    uint256 eth_,\n', '    uint256 cvp_\n', '  ) external;\n', '\n', '  function setBonusPlan(\n', '    address client_,\n', '    uint256 planId_,\n', '    bool active_,\n', '    uint64 bonusNominator_,\n', '    uint64 bonusDenominator_,\n', '    uint64 perGas_\n', '  ) external;\n', '\n', '  function setMinimalDeposit(address client_, uint256 defaultMinDeposit_) external;\n', '\n', '  /*** POKER INTERFACE ***/\n', '  function withdrawRewards(uint256 userId_, address to_) external;\n', '\n', '  function setPokerKeyRewardWithdrawAllowance(uint256 userId_, bool allow_) external;\n', '\n', '  /*** OWNER INTERFACE ***/\n', '  function addClient(\n', '    address client_,\n', '    address owner_,\n', '    bool canSlash_,\n', '    uint256 gasPriceLimit_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external;\n', '\n', '  function setClientActiveFlag(address client_, bool active_) external;\n', '\n', '  function setCanSlashFlag(address client_, bool canSlash) external;\n', '\n', '  function setOracle(address oracle_) external;\n', '\n', '  function pause() external;\n', '\n', '  function unpause() external;\n', '\n', '  /*** GETTERS ***/\n', '  function creditOf(address client_) external view returns (uint256);\n', '\n', '  function ownerOf(address client_) external view returns (address);\n', '\n', '  function getMinMaxReportIntervals(address client_) external view returns (uint256 min, uint256 max);\n', '\n', '  function getSlasherHeartbeat(address client_) external view returns (uint256);\n', '\n', '  function getGasPriceLimit(address client_) external view returns (uint256);\n', '\n', '  function getPokerBonus(\n', '    address client_,\n', '    uint256 bonusPlanId_,\n', '    uint256 gasUsed_,\n', '    uint256 userDeposit_\n', '  ) external view returns (uint256);\n', '\n', '  function getGasPriceFor(address client_) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/utils/PowerOwnable.sol\n', '\n', '// A modified version of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/access/Ownable.sol\n', '// with no GSN Context support and _transferOwnership internal method\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract PowerOwnable {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev Initializes the contract setting the deployer as the initial owner.\n', '   */\n', '  constructor() internal {\n', '    _owner = msg.sender;\n', '    emit OwnershipTransferred(address(0), msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(_owner == msg.sender, "NOT_THE_OWNER");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Leaves the contract without owner. It will not be possible to call\n', '   * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '   *\n', '   * NOTE: Renouncing ownership will leave the contract without an owner,\n', '   * thereby removing any functionality that is only available to the owner.\n', '   */\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "NEW_OWNER_IS_NULL");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '   */\n', '  function _transferOwnership(address newOwner) internal {\n', '    require(newOwner != address(0), "NEW_OWNER_IS_NULL");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/utils/PowerPausable.sol\n', '\n', '// A modified version of https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.2.0/contracts/utils/Pausable.sol\n', '// with no GSN Context support and no construct\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', ' * @dev Contract module which allows children to implement an emergency stop\n', ' * mechanism that can be triggered by an authorized account.\n', ' *\n', ' * This module is used through inheritance. It will make available the\n', ' * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n', ' * the functions of your contract. Note that they will not be pausable by\n', ' * simply including this module, only once the modifiers are put in place.\n', ' */\n', 'contract PowerPausable {\n', '  /**\n', '   * @dev Emitted when the pause is triggered by `account`.\n', '   */\n', '  event Paused(address account);\n', '\n', '  /**\n', '   * @dev Emitted when the pause is lifted by `account`.\n', '   */\n', '  event Unpaused(address account);\n', '\n', '  bool private _paused;\n', '\n', '  /**\n', '   * @dev Returns true if the contract is paused, and false otherwise.\n', '   */\n', '  function paused() public view returns (bool) {\n', '    return _paused;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is not paused.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must not be paused.\n', '   */\n', '  modifier whenNotPaused() {\n', '    require(!_paused, "PAUSED");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Modifier to make a function callable only when the contract is paused.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must be paused.\n', '   */\n', '  modifier whenPaused() {\n', '    require(_paused, "NOT_PAUSED");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Triggers stopped state.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must not be paused.\n', '   */\n', '  function _pause() internal virtual whenNotPaused {\n', '    _paused = true;\n', '    emit Paused(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns to normal state.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The contract must be paused.\n', '   */\n', '  function _unpause() internal virtual whenPaused {\n', '    _paused = false;\n', '    emit Unpaused(msg.sender);\n', '  }\n', '}\n', '\n', '// File: contracts/interfaces/IPowerPokeStaking.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IPowerPokeStaking {\n', '  enum UserStatus { UNAUTHORIZED, HDH, MEMBER }\n', '\n', '  /*** User Interface ***/\n', '  function createDeposit(uint256 userId_, uint256 amount_) external;\n', '\n', '  function executeDeposit(uint256 userId_) external;\n', '\n', '  function createWithdrawal(uint256 userId_, uint256 amount_) external;\n', '\n', '  function executeWithdrawal(uint256 userId_, address to_) external;\n', '\n', '  function createUser(\n', '    address adminKey_,\n', '    address reporterKey_,\n', '    uint256 depositAmount\n', '  ) external;\n', '\n', '  function updateUser(\n', '    uint256 userId,\n', '    address adminKey_,\n', '    address reporterKey_\n', '  ) external;\n', '\n', '  /*** Owner Interface ***/\n', '  function setSlasher(address slasher) external;\n', '\n', '  function setSlashingPct(uint256 slasherRewardPct, uint256 reservoirRewardPct) external;\n', '\n', '  function setTimeouts(uint256 depositTimeout_, uint256 withdrawalTimeout_) external;\n', '\n', '  function pause() external;\n', '\n', '  function unpause() external;\n', '\n', '  /*** PowerOracle Contract Interface ***/\n', '  function slashHDH(uint256 slasherId_, uint256 times_) external;\n', '\n', '  /*** Permissionless Interface ***/\n', '  function setHDH(uint256 candidateId_) external;\n', '\n', '  /*** Viewers ***/\n', '  function getHDHID() external view returns (uint256);\n', '\n', '  function getHighestDeposit() external view returns (uint256);\n', '\n', '  function getDepositOf(uint256 userId) external view returns (uint256);\n', '\n', '  function getPendingDepositOf(uint256 userId_) external view returns (uint256 balance, uint256 timeout);\n', '\n', '  function getPendingWithdrawalOf(uint256 userId_) external view returns (uint256 balance, uint256 timeout);\n', '\n', '  function getSlashAmount(uint256 slasheeId_, uint256 times_)\n', '    external\n', '    view\n', '    returns (\n', '      uint256 slasherReward,\n', '      uint256 reservoirReward,\n', '      uint256 totalSlash\n', '    );\n', '\n', '  function getUserStatus(\n', '    uint256 userId_,\n', '    address reporterKey_,\n', '    uint256 minDeposit_\n', '  ) external view returns (UserStatus);\n', '\n', '  function authorizeHDH(uint256 userId_, address reporterKey_) external view;\n', '\n', '  function authorizeNonHDH(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view;\n', '\n', '  function authorizeMember(\n', '    uint256 userId_,\n', '    address reporterKey_,\n', '    uint256 minDeposit_\n', '  ) external view;\n', '\n', '  function requireValidAdminKey(uint256 userId_, address adminKey_) external view;\n', '\n', '  function requireValidAdminOrPokerKey(uint256 userId_, address adminOrPokerKey_) external view;\n', '\n', '  function getLastDepositChange(uint256 userId_) external view returns (uint256);\n', '}\n', '\n', '// File: contracts/PowerPokeStakingStorageV1.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'contract PowerPokeStakingStorageV1 {\n', '  struct User {\n', '    address adminKey;\n', '    address pokerKey;\n', '    uint256 deposit;\n', '    uint256 pendingDeposit;\n', '    uint256 pendingDepositTimeout;\n', '    uint256 pendingWithdrawal;\n', '    uint256 pendingWithdrawalTimeout;\n', '  }\n', '\n', '  /// @notice The deposit timeout in seconds\n', '  uint256 public depositTimeout;\n', '\n', '  /// @notice The withdrawal timeout in seconds\n', '  uint256 public withdrawalTimeout;\n', '\n', '  /// @notice The reservoir which holds CVP tokens\n', '  address public reservoir;\n', '\n', '  /// @notice The slasher address (PowerPoke)\n', '  address public slasher;\n', '\n', '  /// @notice The total amount of all deposits\n', '  uint256 public totalDeposit;\n', '\n', '  /// @notice The share of a slasher in slashed deposit per one outdated asset (1 eth == 1%)\n', '  uint256 public slasherSlashingRewardPct;\n', '\n', '  /// @notice The share of the protocol(reservoir) in slashed deposit per one outdated asset (1 eth == 1%)\n', '  uint256 public protocolSlashingRewardPct;\n', '\n', '  /// @notice The incremented user ID counter. Is updated only within createUser function call\n', '  uint256 public userIdCounter;\n', '\n', '  /// @dev The highest deposit. Usually of the current reporterId. Is safe to be outdated.\n', '  uint256 internal _highestDeposit;\n', '\n', '  /// @dev The current highest deposit holder ID.\n', '  uint256 internal _hdhId;\n', '\n', "  /// @notice User details by it's ID\n", '  mapping(uint256 => User) public users;\n', '\n', '  /// @dev Last deposit change timestamp by user ID\n', '  mapping(uint256 => uint256) internal _lastDepositChange;\n', '}\n', '\n', '// File: contracts/PowerPokeStaking.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PowerPokeStaking is IPowerPokeStaking, PowerOwnable, Initializable, PowerPausable, PowerPokeStakingStorageV1 {\n', '  using SafeMath for uint256;\n', '\n', '  uint256 public constant HUNDRED_PCT = 100 ether;\n', '\n', '  /// @notice The event emitted when a new user is created\n', '  event CreateUser(uint256 indexed userId, address indexed adminKey, address indexed pokerKey, uint256 initialDeposit);\n', '\n', '  /// @notice The event emitted when an existing user is updated\n', '  event UpdateUser(uint256 indexed userId, address indexed adminKey, address indexed pokerKey);\n', '\n', '  /// @notice The event emitted when the user creates pending deposit\n', '  event CreateDeposit(\n', '    uint256 indexed userId,\n', '    address indexed depositor,\n', '    uint256 pendingTimeout,\n', '    uint256 amount,\n', '    uint256 pendingDepositAfter\n', '  );\n', '\n', '  /// @notice The event emitted when the user transfers his deposit from pending to the active\n', '  event ExecuteDeposit(uint256 indexed userId, uint256 pendingTimeout, uint256 amount, uint256 depositAfter);\n', '\n', '  /// @notice The event emitted when the user creates pending deposit\n', '  event CreateWithdrawal(\n', '    uint256 indexed userId,\n', '    uint256 pendingTimeout,\n', '    uint256 amount,\n', '    uint256 pendingWithdrawalAfter,\n', '    uint256 depositAfter\n', '  );\n', '\n', '  /// @notice The event emitted when a valid admin key withdraws funds from\n', '  event ExecuteWithdrawal(uint256 indexed userId, address indexed to, uint256 pendingTimeout, uint256 amount);\n', '\n', '  /// @notice The event emitted when the owner sets new slashing percent values, where 1ether == 1%\n', '  event SetSlashingPct(uint256 slasherSlashingRewardPct, uint256 protocolSlashingRewardPct);\n', '\n', '  /// @notice The event emitted when the owner sets new deposit and withdrawal timeouts\n', '  event SetTimeouts(uint256 depositTimeout, uint256 withdrawalTimeout);\n', '\n', '  /// @notice The event emitted when the owner sets a new PowerOracle linked contract\n', '  event SetSlasher(address powerOracle);\n', '\n', '  /// @notice The event emitted when an arbitrary user fixes an outdated reporter userId record\n', '  event SetReporter(uint256 indexed reporterId, address indexed msgSender);\n', '\n', '  /// @notice The event emitted when the PowerOracle contract requests to slash a user with the given ID\n', '  event Slash(uint256 indexed slasherId, uint256 indexed reporterId, uint256 slasherReward, uint256 reservoirReward);\n', '\n', '  /// @notice The event emitted when the existing reporter is replaced with a new one due some reason\n', '  event ReporterChange(\n', '    uint256 indexed prevId,\n', '    uint256 indexed nextId,\n', '    uint256 highestDepositPrev,\n', '    uint256 actualDepositPrev,\n', '    uint256 actualDepositNext\n', '  );\n', '\n', '  /// @notice CVP token address\n', '  IERC20 public immutable CVP_TOKEN;\n', '\n', '  constructor(address cvpToken_) public {\n', '    require(cvpToken_ != address(0), "CVP_ADDR_IS_0");\n', '\n', '    CVP_TOKEN = IERC20(cvpToken_);\n', '  }\n', '\n', '  function initialize(\n', '    address owner_,\n', '    address reservoir_,\n', '    address slasher_,\n', '    uint256 slasherSlashingRewardPct_,\n', '    uint256 reservoirSlashingRewardPct_,\n', '    uint256 depositTimeout_,\n', '    uint256 withdrawTimeout_\n', '  ) external initializer {\n', '    require(depositTimeout_ > 0, "DEPOSIT_TIMEOUT_IS_0");\n', '    require(withdrawTimeout_ > 0, "WITHDRAW_TIMEOUT_IS_0");\n', '\n', '    _transferOwnership(owner_);\n', '    reservoir = reservoir_;\n', '    slasher = slasher_;\n', '    slasherSlashingRewardPct = slasherSlashingRewardPct_;\n', '    protocolSlashingRewardPct = reservoirSlashingRewardPct_;\n', '    depositTimeout = depositTimeout_;\n', '    withdrawalTimeout = withdrawTimeout_;\n', '  }\n', '\n', '  /*** User Interface ***/\n', '\n', '  /**\n', '   * @notice An arbitrary user deposits CVP stake to the contract for the given user ID\n', '   * @param userId_ The user ID to make deposit for\n', '   * @param amount_ The amount in CVP tokens to deposit\n', '   */\n', '  function createDeposit(uint256 userId_, uint256 amount_) external override whenNotPaused {\n', '    require(amount_ > 0, "MISSING_AMOUNT");\n', '\n', '    User storage user = users[userId_];\n', '\n', '    require(user.adminKey != address(0), "INVALID_USER");\n', '\n', '    _createDeposit(userId_, amount_);\n', '  }\n', '\n', '  function _createDeposit(uint256 userId_, uint256 amount_) internal {\n', '    User storage user = users[userId_];\n', '\n', '    uint256 pendingDepositAfter = user.pendingDeposit.add(amount_);\n', '    uint256 timeout = block.timestamp.add(depositTimeout);\n', '\n', '    user.pendingDeposit = pendingDepositAfter;\n', '    user.pendingDepositTimeout = timeout;\n', '\n', '    emit CreateDeposit(userId_, msg.sender, timeout, amount_, pendingDepositAfter);\n', '    CVP_TOKEN.transferFrom(msg.sender, address(this), amount_);\n', '  }\n', '\n', '  function executeDeposit(uint256 userId_) external override {\n', '    User storage user = users[userId_];\n', '    uint256 amount = user.pendingDeposit;\n', '    uint256 pendingDepositTimeout = user.pendingDepositTimeout;\n', '\n', '    // check\n', '    require(user.adminKey == msg.sender, "ONLY_ADMIN_ALLOWED");\n', '    require(amount > 0, "NO_PENDING_DEPOSIT");\n', '    require(block.timestamp >= pendingDepositTimeout, "TIMEOUT_NOT_PASSED");\n', '\n', '    // increment deposit\n', '    uint256 depositAfter = user.deposit.add(amount);\n', '    user.deposit = depositAfter;\n', '    totalDeposit = totalDeposit.add(amount);\n', '\n', '    // reset pending deposit\n', '    user.pendingDeposit = 0;\n', '    user.pendingDepositTimeout = 0;\n', '\n', '    _lastDepositChange[userId_] = block.timestamp;\n', '\n', '    _trySetHighestDepositHolder(userId_, depositAfter);\n', '\n', '    emit ExecuteDeposit(userId_, pendingDepositTimeout, amount, depositAfter);\n', '  }\n', '\n', '  function _trySetHighestDepositHolder(uint256 candidateId_, uint256 candidateDepositAfter_) internal {\n', '    uint256 prevHdhID = _hdhId;\n', '    uint256 prevDeposit = users[prevHdhID].deposit;\n', '\n', '    if (candidateDepositAfter_ > prevDeposit && prevHdhID != candidateId_) {\n', '      emit ReporterChange(prevHdhID, candidateId_, _highestDeposit, users[prevHdhID].deposit, candidateDepositAfter_);\n', '\n', '      _highestDeposit = candidateDepositAfter_;\n', '      _hdhId = candidateId_;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice A valid users admin key withdraws the deposited stake form the contract\n', '   * @param userId_ The user ID to withdraw deposit from\n', '   * @param amount_ The amount in CVP tokens to withdraw\n', '   */\n', '  function createWithdrawal(uint256 userId_, uint256 amount_) external override {\n', '    require(amount_ > 0, "MISSING_AMOUNT");\n', '\n', '    User storage user = users[userId_];\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '\n', '    // decrement deposit\n', '    uint256 depositBefore = user.deposit;\n', '    require(amount_ <= depositBefore, "AMOUNT_EXCEEDS_DEPOSIT");\n', '\n', '    uint256 depositAfter = depositBefore - amount_;\n', '    user.deposit = depositAfter;\n', '    totalDeposit = totalDeposit.sub(amount_);\n', '\n', '    // increment pending withdrawal\n', '    uint256 pendingWithdrawalAfter = user.pendingWithdrawal.add(amount_);\n', '    uint256 timeout = block.timestamp.add(withdrawalTimeout);\n', '    user.pendingWithdrawal = pendingWithdrawalAfter;\n', '    user.pendingWithdrawalTimeout = timeout;\n', '\n', '    _lastDepositChange[userId_] = block.timestamp;\n', '\n', '    emit CreateWithdrawal(userId_, timeout, amount_, pendingWithdrawalAfter, depositAfter);\n', '  }\n', '\n', '  function executeWithdrawal(uint256 userId_, address to_) external override {\n', '    require(to_ != address(0), "CANT_WITHDRAW_TO_0");\n', '\n', '    User storage user = users[userId_];\n', '\n', '    uint256 pendingWithdrawalTimeout = user.pendingWithdrawalTimeout;\n', '    uint256 amount = user.pendingWithdrawal;\n', '\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '    require(amount > 0, "NO_PENDING_WITHDRAWAL");\n', '    require(block.timestamp >= pendingWithdrawalTimeout, "TIMEOUT_NOT_PASSED");\n', '\n', '    user.pendingWithdrawal = 0;\n', '    user.pendingWithdrawalTimeout = 0;\n', '\n', '    emit ExecuteWithdrawal(userId_, to_, pendingWithdrawalTimeout, amount);\n', '    CVP_TOKEN.transfer(to_, amount);\n', '  }\n', '\n', '  /**\n', '   * @notice Creates a new user ID and stores the given keys\n', '   * @param adminKey_ The admin key for the new user\n', '   * @param pokerKey_ The poker key for the new user\n', '   * @param initialDeposit_ The initial deposit to be transferred to this contract\n', '   */\n', '  function createUser(\n', '    address adminKey_,\n', '    address pokerKey_,\n', '    uint256 initialDeposit_\n', '  ) external override whenNotPaused {\n', '    uint256 userId = ++userIdCounter;\n', '\n', '    users[userId] = User(adminKey_, pokerKey_, 0, 0, 0, 0, 0);\n', '\n', '    emit CreateUser(userId, adminKey_, pokerKey_, initialDeposit_);\n', '\n', '    if (initialDeposit_ > 0) {\n', '      _createDeposit(userId, initialDeposit_);\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Updates an existing user, only the current adminKey is eligible calling this method.\n', '   * @param adminKey_ The new admin key for the user\n', '   * @param pokerKey_ The new poker key for the user\n', '   */\n', '  function updateUser(\n', '    uint256 userId_,\n', '    address adminKey_,\n', '    address pokerKey_\n', '  ) external override {\n', '    User storage user = users[userId_];\n', '    require(msg.sender == user.adminKey, "ONLY_ADMIN_ALLOWED");\n', '\n', '    if (adminKey_ != user.adminKey) {\n', '      user.adminKey = adminKey_;\n', '    }\n', '    if (pokerKey_ != user.pokerKey) {\n', '      user.pokerKey = pokerKey_;\n', '    }\n', '\n', '    emit UpdateUser(userId_, adminKey_, pokerKey_);\n', '  }\n', '\n', '  /*** SLASHER INTERFACE ***/\n', '\n', '  /**\n', '   * @notice Slashes the current reporter if it did not make poke() call during the given report interval\n', '   * @param slasherId_ The slasher ID\n', '   * @param times_ The multiplier for a single slashing percent\n', '   */\n', '  function slashHDH(uint256 slasherId_, uint256 times_) external virtual override {\n', '    require(msg.sender == slasher, "ONLY_SLASHER_ALLOWED");\n', '\n', '    uint256 hdhId = _hdhId;\n', '    uint256 hdhDeposit = users[hdhId].deposit;\n', '\n', '    (uint256 slasherReward, uint256 reservoirReward, ) = getSlashAmount(hdhId, times_);\n', '\n', '    uint256 amount = slasherReward.add(reservoirReward);\n', '    require(hdhDeposit >= amount, "INSUFFICIENT_HDH_DEPOSIT");\n', '\n', '    // users[reporterId].deposit = reporterDeposit - slasherReward - reservoirReward;\n', '    users[hdhId].deposit = hdhDeposit.sub(amount);\n', '\n', '    // totalDeposit = totalDeposit - reservoirReward; (slasherReward is kept on the contract)\n', '    totalDeposit = totalDeposit.sub(reservoirReward);\n', '\n', '    if (slasherReward > 0) {\n', '      // uint256 slasherDepositAfter = users[slasherId_].deposit + slasherReward\n', '      uint256 slasherDepositAfter = users[slasherId_].deposit.add(slasherReward);\n', '      users[slasherId_].deposit = slasherDepositAfter;\n', '      _trySetHighestDepositHolder(slasherId_, slasherDepositAfter);\n', '    }\n', '\n', '    if (reservoirReward > 0) {\n', '      CVP_TOKEN.transfer(reservoir, reservoirReward);\n', '    }\n', '\n', '    emit Slash(slasherId_, hdhId, slasherReward, reservoirReward);\n', '  }\n', '\n', '  /*** OWNER INTERFACE ***/\n', '\n', '  /**\n', '   * @notice The owner sets a new slasher address\n', '   * @param slasher_ The slasher address to set\n', '   */\n', '  function setSlasher(address slasher_) external override onlyOwner {\n', '    slasher = slasher_;\n', '    emit SetSlasher(slasher_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner sets the new slashing percent values\n', "   * @param slasherSlashingRewardPct_ The slasher share will be accrued on the slasher's deposit\n", '   * @param protocolSlashingRewardPct_ The protocol share will immediately be transferred to reservoir\n', '   */\n', '  function setSlashingPct(uint256 slasherSlashingRewardPct_, uint256 protocolSlashingRewardPct_)\n', '    external\n', '    override\n', '    onlyOwner\n', '  {\n', '    require(slasherSlashingRewardPct_.add(protocolSlashingRewardPct_) <= HUNDRED_PCT, "INVALID_SUM");\n', '\n', '    slasherSlashingRewardPct = slasherSlashingRewardPct_;\n', '    protocolSlashingRewardPct = protocolSlashingRewardPct_;\n', '    emit SetSlashingPct(slasherSlashingRewardPct_, protocolSlashingRewardPct_);\n', '  }\n', '\n', '  function setTimeouts(uint256 depositTimeout_, uint256 withdrawalTimeout_) external override onlyOwner {\n', '    depositTimeout = depositTimeout_;\n', '    withdrawalTimeout = withdrawalTimeout_;\n', '    emit SetTimeouts(depositTimeout_, withdrawalTimeout_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner pauses poke*-operations\n', '   */\n', '  function pause() external override onlyOwner {\n', '    _pause();\n', '  }\n', '\n', '  /**\n', '   * @notice The owner unpauses poke*-operations\n', '   */\n', '  function unpause() external override onlyOwner {\n', '    _unpause();\n', '  }\n', '\n', '  /*** PERMISSIONLESS INTERFACE ***/\n', '\n', '  /**\n', '   * @notice Set a given address as a reporter if his deposit is higher than the current highestDeposit\n', '   * @param candidateId_ Te candidate address to try\n', '   */\n', '  function setHDH(uint256 candidateId_) external override {\n', '    uint256 candidateDeposit = users[candidateId_].deposit;\n', '    uint256 prevHdhId = _hdhId;\n', '    uint256 currentReporterDeposit = users[prevHdhId].deposit;\n', '\n', '    require(candidateDeposit > currentReporterDeposit, "INSUFFICIENT_CANDIDATE_DEPOSIT");\n', '\n', '    emit ReporterChange(prevHdhId, candidateId_, _highestDeposit, currentReporterDeposit, candidateDeposit);\n', '    emit SetReporter(candidateId_, msg.sender);\n', '\n', '    _highestDeposit = candidateDeposit;\n', '    _hdhId = candidateId_;\n', '  }\n', '\n', '  /*** VIEWERS ***/\n', '\n', '  function getHDHID() external view override returns (uint256) {\n', '    return _hdhId;\n', '  }\n', '\n', '  function getHighestDeposit() external view override returns (uint256) {\n', '    return _highestDeposit;\n', '  }\n', '\n', '  function getDepositOf(uint256 userId_) external view override returns (uint256) {\n', '    return users[userId_].deposit;\n', '  }\n', '\n', '  function getPendingDepositOf(uint256 userId_) external view override returns (uint256 balance, uint256 timeout) {\n', '    return (users[userId_].pendingDeposit, users[userId_].pendingDepositTimeout);\n', '  }\n', '\n', '  function getPendingWithdrawalOf(uint256 userId_) external view override returns (uint256 balance, uint256 timeout) {\n', '    return (users[userId_].pendingWithdrawal, users[userId_].pendingWithdrawalTimeout);\n', '  }\n', '\n', '  function getSlashAmount(uint256 slasheeId_, uint256 times_)\n', '    public\n', '    view\n', '    override\n', '    returns (\n', '      uint256 slasherReward,\n', '      uint256 reservoirReward,\n', '      uint256 totalSlash\n', '    )\n', '  {\n', '    uint256 product = times_.mul(users[slasheeId_].deposit);\n', '    // slasherReward = times_ * reporterDeposit * slasherRewardPct / HUNDRED_PCT;\n', '    slasherReward = product.mul(slasherSlashingRewardPct) / HUNDRED_PCT;\n', '    // reservoirReward = times_ * reporterDeposit * reservoirSlashingRewardPct / HUNDRED_PCT;\n', '    reservoirReward = product.mul(protocolSlashingRewardPct) / HUNDRED_PCT;\n', '    // totalSlash = slasherReward + reservoirReward\n', '    totalSlash = slasherReward.add(reservoirReward);\n', '  }\n', '\n', '  function getUserStatus(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view override returns (UserStatus) {\n', '    if (userId_ == _hdhId && users[userId_].pokerKey == pokerKey_) {\n', '      return UserStatus.HDH;\n', '    }\n', '    if (users[userId_].deposit >= minDeposit_ && users[userId_].pokerKey == pokerKey_) {\n', '      return UserStatus.MEMBER;\n', '    }\n', '    return UserStatus.UNAUTHORIZED;\n', '  }\n', '\n', '  function authorizeHDH(uint256 userId_, address pokerKey_) external view override {\n', '    require(userId_ == _hdhId, "NOT_HDH");\n', '    require(users[userId_].pokerKey == pokerKey_, "INVALID_POKER_KEY");\n', '  }\n', '\n', '  function authorizeNonHDH(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) external view override {\n', '    require(userId_ != _hdhId, "IS_HDH");\n', '    authorizeMember(userId_, pokerKey_, minDeposit_);\n', '  }\n', '\n', '  function authorizeMember(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 minDeposit_\n', '  ) public view override {\n', '    require(users[userId_].deposit >= minDeposit_, "INSUFFICIENT_DEPOSIT");\n', '    require(users[userId_].pokerKey == pokerKey_, "INVALID_POKER_KEY");\n', '  }\n', '\n', '  function requireValidAdminKey(uint256 userId_, address adminKey_) external view override {\n', '    require(users[userId_].adminKey == adminKey_, "INVALID_AMIN_KEY");\n', '  }\n', '\n', '  function requireValidAdminOrPokerKey(uint256 userId_, address adminOrPokerKey_) external view override {\n', '    require(\n', '      users[userId_].adminKey == adminOrPokerKey_ || users[userId_].pokerKey == adminOrPokerKey_,\n', '      "INVALID_AMIN_OR_POKER_KEY"\n', '    );\n', '  }\n', '\n', '  function getLastDepositChange(uint256 userId_) external view override returns (uint256) {\n', '    return _lastDepositChange[userId_];\n', '  }\n', '}\n', '\n', '// File: contracts/PowerPokeStorageV1.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', 'contract PowerPokeStorageV1 {\n', '  struct Client {\n', '    bool active;\n', '    bool canSlash;\n', '    bool allowPokerWithdrawingRewards;\n', '    address owner;\n', '    uint256 credit;\n', '    uint256 minReportInterval;\n', '    uint256 maxReportInterval;\n', '    uint256 slasherHeartbeat;\n', '    uint256 gasPriceLimit;\n', '    uint256 defaultMinDeposit;\n', '    uint256 fixedCompensationCVP;\n', '    uint256 fixedCompensationETH;\n', '  }\n', '\n', '  struct BonusPlan {\n', '    bool active;\n', '    uint64 bonusNumerator;\n', '    uint64 bonusDenominator;\n', '    uint64 perGas;\n', '  }\n', '\n', '  IPowerOracle public oracle;\n', '\n', '  uint256 public totalCredits;\n', '\n', '  mapping(uint256 => uint256) public rewards;\n', '\n', '  mapping(uint256 => bool) public pokerKeyRewardWithdrawAllowance;\n', '\n', '  mapping(address => Client) public clients;\n', '\n', '  mapping(address => mapping(uint256 => BonusPlan)) public bonusPlans;\n', '}\n', '\n', '// File: contracts/PowerPoke.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract PowerPoke is IPowerPoke, PowerOwnable, Initializable, PowerPausable, ReentrancyGuard, PowerPokeStorageV1 {\n', '  using SafeMath for uint256;\n', '\n', '  event RewardUser(\n', '    address indexed client,\n', '    uint256 indexed userId,\n', '    uint256 indexed bonusPlan,\n', '    bool compensateInETH,\n', '    uint256 gasUsed,\n', '    uint256 gasPrice,\n', '    uint256 userDeposit,\n', '    uint256 ethPrice,\n', '    uint256 cvpPrice,\n', '    uint256 compensationEvaluationCVP,\n', '    uint256 bonusCVP,\n', '    uint256 earnedCVP,\n', '    uint256 earnedETH\n', '  );\n', '\n', '  event TransferClientOwnership(address indexed client, address indexed from, address indexed to);\n', '\n', '  event SetReportIntervals(address indexed client, uint256 minReportInterval, uint256 maxReportInterval);\n', '\n', '  event SetGasPriceLimit(address indexed client, uint256 gasPriceLimit);\n', '\n', '  event SetSlasherHeartbeat(address indexed client, uint256 slasherHeartbeat);\n', '\n', '  event SetBonusPlan(\n', '    address indexed client,\n', '    uint256 indexed planId,\n', '    bool indexed active,\n', '    uint64 bonusNominator,\n', '    uint64 bonsuDenominator,\n', '    uint128 perGas\n', '  );\n', '\n', '  event SetFixedCompensations(address indexed client, uint256 fixedCompensationETH, uint256 fixedCompensationCVP);\n', '\n', '  event SetDefaultMinDeposit(address indexed client, uint256 defaultMinDeposit);\n', '\n', '  event WithdrawRewards(uint256 indexed userId, address indexed to, uint256 amount);\n', '\n', '  event AddCredit(address indexed client, uint256 amount);\n', '\n', '  event WithdrawCredit(address indexed client, address indexed to, uint256 amount);\n', '\n', '  event SetOracle(address indexed oracle);\n', '\n', '  event AddClient(\n', '    address indexed client,\n', '    address indexed owner,\n', '    bool canSlash,\n', '    uint256 gasPriceLimit,\n', '    uint256 minReportInterval,\n', '    uint256 maxReportInterval,\n', '    uint256 slasherHeartbeat\n', '  );\n', '\n', '  event SetClientActiveFlag(address indexed client, bool indexed active);\n', '\n', '  event SetCanSlashFlag(address indexed client, bool indexed canSlash);\n', '\n', '  event SetPokerKeyRewardWithdrawAllowance(uint256 indexed userId, bool allow);\n', '\n', '  struct PokeRewardOptions {\n', '    address to;\n', '    bool compensateInETH;\n', '  }\n', '\n', '  struct RewardHelperStruct {\n', '    uint256 gasPrice;\n', '    uint256 ethPrice;\n', '    uint256 cvpPrice;\n', '    uint256 totalInCVP;\n', '    uint256 compensationCVP;\n', '    uint256 bonusCVP;\n', '    uint256 earnedCVP;\n', '    uint256 earnedETH;\n', '  }\n', '\n', '  address public immutable WETH_TOKEN;\n', '\n', '  IERC20 public immutable CVP_TOKEN;\n', '\n', '  IEACAggregatorProxy public immutable FAST_GAS_ORACLE;\n', '\n', '  PowerPokeStaking public immutable POWER_POKE_STAKING;\n', '\n', '  IUniswapV2Router02 public immutable UNISWAP_ROUTER;\n', '\n', '  modifier onlyClientOwner(address client_) {\n', '    require(clients[client_].owner == msg.sender, "ONLY_CLIENT_OWNER");\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '    address cvpToken_,\n', '    address wethToken_,\n', '    address fastGasOracle_,\n', '    address uniswapRouter_,\n', '    address powerPokeStaking_\n', '  ) public {\n', '    require(cvpToken_ != address(0), "CVP_ADDR_IS_0");\n', '    require(wethToken_ != address(0), "WETH_ADDR_IS_0");\n', '    require(fastGasOracle_ != address(0), "FAST_GAS_ORACLE_IS_0");\n', '    require(uniswapRouter_ != address(0), "UNISWAP_ROUTER_IS_0");\n', '    require(powerPokeStaking_ != address(0), "POWER_POKE_STAKING_ADDR_IS_0");\n', '\n', '    CVP_TOKEN = IERC20(cvpToken_);\n', '    WETH_TOKEN = wethToken_;\n', '    FAST_GAS_ORACLE = IEACAggregatorProxy(fastGasOracle_);\n', '    POWER_POKE_STAKING = PowerPokeStaking(powerPokeStaking_);\n', '    UNISWAP_ROUTER = IUniswapV2Router02(uniswapRouter_);\n', '  }\n', '\n', '  function initialize(address owner_, address oracle_) external initializer {\n', '    _transferOwnership(owner_);\n', '    oracle = IPowerOracle(oracle_);\n', '  }\n', '\n', "  /*** CLIENT'S CONTRACT INTERFACE ***/\n", '  function authorizeReporter(uint256 userId_, address pokerKey_) external view override {\n', '    POWER_POKE_STAKING.authorizeHDH(userId_, pokerKey_);\n', '  }\n', '\n', '  function authorizeNonReporter(uint256 userId_, address pokerKey_) external view override {\n', '    POWER_POKE_STAKING.authorizeNonHDH(userId_, pokerKey_, clients[msg.sender].defaultMinDeposit);\n', '  }\n', '\n', '  function authorizeNonReporterWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinDeposit_\n', '  ) external view override {\n', '    POWER_POKE_STAKING.authorizeNonHDH(userId_, pokerKey_, overrideMinDeposit_);\n', '  }\n', '\n', '  function authorizePoker(uint256 userId_, address pokerKey_) external view override {\n', '    POWER_POKE_STAKING.authorizeMember(userId_, pokerKey_, clients[msg.sender].defaultMinDeposit);\n', '  }\n', '\n', '  function authorizePokerWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinStake_\n', '  ) external view override {\n', '    POWER_POKE_STAKING.authorizeMember(userId_, pokerKey_, overrideMinStake_);\n', '  }\n', '\n', '  function slashReporter(uint256 slasherId_, uint256 times_) external override nonReentrant {\n', '    require(clients[msg.sender].active, "INVALID_CLIENT");\n', '    require(clients[msg.sender].canSlash, "CANT_SLASH");\n', '    if (times_ == 0) {\n', '      return;\n', '    }\n', '\n', '    POWER_POKE_STAKING.slashHDH(slasherId_, times_);\n', '  }\n', '\n', '  function reward(\n', '    uint256 userId_,\n', '    uint256 gasUsed_,\n', '    uint256 compensationPlan_,\n', '    bytes calldata pokeOptions_\n', '  ) external override nonReentrant whenNotPaused {\n', '    RewardHelperStruct memory helper;\n', '    require(clients[msg.sender].active, "INVALID_CLIENT");\n', '\n', '    PokeRewardOptions memory opts = abi.decode(pokeOptions_, (PokeRewardOptions));\n', '    if (opts.compensateInETH) {\n', '      gasUsed_ = gasUsed_.add(clients[msg.sender].fixedCompensationETH);\n', '    } else {\n', '      gasUsed_ = gasUsed_.add(clients[msg.sender].fixedCompensationCVP);\n', '    }\n', '\n', '    if (gasUsed_ == 0) {\n', '      return;\n', '    }\n', '\n', '    helper.ethPrice = oracle.getPriceByAsset(WETH_TOKEN);\n', '    helper.cvpPrice = oracle.getPriceByAsset(address(CVP_TOKEN));\n', '\n', '    helper.gasPrice = getGasPriceFor(msg.sender);\n', '    helper.compensationCVP = helper.gasPrice.mul(gasUsed_).mul(helper.ethPrice) / helper.cvpPrice;\n', '    uint256 userDeposit = POWER_POKE_STAKING.getDepositOf(userId_);\n', '\n', '    if (userDeposit != 0) {\n', '      helper.bonusCVP = getPokerBonus(msg.sender, compensationPlan_, gasUsed_, userDeposit);\n', '    }\n', '\n', '    helper.totalInCVP = helper.compensationCVP.add(helper.bonusCVP);\n', '    require(clients[msg.sender].credit >= helper.totalInCVP, "NOT_ENOUGH_CREDITS");\n', '    clients[msg.sender].credit = clients[msg.sender].credit.sub(helper.totalInCVP);\n', '\n', '    if (opts.compensateInETH) {\n', '      helper.earnedCVP = helper.bonusCVP;\n', '      rewards[userId_] = rewards[userId_].add(helper.bonusCVP);\n', '      helper.earnedETH = _payoutCompensationInETH(opts.to, helper.compensationCVP);\n', '    } else {\n', '      helper.earnedCVP = helper.compensationCVP.add(helper.bonusCVP);\n', '      rewards[userId_] = rewards[userId_].add(helper.earnedCVP);\n', '    }\n', '\n', '    emit RewardUser(\n', '      msg.sender,\n', '      userId_,\n', '      compensationPlan_,\n', '      opts.compensateInETH,\n', '      gasUsed_,\n', '      helper.gasPrice,\n', '      userDeposit,\n', '      helper.ethPrice,\n', '      helper.cvpPrice,\n', '      helper.compensationCVP,\n', '      helper.bonusCVP,\n', '      helper.earnedCVP,\n', '      helper.earnedETH\n', '    );\n', '  }\n', '\n', '  /*** CLIENT OWNER INTERFACE ***/\n', '  function transferClientOwnership(address client_, address to_) external override onlyClientOwner(client_) {\n', '    clients[client_].owner = to_;\n', '    emit TransferClientOwnership(client_, msg.sender, to_);\n', '  }\n', '\n', '  function addCredit(address client_, uint256 amount_) external override {\n', '    Client storage client = clients[client_];\n', '\n', '    require(client.active, "ONLY_ACTIVE_CLIENT");\n', '\n', '    CVP_TOKEN.transferFrom(msg.sender, address(this), amount_);\n', '    client.credit = client.credit.add(amount_);\n', '    totalCredits = totalCredits.add(amount_);\n', '\n', '    emit AddCredit(client_, amount_);\n', '  }\n', '\n', '  function withdrawCredit(\n', '    address client_,\n', '    address to_,\n', '    uint256 amount_\n', '  ) external override onlyClientOwner(client_) {\n', '    Client storage client = clients[client_];\n', '\n', '    client.credit = client.credit.sub(amount_);\n', '    totalCredits = totalCredits.sub(amount_);\n', '\n', '    CVP_TOKEN.transfer(to_, amount_);\n', '\n', '    emit WithdrawCredit(client_, to_, amount_);\n', '  }\n', '\n', '  function setReportIntervals(\n', '    address client_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external override onlyClientOwner(client_) {\n', '    require(maxReportInterval_ > minReportInterval_ && minReportInterval_ > 0, "INVALID_REPORT_INTERVALS");\n', '    clients[client_].minReportInterval = minReportInterval_;\n', '    clients[client_].maxReportInterval = maxReportInterval_;\n', '    emit SetReportIntervals(client_, minReportInterval_, maxReportInterval_);\n', '  }\n', '\n', '  function setSlasherHeartbeat(address client_, uint256 slasherHeartbeat_) external override onlyClientOwner(client_) {\n', '    clients[client_].slasherHeartbeat = slasherHeartbeat_;\n', '    emit SetSlasherHeartbeat(client_, slasherHeartbeat_);\n', '  }\n', '\n', '  function setGasPriceLimit(address client_, uint256 gasPriceLimit_) external override onlyClientOwner(client_) {\n', '    clients[client_].gasPriceLimit = gasPriceLimit_;\n', '    emit SetGasPriceLimit(client_, gasPriceLimit_);\n', '  }\n', '\n', '  function setFixedCompensations(\n', '    address client_,\n', '    uint256 eth_,\n', '    uint256 cvp_\n', '  ) external override onlyClientOwner(client_) {\n', '    clients[client_].fixedCompensationETH = eth_;\n', '    clients[client_].fixedCompensationCVP = cvp_;\n', '    emit SetFixedCompensations(client_, eth_, cvp_);\n', '  }\n', '\n', '  function setBonusPlan(\n', '    address client_,\n', '    uint256 planId_,\n', '    bool active_,\n', '    uint64 bonusNominator_,\n', '    uint64 bonusDenominator_,\n', '    uint64 perGas_\n', '  ) external override onlyClientOwner(client_) {\n', '    bonusPlans[client_][planId_] = BonusPlan(active_, bonusNominator_, bonusDenominator_, perGas_);\n', '    emit SetBonusPlan(client_, planId_, active_, bonusNominator_, bonusDenominator_, perGas_);\n', '  }\n', '\n', '  function setMinimalDeposit(address client_, uint256 defaultMinDeposit_) external override onlyClientOwner(client_) {\n', '    clients[client_].defaultMinDeposit = defaultMinDeposit_;\n', '    emit SetDefaultMinDeposit(client_, defaultMinDeposit_);\n', '  }\n', '\n', '  /*** POKER INTERFACE ***/\n', '  function withdrawRewards(uint256 userId_, address to_) external override {\n', '    if (pokerKeyRewardWithdrawAllowance[userId_] == true) {\n', '      POWER_POKE_STAKING.requireValidAdminOrPokerKey(userId_, msg.sender);\n', '    } else {\n', '      POWER_POKE_STAKING.requireValidAdminKey(userId_, msg.sender);\n', '    }\n', '    require(to_ != address(0), "0_ADDRESS");\n', '    uint256 rewardAmount = rewards[userId_];\n', '    require(rewardAmount > 0, "NOTHING_TO_WITHDRAW");\n', '    rewards[userId_] = 0;\n', '\n', '    CVP_TOKEN.transfer(to_, rewardAmount);\n', '\n', '    emit WithdrawRewards(userId_, to_, rewardAmount);\n', '  }\n', '\n', '  function setPokerKeyRewardWithdrawAllowance(uint256 userId_, bool allow_) external override {\n', '    POWER_POKE_STAKING.requireValidAdminKey(userId_, msg.sender);\n', '    pokerKeyRewardWithdrawAllowance[userId_] = allow_;\n', '    emit SetPokerKeyRewardWithdrawAllowance(userId_, allow_);\n', '  }\n', '\n', '  /*** OWNER INTERFACE ***/\n', '  function addClient(\n', '    address client_,\n', '    address owner_,\n', '    bool canSlash_,\n', '    uint256 gasPriceLimit_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external override onlyOwner {\n', '    require(maxReportInterval_ > minReportInterval_ && minReportInterval_ > 0, "INVALID_REPORT_INTERVALS");\n', '\n', '    Client storage c = clients[client_];\n', '    c.active = true;\n', '    c.canSlash = canSlash_;\n', '    c.owner = owner_;\n', '    c.gasPriceLimit = gasPriceLimit_;\n', '    c.minReportInterval = minReportInterval_;\n', '    c.maxReportInterval = maxReportInterval_;\n', '    c.slasherHeartbeat = uint256(-1);\n', '\n', '    emit AddClient(client_, owner_, canSlash_, gasPriceLimit_, minReportInterval_, maxReportInterval_, uint256(-1));\n', '  }\n', '\n', '  function setClientActiveFlag(address client_, bool active_) external override onlyOwner {\n', '    clients[client_].active = active_;\n', '    emit SetClientActiveFlag(client_, active_);\n', '  }\n', '\n', '  function setCanSlashFlag(address client_, bool canSlash) external override onlyOwner {\n', '    clients[client_].active = canSlash;\n', '    emit SetCanSlashFlag(client_, canSlash);\n', '  }\n', '\n', '  function setOracle(address oracle_) external override onlyOwner {\n', '    oracle = IPowerOracle(oracle_);\n', '    emit SetOracle(oracle_);\n', '  }\n', '\n', '  /**\n', '   * @notice The owner pauses reward-operation\n', '   */\n', '  function pause() external override onlyOwner {\n', '    _pause();\n', '  }\n', '\n', '  /**\n', '   * @notice The owner unpauses reward-operation\n', '   */\n', '  function unpause() external override onlyOwner {\n', '    _unpause();\n', '  }\n', '\n', '  /*** INTERNAL HELPERS ***/\n', '  function _payoutCompensationInETH(address _to, uint256 _cvpAmount) internal returns (uint256) {\n', '    CVP_TOKEN.approve(address(UNISWAP_ROUTER), _cvpAmount);\n', '\n', '    address[] memory path = new address[](2);\n', '    path[0] = address(CVP_TOKEN);\n', '    path[1] = address(WETH_TOKEN);\n', '\n', '    uint256[] memory amounts = UNISWAP_ROUTER.swapExactTokensForETH(_cvpAmount, uint256(0), path, _to, now.add(1800));\n', '    return amounts[1];\n', '  }\n', '\n', '  function _latestFastGas() internal view returns (uint256) {\n', '    return uint256(FAST_GAS_ORACLE.latestAnswer());\n', '  }\n', '\n', '  /*** GETTERS ***/\n', '  function creditOf(address client_) external view override returns (uint256) {\n', '    return clients[client_].credit;\n', '  }\n', '\n', '  function ownerOf(address client_) external view override returns (address) {\n', '    return clients[client_].owner;\n', '  }\n', '\n', '  function getMinMaxReportIntervals(address client_) external view override returns (uint256 min, uint256 max) {\n', '    return (clients[client_].minReportInterval, clients[client_].maxReportInterval);\n', '  }\n', '\n', '  function getSlasherHeartbeat(address client_) external view override returns (uint256) {\n', '    return clients[client_].slasherHeartbeat;\n', '  }\n', '\n', '  function getGasPriceLimit(address client_) external view override returns (uint256) {\n', '    return clients[client_].gasPriceLimit;\n', '  }\n', '\n', '  function getPokerBonus(\n', '    address client_,\n', '    uint256 bonusPlanId_,\n', '    uint256 gasUsed_,\n', '    uint256 userDeposit_\n', '  ) public view override returns (uint256) {\n', '    BonusPlan memory plan = bonusPlans[client_][bonusPlanId_];\n', '    require(plan.active, "INACTIVE_BONUS_PLAN");\n', '\n', '    // gasUsed_ * userDeposit_ * plan.bonusNumerator / bonusDenominator / plan.perGas\n', '    return gasUsed_.mul(userDeposit_).mul(plan.bonusNumerator) / plan.bonusDenominator / plan.perGas;\n', '  }\n', '\n', '  function getGasPriceFor(address client_) public view override returns (uint256) {\n', '    return Math.min(tx.gasprice, Math.min(_latestFastGas(), clients[client_].gasPriceLimit));\n', '  }\n', '}']