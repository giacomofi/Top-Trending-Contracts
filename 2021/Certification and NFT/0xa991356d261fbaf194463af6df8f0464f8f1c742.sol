['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-20\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-05\n', '*/\n', '\n', '/*\n', "    .'''''''''''..     ..''''''''''''''''..       ..'''''''''''''''..\n", "    .;;;;;;;;;;;'.   .';;;;;;;;;;;;;;;;;;,.     .,;;;;;;;;;;;;;;;;;,.\n", '    .;;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;,.    .,;;;;;;;;;;;;;;;;;;,.\n', '    .;;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.   .;;;;;;;;;;;;;;;;;;;;,.\n', "    ';;;;;;;;'.  .';;;;;;;;;;;;;;;;;;;;;;,. .';;;;;;;;;;;;;;;;;;;;;,.\n", "    ';;;;;,..   .';;;;;;;;;;;;;;;;;;;;;;;,..';;;;;;;;;;;;;;;;;;;;;;,.\n", "    ......     .';;;;;;;;;;;;;,'''''''''''.,;;;;;;;;;;;;;,'''''''''..\n", '              .,;;;;;;;;;;;;;.           .,;;;;;;;;;;;;;.\n', '             .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.\n', '            .,;;;;;;;;;;;;,.           .,;;;;;;;;;;;;,.\n', '           .,;;;;;;;;;;;;,.           .;;;;;;;;;;;;;,.     .....\n', "          .;;;;;;;;;;;;;'.         ..';;;;;;;;;;;;;'.    .',;;;;,'.\n", "        .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.   .';;;;;;;;;;.\n", "       .';;;;;;;;;;;;;'.         .';;;;;;;;;;;;;;'.    .;;;;;;;;;;;,.\n", "      .,;;;;;;;;;;;;;'...........,;;;;;;;;;;;;;;.      .;;;;;;;;;;;,.\n", '     .,;;;;;;;;;;;;,..,;;;;;;;;;;;;;;;;;;;;;;;,.       ..;;;;;;;;;,.\n', "    .,;;;;;;;;;;;;,. .,;;;;;;;;;;;;;;;;;;;;;;,.          .',;;;,,..\n", '   .,;;;;;;;;;;;;,.  .,;;;;;;;;;;;;;;;;;;;;;,.              ....\n', "    ..',;;;;;;;;,.   .,;;;;;;;;;;;;;;;;;;;;,.\n", "       ..',;;;;'.    .,;;;;;;;;;;;;;;;;;;;'.\n", "          ...'..     .';;;;;;;;;;;;;;,,,'.\n", '                       ...............\n', '*/\n', '\n', '// https://github.com/trusttoken/smart-contracts\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '/**\n', ' * @title Initializable\n', ' *\n', ' * @dev Helper contract to support initializer functions. To use it, replace\n', ' * the constructor with a function that has the `initializer` modifier.\n', ' * WARNING: Unlike constructors, initializer functions must be manually\n', ' * invoked. This applies both to deploying an Initializable contract, as well\n', ' * as extending an Initializable contract via inheritance.\n', ' * WARNING: When used with inheritance, manual care must be taken to not invoke\n', ' * a parent initializer twice, or ensure that all initializers are idempotent,\n', ' * because this is not dealt with automatically as with constructors.\n', ' */\n', 'contract Initializable {\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private initializing;\n', '\n', '    /**\n', '     * @dev Modifier to use in the initializer function of a contract.\n', '     */\n', '    modifier initializer() {\n', '        require(initializing || isConstructor() || !initialized, "Contract instance has already been initialized");\n', '\n', '        bool isTopLevelCall = !initializing;\n', '        if (isTopLevelCall) {\n', '            initializing = true;\n', '            initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            initializing = false;\n', '        }\n', '    }\n', '\n', '    /// @dev Returns true if and only if the function is running in the constructor\n', '    function isConstructor() private view returns (bool) {\n', '        // extcodesize checks the size of the code stored in an address, and\n', '        // address returns the current address. Since the code is still not\n', '        // deployed when running a constructor, any checks on its code size will\n', '        // yield zero, making it an effective way to detect if a contract is\n', '        // under construction or not.\n', '        address self = address(this);\n', '        uint256 cs;\n', '        assembly {\n', '            cs := extcodesize(self)\n', '        }\n', '        return cs == 0;\n', '    }\n', '\n', '    /**\n', '     * @dev Return true if and only if the contract has been initialized\n', '     * @return whether the contract has been initialized\n', '     */\n', '    function isInitialized() public view returns (bool) {\n', '        return initialized;\n', '    }\n', '\n', '    // Reserved storage space to allow for layout changes in the future.\n', '    uint256[50] private ______gap;\n', '}\n', '\n', '/**\n', ' * @title UpgradeableClaimable\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. Since\n', ' * this contract combines Claimable and UpgradableOwnable contracts, ownership\n', ' * can be later change via 2 step method {transferOwnership} and {claimOwnership}\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'contract UpgradeableClaimable is Initializable, Context {\n', '    address private _owner;\n', '    address private _pendingOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting a custom initial owner of choice.\n', '     * @param __owner Initial owner of contract to be set.\n', '     */\n', '    function initialize(address __owner) internal initializer {\n', '        _owner = __owner;\n', '        emit OwnershipTransferred(address(0), __owner);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the pending owner.\n', '     */\n', '    function pendingOwner() public view returns (address) {\n', '        return _pendingOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Modifier throws if called by any account other than the pendingOwner.\n', '     */\n', '    modifier onlyPendingOwner() {\n', '        require(msg.sender == _pendingOwner, "Ownable: caller is not the pending owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to set the pendingOwner address.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _pendingOwner = newOwner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the pendingOwner address to finalize the transfer.\n', '     */\n', '    function claimOwnership() public onlyPendingOwner {\n', '        emit OwnershipTransferred(_owner, _pendingOwner);\n', '        _owner = _pendingOwner;\n', '        _pendingOwner = address(0);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title ImplementationReference\n', ' * @dev This contract is made to serve a simple purpose only.\n', ' * To hold the address of the implementation contract to be used by proxy.\n', ' * The implementation address, is changeable anytime by the owner of this contract.\n', ' */\n', 'contract ImplementationReference is UpgradeableClaimable {\n', '    address public implementation;\n', '\n', '    /**\n', '     * @dev Event to show that implementation address has been changed\n', '     * @param newImplementation New address of the implementation\n', '     */\n', '    event ImplementationChanged(address newImplementation);\n', '\n', '    /**\n', '     * @dev Set initial ownership and implementation address\n', '     * @param _implementation Initial address of the implementation\n', '     */\n', '    constructor(address _implementation) public {\n', '        UpgradeableClaimable.initialize(msg.sender);\n', '        implementation = _implementation;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to change the implementation address, which can be called only by the owner\n', '     * @param newImplementation New address of the implementation\n', '     */\n', '    function setImplementation(address newImplementation) external onlyOwner {\n', '        implementation = newImplementation;\n', '        emit ImplementationChanged(newImplementation);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title OwnedProxyWithReference\n', ' * @dev This contract combines an upgradeability proxy with basic authorization control functionalities\n', ' * Its structure makes it easy for a group of contracts alike, to share an implementation and to change it easily for all of them at once\n', ' */\n', 'contract OwnedProxyWithReference {\n', '    /**\n', '     * @dev Event to show ownership has been transferred\n', '     * @param previousOwner representing the address of the previous owner\n', '     * @param newOwner representing the address of the new owner\n', '     */\n', '    event ProxyOwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Event to show ownership transfer is pending\n', '     * @param currentOwner representing the address of the current owner\n', '     * @param pendingOwner representing the address of the pending owner\n', '     */\n', '    event NewPendingOwner(address currentOwner, address pendingOwner);\n', '\n', '    /**\n', '     * @dev Event to show implementation reference has been changed\n', '     * @param implementationReference address of the new implementation reference contract\n', '     */\n', '    event ImplementationReferenceChanged(address implementationReference);\n', '\n', '    // Storage position of the owner and pendingOwner and implementationReference of the contract\n', '    // This is made to ensure, that memory spaces do not interfere with each other\n', '    bytes32 private constant proxyOwnerPosition = 0x6279e8199720cf3557ecd8b58d667c8edc486bd1cf3ad59ea9ebdfcae0d0dfac; //keccak256("trueUSD.proxy.owner");\n', '    bytes32 private constant pendingProxyOwnerPosition = 0x8ddbac328deee8d986ec3a7b933a196f96986cb4ee030d86cc56431c728b83f4; //keccak256("trueUSD.pending.proxy.owner");\n', '    bytes32 private constant implementationReferencePosition = keccak256("trueFiPool.implementation.reference"); //keccak256("trueFiPool.implementation.reference");\n', '\n', '    /**\n', '     * @dev the constructor sets the original owner of the contract to the sender account.\n', '     * @param _owner Initial owner of the proxy\n', '     * @param _implementationReference initial ImplementationReference address\n', '     */\n', '    constructor(address _owner, address _implementationReference) public {\n', '        _setUpgradeabilityOwner(_owner);\n', '        _changeImplementationReference(_implementationReference);\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyProxyOwner() {\n', '        require(msg.sender == proxyOwner(), "only Proxy Owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the pending owner.\n', '     */\n', '    modifier onlyPendingProxyOwner() {\n', '        require(msg.sender == pendingProxyOwner(), "only pending Proxy Owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Tells the address of the owner\n', '     * @return owner the address of the owner\n', '     */\n', '    function proxyOwner() public view returns (address owner) {\n', '        bytes32 position = proxyOwnerPosition;\n', '        assembly {\n', '            owner := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Tells the address of the owner\n', '     * @return pendingOwner the address of the pending owner\n', '     */\n', '    function pendingProxyOwner() public view returns (address pendingOwner) {\n', '        bytes32 position = pendingProxyOwnerPosition;\n', '        assembly {\n', '            pendingOwner := sload(position)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the owner\n', '     * @param newProxyOwner New owner to be set\n', '     */\n', '    function _setUpgradeabilityOwner(address newProxyOwner) internal {\n', '        bytes32 position = proxyOwnerPosition;\n', '        assembly {\n', '            sstore(position, newProxyOwner)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the address of the owner\n', '     * @param newPendingProxyOwner New pending owner address\n', '     */\n', '    function _setPendingUpgradeabilityOwner(address newPendingProxyOwner) internal {\n', '        bytes32 position = pendingProxyOwnerPosition;\n', '        assembly {\n', '            sstore(position, newPendingProxyOwner)\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', "     * changes the pending owner to newOwner. But doesn't actually transfer\n", '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferProxyOwnership(address newOwner) external onlyProxyOwner {\n', '        require(newOwner != address(0));\n', '        _setPendingUpgradeabilityOwner(newOwner);\n', '        emit NewPendingOwner(proxyOwner(), newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the pendingOwner to claim ownership of the proxy\n', '     */\n', '    function claimProxyOwnership() external onlyPendingProxyOwner {\n', '        emit ProxyOwnershipTransferred(proxyOwner(), pendingProxyOwner());\n', '        _setUpgradeabilityOwner(pendingProxyOwner());\n', '        _setPendingUpgradeabilityOwner(address(0));\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the proxy owner to change the contract holding address of implementation.\n', '     * @param _implementationReference representing the address contract, which holds implementation.\n', '     */\n', '    function changeImplementationReference(address _implementationReference) public virtual onlyProxyOwner {\n', '        _changeImplementationReference(_implementationReference);\n', '    }\n', '\n', '    /**\n', '     * @dev Get the address of current implementation.\n', '     * @return Returns address of implementation contract\n', '     */\n', '    function implementation() public view returns (address) {\n', '        bytes32 position = implementationReferencePosition;\n', '        address implementationReference;\n', '        assembly {\n', '            implementationReference := sload(position)\n', '        }\n', '        return ImplementationReference(implementationReference).implementation();\n', '    }\n', '\n', '    /**\n', '     * @dev Fallback functions allowing to perform a delegatecall to the given implementation.\n', '     * This function will return whatever the implementation call returns\n', '     */\n', '    fallback() external payable {\n', '        proxyCall();\n', '    }\n', '\n', '    /**\n', '     * @dev This fallback function gets called only when this contract is called without any calldata e.g. send(), transfer()\n', '     * This would also trigger receive() function on called implementation\n', '     */\n', '    receive() external payable {\n', '        proxyCall();\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a low level call, to the contract holding all the logic, changing state on this contract at the same time\n', '     */\n', '    function proxyCall() internal {\n', '        address impl = implementation();\n', '\n', '        assembly {\n', '            let ptr := mload(0x40)\n', '            calldatacopy(ptr, 0, calldatasize())\n', '            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\n', '            returndatacopy(ptr, 0, returndatasize())\n', '\n', '            switch result\n', '                case 0 {\n', '                    revert(ptr, returndatasize())\n', '                }\n', '                default {\n', '                    return(ptr, returndatasize())\n', '                }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Function to internally change the contract holding address of implementation.\n', '     * @param _implementationReference representing the address contract, which holds implementation.\n', '     */\n', '    function _changeImplementationReference(address _implementationReference) internal virtual {\n', '        bytes32 position = implementationReferencePosition;\n', '        assembly {\n', '            sstore(position, _implementationReference)\n', '        }\n', '\n', '        emit ImplementationReferenceChanged(address(_implementationReference));\n', '    }\n', '}']