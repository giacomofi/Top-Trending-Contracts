['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-12\n', '*/\n', '\n', '// SPDX-License-Identifier: This smart contract is guarded by an angry ghost\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', 'contract POWNFTv3{\n', '\n', '    //v2 Variables\n', '    uint public UNMIGRATED = 0;\n', '    uint public V2_TOTAL = 0;\n', '    bytes32 public PREV_CHAIN_LAST_HASH;\n', '    POWNFTv2 CONTRACT_V2;\n', '\n', '    constructor(address contract_v2){\n', '        supportedInterfaces[0x80ac58cd] = true; //ERC721\n', '        supportedInterfaces[0x5b5e139f] = true; //ERC721Metadata\n', '        supportedInterfaces[0x780e9d63] = true; //ERC721Enumerable\n', '        supportedInterfaces[0x01ffc9a7] = true; //ERC165\n', '\n', '        CONTRACT_V2 = POWNFTv2(contract_v2);\n', '        V2_TOTAL =\n', '        UNMIGRATED = CONTRACT_V2.totalSupply();\n', '        PREV_CHAIN_LAST_HASH = CONTRACT_V2.hashOf(UNMIGRATED);\n', '\n', '    }\n', '\n', '\n', '    //////===721 Standard\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    //////===721 Implementation\n', '    mapping(address => uint256) internal BALANCES;\n', '    mapping (uint256 => address) internal ALLOWANCE;\n', '    mapping (address => mapping (address => bool)) internal AUTHORISED;\n', '\n', '    bytes32[] TOKENS;  //Array of all tokens [hash,hash,...]\n', '    mapping(uint256 => address) OWNERS;  //Mapping of owners\n', '\n', '\n', '    //    METADATA VARS\n', '    string private __name = "POW NFT";\n', '    string private __symbol = "POW";\n', '    bytes private __uriBase = bytes("https://www.pownftmetadata.com/t/");\n', '\n', '\n', '    //    ENUMERABLE VARS\n', '    mapping(address => uint[]) internal OWNER_INDEX_TO_ID;\n', '    mapping(uint => uint) internal OWNER_ID_TO_INDEX;\n', '    mapping(uint => uint) internal ID_TO_INDEX;\n', '    mapping(uint => uint) internal INDEX_TO_ID;\n', '\n', '\n', '    //ETH VAR\n', '    mapping(uint256 => uint256) WITHDRAWALS;\n', '\n', '\n', '    //      MINING VARS\n', '    uint BASE_COST = 0.000045 ether;\n', '    uint BASE_DIFFICULTY = uint(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)/uint(300);\n', '    uint DIFFICULTY_RAMP = 3;\n', '\n', '\n', '    event Migrate(uint indexed _tokenId);\n', '\n', '    //      MINING EVENTS\n', '    event Mined(uint indexed _tokenId, bytes32 hash);\n', '    event Withdraw(uint indexed _tokenId, uint value);\n', '\n', '    //      MINING FUNCTIONS\n', '    function generationOf(uint _tokenId) private pure returns(uint generation){\n', '        for(generation = 0; _tokenId > 0; generation++){\n', '            _tokenId /= 2;\n', '        }\n', '        return generation - 1;\n', '    }\n', '    function hashOf(uint _tokenId) public view returns(bytes32){\n', '        require(isValidToken(_tokenId),"invalid");\n', '        return TOKENS[ID_TO_INDEX[_tokenId]];\n', '    }\n', '\n', '\n', '    function migrate(uint _tokenId,uint _withdrawEthUntil) public {\n', '            _migrate(_tokenId);\n', '            if(_withdrawEthUntil > 0){\n', '                withdraw(_tokenId, _withdrawEthUntil);\n', '            }\n', '    }\n', '    function _migrate(uint _tokenId) internal {\n', '        //require not migrated\n', "        require(!isValidToken(_tokenId),'is_migrated');\n", '\n', '        //Require before snapshot\n', "        require(_tokenId <= V2_TOTAL,'forgery');\n", '\n', '        //require owner on original contract\n', "        require(CONTRACT_V2.ownerOf(_tokenId) == msg.sender,'owner');\n", '        //mint the token with hash from prev contract\n', '        UNMIGRATED--;\n', '        mint(_tokenId,\n', '            CONTRACT_V2.hashOf(_tokenId)\n', '        );\n', '        emit Migrate(_tokenId);\n', '    }\n', '    function migrateMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public {\n', '        for(uint i = 0; i < _tokenIds.length; i++){\n', '            _migrate(_tokenIds[i]);\n', '        }\n', '        withdrawMultiple(_tokenIds,_withdrawUntil);\n', '    }\n', '\n', '\n', '\n', '    function withdraw(uint _tokenId, uint _withdrawUntil) public {\n', '        payable(msg.sender).transfer(\n', '            _withdraw(_tokenId, _withdrawUntil)\n', '        );\n', '    }\n', '    function _withdraw(uint _tokenId, uint _withdrawUntil) internal returns(uint){\n', "        require(isValidToken(_withdrawUntil),'withdrawUntil_exist');\n", '\n', '        require(ownerOf(_tokenId) == msg.sender,"owner");\n', "        require(_withdrawUntil > WITHDRAWALS[_tokenId],'withdrawn');\n", '\n', '        uint generation = generationOf(_tokenId);\n', '        uint firstPayable = 2**(generation+1);\n', '\n', '        uint withdrawFrom = WITHDRAWALS[_tokenId];\n', '        if(withdrawFrom < _tokenId){\n', '            withdrawFrom = _tokenId;\n', '\n', '            //withdraw from if _tokenId < number brought over\n', '            if(withdrawFrom < V2_TOTAL){\n', '                withdrawFrom = V2_TOTAL;\n', '            }\n', '            if(withdrawFrom < firstPayable){\n', '                withdrawFrom = firstPayable - 1;\n', '            }\n', '        }\n', '\n', "        require(_withdrawUntil > withdrawFrom,'underflow');\n", '\n', '        uint payout = BASE_COST * (_withdrawUntil - withdrawFrom);\n', '\n', '        WITHDRAWALS[_tokenId] = _withdrawUntil;\n', '\n', '        emit Withdraw(_tokenId,payout);\n', '\n', '        return payout;\n', '    }\n', '\n', '    function withdrawMultiple(uint[] calldata _tokenIds, uint[] calldata _withdrawUntil) public{\n', '        uint payout = 0;\n', '        for(uint i = 0; i < _tokenIds.length; i++){\n', '            if(_withdrawUntil[i] > 0){\n', '                payout += _withdraw(_tokenIds[i],_withdrawUntil[i]);\n', '            }\n', '        }\n', '        payable(msg.sender).transfer(payout);\n', '    }\n', '\n', '    function mine(uint nonce) external payable{\n', '        uint tokenId = UNMIGRATED + TOKENS.length + 1;\n', '        uint generation = generationOf(tokenId);\n', '\n', '        uint difficulty = BASE_DIFFICULTY / (DIFFICULTY_RAMP**generation);\n', '        if(generation > 13){ //Token 16384\n', '            difficulty /= (tokenId - 2**14 + 1);\n', '        }\n', '\n', '        uint cost = (2**generation - 1)* BASE_COST;\n', '\n', '\n', '        bytes32 hash;\n', '        if(V2_TOTAL - UNMIGRATED != TOKENS.length){\n', '            hash = keccak256(abi.encodePacked(\n', '                    msg.sender,\n', '                    TOKENS[ID_TO_INDEX[tokenId-1]],\n', '                    nonce\n', '                ));\n', '        }else{\n', '//            First mine on new contract\n', '            hash = keccak256(abi.encodePacked(\n', '                        msg.sender,\n', '                        PREV_CHAIN_LAST_HASH,\n', '                    nonce\n', '                ));\n', '        }\n', '\n', '\n', '        require(uint(hash) < difficulty,"difficulty");\n', '        require(msg.value ==cost,"cost");\n', '\n', '        hash = keccak256(abi.encodePacked(hash,block.timestamp));\n', '\n', '        mint(tokenId, hash);\n', '\n', '        emit Mined(tokenId,hash);\n', '    }\n', '\n', '    function mint(uint tokenId, bytes32 hash) private{\n', '        OWNERS[tokenId] = msg.sender;\n', '        BALANCES[msg.sender]++;\n', '        OWNER_ID_TO_INDEX[tokenId] = OWNER_INDEX_TO_ID[msg.sender].length;\n', '        OWNER_INDEX_TO_ID[msg.sender].push(tokenId);\n', '\n', '        ID_TO_INDEX[tokenId] = TOKENS.length;\n', '        INDEX_TO_ID[TOKENS.length] = tokenId;\n', '        TOKENS.push(hash);\n', '\n', '        emit Transfer(address(0),msg.sender,tokenId);\n', '    }\n', '\n', '\n', '    function isValidToken(uint256 _tokenId) internal view returns(bool){\n', '        return OWNERS[_tokenId] != address(0);\n', '    }\n', '\n', '    function balanceOf(address _owner) external view returns (uint256){\n', '        return BALANCES[_owner];\n', '    }\n', '\n', '    function ownerOf(uint256 _tokenId) public view returns(address){\n', '        require(isValidToken(_tokenId),"invalid");\n', '        return OWNERS[_tokenId];\n', '    }\n', '\n', '\n', '    function approve(address _approved, uint256 _tokenId)  external{\n', '        address owner = ownerOf(_tokenId);\n', '        require( owner == msg.sender                    //Require Sender Owns Token\n', '            || AUTHORISED[owner][msg.sender]                //  or is approved for all.\n', '        ,"permission");\n', '        emit Approval(owner, _approved, _tokenId);\n', '        ALLOWANCE[_tokenId] = _approved;\n', '    }\n', '\n', '    function getApproved(uint256 _tokenId) external view returns (address) {\n', '        require(isValidToken(_tokenId),"invalid");\n', '        return ALLOWANCE[_tokenId];\n', '    }\n', '\n', '    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n', '        return AUTHORISED[_owner][_operator];\n', '    }\n', '\n', '\n', '    function setApprovalForAll(address _operator, bool _approved) external {\n', '        emit ApprovalForAll(msg.sender,_operator, _approved);\n', '        AUTHORISED[msg.sender][_operator] = _approved;\n', '    }\n', '\n', '\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) public {\n', '\n', '        //Check Transferable\n', '        //There is a token validity check in ownerOf\n', '        address owner = ownerOf(_tokenId);\n', '\n', '        require ( owner == msg.sender             //Require sender owns token\n', '        //Doing the two below manually instead of referring to the external methods saves gas\n', '        || ALLOWANCE[_tokenId] == msg.sender      //or is approved for this token\n', '            || AUTHORISED[owner][msg.sender]          //or is approved for all\n', '        ,"permission");\n', '        require(owner == _from,"owner");\n', '        require(_to != address(0),"zero");\n', '\n', '        emit Transfer(_from, _to, _tokenId);\n', '\n', '\n', '        OWNERS[_tokenId] =_to;\n', '\n', '        BALANCES[_from]--;\n', '        BALANCES[_to]++;\n', '\n', '        //Reset approved if there is one\n', '        if(ALLOWANCE[_tokenId] != address(0)){\n', '            delete ALLOWANCE[_tokenId];\n', '        }\n', '\n', '        //Enumerable Additions\n', '        uint oldIndex = OWNER_ID_TO_INDEX[_tokenId];\n', "        //If the token isn't the last one in the owner's index\n", '        if(oldIndex != OWNER_INDEX_TO_ID[_from].length - 1){\n', '            //Move the old one in the index list\n', '            OWNER_INDEX_TO_ID[_from][oldIndex] = OWNER_INDEX_TO_ID[_from][OWNER_INDEX_TO_ID[_from].length - 1];\n', "            //Update the token's reference to its place in the index list\n", '            OWNER_ID_TO_INDEX[OWNER_INDEX_TO_ID[_from][oldIndex]] = oldIndex;\n', '        }\n', '        OWNER_INDEX_TO_ID[_from].pop();\n', '\n', '        OWNER_ID_TO_INDEX[_tokenId] = OWNER_INDEX_TO_ID[_to].length;\n', '        OWNER_INDEX_TO_ID[_to].push(_tokenId);\n', '\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) public {\n', '        transferFrom(_from, _to, _tokenId);\n', '\n', '        //Get size of "_to" address, if 0 it\'s a wallet\n', '        uint32 size;\n', '        assembly {\n', '            size := extcodesize(_to)\n', '        }\n', '        if(size > 0){\n', '            ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\n', '            require(receiver.onERC721Received(msg.sender,_from,_tokenId,data) == bytes4(keccak256("onERC721Received(address,address,uint256,bytes)")),"receiver");\n', '        }\n', '\n', '    }\n', '\n', '    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\n', '        safeTransferFrom(_from,_to,_tokenId,"");\n', '    }\n', '\n', '\n', '    // METADATA FUNCTIONS\n', '    function tokenURI(uint256 _tokenId) public view returns (string memory){\n', '        //Note: changed visibility to public\n', "        require(isValidToken(_tokenId),'tokenId');\n", '\n', '        uint _i = _tokenId;\n', '        uint j = _i;\n', '        uint len;\n', '        while (j != 0) {\n', '            len++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(len);\n', '        uint k = len;\n', '        while (_i != 0) {\n', '            k = k-1;\n', '            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n', '            bytes1 b1 = bytes1(temp);\n', '            bstr[k] = b1;\n', '            _i /= 10;\n', '        }\n', '\n', '\n', '        return string(abi.encodePacked(__uriBase,bstr));\n', '\n', '    }\n', '\n', '\n', '\n', '    function name() external view returns (string memory _name){\n', '        return __name;\n', '    }\n', '\n', '    function symbol() external view returns (string memory _symbol){\n', '        return __symbol;\n', '    }\n', '\n', '\n', '    // ENUMERABLE FUNCTIONS\n', '    function totalSupply() external view returns (uint256){\n', '        return TOKENS.length;\n', '    }\n', '\n', '    function tokenByIndex(uint256 _index) external view returns(uint256){\n', '        require(_index < TOKENS.length,"index");\n', '        return INDEX_TO_ID[_index];\n', '    }\n', '\n', '    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256){\n', '        require(_index < BALANCES[_owner],"index");\n', '        return OWNER_INDEX_TO_ID[_owner][_index];\n', '    }\n', '\n', '    // End 721 Implementation\n', '\n', '    ///////===165 Implementation\n', '    mapping (bytes4 => bool) internal supportedInterfaces;\n', '    function supportsInterface(bytes4 interfaceID) external view returns (bool){\n', '        return supportedInterfaces[interfaceID];\n', '    }\n', '    ///==End 165\n', '}\n', '\n', '\n', '\n', '\n', 'interface ERC721TokenReceiver {\n', '    //note: the national treasure is buried under parliament house\n', '    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n', '}\n', '\n', '\n', 'interface POWNFTv2 {\n', '    function hashOf(uint _tokenId) external view returns(bytes32);\n', '    function ownerOf(uint256 _tokenId) external view returns(address);\n', '    function totalSupply() external view returns (uint256);\n', '    //NWH YDY DDUG SEGEN DIN\n', '}']