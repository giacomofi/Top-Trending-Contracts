['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-21\n', '*/\n', '\n', '// SPDX-License-Identifier: AGPL-3.0-or-later\n', 'pragma solidity 0.7.5;\n', '\n', 'interface IOwnable {\n', '\n', '    function owner() external view returns (address);\n', '\n', '    function renounceOwnership() external;\n', '  \n', '    function transferOwnership( address newOwner_ ) external;\n', '}\n', '\n', 'contract Ownable is IOwnable {\n', '    \n', '    address internal _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    constructor () {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred( address(0), _owner );\n', '    }\n', '\n', '    function owner() public view override returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require( _owner == msg.sender, "Ownable: caller is not the owner" );\n', '        _;\n', '    }\n', '\n', '    function renounceOwnership() public virtual override onlyOwner() {\n', '        emit OwnershipTransferred( _owner, address(0) );\n', '        _owner = address(0);\n', '    }\n', '\n', '    function transferOwnership( address newOwner_ ) public virtual override onlyOwner() {\n', '        require( newOwner_ != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred( _owner, newOwner_ );\n', '        _owner = newOwner_;\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '\n', '    function sqrrt(uint256 a) internal pure returns (uint c) {\n', '        if (a > 3) {\n', '            c = a;\n', '            uint b = add( div( a, 2), 1 );\n', '            while (b < c) {\n', '                c = b;\n', '                b = div( add( div( a, b ), b), 2 );\n', '            }\n', '        } else if (a != 0) {\n', '            c = 1;\n', '        }\n', '    }\n', '\n', '    function percentageAmount( uint256 total_, uint8 percentage_ ) internal pure returns ( uint256 percentAmount_ ) {\n', '        return div( mul( total_, percentage_ ), 1000 );\n', '    }\n', '\n', '    function substractPercentage( uint256 total_, uint8 percentageToSub_ ) internal pure returns ( uint256 result_ ) {\n', '        return sub( total_, div( mul( total_, percentageToSub_ ), 1000 ) );\n', '    }\n', '\n', '    function percentageOfTotal( uint256 part_, uint256 total_ ) internal pure returns ( uint256 percent_ ) {\n', '        return div( mul(part_, 100) , total_ );\n', '    }\n', '\n', '    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // (a + b) / 2 can overflow, so we distribute\n', '        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n', '    }\n', '\n', '    function quadraticPricing( uint256 payment_, uint256 multiplier_ ) internal pure returns (uint256) {\n', '        return sqrrt( mul( multiplier_, payment_ ) );\n', '    }\n', '\n', '  function bondingCurve( uint256 supply_, uint256 multiplier_ ) internal pure returns (uint256) {\n', '      return mul( multiplier_, supply_ );\n', '  }\n', '}\n', '\n', 'library Address {\n', '\n', '    function isContract(address account) internal view returns (bool) {\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return _functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            if (returndata.length > 0) {\n', '\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '\n', '    function addressToString(address _address) internal pure returns(string memory) {\n', '        bytes32 _bytes = bytes32(uint256(_address));\n', '        bytes memory HEX = "0123456789abcdef";\n', '        bytes memory _addr = new bytes(42);\n', '\n', "        _addr[0] = '0';\n", "        _addr[1] = 'x';\n", '\n', '        for(uint256 i = 0; i < 20; i++) {\n', '            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\n', '            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\n', '        }\n', '\n', '        return string(_addr);\n', '\n', '    }\n', '}\n', '\n', 'interface IERC20 {\n', '    function decimals() external view returns (uint8);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'abstract contract ERC20 is IERC20 {\n', '\n', '    using SafeMath for uint256;\n', '\n', '    // TODO comment actual hash value.\n', '    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( "ERC20Token" );\n', '    \n', '    mapping (address => uint256) internal _balances;\n', '\n', '    mapping (address => mapping (address => uint256)) internal _allowances;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    string internal _name;\n', '    \n', '    string internal _symbol;\n', '    \n', '    uint8 internal _decimals;\n', '\n', '    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\n', '        _name = name_;\n', '        _symbol = symbol_;\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    function symbol() public view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    function decimals() public view override returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    function totalSupply() public view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function balanceOf(address account) public view virtual override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '\n', '    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(msg.sender, recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, "ERC20: transfer amount exceeds allowance"));\n', '        return true;\n', '    }\n', '\n', '    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n', '        return true;\n', '    }\n', '\n', '    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n', '        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));\n', '        return true;\n', '    }\n', '\n', '    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '\n', '        _beforeTokenTransfer(sender, recipient, amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");\n', '        _balances[recipient] = _balances[recipient].add(amount);\n', '        emit Transfer(sender, recipient, amount);\n', '    }\n', '\n', '    function _mint(address account_, uint256 ammount_) internal virtual {\n', '        require(account_ != address(0), "ERC20: mint to the zero address");\n', '        _beforeTokenTransfer(address( this ), account_, ammount_);\n', '        _totalSupply = _totalSupply.add(ammount_);\n', '        _balances[account_] = _balances[account_].add(ammount_);\n', '        emit Transfer(address( this ), account_, ammount_);\n', '    }\n', '\n', '    function _burn(address account, uint256 amount) internal virtual {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        emit Transfer(account, address(0), amount);\n', '    }\n', '\n', '    function _approve(address owner, address spender, uint256 amount) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '  function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\n', '}\n', '\n', 'interface IERC2612Permit {\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function nonces(address owner) external view returns (uint256);\n', '}\n', '\n', 'library Counters {\n', '    using SafeMath for uint256;\n', '\n', '    struct Counter {\n', '\n', '        uint256 _value; // default: 0\n', '    }\n', '\n', '    function current(Counter storage counter) internal view returns (uint256) {\n', '        return counter._value;\n', '    }\n', '\n', '    function increment(Counter storage counter) internal {\n', '        counter._value += 1;\n', '    }\n', '\n', '    function decrement(Counter storage counter) internal {\n', '        counter._value = counter._value.sub(1);\n', '    }\n', '}\n', '\n', 'abstract contract ERC20Permit is ERC20, IERC2612Permit {\n', '    using Counters for Counters.Counter;\n', '\n', '    mapping(address => Counters.Counter) private _nonces;\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '\n', '    constructor() {\n', '        uint256 chainID;\n', '        assembly {\n', '            chainID := chainid()\n', '        }\n', '\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', '                keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),\n', '                keccak256(bytes(name())),\n', '                keccak256(bytes("1")), // Version\n', '                chainID,\n', '                address(this)\n', '            )\n', '        );\n', '    }\n', '\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) public virtual override {\n', '        require(block.timestamp <= deadline, "Permit: expired deadline");\n', '\n', '        bytes32 hashStruct =\n', '            keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));\n', '\n', '        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\n', '\n', '        address signer = ecrecover(_hash, v, r, s);\n', '        require(signer != address(0) && signer == owner, "ZeroSwapPermit: Invalid signature");\n', '\n', '        _nonces[owner].increment();\n', '        _approve(owner, spender, amount);\n', '    }\n', '\n', '    function nonces(address owner) public view override returns (uint256) {\n', '        return _nonces[owner].current();\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'library FullMath {\n', '    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\n', '        uint256 mm = mulmod(x, y, uint256(-1));\n', '        l = x * y;\n', '        h = mm - l;\n', '        if (mm < l) h -= 1;\n', '    }\n', '\n', '    function fullDiv(\n', '        uint256 l,\n', '        uint256 h,\n', '        uint256 d\n', '    ) private pure returns (uint256) {\n', '        uint256 pow2 = d & -d;\n', '        d /= pow2;\n', '        l /= pow2;\n', '        l += h * ((-pow2) / pow2 + 1);\n', '        uint256 r = 1;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        r *= 2 - d * r;\n', '        return l * r;\n', '    }\n', '\n', '    function mulDiv(\n', '        uint256 x,\n', '        uint256 y,\n', '        uint256 d\n', '    ) internal pure returns (uint256) {\n', '        (uint256 l, uint256 h) = fullMul(x, y);\n', '        uint256 mm = mulmod(x, y, d);\n', '        if (mm > l) h -= 1;\n', '        l -= mm;\n', "        require(h < d, 'FullMath::mulDiv: overflow');\n", '        return fullDiv(l, h, d);\n', '    }\n', '}\n', '\n', 'library FixedPoint {\n', '\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    struct uq144x112 {\n', '        uint256 _x;\n', '    }\n', '\n', '    uint8 private constant RESOLUTION = 112;\n', '    uint256 private constant Q112 = 0x10000000000000000000000000000;\n', '    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\n', '    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n', '\n', '    function decode(uq112x112 memory self) internal pure returns (uint112) {\n', '        return uint112(self._x >> RESOLUTION);\n', '    }\n', '\n', '    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\n', '\n', '        return uint(self._x) / 5192296858534827;\n', '    }\n', '\n', '    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n', "        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n", '        if (numerator == 0) return FixedPoint.uq112x112(0);\n', '\n', '        if (numerator <= uint144(-1)) {\n', '            uint256 result = (numerator << RESOLUTION) / denominator;\n', "            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n", '            return uq112x112(uint224(result));\n', '        } else {\n', '            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n', "            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n", '            return uq112x112(uint224(result));\n', '        }\n', '    }\n', '}\n', '\n', 'interface ITreasury {\n', '    function depositReserves( uint depositAmount_ ) external returns ( bool );\n', '}\n', '\n', 'interface ICirculatingOHM {\n', '    function OHMCirculatingSupply() external view returns ( uint );\n', '}\n', '\n', 'interface IBondDepo {\n', '\n', '    function getDepositorInfo( address _depositorAddress_ ) external view returns ( uint principleValue_, uint paidOut_, uint maxPayout, uint vestingPeriod_ );\n', '    \n', '    function deposit( uint256 amount_, uint maxPremium_, address depositor_ ) external returns ( bool );\n', '\n', '    function depositWithPermit( uint256 amount_, uint maxPremium_, address depositor_, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external returns ( bool );\n', '\n', '    function redeem() external returns ( bool );\n', '\n', '    function calculatePercentVested( address depositor_ ) external view returns ( uint _percentVested );\n', '    \n', '    function calculatePendingPayout( address depositor_ ) external view returns ( uint _pendingPayout );\n', '      \n', '    function calculateBondInterest( uint value_ ) external view returns ( uint _interestDue );\n', '        \n', '    function calculatePremium() external view returns ( uint _premium );\n', '}\n', '\n', '\n', '\n', 'contract OlympusDAIDepository is IBondDepo, Ownable {\n', '\n', '    using FixedPoint for *;\n', '    using SafeERC20 for IERC20;\n', '    using SafeMath for uint;\n', '\n', '    struct DepositInfo {\n', '        uint value; // Value\n', '        uint payoutRemaining; // OHM remaining to be paid\n', '        uint lastBlock; // Last interaction\n', '        uint vestingPeriod; // Blocks left to vest\n', '    }\n', '\n', '    mapping( address => DepositInfo ) public depositorInfo; \n', '\n', '    uint public DAOShare; // % = 1 / DAOShare\n', '    uint public bondControlVariable; // Premium scaling variable\n', '    uint public vestingPeriodInBlocks; \n', '    uint public minPremium; // Floor for the premium\n', '\n', '    //  Max a payout can be compared to the circulating supply, in hundreths. i.e. 50 = 0.5%\n', '    uint public maxPayoutPercent;\n', '\n', '    address public treasury;\n', '    address public DAI;\n', '    address public OHM;\n', '\n', '    uint256 public totalDebt; // Total value of outstanding bonds\n', '\n', '    address public stakingContract;\n', '    address public DAOWallet;\n', '    address public circulatingOHMContract; // calculates circulating supply\n', '\n', '    bool public useCircForDebtRatio; // Use circulating or total supply to calc total debt\n', '\n', '    constructor ( \n', '        address DAI_, \n', '        address OHM_,\n', '        address treasury_, \n', '        address stakingContract_, \n', '        address DAOWallet_, \n', '        address circulatingOHMContract_\n', '    ) {\n', '        DAI = DAI_;\n', '        OHM = OHM_;\n', '        treasury = treasury_;\n', '        stakingContract = stakingContract_;\n', '        DAOWallet = DAOWallet_;\n', '        circulatingOHMContract = circulatingOHMContract_;\n', '    }\n', '\n', '    /**\n', '        @notice set parameters of new bonds\n', '        @param bondControlVariable_ uint\n', '        @param vestingPeriodInBlocks_ uint\n', '        @param minPremium_ uint\n', '        @param maxPayout_ uint\n', '        @param DAOShare_ uint\n', '        @return bool\n', '     */\n', '    function setBondTerms( \n', '        uint bondControlVariable_, \n', '        uint vestingPeriodInBlocks_, \n', '        uint minPremium_, \n', '        uint maxPayout_,\n', '        uint DAOShare_ ) \n', '    external onlyOwner() returns ( bool ) {\n', '        bondControlVariable = bondControlVariable_;\n', '        vestingPeriodInBlocks = vestingPeriodInBlocks_;\n', '        minPremium = minPremium_;\n', '        maxPayoutPercent = maxPayout_;\n', '        DAOShare = DAOShare_;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice deposit bond\n', '        @param amount_ uint\n', '        @param maxPremium_ uint\n', '        @param depositor_ address\n', '        @return bool\n', '     */\n', '    function deposit( \n', '        uint amount_, \n', '        uint maxPremium_,\n', '        address depositor_ ) \n', '    external override returns ( bool ) {\n', '        _deposit( amount_, maxPremium_, depositor_ ) ;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice deposit bond with permit\n', '        @param amount_ uint\n', '        @param maxPremium_ uint\n', '        @param depositor_ address\n', '        @param v uint8\n', '        @param r bytes32\n', '        @param s bytes32\n', '        @return bool\n', '     */\n', '    function depositWithPermit( \n', '        uint amount_, \n', '        uint maxPremium_,\n', '        address depositor_, \n', '        uint deadline, \n', '        uint8 v, \n', '        bytes32 r, \n', '        bytes32 s ) \n', '    external override returns ( bool ) {\n', '        ERC20Permit( DAI ).permit( msg.sender, address(this), amount_, deadline, v, r, s );\n', '        _deposit( amount_, maxPremium_, depositor_ ) ;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice deposit function like mint\n', '        @param amount_ uint\n', '        @param maxPremium_ uint\n', '        @param depositor_ address\n', '        @return bool\n', '     */\n', '    function _deposit( \n', '        uint amount_, \n', '        uint maxPremium_, \n', '        address depositor_ ) \n', '    internal returns ( bool ) {\n', '        // slippage protection\n', '        require( maxPremium_ >= _calcPremium(), "Slippage protection: more than max premium" );\n', '\n', '        IERC20( DAI ).safeTransferFrom( msg.sender, address(this), amount_ );\n', '\n', '        uint value_ = amount_.div( 1e9 );\n', '        uint payout_ = calculateBondInterest( value_ );\n', '\n', '        require( payout_ >= 10000000, "Bond too small" ); // must be > 0.01 OHM\n', '        require( payout_ <= getMaxPayoutAmount(), "Bond too large");\n', '\n', '        totalDebt = totalDebt.add( value_ );\n', '\n', '        // Deposit token to mint OHM\n', '        IERC20( DAI ).approve( address( treasury ), amount_ );\n', '        ITreasury( treasury ).depositReserves( amount_ ); // Returns OHM\n', '\n', '        uint profit_ = value_.sub( payout_ );\n', '        uint DAOProfit_ = FixedPoint.fraction( profit_, DAOShare ).decode();\n', '        // Transfer profits to staking distributor and dao\n', '        IERC20( OHM ).safeTransfer( stakingContract, profit_.sub( DAOProfit_ ) );\n', '        IERC20( OHM ).safeTransfer( DAOWallet, DAOProfit_ );\n', '\n', '        // Store depositor info\n', '        depositorInfo[ depositor_ ] = DepositInfo({\n', '            value: depositorInfo[ depositor_ ].value.add( value_ ),\n', '            payoutRemaining: depositorInfo[ depositor_ ].payoutRemaining.add( payout_ ),\n', '            lastBlock: block.number,\n', '            vestingPeriod: vestingPeriodInBlocks\n', '        });\n', '        return true;\n', '    }\n', '\n', '    /** \n', '        @notice redeem bond\n', '        @return bool\n', '     */ \n', '    function redeem() external override returns ( bool ) {\n', '        uint payoutRemaining_ = depositorInfo[ msg.sender ].payoutRemaining;\n', '\n', '        require( payoutRemaining_ > 0, "Sender is not due any interest." );\n', '\n', '        uint value_ = depositorInfo[ msg.sender ].value;\n', '        uint percentVested_ = _calculatePercentVested( msg.sender );\n', '\n', '        if ( percentVested_ >= 10000 ) { // if fully vested\n', '            delete depositorInfo[msg.sender];\n', '            IERC20( OHM ).safeTransfer( msg.sender, payoutRemaining_ );\n', '            totalDebt = totalDebt.sub( value_ );\n', '            return true;\n', '        }\n', '\n', '        // calculate and send vested OHM\n', '        uint payout_ = payoutRemaining_.mul( percentVested_ ).div( 10000 );\n', '        IERC20( OHM ).safeTransfer( msg.sender, payout_ );\n', '\n', '        // reduce total debt by vested amount\n', '        uint valueUsed_ = value_.mul( percentVested_ ).div( 10000 );\n', '        totalDebt = totalDebt.sub( valueUsed_ );\n', '\n', '        uint vestingPeriod_ = depositorInfo[msg.sender].vestingPeriod;\n', '        uint blocksSinceLast_ = block.number.sub( depositorInfo[ msg.sender ].lastBlock );\n', '\n', '        // store updated deposit info\n', '        depositorInfo[msg.sender] = DepositInfo({\n', '            value: value_.sub( valueUsed_ ),\n', '            payoutRemaining: payoutRemaining_.sub( payout_ ),\n', '            lastBlock: block.number,\n', '            vestingPeriod: vestingPeriod_.sub( blocksSinceLast_ )\n', '        });\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice get info of depositor\n', '        @param address_ info\n', '     */\n', '    function getDepositorInfo( address address_ ) external view override returns ( \n', '        uint _value, \n', '        uint _payoutRemaining, \n', '        uint _lastBlock, \n', '        uint _vestingPeriod ) \n', '    {\n', '        DepositInfo memory info = depositorInfo[ address_ ];\n', '        _value = info.value;\n', '        _payoutRemaining = info.payoutRemaining;\n', '        _lastBlock = info.lastBlock;\n', '        _vestingPeriod = info.vestingPeriod;\n', '    }\n', '\n', '    /**\n', '        @notice set contract to use circulating or total supply to calc debt\n', '     */\n', '    function toggleUseCircForDebtRatio() external onlyOwner() returns ( bool ) {\n', '        useCircForDebtRatio = !useCircForDebtRatio;\n', '        return true;\n', '    }\n', '\n', '    /**\n', '        @notice use maxPayoutPercent to determine maximum bond available\n', '        @return uint\n', '     */\n', '    function getMaxPayoutAmount() public view returns ( uint ) {\n', '        uint circulatingOHM = ICirculatingOHM( circulatingOHMContract ).OHMCirculatingSupply();\n', '\n', '        uint maxPayout = circulatingOHM.mul( maxPayoutPercent ).div( 10000 );\n', '\n', '        return maxPayout;\n', '    }\n', '\n', '    /**\n', '        @notice view function for _calculatePercentVested\n', '        @param depositor_ address\n', '        @return _percentVested uint\n', '     */\n', '    function calculatePercentVested( address depositor_ ) external view override returns ( uint _percentVested ) {\n', '        _percentVested = _calculatePercentVested( depositor_ );\n', '    }\n', '\n', '    /**\n', '        @notice calculate how far into vesting period depositor is\n', '        @param depositor_ address\n', '        @return _percentVested uint ( in hundreths - i.e. 10 = 0.1% )\n', '     */\n', '    function _calculatePercentVested( address depositor_ ) internal view returns ( uint _percentVested ) {\n', '        uint vestingPeriod_ = depositorInfo[ depositor_ ].vestingPeriod;\n', '        if ( vestingPeriod_ > 0 ) {\n', '            uint blocksSinceLast_ = block.number.sub( depositorInfo[ depositor_ ].lastBlock );\n', '            _percentVested = blocksSinceLast_.mul( 10000 ).div( vestingPeriod_ );\n', '        } else {\n', '            _percentVested = 0;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice calculate amount of OHM available for claim by depositor\n', '        @param depositor_ address\n', '        @return uint\n', '     */\n', '    function calculatePendingPayout( address depositor_ ) external view override returns ( uint ) {\n', '        uint percentVested_ = _calculatePercentVested( depositor_ );\n', '        uint payoutRemaining_ = depositorInfo[ depositor_ ].payoutRemaining;\n', '        \n', '        uint pendingPayout = payoutRemaining_.mul( percentVested_ ).div( 10000 );\n', '\n', '        if ( percentVested_ >= 10000 ) {\n', '            pendingPayout = payoutRemaining_;\n', '        } \n', '        return pendingPayout;\n', '    }\n', '\n', '    /**\n', '        @notice calculate interest due to new bonder\n', '        @param value_ uint\n', '        @return _interestDue uint\n', '     */\n', '    function calculateBondInterest( uint value_ ) public view override returns ( uint _interestDue ) {\n', '        _interestDue = FixedPoint.fraction( value_, _calcPremium() ).decode112with18().div( 1e16 );\n', '    }\n', '\n', '    /**\n', '        @notice view function for _calcPremium()\n', '        @return _premium uint\n', '     */\n', '    function calculatePremium() external view override returns ( uint _premium ) {\n', '        _premium = _calcPremium();\n', '    }\n', '\n', '    /**\n', '        @notice calculate current bond premium\n', '        @return _premium uint\n', '     */\n', '    function _calcPremium() internal view returns ( uint _premium ) {\n', '        _premium = bondControlVariable.mul( _calcDebtRatio() ).add( uint(1000000000) ).div( 1e7 );\n', '        if ( _premium < minPremium ) {\n', '            _premium = minPremium;\n', '        }\n', '    }\n', '\n', '    /**\n', '        @notice calculate current debt ratio\n', '        @return _debtRatio uint\n', '     */\n', '    function _calcDebtRatio() internal view returns ( uint _debtRatio ) {   \n', '        uint supply;\n', '\n', '        if( useCircForDebtRatio ) {\n', '            supply = ICirculatingOHM( circulatingOHMContract ).OHMCirculatingSupply();\n', '        } else {\n', '            supply = IERC20( OHM ).totalSupply();\n', '        }\n', '\n', '        _debtRatio = FixedPoint.fraction( \n', '            // Must move the decimal to the right by 9 places to avoid math underflow error\n', '            totalDebt.mul( 1e9 ), \n', '            supply\n', '        ).decode112with18().div( 1e18 );\n', '        // Must move the decimal to the left 18 places to account for the 9 places added above and the 19 signnificant digits added by FixedPoint.\n', '    }\n', '}']