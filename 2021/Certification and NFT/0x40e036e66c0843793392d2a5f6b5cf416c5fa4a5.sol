['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-23\n', '*/\n', '\n', '// File: contracts\\farming\\FarmData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct FarmingPositionRequest {\n', '    uint256 setupIndex; // index of the chosen setup.\n', '    uint256 amount0; // amount of main token or liquidity pool token.\n', '    uint256 amount1; // amount of other token or liquidity pool token. Needed for gen2\n', '    address positionOwner; // position extension or address(0) [msg.sender].\n', '}\n', '\n', 'struct FarmingSetupConfiguration {\n', "    bool add; // true if we're adding a new setup, false we're updating it.\n", '    bool disable;\n', "    uint256 index; // index of the setup we're updating.\n", '    FarmingSetupInfo info; // data of the new or updated setup\n', '}\n', '\n', 'struct FarmingSetupInfo {\n', '    uint256 blockDuration; // duration of setup\n', '    uint256 startBlock; // optional start block used for the delayed activation of the first setup\n', '    uint256 originalRewardPerBlock;\n', '    uint256 minStakeable; // minimum amount of staking tokens.\n', "    uint256 renewTimes; // if the setup is renewable or if it's one time.\n", '    address liquidityPoolTokenAddress; // address of the liquidity pool token\n', '    address mainTokenAddress; // eg. buidl address.\n', '    bool involvingETH; // if the setup involves ETH or not.\n', '    uint256 setupsCount; // number of setups created by this info.\n', '    uint256 lastSetupIndex; // index of last setup;\n', '    int24 tickLower; // Gen2 Only - tickLower of the UniswapV3 pool\n', '    int24 tickUpper; // Gen 2 Only - tickUpper of the UniswapV3 pool\n', '}\n', '\n', 'struct FarmingSetup {\n', '    uint256 infoIndex; // setup info\n', '    bool active; // if the setup is active or not.\n', '    uint256 startBlock; // farming setup start block.\n', '    uint256 endBlock; // farming setup end block.\n', '    uint256 lastUpdateBlock; // number of the block where an update was triggered.\n', '    uint256 objectId; // need for gen2. uniswapV3 NFT position Id\n', '    uint256 rewardPerBlock; // farming setup reward per single block.\n', '    uint128 totalSupply; // Total LP token liquidity of all the positions of this setup\n', '}\n', '\n', 'struct FarmingPosition {\n', '    address uniqueOwner; // address representing the owner of the position.\n', '    uint256 setupIndex; // the setup index related to this position.\n', '    uint256 creationBlock; // block when this position was created.\n', '    uint128 liquidityPoolTokenAmount; // amount of liquidity pool token in the position.\n', '    uint256 reward; // position reward.\n', '}\n', '\n', '// File: contracts\\farming\\IFarmExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IFarmExtension {\n', '\n', '    function init(bool byMint, address host, address treasury) external;\n', '\n', '    function setHost(address host) external;\n', '    function setTreasury(address treasury) external;\n', '\n', '    function data() external view returns(address farmMainContract, bool byMint, address host, address treasury, address rewardTokenAddress);\n', '\n', '    function transferTo(uint256 amount) external;\n', '    function backToYou(uint256 amount) external payable;\n', '\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\n', '}\n', '\n', '// File: contracts\\farming\\IFarmMain.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IFarmMain {\n', '\n', '    function ONE_HUNDRED() external view returns(uint256);\n', '    function _rewardTokenAddress() external view returns(address);\n', '    function position(uint256 positionId) external view returns (FarmingPosition memory);\n', '    function setups() external view returns (FarmingSetup[] memory);\n', '    function setup(uint256 setupIndex) external view returns (FarmingSetup memory, FarmingSetupInfo memory);\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\n', '    function openPosition(FarmingPositionRequest calldata request) external payable returns(uint256 positionId);\n', '    function addLiquidity(uint256 positionId, FarmingPositionRequest calldata request) external payable;\n', '}\n', '\n', '// File: contracts\\farming\\util\\DFOHub.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IDoubleProxy {\n', '    function proxy() external view returns (address);\n', '}\n', '\n', 'interface IMVDProxy {\n', '    function getMVDFunctionalitiesManagerAddress() external view returns(address);\n', '    function getMVDWalletAddress() external view returns (address);\n', '    function getStateHolderAddress() external view returns(address);\n', '    function submit(string calldata codeName, bytes calldata data) external payable returns(bytes memory returnData);\n', '}\n', '\n', 'interface IMVDFunctionalitiesManager {\n', '    function getFunctionalityData(string calldata codeName) external view returns(address, uint256, string memory, address, uint256);\n', '    function isAuthorizedFunctionality(address functionality) external view returns(bool);\n', '}\n', '\n', 'interface IStateHolder {\n', '    function getUint256(string calldata name) external view returns(uint256);\n', '    function getAddress(string calldata name) external view returns(address);\n', '    function clear(string calldata varName) external returns(string memory oldDataType, bytes memory oldVal);\n', '}\n', '\n', '// File: contracts\\WUSD\\AllowedAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct AllowedAMM {\n', '    address ammAddress;\n', '    address[] liquidityPools;\n', '}\n', '\n', '// File: contracts\\WUSD\\IWUSDExtensionController.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IWUSDExtensionController {\n', '\n', '    function rebalanceByCreditBlockInterval() external view returns(uint256);\n', '\n', '    function lastRebalanceByCreditBlock() external view returns(uint256);\n', '\n', '    function wusdInfo() external view returns (address, uint256, address);\n', '\n', '    function allowedAMMs() external view returns(AllowedAMM[] memory);\n', '\n', '    function extension() external view returns (address);\n', '\n', '    function addLiquidity(\n', '        uint256 ammPosition,\n', '        uint256 liquidityPoolPosition,\n', '        uint256 liquidityPoolAmount,\n', '        bool byLiquidityPool\n', '    ) external returns(uint256);\n', '}\n', '\n', '// File: contracts\\WUSD\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\WUSD\\WUSDFarmingExtension.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract WUSDFarmingExtension is IFarmExtension {\n', '\n', '    string private constant FUNCTIONALITY_NAME = "manageFarming";\n', '\n', '    uint256 public constant ONE_HUNDRED = 1e18;\n', '\n', '    // wallet who has control on the extension\n', '    address internal _doubleProxy;\n', '\n', '    // mapping that contains all the farming contract linked to this extension\n', '    address internal _farmingContract;\n', '\n', '    // the reward token address linked to this farming contract\n', '    address internal _rewardTokenAddress;\n', '\n', '    address public wusdExtensionControllerAddress;\n', '\n', '    uint256 public rewardCreditPercentage;\n', '\n', '    FarmingSetupInfo[] private infoModels;\n', '    uint256[] private rebalancePercentages;\n', '\n', '    uint256 public lastCheck;\n', '    uint256 public lastBalance;\n', '\n', '    /** MODIFIERS */\n', '\n', '    /** @dev farmingOnly modifier used to check for unauthorized transfers. */\n', '    modifier farmingOnly() {\n', '        require(msg.sender == _farmingContract, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** @dev hostOnly modifier used to check for unauthorized edits. */\n', '    modifier hostOnly() {\n', '        require(_isFromDFO(msg.sender), "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** PUBLIC METHODS */\n', '\n', '    function init(bool, address, address) public virtual override {\n', '        revert("Method not allowed, use specific one instead");\n', '    }\n', '\n', '    function init(address host, address _wusdExtensionControllerAddress, FarmingSetupInfo[] memory farmingSetups, uint256[] memory _rebalancePercentages, uint256 _rewardCreditPercentage) public virtual {\n', '        require(_farmingContract == address(0), "Already init");\n', '        require(host != address(0), "blank host");\n', '        _rewardTokenAddress = IFarmMain(_farmingContract = msg.sender)._rewardTokenAddress();\n', '        _doubleProxy = host;\n', '        wusdExtensionControllerAddress = _wusdExtensionControllerAddress;\n', '        _setModels(farmingSetups, _rebalancePercentages);\n', '        rewardCreditPercentage = _rewardCreditPercentage;\n', '    }\n', '\n', '    function _setModels(FarmingSetupInfo[] memory farmingSetups, uint256[] memory _rebalancePercentages) private {\n', '        require(farmingSetups.length > 0 && (farmingSetups.length - 1) == _rebalancePercentages.length, "Invalid data");\n', '        delete rebalancePercentages;\n', '        delete infoModels;\n', '        uint256 percentage = 0;\n', '        for(uint256 i = 0; i < _rebalancePercentages.length; i++) {\n', '            farmingSetups[i].renewTimes = 0;\n', '            infoModels.push(farmingSetups[i]);\n', '            percentage += _rebalancePercentages[i];\n', '            rebalancePercentages.push(_rebalancePercentages[i]);\n', '        }\n', '        farmingSetups[farmingSetups.length - 1].renewTimes = 0;\n', '        infoModels.push(farmingSetups[farmingSetups.length - 1]);\n', '        require(percentage < ONE_HUNDRED, "More than one hundred");\n', '    }\n', '\n', '    /** @dev allows the DFO to update the double proxy address.\n', '      * @param newDoubleProxy new double proxy address.\n', '     */\n', '    function setHost(address newDoubleProxy) public virtual override hostOnly {\n', '        _doubleProxy = newDoubleProxy;\n', '    }\n', '\n', '    /** @dev method used to update the extension treasury.\n', '     */\n', '    function setTreasury(address) public virtual override hostOnly {\n', '        revert("Impossibru!");\n', '    }\n', '\n', '    function setRewardCreditPercentage(uint256 _rewardCreditPercentage) public hostOnly {\n', '        rewardCreditPercentage = _rewardCreditPercentage;\n', '    }\n', '\n', '    function data() view public virtual override returns(address farmingContract, bool byMint, address host, address treasury, address rewardTokenAddress) {\n', '        return (_farmingContract, false, _doubleProxy, _getDFOWallet(), _rewardTokenAddress);\n', '    }\n', '\n', '    function models() public view returns(FarmingSetupInfo[] memory, uint256[] memory) {\n', '        return (infoModels, rebalancePercentages);\n', '    }\n', '\n', '    /** @dev transfers the input amount to the caller farming contract.\n', '      * @param amount amount of erc20 to transfer or mint.\n', '     */\n', '    function transferTo(uint256 amount) public virtual override farmingOnly {\n', '        lastBalance -= amount;\n', '        if(_rewardTokenAddress != address(0)) {\n', '            return _safeTransfer(_rewardTokenAddress, _farmingContract, amount);\n', '        }\n', '        (bool result, ) = _farmingContract.call{value:amount}("");\n', '        require(result, "ETH transfer failed.");\n', '    }\n', '\n', '    /** @dev transfers the input amount from the caller farming contract to the extension.\n', '      * @param amount amount of erc20 to transfer back or burn.\n', '     */\n', '    function backToYou(uint256 amount) payable public virtual override farmingOnly {\n', '        lastBalance += amount;\n', '        if(_rewardTokenAddress != address(0)) {\n', '            return _safeTransferFrom(_rewardTokenAddress, msg.sender, address(this), amount);\n', '        }\n', '        require(msg.value == amount, "invalid sent amount");\n', '    }\n', '\n', '    function flushTo(address[] memory tokenAddresses, uint256[] memory amounts, address receiver) public hostOnly {\n', '        for(uint256 i = 0; i < tokenAddresses.length; i++) {\n', '            if(tokenAddresses[i] == address(0)) {\n', '                (bool result, ) = receiver.call{value:amounts[i]}("");\n', '                require(result, "ETH transfer failed.");\n', '            } else {\n', '                _safeTransfer(tokenAddresses[i], receiver, amounts[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @dev this function calls the liquidity mining contract with the given address and sets the given liquidity mining setups.*/\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) public override hostOnly {\n', '        IFarmMain(_farmingContract).setFarmingSetups(farmingSetups);\n', '    }\n', '\n', '    function setWusdExtensionControllerAddress(address _wusdExtensionControllerAddress) public hostOnly {\n', '        wusdExtensionControllerAddress = _wusdExtensionControllerAddress;\n', '    }\n', '\n', '    function setModels(FarmingSetupInfo[] memory farmingSetups, uint256[] memory _rebalancePercentages) public hostOnly {\n', '        _setModels(farmingSetups, _rebalancePercentages);\n', '    }\n', '\n', '    function rebalanceRewardsPerBlock() public {\n', '        uint256 lastRebalanceByCreditBlock = IWUSDExtensionController(wusdExtensionControllerAddress).lastRebalanceByCreditBlock();\n', '        require(lastRebalanceByCreditBlock > 0 && lastRebalanceByCreditBlock != lastCheck, "Invalid block");\n', '        lastCheck = lastRebalanceByCreditBlock;\n', '        uint256 amount = _calculatePercentage(IERC20(_rewardTokenAddress).balanceOf(_getDFOWallet()), rewardCreditPercentage);\n', '        IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).submit(FUNCTIONALITY_NAME, abi.encode(address(0), 0, true, _rewardTokenAddress, address(this), amount, false));\n', '        uint256 totalBalance = IERC20(_rewardTokenAddress).balanceOf(address(this));\n', '        uint256 balance = totalBalance - lastBalance;\n', '        lastBalance = totalBalance;\n', '        uint256 remainingBalance = balance;\n', '        uint256 currentReward = 0;\n', '        FarmingSetupConfiguration[] memory farmingSetups = new FarmingSetupConfiguration[](infoModels.length);\n', '        uint256 i;\n', '        for(i = 0; i < rebalancePercentages.length; i++) {\n', '            infoModels[i].originalRewardPerBlock = (currentReward = _calculatePercentage(balance, rebalancePercentages[i])) / infoModels[i].blockDuration;\n', '            remainingBalance -= currentReward;\n', '            farmingSetups[i] = FarmingSetupConfiguration(\n', '                true,\n', '                false,\n', '                0,\n', '                infoModels[i]\n', '            );\n', '        }\n', '        i = rebalancePercentages.length;\n', '        infoModels[i].originalRewardPerBlock = remainingBalance / infoModels[i].blockDuration;\n', '        farmingSetups[i] = FarmingSetupConfiguration(\n', '            true,\n', '            false,\n', '            0,\n', '            infoModels[i]\n', '        );\n', '        IFarmMain(_farmingContract).setFarmingSetups(farmingSetups);\n', '    }\n', '\n', '    /** PRIVATE METHODS */\n', '\n', '    function _calculatePercentage(uint256 totalSupply, uint256 percentage) private pure returns(uint256) {\n', '        return (totalSupply * ((percentage * 1e18) / ONE_HUNDRED)) / 1e18;\n', '    }\n', '\n', '    /** @dev this function returns the address of the functionality with the FUNCTIONALITY_NAME.\n', '      * @return functionalityAddress functionality FUNCTIONALITY_NAME address.\n', '     */\n', '    function _getFunctionalityAddress() private view returns(address functionalityAddress) {\n', '        (functionalityAddress,,,,) = IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).getFunctionalityData(FUNCTIONALITY_NAME);\n', '    }\n', '\n', '    /** @dev this function returns the address of the wallet of the linked DFO.\n', '      * @return linked DFO wallet address.\n', '     */\n', '    function _getDFOWallet() private view returns(address) {\n', '        return IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDWalletAddress();\n', '    }\n', '\n', '    /** @dev this function returns true if the sender is an authorized DFO functionality, false otherwise.\n', '      * @param sender address of the caller.\n', '      * @return true if the call is from a DFO, false otherwise.\n', '     */\n', '    function _isFromDFO(address sender) private view returns(bool) {\n', '        return IMVDFunctionalitiesManager(IMVDProxy(IDoubleProxy(_doubleProxy).proxy()).getMVDFunctionalitiesManagerAddress()).isAuthorizedFunctionality(sender);\n', '    }\n', '\n', '    /** @dev function used to safely approve ERC20 transfers.\n', '      * @param erc20TokenAddress address of the token to approve.\n', '      * @param to receiver of the approval.\n', '      * @param value amount to approve for.\n', '     */\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    /** @dev function used to safe transfer ERC20 tokens.\n', '      * @param erc20TokenAddress address of the token to transfer.\n', '      * @param to receiver of the tokens.\n', '      * @param value amount of tokens to transfer.\n', '     */\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    /** @dev this function safely transfers the given ERC20 value from an address to another.\n', '      * @param erc20TokenAddress erc20 token address.\n', '      * @param from address from.\n', '      * @param to address to.\n', '      * @param value amount to transfer.\n', '     */\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '}']