['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-04\n', '*/\n', '\n', 'pragma solidity ^0.4.23;\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// Wall Street Decentral (WALL) token public sale contract\n', '//\n', '// For details, please visit: http://WallStreetDecentral.com\n', '//\n', '//\n', '// Written by Wall Street Decentral [email\xa0protected]\n', '//\n', '// ----------------------------------------------------------------------------\n', '// ----------------------------------------------------------------------------\n', '//\n', '// SafeMath\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'library SafeMath {\n', '\n', '    function add(uint a, uint b) internal pure returns (uint c) {\n', '        c = a + b;\n', '        require(c >= a);\n', '    }\n', '\n', '    function sub(uint a, uint b) internal pure returns (uint c) {\n', '        require(b <= a);\n', '        c = a - b;\n', '    }\n', '\n', '    function mul(uint a, uint b) internal pure returns (uint c) {\n', '        c = a * b;\n', '        require(a == 0 || c / a == b);\n', '    }\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// Owned\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Owned {\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    mapping(address => bool) public isAdmin;\n', '\n', '    event OwnershipTransferProposed(address indexed _from, address indexed _to);\n', '    event OwnershipTransferred(address indexed _from, address indexed _to);\n', '    event AdminChange(address indexed _admin, bool _status);\n', '\n', '    modifier onlyOwner {require(msg.sender == owner); _;}\n', '    modifier onlyAdmin {require(isAdmin[msg.sender]); _;}\n', '\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        isAdmin[owner] = true;\n', '    }\n', '\n', '    function transferOwnership(address _newOwner) public onlyOwner {\n', '        require(_newOwner != address(0x0));\n', '        emit OwnershipTransferProposed(owner, _newOwner);\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '    }\n', '\n', '    function addAdmin(address _a) public onlyOwner {\n', '        require(isAdmin[_a] == false);\n', '        isAdmin[_a] = true;\n', '        emit AdminChange(_a, true);\n', '    }\n', '\n', '    function removeAdmin(address _a) public onlyOwner {\n', '        require(isAdmin[_a] == true);\n', '        isAdmin[_a] = false;\n', '        emit AdminChange(_a, false);\n', '    }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// Wallet\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract Wallet is Owned {\n', '\n', '    address public wallet;\n', '\n', '    event WalletUpdated(address newWallet);\n', '\n', '    constructor() public {\n', '        wallet = owner;\n', '    }\n', '\n', '    function setWallet(address _wallet) public onlyOwner {\n', '        require(_wallet != address(0x0));\n', '        wallet = _wallet;\n', '        emit WalletUpdated(_wallet);\n', '    }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC20Interface\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Interface {\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint _value);\n', '\n', '    function totalSupply() public view returns (uint);\n', '    function balanceOf(address _owner) public view returns (uint balance);\n', '    function transfer(address _to, uint _value) public returns (bool success);\n', '    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n', '    function approve(address _spender, uint _value) public returns (bool success);\n', '    function allowance(address _owner, address _spender) public view returns (uint remaining);\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// ERC20 Token Standard\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract ERC20Token is ERC20Interface, Owned {\n', '\n', '    using SafeMath for uint;\n', '\n', '    uint public tokensIssuedTotal;\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping (address => uint)) allowed;\n', '\n', '    function totalSupply() public view returns (uint) {\n', '        return tokensIssuedTotal;\n', '    }\n', '    // Includes BOTH locked AND unlocked tokens\n', '\n', '    function balanceOf(address _owner) public view returns (uint) {\n', '        return balances[_owner];\n', '    }\n', '\n', '    function transfer(address _to, uint _amount) public returns (bool) {\n', '        require(_to != 0x0);\n', '        balances[msg.sender] = balances[msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(msg.sender, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function approve(address _spender, uint _amount) public returns (bool) {\n', '        allowed[msg.sender][_spender] = _amount;\n', '        emit Approval(msg.sender, _spender, _amount);\n', '        return true;\n', '    }\n', '\n', '    function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\n', '        require(_to != 0x0);\n', '        balances[_from] = balances[_from].sub(_amount);\n', '        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\n', '        balances[_to] = balances[_to].add(_amount);\n', '        emit Transfer(_from, _to, _amount);\n', '        return true;\n', '    }\n', '\n', '    function allowance(address _owner, address _spender) public view returns (uint) {\n', '        return allowed[_owner][_spender];\n', '    }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// LockSlots\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract LockSlots is ERC20Token {\n', '\n', '    using SafeMath for uint;\n', '\n', '    uint public constant LOCK_SLOTS = 5;\n', '    mapping(address => uint[LOCK_SLOTS]) public lockTerm;\n', '    mapping(address => uint[LOCK_SLOTS]) public lockAmnt;\n', '    mapping(address => bool) public mayHaveLockedTokens;\n', '\n', '    event RegisteredLockedTokens(address indexed account, uint indexed idx, uint tokens, uint term);\n', '\n', '    function registerLockedTokens(address _account, uint _tokens, uint _term) internal returns (uint idx) {\n', '        require(_term > now, "lock term must be in the future");\n', '\n', '        // find a slot (clean up while doing this)\n', '        // use either the existing slot with the exact same term,\n', '        // of which there can be at most one, or the first empty slot\n', '        idx = 9999;\n', '        uint[LOCK_SLOTS] storage term = lockTerm[_account];\n', '        uint[LOCK_SLOTS] storage amnt = lockAmnt[_account];\n', '        for (uint i; i < LOCK_SLOTS; i++) {\n', '            if (term[i] < now) {\n', '                term[i] = 0;\n', '                amnt[i] = 0;\n', '                if (idx == 9999) idx = i;\n', '            }\n', '            if (term[i] == _term) idx = i;\n', '        }\n', '\n', '        // fail if no slot was found\n', '        require(idx != 9999, "registerLockedTokens: no available slot found");\n', '\n', '        // register locked tokens\n', '        if (term[idx] == 0) term[idx] = _term;\n', '        amnt[idx] = amnt[idx].add(_tokens);\n', '        mayHaveLockedTokens[_account] = true;\n', '        emit RegisteredLockedTokens(_account, idx, _tokens, _term);\n', '    }\n', '\n', '    // public view functions\n', '\n', '    function lockedTokens(address _account) public view returns (uint) {\n', '        if (!mayHaveLockedTokens[_account]) return 0;\n', '        return pNumberOfLockedTokens(_account);\n', '    }\n', '\n', '    function unlockedTokens(address _account) public view returns (uint) {\n', '        return balances[_account].sub(lockedTokens(_account));\n', '    }\n', '\n', '    function isAvailableLockSlot(address _account, uint _term) public view returns (bool) {\n', '        if (!mayHaveLockedTokens[_account]) return true;\n', '        if (_term < now) return true;\n', '        uint[LOCK_SLOTS] storage term = lockTerm[_account];\n', '        for (uint i; i < LOCK_SLOTS; i++) {\n', '            if (term[i] < now || term[i] == _term) return true;\n', '        }\n', '        return false;\n', '    }\n', '\n', '    // internal and private functions\n', '\n', '    function unlockedTokensInternal(address _account) internal returns (uint) {\n', '        // updates mayHaveLockedTokens if necessary\n', '        if (!mayHaveLockedTokens[_account]) return balances[_account];\n', '        uint locked = pNumberOfLockedTokens(_account);\n', '        if (locked == 0) mayHaveLockedTokens[_account] = false;\n', '        return balances[_account].sub(locked);\n', '    }\n', '\n', '    function pNumberOfLockedTokens(address _account) private view returns (uint locked) {\n', '        uint[LOCK_SLOTS] storage term = lockTerm[_account];\n', '        uint[LOCK_SLOTS] storage amnt = lockAmnt[_account];\n', '        for (uint i; i < LOCK_SLOTS; i++) {\n', '            if (term[i] >= now) locked = locked.add(amnt[i]);\n', '        }\n', '    }\n', '\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// WALLIcoDates\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract WALLIcoDates is Owned {\n', '\n', '    uint public dateMainStart = 1619859600; // 1-MAY-2021 09:00 GMT +0 \n', '    uint public dateMainEnd   = 1620464400; // 8-MAY-2021 09:00 GMT +0 \n', '\n', '    uint public constant DATE_LIMIT = 1620464400 + 180 days;\n', '\n', '    event IcoDateUpdated(uint id, uint unixts);\n', '\n', '    // check dates\n', '\n', '    modifier checkDateOrder {\n', '      _ ;\n', '      require ( dateMainStart < dateMainEnd ) ;\n', '      require ( dateMainEnd < DATE_LIMIT ) ;\n', '    }\n', '\n', '    constructor() public checkDateOrder() {\n', '        require(now < dateMainStart);\n', '    }\n', '\n', '    // set ico dates\n', '\n', '    function setDateMainStart(uint _unixts) public onlyOwner checkDateOrder {\n', '        require(now < _unixts && now < dateMainStart);\n', '        dateMainStart = _unixts;\n', '        emit IcoDateUpdated(1, _unixts);\n', '    }\n', '\n', '    function setDateMainEnd(uint _unixts) public onlyOwner checkDateOrder {\n', '        require(now < _unixts && now < dateMainEnd);\n', '        dateMainEnd = _unixts;\n', '        emit IcoDateUpdated(2, _unixts);\n', '    }\n', '\n', '    // where are we? Passed first day or not?\n', '\n', '    function isMainFirstDay() public view returns (bool) {\n', '        if (now > dateMainStart && now <= dateMainStart + 1 days) return true;\n', '        return false;\n', '    }\n', '\n', '    function isMain() public view returns (bool) {\n', '        if (now > dateMainStart && now < dateMainEnd) return true;\n', '        return false;\n', '    }\n', '\n', '}\n', '\n', '// ----------------------------------------------------------------------------\n', '//\n', '// WALL public token sale\n', '//\n', '// ----------------------------------------------------------------------------\n', '\n', 'contract WALLToken is ERC20Token, Wallet, LockSlots, WALLIcoDates {\n', '\n', '    // Utility variable\n', '\n', '    uint constant E18 = 10**18;\n', '\n', '    // Basic token data\n', '\n', '    string public constant name = "Wall Street Decentral Token";\n', '    string public constant symbol = "WALL";\n', '    uint8 public constant decimals = 18;\n', '\n', '    // Token number of possible tokens in existance 3333333333\n', '\n', '    uint public constant MAX_TOTAL_TOKEN_SUPPLY = 3333333333 * E18;\n', '\n', '\n', '    // ICO parameters\n', '    // Opening ETH Rate: USD$1827.28\n', '    // Therefore, 1 ETH = 45682 WALL\n', '\n', '\n', '    uint public tokensPerEth = 45682;\n', '\n', '    // USD$2,000,000/1827.28 = 1094.523006 ether\n', '    // 1094.523006 ether/2551 addresses = 0.429056450 ether per address for the first 24 hours\n', '    // 65,999,999,988 MainNet Coins / 19.79999999838 = 3,333,333,333 Tokens Total Supply \n', '    uint public constant MINIMUM_CONTRIBUTION = 0.2 ether;\n', '    uint public constant MAXIMUM_FIRST_DAY_CONTRIBUTION = 0.429056450 ether;\n', '\n', '    uint public constant TOKEN_MAIN_CAP = 50000000 * E18;\n', '\n', '    bool public tokensTradeable;\n', '\n', '    // whitelisting\n', '\n', '    mapping(address => bool) public whitelist;\n', '    uint public numberWhitelisted;\n', '\n', '    // track main sale\n', '\n', '    uint public tokensMain;\n', '    mapping(address => uint) public balancesMain;\n', '\n', '    uint public totalEthContributed;\n', '    mapping(address => uint) public ethContributed;\n', '\n', '    // tracking tokens minted\n', '\n', '    uint public tokensMinted;\n', '    mapping(address => uint) public balancesMinted;\n', '    mapping(address => mapping(uint => uint)) public balancesMintedByType;\n', '\n', '    // migration variable\n', '\n', '    bool public isMigrationPhaseOpen;\n', '\n', '    // Events ---------------------------------------------\n', '\n', '    event UpdatedTokensPerEth(uint tokensPerEth);\n', '    event Whitelisted(address indexed account, uint countWhitelisted);\n', '    event TokensMinted(uint indexed mintType, address indexed account, uint tokens, uint term);\n', '    event RegisterContribution(address indexed account, uint tokensIssued, uint ethContributed, uint ethReturned);\n', '    event TokenExchangeRequested(address indexed account, uint tokens);\n', '\n', '    // Basic Functions ------------------------------------\n', '\n', '    constructor() public {}\n', '\n', '    function () public payable {\n', '        buyTokens();\n', '    }\n', '\n', '    // Information functions\n', '\n', '\n', '    function availableToMint() public view returns (uint) {\n', '        return MAX_TOTAL_TOKEN_SUPPLY.sub(TOKEN_MAIN_CAP).sub(tokensMinted);\n', '    }\n', '\n', '    function firstDayTokenLimit() public view returns (uint) {\n', '        return ethToTokens(MAXIMUM_FIRST_DAY_CONTRIBUTION);\n', '    }\n', '\n', '    function ethToTokens(uint _eth) public view returns (uint tokens) {\n', '        tokens = _eth.mul(tokensPerEth);\n', '    }\n', '\n', '    function tokensToEth(uint _tokens) public view returns (uint eth) {\n', '        eth = _tokens / tokensPerEth;\n', '    }\n', '\n', '    // Admin functions\n', '\n', '    function addToWhitelist(address _account) public onlyAdmin {\n', '        pWhitelist(_account);\n', '    }\n', '\n', '    function addToWhitelistMultiple(address[] _addresses) public onlyAdmin {\n', '        for (uint i; i < _addresses.length; i++) {\n', '            pWhitelist(_addresses[i]);\n', '        }\n', '    }\n', '\n', '    function pWhitelist(address _account) internal {\n', '        if (whitelist[_account]) return;\n', '        whitelist[_account] = true;\n', '        numberWhitelisted = numberWhitelisted.add(1);\n', '        emit Whitelisted(_account, numberWhitelisted);\n', '    }\n', '\n', '    // Owner functions ------------------------------------\n', '\n', '    function updateTokensPerEth(uint _tokens_per_eth) public onlyOwner {\n', '        require(now < dateMainStart);\n', '        tokensPerEth = _tokens_per_eth;\n', '        emit UpdatedTokensPerEth(tokensPerEth);\n', '    }\n', '\n', '    // Only owner can make tokens tradable at any time, or if the date is\n', '    // greater than the end of the mainsale date plus 20 weeks, allow\n', '    // any caller to make tokensTradeable.\n', '\n', '    function makeTradeable() public {\n', '        require(msg.sender == owner || now > dateMainEnd + 20 weeks);\n', '        tokensTradeable = true;\n', '    }\n', '\n', '    function openMigrationPhase() public onlyOwner {\n', '        require(now > dateMainEnd);\n', '        isMigrationPhaseOpen = true;\n', '    }\n', '\n', '    // Token minting --------------------------------------\n', '\n', '    function mintTokens(uint _mint_type, address _account, uint _tokens) public onlyOwner {\n', '        pMintTokens(_mint_type, _account, _tokens, 0);\n', '    }\n', '\n', '    function mintTokensMultiple(uint _mint_type, address[] _accounts, uint[] _tokens) public onlyOwner {\n', '        require(_accounts.length == _tokens.length);\n', '        for (uint i; i < _accounts.length; i++) {\n', '            pMintTokens(_mint_type, _accounts[i], _tokens[i], 0);\n', '        }\n', '    }\n', '\n', '    function mintTokensLocked(uint _mint_type, address _account, uint _tokens, uint _term) public onlyOwner {\n', '        pMintTokens(_mint_type, _account, _tokens, _term);\n', '    }\n', '\n', '    function mintTokensLockedMultiple(uint _mint_type, address[] _accounts, uint[] _tokens, uint[] _terms) public onlyOwner {\n', '        require(_accounts.length == _tokens.length);\n', '        require(_accounts.length == _terms.length);\n', '        for (uint i; i < _accounts.length; i++) {\n', '            pMintTokens(_mint_type, _accounts[i], _tokens[i], _terms[i]);\n', '        }\n', '    }\n', '\n', '    function pMintTokens(uint _mint_type, address _account, uint _tokens, uint _term) private {\n', '        require(whitelist[_account]);\n', '        require(_account != 0x0);\n', '        require(_tokens > 0);\n', '        require(_tokens <= availableToMint(), "not enough tokens available to mint");\n', '        require(_term == 0 || _term > now, "either without lock term, or lock term must be in the future");\n', '\n', '        // register locked tokens (will throw if no slot is found)\n', '        if (_term > 0) registerLockedTokens(_account, _tokens, _term);\n', '\n', '        // update\n', '        balances[_account] = balances[_account].add(_tokens);\n', '        balancesMinted[_account] = balancesMinted[_account].add(_tokens);\n', '        balancesMintedByType[_account][_mint_type] = balancesMintedByType[_account][_mint_type].add(_tokens);\n', '        tokensMinted = tokensMinted.add(_tokens);\n', '        tokensIssuedTotal = tokensIssuedTotal.add(_tokens);\n', '\n', '        // log event\n', '        emit Transfer(0x0, _account, _tokens);\n', '        emit TokensMinted(_mint_type, _account, _tokens, _term);\n', '    }\n', '\n', '    // Main sale ------------------------------------------\n', '\n', '    function buyTokens() private {\n', '\n', '        require(isMain());\n', '        require(msg.value >= MINIMUM_CONTRIBUTION);\n', '        require(whitelist[msg.sender]);\n', '\n', '        uint tokens_available = TOKEN_MAIN_CAP.sub(tokensMain);\n', '\n', '        // adjust tokens_available on first day, if necessary\n', '        if (isMainFirstDay()) {\n', '            uint tokens_available_first_day = firstDayTokenLimit().sub(balancesMain[msg.sender]);\n', '            if (tokens_available_first_day < tokens_available) {\n', '                tokens_available = tokens_available_first_day;\n', '            }\n', '        }\n', '\n', '        require (tokens_available > 0);\n', '\n', '        uint tokens_requested = ethToTokens(msg.value);\n', '        uint tokens_issued = tokens_requested;\n', '\n', '        uint eth_contributed = msg.value;\n', '        uint eth_returned;\n', '\n', '        if (tokens_requested > tokens_available) {\n', '            tokens_issued = tokens_available;\n', '            eth_returned = tokensToEth(tokens_requested.sub(tokens_available));\n', '            eth_contributed = msg.value.sub(eth_returned);\n', '        }\n', '\n', '        balances[msg.sender] = balances[msg.sender].add(tokens_issued);\n', '        balancesMain[msg.sender] = balancesMain[msg.sender].add(tokens_issued);\n', '        tokensMain = tokensMain.add(tokens_issued);\n', '        tokensIssuedTotal = tokensIssuedTotal.add(tokens_issued);\n', '\n', '        ethContributed[msg.sender] = ethContributed[msg.sender].add(eth_contributed);\n', '        totalEthContributed = totalEthContributed.add(eth_contributed);\n', '\n', '        // ether transfers\n', '        if (eth_returned > 0) msg.sender.transfer(eth_returned);\n', '        wallet.transfer(eth_contributed);\n', '\n', '        // log\n', '        emit Transfer(0x0, msg.sender, tokens_issued);\n', '        emit RegisterContribution(msg.sender, tokens_issued, eth_contributed, eth_returned);\n', '    }\n', '\n', '    // Token exchange / migration to new platform ---------\n', '\n', '    function requestTokenExchangeMax() public {\n', '        requestTokenExchange(unlockedTokensInternal(msg.sender));\n', '    }\n', '\n', '    function requestTokenExchange(uint _tokens) public {\n', '        require(isMigrationPhaseOpen);\n', '        require(_tokens > 0 && _tokens <= unlockedTokensInternal(msg.sender));\n', '        balances[msg.sender] = balances[msg.sender].sub(_tokens);\n', '        tokensIssuedTotal = tokensIssuedTotal.sub(_tokens);\n', '        emit Transfer(msg.sender, 0x0, _tokens);\n', '        emit TokenExchangeRequested(msg.sender, _tokens);\n', '    }\n', '\n', '    // ERC20 functions -------------------\n', '\n', '    /* Transfer out any accidentally sent ERC20 tokens */\n', '\n', '    function transferAnyERC20Token(address _token_address, uint _amount) public onlyOwner returns (bool success) {\n', '        return ERC20Interface(_token_address).transfer(owner, _amount);\n', '    }\n', '\n', '    /* Override "transfer" */\n', '\n', '    function transfer(address _to, uint _amount) public returns (bool success) {\n', '        require(tokensTradeable);\n', '        require(_amount <= unlockedTokensInternal(msg.sender));\n', '        return super.transfer(_to, _amount);\n', '    }\n', '\n', '    /* Override "transferFrom" */\n', '\n', '    function transferFrom(address _from, address _to, uint _amount) public returns (bool success) {\n', '        require(tokensTradeable);\n', '        require(_amount <= unlockedTokensInternal(_from));\n', '        return super.transferFrom(_from, _to, _amount);\n', '    }\n', '\n', '    /* Multiple token transfers from one address to save gas */\n', '\n', '    function transferMultiple(address[] _addresses, uint[] _amounts) external {\n', '        require(_addresses.length <= 100);\n', '        require(_addresses.length == _amounts.length);\n', '\n', '        // do the transfers\n', '        for (uint j; j < _addresses.length; j++) {\n', '            transfer(_addresses[j], _amounts[j]);\n', '        }\n', '\n', '    }\n', '\n', '}']