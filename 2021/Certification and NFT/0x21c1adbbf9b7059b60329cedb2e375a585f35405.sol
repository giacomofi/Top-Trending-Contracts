['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-20\n', '*/\n', '\n', '/*\n', '  The shared configuration for tidal and riptide sibling tokens\n', '  riptide.finance\n', '\n', '  @nightg0at\n', '  SPDX-License-Identifier: MIT\n', '*/\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/introspection/IERC165.sol\n', '\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC1155/IERC1155.sol\n', '\n', '\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Required interface of an ERC1155 compliant contract, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n', ' *\n', ' * _Available since v3.1._\n', ' */\n', 'interface IERC1155 is IERC165 {\n', '    /**\n', '     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n', '     */\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    /**\n', '     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n', '     * transfers.\n', '     */\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    /**\n', '     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n', '     * `approved`.\n', '     */\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    /**\n', '     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n', '     *\n', '     * If an {URI} event was emitted for `id`, the standard\n', '     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n', '     * returned by {IERC1155MetadataURI-uri}.\n', '     */\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `account` cannot be the zero address.\n', '     */\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `accounts` and `ids` must have the same length.\n', '     */\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    /**\n', "     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n", '     *\n', '     * Emits an {ApprovalForAll} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `operator` cannot be the caller.\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    /**\n', "     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n", '     *\n', '     * See {setApprovalForAll}.\n', '     */\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    /**\n', '     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n', '     *\n', '     * Emits a {TransferSingle} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `to` cannot be the zero address.\n', "     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n", '     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    /**\n', '     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n', '     *\n', '     * Emits a {TransferBatch} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `ids` and `amounts` must have the same length.\n', '     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n', '     * acceptance magic value.\n', '     */\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/introspection/IERC1820Registry.sol\n', '\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the global ERC1820 Registry, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\n', ' * implementers for interfaces in this registry, as well as query support.\n', ' *\n', ' * Implementers may be shared by multiple accounts, and can also implement more\n', ' * than a single interface for each account. Contracts can implement interfaces\n', ' * for themselves, but externally-owned accounts (EOA) must delegate this to a\n', ' * contract.\n', ' *\n', ' * {IERC165} interfaces can also be queried via the registry.\n', ' *\n', ' * For an in-depth explanation and source code analysis, see the EIP text.\n', ' */\n', 'interface IERC1820Registry {\n', '    /**\n', '     * @dev Sets `newManager` as the manager for `account`. A manager of an\n', '     * account is able to set interface implementers for it.\n', '     *\n', '     * By default, each account is its own manager. Passing a value of `0x0` in\n', '     * `newManager` will reset the manager to this initial state.\n', '     *\n', '     * Emits a {ManagerChanged} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     */\n', '    function setManager(address account, address newManager) external;\n', '\n', '    /**\n', '     * @dev Returns the manager for `account`.\n', '     *\n', '     * See {setManager}.\n', '     */\n', '    function getManager(address account) external view returns (address);\n', '\n', '    /**\n', "     * @dev Sets the `implementer` contract as ``account``'s implementer for\n", '     * `interfaceHash`.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     * The zero address can also be used in `implementer` to remove an old one.\n', '     *\n', '     * See {interfaceHash} to learn how these are created.\n', '     *\n', '     * Emits an {InterfaceImplementerSet} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the caller must be the current manager for `account`.\n', '     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\n', '     * end in 28 zeroes).\n', '     * - `implementer` must implement {IERC1820Implementer} and return true when\n', '     * queried for support, unless `implementer` is the caller. See\n', '     * {IERC1820Implementer-canImplementInterfaceForAddress}.\n', '     */\n', '    function setInterfaceImplementer(address account, bytes32 _interfaceHash, address implementer) external;\n', '\n', '    /**\n', '     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\n', '     * implementer is registered, returns the zero address.\n', '     *\n', '     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\n', '     * zeroes), `account` will be queried for support of it.\n', '     *\n', "     * `account` being the zero address is an alias for the caller's address.\n", '     */\n', '    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\n', '\n', '    /**\n', '     * @dev Returns the interface hash for an `interfaceName`, as defined in the\n', '     * corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\n', '     */\n', '    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\n', '\n', '    /**\n', '     *  @notice Updates the cache with whether the contract implements an ERC165 interface or not.\n', '     *  @param account Address of the contract for which to update the cache.\n', '     *  @param interfaceId ERC165 interface for which to update the cache.\n', '     */\n', '    function updateERC165Cache(address account, bytes4 interfaceId) external;\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not.\n', '     *  If the result is not cached a direct lookup on the contract address is performed.\n', '     *  If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\n', '     *  {updateERC165Cache} with the contract address.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    /**\n', '     *  @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\n', '     *  @param account Address of the contract to check.\n', '     *  @param interfaceId ERC165 interface to check.\n', '     *  @return True if `account` implements `interfaceId`, false otherwise.\n', '     */\n', '    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\n', '\n', '    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\n', '\n', '    event ManagerChanged(address indexed account, address indexed newManager);\n', '}\n', '\n', '// File: @uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\n', '\n', 'pragma solidity >=0.5.0;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/access/Ownable.sol\n', '\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: contracts/Whitelist.sol\n', '\n', '/*\n', "  Exemption whitelists and convenience methods for Tidal's punitive mechanisms\n", '\n', '  @nightg0at\n', '*/\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract Whitelist is Ownable {\n', '\n', '  // protectors can be ERC20, ERC777 or ERC1155 tokens\n', '  // ERC115 tokens have a different balanceOf() method, so we use the ERC1820 registry to identify the ERC1155 interface\n', '  IERC1820Registry private erc1820Registry; // 0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24\n', '  bytes4 private constant ERC1155_INTERFACE_ID = 0xd9b67a26;\n', '\n', '  // used to identify if an address is likely to be a uniswap pair\n', '  address private constant UNISWAP_FACTORY = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f;\n', '\n', '  // tokens that offer the holder some kind of protection\n', '  struct TokenAttributes {\n', '    bool active;\n', '    uint256 proportion; // proportion of incoming tokens used as burn amount (typically 1 or 0.5)\n', '    uint256 floor; // the lowest the balance can be after a wipeout event\n', '  }\n', '\n', '  struct TokenID {\n', '    address addr;\n', '    uint256 id; // for IERC1155 tokens else 0\n', '  }\n', '\n', '  // addresses that have some kind of protection as if they are holding protective tokens\n', '  struct AddressAttributes {\n', '    bool active;\n', '    uint256 proportion;\n', '    uint256 floor;\n', '  }\n', '\n', '  // addresses that do not incur punitive burns or wipeouts as senders or receivers\n', '  struct WhitelistAttributes {\n', '    bool active;\n', '    bool sendBurn;\n', '    bool receiveBurn;\n', '    bool sendWipeout;\n', '    bool receiveWipeout;\n', '  }\n', '\n', '  uint256 public defaultProportion = 1e18;\n', '  uint256 public defaultFloor = 0;\n', '\n', '  constructor(\n', '    IERC1820Registry _erc1820Registry\n', '  ) public {\n', '    erc1820Registry = _erc1820Registry;\n', '    \n', '    // premine our starting protectors. Surfboards and trident NFTs\n', '    addProtector(0xf90AeeF57Ae8Bc85FE8d40a3f4a45042F4258c67, 0, 5e17, 0); // surfboard, 0.5x, 0 floor\n', '    addProtector(0xd07dc4262BCDbf85190C01c996b4C06a461d2430, 78947, 1e18, 2496e14); // bronze trident , 1x, 0.2496 floor\n', '    addProtector(0xd07dc4262BCDbf85190C01c996b4C06a461d2430, 78955, 1e18, 42e16); // silver trident, 1x, 0.42 floor\n', '    addProtector(0xd07dc4262BCDbf85190C01c996b4C06a461d2430, 78963, 1e18, 69e16); // gold trident, 1x, 0.69 floor\n', '\n', '  }\n', '\n', '  mapping (address => AddressAttributes) public protectedAddress;\n', '  TokenID[] public protectors;\n', '  mapping (address => mapping (uint256 => TokenAttributes)) public protectorAttributes;\n', '  mapping (address => WhitelistAttributes) public whitelist;\n', '  \n', '\n', '  function addProtector(address _token, uint256 _id, uint256 _proportion, uint256 _floor) public onlyOwner {\n', '    uint256 id = isERC1155(_token) ? _id : 0;\n', '    require(protectorAttributes[_token][id].active == false, "WIPEOUT::addProtector: Token already active");\n', '    editProtector(_token, true, id, _proportion, _floor);\n', '    protectors.push(TokenID(_token, id));\n', '  }\n', '\n', '  function editProtector(address _token, bool _active, uint256 _id, uint256 _proportion, uint256 _floor) public onlyOwner {\n', '    protectorAttributes[_token][_id] = TokenAttributes(_active, _proportion, _floor);\n', '  }\n', '\n', '  function protectorLength() external view returns (uint256) {\n', '    return protectors.length;\n', '  }\n', '\n', '  function getProtectorAttributes(address _addr, uint256 _id) external view returns (bool, uint256, uint256) {\n', '    return (\n', '      protectorAttributes[_addr][_id].active,\n', '      protectorAttributes[_addr][_id].proportion,\n', '      protectorAttributes[_addr][_id].floor\n', '    );\n', '  }\n', '\n', '\n', '  function isERC1155(address _token) private view returns (bool) {\n', '    return erc1820Registry.implementsERC165Interface(_token, ERC1155_INTERFACE_ID);\n', '  }\n', '\n', '  function hasProtector(address _addr, address _protector, uint256 _id) public view returns (bool) {\n', '    bool has = false;\n', '    if (isERC1155(_protector)) {\n', '      if (IERC1155(_protector).balanceOf(_addr, _id) > 0) {\n', '        has = true;\n', '      }\n', '    } else {\n', '      if (IERC20(_protector).balanceOf(_addr) > 0) {\n', '        has = true;\n', '      }\n', '    }\n', '    return has;\n', '  }\n', '\n', '  function cumulativeProtectionOf(address _addr) external view returns (uint256, uint256) {\n', '    uint256 proportion = defaultProportion;\n', '    uint256 floor = defaultFloor;\n', '    for (uint256 i=0; i<protectors.length; i++) {\n', '      address protector = protectors[i].addr;\n', '      uint256 id = protectors[i].id;\n', '      if (hasProtector(_addr, protector, id)) {\n', '        if (proportion > protectorAttributes[protector][id].proportion) {\n', '          proportion = protectorAttributes[protector][id].proportion;\n', '        }\n', '        if (floor < protectorAttributes[protector][id].floor) {\n', '          floor = protectorAttributes[protector][id].floor;\n', '        }\n', '      }\n', '    }\n', '    return (proportion, floor);\n', '  }\n', '\n', '  function setProtectedAddress(address _addr, bool _active, uint256 _proportion, uint256 _floor) public onlyOwner {\n', '    require(_addr != address(0), "WIPEOUT::setProtector: zero address");\n', '    protectedAddress[_addr] = AddressAttributes(_active, _proportion, _floor);\n', '  }\n', '\n', '  function getProtectedAddress(address _addr) external view returns (bool, uint256, uint256) {\n', '    return (\n', '      protectedAddress[_addr].active,\n', '      protectedAddress[_addr].proportion,\n', '      protectedAddress[_addr].floor\n', '    );\n', '  }\n', '\n', '  function setWhitelist(\n', '    address _whitelisted,\n', '    bool _active,\n', '    bool _sendBurn,\n', '    bool _receiveBurn,\n', '    bool _sendWipeout,\n', '    bool _receiveWipeout\n', '  ) public onlyOwner {\n', '    require(_whitelisted != address(0), "WIPEOUT::setWhitelist: zero address");\n', '    whitelist[_whitelisted] = WhitelistAttributes(_active, _sendBurn, _receiveBurn, _sendWipeout, _receiveWipeout);\n', '  }\n', '\n', '  function getWhitelist(address _addr) external view returns (bool, bool, bool, bool, bool) {\n', '    return (\n', '      whitelist[_addr].active,\n', '      whitelist[_addr].sendBurn,\n', '      whitelist[_addr].receiveBurn,\n', '      whitelist[_addr].sendWipeout,\n', '      whitelist[_addr].receiveWipeout\n', '    );\n', '  }\n', '\n', '  // checks if the address is a deployed contract and if so,\n', '  // checks if the factory() method is present and returns the uniswap factory address.\n', '  // returns true if it is.\n', '  // This is easy to spoof but the gains are low enough for this to be ok.\n', '  function isUniswapTokenPair(address _addr) public view returns (bool) {\n', '    uint32 size;\n', '    assembly {\n', '      size := extcodesize(_addr)\n', '    }\n', '    if (size == 0) {\n', '      return false;\n', '    } else {\n', '      try IUniswapV2Pair(_addr).factory() returns (address _factory) {\n', '        return _factory == UNISWAP_FACTORY ? true : false;\n', '      } catch {\n', '        return false;\n', '      }\n', '    }\n', '  }\n', '\n', '  function isUniswapTokenPairWith(address _pair, address _token) public view returns (bool) {\n', '    return (IUniswapV2Pair(_pair).token0() == _token || IUniswapV2Pair(_pair).token1() == _token);\n', '  }\n', '\n', '  function willBurn(address _sender, address _recipient) public view returns (bool) {\n', '    // returns true if everything is false\n', '    return !(whitelist[_sender].sendBurn || whitelist[_recipient].receiveBurn);\n', '  }\n', '\n', '  function willWipeout(address _sender, address _recipient) public view returns (bool) {\n', '    bool whitelisted = whitelist[_sender].sendWipeout || isUniswapTokenPair(_sender);\n', '    whitelisted = whitelisted || whitelist[_recipient].receiveWipeout;\n', '    // returns true if everything is false\n', '    return !whitelisted;\n', '  }\n', '\n', '}\n', '\n', '// File: contracts/interfaces/ITideToken.sol\n', '\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '\n', 'interface ITideToken is IERC20 {\n', '  function owner() external view returns (address);\n', '  function mint(address _to, uint256 _amount) external;\n', '  function setParent(address _newConfig) external;\n', '  function wipeout(address _recipient, uint256 _amount) external;\n', '}\n', '\n', '// File: contracts/TideParent.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'contract TideParent is Whitelist {\n', '\n', '  address private _poseidon;\n', '  address[2] public siblings; //0: tidal, 1: riptide\n', '\n', '  uint256 private _burnRate = 69e15; //6.9%, 0.069\n', '  uint256 private _transmuteRate = 42e14; //0.42%, 0.0042\n', '\n', '  constructor(\n', '    IERC1820Registry _erc1820Registry\n', '  ) public Whitelist(_erc1820Registry) {}\n', '\n', '  function setPoseidon(address _newPoseidon) public onlyOwner {\n', '    if (whitelist[_poseidon].active) {\n', '      setWhitelist(_poseidon, false, false, false, false, false);\n', '    }\n', '    if (protectedAddress[_poseidon].active) {\n', '      setProtectedAddress(_poseidon, false, 0, 0);\n', '    }\n', '    setProtectedAddress(_newPoseidon, true, 5e17, 69e16);\n', '    setWhitelist(_newPoseidon, true, true, false, true, false);\n', '    _poseidon = _newPoseidon;\n', '  }\n', '\n', '  function setSibling(uint256 _index, address _token) public onlyOwner {\n', '    require(_token != address(0), "TIDEPARENT::setToken: zero address");\n', '    siblings[_index] = _token;\n', '  }\n', '\n', '  function setAddresses(address _siblingA, address _siblingB, address _newPoseidon) external onlyOwner {\n', '    setSibling(0, _siblingA);\n', '    setSibling(1, _siblingB);\n', '    setPoseidon(_newPoseidon);\n', '  }\n', '\n', '  function setBurnRate(uint256 _newBurnRate) external onlyOwner {\n', '    require(_newBurnRate <= 2e17, "TIDEPARENT:setBurnRate: 20% max");\n', '    _burnRate = _newBurnRate;\n', '  }\n', '\n', '  function setTransmuteRate(uint256 _newTransmuteRate) external onlyOwner {\n', '    require(_newTransmuteRate <= 1e17, "TIDEPARENT:setTransmuteRate: 10% max");\n', '    _transmuteRate = _newTransmuteRate;\n', '  }\n', '\n', '  function setNewParent(address _newConfig) external onlyOwner {\n', '    ITideToken(siblings[0]).setParent(_newConfig);\n', '    ITideToken(siblings[1]).setParent(_newConfig);\n', '  }\n', '\n', '  function poseidon() public view returns (address) {\n', '    return _poseidon;\n', '  }\n', '\n', '  function burnRate() public view returns (uint256) {\n', '    return _burnRate;\n', '  }\n', '\n', '  function transmuteRate() public view returns (uint256) {\n', '    return _transmuteRate;\n', '  }\n', '\n', '  function sibling(address _siblingCandidate) public view returns (address) {\n', '    if (_siblingCandidate == siblings[0]) {\n', '      return siblings[1];\n', '    } else if (_siblingCandidate == siblings[1]) {\n', '      return siblings[0];\n', '    } else {\n', '      return address(0);\n', '    }\n', '  }\n', '}']