['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-27\n', '*/\n', '\n', '/*\n', 'https://powerpool.finance/\n', '\n', '          wrrrw r wrr\n', '         ppwr rrr wppr0       prwwwrp                                 prwwwrp                   wr0\n', '        rr 0rrrwrrprpwp0      pp   pr  prrrr0 pp   0r  prrrr0  0rwrrr pp   pr  prrrr0  prrrr0    r0\n', '        rrp pr   wr00rrp      prwww0  pp   wr pp w00r prwwwpr  0rw    prwww0  pp   wr pp   wr    r0\n', '        r0rprprwrrrp pr0      pp      wr   pr pp rwwr wr       0r     pp      wr   pr wr   pr    r0\n', '         prwr wrr0wpwr        00        www0   0w0ww    www0   0w     00        www0    www0   0www0\n', '          wrr ww0rrrr\n', '\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', '// File: contracts/utils/SafeMath.sol\n', '\n', '// From\n', '// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/ccf79ee483b12fb9759dc5bb5f947a31aa0a3bd6/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Context.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '    function _msgSender() internal view virtual returns (address payable) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes memory) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/access/Ownable.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    constructor () internal {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Leaves the contract without owner. It will not be possible to call\n', '     * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '     *\n', '     * NOTE: Renouncing ownership will leave the contract without an owner,\n', '     * thereby removing any functionality that is only available to the owner.\n', '     */\n', '    function renounceOwnership() public virtual onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '     * Can only be called by the current owner.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/SafeCast.sol\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n", ' * checks.\n', ' *\n', ' * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n', ' * easily result in undesired exploitation or bugs, since developers usually\n', ' * assume that overflows raise errors. `SafeCast` restores this intuition by\n', ' * reverting the transaction when such an operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' *\n', ' * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n', ' * all math on `uint256` and `int256` and then downcasting.\n', ' */\n', 'library SafeCast {\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint128 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint128).\n', '     *\n', "     * Counterpart to Solidity's `uint128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     */\n', '    function toUint128(uint256 value) internal pure returns (uint128) {\n', '        require(value < 2**128, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return uint128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint64 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint64).\n', '     *\n', "     * Counterpart to Solidity's `uint64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     */\n', '    function toUint64(uint256 value) internal pure returns (uint64) {\n', '        require(value < 2**64, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return uint64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint32 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint32).\n', '     *\n', "     * Counterpart to Solidity's `uint32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     */\n', '    function toUint32(uint256 value) internal pure returns (uint32) {\n', '        require(value < 2**32, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return uint32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint16 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint16).\n', '     *\n', "     * Counterpart to Solidity's `uint16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     */\n', '    function toUint16(uint256 value) internal pure returns (uint16) {\n', '        require(value < 2**16, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return uint16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted uint8 from uint256, reverting on\n', '     * overflow (when the input is greater than largest uint8).\n', '     *\n', "     * Counterpart to Solidity's `uint8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     */\n', '    function toUint8(uint256 value) internal pure returns (uint8) {\n', '        require(value < 2**8, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return uint8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts a signed int256 into an unsigned uint256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be greater than or equal to 0.\n', '     */\n', '    function toUint256(int256 value) internal pure returns (uint256) {\n', '        require(value >= 0, "SafeCast: value must be positive");\n', '        return uint256(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int128 from int256, reverting on\n', '     * overflow (when the input is less than smallest int128 or\n', '     * greater than largest int128).\n', '     *\n', "     * Counterpart to Solidity's `int128` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 128 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt128(int256 value) internal pure returns (int128) {\n', '        require(value >= -2**127 && value < 2**127, "SafeCast: value doesn\\\'t fit in 128 bits");\n', '        return int128(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int64 from int256, reverting on\n', '     * overflow (when the input is less than smallest int64 or\n', '     * greater than largest int64).\n', '     *\n', "     * Counterpart to Solidity's `int64` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 64 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt64(int256 value) internal pure returns (int64) {\n', '        require(value >= -2**63 && value < 2**63, "SafeCast: value doesn\\\'t fit in 64 bits");\n', '        return int64(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int32 from int256, reverting on\n', '     * overflow (when the input is less than smallest int32 or\n', '     * greater than largest int32).\n', '     *\n', "     * Counterpart to Solidity's `int32` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 32 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt32(int256 value) internal pure returns (int32) {\n', '        require(value >= -2**31 && value < 2**31, "SafeCast: value doesn\\\'t fit in 32 bits");\n', '        return int32(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int16 from int256, reverting on\n', '     * overflow (when the input is less than smallest int16 or\n', '     * greater than largest int16).\n', '     *\n', "     * Counterpart to Solidity's `int16` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 16 bits\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt16(int256 value) internal pure returns (int16) {\n', '        require(value >= -2**15 && value < 2**15, "SafeCast: value doesn\\\'t fit in 16 bits");\n', '        return int16(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the downcasted int8 from int256, reverting on\n', '     * overflow (when the input is less than smallest int8 or\n', '     * greater than largest int8).\n', '     *\n', "     * Counterpart to Solidity's `int8` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - input must fit into 8 bits.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function toInt8(int256 value) internal pure returns (int8) {\n', '        require(value >= -2**7 && value < 2**7, "SafeCast: value doesn\\\'t fit in 8 bits");\n', '        return int8(value);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an unsigned uint256 into a signed int256.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - input must be less than or equal to maxInt256.\n', '     */\n', '    function toInt256(uint256 value) internal pure returns (int256) {\n', '        require(value < 2**255, "SafeCast: value doesn\'t fit in an int256");\n', '        return int256(value);\n', '    }\n', '}\n', '\n', '// File: contracts/PPTimedVesting.sol\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  function transfer(address _to, uint256 _amount) external returns (bool);\n', '}\n', '\n', 'interface CvpInterface {\n', '  function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n', '}\n', '\n', '/**\n', ' * @title PowerPool Vesting Contract\n', ' * @author PowerPool\n', ' */\n', 'contract PPTimedVesting is CvpInterface, Ownable {\n', '  using SafeMath for uint256;\n', '  using SafeCast for uint256;\n', '\n', '  // @notice Emitted when a member is disabled either by the owner or the by the member itself\n', '  event DisableMember(address indexed member, uint256 tokensRemainder);\n', '\n', '  // @notice Emitted once when the contract was deployed\n', '  event Init(address[] members);\n', '\n', '  // @notice Emitted when the owner increases durationT correspondingly increasing the endT timestamp\n', '  event IncreaseDurationT(uint256 prevDurationT, uint256 prevEndT, uint256 newDurationT, uint256 newEndT);\n', '\n', '  // @notice Emitted when the owner increases personalDurationT correspondingly increasing the personalEndT timestamp\n', '  event IncreasePersonalDurationT(\n', '    address indexed member,\n', '    uint256 prevEvaluatedDurationT,\n', '    uint256 prevEvaluatedEndT,\n', '    uint256 prevPersonalDurationT,\n', '    uint256 newPersonalDurationT,\n', '    uint256 newPersonalEndT\n', '  );\n', '\n', '  // @notice Emitted when a member delegates his votes to one of the delegates or to himself\n', '  event DelegateVotes(address indexed from, address indexed to, address indexed previousDelegate, uint96 adjustedVotes);\n', '\n', '  // @notice Emitted when a member transfer his permission\n', '  event Transfer(\n', '    address indexed from,\n', '    address indexed to,\n', '    uint96 alreadyClaimedVotes,\n', '    uint96 alreadyClaimedTokens,\n', '    address currentDelegate\n', '  );\n', '\n', '  /// @notice Emitted when a member claims available votes\n', '  event ClaimVotes(\n', '    address indexed member,\n', '    address indexed delegate,\n', '    uint96 lastAlreadyClaimedVotes,\n', '    uint96 lastAlreadyClaimedTokens,\n', '    uint96 newAlreadyClaimedVotes,\n', '    uint96 newAlreadyClaimedTokens,\n', '    uint96 lastMemberAdjustedVotes,\n', '    uint96 adjustedVotes,\n', '    uint96 diff\n', '  );\n', '\n', '  /// @notice Emitted when a member claims available tokens\n', '  event ClaimTokens(\n', '    address indexed member,\n', '    address indexed to,\n', '    uint96 amount,\n', '    uint256 newAlreadyClaimed,\n', '    uint256 votesAvailable\n', '  );\n', '\n', '  /// @notice A Emitted when a member unclaimed balance changes\n', '  event UnclaimedBalanceChanged(address indexed member, uint256 previousUnclaimed, uint256 newUnclaimed);\n', '\n', '  /// @notice A member statuses and unclaimed balance tracker\n', '  struct Member {\n', '    bool active;\n', '    bool transferred;\n', '    uint32 personalDurationT;\n', '    uint96 alreadyClaimedVotes;\n', '    uint96 alreadyClaimedTokens;\n', '  }\n', '\n', '  /// @notice A checkpoint for marking number of votes from a given block\n', '  struct Checkpoint {\n', '    uint32 fromBlock;\n', '    uint96 votes;\n', '  }\n', '\n', '  /// @notice ERC20 token address\n', '  address public immutable token;\n', '\n', '  /// @notice Start timestamp for vote vesting calculations\n', '  uint256 public immutable startV;\n', '\n', '  /// @notice Duration of the vote vesting in seconds\n', '  uint256 public immutable durationV;\n', '\n', '  /// @notice End vote vesting timestamp\n', '  uint256 public immutable endV;\n', '\n', '  /// @notice Start timestamp for token vesting calculations\n', '  uint256 public immutable startT;\n', '\n', '  /// @notice Number of the vesting contract members, used only from UI\n', '  uint256 public memberCount;\n', '\n', '  /// @notice Amount of ERC20 tokens to distribute during the vesting period\n', '  uint96 public immutable amountPerMember;\n', '\n', '  /// @notice Duration of the token vesting in seconds\n', '  uint256 public durationT;\n', '\n', '  /// @notice End token timestamp, used only from UI\n', '  uint256 public endT;\n', '\n', '  /// @notice Member details by their address\n', '  mapping(address => Member) public members;\n', '\n', '  /// @notice A record of vote checkpoints for each member, by index\n', '  mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n', '\n', '  /// @notice The number of checkpoints for each member\n', '  mapping(address => uint32) public numCheckpoints;\n', '\n', '  /// @notice Vote delegations\n', '  mapping(address => address) public voteDelegations;\n', '\n', '  /**\n', '   * @notice Constructs a new vesting contract\n', "   * @dev It's up to a deployer to allocate the correct amount of ERC20 tokens on this contract\n", '   * @param _tokenAddress The ERC20 token address to use with this vesting contract\n', '   * @param _startV The timestamp when the vote vesting period starts\n', '   * @param _durationV The duration in second the vote vesting period should last\n', '   * @param _startT The timestamp when the token vesting period starts\n', '   * @param _durationT The duration in seconds the token vesting period should last\n', '   * @param _amountPerMember The number of tokens to distribute to each vesting contract member\n', '   */\n', '  constructor(\n', '    address _tokenAddress,\n', '    uint256 _startV,\n', '    uint256 _durationV,\n', '    uint256 _startT,\n', '    uint256 _durationT,\n', '    uint96 _amountPerMember\n', '  ) public {\n', '    require(_durationV > 1, "Vesting: Invalid durationV");\n', '    require(_durationT > 1, "Vesting: Invalid durationT");\n', '    require(_startV < _startT, "Vesting: Requires startV < startT");\n', '    // require((_startV + _durationV) <= (_startT + _durationT), "Vesting: Requires endV <= endT");\n', '    require((_startV.add(_durationV)) <= (_startT.add(_durationT)), "Vesting: Requires endV <= endT");\n', '    require(_amountPerMember > 0, "Vesting: Invalid amount per member");\n', '    require(IERC20(_tokenAddress).totalSupply() > 0, "Vesting: Missing supply of the token");\n', '\n', '    token = _tokenAddress;\n', '\n', '    startV = _startV;\n', '    durationV = _durationV;\n', '    endV = _startV + _durationV;\n', '\n', '    startT = _startT;\n', '    durationT = _durationT;\n', '    endT = _startT + _durationT;\n', '\n', '    amountPerMember = _amountPerMember;\n', '  }\n', '\n', '  /**\n', '   * @notice Initialize members of vesting\n', '   * @param _memberList The list of addresses to distribute tokens to\n', '   */\n', '  function initializeMembers(address[] calldata _memberList) external onlyOwner {\n', '    require(memberCount == 0, "Vesting: Already initialized");\n', '\n', '    uint256 len = _memberList.length;\n', '    require(len > 0, "Vesting: Empty member list");\n', '\n', '    memberCount = len;\n', '\n', '    for (uint256 i = 0; i < len; i++) {\n', '      members[_memberList[i]].active = true;\n', '    }\n', '\n', '    emit Init(_memberList);\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether the vote vesting period has started or not\n', '   * @return true If the vote vesting period has started\n', '   */\n', '  function hasVoteVestingStarted() external view returns (bool) {\n', '    return block.timestamp >= startV;\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether the vote vesting period has ended or not\n', '   * @return true If the vote vesting period has ended\n', '   */\n', '  function hasVoteVestingEnded() external view returns (bool) {\n', '    return block.timestamp >= endV;\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether the token vesting period has started or not\n', '   * @return true If the token vesting period has started\n', '   */\n', '  function hasTokenVestingStarted() external view returns (bool) {\n', '    return block.timestamp >= startT;\n', '  }\n', '\n', '  /**\n', '   * @notice Checks whether the token vesting period has ended or not\n', '   * @return true If the token vesting period has ended\n', '   */\n', '  function hasTokenVestingEnded() external view returns (bool) {\n', '    return block.timestamp >= endT;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns the address a _voteHolder delegated their votes to\n', '   * @param _voteHolder The address to fetch delegate for\n', '   * @return address The delegate address\n', '   */\n', '  function getVoteUser(address _voteHolder) public view returns (address) {\n', '    address currentDelegate = voteDelegations[_voteHolder];\n', '    if (currentDelegate == address(0)) {\n', '      return _voteHolder;\n', '    }\n', '    return currentDelegate;\n', '  }\n', '\n', '  /**\n', '   * @notice Provides information about the last cached votes checkpoint with no other conditions\n', '   * @dev Provides a latest cached votes value. For actual votes information use `getPriorVotes()` which introduce\n', '   *      some additional logic constraints on top of this cached value.\n', '   * @param _member The member address to get votes for\n', '   */\n', '  function getLastCachedVotes(address _member) external view returns (uint256) {\n', '    uint32 dstRepNum = numCheckpoints[_member];\n', '    return dstRepNum > 0 ? checkpoints[_member][dstRepNum - 1].votes : 0;\n', '  }\n', '\n', '  /**\n', '   * @notice Provides information about a member already claimed votes\n', '   * @dev Behaves like a CVP delegated balance, but with a member unclaimed balance\n', '   * @dev Block number must be a finalized block or else this function will revert to prevent misinformation\n', '   * @dev Returns 0 for non-member addresses, even for previously valid ones\n', '   * @dev This method is a copy from CVP token with several modifications\n', '   * @param account The address of the member to check\n', '   * @param blockNumber The block number to get the vote balance at\n', '   * @return The number of votes the account had as of the given block\n', '   */\n', '  function getPriorVotes(address account, uint256 blockNumber) external view override returns (uint96) {\n', '    require(blockNumber < block.number, "Vesting::getPriorVotes: Not yet determined");\n', '\n', '    uint32 nCheckpoints = numCheckpoints[account];\n', '\n', '    Member memory member = members[account];\n', '\n', '    // Transferred member\n', '    if (member.transferred == true) {\n', '      return 0;\n', '    }\n', '\n', '    // (No one can use vesting votes left on the contract after endT, even for votings created before endT)\n', '    if (block.timestamp > getLoadedMemberEndT(member) || block.timestamp > endT) {\n', '      return 0;\n', '    }\n', '\n', '    // (A member has not claimed any tokens yet) OR (The blockNumber is before the first checkpoint)\n', '    if (nCheckpoints == 0 || checkpoints[account][0].fromBlock > blockNumber) {\n', '      return 0;\n', '    }\n', '\n', '    // Next check most recent balance\n', '    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n', '      return checkpoints[account][nCheckpoints - 1].votes;\n', '    }\n', '\n', '    uint32 lower = 0;\n', '    uint32 upper = nCheckpoints - 1;\n', '    while (upper > lower) {\n', '      uint32 center = upper - (upper - lower) / 2;\n', '      // ceil, avoiding overflow\n', '      Checkpoint memory cp = checkpoints[account][center];\n', '      if (cp.fromBlock == blockNumber) {\n', '        return cp.votes;\n', '      } else if (cp.fromBlock < blockNumber) {\n', '        lower = center;\n', '      } else {\n', '        upper = center - 1;\n', '      }\n', '    }\n', '    return checkpoints[account][lower].votes;\n', '  }\n', '\n', '  /*** Available to Claim calculation ***/\n', '\n', '  /**\n', '   * @notice Returns available amount for a claim in the given timestamp\n', '   *         by the given member based on the current contract values\n', '   * @param _atTimestamp The timestamp to calculate available balance for\n', '   * @param _member The member address to return available balance for\n', '   * @return The available amount for a claim in the provided timestamp\n', '   */\n', '  function getAvailableTokensForMemberAt(uint256 _atTimestamp, address _member) external view returns (uint256) {\n', '    Member memory member = members[_member];\n', '    if (member.active == false) {\n', '      return 0;\n', '    }\n', '\n', '    return\n', '      getAvailable(\n', '        _atTimestamp,\n', '        startT,\n', '        amountPerMember,\n', '        getLoadedMemberDurationT(member),\n', '        member.alreadyClaimedTokens\n', '      );\n', '  }\n', '\n', '  /**\n', '   * @notice Returns an evaluated endT value for the given member using\n', "   *         the member's personalDurationT if it set or the global endT otherwise.\n", '   * @param _member The member address to return endT for\n', '   * @return The evaluated endT value\n', '   */\n', '  function getMemberEndT(address _member) external view returns (uint256) {\n', '    return startT.add(getMemberDurationT(_member));\n', '  }\n', '\n', '  /**\n', '   * @notice Returns an evaluated durationT value for the given member using\n', "   *         the member's personalDurationT if it set or the global durationT otherwise.\n", '   * @param _member The member address to return durationT for\n', '   * @return The evaluated durationT value\n', '   */\n', '  function getMemberDurationT(address _member) public view returns (uint256) {\n', '    return getLoadedMemberDurationT(members[_member]);\n', '  }\n', '\n', '  function getLoadedMemberEndT(Member memory _member) internal view returns (uint256) {\n', '    return startT.add(getLoadedMemberDurationT(_member));\n', '  }\n', '\n', '  function getLoadedMemberDurationT(Member memory _member) internal view returns (uint256) {\n', '    uint256 _personalDurationT = uint256(_member.personalDurationT);\n', '    if (_personalDurationT == 0) {\n', '      return durationT;\n', '    }\n', '\n', '    return _personalDurationT;\n', '  }\n', '\n', '  /**\n', '   * @notice Returns available token amount for a claim by a given member in the current timestamp\n', '   *         based on the current contract values\n', '   * @param _member The member address to return available balance for\n', '   * @return The available amount for a claim in the current block\n', '   */\n', '  function getAvailableTokensForMember(address _member) external view returns (uint256) {\n', '    Member memory member = members[_member];\n', '    if (member.active == false) {\n', '      return 0;\n', '    }\n', '\n', '    return getAvailableTokens(member.alreadyClaimedTokens, getLoadedMemberDurationT(member));\n', '  }\n', '\n', '  /**\n', '   * @notice Returns available vote amount for a claim by a given member at the moment\n', '   *         based on the current contract values\n', '   * @param _member The member address to return available balance for\n', '   * @return The available amount for a claim at the moment\n', '   */\n', '  function getAvailableVotesForMember(address _member) external view returns (uint256) {\n', '    Member storage member = members[_member];\n', '    if (member.active == false) {\n', '      return 0;\n', '    }\n', '\n', '    return getAvailableVotes({ _alreadyClaimed: member.alreadyClaimedVotes, _memberEndT: getLoadedMemberEndT(member) });\n', '  }\n', '\n', '  /**\n', '   * @notice Returns available token amount for a claim based on the current contract values\n', '   *         and an already claimed amount input\n', '   * @dev Will return amountPerMember for non-members, so an external check is required for this case\n', '   * @param _alreadyClaimed amount\n', '   * @param _durationT in seconds\n', '   * @return The available amount for claim\n', '   */\n', '  function getAvailableTokens(uint256 _alreadyClaimed, uint256 _durationT) public view returns (uint256) {\n', '    return getAvailable(block.timestamp, startT, amountPerMember, _durationT, _alreadyClaimed);\n', '  }\n', '\n', '  /**\n', '   * @notice Returns available vote amount for claim based on the current contract values\n', '   *         and an already claimed amount input\n', '   * @dev Will return amountPerMember for non-members, so an external check is required for this case.\n', '   *      Will return 0 if global vesting is over.\n', '   * @param _alreadyClaimed amount\n', '   * @param _memberEndT either the global or a personal endT timestamp\n', '   * @return The available amount for claim\n', '   */\n', '  function getAvailableVotes(uint256 _alreadyClaimed, uint256 _memberEndT) public view returns (uint256) {\n', '    if (block.timestamp > _memberEndT || block.timestamp > endT) {\n', '      return 0;\n', '    }\n', '    return getAvailable(block.timestamp, startV, amountPerMember, durationV, _alreadyClaimed);\n', '  }\n', '\n', '  /**\n', '   * @notice Calculates available amount for a claim\n', "   * @dev A pure function which doesn't reads anything from state\n", '   * @param _now A timestamp to calculate the available amount\n', '   * @param _start The vesting period start timestamp\n', '   * @param _amountPerMember The amount of ERC20 tokens to be distributed to each member\n', '   *         during this vesting period\n', '   * @param _duration The vesting total duration in seconds\n', '   * @param _alreadyClaimed The amount of tokens already claimed by a member\n', '   * @return The available amount for a claim\n', '   */\n', '  function getAvailable(\n', '    uint256 _now,\n', '    uint256 _start,\n', '    uint256 _amountPerMember,\n', '    uint256 _duration,\n', '    uint256 _alreadyClaimed\n', '  ) public pure returns (uint256) {\n', '    if (_now <= _start) {\n', '      return 0;\n', '    }\n', '\n', '    // uint256 vestingEndsAt = _start + _duration;\n', '    uint256 vestingEndsAt = _start.add(_duration);\n', '    uint256 to = _now > vestingEndsAt ? vestingEndsAt : _now;\n', '\n', '    // uint256 accrued = (to - _start) * _amountPerMember / _duration;\n', '    uint256 accrued = ((to - _start).mul(_amountPerMember).div(_duration));\n', '\n', '    // return accrued - _alreadyClaimed;\n', '    return accrued.sub(_alreadyClaimed);\n', '  }\n', '\n', '  /*** Owner Methods ***/\n', '\n', '  /**\n', '   * @notice Increase global duration of vesting.\n', '   *         Owner must find all personal durations lower than global duration and increase before call this function.\n', '   * @param _newDurationT New global vesting duration\n', '   */\n', '  function increaseDurationT(uint256 _newDurationT) external onlyOwner {\n', '    require(block.timestamp < endT, "Vesting::increaseDurationT: Vesting is over");\n', '    require(_newDurationT > durationT, "Vesting::increaseDurationT: Too small duration");\n', '    require((_newDurationT - durationT) <= 180 days, "Vesting::increaseDurationT: Too big duration");\n', '\n', '    uint256 prevDurationT = durationT;\n', '    uint256 prevEndT = endT;\n', '\n', '    durationT = _newDurationT;\n', '    uint256 newEndT = startT.add(_newDurationT);\n', '    endT = newEndT;\n', '\n', '    emit IncreaseDurationT(prevDurationT, prevEndT, _newDurationT, newEndT);\n', '  }\n', '\n', '  /**\n', '   * @notice Increase personal duration of vesting.\n', '   *         Personal vesting duration must be always greater than global duration.\n', '   * @param _members Members list for increase duration\n', '   * @param _newPersonalDurationsT New personal vesting duration\n', '   */\n', '  function increasePersonalDurationsT(address[] calldata _members, uint256[] calldata _newPersonalDurationsT)\n', '    external\n', '    onlyOwner\n', '  {\n', '    uint256 len = _members.length;\n', '    require(_newPersonalDurationsT.length == len, "LENGTH_MISMATCH");\n', '\n', '    for (uint256 i = 0; i < len; i++) {\n', '      _increasePersonalDurationT(_members[i], _newPersonalDurationsT[i]);\n', '    }\n', '  }\n', '\n', '  function _increasePersonalDurationT(address _member, uint256 _newPersonalDurationT) internal {\n', '    Member memory member = members[_member];\n', '    uint256 prevPersonalDurationT = getLoadedMemberDurationT(member);\n', '\n', '    require(_newPersonalDurationT > prevPersonalDurationT, "Vesting::increasePersonalDurationT: Too small duration");\n', '    require(\n', '      (_newPersonalDurationT - prevPersonalDurationT) <= 180 days,\n', '      "Vesting::increasePersonalDurationT: Too big duration"\n', '    );\n', '    require(_newPersonalDurationT >= durationT, "Vesting::increasePersonalDurationT: Less than durationT");\n', '\n', '    uint256 prevPersonalEndT = startT.add(prevPersonalDurationT);\n', '\n', '    members[_member].personalDurationT = _newPersonalDurationT.toUint32();\n', '\n', '    uint256 newPersonalEndT = startT.add(_newPersonalDurationT);\n', '    emit IncreasePersonalDurationT(\n', '      _member,\n', '      prevPersonalDurationT,\n', '      prevPersonalEndT,\n', '      member.personalDurationT,\n', '      _newPersonalDurationT,\n', '      newPersonalEndT\n', '    );\n', '  }\n', '\n', '  function disableMember(address _member) external onlyOwner {\n', '    _disableMember(_member);\n', '  }\n', '\n', '  function _disableMember(address _member) internal {\n', '    Member memory from = members[_member];\n', '\n', '    require(from.active == true, "Vesting::_disableMember: The member is inactive");\n', '\n', '    members[_member].active = false;\n', '\n', '    address currentDelegate = voteDelegations[_member];\n', '\n', '    uint32 nCheckpoints = numCheckpoints[_member];\n', '    if (nCheckpoints != 0 && currentDelegate != address(0) && currentDelegate != _member) {\n', '      uint96 adjustedVotes =\n', '        sub96(from.alreadyClaimedVotes, from.alreadyClaimedTokens, "Vesting::_disableMember: AdjustedVotes underflow");\n', '\n', '      if (adjustedVotes > 0) {\n', '        _subDelegatedVotesCache(currentDelegate, adjustedVotes);\n', '      }\n', '    }\n', '\n', '    delete voteDelegations[_member];\n', '\n', '    uint256 tokensRemainder =\n', '      sub96(amountPerMember, from.alreadyClaimedTokens, "Vesting::_disableMember: BalanceRemainder overflow");\n', '    require(IERC20(token).transfer(address(1), uint256(tokensRemainder)), "ERC20::transfer: failed");\n', '\n', '    emit DisableMember(_member, tokensRemainder);\n', '  }\n', '\n', '  /*** Member Methods ***/\n', '\n', '  /**\n', '   * @notice An active member can renounce his membership once.\n', "   * @dev This action is irreversible. The disabled member can't be enabled again.\n", "   *      Disables all the member's vote checkpoints. Transfers all the member's unclaimed tokens to the address(1).\n", '   */\n', '  function renounceMembership() external {\n', '    _disableMember(msg.sender);\n', '  }\n', '\n', '  /**\n', '   * @notice An active member claims a distributed amount of votes\n', '   * @dev Caches unclaimed balance per block number which could be used by voting contract\n', '   * @param _to address to claim votes to\n', '   */\n', '  function claimVotes(address _to) external {\n', '    Member memory member = members[_to];\n', '    require(member.active == true, "Vesting::claimVotes: User not active");\n', '\n', '    uint256 endT_ = getLoadedMemberEndT(member);\n', '    uint256 votes = getAvailableVotes({ _alreadyClaimed: member.alreadyClaimedVotes, _memberEndT: endT_ });\n', '\n', '    require(block.timestamp <= endT_, "Vesting::claimVotes: Vote vesting has ended");\n', '    require(votes > 0, "Vesting::claimVotes: Nothing to claim");\n', '\n', '    _claimVotes(_to, member, votes);\n', '  }\n', '\n', '  function _claimVotes(\n', '    address _memberAddress,\n', '    Member memory _member,\n', '    uint256 _availableVotes\n', '  ) internal {\n', '    uint96 newAlreadyClaimedVotes;\n', '\n', '    if (_availableVotes > 0) {\n', '      uint96 amount = safe96(_availableVotes, "Vesting::_claimVotes: Amount overflow");\n', '\n', '      // member.alreadyClaimed += amount\n', '      newAlreadyClaimedVotes = add96(\n', '        _member.alreadyClaimedVotes,\n', '        amount,\n', '        "Vesting::claimVotes: newAlreadyClaimed overflow"\n', '      );\n', '      members[_memberAddress].alreadyClaimedVotes = newAlreadyClaimedVotes;\n', '    } else {\n', '      newAlreadyClaimedVotes = _member.alreadyClaimedVotes;\n', '    }\n', '\n', '    // Step #1. Get the accrued votes value\n', '    // lastMemberAdjustedVotes = claimedVotesBeforeTx - claimedTokensBeforeTx\n', '    uint96 lastMemberAdjustedVotes =\n', '      sub96(\n', '        _member.alreadyClaimedVotes,\n', '        _member.alreadyClaimedTokens,\n', '        "Vesting::_claimVotes: lastMemberAdjustedVotes overflow"\n', '      );\n', '\n', '    // Step #2. Get the adjusted value in relation to the member itself.\n', '    // `adjustedVotes = votesAfterTx - claimedTokensBeforeTheCalculation`\n', '    // `claimedTokensBeforeTheCalculation` could be updated earlier in claimVotes() method in the same tx\n', '    uint96 adjustedVotes =\n', '      sub96(\n', '        newAlreadyClaimedVotes,\n', '        members[_memberAddress].alreadyClaimedTokens,\n', '        "Vesting::_claimVotes: adjustedVotes underflow"\n', '      );\n', '\n', '    address delegate = getVoteUser(_memberAddress);\n', '    uint96 diff;\n', '\n', '    // Step #3. Apply the adjusted value in relation to the delegate\n', '    if (adjustedVotes > lastMemberAdjustedVotes) {\n', '      diff = sub96(adjustedVotes, lastMemberAdjustedVotes, "Vesting::_claimVotes: Positive diff underflow");\n', '      _addDelegatedVotesCache(delegate, diff);\n', '    } else if (lastMemberAdjustedVotes > adjustedVotes) {\n', '      diff = sub96(lastMemberAdjustedVotes, adjustedVotes, "Vesting::_claimVotes: Negative diff underflow");\n', '      _subDelegatedVotesCache(delegate, diff);\n', '    }\n', '\n', '    emit ClaimVotes(\n', '      _memberAddress,\n', '      delegate,\n', '      _member.alreadyClaimedVotes,\n', '      _member.alreadyClaimedTokens,\n', '      newAlreadyClaimedVotes,\n', '      members[_memberAddress].alreadyClaimedTokens,\n', '      lastMemberAdjustedVotes,\n', '      adjustedVotes,\n', '      diff\n', '    );\n', '  }\n', '\n', '  /**\n', '   * @notice An active member claims a distributed amount of ERC20 tokens\n', '   * @param _to address to claim ERC20 tokens to\n', '   */\n', '  function claimTokens(address _to) external {\n', '    Member memory member = members[msg.sender];\n', '    require(member.active == true, "Vesting::claimTokens: User not active");\n', '\n', '    uint256 durationT_ = getLoadedMemberDurationT(member);\n', '    uint256 bigAmount = getAvailableTokens(member.alreadyClaimedTokens, durationT_);\n', '    require(bigAmount > 0, "Vesting::claimTokens: Nothing to claim");\n', '    uint96 amount = safe96(bigAmount, "Vesting::claimTokens: Amount overflow");\n', '\n', '    // member.alreadyClaimed += amount\n', '    uint96 newAlreadyClaimed =\n', '      add96(member.alreadyClaimedTokens, amount, "Vesting::claimTokens: NewAlreadyClaimed overflow");\n', '    members[msg.sender].alreadyClaimedTokens = newAlreadyClaimed;\n', '\n', '    uint256 endT_ = startT.add(durationT_);\n', '    uint256 votes = getAvailableVotes({ _alreadyClaimed: member.alreadyClaimedVotes, _memberEndT: endT_ });\n', '\n', '    if (block.timestamp <= endT) {\n', '      _claimVotes(msg.sender, member, votes);\n', '    }\n', '\n', '    emit ClaimTokens(msg.sender, _to, amount, newAlreadyClaimed, votes);\n', '\n', '    require(IERC20(token).transfer(_to, bigAmount), "ERC20::transfer: failed");\n', '  }\n', '\n', '  /**\n', '   * @notice Delegates an already claimed votes amount to the given address\n', '   * @param _to address to delegate votes\n', '   */\n', '  function delegateVotes(address _to) external {\n', '    Member memory member = members[msg.sender];\n', '    require(_to != address(0), "Vesting::delegateVotes: Can\'t delegate to 0 address");\n', '    require(member.active == true, "Vesting::delegateVotes: msg.sender not active");\n', '\n', '    address currentDelegate = getVoteUser(msg.sender);\n', '    require(_to != currentDelegate, "Vesting::delegateVotes: Already delegated to this address");\n', '\n', '    voteDelegations[msg.sender] = _to;\n', '    uint96 adjustedVotes =\n', '      sub96(member.alreadyClaimedVotes, member.alreadyClaimedTokens, "Vesting::claimVotes: AdjustedVotes underflow");\n', '\n', '    _subDelegatedVotesCache(currentDelegate, adjustedVotes);\n', '    _addDelegatedVotesCache(_to, adjustedVotes);\n', '\n', '    emit DelegateVotes(msg.sender, _to, currentDelegate, adjustedVotes);\n', '  }\n', '\n', '  /**\n', '   * @notice Transfers a vested rights for a member funds to another address\n', "   * @dev A new member won't have any votes for a period between a start timestamp and a current timestamp\n", '   * @param _to address to transfer a vested right to\n', '   */\n', '  function transfer(address _to) external {\n', '    Member memory from = members[msg.sender];\n', '    Member memory to = members[_to];\n', '\n', '    uint96 alreadyClaimedTokens = from.alreadyClaimedTokens;\n', '    uint96 alreadyClaimedVotes = from.alreadyClaimedVotes;\n', '    uint32 personalDurationT = from.personalDurationT;\n', '\n', '    require(from.active == true, "Vesting::transfer: From member is inactive");\n', '    require(to.active == false, "Vesting::transfer: To address is already active");\n', '    require(to.transferred == false, "Vesting::transfer: To address has been already used");\n', '    require(numCheckpoints[_to] == 0, "Vesting::transfer: To address already had a checkpoint");\n', '\n', '    members[msg.sender] = Member({\n', '      active: false,\n', '      transferred: true,\n', '      alreadyClaimedVotes: 0,\n', '      alreadyClaimedTokens: 0,\n', '      personalDurationT: 0\n', '    });\n', '    members[_to] = Member({\n', '      active: true,\n', '      transferred: false,\n', '      alreadyClaimedVotes: alreadyClaimedVotes,\n', '      alreadyClaimedTokens: alreadyClaimedTokens,\n', '      personalDurationT: personalDurationT\n', '    });\n', '\n', '    address currentDelegate = voteDelegations[msg.sender];\n', '\n', '    uint32 currentBlockNumber = safe32(block.number, "Vesting::transfer: Block number exceeds 32 bits");\n', '\n', '    checkpoints[_to][0] = Checkpoint(uint32(0), 0);\n', '    if (currentDelegate == address(0)) {\n', '      uint96 adjustedVotes =\n', '        sub96(from.alreadyClaimedVotes, from.alreadyClaimedTokens, "Vesting::claimVotes: AdjustedVotes underflow");\n', '      _subDelegatedVotesCache(msg.sender, adjustedVotes);\n', '      checkpoints[_to][1] = Checkpoint(currentBlockNumber, adjustedVotes);\n', '      numCheckpoints[_to] = 2;\n', '    } else {\n', '      numCheckpoints[_to] = 1;\n', '    }\n', '\n', '    voteDelegations[_to] = voteDelegations[msg.sender];\n', '    delete voteDelegations[msg.sender];\n', '\n', '    Member memory toMember = members[_to];\n', '\n', '    emit Transfer(msg.sender, _to, alreadyClaimedVotes, alreadyClaimedTokens, currentDelegate);\n', '\n', '    uint256 votes =\n', '      getAvailableVotes({ _alreadyClaimed: toMember.alreadyClaimedVotes, _memberEndT: getLoadedMemberEndT(toMember) });\n', '\n', '    _claimVotes(_to, toMember, votes);\n', '  }\n', '\n', '  function _subDelegatedVotesCache(address _member, uint96 _subAmount) internal {\n', '    uint32 dstRepNum = numCheckpoints[_member];\n', '    uint96 dstRepOld = dstRepNum > 0 ? checkpoints[_member][dstRepNum - 1].votes : 0;\n', '    uint96 dstRepNew = sub96(dstRepOld, _subAmount, "Vesting::_cacheUnclaimed: Sub amount overflows");\n', '    _writeCheckpoint(_member, dstRepNum, dstRepOld, dstRepNew);\n', '  }\n', '\n', '  function _addDelegatedVotesCache(address _member, uint96 _addAmount) internal {\n', '    uint32 dstRepNum = numCheckpoints[_member];\n', '    uint96 dstRepOld = dstRepNum > 0 ? checkpoints[_member][dstRepNum - 1].votes : 0;\n', '    uint96 dstRepNew = add96(dstRepOld, _addAmount, "Vesting::_cacheUnclaimed: Add amount overflows");\n', '    _writeCheckpoint(_member, dstRepNum, dstRepOld, dstRepNew);\n', '  }\n', '\n', '  /// @dev A copy from CVP token, only the event name changed\n', '  function _writeCheckpoint(\n', '    address delegatee,\n', '    uint32 nCheckpoints,\n', '    uint96 oldVotes,\n', '    uint96 newVotes\n', '  ) internal {\n', '    uint32 blockNumber = safe32(block.number, "Vesting::_writeCheckpoint: Block number exceeds 32 bits");\n', '\n', '    if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n', '      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n', '    } else {\n', '      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n', '      numCheckpoints[delegatee] = nCheckpoints + 1;\n', '    }\n', '\n', '    emit UnclaimedBalanceChanged(delegatee, oldVotes, newVotes);\n', '  }\n', '\n', '  /// @dev The exact copy from CVP token\n', '  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n', '    require(n < 2**32, errorMessage);\n', '    return uint32(n);\n', '  }\n', '\n', '  /// @dev The exact copy from CVP token\n', '  function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n', '    require(n < 2**96, errorMessage);\n', '    return uint96(n);\n', '  }\n', '\n', '  /// @dev The exact copy from CVP token\n', '  function sub96(\n', '    uint96 a,\n', '    uint96 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint96) {\n', '    require(b <= a, errorMessage);\n', '    return a - b;\n', '  }\n', '\n', '  /// @dev The exact copy from CVP token\n', '  function add96(\n', '    uint96 a,\n', '    uint96 b,\n', '    string memory errorMessage\n', '  ) internal pure returns (uint96) {\n', '    uint96 c = a + b;\n', '    require(c >= a, errorMessage);\n', '    return c;\n', '  }\n', '}']