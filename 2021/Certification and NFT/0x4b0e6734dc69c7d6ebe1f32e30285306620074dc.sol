['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-10\n', '*/\n', '\n', 'pragma solidity ^0.6.9;\n', '//SPDX-License-Identifier: UNLICENSED\n', '\n', '\n', 'library SafeMathChainlink {\n', '\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b <= a, "SafeMath: subtraction overflow");\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    // Solidity only automatically asserts when dividing by 0\n', '    require(b > 0, "SafeMath: division by zero");\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    require(b != 0, "SafeMath: modulo by zero");\n', '    return a % b;\n', '  }\n', '}\n', '\n', 'interface LinkTokenInterface {\n', '  function allowance(address owner, address spender) external view returns (uint256 remaining);\n', '  function approve(address spender, uint256 value) external returns (bool success);\n', '  function balanceOf(address owner) external view returns (uint256 balance);\n', '  function decimals() external view returns (uint8 decimalPlaces);\n', '  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n', '  function increaseApproval(address spender, uint256 subtractedValue) external;\n', '  function name() external view returns (string memory tokenName);\n', '  function symbol() external view returns (string memory tokenSymbol);\n', '  function totalSupply() external view returns (uint256 totalTokensIssued);\n', '  function transfer(address to, uint256 value) external returns (bool success);\n', '  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n', '  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n', '}\n', '\n', 'contract VRFRequestIDBase {\n', '\n', '  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\n', '    address _requester, uint256 _nonce)\n', '    internal pure returns (uint256)\n', '  {\n', '    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n', '  }\n', '\n', '  function makeRequestId(\n', '    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n', '    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n', '  }\n', '}\n', '\n', '\n', 'abstract contract VRFConsumerBase is VRFRequestIDBase {\n', '\n', '  using SafeMathChainlink for uint256;\n', '\n', '  function fulfillRandomness(bytes32 requestId, uint256 randomness)\n', '    internal virtual;\n', '\n', '  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\n', '    internal returns (bytes32 requestId)\n', '  {\n', '    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\n', '\n', '    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\n', '\n', '    nonces[_keyHash] = nonces[_keyHash].add(1);\n', '    return makeRequestId(_keyHash, vRFSeed);\n', '  }\n', '\n', '  LinkTokenInterface immutable internal LINK;\n', '  address immutable private vrfCoordinator;\n', '\n', '  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\n', '\n', '  constructor(address _vrfCoordinator, address _link) public {\n', '    vrfCoordinator = _vrfCoordinator;\n', '    LINK = LinkTokenInterface(_link);\n', '  }\n', '\n', '  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n', '    require(msg.sender == vrfCoordinator, "Only VRFCoordinator can fulfill");\n', '    fulfillRandomness(requestId, randomness);\n', '  }\n', '}\n', '\n', 'interface IERC20 {\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '} \n', '\n', 'contract CandorFiv2 is VRFConsumerBase{\n', '    uint[] private entryArray;\n', '    address[] public userAddresses;\n', '    address public owner;\n', '    uint public totalEntry;\n', '    uint public round;\n', '    address[] public winners;\n', '    uint[] public winningNumbers;\n', '    uint public ticketPrice = 10 * 1e6; // 10$ ticket price (6 decimals)\n', '    uint public poolLimit = 20000 * 1e6; // 20000$ pool limit\n', '    uint public adminFee = 50; // 50% admin fee\n', '    uint[10] public rewardArray = [250,100,50,30,20,10,10,10,10,10]; // Change here (Prize % with an additional 0)\n', '    IERC20 public token;\n', '    \n', '    bytes32 internal keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;\n', '\tuint internal fee;\n', '\tuint public randomResult;\n', '\tuint public oldRandomResult;\n', '\t\n', '    struct User{\n', '        bool isEntered;\n', '        uint totalEntries;\n', '        bool isPicked;\n', '    }\n', '    modifier onlyOwner{\n', '        require(msg.sender == owner,"Only owner allowed");\n', '        _;\n', '    }\n', '    mapping(uint => address) public entryMapping;\n', '    mapping(uint => mapping(address => User)) public userInfo;\n', '    \n', '    event RandomNumberGenerated(bytes32,uint256);\n', '    event EntryComplete(address,uint,uint);\n', '    event WinnerPicked(address[],uint[]);\n', '    \n', '    function setTicketPrice(uint value) external onlyOwner{\n', '       ticketPrice = value; \n', '    }\n', '    \n', '    function setPoolLimit(uint value) external onlyOwner{\n', '        poolLimit = value;\n', '    }\n', '    \n', '    function setAdminFee(uint value) external onlyOwner{\n', '        adminFee = value;\n', '    }\n', '    \n', '    function withdrawLink(uint value) external onlyOwner {\n', '    \trequire(LINK.transfer(msg.sender, value), "Unable to transfer");\n', '    }\n', '    \n', '    function transferOwnership(address newOwner) external onlyOwner{\n', '        owner = newOwner;\n', '    }\n', '    \n', '    //Mainnet network\n', '    constructor() VRFConsumerBase (\n', '            0xf0d54349aDdcf704F77AE15b96510dEA15cb7952,  //VRF Coordinator\n', '\t        0x514910771AF9Ca656af840dff83E8264EcF986CA   //LINK token\n', '           ) public {\n', '        fee = 2000000000000000000; // 2 LINK\n', '        owner = msg.sender;\n', '        token = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // USDC contract address\n', '    }\n', '    \n', '    function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\n', '        randomResult = randomness;\n', '        emit RandomNumberGenerated(requestId,randomResult);\n', '    }\n', '    \n', '    function getRandomNumber() public onlyOwner returns (bytes32 requestId) {\n', '        require(LINK.balanceOf(address(this)) > fee, "Not enough LINK - fill contract with faucet");\n', '        winners = new address[](0);\n', '        winningNumbers = new uint[](0);\n', '        return requestRandomness(keyHash, fee, getSeed());\n', '    }\n', '    \n', '    function enterLottery(uint256 amount) external {\n', '        require(amount >= ticketPrice && amount <= (poolLimit / 10),"Invalid amount!"); //Change here\n', '        require(!userInfo[round][msg.sender].isEntered,"Already entered!");\n', '        require(token.allowance(msg.sender,address(this)) >= amount,"Set allowance first!");\n', '        bool success = token.transferFrom(msg.sender,address(this),amount);\n', '        require(success,"Transfer failed");\n', '        require(token.balanceOf(address(this)) <= poolLimit,"Pool already full");\n', '        uint ticketCount = amount.div(ticketPrice);\n', '        require((totalEntry + ticketCount) <= (poolLimit / ticketPrice),"Buy lower amount of tickets");\n', '        userInfo[round][msg.sender].totalEntries = ticketCount;\n', '        userInfo[round][msg.sender].isEntered = true;\n', '        entryArray.push(totalEntry);\n', '        entryMapping[totalEntry] = msg.sender; \n', '        totalEntry += ticketCount;\n', '        userAddresses.push(msg.sender);\n', '        emit EntryComplete(msg.sender,amount,ticketCount);\n', '    }\n', '    \n', '    function pickWinner() external onlyOwner{\n', '        require(userAddresses.length >= 10,"Atleast 10 participants"); //Change here\n', '        require(totalEntry >= 50,"Minimum 50 tickets sold");\n', '        require(oldRandomResult != randomResult,"Update random number first!");\n', '        uint i;\n', '        uint winner;\n', '        address wonUser;\n', '        uint tempRandom;\n', '        uint totalBalance = token.balanceOf(address(this));\n', '        token.transfer(owner,(totalBalance * adminFee) / 100);\n', '        totalBalance -= (totalBalance * adminFee) / 100;\n', '        while(i<10){ //Change here\n', '            winner = calculateWinner((randomResult % totalEntry));\n', '            wonUser = entryMapping[winner];\n', '            winners.push(wonUser);\n', '            winningNumbers.push(randomResult % totalEntry); \n', '            token.transfer(wonUser,(totalBalance * rewardArray[i]) / 1000);\n', '            i++;\n', '            tempRandom = uint(keccak256(abi.encodePacked(randomResult, now, i)));\n', '            randomResult = tempRandom;\n', '        }\n', '        emit WinnerPicked(winners,winningNumbers);\n', '        oldRandomResult = randomResult;\n', '        totalEntry = 0;\n', '        entryArray = new uint[](0);\n', '        userAddresses = new address[](0);\n', '        round++;\n', '    }\n', '    \n', '    function getSeed() private view returns(uint) {\n', '\t\treturn uint(keccak256(abi.encodePacked(block.difficulty, now, userAddresses)));\n', '\t}\n', '\t\n', '\tfunction calculateWinner(uint target) internal view returns(uint){\n', '\t    uint last = entryArray.length; \n', '\t    uint first = 0;\n', '\t    uint mid = 0;\n', '\t    if(target <= entryArray[0]){\n', '\t        return entryArray[0];\n', '\t    }\n', '\t    \n', '\t    if(target >= entryArray[last-1]){\n', '\t        return entryArray[last-1];\n', '\t    }\n', '\t    \n', '\t    while(first < last){\n', '\t        mid = (first + last) / 2;\n', '\t        \n', '\t        if(entryArray[mid] == target){\n', '\t            return entryArray[mid];\n', '\t        }\n', '\t        \n', '\t        if(target < entryArray[mid]){\n', '\t            if(mid > 0 && target > entryArray[mid - 1]){\n', '\t                return entryArray[mid - 1];\n', '\t            }\n', '\t            \n', '\t            last = mid;\n', '\t        }\n', '\t        else{\n', '\t            if(mid < last - 1 && target < entryArray[mid + 1]){\n', '\t                return entryArray[mid];\n', '\t            }\n', '\t            \n', '\t            first = mid + 1;\n', '\t        }\n', '\t    }\n', '\t    return entryArray[mid];\n', '\t}\n', '\t\n', '\tfunction winningChance() public view returns(uint winchance){\n', '\t    \n', '\t    return(\n', '\t        (userInfo[round][msg.sender].totalEntries * 100) / totalEntry);\n', '\t}\n', '\t\n', '\tfunction lastRoundInfo() external view returns(address[] memory,uint[] memory){\n', '\t    return (winners,winningNumbers);\n', '\t}\n', '\t\n', '\tfunction transferAnyERC20(address _tokenAddress, address _to, uint _amount) public onlyOwner {\n', '\t    require(_tokenAddress != address(token),"Not USDC");\n', '        IERC20(_tokenAddress).transfer(_to, _amount);\n', '    }\n', '\t\n', '}']