['pragma solidity ^0.5.16;\n', '\n', 'import "./SToken.sol";\n', '\n', '/**\n', " * @title Strike's SEther Contract\n", ' * @notice SToken which wraps Ether\n', ' * @author Strike\n', ' */\n', 'contract SEther is SToken {\n', '    /**\n', '     * @notice Construct a new SEther money market\n', '     * @param comptroller_ The address of the Comptroller\n', '     * @param interestRateModel_ The address of the interest rate model\n', '     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n', '     * @param name_ ERC-20 name of this token\n', '     * @param symbol_ ERC-20 symbol of this token\n', '     * @param decimals_ ERC-20 decimal precision of this token\n', '     * @param admin_ Address of the administrator of this token\n', '     */\n', '    constructor(ComptrollerInterface comptroller_,\n', '                InterestRateModel interestRateModel_,\n', '                uint initialExchangeRateMantissa_,\n', '                string memory name_,\n', '                string memory symbol_,\n', '                uint8 decimals_,\n', '                address payable admin_) public {\n', '        // Creator of the contract is admin during initialization\n', '        admin = msg.sender;\n', '\n', '        initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n', '\n', '        // Set the proper admin now that initialization is done\n', '        admin = admin_;\n', '    }\n', '\n', '\n', '    /*** User Interface ***/\n', '\n', '    /**\n', '     * @notice Sender supplies assets into the market and receives sTokens in exchange\n', '     * @dev Reverts upon any failure\n', '     */\n', '    function mint() external payable {\n', '        (uint err,) = mintInternal(msg.value);\n', '        requireNoError(err, "mint failed");\n', '    }\n', '\n', '    /**\n', '     * @notice Sender redeems sTokens in exchange for the underlying asset\n', '     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n', '     * @param redeemTokens The number of sTokens to redeem into underlying\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function redeem(uint redeemTokens) external returns (uint) {\n', '        return redeemInternal(redeemTokens);\n', '    }\n', '\n', '    /**\n', '     * @notice Sender redeems sTokens in exchange for a specified amount of underlying asset\n', '     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n', '     * @param redeemAmount The amount of underlying to redeem\n', '     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '     */\n', '    function redeemUnderlying(uint redeemAmount) external returns (uint) {\n', '        return redeemUnderlyingInternal(redeemAmount);\n', '    }\n', '\n', '    /**\n', '      * @notice Sender borrows assets from the protocol to their own address\n', '      * @param borrowAmount The amount of the underlying asset to borrow\n', '      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n', '      */\n', '    function borrow(uint borrowAmount) external returns (uint) {\n', '        return borrowInternal(borrowAmount);\n', '    }\n', '\n', '    /**\n', '     * @notice Sender repays their own borrow\n', '     * @dev Reverts upon any failure\n', '     */\n', '    function repayBorrow() external payable {\n', '        (uint err,) = repayBorrowInternal(msg.value);\n', '        requireNoError(err, "repayBorrow failed");\n', '    }\n', '\n', '    /**\n', '     * @notice Sender repays a borrow belonging to borrower\n', '     * @dev Reverts upon any failure\n', '     * @param borrower the account with the debt being payed off\n', '     */\n', '    function repayBorrowBehalf(address borrower) external payable {\n', '        (uint err,) = repayBorrowBehalfInternal(borrower, msg.value);\n', '        requireNoError(err, "repayBorrowBehalf failed");\n', '    }\n', '\n', '    /**\n', '     * @notice The sender liquidates the borrowers collateral.\n', '     *  The collateral seized is transferred to the liquidator.\n', '     * @dev Reverts upon any failure\n', '     * @param borrower The borrower of this sToken to be liquidated\n', '     * @param sTokenCollateral The market in which to seize collateral from the borrower\n', '     */\n', '    function liquidateBorrow(address borrower, SToken sTokenCollateral) external payable {\n', '        (uint err,) = liquidateBorrowInternal(borrower, msg.value, sTokenCollateral);\n', '        requireNoError(err, "liquidateBorrow failed");\n', '    }\n', '\n', '    /**\n', '     * @notice Send Ether to SEther to mint\n', '     */\n', '    function () external payable {\n', '        (uint err,) = mintInternal(msg.value);\n', '        requireNoError(err, "mint failed");\n', '    }\n', '\n', '    /*** Safe Token ***/\n', '\n', '    /**\n', '     * @notice Gets balance of this contract in terms of Ether, before this message\n', '     * @dev This excludes the value of the current message, if any\n', '     * @return The quantity of Ether owned by this contract\n', '     */\n', '    function getCashPrior() internal view returns (uint) {\n', '        (MathError err, uint startingBalance) = subUInt(address(this).balance, msg.value);\n', '        require(err == MathError.NO_ERROR);\n', '        return startingBalance;\n', '    }\n', '\n', '    /**\n', '     * @notice Perform the actual transfer in, which is a no-op\n', '     * @param from Address sending the Ether\n', '     * @param amount Amount of Ether being sent\n', '     * @return The actual amount of Ether transferred\n', '     */\n', '    function doTransferIn(address from, uint amount) internal returns (uint) {\n', '        // Sanity checks\n', '        require(msg.sender == from, "sender mismatch");\n', '        require(msg.value == amount, "value mismatch");\n', '        return amount;\n', '    }\n', '\n', '    function doTransferOut(address payable to, uint amount) internal {\n', '        /* Send the Ether, with minimal gas and revert on failure */\n', '        to.transfer(amount);\n', '    }\n', '\n', '    function requireNoError(uint errCode, string memory message) internal pure {\n', '        if (errCode == uint(Error.NO_ERROR)) {\n', '            return;\n', '        }\n', '\n', '        bytes memory fullMessage = new bytes(bytes(message).length + 5);\n', '        uint i;\n', '\n', '        for (i = 0; i < bytes(message).length; i++) {\n', '            fullMessage[i] = bytes(message)[i];\n', '        }\n', '\n', '        fullMessage[i+0] = byte(uint8(32));\n', '        fullMessage[i+1] = byte(uint8(40));\n', '        fullMessage[i+2] = byte(uint8(48 + ( errCode / 10 )));\n', '        fullMessage[i+3] = byte(uint8(48 + ( errCode % 10 )));\n', '        fullMessage[i+4] = byte(uint8(41));\n', '\n', '        require(errCode == uint(Error.NO_ERROR), string(fullMessage));\n', '    }\n', '}']