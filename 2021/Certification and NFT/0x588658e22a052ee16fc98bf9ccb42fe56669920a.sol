['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-06\n', '*/\n', '\n', 'pragma solidity 0.6.7;\n', '\n', 'contract GebMath {\n', '    uint256 public constant RAY = 10 ** 27;\n', '    uint256 public constant WAD = 10 ** 18;\n', '\n', '    function ray(uint x) public pure returns (uint z) {\n', '        z = multiply(x, 10 ** 9);\n', '    }\n', '    function rad(uint x) public pure returns (uint z) {\n', '        z = multiply(x, 10 ** 27);\n', '    }\n', '    function minimum(uint x, uint y) public pure returns (uint z) {\n', '        z = (x <= y) ? x : y;\n', '    }\n', '    function addition(uint x, uint y) public pure returns (uint z) {\n', '        z = x + y;\n', '        require(z >= x, "uint-uint-add-overflow");\n', '    }\n', '    function subtract(uint x, uint y) public pure returns (uint z) {\n', '        z = x - y;\n', '        require(z <= x, "uint-uint-sub-underflow");\n', '    }\n', '    function multiply(uint x, uint y) public pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x, "uint-uint-mul-overflow");\n', '    }\n', '    function rmultiply(uint x, uint y) public pure returns (uint z) {\n', '        z = multiply(x, y) / RAY;\n', '    }\n', '    function rdivide(uint x, uint y) public pure returns (uint z) {\n', '        z = multiply(x, RAY) / y;\n', '    }\n', '    function wdivide(uint x, uint y) public pure returns (uint z) {\n', '        z = multiply(x, WAD) / y;\n', '    }\n', '    function wmultiply(uint x, uint y) public pure returns (uint z) {\n', '        z = multiply(x, y) / WAD;\n', '    }\n', '    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\n', '        assembly {\n', '            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n', '            default {\n', '                switch mod(n, 2) case 0 { z := base } default { z := x }\n', '                let half := div(base, 2)  // for rounding.\n', '                for { n := div(n, 2) } n { n := div(n,2) } {\n', '                    let xx := mul(x, x)\n', '                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n', '                    let xxRound := add(xx, half)\n', '                    if lt(xxRound, xx) { revert(0,0) }\n', '                    x := div(xxRound, base)\n', '                    if mod(n,2) {\n', '                        let zx := mul(z, x)\n', '                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n', '                        let zxRound := add(zx, half)\n', '                        if lt(zxRound, zx) { revert(0,0) }\n', '                        z := div(zxRound, base)\n', '                    }\n', '                }\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '\n', '    function feeTo() external view returns (address);\n', '    function feeToSetter() external view returns (address);\n', '\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '    function allPairs(uint) external view returns (address pair);\n', '    function allPairsLength() external view returns (uint);\n', '\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '\n', '    function setFeeTo(address) external;\n', '    function setFeeToSetter(address) external;\n', '}\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external pure returns (string memory);\n', '    function symbol() external pure returns (string memory);\n', '    function decimals() external pure returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32);\n', '    function PERMIT_TYPEHASH() external pure returns (bytes32);\n', '    function nonces(address owner) external view returns (uint);\n', '\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    event Mint(address indexed sender, uint amount0, uint amount1);\n', '    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n', '    event Swap(\n', '        address indexed sender,\n', '        uint amount0In,\n', '        uint amount1In,\n', '        uint amount0Out,\n', '        uint amount1Out,\n', '        address indexed to\n', '    );\n', '    event Sync(uint112 reserve0, uint112 reserve1);\n', '\n', '    function MINIMUM_LIQUIDITY() external pure returns (uint);\n', '    function factory() external view returns (address);\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '    function kLast() external view returns (uint);\n', '\n', '    function mint(address to) external returns (uint liquidity);\n', '    function burn(address to) external returns (uint amount0, uint amount1);\n', '    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n', '    function skim(address to) external;\n', '    function sync() external;\n', '\n', '    function initialize(address, address) external;\n', '}\n', '\n', 'contract UniswapV2Library {\n', '    // --- Math ---\n', '    function uniAddition(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x + y) >= x, 'UniswapV2Library: add-overflow');\n", '    }\n', '    function uniSubtract(uint x, uint y) internal pure returns (uint z) {\n', "        require((z = x - y) <= x, 'UniswapV2Library: sub-underflow');\n", '    }\n', '    function uniMultiply(uint x, uint y) internal pure returns (uint z) {\n', "        require(y == 0 || (z = x * y) / y == x, 'UniswapV2Library: mul-overflow');\n", '    }\n', '\n', '    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n', '    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\n', "        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\n", '        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n', "        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\n", '    }\n', '\n', '    // Modified Uniswap function to work with dapp.tools (CREATE2 throws)\n', '    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {\n', '        (address token0, address token1) = sortTokens(tokenA, tokenB);\n', '        return IUniswapV2Factory(factory).getPair(tokenA, tokenB);\n', '    }\n', '\n', '    // fetches and sorts the reserves for a pair; modified from the initial Uniswap version in order to work with dapp.tools\n', '    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\n', '        (address token0,) = sortTokens(tokenA, tokenB);\n', '        (uint reserve0, uint reserve1,) = IUniswapV2Pair(IUniswapV2Factory(factory).getPair(tokenA, tokenB)).getReserves();\n', '        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\n', '    }\n', '\n', '    // Given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n', '    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\n', "        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\n", "        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        amountB = uniMultiply(amountA, reserveB) / reserveA;\n', '    }\n', '\n', '    // Given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n', '    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\n', "        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint amountInWithFee = uniMultiply(amountIn, 997);\n', '        uint numerator = uniMultiply(amountInWithFee, reserveOut);\n', '        uint denominator = uniAddition(uniMultiply(reserveIn, 1000), amountInWithFee);\n', '        amountOut = numerator / denominator;\n', '    }\n', '\n', '    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n', '    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\n', "        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\n", "        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\n", '        uint numerator = uniMultiply(uniMultiply(reserveIn, amountOut), 1000);\n', '        uint denominator = uniMultiply(uniSubtract(reserveOut, amountOut), 997);\n', '        amountIn = uniAddition((numerator / denominator), 1);\n', '    }\n', '\n', '    // performs chained getAmountOut calculations on any number of pairs\n', '    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[0] = amountIn;\n', '        for (uint i; i < path.length - 1; i++) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\n', '            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '\n', '    // performs chained getAmountIn calculations on any number of pairs\n', '    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\n', "        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\n", '        amounts = new uint[](path.length);\n', '        amounts[amounts.length - 1] = amountOut;\n', '        for (uint i = path.length - 1; i > 0; i--) {\n', '            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\n', '            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n', '        }\n', '    }\n', '}\n', '\n', '// computes square roots using the babylonian method\n', '// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n', 'contract BabylonianMath {\n', '    function sqrt(uint y) internal pure returns (uint z) {\n', '        if (y > 3) {\n', '            z = y;\n', '            uint x = y / 2 + 1;\n', '            while (x < z) {\n', '                z = x;\n', '                x = (y / x + x) / 2;\n', '            }\n', '        } else if (y != 0) {\n', '            z = 1;\n', '        }\n', '        // else z = 0\n', '    }\n', '}\n', '\n', '// Contract for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n', 'contract FixedPointMath is BabylonianMath {\n', '    // range: [0, 2**112 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq112x112 {\n', '        uint224 _x;\n', '    }\n', '\n', '    // range: [0, 2**144 - 1]\n', '    // resolution: 1 / 2**112\n', '    struct uq144x112 {\n', '        uint _x;\n', '    }\n', '\n', '    uint8 private constant RESOLUTION = 112;\n', '    uint private constant Q112 = uint(1) << RESOLUTION;\n', '    uint private constant Q224 = Q112 << RESOLUTION;\n', '\n', '    // encode a uint112 as a UQ112x112\n', '    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n', '        return uq112x112(uint224(x) << RESOLUTION);\n', '    }\n', '\n', '    // encodes a uint144 as a UQ144x112\n', '    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n', '        return uq144x112(uint256(x) << RESOLUTION);\n', '    }\n', '\n', '    // divide a UQ112x112 by a uint112, returning a UQ112x112\n', '    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\n', "        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\n", '        return uq112x112(self._x / uint224(x));\n', '    }\n', '\n', '    // multiply a UQ112x112 by a uint, returning a UQ144x112\n', '    // reverts on overflow\n', '    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\n', '        uint z;\n', '        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), "FixedPoint: MULTIPLICATION_OVERFLOW");\n', '        return uq144x112(z);\n', '    }\n', '\n', '    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n', '    // equivalent to encode(numerator).divide(denominator)\n', '    function frac(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\n', '        require(denominator > 0, "FixedPoint: DIV_BY_ZERO");\n', '        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\n', '    }\n', '\n', '    // decode a UQ112x112 into a uint112 by truncating after the radix point\n', '    function decode(uq112x112 memory self) internal pure returns (uint112) {\n', '        return uint112(self._x >> RESOLUTION);\n', '    }\n', '\n', '    // decode a UQ144x112 into a uint144 by truncating after the radix point\n', '    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n', '        return uint144(self._x >> RESOLUTION);\n', '    }\n', '\n', '    // take the reciprocal of a UQ112x112\n', '    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n', "        require(self._x != 0, 'FixedPoint: ZERO_RECIPROCAL');\n", '        return uq112x112(uint224(Q224 / self._x));\n', '    }\n', '\n', '    // square root of a UQ112x112\n', '    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n', '        return uq112x112(uint224(super.sqrt(uint256(self._x)) << 56));\n', '    }\n', '}\n', '\n', '// Contract with helper methods for oracles that are concerned with computing average prices\n', 'contract UniswapV2OracleLibrary is FixedPointMath {\n', '    // Helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n', '    function currentBlockTimestamp() internal view returns (uint32) {\n', '        return uint32(block.timestamp % 2 ** 32);\n', '    }\n', '\n', '    // Produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n', '    function currentCumulativePrices(\n', '        address pair\n', '    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\n', '        blockTimestamp = currentBlockTimestamp();\n', '        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n', '        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n', '\n', '        // if time has elapsed since the last update on the pair, mock the accumulated price values\n', '        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\n', '        if (blockTimestampLast != blockTimestamp) {\n', '            // subtraction overflow is desired\n', '            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n', '            // addition overflow is desired\n', '            // counterfactual\n', '            price0Cumulative += uint(frac(reserve1, reserve0)._x) * timeElapsed;\n', '            // counterfactual\n', '            price1Cumulative += uint(frac(reserve0, reserve1)._x) * timeElapsed;\n', '        }\n', '    }\n', '}\n', '\n', 'abstract contract ConverterFeedLike {\n', '    function getResultWithValidity() virtual external view returns (uint256,bool);\n', '    function updateResult(address) virtual external;\n', '}\n', '\n', 'abstract contract IncreasingRewardRelayerLike {\n', '    function reimburseCaller(address) virtual external;\n', '}\n', '\n', 'contract UniswapConsecutiveSlotsPriceFeedMedianizer is GebMath, UniswapV2Library, UniswapV2OracleLibrary {\n', '    // --- Auth ---\n', '    mapping (address => uint) public authorizedAccounts;\n', '    /**\n', '     * @notice Add auth to an account\n', '     * @param account Account to add auth to\n', '     */\n', '    function addAuthorization(address account) virtual external isAuthorized {\n', '        authorizedAccounts[account] = 1;\n', '        emit AddAuthorization(account);\n', '    }\n', '    /**\n', '     * @notice Remove auth from an account\n', '     * @param account Account to remove auth from\n', '     */\n', '    function removeAuthorization(address account) virtual external isAuthorized {\n', '        authorizedAccounts[account] = 0;\n', '        emit RemoveAuthorization(account);\n', '    }\n', '    /**\n', '    * @notice Checks whether msg.sender can call an authed function\n', '    **/\n', '    modifier isAuthorized {\n', '        require(authorizedAccounts[msg.sender] == 1, "UniswapConsecutiveSlotsPriceFeedMedianizer/account-not-authorized");\n', '        _;\n', '    }\n', '\n', '    // --- Observations ---\n', '    struct UniswapObservation {\n', '        uint timestamp;\n', '        uint price0Cumulative;\n', '        uint price1Cumulative;\n', '    }\n', '    struct ConverterFeedObservation {\n', '        uint timestamp;\n', '        uint timeAdjustedPrice;\n', '    }\n', '\n', '    // --- Uniswap Vars ---\n', '    // Default amount of targetToken used when calculating the denominationToken output\n', '    uint256              public defaultAmountIn;\n', '    // Token for which the contract calculates the medianPrice for\n', '    address              public targetToken;\n', '    // Pair token from the Uniswap pair\n', '    address              public denominationToken;\n', '    address              public uniswapPair;\n', '\n', '    IUniswapV2Factory    public uniswapFactory;\n', '\n', '    UniswapObservation[] public uniswapObservations;\n', '\n', '    // --- Converter Feed Vars ---\n', '    // Latest converter price accumulator snapshot\n', '    uint256                    public converterPriceCumulative;\n', '\n', '    ConverterFeedLike          public converterFeed;\n', '    ConverterFeedObservation[] public converterFeedObservations;\n', '\n', '    // --- General Vars ---\n', '    // Symbol - you want to change this every deployment\n', '    bytes32 public symbol = "raiusd";\n', '\n', '    uint8   public granularity;\n', '    // When the price feed was last updated\n', '    uint256 public lastUpdateTime;\n', '    // Total number of updates\n', '    uint256 public updates;\n', '    /**\n', '      The ideal amount of time over which the moving average should be computed, e.g. 24 hours.\n', '      In practice it can and most probably will be different than the actual window over which the contract medianizes.\n', '    **/\n', '    uint256 public windowSize;\n', "    // Maximum window size used to determine if the median is 'valid' (close to the real one) or not\n", '    uint256 public maxWindowSize;\n', '    // Stored for gas savings. Equals windowSize / granularity\n', '    uint256 public periodSize;\n', '    // This is the denominator for computing\n', '    uint256 public converterFeedScalingFactor;\n', '    // The last computed median price\n', '    uint256 private medianPrice;\n', '    // Manual flag that can be set by governance and indicates if a result is valid or not\n', '    uint256 public validityFlag;\n', '\n', '    // Contract relaying the SF reward to addresses that update this oracle\n', '    IncreasingRewardRelayerLike public relayer;\n', '\n', '    // --- Events ---\n', '    event AddAuthorization(address account);\n', '    event RemoveAuthorization(address account);\n', '    event ModifyParameters(\n', '      bytes32 parameter,\n', '      address addr\n', '    );\n', '    event ModifyParameters(\n', '      bytes32 parameter,\n', '      uint256 val\n', '    );\n', '    event UpdateResult(uint256 medianPrice, uint256 lastUpdateTime);\n', '    event FailedConverterFeedUpdate(bytes reason);\n', '    event FailedUniswapPairSync(bytes reason);\n', '\n', '    constructor(\n', '      address converterFeed_,\n', '      address uniswapFactory_,\n', '      uint256 defaultAmountIn_,\n', '      uint256 windowSize_,\n', '      uint256 converterFeedScalingFactor_,\n', '      uint256 maxWindowSize_,\n', '      uint8   granularity_\n', '    ) public {\n', '        require(uniswapFactory_ != address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/null-uniswap-factory");\n', "        require(granularity_ > 1, 'UniswapConsecutiveSlotsPriceFeedMedianizer/null-granularity');\n", "        require(windowSize_ > 0, 'UniswapConsecutiveSlotsPriceFeedMedianizer/null-window-size');\n", "        require(maxWindowSize_ > windowSize_, 'UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-max-window-size');\n", "        require(defaultAmountIn_ > 0, 'UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-default-amount-in');\n", "        require(converterFeedScalingFactor_ > 0, 'UniswapConsecutiveSlotsPriceFeedMedianizer/null-feed-scaling-factor');\n", '        require(\n', '            (periodSize = windowSize_ / granularity_) * granularity_ == windowSize_,\n', "            'UniswapConsecutiveSlotsPriceFeedMedianizer/window-not-evenly-divisible'\n", '        );\n', '\n', '        authorizedAccounts[msg.sender] = 1;\n', '\n', '        converterFeed                  = ConverterFeedLike(converterFeed_);\n', '        uniswapFactory                 = IUniswapV2Factory(uniswapFactory_);\n', '        defaultAmountIn                = defaultAmountIn_;\n', '        windowSize                     = windowSize_;\n', '        maxWindowSize                  = maxWindowSize_;\n', '        converterFeedScalingFactor     = converterFeedScalingFactor_;\n', '        granularity                    = granularity_;\n', '        lastUpdateTime                 = now;\n', '        validityFlag                   = 1;\n', '\n', '        // Emit events\n', '        emit AddAuthorization(msg.sender);\n', '        emit ModifyParameters(bytes32("converterFeed"), converterFeed_);\n', '        emit ModifyParameters(bytes32("maxWindowSize"), maxWindowSize_);\n', '    }\n', '\n', '    // --- Administration ---\n', '    /**\n', '    * @notice Modify the converter feed address\n', '    * @param parameter Name of the parameter to modify\n', '    * @param data New parameter value\n', '    **/\n', '    function modifyParameters(bytes32 parameter, address data) external isAuthorized {\n', '        require(data != address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/null-data");\n', '        if (parameter == "converterFeed") {\n', '          require(data != address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/null-converter-feed");\n', '          converterFeed = ConverterFeedLike(data);\n', '        }\n', '        else if (parameter == "targetToken") {\n', '          require(uniswapPair == address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/pair-already-set");\n', '          targetToken = data;\n', '          if (denominationToken != address(0)) {\n', '            uniswapPair = uniswapFactory.getPair(targetToken, denominationToken);\n', '            require(uniswapPair != address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/null-uniswap-pair");\n', '          }\n', '        }\n', '        else if (parameter == "denominationToken") {\n', '          require(uniswapPair == address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/pair-already-set");\n', '          denominationToken = data;\n', '          if (targetToken != address(0)) {\n', '            uniswapPair = uniswapFactory.getPair(targetToken, denominationToken);\n', '            require(uniswapPair != address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/null-uniswap-pair");\n', '          }\n', '        }\n', '        else if (parameter == "relayer") {\n', '          relayer = IncreasingRewardRelayerLike(data);\n', '        }\n', '        else revert("UniswapConsecutiveSlotsPriceFeedMedianizer/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '    function modifyParameters(bytes32 parameter, uint256 data) external isAuthorized {\n', '        if (parameter == "validityFlag") {\n', '          require(either(data == 1, data == 0), "UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-data");\n', '          validityFlag = data;\n', '        }\n', '        else if (parameter == "defaultAmountIn") {\n', '          require(data > 0, "UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-default-amount-in");\n', '          defaultAmountIn = data;\n', '        }\n', '        else if (parameter == "maxWindowSize") {\n', "          require(data > windowSize, 'UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-max-window-size');\n", '          maxWindowSize = data;\n', '        }\n', '        else revert("UniswapConsecutiveSlotsPriceFeedMedianizer/modify-unrecognized-param");\n', '        emit ModifyParameters(parameter, data);\n', '    }\n', '\n', '    // --- General Utils ---\n', '    function either(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := or(x, y)}\n', '    }\n', '    function both(bool x, bool y) private pure returns (bool z) {\n', '        assembly{ z := and(x, y)}\n', '    }\n', '    /**\n', '    * @notice Returns the oldest observations (relative to the current index in the Uniswap/Converter lists)\n', '    **/\n', '    function getFirstObservationsInWindow()\n', '      private view returns (UniswapObservation storage firstUniswapObservation, ConverterFeedObservation storage firstConverterFeedObservation) {\n', '        uint256 earliestObservationIndex = earliestObservationIndex();\n', '        firstUniswapObservation          = uniswapObservations[earliestObservationIndex];\n', '        firstConverterFeedObservation    = converterFeedObservations[earliestObservationIndex];\n', '    }\n', '    /**\n', '      @notice It returns the time passed since the first observation in the window\n', '    **/\n', '    function timeElapsedSinceFirstObservation() public view returns (uint256) {\n', '        if (updates > 1) {\n', '          (\n', '            UniswapObservation storage firstUniswapObservation,\n', '          ) = getFirstObservationsInWindow();\n', '          return subtract(now, firstUniswapObservation.timestamp);\n', '        }\n', '        return 0;\n', '    }\n', '    /**\n', '    * @notice Calculate the median price using the latest observations and the latest Uniswap pair prices\n', '    * @param price0Cumulative Cumulative price for the first token in the pair\n', '    * @param price1Cumulative Cumulative price for the second token in the pair\n', '    **/\n', '    function getMedianPrice(uint256 price0Cumulative, uint256 price1Cumulative) private view returns (uint256) {\n', '        if (updates > 1) {\n', '          (\n', '            UniswapObservation storage firstUniswapObservation,\n', '          ) = getFirstObservationsInWindow();\n', '\n', '          uint timeSinceFirst = subtract(now, firstUniswapObservation.timestamp);\n', '          (address token0,)   = sortTokens(targetToken, denominationToken);\n', '          uint256 uniswapAmountOut;\n', '\n', '          if (token0 == targetToken) {\n', '              uniswapAmountOut = uniswapComputeAmountOut(\n', '                firstUniswapObservation.price0Cumulative, price0Cumulative, timeSinceFirst, defaultAmountIn\n', '              );\n', '          } else {\n', '              uniswapAmountOut = uniswapComputeAmountOut(\n', '                firstUniswapObservation.price1Cumulative, price1Cumulative, timeSinceFirst, defaultAmountIn\n', '              );\n', '          }\n', '\n', '          return converterComputeAmountOut(timeSinceFirst, uniswapAmountOut);\n', '        }\n', '\n', '        return medianPrice;\n', '    }\n', '    /**\n', '    * @notice Returns the index of the earliest observation in the window\n', '    **/\n', '    function earliestObservationIndex() public view returns (uint256) {\n', '        if (updates <= granularity) {\n', '          return 0;\n', '        }\n', '        return subtract(updates, uint(granularity));\n', '    }\n', '    /**\n', '    * @notice Get the observation list length\n', '    **/\n', '    function getObservationListLength() public view returns (uint256, uint256) {\n', '        return (uniswapObservations.length, converterFeedObservations.length);\n', '    }\n', '\n', '    // --- Uniswap Utils ---\n', '    /**\n', '    * @notice Given the Uniswap cumulative prices of the start and end of a period, and the length of the period, compute the average\n', '    *         price in terms of how much amount out is received for the amount in.\n', '    * @param priceCumulativeStart Old snapshot of the cumulative price of a token\n', '    * @param priceCumulativeEnd New snapshot of the cumulative price of a token\n', '    * @param timeElapsed Total time elapsed\n', '    * @param amountIn Amount of target tokens we want to find the price for\n', '    **/\n', '    function uniswapComputeAmountOut(\n', '        uint256 priceCumulativeStart,\n', '        uint256 priceCumulativeEnd,\n', '        uint256 timeElapsed,\n', '        uint256 amountIn\n', '    ) public pure returns (uint256 amountOut) {\n', '        require(priceCumulativeEnd >= priceCumulativeStart, "UniswapConverterBasicAveragePriceFeedMedianizer/invalid-end-cumulative");\n', '        require(timeElapsed > 0, "UniswapConsecutiveSlotsPriceFeedMedianizer/null-time-elapsed");\n', '        // Overflow is desired\n', '        uq112x112 memory priceAverage = uq112x112(\n', '            uint224((priceCumulativeEnd - priceCumulativeStart) / timeElapsed)\n', '        );\n', '        amountOut = decode144(mul(priceAverage, amountIn));\n', '    }\n', '\n', '    // --- Converter Utils ---\n', '    /**\n', '    * @notice Calculate the price of an amount of tokens using the converter price feed as well as the time elapsed between\n', '    *         the latest timestamp and the timestamp of the earliest observation in the window.\n', '    *         Used after the contract determines the amount of Uniswap pair denomination tokens for amountIn target tokens\n', '    * @param timeElapsed Time elapsed between now and the earliest observation in the window.\n', '    * @param amountIn Amount of denomination tokens to calculate the price for\n', '    **/\n', '    function converterComputeAmountOut(\n', '        uint256 timeElapsed,\n', '        uint256 amountIn\n', '    ) public view returns (uint256 amountOut) {\n', '        require(timeElapsed > 0, "UniswapConsecutiveSlotsPriceFeedMedianizer/null-time-elapsed");\n', '        uint256 priceAverage = converterPriceCumulative / timeElapsed;\n', '        amountOut            = multiply(amountIn, priceAverage) / converterFeedScalingFactor;\n', '    }\n', '\n', '    // --- Core Logic ---\n', '    /**\n', '    * @notice Update the internal median price\n', '    **/\n', '    function updateResult(address feeReceiver) external {\n', '        require(address(relayer) != address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/null-relayer");\n', '        require(uniswapPair != address(0), "UniswapConsecutiveSlotsPriceFeedMedianizer/null-uniswap-pair");\n', '\n', '        // Get final fee receiver\n', '        address finalFeeReceiver = (feeReceiver == address(0)) ? msg.sender : feeReceiver;\n', '\n', "        // Update the converter's median price first\n", '        try converterFeed.updateResult(finalFeeReceiver) {}\n', '        catch (bytes memory converterRevertReason) {\n', '          emit FailedConverterFeedUpdate(converterRevertReason);\n', '        }\n', '\n', '        // Get the observation for the current period\n', '        uint256 timeElapsedSinceLatest = (uniswapObservations.length == 0) ?\n', '          subtract(now, lastUpdateTime) : subtract(now, uniswapObservations[uniswapObservations.length - 1].timestamp);\n', '        // We only want to commit updates once per period (i.e. windowSize / granularity)\n', '        if (uniswapObservations.length > 0) {\n', '          require(timeElapsedSinceLatest >= periodSize, "UniswapConsecutiveSlotsPriceFeedMedianizer/not-enough-time-elapsed");\n', '        }\n', '\n', '        // Update Uniswap pair\n', '        try IUniswapV2Pair(uniswapPair).sync() {}\n', '        catch (bytes memory uniswapRevertReason) {\n', '          emit FailedUniswapPairSync(uniswapRevertReason);\n', '        }\n', '\n', '        // Get the last update time used when calculating the reward\n', '        uint256 rewardCalculationLastUpdateTime = (uniswapObservations.length == 0) ? 0 : lastUpdateTime;\n', '\n', '        // Get Uniswap cumulative prices\n', '        (uint uniswapPrice0Cumulative, uint uniswapPrice1Cumulative,) = currentCumulativePrices(uniswapPair);\n', '\n', '        // Add new observations\n', '        updateObservations(timeElapsedSinceLatest, uniswapPrice0Cumulative, uniswapPrice1Cumulative);\n', '\n', '        // Calculate latest medianPrice\n', '        medianPrice    = getMedianPrice(uniswapPrice0Cumulative, uniswapPrice1Cumulative);\n', '        lastUpdateTime = now;\n', '        updates        = addition(updates, 1);\n', '\n', '        emit UpdateResult(medianPrice, lastUpdateTime);\n', '\n', '        // Reward caller\n', '        relayer.reimburseCaller(finalFeeReceiver);\n', '    }\n', '    /**\n', '    * @notice Push new observation data in the observation arrays\n', '    * @param timeElapsedSinceLatest Time elapsed between now and the earliest observation in the window\n', '    * @param uniswapPrice0Cumulative Latest cumulative price of the first token in a Uniswap pair\n', '    * @param uniswapPrice1Cumulative Latest cumulative price of the second tokens in a Uniswap pair\n', '    **/\n', '    function updateObservations(\n', '      uint256 timeElapsedSinceLatest,\n', '      uint256 uniswapPrice0Cumulative,\n', '      uint256 uniswapPrice1Cumulative\n', '    ) internal {\n', '        // Add converter feed observation\n', '        (uint256 priceFeedValue, bool hasValidValue) = converterFeed.getResultWithValidity();\n', '        require(hasValidValue, "UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-converter-price-feed");\n', '        uint256 newTimeAdjustedPrice = multiply(priceFeedValue, timeElapsedSinceLatest);\n', '\n', '        // Add converter observation\n', '        converterFeedObservations.push(ConverterFeedObservation(now, newTimeAdjustedPrice));\n', '        // Add Uniswap observation\n', '        uniswapObservations.push(UniswapObservation(now, uniswapPrice0Cumulative, uniswapPrice1Cumulative));\n', '\n', '        // Add the new update\n', '        converterPriceCumulative = addition(converterPriceCumulative, newTimeAdjustedPrice);\n', '\n', '        // Subtract the earliest update\n', '        if (updates >= granularity) {\n', '          (\n', '            ,\n', '            ConverterFeedObservation storage firstConverterFeedObservation\n', '          ) = getFirstObservationsInWindow();\n', '          converterPriceCumulative = subtract(converterPriceCumulative, firstConverterFeedObservation.timeAdjustedPrice);\n', '        }\n', '    }\n', '\n', '    // --- Getters ---\n', '    /**\n', '    * @notice Fetch the latest medianPrice or revert if is is null\n', '    **/\n', '    function read() external view returns (uint256) {\n', '        require(\n', '          both(both(both(medianPrice > 0, updates > granularity), timeElapsedSinceFirstObservation() <= maxWindowSize), validityFlag == 1),\n', '          "UniswapConsecutiveSlotsPriceFeedMedianizer/invalid-price-feed"\n', '        );\n', '        return medianPrice;\n', '    }\n', '    /**\n', '    * @notice Fetch the latest medianPrice and whether it is null or not\n', '    **/\n', '    function getResultWithValidity() external view returns (uint256, bool) {\n', '        return (\n', '          medianPrice,\n', '          both(both(both(medianPrice > 0, updates > granularity), timeElapsedSinceFirstObservation() <= maxWindowSize), validityFlag == 1)\n', '        );\n', '    }\n', '}\n', '\n', 'abstract contract StabilityFeeTreasuryLike {\n', '    function getAllowance(address) virtual external view returns (uint, uint);\n', '    function systemCoin() virtual external view returns (address);\n', '    function pullFunds(address, address, uint) virtual external;\n', '    function setTotalAllowance(address, uint256) external virtual;\n', '    function setPerBlockAllowance(address, uint256) external virtual;\n', '}\n', '\n', 'contract IncreasingTreasuryReimbursement is GebMath {\n', '    // --- Auth ---\n', '    mapping (address => uint) public authorizedAccounts;\n', '    /**\n', '     * @notice Add auth to an account\n', '     * @param account Account to add auth to\n', '     */\n', '    function addAuthorization(address account) virtual external isAuthorized {\n', '        authorizedAccounts[account] = 1;\n', '        emit AddAuthorization(account);\n', '    }\n', '    /**\n', '     * @notice Remove auth from an account\n', '     * @param account Account to remove auth from\n', '     */\n', '    function removeAuthorization(address account) virtual external isAuthorized {\n', '        authorizedAccounts[account] = 0;\n', '        emit RemoveAuthorization(account);\n', '    }\n', '    /**\n', '    * @notice Checks whether msg.sender can call an authed function\n', '    **/\n', '    modifier isAuthorized {\n', '        require(authorizedAccounts[msg.sender] == 1, "IncreasingTreasuryReimbursement/account-not-authorized");\n', '        _;\n', '    }\n', '\n', '    // --- Variables ---\n', '    // Starting reward for the fee receiver/keeper\n', '    uint256 public baseUpdateCallerReward;          // [wad]\n', '    // Max possible reward for the fee receiver/keeper\n', '    uint256 public maxUpdateCallerReward;           // [wad]\n', '    // Max delay taken into consideration when calculating the adjusted reward\n', '    uint256 public maxRewardIncreaseDelay;          // [seconds]\n', '    // Rate applied to baseUpdateCallerReward every extra second passed beyond a certain point (e.g next time when a specific function needs to be called)\n', '    uint256 public perSecondCallerRewardIncrease;   // [ray]\n', '\n', '    // SF treasury\n', '    StabilityFeeTreasuryLike  public treasury;\n', '\n', '    // --- Events ---\n', '    event AddAuthorization(address account);\n', '    event RemoveAuthorization(address account);\n', '    event ModifyParameters(\n', '      bytes32 parameter,\n', '      address addr\n', '    );\n', '    event ModifyParameters(\n', '      bytes32 parameter,\n', '      uint256 val\n', '    );\n', '    event FailRewardCaller(bytes revertReason, address feeReceiver, uint256 amount);\n', '\n', '    constructor(\n', '      address treasury_,\n', '      uint256 baseUpdateCallerReward_,\n', '      uint256 maxUpdateCallerReward_,\n', '      uint256 perSecondCallerRewardIncrease_\n', '    ) public {\n', '        if (address(treasury_) != address(0)) {\n', '          require(StabilityFeeTreasuryLike(treasury_).systemCoin() != address(0), "IncreasingTreasuryReimbursement/treasury-coin-not-set");\n', '        }\n', '        require(maxUpdateCallerReward_ >= baseUpdateCallerReward_, "IncreasingTreasuryReimbursement/invalid-max-caller-reward");\n', '        require(perSecondCallerRewardIncrease_ >= RAY, "IncreasingTreasuryReimbursement/invalid-per-second-reward-increase");\n', '        authorizedAccounts[msg.sender] = 1;\n', '\n', '        treasury                        = StabilityFeeTreasuryLike(treasury_);\n', '        baseUpdateCallerReward          = baseUpdateCallerReward_;\n', '        maxUpdateCallerReward           = maxUpdateCallerReward_;\n', '        perSecondCallerRewardIncrease   = perSecondCallerRewardIncrease_;\n', '        maxRewardIncreaseDelay          = uint(-1);\n', '\n', '        emit AddAuthorization(msg.sender);\n', '        emit ModifyParameters("treasury", treasury_);\n', '        emit ModifyParameters("baseUpdateCallerReward", baseUpdateCallerReward);\n', '        emit ModifyParameters("maxUpdateCallerReward", maxUpdateCallerReward);\n', '        emit ModifyParameters("perSecondCallerRewardIncrease", perSecondCallerRewardIncrease);\n', '    }\n', '\n', '    // --- Boolean Logic ---\n', '    function either(bool x, bool y) internal pure returns (bool z) {\n', '        assembly{ z := or(x, y)}\n', '    }\n', '\n', '    // --- Treasury ---\n', '    /**\n', '    * @notice This returns the stability fee treasury allowance for this contract by taking the minimum between the per block and the total allowances\n', '    **/\n', '    function treasuryAllowance() public view returns (uint256) {\n', '        (uint total, uint perBlock) = treasury.getAllowance(address(this));\n', '        return minimum(total, perBlock);\n', '    }\n', '    /*\n', '    * @notice Get the SF reward that can be sent to a function caller right now\n', '    * @param timeOfLastUpdate The last time when the function that the treasury pays for has been updated\n', '    * @param defaultDelayBetweenCalls Enforced delay between calls to the function for which the treasury reimburses callers\n', '    */\n', '    function getCallerReward(uint256 timeOfLastUpdate, uint256 defaultDelayBetweenCalls) public view returns (uint256) {\n', '        // If the rewards are null or if the time of the last update is in the future or present, return 0\n', '        bool nullRewards = (baseUpdateCallerReward == 0 && maxUpdateCallerReward == 0);\n', '        if (either(timeOfLastUpdate >= now, nullRewards)) return 0;\n', '\n', '        // If the time elapsed is smaller than defaultDelayBetweenCalls or if the base reward is zero, return 0\n', '        uint256 timeElapsed = (timeOfLastUpdate == 0) ? defaultDelayBetweenCalls : subtract(now, timeOfLastUpdate);\n', '        if (either(timeElapsed < defaultDelayBetweenCalls, baseUpdateCallerReward == 0)) {\n', '            return 0;\n', '        }\n', '\n', '        // If too much time elapsed, return the max reward\n', '        uint256 adjustedTime      = subtract(timeElapsed, defaultDelayBetweenCalls);\n', '        uint256 maxPossibleReward = minimum(maxUpdateCallerReward, treasuryAllowance() / RAY);\n', '        if (adjustedTime > maxRewardIncreaseDelay) {\n', '            return maxPossibleReward;\n', '        }\n', '\n', '        // Calculate the reward\n', '        uint256 calculatedReward = baseUpdateCallerReward;\n', '        if (adjustedTime > 0) {\n', '            calculatedReward = rmultiply(rpower(perSecondCallerRewardIncrease, adjustedTime, RAY), calculatedReward);\n', '        }\n', '\n', '        // If the reward is higher than max, set it to max\n', '        if (calculatedReward > maxPossibleReward) {\n', '            calculatedReward = maxPossibleReward;\n', '        }\n', '        return calculatedReward;\n', '    }\n', '    /**\n', '    * @notice Send a stability fee reward to an address\n', '    * @param proposedFeeReceiver The SF receiver\n', '    * @param reward The system coin amount to send\n', '    **/\n', '    function rewardCaller(address proposedFeeReceiver, uint256 reward) internal {\n', '        // If the receiver is the treasury itself or if the treasury is null or if the reward is zero, return\n', '        if (address(treasury) == proposedFeeReceiver) return;\n', '        if (either(address(treasury) == address(0), reward == 0)) return;\n', '\n', '        // Determine the actual receiver and send funds\n', '        address finalFeeReceiver = (proposedFeeReceiver == address(0)) ? msg.sender : proposedFeeReceiver;\n', '        try treasury.pullFunds(finalFeeReceiver, treasury.systemCoin(), reward) {}\n', '        catch(bytes memory revertReason) {\n', '            emit FailRewardCaller(revertReason, finalFeeReceiver, reward);\n', '        }\n', '    }\n', '}\n', '\n', '\n', 'contract IncreasingRewardRelayer is IncreasingTreasuryReimbursement {\n', '    // --- Variables ---\n', '    // Address that can request funds\n', '    address public refundRequestor;\n', '    // Timestamp of the last reimbursement\n', '    uint256 public lastReimburseTime;       // [timestamp]\n', '    // Enforced gap between reimbursements\n', '    uint256 public reimburseDelay;          // [seconds]\n', '\n', '    constructor(\n', '      address refundRequestor_,\n', '      address treasury_,\n', '      uint256 baseUpdateCallerReward_,\n', '      uint256 maxUpdateCallerReward_,\n', '      uint256 perSecondCallerRewardIncrease_,\n', '      uint256 reimburseDelay_\n', '    ) public IncreasingTreasuryReimbursement(treasury_, baseUpdateCallerReward_, maxUpdateCallerReward_, perSecondCallerRewardIncrease_) {\n', '        require(refundRequestor_ != address(0), "IncreasingRewardRelayer/null-refund-requestor");\n', '        require(reimburseDelay_ > 0, "IncreasingRewardRelayer/null-reimburse-delay");\n', '\n', '        refundRequestor = refundRequestor_;\n', '        reimburseDelay  = reimburseDelay_;\n', '\n', '        emit ModifyParameters("refundRequestor", refundRequestor);\n', '        emit ModifyParameters("reimburseDelay", reimburseDelay);\n', '    }\n', '\n', '    // --- Administration ---\n', '    /*\n', '    * @notice Change the addresses of contracts that this wrapper is connected to\n', '    * @param parameter The contract whose address is changed\n', '    * @param addr The new contract address\n', '    */\n', '    function modifyParameters(bytes32 parameter, address addr) external isAuthorized {\n', '        require(addr != address(0), "IncreasingRewardRelayer/null-addr");\n', '        if (parameter == "treasury") {\n', '          require(StabilityFeeTreasuryLike(addr).systemCoin() != address(0), "IncreasingRewardRelayer/treasury-coin-not-set");\n', '          treasury = StabilityFeeTreasuryLike(addr);\n', '        } else if (parameter == "refundRequestor") {\n', '          refundRequestor = addr;\n', '        }\n', '        else revert("IncreasingRewardRelayer/modify-unrecognized-param");\n', '        emit ModifyParameters(\n', '          parameter,\n', '          addr\n', '        );\n', '    }\n', '    /*\n', '    * @notify Modify a uint256 parameter\n', '    * @param parameter The parameter name\n', '    * @param val The new parameter value\n', '    */\n', '    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\n', '        if (parameter == "baseUpdateCallerReward") {\n', '          require(val <= maxUpdateCallerReward, "IncreasingRewardRelayer/invalid-base-caller-reward");\n', '          baseUpdateCallerReward = val;\n', '        }\n', '        else if (parameter == "maxUpdateCallerReward") {\n', '          require(val >= baseUpdateCallerReward, "IncreasingRewardRelayer/invalid-max-caller-reward");\n', '          maxUpdateCallerReward = val;\n', '        }\n', '        else if (parameter == "perSecondCallerRewardIncrease") {\n', '          require(val >= RAY, "IncreasingRewardRelayer/invalid-caller-reward-increase");\n', '          perSecondCallerRewardIncrease = val;\n', '        }\n', '        else if (parameter == "maxRewardIncreaseDelay") {\n', '          require(val > 0, "IncreasingRewardRelayer/invalid-max-increase-delay");\n', '          maxRewardIncreaseDelay = val;\n', '        }\n', '        else if (parameter == "reimburseDelay") {\n', '          require(val > 0, "IncreasingRewardRelayer/invalid-reimburse-delay");\n', '          reimburseDelay = val;\n', '        }\n', '        else revert("IncreasingRewardRelayer/modify-unrecognized-param");\n', '        emit ModifyParameters(\n', '          parameter,\n', '          val\n', '        );\n', '    }\n', '\n', '    // --- Core Logic ---\n', '    /*\n', '    * @notice Send a stability fee reward to an address proposed by the refundRequestor\n', '    * @param feeReceiver Address that will receive the SF reward\n', '    */\n', '    function reimburseCaller(address feeReceiver) external {\n', '        // Perform checks\n', '        require(refundRequestor == msg.sender, "IncreasingRewardRelayer/invalid-caller");\n', '        require(feeReceiver != address(0), "IncreasingRewardRelayer/null-fee-receiver");\n', '        require(feeReceiver != refundRequestor, "IncreasingRewardRelayer/requestor-cannot-receive-fees");\n', '        // Check delay between calls\n', '        require(either(subtract(now, lastReimburseTime) >= reimburseDelay, lastReimburseTime == 0), "IncreasingRewardRelayer/wait-more");\n', "        // Get the caller's reward\n", '        uint256 callerReward = getCallerReward(lastReimburseTime, reimburseDelay);\n', '        // Store the timestamp of the reimbursement\n', '        lastReimburseTime = now;\n', '        // Pay the fee receiver\n', '        rewardCaller(feeReceiver, callerReward);\n', '    }\n', '}\n', '\n', 'abstract contract OldTwapLike is UniswapConsecutiveSlotsPriceFeedMedianizer {\n', '    function treasury() public virtual returns (address);\n', '}\n', '\n', '// @notice Proposal to deploy and setup a new Uniswap TWAP\n', '// @notice The contract will be deployed/setup, but not yet connected to the system (to allow for testing)\n', '// Missing steps:\n', '// - Connect to the RateSetter\n', 'contract DeployUniswapTWAP {\n', '    // --- Variables ---\n', '    uint256 public constant RAY = 10**27;\n', '\n', '    function execute(address oldTwapAddress) public returns (address, address) {\n', '        OldTwapLike oldTwap               = OldTwapLike(oldTwapAddress);\n', '        StabilityFeeTreasuryLike treasury = StabilityFeeTreasuryLike(oldTwap.treasury());\n', '\n', '        // deploy new TWAP\n', '        UniswapConsecutiveSlotsPriceFeedMedianizer newTwap = new UniswapConsecutiveSlotsPriceFeedMedianizer(\n', '            address(oldTwap.converterFeed()),\n', '            address(oldTwap.uniswapFactory()),\n', '            oldTwap.defaultAmountIn(),\n', '            64800, // windowSize\n', '            oldTwap.converterFeedScalingFactor(),\n', '            86400, // maxWindowSize\n', '            3      // granularity\n', '        );\n', '\n', '        newTwap.modifyParameters("targetToken", oldTwap.targetToken());\n', '        newTwap.modifyParameters("denominationToken", oldTwap.denominationToken());\n', '\n', '        // deploy increasing reward relayer\n', '        IncreasingRewardRelayer rewardRelayer = new IncreasingRewardRelayer(\n', '            address(newTwap), // refundRequestor\n', '            address(oldTwap.treasury()),\n', '            0.0001 ether,     // baseUpdateCallerReward\n', '            0.0001 ether,     // maxUpdateCallerReward\n', '            1 * RAY,          // perSecondCallerRewardIncrease,\n', '            21600             // reimburseDelay\n', '        );\n', '\n', '        rewardRelayer.modifyParameters("maxRewardIncreaseDelay", 10800);\n', '\n', '        // setting relayer in the TWAP\n', '        newTwap.modifyParameters("relayer", address(rewardRelayer));\n', '\n', '        // Setup treasury allowance\n', '        treasury.setTotalAllowance(address(oldTwap), 0);\n', '        treasury.setPerBlockAllowance(address(oldTwap), 0);\n', '\n', '        treasury.setTotalAllowance(address(rewardRelayer), uint(-1));\n', '        treasury.setPerBlockAllowance(address(rewardRelayer), 0.0001 ether * RAY);\n', '\n', '        return (address(newTwap), address(rewardRelayer));\n', '    }\n', '}']