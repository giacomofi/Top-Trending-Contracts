['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-11\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2018-12-08\n', '*/\n', '\n', '// Built off of https://github.com/DeltaBalances/DeltaBalances.github.io/blob/master/smart_contract/deltabalances.sol\n', 'pragma solidity ^0.4.21;\n', '\n', '// ERC20 contract interface\n', 'contract Token {\n', '  function balanceOf(address) public view returns (uint);\n', '  function allowance(address,address) public view returns (uint);\n', '}\n', '\n', 'contract BalanceChecker {\n', "  /* Fallback function, don't accept any ETH */\n", '  function() public payable {\n', '    revert("BalanceChecker does not accept payments");\n', '  }\n', '\n', '  /*\n', '    Check the token balance of a wallet in a token contract\n', '\n', '    Returns the balance of the token for user. Avoids possible errors:\n', '      - return 0 on non-contract address \n', "      - returns 0 if the contract doesn't implement balanceOf\n", '  */\n', '  function tokenBalance(address user, address token) public view returns (uint) {\n', '    // check if token is actually a contract\n', '    uint256 tokenCode;\n', '    assembly { tokenCode := extcodesize(token) } // contract code size\n', '  \n', '    // is it a contract and does it implement balanceOf \n', '    if (tokenCode > 0 && token.call(bytes4(0x70a08231), user)) {  \n', '      return Token(token).balanceOf(user);\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '\n', '  function tokenAllowance(address owner, address spender, address token) public view returns (uint) {\n', '    // check if token is actually a contract\n', '    uint256 tokenCode;\n', '    assembly { tokenCode := extcodesize(token) } // contract code size\n', '  \n', '    // is it a contract and does it implement balanceOf \n', '    if (tokenCode > 0 && token.call(bytes4(0xdd62ed3e), owner, spender)) {  \n', '      return Token(token).allowance(owner,spender);\n', '    } else {\n', '      return 0;\n', '    }\n', '  }\n', '  /*\n', '    Check the token balances of a wallet for multiple tokens.\n', '    Pass 0x0 as a "token" address to get ETH balance.\n', '\n', '    Possible error throws:\n', '      - extremely large arrays for user and or tokens (gas cost too high) \n', '          \n', "    Returns a one-dimensional that's user.length * tokens.length long. The\n", '    array is ordered by all of the 0th users token balances, then the 1th\n', '    user, and so on.\n', '  */\n', '  function balances(address[] users, address[] tokens) external view returns (uint[]) {\n', '    uint[] memory addrBalances = new uint[](tokens.length * users.length);\n', '    \n', '    for(uint i = 0; i < users.length; i++) {\n', '      for (uint j = 0; j < tokens.length; j++) {\n', '        uint addrIdx = j + tokens.length * i;\n', '        if (tokens[j] != address(0x0)) { \n', '          addrBalances[addrIdx] = tokenBalance(users[i], tokens[j]);\n', '        } else {\n', '          addrBalances[addrIdx] = users[i].balance;   \n', '        }\n', '      }  \n', '    }\n', '  \n', '    return addrBalances;\n', '  }\n', 'function allowances(address[] users, address spender, address token) external view returns (uint[]) {\n', '    uint[] memory _allowances = new uint[](users.length);\n', '    \n', '    for (uint i = 0; i < users.length; i++) {\n', '        if (token != address(0x0)) { \n', '            _allowances[i] = tokenAllowance(users[i], spender, token);\n', '        } else {\n', '            _allowances[i] = Token(0x0).allowance(users[i],spender); \n', '        }\n', '    }  \n', '    return _allowances;\n', '  }\n', '}']