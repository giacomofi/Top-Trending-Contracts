['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-14\n', '*/\n', '\n', '// File: contracts\\amm-aggregator\\common\\AMMData.sol\n', '\n', '//SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct LiquidityPoolData {\n', '    address liquidityPoolAddress;\n', '    uint256 amount;\n', '    address tokenAddress;\n', '    bool amountIsLiquidityPool;\n', '    bool involvingETH;\n', '    address receiver;\n', '}\n', '\n', 'struct SwapData {\n', '    bool enterInETH;\n', '    bool exitInETH;\n', '    address[] liquidityPoolAddresses;\n', '    address[] path;\n', '    address inputToken;\n', '    uint256 amount;\n', '    address receiver;\n', '}\n', '\n', '// File: contracts\\amm-aggregator\\common\\IAMM.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', 'pragma abicoder v2;\n', '\n', '\n', 'interface IAMM {\n', '\n', '    event NewLiquidityPoolAddress(address indexed);\n', '\n', '    function info() external view returns(string memory name, uint256 version);\n', '\n', '    function data() external view returns(address ethereumAddress, uint256 maxTokensPerLiquidityPool, bool hasUniqueLiquidityPools);\n', '\n', '    function balanceOf(address liquidityPoolAddress, address owner) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPool(address liquidityPoolAddress) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function byTokens(address[] calldata liquidityPoolTokens) external view returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function byPercentage(address liquidityPoolAddress, uint256 numerator, uint256 denominator) external view returns (uint256, uint256[] memory, address[] memory);\n', '\n', '    function byLiquidityPoolAmount(address liquidityPoolAddress, uint256 liquidityPoolAmount) external view returns(uint256[] memory, address[] memory);\n', '\n', '    function byTokenAmount(address liquidityPoolAddress, address tokenAddress, uint256 tokenAmount) external view returns(uint256, uint256[] memory, address[] memory);\n', '\n', '    function createLiquidityPoolAndAddLiquidity(address[] calldata tokenAddresses, uint256[] calldata amounts, bool involvingETH, address receiver) external payable returns(uint256, uint256[] memory, address, address[] memory);\n', '\n', '    function addLiquidity(LiquidityPoolData calldata data) external payable returns(uint256, uint256[] memory, address[] memory);\n', '    function addLiquidityBatch(LiquidityPoolData[] calldata data) external payable returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function removeLiquidity(LiquidityPoolData calldata data) external returns(uint256, uint256[] memory, address[] memory);\n', '    function removeLiquidityBatch(LiquidityPoolData[] calldata data) external returns(uint256[] memory, uint256[][] memory, address[][] memory);\n', '\n', '    function getSwapOutput(address tokenAddress, uint256 tokenAmount, address[] calldata, address[] calldata path) view external returns(uint256[] memory);\n', '\n', '    function swapLiquidity(SwapData calldata data) external payable returns(uint256);\n', '    function swapLiquidityBatch(SwapData[] calldata data) external payable returns(uint256[] memory);\n', '}\n', '\n', '// File: contracts\\farming\\FarmDataGen1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'struct FarmingPositionRequest {\n', '    uint256 setupIndex; // index of the chosen setup.\n', '    uint256 amount; // amount of main token or liquidity pool token.\n', '    bool amountIsLiquidityPool; //true if user wants to directly share the liquidity pool token amount, false to add liquidity to AMM\n', '    address positionOwner; // position extension or address(0) [msg.sender].\n', '}\n', '\n', 'struct FarmingSetupConfiguration {\n', "    bool add; // true if we're adding a new setup, false we're updating it.\n", '    bool disable;\n', "    uint256 index; // index of the setup we're updating.\n", '    FarmingSetupInfo info; // data of the new or updated setup\n', '}\n', '\n', 'struct FarmingSetupInfo {\n', '    bool free; // if the setup is a free farming setup or a locked one.\n', '    uint256 blockDuration; // duration of setup\n', '    uint256 startBlock; // optional start block used for the delayed activation of the first setup\n', '    uint256 originalRewardPerBlock;\n', '    uint256 minStakeable; // minimum amount of staking tokens.\n', '    uint256 maxStakeable; // maximum amount stakeable in the setup (used only if free is false).\n', "    uint256 renewTimes; // if the setup is renewable or if it's one time.\n", '    address ammPlugin; // amm plugin address used for this setup (eg. uniswap amm plugin address).\n', '    address liquidityPoolTokenAddress; // address of the liquidity pool token\n', '    address mainTokenAddress; // eg. buidl address.\n', '    address ethereumAddress;\n', '    bool involvingETH; // if the setup involves ETH or not.\n', '    uint256 penaltyFee; // fee paid when the user exits a still active locked farming setup (used only if free is false).\n', '    uint256 setupsCount; // number of setups created by this info.\n', '    uint256 lastSetupIndex; // index of last setup;\n', '}\n', '\n', 'struct FarmingSetup {\n', '    uint256 infoIndex; // setup info\n', '    bool active; // if the setup is active or not.\n', '    uint256 startBlock; // farming setup start block.\n', '    uint256 endBlock; // farming setup end block.\n', '    uint256 lastUpdateBlock; // number of the block where an update was triggered.\n', '    uint256 objectId; // items object id for the liquidity pool token (used only if free is false).\n', '    uint256 rewardPerBlock; // farming setup reward per single block.\n', "    uint256 totalSupply; // If free it's the LP amount, if locked is currentlyStaked.\n", '}\n', '\n', 'struct FarmingPosition {\n', '    address uniqueOwner; // address representing the owner of the position.\n', '    uint256 setupIndex; // the setup index related to this position.\n', '    uint256 creationBlock; // block when this position was created.\n', '    uint256 liquidityPoolTokenAmount; // amount of liquidity pool token in the position.\n', '    uint256 mainTokenAmount; // amount of main token in the position (used only if free is false).\n', '    uint256 reward; // position reward (used only if free is false).\n', '    uint256 lockedRewardPerBlock; // position locked reward per block (used only if free is false).\n', '}\n', '\n', '// File: contracts\\farming\\IFarmMainGen1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IFarmMainGen1 {\n', '\n', '    function ONE_HUNDRED() external view returns(uint256);\n', '    function _rewardTokenAddress() external view returns(address);\n', '    function position(uint256 positionId) external view returns (FarmingPosition memory);\n', '    function setups() external view returns (FarmingSetup[] memory);\n', '    function setup(uint256 setupIndex) external view returns (FarmingSetup memory, FarmingSetupInfo memory);\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\n', '    function openPosition(FarmingPositionRequest calldata request) external payable returns(uint256 positionId);\n', '    function addLiquidity(uint256 positionId, FarmingPositionRequest calldata request) external payable;\n', '}\n', '\n', '// File: contracts\\farming\\IFarmExtensionGen1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', 'interface IFarmExtensionGen1 {\n', '\n', '    function init(bool byMint, address host, address treasury) external;\n', '\n', '    function setHost(address host) external;\n', '    function setTreasury(address treasury) external;\n', '\n', '    function data() external view returns(address farmMainContract, bool byMint, address host, address treasury, address rewardTokenAddress);\n', '\n', '    function transferTo(uint256 amount) external;\n', '    function backToYou(uint256 amount) external payable;\n', '\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) external;\n', '\n', '}\n', '\n', '// File: contracts\\farming\\IFarmFactory.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IFarmFactory {\n', '\n', '    event ExtensionCloned(address indexed);\n', '\n', '    function feePercentageInfo() external view returns (uint256, address);\n', '    function farmDefaultExtension() external view returns(address);\n', '    function cloneFarmDefaultExtension() external returns(address);\n', '    function getFarmTokenCollectionURI() external view returns (string memory);\n', '    function getFarmTokenURI() external view returns (string memory);\n', '}\n', '\n', '// File: contracts\\farming\\util\\ERC1155Receiver.sol\n', '\n', '// File: contracts/usd-v2/util/ERC1155Receiver.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'abstract contract ERC1155Receiver {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    constructor() {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '        _registerInterface(\n', '            ERC1155Receiver(0).onERC1155Received.selector ^\n', '            ERC1155Receiver(0).onERC1155BatchReceived.selector\n', '        );\n', '    }\n', '\n', '    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    function _registerInterface(bytes4 interfaceId) internal virtual {\n', '        require(interfaceId != 0xffffffff, "ERC165: invalid interface id");\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '\n', '    function onERC1155Received(\n', '        address operator,\n', '        address from,\n', '        uint256 id,\n', '        uint256 value,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        virtual\n', '        returns(bytes4);\n', '\n', '    function onERC1155BatchReceived(\n', '        address operator,\n', '        address from,\n', '        uint256[] calldata ids,\n', '        uint256[] calldata values,\n', '        bytes calldata data\n', '    )\n', '        external\n', '        virtual\n', '        returns(bytes4);\n', '}\n', '\n', '// File: contracts\\farming\\util\\IERC20.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    function safeApprove(address spender, uint256 amount) external;\n', '\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts\\farming\\util\\IEthItemOrchestrator.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IEthItemOrchestrator {\n', '    function createNative(bytes calldata modelInitPayload, string calldata ens)\n', '        external\n', '        returns (address newNativeAddress, bytes memory modelInitCallResponse);\n', '}\n', '\n', '// File: contracts\\farming\\util\\IERC1155.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', 'interface IERC1155 {\n', '\n', '    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n', '\n', '    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n', '\n', '    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n', '\n', '    event URI(string value, uint256 indexed id);\n', '\n', '    function balanceOf(address account, uint256 id) external view returns (uint256);\n', '\n', '    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n', '\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    function isApprovedForAll(address account, address operator) external view returns (bool);\n', '\n', '    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n', '\n', '    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n', '}\n', '\n', '// File: contracts\\farming\\util\\IEthItemInteroperableInterface.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'interface IEthItemInteroperableInterface is IERC20 {\n', '\n', '    function mainInterface() external view returns (address);\n', '\n', '    function objectId() external view returns (uint256);\n', '\n', '    function mint(address owner, uint256 amount) external;\n', '\n', '    function burn(address owner, uint256 amount) external;\n', '\n', '    function permitNonce(address sender) external view returns(uint256);\n', '\n', '    function permit(address owner, address spender, uint value, uint8 v, bytes32 r, bytes32 s) external;\n', '\n', '    function interoperableInterfaceVersion() external pure returns(uint256 ethItemInteroperableInterfaceVersion);\n', '}\n', '\n', '// File: contracts\\farming\\util\\IEthItem.sol\n', '\n', '// SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', '\n', 'interface IEthItem is IERC1155 {\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function totalSupply(uint256 objectId) external view returns (uint256);\n', '\n', '    function name(uint256 objectId) external view returns (string memory);\n', '\n', '    function symbol(uint256 objectId) external view returns (string memory);\n', '\n', '    function decimals(uint256 objectId) external view returns (uint256);\n', '\n', '    function uri(uint256 objectId) external view returns (string memory);\n', '\n', '    function mainInterfaceVersion() external pure returns(uint256 ethItemInteroperableVersion);\n', '\n', '    function toInteroperableInterfaceAmount(uint256 objectId, uint256 ethItemAmount) external view returns (uint256 interoperableInterfaceAmount);\n', '\n', '    function toMainInterfaceAmount(uint256 objectId, uint256 erc20WrapperAmount) external view returns (uint256 mainInterfaceAmount);\n', '\n', '    function interoperableInterfaceModel() external view returns (address, uint256);\n', '\n', '    function asInteroperable(uint256 objectId) external view returns (IEthItemInteroperableInterface);\n', '\n', '    function emitTransferSingleEvent(address sender, address from, address to, uint256 objectId, uint256 amount) external;\n', '\n', '    function mint(uint256 amount, string calldata partialUri)\n', '        external\n', '        returns (uint256, address);\n', '\n', '    function burn(\n', '        uint256 objectId,\n', '        uint256 amount\n', '    ) external;\n', '\n', '    function burnBatch(\n', '        uint256[] calldata objectIds,\n', '        uint256[] calldata amounts\n', '    ) external;\n', '}\n', '\n', '// File: contracts\\farming\\util\\INativeV1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', '\n', 'pragma solidity ^0.7.6;\n', '\n', '\n', 'interface INativeV1 is IEthItem {\n', '\n', '    function init(string calldata name, string calldata symbol, bool hasDecimals, string calldata collectionUri, address extensionAddress, bytes calldata extensionInitPayload) external returns(bytes memory extensionInitCallResponse);\n', '    function extension() external view returns (address extensionAddress);\n', '    function canMint(address operator) external view returns (bool result);\n', '    function isEditable(uint256 objectId) external view returns (bool result);\n', '    function releaseExtension() external;\n', '    function uri() external view returns (string memory);\n', '    function decimals() external view returns (uint256);\n', '    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri, bool editable) external returns (uint256 objectId, address tokenAddress);\n', '    function mint(uint256 amount, string calldata tokenName, string calldata tokenSymbol, string calldata objectUri) external returns (uint256 objectId, address tokenAddress);\n', '    function mint(uint256 objectId, uint256 amount) external;\n', '    function makeReadOnly(uint256 objectId) external;\n', '    function setUri(string calldata newUri) external;\n', '    function setUri(uint256 objectId, string calldata newUri) external;\n', '}\n', '\n', '// File: contracts\\farming\\FarmMainGen1.sol\n', '\n', '//SPDX_License_Identifier: MIT\n', 'pragma solidity ^0.7.6;\n', '//pragma abicoder v2;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract FarmMainGen1 is IFarmMainGen1, ERC1155Receiver {\n', '\n', '    // percentage\n', '    uint256 public override constant ONE_HUNDRED = 1e18;\n', '    // event that tracks contracts deployed for the given reward token\n', '    event RewardToken(address indexed rewardTokenAddress);\n', '    // new or transferred farming position event\n', '    event Transfer(uint256 indexed positionId, address indexed from, address indexed to);\n', '    // event that tracks involved tokens for this contract\n', '    event SetupToken(address indexed mainToken, address indexed involvedToken);\n', '    // event that tracks farm tokens\n', '    event FarmToken(uint256 indexed objectId, address indexed liquidityPoolToken, uint256 setupIndex, uint256 endBlock);\n', '    // factory address that will create clones of this contract\n', '    address public _factory;\n', '    // address of the extension of this contract\n', '    address public _extension;\n', '    // address of the reward token\n', '    address public override _rewardTokenAddress;\n', '     // farm token collection\n', '    address public _farmTokenCollection;\n', '    // mapping containing all the currently available farming setups info\n', '    mapping(uint256 => FarmingSetupInfo) private _setupsInfo;\n', '    // counter for the farming setup info\n', '    uint256 public _farmingSetupsInfoCount;\n', '    // mapping containing all the currently available farming setups\n', '    mapping(uint256 => FarmingSetup) private _setups;\n', '    // counter for the farming setups\n', '    uint256 public _farmingSetupsCount;\n', '    // mapping containing all the positions\n', '    mapping(uint256 => FarmingPosition) private _positions;\n', '    // mapping containing the reward per token per setup per block\n', '    mapping(uint256 => uint256) private _rewardPerTokenPerSetup;\n', '    // mapping containing the reward per token paid per position\n', '    mapping(uint256 => uint256) private _rewardPerTokenPaid;\n', '    // mapping containing whether a farming position has been partially reedemed or not\n', '    mapping(uint256 => uint256) public _partiallyRedeemed;\n', '    // mapping containing object id to setup index\n', '    mapping(uint256 => uint256) private _objectIdSetup;\n', '    // mapping containing all the number of opened positions for each setups\n', '    mapping(uint256 => uint256) private _setupPositionsCount;\n', '    // mapping containing all the reward received/paid per setup\n', '    mapping(uint256 => uint256) public _rewardReceived;\n', '    mapping(uint256 => uint256) public _rewardPaid;\n', '\n', '    /** Modifiers. */\n', '\n', '    /** @dev byExtension modifier used to check for unauthorized changes. */\n', '    modifier byExtension() {\n', '        require(msg.sender == _extension, "Unauthorized");\n', '        _;\n', '    }\n', '\n', '    /** @dev byPositionOwner modifier used to check for unauthorized accesses. */\n', '    modifier byPositionOwner(uint256 positionId) {\n', '        require(_positions[positionId].uniqueOwner == msg.sender && _positions[positionId].creationBlock != 0, "Not owned");\n', '        _;\n', '    }\n', '\n', '    /** @dev activeSetupOnly modifier used to check for function calls only if the setup is active. */\n', '    modifier activeSetupOnly(uint256 setupIndex) {\n', '        require(_setups[setupIndex].active, "Setup not active");\n', '        require(_setups[setupIndex].startBlock <= block.number && _setups[setupIndex].endBlock > block.number, "Invalid setup");\n', '        _;\n', '    }\n', '\n', '    receive() external payable {}\n', '\n', '    /** Extension methods */\n', '\n', '    /** @dev initializes the farming contract.\n', '      * @param extension extension address.\n', '      * @param extensionInitData lm extension init payload.\n', '      * @param orchestrator address of the eth item orchestrator.\n', '      * @param rewardTokenAddress address of the reward token.\n', '      * @return extensionReturnCall result of the extension initialization function, if it was called.  \n', '     */\n', '    function init(address extension, bytes memory extensionInitData, address orchestrator, address rewardTokenAddress, bytes memory farmingSetupInfosBytes) public returns(bytes memory extensionReturnCall) {\n', '        require(_factory == address(0), "Already initialized");\n', '        require((_extension = extension) != address(0), "extension");\n', '        _factory = msg.sender;\n', '        emit RewardToken(_rewardTokenAddress = rewardTokenAddress);\n', '        if (keccak256(extensionInitData) != keccak256("")) {\n', '            extensionReturnCall = _call(_extension, extensionInitData);\n', '        }\n', '        (_farmTokenCollection,) = IEthItemOrchestrator(orchestrator).createNative(abi.encodeWithSignature("init(string,string,bool,string,address,bytes)", "Covenants Farming", "cFARM", true, IFarmFactory(_factory).getFarmTokenCollectionURI(), address(this), ""), "");\n', '        if(farmingSetupInfosBytes.length > 0) {\n', '            FarmingSetupInfo[] memory farmingSetupInfos = abi.decode(farmingSetupInfosBytes, (FarmingSetupInfo[]));\n', '            for(uint256 i = 0; i < farmingSetupInfos.length; i++) {\n', '                _setOrAddFarmingSetupInfo(farmingSetupInfos[i], true, false, 0);\n', '            }\n', '        }\n', '    }\n', '\n', '    function setFarmingSetups(FarmingSetupConfiguration[] memory farmingSetups) public override byExtension {\n', '        for (uint256 i = 0; i < farmingSetups.length; i++) {\n', '            _setOrAddFarmingSetupInfo(farmingSetups[i].info, farmingSetups[i].add, farmingSetups[i].disable, farmingSetups[i].index);\n', '        }\n', '    }\n', '\n', '    function finalFlush(address[] calldata tokens, uint256[] calldata amounts) public  {\n', '        for(uint256 i = 0; i < _farmingSetupsCount; i++) {\n', '            require(_setupPositionsCount[i] == 0 && !_setups[i].active && _setups[i].totalSupply == 0, "Not Empty");\n', '        }\n', '        (,,, address receiver,) = IFarmExtensionGen1(_extension).data();\n', '        require(tokens.length == amounts.length, "length");\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            address token = tokens[i];\n', '            uint256 amount = amounts[i];\n', '            require(receiver != address(0));\n', '            if(token == address(0)) {\n', '                (bool result,) = receiver.call{value : amount}("");\n', '                require(result, "ETH");\n', '            } else {\n', '                _safeTransfer(token, receiver, amount);\n', '            }\n', '        }\n', '    }\n', '\n', '    /** Public methods */\n', '\n', '    /** @dev returns the position with the given id.\n', '      * @param positionId id of the position.\n', '      * @return farming position with the given id.\n', '     */\n', '    function position(uint256 positionId) public override view returns (FarmingPosition memory) {\n', '        return _positions[positionId];\n', '    }\n', '\n', '    function setup(uint256 setupIndex) public override view returns (FarmingSetup memory, FarmingSetupInfo memory) {\n', '        return (_setups[setupIndex], _setupsInfo[_setups[setupIndex].infoIndex]);\n', '    }\n', '\n', '    function setups() public override view returns (FarmingSetup[] memory) {\n', '        FarmingSetup[] memory farmingSetups = new FarmingSetup[](_farmingSetupsCount);\n', '        for (uint256 i = 0; i < _farmingSetupsCount; i++) {\n', '            farmingSetups[i] = _setups[i];\n', '        }\n', '        return farmingSetups;\n', '    }\n', '\n', '    function activateSetup(uint256 setupInfoIndex) public {\n', '        require(_setupsInfo[setupInfoIndex].renewTimes > 0 && !_setups[_setupsInfo[setupInfoIndex].lastSetupIndex].active, "Invalid toggle.");\n', '        _toggleSetup(_setupsInfo[setupInfoIndex].lastSetupIndex);\n', '    }\n', '\n', '    function toggleSetup(uint256 setupInfoIndex) public {\n', '        require(_setups[_setupsInfo[setupInfoIndex].lastSetupIndex].active && block.number > _setups[_setupsInfo[setupInfoIndex].lastSetupIndex].endBlock, "Invalid toggle.");\n', '        _toggleSetup(_setupsInfo[setupInfoIndex].lastSetupIndex);\n', '    }\n', '\n', '    function openPosition(FarmingPositionRequest memory request) public override payable activeSetupOnly(request.setupIndex) returns(uint256 positionId) {\n', '        // retrieve the setup\n', '        FarmingSetup storage chosenSetup = _setups[request.setupIndex];\n', '        // retrieve the unique owner\n', '        address uniqueOwner = (request.positionOwner != address(0)) ? request.positionOwner : msg.sender;\n', '        // create the position id\n', '        positionId = uint256(keccak256(abi.encode(uniqueOwner, _setupsInfo[chosenSetup.infoIndex].free ? 0 : block.number, request.setupIndex)));\n', '        require(_positions[positionId].creationBlock == 0, "Invalid open");\n', '        // create the lp data for the amm\n', '        (LiquidityPoolData memory liquidityPoolData, uint256 mainTokenAmount) = _addLiquidity(request.setupIndex, request);\n', '        // calculate the reward\n', '        uint256 reward;\n', '        uint256 lockedRewardPerBlock;\n', '        if (!_setupsInfo[chosenSetup.infoIndex].free) {\n', '            (reward, lockedRewardPerBlock) = calculateLockedFarmingReward(request.setupIndex, mainTokenAmount, false, 0);\n', '            require(reward > 0 && lockedRewardPerBlock > 0, "Insufficient staked amount");\n', '            chosenSetup.totalSupply = chosenSetup.totalSupply + mainTokenAmount;\n', '            chosenSetup.lastUpdateBlock = block.number;\n', '            _mintFarmTokenAmount(uniqueOwner, liquidityPoolData.amount, request.setupIndex);\n', '        } else {\n', '            _updateFreeSetup(request.setupIndex, liquidityPoolData.amount, positionId, false);\n', '        }\n', '        _positions[positionId] = FarmingPosition({\n', '            uniqueOwner: uniqueOwner,\n', '            setupIndex : request.setupIndex,\n', '            liquidityPoolTokenAmount: liquidityPoolData.amount,\n', '            mainTokenAmount: mainTokenAmount,\n', '            reward: reward,\n', '            lockedRewardPerBlock: lockedRewardPerBlock,\n', '            creationBlock: block.number\n', '        });\n', '        _setupPositionsCount[request.setupIndex] += (1 + (_setupsInfo[chosenSetup.infoIndex].free ? 0 : liquidityPoolData.amount));\n', '        emit Transfer(positionId, address(0), uniqueOwner);\n', '    }\n', '\n', '    function addLiquidity(uint256 positionId, FarmingPositionRequest memory request) public override payable activeSetupOnly(request.setupIndex) byPositionOwner(positionId) {\n', '        // retrieve farming position\n', '        FarmingPosition storage farmingPosition = _positions[positionId];\n', '        FarmingSetup storage chosenSetup = _setups[farmingPosition.setupIndex];\n', '        // check if farmoing position is valid\n', '        require(_setupsInfo[chosenSetup.infoIndex].free, "Invalid add liquidity");\n', '        // create the lp data for the amm\n', '        (LiquidityPoolData memory liquidityPoolData,) = _addLiquidity(farmingPosition.setupIndex, request);\n', '        // rebalance the reward per token\n', '        _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((block.number - chosenSetup.lastUpdateBlock) * chosenSetup.rewardPerBlock) * 1e18) / chosenSetup.totalSupply;\n', '        farmingPosition.reward = calculateFreeFarmingReward(positionId, false);\n', '        _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex];\n', '        farmingPosition.liquidityPoolTokenAmount += liquidityPoolData.amount;\n', '        // update the last block update variablex\n', '        chosenSetup.lastUpdateBlock = block.number;\n', '        chosenSetup.totalSupply += liquidityPoolData.amount;\n', '    }\n', '\n', '\n', '    /** @dev this function allows a user to withdraw the reward.\n', '      * @param positionId farming position id.\n', '     */\n', '    function withdrawReward(uint256 positionId) public byPositionOwner(positionId) {\n', '        // retrieve farming position\n', '        FarmingPosition storage farmingPosition = _positions[positionId];\n', '        uint256 reward = farmingPosition.reward;\n', '        uint256 currentBlock = block.number;\n', '        if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\n', '            // check if reward is available\n', '            require(farmingPosition.reward > 0, "No reward");\n', "            // check if it's a partial reward or not\n", '            // if (_setups[farmingPosition.setupIndex].endBlock > block.number) {\n', '            // calculate the reward from the farming position creation block to the current block multiplied by the reward per block\n', '            (reward,) = calculateLockedFarmingReward(0, 0, true, positionId);\n', '            //}\n', '            require(reward <= farmingPosition.reward, "Reward is bigger than expected");\n', '            // remove the partial reward from the liquidity mining position total reward\n', '            farmingPosition.reward = currentBlock >= _setups[farmingPosition.setupIndex].endBlock ? 0 : farmingPosition.reward - reward;\n', '            farmingPosition.creationBlock = block.number;\n', '        } else {\n', '            // rebalance setup\n', '            currentBlock = currentBlock > _setups[farmingPosition.setupIndex].endBlock ? _setups[farmingPosition.setupIndex].endBlock : currentBlock;\n', '            _rewardPerTokenPerSetup[farmingPosition.setupIndex] += (((currentBlock - _setups[farmingPosition.setupIndex].lastUpdateBlock) * _setups[farmingPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[farmingPosition.setupIndex].totalSupply;\n', '            reward = calculateFreeFarmingReward(positionId, false);\n', '            _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[farmingPosition.setupIndex];\n', '            farmingPosition.reward = 0;\n', '            // update the last block update variable\n', '            _setups[farmingPosition.setupIndex].lastUpdateBlock = currentBlock;\n', '        }\n', '        if (reward > 0) {\n', '            // transfer the reward\n', '            if (_rewardTokenAddress != address(0)) {\n', '                _safeTransfer(_rewardTokenAddress, farmingPosition.uniqueOwner, reward);\n', '            } else {\n', '                (bool result,) = farmingPosition.uniqueOwner.call{value:reward}("");\n', '                require(result, "Invalid ETH transfer.");\n', '            }\n', '            _rewardPaid[farmingPosition.setupIndex] += reward;\n', '        }\n', '        if (_setups[farmingPosition.setupIndex].endBlock <= block.number) {\n', '            if (_setups[farmingPosition.setupIndex].active) {\n', '                _toggleSetup(farmingPosition.setupIndex);\n', '            }\n', '            // close the locked position after withdrawing all the reward\n', '            if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\n', '                _setupPositionsCount[farmingPosition.setupIndex] -= 1;\n', '                if (_setupPositionsCount[farmingPosition.setupIndex] == 0 && !_setups[farmingPosition.setupIndex].active) {\n', '                    delete _setups[farmingPosition.setupIndex];\n', '                }\n', '                delete _positions[positionId];\n', '            }\n', '        } else if (!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free) {\n', '            // set the partially redeemed amount\n', '            _partiallyRedeemed[positionId] += reward;\n', '        }\n', '    }\n', '\n', '    function withdrawLiquidity(uint256 positionId, uint256 objectId, bool unwrapPair, uint256 removedLiquidity) public {\n', '        // retrieve farming position\n', '        FarmingPosition memory farmingPosition = _positions[positionId];\n', '        uint256 setupIndex = farmingPosition.setupIndex;\n', '        if (objectId != 0 && address(INativeV1(_farmTokenCollection).asInteroperable(objectId)) != address(0)) {\n', '            setupIndex = _objectIdSetup[objectId];\n', '        }\n', '        require((positionId != 0 && objectId == 0) || (objectId != 0 && positionId == 0 && _setups[setupIndex].objectId == objectId), "Invalid position");\n', '        // current owned liquidity\n', '        require(\n', '            (\n', '                _setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free && \n', '                farmingPosition.creationBlock != 0 &&\n', '                removedLiquidity <= farmingPosition.liquidityPoolTokenAmount &&\n', '                farmingPosition.uniqueOwner == msg.sender\n', '            ) || (INativeV1(_farmTokenCollection).balanceOf(msg.sender, objectId) >= removedLiquidity && (_setups[setupIndex].endBlock <= block.number)), "Invalid withdraw");\n', '        // burn the liquidity in the locked setup\n', '        if (positionId == 0) {\n', '            _burnFarmTokenAmount(objectId, removedLiquidity);\n', '        } else {\n', '            withdrawReward(positionId);\n', '            _setups[farmingPosition.setupIndex].totalSupply -= removedLiquidity;\n', '        }\n', '        _removeLiquidity(positionId, setupIndex, unwrapPair, removedLiquidity, false);\n', '        if (positionId == 0) {\n', '            _setupPositionsCount[setupIndex] -= removedLiquidity;\n', '            if (_setupPositionsCount[setupIndex] == 0 && !_setups[setupIndex].active) {\n', '                delete _setups[setupIndex];\n', '            }\n', '        }\n', '    }\n', '\n', '    function unlock(uint256 positionId, bool unwrapPair) public payable byPositionOwner(positionId) {\n', '        // retrieve liquidity mining position\n', '        FarmingPosition storage farmingPosition = _positions[positionId];\n', '        require(!_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].free && _setups[farmingPosition.setupIndex].endBlock > block.number, "Invalid unlock");\n', '        uint256 rewardToGiveBack = _partiallyRedeemed[positionId];\n', '        // must pay a penalty fee\n', '        rewardToGiveBack += _setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].penaltyFee == 0 ? 0 : (farmingPosition.reward * ((_setupsInfo[_setups[farmingPosition.setupIndex].infoIndex].penaltyFee * 1e18) / ONE_HUNDRED) / 1e18);\n', '        // add all the unissued reward\n', '        if (rewardToGiveBack > 0) {\n', '            _safeTransferFrom(_rewardTokenAddress, msg.sender, address(this), rewardToGiveBack);\n', '        } \n', '        _setups[farmingPosition.setupIndex].totalSupply -= farmingPosition.mainTokenAmount;\n', '        _burnFarmTokenAmount(_setups[farmingPosition.setupIndex].objectId, farmingPosition.liquidityPoolTokenAmount);\n', '        _removeLiquidity(positionId, farmingPosition.setupIndex, unwrapPair, farmingPosition.liquidityPoolTokenAmount, true);\n', '        _setupPositionsCount[farmingPosition.setupIndex] -= 1 + farmingPosition.liquidityPoolTokenAmount;\n', '        delete _positions[positionId];\n', '    }\n', '\n', '    function calculateLockedFarmingReward(uint256 setupIndex, uint256 mainTokenAmount, bool isPartial, uint256 positionId) public view returns(uint256 reward, uint256 relativeRewardPerBlock) {\n', '        if (isPartial) {\n', '            // retrieve the position\n', '            FarmingPosition memory farmingPosition = _positions[positionId];\n', '            // calculate the reward\n', '            uint256 currentBlock = block.number >= _setups[farmingPosition.setupIndex].endBlock ? _setups[farmingPosition.setupIndex].endBlock : block.number;\n', '            reward = ((currentBlock - farmingPosition.creationBlock) * farmingPosition.lockedRewardPerBlock);\n', '        } else {\n', '            FarmingSetup memory setup = _setups[setupIndex];\n', '            // check if main token amount is less than the stakeable liquidity\n', '            require(mainTokenAmount <= _setupsInfo[_setups[setupIndex].infoIndex].maxStakeable - setup.totalSupply, "Invalid liquidity");\n', '            uint256 remainingBlocks = block.number >= setup.endBlock ? 0 : setup.endBlock - block.number;\n', '            // get amount of remaining blocks\n', '            require(remainingBlocks > 0, "FarmingSetup ended");\n', '            // get total reward still available (= 0 if rewardPerBlock = 0)\n', '            require(setup.rewardPerBlock * remainingBlocks > 0, "No rewards");\n', '            // calculate relativeRewardPerBlock\n', '            relativeRewardPerBlock = (setup.rewardPerBlock * ((mainTokenAmount * 1e18) / _setupsInfo[_setups[setupIndex].infoIndex].maxStakeable)) / 1e18;\n', '            // check if rewardPerBlock is greater than 0\n', '            require(relativeRewardPerBlock > 0, "Invalid rpb");\n', '            // calculate reward by multiplying relative reward per block and the remaining blocks\n', '            reward = relativeRewardPerBlock * remainingBlocks;\n', '        }\n', '    }\n', '\n', '    function calculateFreeFarmingReward(uint256 positionId, bool isExt) public view returns(uint256 reward) {\n', '        FarmingPosition memory farmingPosition = _positions[positionId];\n', '        reward = ((_rewardPerTokenPerSetup[farmingPosition.setupIndex] - _rewardPerTokenPaid[positionId]) * farmingPosition.liquidityPoolTokenAmount) / 1e18;\n', '        if (isExt) {\n', '            uint256 currentBlock = block.number < _setups[farmingPosition.setupIndex].endBlock ? block.number : _setups[farmingPosition.setupIndex].endBlock;\n', '            uint256 lastUpdateBlock = _setups[farmingPosition.setupIndex].lastUpdateBlock < _setups[farmingPosition.setupIndex].startBlock ? _setups[farmingPosition.setupIndex].startBlock : _setups[farmingPosition.setupIndex].lastUpdateBlock;\n', '            uint256 rpt = (((currentBlock - lastUpdateBlock) * _setups[farmingPosition.setupIndex].rewardPerBlock) * 1e18) / _setups[farmingPosition.setupIndex].totalSupply;\n', '            reward += (rpt * farmingPosition.liquidityPoolTokenAmount) / 1e18;\n', '        }\n', '        reward += farmingPosition.reward;\n', '    }\n', '\n', '    function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public view override returns(bytes4) {\n', '        require(_farmTokenCollection == msg.sender, "Invalid sender");\n', '        return this.onERC1155BatchReceived.selector;\n', '    }\n', '\n', '    function onERC1155Received(address, address, uint256, uint256, bytes memory) public view override returns(bytes4) {\n', '        require(_farmTokenCollection == msg.sender, "Invalid sender");\n', '        return this.onERC1155Received.selector;\n', '    }\n', '\n', '    /** Private methods */\n', '\n', '    function _setOrAddFarmingSetupInfo(FarmingSetupInfo memory info, bool add, bool disable, uint256 setupIndex) private {\n', '        FarmingSetupInfo memory farmingSetupInfo = info;\n', '\n', '        if(add || !disable) {\n', '            farmingSetupInfo.renewTimes = farmingSetupInfo.renewTimes + 1;\n', '            if(farmingSetupInfo.renewTimes == 0) {\n', '                farmingSetupInfo.renewTimes = farmingSetupInfo.renewTimes - 1;\n', '            }\n', '        }\n', '\n', '        if (add) {\n', '            require(\n', '                farmingSetupInfo.ammPlugin != address(0) &&\n', '                farmingSetupInfo.liquidityPoolTokenAddress != address(0) &&\n', '                farmingSetupInfo.originalRewardPerBlock > 0 &&\n', '                (farmingSetupInfo.free || farmingSetupInfo.maxStakeable > 0),\n', '                "Invalid setup configuration"\n', '            );\n', '\n', '            (,,address[] memory tokenAddresses) = IAMM(farmingSetupInfo.ammPlugin).byLiquidityPool(farmingSetupInfo.liquidityPoolTokenAddress);\n', '            farmingSetupInfo.ethereumAddress = address(0);\n', '            if (farmingSetupInfo.involvingETH) {\n', '                (farmingSetupInfo.ethereumAddress,,) = IAMM(farmingSetupInfo.ammPlugin).data();\n', '            }\n', '            bool mainTokenFound = false;\n', '            bool ethTokenFound = false;\n', '            for(uint256 z = 0; z < tokenAddresses.length; z++) {\n', '                if(tokenAddresses[z] == farmingSetupInfo.mainTokenAddress) {\n', '                    mainTokenFound = true;\n', '                    if(tokenAddresses[z] == farmingSetupInfo.ethereumAddress) {\n', '                        ethTokenFound = true;\n', '                    }\n', '                } else {\n', '                    emit SetupToken(farmingSetupInfo.mainTokenAddress, tokenAddresses[z]);\n', '                    if(tokenAddresses[z] == farmingSetupInfo.ethereumAddress) {\n', '                        ethTokenFound = true;\n', '                    }\n', '                }\n', '            }\n', '            require(mainTokenFound, "No main token");\n', '            require(!farmingSetupInfo.involvingETH || ethTokenFound, "No ETH token");\n', '            farmingSetupInfo.setupsCount = 0;\n', '            _setupsInfo[_farmingSetupsInfoCount] = farmingSetupInfo;\n', '            _setups[_farmingSetupsCount] = FarmingSetup(_farmingSetupsInfoCount, false, 0, 0, 0, 0, farmingSetupInfo.originalRewardPerBlock, 0);\n', '            _setupsInfo[_farmingSetupsInfoCount].lastSetupIndex = _farmingSetupsCount;\n', '            _farmingSetupsInfoCount += 1;\n', '            _farmingSetupsCount += 1;\n', '            return;\n', '        }\n', '\n', '        FarmingSetup storage setup = _setups[setupIndex];\n', '        farmingSetupInfo = _setupsInfo[_setups[setupIndex].infoIndex];\n', '\n', '        if(disable) {\n', '            require(setup.active, "Not possible");\n', '            _toggleSetup(setupIndex);\n', '            return;\n', '        }\n', '\n', '        info.renewTimes -= 1;\n', '\n', '        if (setup.active && _setupsInfo[_setups[setupIndex].infoIndex].free) {\n', '            setup = _setups[setupIndex];\n', '            if(block.number < setup.endBlock) {\n', '                uint256 difference = info.originalRewardPerBlock < farmingSetupInfo.originalRewardPerBlock ? farmingSetupInfo.originalRewardPerBlock - info.originalRewardPerBlock : info.originalRewardPerBlock - farmingSetupInfo.originalRewardPerBlock;\n', '                uint256 duration = setup.endBlock - block.number;\n', '                uint256 amount = difference * duration;\n', '                if (amount > 0) {\n', '                    if (info.originalRewardPerBlock > farmingSetupInfo.originalRewardPerBlock) {\n', '                        require(_ensureTransfer(amount), "Insufficient reward in extension.");\n', '                        _rewardReceived[setupIndex] += amount;\n', '                    }\n', '                    _updateFreeSetup(setupIndex, 0, 0, false);\n', '                    setup.rewardPerBlock = info.originalRewardPerBlock;\n', '                }\n', '            }\n', '            _setupsInfo[_setups[setupIndex].infoIndex].originalRewardPerBlock = info.originalRewardPerBlock;\n', '        }\n', '        if(_setupsInfo[_setups[setupIndex].infoIndex].renewTimes > 0) {\n', '            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes = info.renewTimes;\n', '        }\n', '    }\n', '\n', '    function _transferToMeAndCheckAllowance(FarmingSetup memory setup, FarmingPositionRequest memory request) private returns(IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount) {\n', '        require(request.amount > 0, "No amount");\n', '        // retrieve the values\n', '        amm = IAMM(_setupsInfo[setup.infoIndex].ammPlugin);\n', '        liquidityPoolAmount = request.amountIsLiquidityPool ? request.amount : 0;\n', '        mainTokenAmount = request.amountIsLiquidityPool ? 0 : request.amount;\n', '        address[] memory tokens;\n', '        uint256[] memory tokenAmounts;\n', '        // if liquidity pool token amount is provided, the position is opened by liquidity pool token amount\n', '        if(request.amountIsLiquidityPool) {\n', '            _safeTransferFrom(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, msg.sender, address(this), liquidityPoolAmount);\n', '            (tokenAmounts, tokens) = amm.byLiquidityPoolAmount(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, liquidityPoolAmount);\n', '        } else {\n', '            // else it is opened by the tokens amounts\n', '            (liquidityPoolAmount, tokenAmounts, tokens) = amm.byTokenAmount(_setupsInfo[setup.infoIndex].liquidityPoolTokenAddress, _setupsInfo[setup.infoIndex].mainTokenAddress, mainTokenAmount);\n', '        }\n', '\n', '        // iterate the tokens and perform the transferFrom and the approve\n', '        for(uint256 i = 0; i < tokens.length; i++) {\n', '            if(tokens[i] == _setupsInfo[setup.infoIndex].mainTokenAddress) {\n', '                mainTokenAmount = tokenAmounts[i];\n', '                require(mainTokenAmount >= _setupsInfo[setup.infoIndex].minStakeable, "Invalid liquidity.");\n', '                if(request.amountIsLiquidityPool) {\n', '                    break;\n', '                }\n', '            }\n', '            if(request.amountIsLiquidityPool) {\n', '                continue;\n', '            }\n', '            if(_setupsInfo[setup.infoIndex].involvingETH && _setupsInfo[setup.infoIndex].ethereumAddress == tokens[i]) {\n', '                require(msg.value == tokenAmounts[i], "Incorrect eth value");\n', '            } else {\n', '                _safeTransferFrom(tokens[i], msg.sender, address(this), tokenAmounts[i]);\n', '                _safeApprove(tokens[i], _setupsInfo[setup.infoIndex].ammPlugin, tokenAmounts[i]);\n', '            }\n', '        }\n', '    }\n', '\n', '    function _addLiquidity(uint256 setupIndex, FarmingPositionRequest memory request) private returns(LiquidityPoolData memory liquidityPoolData, uint256 tokenAmount) {\n', '        (IAMM amm, uint256 liquidityPoolAmount, uint256 mainTokenAmount) = _transferToMeAndCheckAllowance(_setups[setupIndex], request);\n', '        // liquidity pool data struct for the AMM\n', '        liquidityPoolData = LiquidityPoolData(\n', '            _setupsInfo[_setups[setupIndex].infoIndex].liquidityPoolTokenAddress,\n', '            request.amountIsLiquidityPool ? liquidityPoolAmount : mainTokenAmount,\n', '            _setupsInfo[_setups[setupIndex].infoIndex].mainTokenAddress,\n', '            request.amountIsLiquidityPool,\n', '            _setupsInfo[_setups[setupIndex].infoIndex].involvingETH,\n', '            address(this)\n', '        );\n', '        tokenAmount = mainTokenAmount;\n', '        // amount is lp check\n', '        if (liquidityPoolData.amountIsLiquidityPool || !_setupsInfo[_setups[setupIndex].infoIndex].involvingETH) {\n', '            require(msg.value == 0, "ETH not involved");\n', '        }\n', '        if (liquidityPoolData.amountIsLiquidityPool) {\n', '            return(liquidityPoolData, tokenAmount);\n', '        }\n', '        // retrieve the poolTokenAmount from the amm\n', '        if(liquidityPoolData.involvingETH) {\n', '            (liquidityPoolData.amount,,) = amm.addLiquidity{value : msg.value}(liquidityPoolData);\n', '        } else {\n', '            (liquidityPoolData.amount,,) = amm.addLiquidity(liquidityPoolData);\n', '        }\n', '    }\n', '\n', '    /** @dev helper function used to remove liquidity from a free position or to burn item farm tokens and retrieve their content.\n', '      * @param positionId id of the position.\n', '      * @param setupIndex index of the setup related to the item farm tokens.\n', '      * @param unwrapPair whether to unwrap the liquidity pool tokens or not.\n', "      * @param isUnlock if we're removing liquidity from an unlock method or not.\n", '     */\n', '    function _removeLiquidity(uint256 positionId, uint256 setupIndex, bool unwrapPair, uint256 removedLiquidity, bool isUnlock) private {\n', '        FarmingSetupInfo memory setupInfo = _setupsInfo[_setups[setupIndex].infoIndex];\n', '        // create liquidity pool data struct for the AMM\n', '        LiquidityPoolData memory lpData = LiquidityPoolData(\n', '            setupInfo.liquidityPoolTokenAddress,\n', '            removedLiquidity,\n', '            setupInfo.mainTokenAddress,\n', '            true,\n', '            setupInfo.involvingETH,\n', '            msg.sender\n', '        );\n', '        // retrieve the position\n', '        FarmingPosition storage farmingPosition = _positions[positionId];\n', '        // remaining liquidity\n', '        uint256 remainingLiquidity;\n', '        // we are removing liquidity using the setup items\n', '        if (setupInfo.free && farmingPosition.creationBlock != 0 && positionId != 0) {\n', '            // update the remaining liquidity\n', '            remainingLiquidity = farmingPosition.liquidityPoolTokenAmount - removedLiquidity;\n', '        }\n', '        // retrieve fee stuff\n', '        (uint256 exitFeePercentage, address exitFeeWallet) = IFarmFactory(_factory).feePercentageInfo();\n', '        // pay the fees!\n', '        if (exitFeePercentage > 0) {\n', '            uint256 fee = (lpData.amount * ((exitFeePercentage * 1e18) / ONE_HUNDRED)) / 1e18;\n', '            _safeTransfer(setupInfo.liquidityPoolTokenAddress, exitFeeWallet, fee);\n', '            lpData.amount = lpData.amount - fee;\n', '        }\n', '        // check if the user wants to unwrap its pair or not\n', '        if (unwrapPair) {\n', '            // remove liquidity using AMM\n', '            _safeApprove(lpData.liquidityPoolAddress, setupInfo.ammPlugin, lpData.amount);\n', '            IAMM(setupInfo.ammPlugin).removeLiquidity(lpData);\n', '        } else {\n', '            // send back the liquidity pool token amount without the fee\n', '            _safeTransfer(lpData.liquidityPoolAddress, lpData.receiver, lpData.amount);\n', '        }\n', '        if (!setupInfo.free && _setups[setupIndex].active && !isUnlock) {\n', '            _toggleSetup(setupIndex);\n', '        } else if (setupInfo.free && positionId != 0) {\n', '            if (_setups[farmingPosition.setupIndex].active && _setups[farmingPosition.setupIndex].endBlock <= block.number) {\n', '                _toggleSetup(farmingPosition.setupIndex);\n', '            }\n', '            // delete the farming position after the withdraw\n', '            if (remainingLiquidity == 0) {\n', '                _setupPositionsCount[farmingPosition.setupIndex] -= 1;\n', '                if (_setupPositionsCount[farmingPosition.setupIndex] == 0 && !_setups[farmingPosition.setupIndex].active) {\n', '                    delete _setups[farmingPosition.setupIndex];\n', '                }\n', '                delete _positions[positionId];\n', '            } else {\n', '                // update the creation block and amount\n', '                farmingPosition.liquidityPoolTokenAmount = remainingLiquidity;\n', '            }\n', '        }\n', '    }\n', '\n', '    /** @dev updates the free setup with the given index.\n', "      * @param setupIndex index of the setup that we're updating.\n", "      * @param amount amount of liquidity that we're adding/removeing.\n", '      * @param positionId position id.\n', "      * @param fromExit if it's from an exit or not.\n", '     */\n', '    function _updateFreeSetup(uint256 setupIndex, uint256 amount, uint256 positionId, bool fromExit) private {\n', '        uint256 currentBlock = block.number < _setups[setupIndex].endBlock ? block.number : _setups[setupIndex].endBlock;\n', '        if (_setups[setupIndex].totalSupply != 0) {\n', '            uint256 lastUpdateBlock = _setups[setupIndex].lastUpdateBlock < _setups[setupIndex].startBlock ? _setups[setupIndex].startBlock : _setups[setupIndex].lastUpdateBlock;\n', '            _rewardPerTokenPerSetup[setupIndex] += (((currentBlock - lastUpdateBlock) * _setups[setupIndex].rewardPerBlock) * 1e18) / _setups[setupIndex].totalSupply;\n', '        }\n', '        // update the last block update variable\n', '        _setups[setupIndex].lastUpdateBlock = currentBlock;\n', '        if (positionId != 0) {\n', '            _rewardPerTokenPaid[positionId] = _rewardPerTokenPerSetup[setupIndex];\n', '        }\n', '        if (amount > 0) {\n', '            fromExit ? _setups[setupIndex].totalSupply -= amount : _setups[setupIndex].totalSupply += amount;\n', '        }\n', '    }\n', '\n', '    function _toggleSetup(uint256 setupIndex) private {\n', '        FarmingSetup storage setup = _setups[setupIndex];\n', '        // require(!setup.active || block.number >= setup.endBlock, "Not valid activation");\n', '\n', '        require(block.number > _setupsInfo[setup.infoIndex].startBlock, "Too early for this setup");\n', '\n', '        if (setup.active && block.number >= setup.endBlock && _setupsInfo[setup.infoIndex].renewTimes == 0) {\n', '            setup.active = false;\n', '            return;\n', '        } else if (block.number >= setup.startBlock && block.number < setup.endBlock && setup.active) {\n', '            setup.active = false;\n', '            _setupsInfo[setup.infoIndex].renewTimes = 0;\n', '            uint256 amount = (setup.endBlock - block.number) * setup.rewardPerBlock;\n', '            setup.endBlock = block.number;\n', '            if (_setupsInfo[setup.infoIndex].free) {\n', '                _updateFreeSetup(setupIndex, 0, 0, false);\n', '            }\n', '            _rewardReceived[setupIndex] -= amount;\n', '            return;\n', '        }\n', '\n', '        bool wasActive = setup.active;\n', '        setup.active = _ensureTransfer(setup.rewardPerBlock * _setupsInfo[setup.infoIndex].blockDuration);\n', '\n', '        if (setup.active && wasActive) {\n', '            _rewardReceived[_farmingSetupsCount] = setup.rewardPerBlock * _setupsInfo[setup.infoIndex].blockDuration;\n', '            // set new setup\n', '            _setups[_farmingSetupsCount] = abi.decode(abi.encode(setup), (FarmingSetup));\n', '            // update old setup\n', '            _setups[setupIndex].active = false;\n', '            // update new setup\n', '            _setupsInfo[setup.infoIndex].renewTimes -= 1;\n', '            _setupsInfo[setup.infoIndex].setupsCount += 1;\n', '            _setupsInfo[setup.infoIndex].lastSetupIndex = _farmingSetupsCount;\n', '            _setups[_farmingSetupsCount].startBlock = block.number;\n', '            _setups[_farmingSetupsCount].endBlock = block.number + _setupsInfo[_setups[_farmingSetupsCount].infoIndex].blockDuration;\n', '            _setups[_farmingSetupsCount].objectId = 0;\n', '            _setups[_farmingSetupsCount].totalSupply = 0;\n', '            _farmingSetupsCount += 1;\n', '        } else if (setup.active && !wasActive) {\n', '            _rewardReceived[setupIndex] = setup.rewardPerBlock * _setupsInfo[_setups[setupIndex].infoIndex].blockDuration;\n', '            // update new setup\n', '            _setups[setupIndex].startBlock = block.number;\n', '            _setups[setupIndex].endBlock = block.number + _setupsInfo[_setups[setupIndex].infoIndex].blockDuration;\n', '            _setups[setupIndex].totalSupply = 0;\n', '            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes -= 1;\n', '        } else {\n', '            _setupsInfo[_setups[setupIndex].infoIndex].renewTimes = 0;\n', '        }\n', '    }\n', '\n', '    /** @dev mints a new FarmToken inside the collection for the given position.\n', '      * @param uniqueOwner farming position owner.\n', '      * @param amount amount of to mint for a farm token.\n', '      * @param setupIndex index of the setup.\n', '      * @return objectId new farm token object id.\n', '     */\n', '    function _mintFarmTokenAmount(address uniqueOwner, uint256 amount, uint256 setupIndex) private returns(uint256 objectId) {\n', '        if (_setups[setupIndex].objectId == 0) {\n', '            (objectId,) = INativeV1(_farmTokenCollection).mint(amount, string(abi.encodePacked("Farming LP ", _toString(_setupsInfo[_setups[setupIndex].infoIndex].liquidityPoolTokenAddress))), "fLP", IFarmFactory(_factory).getFarmTokenURI(), true);\n', '            emit FarmToken(objectId, _setupsInfo[_setups[setupIndex].infoIndex].liquidityPoolTokenAddress, setupIndex, _setups[setupIndex].endBlock);\n', '            _objectIdSetup[objectId] = setupIndex;\n', '            _setups[setupIndex].objectId = objectId;\n', '        } else {\n', '            INativeV1(_farmTokenCollection).mint(_setups[setupIndex].objectId, amount);\n', '        }\n', '        INativeV1(_farmTokenCollection).safeTransferFrom(address(this), uniqueOwner, _setups[setupIndex].objectId, amount, "");\n', '    }\n', '\n', '    /** @dev burns a farm token from the collection.\n', '      * @param objectId object id where to burn liquidity.\n', '      * @param amount amount of liquidity to burn.\n', '      */\n', '    function _burnFarmTokenAmount(uint256 objectId, uint256 amount) private {\n', '        INativeV1 tokenCollection = INativeV1(_farmTokenCollection);\n', '        // transfer the farm token to this contract\n', '        tokenCollection.safeTransferFrom(msg.sender, address(this), objectId, amount, "");\n', '        // burn the farm token\n', '        tokenCollection.burn(objectId, amount);\n', '    }\n', '\n', '    /** @dev function used to safely approve ERC20 transfers.\n', '      * @param erc20TokenAddress address of the token to approve.\n', '      * @param to receiver of the approval.\n', '      * @param value amount to approve for.\n', '     */\n', '    function _safeApprove(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\n", '    }\n', '\n', '    /** @dev function used to safe transfer ERC20 tokens.\n', '      * @param erc20TokenAddress address of the token to transfer.\n', '      * @param to receiver of the tokens.\n', '      * @param value amount of tokens to transfer.\n', '     */\n', '    function _safeTransfer(address erc20TokenAddress, address to, uint256 value) internal virtual {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\n", '    }\n', '\n', '    /** @dev this function safely transfers the given ERC20 value from an address to another.\n', '      * @param erc20TokenAddress erc20 token address.\n', '      * @param from address from.\n', '      * @param to address to.\n', '      * @param value amount to transfer.\n', '     */\n', '    function _safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) private {\n', '        bytes memory returnData = _call(erc20TokenAddress, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\n', "        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\n", '    }\n', '\n', '    /** @dev calls the contract at the given location using the given payload and returns the returnData.\n', '      * @param location location to call.\n', '      * @param payload call payload.\n', '      * @return returnData call return data.\n', '     */\n', '    function _call(address location, bytes memory payload) private returns(bytes memory returnData) {\n', '        assembly {\n', '            let result := call(gas(), location, 0, add(payload, 0x20), mload(payload), 0, 0)\n', '            let size := returndatasize()\n', '            returnData := mload(0x40)\n', '            mstore(returnData, size)\n', '            let returnDataPayloadStart := add(returnData, 0x20)\n', '            returndatacopy(returnDataPayloadStart, 0, size)\n', '            mstore(0x40, add(returnDataPayloadStart, size))\n', '            switch result case 0 {revert(returnDataPayloadStart, size)}\n', '        }\n', '    }\n', '\n', '    /** @dev returns the input address to string.\n', '      * @param _addr address to convert as string.\n', '      * @return address as string.\n', '     */\n', '    function _toString(address _addr) internal pure returns(string memory) {\n', '        bytes32 value = bytes32(uint256(_addr));\n', '        bytes memory alphabet = "0123456789abcdef";\n', '\n', '        bytes memory str = new bytes(42);\n', "        str[0] = '0';\n", "        str[1] = 'x';\n", '        for (uint i = 0; i < 20; i++) {\n', '            str[2+i*2] = alphabet[uint(uint8(value[i + 12] >> 4))];\n', '            str[3+i*2] = alphabet[uint(uint8(value[i + 12] & 0x0f))];\n', '        }\n', '        return string(str);\n', '    }\n', '\n', '    /** @dev gives back the reward to the extension.\n', '      * @param amount to give back.\n', '     */\n', '    function _giveBack(uint256 amount) private {\n', '        if(amount == 0) {\n', '            return;\n', '        }\n', '        if (_rewardTokenAddress == address(0)) {\n', '            IFarmExtensionGen1(_extension).backToYou{value : amount}(amount);\n', '        } else {\n', '            _safeApprove(_rewardTokenAddress, _extension, amount);\n', '            IFarmExtensionGen1(_extension).backToYou(amount);\n', '        }\n', '    }\n', '\n', '    /** @dev ensures the transfer from the contract to the extension.\n', '      * @param amount amount to transfer.\n', '     */\n', '    function _ensureTransfer(uint256 amount) private returns(bool) {\n', '        uint256 initialBalance = _rewardTokenAddress == address(0) ? address(this).balance : IERC20(_rewardTokenAddress).balanceOf(address(this));\n', '        uint256 expectedBalance = initialBalance + amount;\n', '        try IFarmExtensionGen1(_extension).transferTo(amount) {} catch {}\n', '        uint256 actualBalance = _rewardTokenAddress == address(0) ? address(this).balance : IERC20(_rewardTokenAddress).balanceOf(address(this));\n', '        if(actualBalance == expectedBalance) {\n', '            return true;\n', '        }\n', '        _giveBack(actualBalance - initialBalance);\n', '        return false;\n', '    }\n', '}']