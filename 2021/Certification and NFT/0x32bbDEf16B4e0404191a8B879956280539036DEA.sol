['// SPDX-License-Identifier: Unlicense\n', 'pragma solidity >=0.7.6;\n', '\n', "import './MetaProxyFactory.sol';\n", "import './IBridge.sol';\n", '\n', '/// @notice This contract verifies execution permits and is meant to be used for L1 governance.\n', '/// A new proxy can be created with `createProxy`, to be used for governance.\n', '// Audit-1: ok\n', 'contract ExecutionProxy is MetaProxyFactory {\n', '  /// @notice keeps track of already executed permits\n', '  mapping (bytes32 => bool) public executed;\n', '\n', '  event ProxyCreated(address indexed bridge, address indexed vault, address proxy);\n', '\n', '  /// @notice Returns the metadata of this (MetaProxy) contract.\n', '  /// Only relevant with contracts created via the MetaProxy.\n', '  /// @dev This function is aimed to be invoked with- & without a call.\n', '  function getMetadata () public pure returns (\n', '    address bridge,\n', '    address vault\n', '  ) {\n', '    assembly {\n', '      // calldata layout:\n', '      // [ arbitrary data... ] [ metadata... ] [ size of metadata 32 bytes ]\n', '      bridge := calldataload(sub(calldatasize(), 96))\n', '      vault := calldataload(sub(calldatasize(), 64))\n', '    }\n', '  }\n', '\n', '  /// @notice MetaProxy construction via calldata.\n', '  /// @param bridge is the address of the habitat rollup\n', '  /// @param vault is the L2 vault used for governance.\n', '  function createProxy (address bridge, address vault) external returns (address addr) {\n', '    addr = MetaProxyFactory._metaProxyFromCalldata();\n', '    emit ProxyCreated(bridge, vault, addr);\n', '  }\n', '\n', '  /// @notice Executes a set of contract calls `actions` if there is a valid\n', '  /// permit on the rollup bridge for `proposalId` and `actions`.\n', '  function execute (bytes32 proposalId, bytes memory actions) external {\n', '    (address bridge, address vault) = getMetadata();\n', '\n', "    require(executed[proposalId] == false, 'already executed');\n", '    require(\n', '      IBridge(bridge).executionPermit(vault, proposalId) == keccak256(actions),\n', "      'wrong permit'\n", '    );\n', '\n', '    // mark it as executed\n', '    executed[proposalId] = true;\n', '    // execute\n', '    assembly {\n', '      // Note: we use `callvalue()` instead of `0`\n', '      let ptr := add(actions, 32)\n', '      let max := add(ptr, mload(actions))\n', '\n', '      for { } lt(ptr, max) { } {\n', '        let addr := mload(ptr)\n', '        ptr := add(ptr, 32)\n', '        let size := mload(ptr)\n', '        ptr := add(ptr, 32)\n', '\n', '        let success := call(gas(), addr, callvalue(), ptr, size, callvalue(), callvalue())\n', '        if iszero(success) {\n', '          // failed, copy the error\n', '          returndatacopy(callvalue(), callvalue(), returndatasize())\n', '          revert(callvalue(), returndatasize())\n', '        }\n', '        ptr := add(ptr, size)\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', '// SPDX-License-Identifier: Unlicense\n', 'pragma solidity >=0.7.6;\n', '\n', 'interface IBridge {\n', '  function executionPermit (address vault, bytes32 proposalId) external view returns (bytes32);\n', '  function deposit (address token, uint256 amountOrId, address receiver) external;\n', '}\n', '\n', '// SPDX-License-Identifier: Unlicense\n', 'pragma solidity >=0.7.6;\n', '\n', '/// @notice Based on EIP-3448\n', '// Audit-1: ok\n', 'contract MetaProxyFactory {\n', '  /// @dev Creates a child with metadata from calldata.\n', '  /// Copies everything from calldata except the first 4 bytes.\n', '  function _metaProxyFromCalldata () internal returns (address addr) {\n', '    // the following assembly code (init code + contract code) constructs a metaproxy.\n', '    assembly {\n', '      // load free memory pointer as per solidity convention\n', '      let start := mload(64)\n', '      // copy\n', '      let ptr := start\n', '      // deploy code (11 bytes) + first part of the proxy (21 bytes)\n', '      mstore(ptr, 0x600b380380600b3d393df3363d3d373d3d3d3d60368038038091363936013d73)\n', '      ptr := add(ptr, 32)\n', '\n', '      // store the address of the contract to be called\n', '      mstore(ptr, shl(96, address()))\n', '      // 20 bytes\n', '      ptr := add(ptr, 20)\n', '\n', '      // the remaining proxy code...\n', '      mstore(ptr, 0x5af43d3d93803e603457fd5bf300000000000000000000000000000000000000)\n', '      // ...13 bytes\n', '      ptr := add(ptr, 13)\n', '\n', '      // now calculdate the size and copy the metadata\n', '      // - 4 bytes function signature\n', '      let size := sub(calldatasize(), 4)\n', '      // copy\n', '      calldatacopy(ptr, 4, size)\n', '      ptr := add(ptr, size)\n', '      // store the size of the metadata at the end of the bytecode\n', '      mstore(ptr, size)\n', '      ptr := add(ptr, 32)\n', '\n', '      // The size is deploy code + contract code + calldatasize - 4 + 32.\n', '      addr := create(0, start, sub(ptr, start))\n', '    }\n', '  }\n', '}\n', '\n', '{\n', '  "evmVersion": "berlin",\n', '  "libraries": {},\n', '  "metadata": {\n', '    "bytecodeHash": "none"\n', '  },\n', '  "optimizer": {\n', '    "details": {\n', '      "constantOptimizer": true,\n', '      "cse": true,\n', '      "deduplicate": true,\n', '      "jumpdestRemover": true,\n', '      "orderLiterals": false,\n', '      "peephole": true,\n', '      "yul": false\n', '    },\n', '    "runs": 256\n', '  },\n', '  "remappings": [],\n', '  "outputSelection": {\n', '    "*": {\n', '      "*": [\n', '        "evm.bytecode",\n', '        "evm.deployedBytecode",\n', '        "abi"\n', '      ]\n', '    }\n', '  }\n', '}']