['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-09\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.8.0;\n', '\n', '\n', '\n', '// Part: IERC20\n', '\n', 'interface IERC20 {\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '}\n', '\n', '// Part: IERC721\n', '\n', 'interface IERC721 {\n', '    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n', '    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n', '    ///  THEY MAY BE PERMANENTLY LOST\n', '    /// @dev Throws unless `msg.sender` is the current owner, an authorized\n', '    ///  operator, or the approved address for this NFT. Throws if `_from` is\n', '    ///  not the current owner. Throws if `_to` is the zero address. Throws if\n', '    ///  `_tokenId` is not a valid NFT.\n', '    /// @param _from The current owner of the NFT\n', '    /// @param _to The new owner\n', '    /// @param _tokenId The NFT to transfer\n', '    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) external;\n', '    \n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    function approve(address to, uint256 tokenId) external;\n', '    \n', '    function isApprovedForAll(address owner, address operator) external returns (bool);\n', '}\n', '\n', '// Part: IMarketPlace\n', '\n', 'interface IMarketPlace {\n', '    \n', '    struct Order {\n', '        // Order ID\n', '        bytes32 id;\n', '        // Owner of the NFT\n', '        address seller;\n', '        // NFT registry address\n', '        address nftAddress;\n', '        // Price (in wei) for the published item\n', '        uint256 price;\n', '        // Time when this sale ends\n', '        uint256 expiresAt;\n', '    }\n', '    \n', '    /**\n', '    * @dev Executes the sale for a published NFT\n', '    * @param nftAddress - Address of the NFT registry\n', '    * @param assetId - ID of the published NFT\n', '    * @param price - Order price\n', '    */\n', '    function executeOrder(\n', '        address nftAddress,\n', '        uint256 assetId,\n', '        uint256 price\n', '    ) external;\n', '\n', '    function orderByAssetId(address nftAddress, uint256 assetId) external view returns (Order memory order);\n', '}\n', '\n', '// File: DecentralandMarket.sol\n', '\n', 'library DecentralandMarket {\n', '\n', '    address public constant MARKETPLACE_PROXY = 0x8e5660b4Ab70168b5a6fEeA0e0315cb49c8Cd539;\n', '    address public constant ACCEPTED_TOKEN = 0x0F5D2fB29fb7d3CFeE444a200298f468908cC942; // MANA\n', '\n', '    function buyAssetsForErc20(bytes memory data, address recipient) external {\n', '        address[] memory nftAddrs;\n', '        uint256[] memory assetIds;\n', '\n', '        (nftAddrs, assetIds) = abi.decode(\n', '            data,\n', '            (address[],uint256[])\n', '        );\n', '\n', '        for (uint256 i = 0; i < nftAddrs.length; i++) {\n', '            _buyAssetForErc20(assetIds[i], estimateAssetPriceInErc20(nftAddrs[i], assetIds[i]), nftAddrs[i], recipient);\n', '        }\n', '    }\n', '\n', '    function estimateAssetPriceInErc20(address nftAddress, uint256 assetId) public view returns(uint256) {\n', '        return IMarketPlace(MARKETPLACE_PROXY).orderByAssetId(nftAddress, assetId).price;\n', '    }\n', '\n', '    function estimateBatchAssetPriceInErc20(bytes memory data) external view returns(address[] memory erc20Addrs, uint256[] memory amounts) {\n', '        address[] memory nftAddrs;\n', '        uint256[] memory assetIds;\n', '\n', '        (nftAddrs, assetIds) = abi.decode(\n', '            data,\n', '            (address[],uint256[])\n', '        );\n', '        \n', '        erc20Addrs = new address[](nftAddrs.length);\n', '        amounts = new uint256[](assetIds.length);\n', '\n', '        for (uint256 i = 0; i < nftAddrs.length; i++) {\n', '            erc20Addrs[i] = ACCEPTED_TOKEN;\n', '            amounts[i] = estimateAssetPriceInErc20(nftAddrs[i], assetIds[i]);\n', '        }\n', '    }\n', '\n', '    function _buyAssetForErc20(uint256 _assetId, uint256 _price, address _nftAddr, address _recipient) internal {\n', '        IERC20(ACCEPTED_TOKEN).approve(MARKETPLACE_PROXY, _price);\n', '        IMarketPlace(MARKETPLACE_PROXY).executeOrder(_nftAddr, _assetId, _price);\n', '        IERC721(_nftAddr).transferFrom(address(this), _recipient, _assetId);\n', '    }\n', '}']