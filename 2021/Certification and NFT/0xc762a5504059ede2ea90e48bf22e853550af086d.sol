['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-25\n', '*/\n', '\n', '// Sources flattened with hardhat v2.0.11 https://hardhat.org\n', '\n', '// File @animoca/ethereum-contracts-assets_inventory/contracts/token/ERC721/[email\xa0protected]\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.8;\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard, basic interface\n', ' * @dev See https://eips.ethereum.org/EIPS/eip-721\n', ' * Note: The ERC-165 identifier for this interface is 0x80ac58cd.\n', ' */\n', 'interface IERC721 {\n', '    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n', '\n', '    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n', '\n', '    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n', '\n', '    /**\n', '     * Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return balance uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance);\n', '\n', '    /**\n', '     * Gets the owner of the specified ID\n', '     * @param tokenId uint256 ID to query the owner of\n', '     * @return owner address currently marked as the owner of the given ID\n', '     */\n', '    function ownerOf(uint256 tokenId) external view returns (address owner);\n', '\n', '    /**\n', '     * Approves another address to transfer the given token ID\n', '     * @dev The zero address indicates there is no approved address.\n', '     * @dev There can only be one approved address per token at a given time.\n', '     * @dev Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) external;\n', '\n', '    /**\n', '     * Gets the approved address for a token ID, or zero if no address set\n', '     * @dev Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return operator address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) external view returns (address operator);\n', '\n', '    /**\n', '     * Sets or unsets the approval of a given operator\n', '     * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param operator operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address operator, bool approved) external;\n', '\n', '    /**\n', '     * Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) external view returns (bool);\n', '\n', '    /**\n', '     * Transfers the ownership of a given token ID to another address\n', '     * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * @dev Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) external;\n', '\n', '    /**\n', '     * Safely transfers the ownership of a given token ID to another address\n', '     *\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     *\n', '     * @dev Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId\n', '    ) external;\n', '\n', '    /**\n', '     * Safely transfers the ownership of a given token ID to another address\n', '     *\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     *\n', '     * @dev Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 tokenId,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '\n', '// File @openzeppelin/contracts/introspection/[email\xa0protected]\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC165 standard, as defined in the\n', ' * https://eips.ethereum.org/EIPS/eip-165[EIP].\n', ' *\n', ' * Implementers can declare support of contract interfaces, which can then be\n', ' * queried by others ({ERC165Checker}).\n', ' *\n', ' * For an implementation, see {ERC165}.\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @dev Returns true if this contract implements the interface defined by\n', '     * `interfaceId`. See the corresponding\n', '     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n', '     * to learn more about how these ids are created.\n', '     *\n', '     * This function call must use less than 30 000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '\n', '// File @animoca/ethereum-contracts-assets_inventory/contracts/token/ERC721/[email\xa0protected]\n', '\n', 'pragma solidity 0.6.8;\n', '\n', '/**\n', '    @title ERC721 Non-Fungible Token Standard, token receiver\n', '    @dev See https://eips.ethereum.org/EIPS/eip-721\n', '    Interface for any contract that wants to support safeTransfers from ERC721 asset contracts.\n', '    Note: The ERC-165 identifier for this interface is 0x150b7a02.\n', ' */\n', 'interface IERC721Receiver {\n', '    /**\n', '        @notice Handle the receipt of an NFT\n', '        @dev The ERC721 smart contract calls this function on the recipient\n', '        after a {IERC721-safeTransferFrom}. This function MUST return the function selector,\n', '        otherwise the caller will revert the transaction. The selector to be\n', '        returned can be obtained as `this.onERC721Received.selector`. This\n', '        function MAY throw to revert and reject the transfer.\n', '        Note: the ERC721 contract address is always the message sender.\n', '        @param operator The address which called `safeTransferFrom` function\n', '        @param from The address which previously owned the token\n', '        @param tokenId The NFT identifier which is being transferred\n', '        @param data Additional data with no specified format\n', '        @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(\n', '        address operator,\n', '        address from,\n', '        uint256 tokenId,\n', '        bytes calldata data\n', '    ) external returns (bytes4);\n', '}\n', '\n', '\n', '// File @animoca/ethereum-contracts-assets_inventory/contracts/token/ERC721/[email\xa0protected]\n', '\n', 'pragma solidity 0.6.8;\n', '\n', '\n', 'abstract contract ERC721Receiver is IERC721Receiver, IERC165 {\n', '    bytes4 private constant _ERC165_INTERFACE_ID = type(IERC165).interfaceId;\n', '    bytes4 private constant _ERC721_RECEIVER_INTERFACE_ID = type(IERC721Receiver).interfaceId;\n', '\n', '    bytes4 internal constant _ERC721_RECEIVED = type(IERC721Receiver).interfaceId;\n', '    bytes4 internal constant _ERC721_REJECTED = 0xffffffff;\n', '\n', '    /**\n', '     * @dev See {IERC165-supportsInterface}.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n', '        return interfaceId == _ERC165_INTERFACE_ID || interfaceId == _ERC721_RECEIVER_INTERFACE_ID;\n', '    }\n', '}\n', '\n', '\n', '// File contracts/token/ERC1155721/BlackHoleBoredElonTweeter.sol\n', '\n', 'pragma solidity ^0.6.8;\n', '\n', '\n', 'contract BlackHoleBoredElonTweeter is ERC721Receiver {\n', '\n', '    address public constant RARIBLE_NFT_CONTRACT = 0x60F80121C31A0d46B5279700f9DF786054aa5eE5;\n', '    uint256 public constant BOREDELON_TWEET_NFT_ID = 182768;\n', '\n', '    // some place with no way back\n', '    address public constant BLACK_HOLE = 0xDeAD0deAD0DeAd0DEaD0dEAd0DeaD0dEAd0DEaD1;\n', '\n', '    string public daImmortalText;\n', '    string public daImmortalAuthor;\n', '    address public daImmortalOwner;\n', '\n', '    function onERC721Received(\n', '        address /*operator*/,\n', '        address from,\n', '        uint256 tokenId,\n', '        bytes calldata data\n', '    ) external override returns (bytes4) {\n', '        // Door to hell, no trespassers\n', '        require(msg.sender == RARIBLE_NFT_CONTRACT, "Wrong contract");\n', '        require(tokenId == BOREDELON_TWEET_NFT_ID, "Wrong token");\n', '\n', '        // Mark this moment forever on-chain\n', '        daImmortalOwner = from;\n', '        (daImmortalText, daImmortalAuthor) = abi.decode(data, (string, string));\n', '\n', '        // NFT destruction\n', '        IERC721(RARIBLE_NFT_CONTRACT).transferFrom(address(this), BLACK_HOLE, BOREDELON_TWEET_NFT_ID);\n', '\n', '        // All went well :)\n', '        return _ERC721_RECEIVED;\n', '    }\n', '}']