['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-28\n', '*/\n', '\n', '// File: contracts/utils/Address.sol\n', '\n', 'pragma solidity 0.5.17;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n', '        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n', "        // for accounts without code, i.e. `keccak256('')`\n", '        bytes32 codehash;\n', '        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { codehash := extcodehash(account) }\n', '        return (codehash != accountHash && codehash != 0x0);\n', '    }\n', '\n', '    /**\n', '     * @dev Converts an `address` into `address payable`. Note that this is\n', '     * simply a type cast: the actual underlying value is not changed.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function toPayable(address account) internal pure returns (address payable) {\n', '        return address(uint160(account));\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-call-value\n', '        (bool success, ) = recipient.call.value(amount)("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '}\n', '\n', '// File: contracts/utils/SafeMath.sol\n', '\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return sub(a, b, "SafeMath: subtraction overflow");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     * - Subtraction cannot overflow.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return div(a, b, "SafeMath: division by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, errorMessage);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return mod(a, b, "SafeMath: modulo by zero");\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * Reverts with custom message when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     * - The divisor cannot be zero.\n', '     *\n', '     * _Available since v2.4.0._\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b != 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title A simple holder of tokens.\n', " * This is a simple contract to hold tokens. It's useful in the case where a separate contract\n", ' * needs to hold multiple distinct pools of the same token.\n', ' */\n', 'contract TokenPool {\n', '    IUniswapV2Router02 public uniswapRouterV2;\n', '    IUniswapV2Factory public uniswapFactory;\n', '    address public rptContract;\n', '\n', '    constructor() public {\n', '      uniswapRouterV2 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '      uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n', '      rptContract = 0xa0Bb0027C28ade4Ac628b7f81e7b93Ec71b4E020;\n', '    }\n', '\n', '    function balance(address token) public view returns (uint256) {\n', '        return IERC20(token).balanceOf(address(this));\n', '    }\n', '\n', '    function () external payable {}\n', '\n', '\n', '    function swapETHForRPT() external {\n', '        if(address(this).balance > 0) {\n', '          address[] memory uniswapPairPath = new address[](2);\n', '          uniswapPairPath[0] = rptContract; // RPT contract address\n', '          uniswapPairPath[1] = uniswapRouterV2.WETH(); // weth address\n', '\n', '          uniswapRouterV2.swapExactETHForTokensSupportingFeeOnTransferTokens.value(address(this).balance)(\n', '                  0,\n', '                  uniswapPairPath,\n', '                  address(this),\n', '                  block.timestamp\n', '              );\n', '        }\n', '    }\n', '\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n', ' * the optional functions; to access them see {ERC20Detailed}.\n', ' */\n', 'interface IERC20 {\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '}\n', '\n', 'interface IUniswapV2Factory {\n', '    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n', '    function createPair(address tokenA, address tokenB) external returns (address pair);\n', '    function getPair(address tokenA, address tokenB) external view returns (address pair);\n', '}\n', '\n', 'interface IUniswapV2Router02 {\n', '    function WETH() external pure returns (address);\n', '    function addLiquidityETH(\n', '        address token,\n', '        uint amountTokenDesired,\n', '        uint amountTokenMin,\n', '        uint amountETHMin,\n', '        address to,\n', '        uint deadline\n', '    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n', '    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n', '        uint amountOutMin,\n', '        address[] calldata path,\n', '        address to,\n', '        uint deadline\n', '    )  external payable;\n', '}\n', '\n', '// File: contracts/RugProofMaster.sol\n', '\n', '/*\n', 'Rug Proof Master Contract\n', '\n', 'Website: rugproof.io\n', '\n', 'The Rug Proof Master Contract is an experimental rug proof token sale platform.\n', '\n', 'This contract allows token sellers to predefine liquidity % amounts that are validated and trustless.\n', 'This allows buyers of the token sale to have confidence in what they are buying, as it ensures liquidity gets locked.\n', '\n', 'A 1% platform tax is applied which market buys RPT and locks it into the burn pool.\n', '\n', 'At the end of a successful sale, any remaining tokens are sent to the burn pool.\n', '\n', 'If a sale does not meet its softcap after the end time, users can get their ETH refund minus the 1% platform tax.\n', '*/\n', '\n', '\n', '\n', '\n', 'contract RugProofMaster {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    struct SaleInfo {\n', '      address contractAddress; // address of the token\n', '      address payable receiveAddress; // address to receive ETH\n', '      uint256 tokenAmount; // amount of tokens to sell\n', '      uint256 tokenRatio; // ratio of ETH to token\n', '      uint256 totalEth; // total eth currently raised\n', '      uint256 softcap; // amount of ETH we need to set this as a success\n', '      uint32 counter; // amount of buyers\n', '      uint32 timestampStartSec; // unix second start\n', '      uint32 timestampEndSec; // unix second end\n', '      uint8 liquidityLockPercent; // 20 = 20%, capped at 100%, intervals of 1%\n', '      bool isEnded; // signals the end of this sale\n', '      bool isSuccess; // if false, users can claim their eth back\n', '      mapping(address => uint256) ethContributed; // amount of eth contributed per address\n', '    }\n', '\n', '    SaleInfo[] public tokenSales;\n', '\n', '    IUniswapV2Router02 public uniswapRouterV2;\n', '    IUniswapV2Factory public uniswapFactory;\n', '\n', '    //inaccessible contract that stores funds\n', '    //cannot use 0 address because some tokens prohibit it without a burn function\n', '    TokenPool public burnPool;\n', '\n', '    // address for the RPT token\n', '    address public rptContract;\n', '\n', '    // Amount of wei raised in this contracts lifetime\n', '    uint256 public _weiRaised;\n', '\n', '    uint256 public rptTax;\n', '\n', '    address public owner;\n', '\n', '    bool private _notEntered;\n', '\n', '\n', '    event LogCreateNewSale(address _contract, uint256 _tokenAmount);\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "RugProofMaster::OnlyOwner: Not the owner");\n', '        _;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        // On the first call to nonReentrant, _notEntered will be true\n', '        require(_notEntered, "ReentrancyGuard: reentrant call");\n', '\n', '        // Any calls to nonReentrant after this point will fail\n', '        _notEntered = false;\n', '\n', '        _;\n', '\n', '        // By storing the original value once again, a refund is triggered (see\n', '        // https://eips.ethereum.org/EIPS/eip-2200)\n', '        _notEntered = true;\n', '    }\n', '\n', '    function initialize(address router, address factory, address _rptContract) public {\n', '        require(owner == address(0x0), "RugProofMaster::Initialize: Already initialized");\n', '        //uniswapRouterV2 = IUniswapV2Router02(router != address(0) ? router : 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D); // For testing\n', '        //uniswapFactory = IUniswapV2Factory(factory != address(0) ? factory : 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f); // For testing\n', '        //rptContract = _rptContract != address(0) ? _rptContract : 0xa0Bb0027C28ade4Ac628b7f81e7b93Ec71b4E020; // For testing\n', '        uniswapRouterV2 = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n', '        uniswapFactory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);\n', '        rptContract = 0xa0Bb0027C28ade4Ac628b7f81e7b93Ec71b4E020;\n', '\n', '        burnPool = new TokenPool();\n', '        rptTax = 1;\n', '        owner = msg.sender;\n', '\n', '        _notEntered = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Sets the % tax for each purchase. This tax sends market buys and burns RPT\n', '     *\n', '     */\n', '    function setTax(uint256 _rptTax) public onlyOwner {\n', '        require(_rptTax <= 100, "RugProofMaster::setTax: tax is too high");\n', '        rptTax = _rptTax;\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Creates a token sale with a timer.\n', '     *\n', '     *      _contractAddress: contract of the token being sold\n', '     *      _tokenAmount: amount of tokens being sold\n', '     *      _tokenRatio: price of the token vs ETH i.e. 1e9 and a user buys 0.5 ETH worth => tokenRatio * ETHAmount / ETH Decimals = (1e9 * 0.5e18)/1e18\n', '     *      _timestampStartSec: unix time in seconds when the sale starts\n', '     *      _timestampStartSec: unix time in seconds when the sale ends\n', '     *      _liquidityLockPercent: % of the sale that should go to locked ETH liquidity i.e. 50 => 50%. Capped at 100, increments of 1%\n', '     *      _softcap: ETH amount that is needed for the sale to be a success\n', '     */\n', '    function createNewTokenSale(\n', '      address _contractAddress, uint256 _tokenAmount,\n', '      uint256 _tokenRatio, uint32 _timestampEndSec,\n', '      uint8 _liquidityLockPercent, uint256 _softcap) external {\n', '\n', '        require(_contractAddress != address(0), "CreateNewTokenSale: Cannot use the zero address");\n', '        require(msg.sender != address(this), "CreateNewTokenSale: Cannot call from this contract");\n', '        require(_tokenAmount != 0, "CreateNewTokenSale: Cannot sell zero tokens");\n', '        require(_tokenRatio != 0, "CreateNewTokenSale: Cannot have a zero ratio");\n', '        require(_softcap != 0, "CreateNewTokenSale: Cannot have a zero softcap");\n', '        require(_timestampEndSec > now, "CreateNewTokenSale: Cannot start sale after end time");\n', '        require(_liquidityLockPercent <= 100, "CreateNewTokenSale: Cannot have higher than 100% liquidity lock");\n', '\n', '        // check how many tokens we receive\n', '        // this is an important step to ensure we log proper amounts if this is a deflationary token\n', '        // approve must be called before this function is executed. Need to approve this contract address to send the token amount\n', '        uint256 tokenBalanceBeforeTransfer = IERC20(_contractAddress).balanceOf(address(this));\n', '        IERC20(_contractAddress).transferFrom(address(msg.sender), address(this), _tokenAmount);\n', '        uint256 tokensReceived = IERC20(_contractAddress).balanceOf(address(this)).sub(tokenBalanceBeforeTransfer);\n', '\n', '\n', '        SaleInfo memory saleInfo = SaleInfo(\n', '          _contractAddress, msg.sender, tokensReceived, _tokenRatio, 0, _softcap,\n', '          0, uint32(now), _timestampEndSec, _liquidityLockPercent, false, false\n', '          );\n', '\n', '        tokenSales.push(saleInfo);\n', '    }\n', '\n', '    /**\n', '     * @dev Enabled ability for tokens to be withdrawn by buyers after the sale has ended successfully.\n', '                     On a successful sale (softcap reached by time, or hardcap reached), this function:\n', '                     1. Creates uniswap pair if not created.\n', '                     2. adds token liquidity to uniswap pair.\n', '                     3. burns tokens if hardcap was not met\n', '     *\n', '     *      contractIndex: index of the token sale. See tokenSales variable\n', '     *\n', '     */\n', '    function endTokenSale(uint256 contractIndex) external {\n', '        SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\n', '\n', '        uint256 hardcapETH = tokenSaleInfo.tokenAmount.mul(100 - tokenSaleInfo.liquidityLockPercent).div(100);\n', '\n', '        //require(tokenSaleInfo.receiveAddress == msg.sender, "endTokenSale: can only be called by funding owner");\n', '        require(tokenSaleInfo.isEnded == false, "endTokenSale: token sale has ended already");\n', '        require(block.timestamp > tokenSaleInfo.timestampEndSec || hardcapETH <= tokenSaleInfo.totalEth, "endTokenSale: token sale is not over yet");\n', '        require(IERC20(tokenSaleInfo.contractAddress).balanceOf(address(this)) >= tokenSaleInfo.tokenAmount,  "endTokenSale: contract does not have enough tokens");\n', '\n', '        // flag that allows ends this funding round\n', '        // also allows token withdrawals and refunds if failed\n', '        tokenSaleInfo.isEnded = true;\n', '\n', '        // sale was a success if we hit the softcap\n', '        if(tokenSaleInfo.totalEth >= tokenSaleInfo.softcap){\n', '          tokenSaleInfo.isSuccess = true;\n', '\n', '          uint256 saleEthToLock = tokenSaleInfo.totalEth.mul(tokenSaleInfo.liquidityLockPercent).div(100);\n', '          uint256 saleEthToUnlock = tokenSaleInfo.totalEth.mul(saleEthToLock);\n', '\n', '          uint256 tokenAmountToLock = saleEthToLock.mul(tokenSaleInfo.tokenRatio).div(1e18);\n', '          uint256 tokenAmountToUnlock = saleEthToUnlock.mul(tokenSaleInfo.tokenRatio).div(1e18);\n', '\n', '          // send the ETH to the owner of the sale so they can pay for the uniswap pair\n', '          tokenSaleInfo.receiveAddress.transfer(saleEthToUnlock);\n', '\n', '          // create uniswap pair\n', '          createUniswapPairMainnet(tokenSaleInfo.contractAddress);\n', '\n', '          // burn the rest of the tokens if there are any left\n', '          uint256 tokenAmountToBurn = tokenSaleInfo.tokenAmount.sub(tokenAmountToLock).sub(tokenAmountToUnlock);\n', '\n', '          if(tokenAmountToBurn > 0){\n', '            IERC20(tokenSaleInfo.contractAddress).transfer(address(burnPool), tokenAmountToBurn);\n', '          }\n', '\n', '          // add liquidity to uniswap pair\n', '          addLiquidity(tokenSaleInfo.contractAddress, tokenAmountToLock, saleEthToLock);\n', '\n', '        } else {\n', '          tokenSaleInfo.isSuccess = false;\n', '          // transfer the token amount from this address back to the owner\n', '          IERC20(tokenSaleInfo.contractAddress).transfer(tokenSaleInfo.receiveAddress, tokenSaleInfo.tokenAmount);\n', '        }\n', '\n', '        burnPool.swapETHForRPT();\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     * @dev Buys tokens from the token sale from the function caller. A tax is applied here based on the rptTax.\n', '     *               ETH tax is sent to the burn pool which can be used to market buy RPT. This is nonrefundable\n', '     *\n', '     *               Prevents users from buying in if the hardcap is met, or if the sale is expired.\n', '     *\n', '     *      contractIndex: index of the token sale. See tokenSales variable\n', '     *\n', '     */\n', '    function buyTokens(uint256 contractIndex) external payable nonReentrant{\n', '      require(msg.value != 0, "buyTokens: msg.value is 0");\n', '\n', '      uint256 weiAmount = msg.value;\n', '      uint256 weiAmountTax = weiAmount.mul(rptTax).div(100);\n', '\n', '      SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\n', '\n', '      // make sure this sale exists\n', '      require(tokenSales.length > contractIndex, "buyTokens: no token sale for this index");\n', '      // make sure we are not raising too much ETH\n', '      // we can only raise this much eth\n', '      uint256 hardcapETH = tokenSaleInfo.tokenAmount.mul(100 - tokenSaleInfo.liquidityLockPercent).div(100);\n', '      require(hardcapETH >= tokenSaleInfo.totalEth.add(weiAmount.sub(weiAmountTax)), "buyTokens: Sale has reached hardcap");\n', '      // make sure this sale is not over\n', '      require(tokenSaleInfo.timestampEndSec > block.timestamp && tokenSaleInfo.isEnded == false, "buyTokens: Token sale is over");\n', '\n', '\n', '      // log raised eth\n', '      tokenSaleInfo.ethContributed[msg.sender] = tokenSaleInfo.ethContributed[msg.sender].add(weiAmount.sub(weiAmountTax));\n', '      tokenSaleInfo.totalEth = tokenSaleInfo.totalEth.add(weiAmount.sub(weiAmountTax));\n', '\n', '      // increment buyer\n', '      tokenSaleInfo.counter++;\n', '\n', '      // log global raised amount\n', '      _weiRaised = _weiRaised.add(weiAmount);\n', '\n', '      // send eth to burn pool to marketbuy later\n', '      address(burnPool).transfer(weiAmountTax);\n', '    }\n', '\n', '\n', '    /**\n', '     * @dev Withdraws tokens the are bought from the sale if the message sender has any.\n', '     *\n', '     *\n', '     *      contractIndex: index of the token sale. See tokenSales variable\n', '     *\n', '     */\n', '    function claimTokens(uint256 contractIndex) external {\n', '      require(tokenSales.length > contractIndex, "claimTokens: no available token sale");\n', '\n', '      SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\n', '      require(tokenSaleInfo.isEnded == true, "claimTokens: token sale has not ended");\n', '      require(tokenSaleInfo.isSuccess == true, "claimTokens: token sale was not successful");\n', '      require(tokenSaleInfo.ethContributed[msg.sender] > 0, "claimTokens: address contributed nothing");\n', '\n', '      // prevent caller from re-entering\n', '      tokenSaleInfo.ethContributed[msg.sender] = 0;\n', '\n', '      uint256 tokenAmountToSend = tokenSaleInfo.ethContributed[msg.sender].mul(tokenSaleInfo.tokenRatio).div(1e18);\n', '\n', '      IERC20(tokenSaleInfo.contractAddress).transfer(address(msg.sender), tokenAmountToSend);\n', '    }\n', '\n', '\n', '\n', '    /**\n', '     * @dev If a sale was not successful, allows users to withdraw their ETH from the sale minus the tax amount\n', '     *\n', '     *\n', '     *      contractIndex: index of the token sale. See tokenSales variable\n', '     *\n', '     */\n', '    function withdrawRefundedETH(uint256 contractIndex) external {\n', '      require(tokenSales.length > contractIndex, "withdrawRefundedETH: no available token sale");\n', '\n', '      SaleInfo storage tokenSaleInfo = tokenSales[contractIndex];\n', '      // allow refunds when sale is over and was not a success\n', '      if(tokenSaleInfo.isEnded == true && tokenSaleInfo.isSuccess == false && tokenSaleInfo.ethContributed[msg.sender] > 0){\n', '        //refund eth back to msgOwner\n', '        address(msg.sender).transfer(tokenSaleInfo.ethContributed[msg.sender]);\n', '        // set eth contributed to this sale as 0\n', '        tokenSaleInfo.ethContributed[msg.sender] = 0;\n', '      }\n', '    }\n', '\n', '\n', '\n', '\n', '    function getTokenSalesOne() public view returns (address[] memory, address[] memory, uint256[] memory, uint256[] memory)\n', '    {\n', '\n', '      address[] memory contractAddresses = new address[](tokenSales.length);\n', '      address[] memory receiveAddresses = new address[](tokenSales.length);\n', '      uint256[] memory tokenAmounts = new uint256[](tokenSales.length);\n', '      uint256[] memory tokenRatios = new uint256[](tokenSales.length);\n', '\n', '      for (uint i = 0; i < tokenSales.length; i++) {\n', '          SaleInfo storage saleInfo = tokenSales[i];\n', '          contractAddresses[i] = saleInfo.contractAddress;\n', '          receiveAddresses[i] = saleInfo.receiveAddress;\n', '          tokenAmounts[i] = saleInfo.tokenAmount;\n', '          tokenRatios[i] = saleInfo.tokenRatio;\n', '      }\n', '\n', '      return (contractAddresses, receiveAddresses, tokenAmounts, tokenRatios);\n', '    }\n', '    function getTokenSalesTwo() public view returns (uint32[] memory, uint32[] memory, uint8[] memory, uint256[] memory)\n', '    {\n', '      uint32[] memory timestampStartSec = new uint32[](tokenSales.length);\n', '      uint32[] memory timestampEndSec = new uint32[](tokenSales.length);\n', '      uint8[] memory liquidityLockPercents = new uint8[](tokenSales.length);\n', '      uint256[] memory totalEths = new uint256[](tokenSales.length);\n', '\n', '      for (uint i = 0; i < tokenSales.length; i++) {\n', '          SaleInfo storage saleInfo = tokenSales[i];\n', '          timestampStartSec[i] = saleInfo.timestampStartSec;\n', '          timestampEndSec[i] = saleInfo.timestampEndSec;\n', '          liquidityLockPercents[i] = saleInfo.liquidityLockPercent;\n', '          totalEths[i] = saleInfo.totalEth;\n', '      }\n', '\n', '      return (timestampStartSec, timestampEndSec, liquidityLockPercents, totalEths);\n', '    }\n', '    function getTokenSalesThree() public view returns (bool[] memory, bool[] memory, uint256[] memory, uint32[] memory, uint256[] memory)\n', '    {\n', '      bool[] memory isEnded = new bool[](tokenSales.length);\n', '      bool[] memory isSuccess = new bool[](tokenSales.length);\n', '      uint256[] memory softcaps = new uint256[](tokenSales.length);\n', '      uint32[] memory counters = new uint32[](tokenSales.length);\n', '      uint256[] memory contributions = new uint256[](tokenSales.length);\n', '\n', '      for (uint i = 0; i < tokenSales.length; i++) {\n', '          SaleInfo storage saleInfo = tokenSales[i];\n', '          isEnded[i] = saleInfo.isEnded;\n', '          isSuccess[i] = saleInfo.isSuccess;\n', '          softcaps[i] = saleInfo.softcap;\n', '          counters[i] = saleInfo.counter;\n', '          contributions[i] = saleInfo.ethContributed[msg.sender];\n', '      }\n', '\n', '      return (isEnded, isSuccess, softcaps, counters, contributions);\n', '    }\n', '\n', '\n', '    function getContribution(uint contractIndex) public view returns (uint256){\n', '      require(tokenSales.length > contractIndex, "withdrawRefundedETH: no available token sale");\n', '\n', '      uint256 ethContributed = tokenSales[contractIndex].ethContributed[msg.sender];\n', '\n', '      return (ethContributed);\n', '    }\n', '\n', '\n', '    function createUniswapPairMainnet(address _contractAddress) internal returns (bool) {\n', '        require(_contractAddress == address(0), "CreateUniswapPairMainnet: cannot create uniswap pair for zero address");\n', '        address pairAddress = uniswapFactory.getPair(_contractAddress, address(uniswapRouterV2.WETH()));\n', '\n', '        // zero address means this pair has not been created, we need to create it\n', '        if(pairAddress == address(0)){\n', '          address tokenUniswapPair = uniswapFactory.createPair( address(uniswapRouterV2.WETH()), _contractAddress);\n', '\n', '          require(tokenUniswapPair != address(0), "createUniswapPairMainnet: issue creating pair");\n', '        }\n', '\n', '        return true;\n', '    }\n', '\n', '    function addLiquidity(address contractAddress, uint256 tokenAmount, uint256 ethAmount) internal {\n', '        // need to approve the token movement\n', '        IERC20(contractAddress).approve(address(uniswapRouterV2), tokenAmount);\n', '\n', '        // transfer lp tokens directly into burn pool\n', '        uniswapRouterV2.addLiquidityETH.value(ethAmount)(\n', '                contractAddress,\n', '                tokenAmount,\n', '                0,\n', '                0,\n', '                address(burnPool),\n', '                block.timestamp\n', '            );\n', '    }\n', '}']