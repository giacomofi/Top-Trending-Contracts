['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-05\n', '*/\n', '\n', '// "SPDX-License-Identifier: GPL-3.0-or-later"\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '\n', '// Highly opinionated token implementation\n', '\n', 'interface IERC20 {\n', '\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address whom) external view returns (uint);\n', '    function allowance(address src, address dst) external view returns (uint);\n', '\n', '    function approve(address dst, uint amt) external returns (bool);\n', '    function transfer(address dst, uint amt) external returns (bool);\n', '    function transferFrom(\n', '        address src, address dst, uint amt\n', '    ) external returns (bool);\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '/// @title Derivative Specification interface\n', '/// @notice Immutable collection of derivative attributes\n', "/// @dev Created by the derivative's author and published to the DerivativeSpecificationRegistry\n", 'interface IDerivativeSpecification {\n', '    /// @notice Proof of a derivative specification\n', '    /// @dev Verifies that contract is a derivative specification\n', '    /// @return true if contract is a derivative specification\n', '    function isDerivativeSpecification() external pure returns (bool);\n', '\n', '    /// @notice Set of oracles that are relied upon to measure changes in the state of the world\n', '    /// between the start and the end of the Live period\n', '    /// @dev Should be resolved through OracleRegistry contract\n', '    /// @return oracle symbols\n', '    function oracleSymbols() external view returns (bytes32[] memory);\n', '\n', '    /// @notice Algorithm that, for the type of oracle used by the derivative,\n', '    /// finds the value closest to a given timestamp\n', '    /// @dev Should be resolved through OracleIteratorRegistry contract\n', '    /// @return oracle iterator symbols\n', '    function oracleIteratorSymbols() external view returns (bytes32[] memory);\n', '\n', '    /// @notice Type of collateral that users submit to mint the derivative\n', '    /// @dev Should be resolved through CollateralTokenRegistry contract\n', '    /// @return collateral token symbol\n', '    function collateralTokenSymbol() external view returns (bytes32);\n', '\n', '    /// @notice Mapping from the change in the underlying variable (as defined by the oracle)\n', '    /// and the initial collateral split to the final collateral split\n', '    /// @dev Should be resolved through CollateralSplitRegistry contract\n', '    /// @return collateral split symbol\n', '    function collateralSplitSymbol() external view returns (bytes32);\n', '\n', "    /// @notice Lifecycle parameter that define the length of the derivative's Live period.\n", '    /// @dev Set in seconds\n', '    /// @return live period value\n', '    function livePeriod() external view returns (uint256);\n', '\n', '    /// @notice Parameter that determines starting nominal value of primary asset\n', '    /// @dev Units of collateral theoretically swappable for 1 unit of primary asset\n', '    /// @return primary nominal value\n', '    function primaryNominalValue() external view returns (uint256);\n', '\n', '    /// @notice Parameter that determines starting nominal value of complement asset\n', '    /// @dev Units of collateral theoretically swappable for 1 unit of complement asset\n', '    /// @return complement nominal value\n', '    function complementNominalValue() external view returns (uint256);\n', '\n', '    /// @notice Minting fee rate due to the author of the derivative specification.\n', '    /// @dev Percentage fee multiplied by 10 ^ 12\n', '    /// @return author fee\n', '    function authorFee() external view returns (uint256);\n', '\n', '    /// @notice Symbol of the derivative\n', '    /// @dev Should be resolved through DerivativeSpecificationRegistry contract\n', '    /// @return derivative specification symbol\n', '    function symbol() external view returns (string memory);\n', '\n', '    /// @notice Return optional long name of the derivative\n', "    /// @dev Isn't used directly in the protocol\n", '    /// @return long name\n', '    function name() external view returns (string memory);\n', '\n', '    /// @notice Optional URI to the derivative specs\n', "    /// @dev Isn't used directly in the protocol\n", '    /// @return URI to the derivative specs\n', '    function baseURI() external view returns (string memory);\n', '\n', '    /// @notice Derivative spec author\n', "    /// @dev Used to set and receive author's fee\n", '    /// @return address of the author\n', '    function author() external view returns (address);\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'interface IVault {\n', '    /// @notice vault initialization time\n', '    function initializationTime() external view returns(uint256);\n', '    /// @notice start of live period\n', '    function liveTime() external view returns(uint256);\n', '    /// @notice end of live period\n', '    function settleTime() external view returns(uint256);\n', '\n', '    /// @notice underlying value at the start of live period\n', '    function underlyingStarts(uint index) external view returns(int256);\n', '    /// @notice underlying value at the end of live period\n', '    function underlyingEnds(uint index) external view returns(int256);\n', '\n', '    /// @notice primary token conversion rate multiplied by 10 ^ 12\n', '    function primaryConversion() external view returns(uint256);\n', '    /// @notice complement token conversion rate multiplied by 10 ^ 12\n', '    function complementConversion() external view returns(uint256);\n', '\n', '    // @notice derivative specification address\n', '    function derivativeSpecification() external view returns(IDerivativeSpecification);\n', '    // @notice collateral token address\n', '    function collateralToken() external view returns(IERC20);\n', '    // @notice oracle address\n', '    function oracles(uint index) external view returns(address);\n', '    function oracleIterators(uint index) external view returns(address);\n', '\n', '    // @notice primary token address\n', '    function primaryToken() external view returns(IERC20);\n', '    // @notice complement token address\n', '    function complementToken() external view returns(IERC20);\n', '\n', '    function mint(uint256 _collateralAmount) external;\n', '\n', '    function mintTo(address _recipient, uint256 _collateralAmount) external;\n', '\n', '    function refund(uint256 _tokenAmount) external;\n', '\n', '    function refundTo(address _recipient, uint256 _tokenAmount) external;\n', '\n', '    function redeem(\n', '        uint256 _primaryTokenAmount,\n', '        uint256 _complementTokenAmount,\n', '        uint256[] memory _underlyingEndRoundHints\n', '    ) external;\n', '\n', '    function redeemTo(\n', '        address _recipient,\n', '        uint256 _primaryTokenAmount,\n', '        uint256 _complementTokenAmount,\n', '        uint256[] memory _underlyingEndRoundHints\n', '    ) external;\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'interface IPool is IERC20 {\n', '\n', '    function repricingBlock() external view returns(uint);\n', '\n', '    function baseFee() external view returns(uint);\n', '    function feeAmp() external view returns(uint);\n', '    function maxFee() external view returns(uint);\n', '\n', '    function pMin() external view returns(uint);\n', '    function qMin() external view returns(uint);\n', '    function exposureLimit() external view returns(uint);\n', '    function volatility() external view returns(uint);\n', '\n', '    function derivativeVault() external view returns(IVault);\n', '    function dynamicFee() external view returns(address);\n', '    function repricer() external view returns(address);\n', '\n', '    function isFinalized()\n', '    external view\n', '    returns (bool);\n', '\n', '    function getNumTokens()\n', '    external view\n', '    returns (uint);\n', '\n', '    function getTokens()\n', '    external view\n', '    returns (address[] memory tokens);\n', '\n', '    function getLeverage(address token)\n', '    external view\n', '    returns (uint);\n', '\n', '    function getBalance(address token)\n', '    external view\n', '    returns (uint);\n', '\n', '    function getController()\n', '    external view\n', '    returns (address);\n', '\n', '    function setController(address manager)\n', '    external;\n', '\n', '\n', '    function joinPool(uint poolAmountOut, uint[2] calldata maxAmountsIn)\n', '    external;\n', '\n', '    function exitPool(uint poolAmountIn, uint[2] calldata minAmountsOut)\n', '    external;\n', '\n', '    function swapExactAmountIn(\n', '        address tokenIn,\n', '        uint tokenAmountIn,\n', '        address tokenOut,\n', '        uint minAmountOut\n', '    )\n', '    external\n', '    returns (uint tokenAmountOut, uint spotPriceAfter);\n', '}\n', '\n', 'pragma solidity 0.7.6;\n', '\n', 'interface IERC20Metadata {\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    function decimals() external view returns (uint8);\n', '}\n', '\n', '// File: contracts/ProxyActions.sol\n', '\n', 'pragma solidity 0.7.6;\n', '\n', '\n', '\n', 'contract ProxyActions {\n', '\n', '    uint public constant BONE = 10**18;\n', '\n', '    // Using vars to avoid stack do deep error\n', '    struct Vars {\n', '        IERC20 collateralToken;\n', '        IERC20 primaryToken;\n', '        IERC20 complementToken;\n', '        IVault vault;\n', '        IPool pool;\n', '        uint256 primaryTokenBalance;\n', '        uint256 complementTokenBalance;\n', '        uint256 primaryTokenAmount;\n', '        uint256 complementTokenAmount;\n', '        IERC20 derivativeIn;\n', '        IERC20 derivativeOut;\n', '        uint256 tokenDecimals;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the smallest of two numbers.\n', '     */\n', '    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        return a < b ? a : b;\n', '    }\n', '\n', '    /// @notice Direct method mint\n', '    function mint(\n', '        address _vault,\n', '        uint256 _collateralAmount\n', '    ) external {\n', '\n', '        Vars memory vars;\n', '        vars.vault = IVault(_vault);\n', '        vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '        // Transfer collateral from user to Proxy\n', '        require(\n', '            vars.collateralToken.transferFrom(msg.sender, address(this), _collateralAmount),\n', '            "COLLATERAL_IN"\n', '        );\n', '\n', '        vars.collateralToken.approve(_vault, _collateralAmount);\n', '\n', '        vars.vault.mintTo(msg.sender, _collateralAmount);\n', '    }\n', '\n', '    /// @notice Direct method refund\n', '    function refund(\n', '        address _vault,\n', '        uint256 _tokenAmount\n', '    ) external {\n', '\n', '        Vars memory vars;\n', '        vars.vault = IVault(_vault);\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '\n', '        require(\n', '            vars.primaryToken.transferFrom(msg.sender, address(this), _tokenAmount),\n', '            "PRIMARY_IN"\n', '        );\n', '\n', '        require(\n', '            vars.complementToken.transferFrom(msg.sender, address(this), _tokenAmount),\n', '            "COLLATERAL_IN"\n', '        );\n', '\n', '        vars.primaryToken.approve(_vault, _tokenAmount);\n', '        vars.complementToken.approve(_vault, _tokenAmount);\n', '\n', '        vars.vault.refundTo(msg.sender, _tokenAmount);\n', '    }\n', '\n', '    /// @notice Direct method redeem\n', '    function redeem(\n', '        address _vault,\n', '        uint256 _primaryTokenAmount,\n', '        uint256 _complementTokenAmount,\n', '        uint256[] memory _underlyingEndRoundHints\n', '    ) external {\n', '\n', '        Vars memory vars;\n', '        vars.vault = IVault(_vault);\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '\n', '        // Transfer collateral from user to Proxy\n', '        if(_primaryTokenAmount > 0) {\n', '            require(\n', '                vars.primaryToken.transferFrom(msg.sender, address(this), _primaryTokenAmount),\n', '                "PRIMARY_IN"\n', '            );\n', '            vars.primaryToken.approve(_vault, _primaryTokenAmount);\n', '        }\n', '\n', '        if(_complementTokenAmount > 0) {\n', '            require(\n', '                vars.complementToken.transferFrom(msg.sender, address(this), _complementTokenAmount),\n', '                "COLLATERAL_IN"\n', '            );\n', '            vars.complementToken.approve(_vault, _complementTokenAmount);\n', '        }\n', '\n', '        vars.vault.redeemTo(msg.sender, _primaryTokenAmount, _complementTokenAmount, _underlyingEndRoundHints);\n', '    }\n', '\n', '    /// @notice Withdraw own token balance\n', '    function withdraw(\n', '        address _token\n', '    ) external {\n', '        require(_token != address(0), "ZERO_ADDRESS");\n', '        IERC20 token = IERC20(_token);\n', '        token.transfer(msg.sender, token.balanceOf(address(this)));\n', '    }\n', '\n', '    function withdrawAll(\n', '        address[] memory _tokens\n', '    ) external {\n', '        for(uint256 i = 0; i < _tokens.length; i++) {\n', '            this.withdraw(_tokens[i]);\n', '        }\n', '    }\n', '\n', '    /// @notice direct method joinPool\n', '    function joinPool(\n', '        address _pool,\n', '        uint256 _poolAmountOut,\n', '        uint256[2] calldata _maxAmountsIn\n', '    ) external {\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '\n', '        require(\n', '            vars.primaryToken.transferFrom(msg.sender, address(this), _maxAmountsIn[0]),\n', '            "TAKE_PRIMARY"\n', '        );\n', '\n', '        require(\n', '            vars.complementToken.transferFrom(msg.sender, address(this), _maxAmountsIn[1]),\n', '            "TAKE_COMPLEMENT"\n', '        );\n', '\n', '        vars.primaryToken.approve(_pool, _maxAmountsIn[0]);\n', '        vars.complementToken.approve(_pool, _maxAmountsIn[1]);\n', '\n', '        vars.pool.joinPool(_poolAmountOut,_maxAmountsIn);\n', '\n', '        // Return Remaining tokens\n', '        if (vars.primaryToken.balanceOf(address(this)) > 0) {\n', '            require(\n', '                vars.primaryToken.transfer(msg.sender,vars.primaryToken.balanceOf(address(this))),\n', '                "GIVE_PRIMARY"\n', '            );\n', '        }\n', '\n', '        if (vars.complementToken.balanceOf(address(this)) > 0) {\n', '            require(\n', '                    vars.complementToken.transfer(msg.sender,vars.complementToken.balanceOf(address(this))),\n', '                    "GIVE_COMPLEMENT"\n', '                );\n', '        }\n', '\n', '        // Transfer Pool Tokens To users\n', '        require (vars.pool.transfer( msg.sender, vars.pool.balanceOf(address(this))), "GIVE_POOL");\n', '    }\n', '\n', '    /// @notice Direct method swapExactAmountIn\n', '    function swap(\n', '        address _pool,\n', '        address _tokenIn,\n', '        uint256 _tokenAmountIn,\n', '        address _tokenOut,\n', '        uint256 _minAmountOut\n', '    ) external {\n', '\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        IERC20 tokenIn = IERC20(_tokenIn);\n', '        IERC20 tokenOut = IERC20(_tokenOut);\n', '\n', '        // Transfer tokens from user to Proxy\n', '        require(\n', '            tokenIn.transferFrom(msg.sender, address(this), _tokenAmountIn),\n', '            "TAKE_IN"\n', '        );\n', '\n', '        tokenIn.approve(_pool, _tokenAmountIn);\n', '\n', '        vars.pool.swapExactAmountIn(_tokenIn,_tokenAmountIn,_tokenOut,_minAmountOut);\n', '\n', '        require(\n', '            tokenOut.transfer(msg.sender, tokenOut.balanceOf(address(this))),\n', '            "GIVE_OUT"\n', '        );\n', '    }\n', '\n', '    /// @notice Direct method:  exitPool\n', '    function exitPool(\n', '        address _pool,\n', '        uint256 _poolAmountIn,\n', '        uint256[2] calldata _minAmountsOut\n', '    ) external {\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '        vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '        require(\n', '            vars.pool.transferFrom(msg.sender, address(this), _poolAmountIn),\n', '            "TAKE_POOL"\n', '        );\n', '\n', '        vars.pool.exitPool(_poolAmountIn, _minAmountsOut);\n', '\n', '        // Transfer Tokens to User Wallet\n', '        require(\n', '            vars.primaryToken.transfer(msg.sender, vars.primaryToken.balanceOf(address(this))),\n', '            "GIVE_PRIMARY"\n', '        );\n', '        require(\n', '            vars.complementToken.transfer(msg.sender, vars.complementToken.balanceOf(address(this))),\n', '            "GIVE_COMPLEMENT"\n', '        );\n', '    }\n', '\n', '    /// @notice  1 (Δ𝑪+, Δ𝑩𝒊-), user declares Δ𝑪+ : State = Live\n', '    function mintAndSwapCollateralToDerivative(\n', '        address _pool,\n', '        uint256 _collateralAmount,\n', '        address _tokenIn, // Unwanted Derivative to be swaped\n', '        uint256 _minAmountOut\n', '    ) external {\n', '\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '        vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '        /// Transfer collateral tokens from user to Proxy\n', '        require(\n', '            vars.collateralToken.transferFrom(msg.sender, address(this), _collateralAmount),\n', '            "TAKE_COLLATERAL"\n', '        );\n', '\n', '        (IERC20 tokenOut) = mintAndSwapCollateralToDerivativeInternal(\n', '            _pool,\n', '            _collateralAmount,\n', '            _tokenIn,\n', '            _minAmountOut\n', '        );\n', '\n', '        uint256 tokenOutBalance = tokenOut.balanceOf(address(this));\n', '\n', '        // Transfer Back To user wallet\n', '        require(tokenOut.transfer(msg.sender, tokenOutBalance), "GIVE_OUT");\n', '    }\n', '\n', '    function mintAndSwapCollateralToDerivativeInternal(\n', '        address _pool,\n', '        uint256 _collateralAmount,\n', '        address _tokenIn, // Unwanted Derivative to be swaped\n', '        uint256 _minAmountOut\n', '    ) internal returns (IERC20 tokenOut) {\n', '\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '        vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '        // Approve collateral Tokens for Vault Contract\n', '        vars.collateralToken.approve(address(vars.vault), _collateralAmount);\n', '\n', '        /// Mint Symmetric derivatives\n', '        vars.vault.mint(_collateralAmount);\n', '\n', '        address tokenOutAddress =\n', '        _tokenIn == address(vars.primaryToken)\n', '        ? address(vars.complementToken)\n', '        : address(vars.primaryToken);\n', '\n', '        tokenOut = IERC20(tokenOutAddress);\n', '        IERC20 tokenIn = IERC20(_tokenIn);\n', '\n', '        uint256 tokenInBalance = tokenIn.balanceOf(address(this));\n', '\n', '        tokenIn.approve(_pool, tokenInBalance);\n', '\n', '        /// Swap Unwanted derivative\n', '        vars.pool.swapExactAmountIn(\n', '            _tokenIn,\n', '            tokenInBalance,\n', '            tokenOutAddress,\n', '            _minAmountOut\n', '        );\n', '    }\n', '\n', '    /// @notice 3 (∆Bi+,∆C-), user declares ∆Bi+\n', '    /// @notice There is a sufficient collateral in the pool\n', '    function swapDerivativesToCollateral(\n', '        address _pool,\n', '        address _derivativeIn,\n', '        uint256 _derivativeAmount,\n', '        uint256 _tokenAmountIn,\n', '        address _derivativeOut,\n', '        uint256 _derivativeMinAmountOut\n', '    ) external {\n', '\n', '        (IERC20 collateralToken, uint256 collateralAmount) = swapDerivativesToCollateralInternal(\n', '            _pool,\n', '            _derivativeIn,\n', '            _derivativeAmount,\n', '            _tokenAmountIn,\n', '            _derivativeOut,\n', '            _derivativeMinAmountOut\n', '        );\n', '\n', '        // Transfer Collateral To users Wallet\n', '        require(collateralToken.transfer(msg.sender, collateralAmount), "GIVE_COLLATERAL");\n', '    }\n', '\n', '    function swapDerivativesToCollateralInternal(\n', '        address _pool,\n', '        address _derivativeIn,\n', '        uint256 _derivativeAmount,\n', '        uint256 _tokenAmountIn,\n', '        address _derivativeOut,\n', '        uint256 _derivativeMinAmountOut\n', '    ) internal returns (IERC20 collateralToken, uint256 collateralAmountOut) {\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '        vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '        require(\n', '            IERC20(_derivativeIn).transferFrom(msg.sender, address(this), _derivativeAmount),\n', '            "TAKE_IN"\n', '        );\n', '\n', '        IERC20(_derivativeIn).approve(_pool, _tokenAmountIn);\n', '\n', '        vars.pool.swapExactAmountIn(\n', '            _derivativeIn,\n', '            _tokenAmountIn,\n', '            _derivativeOut,\n', '            _derivativeMinAmountOut\n', '        );\n', '\n', '        uint256 primaryTokenAmount = vars.primaryToken.balanceOf(address(this));\n', '        uint256 complementTokenAmount = vars.complementToken.balanceOf(address(this));\n', '\n', '        vars.primaryToken.approve(address(vars.vault), primaryTokenAmount);\n', '        vars.complementToken.approve(address(vars.vault), complementTokenAmount);\n', '\n', '        uint256 _tokenAmountOut = min(primaryTokenAmount, complementTokenAmount);\n', '\n', '        vars.vault.refund(_tokenAmountOut);\n', '\n', '        if (vars.primaryToken.balanceOf(address(this)) > 0) {\n', '            vars.primaryToken.transfer(msg.sender, vars.primaryToken.balanceOf(address(this)));\n', '        }\n', '\n', '        if (vars.complementToken.balanceOf(address(this)) > 0) {\n', '            vars.complementToken.transfer(\n', '                msg.sender,\n', '                vars.complementToken.balanceOf(address(this))\n', '            );\n', '        }\n', '\n', '        collateralAmountOut = vars.collateralToken.balanceOf(address(this));\n', '        collateralToken  = vars.collateralToken;\n', '    }\n', '\n', '\n', '    // 6 Trade Between Derivatives\n', '    function tradeBetweenDerivatives(\n', '        address _poolFromAddress,\n', '        address _derivativeInAddress,\n', '        uint256 _derivativeInAmount,\n', '        uint256 _derivativeInAmountToSell,\n', '        address _derivativeOut,\n', '        uint256 _minTokenOutAmountForFirstSwap,\n', '        address _poolToAddress,\n', '        address _mintedDerivativeToSell,\n', '        uint256 _minTokenOutAmountForSecondSwap\n', '    ) external {\n', '\n', '        Vars memory vars;\n', '        vars.pool = IPool(_poolFromAddress);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '        vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '        // Step 1: execute (ΔBi+, ΔC_) using Method 3\n', '        swapDerivativesToCollateralInternal(\n', '            _poolFromAddress,\n', '            _derivativeInAddress,\n', '            _derivativeInAmount,\n', '            _derivativeInAmountToSell,\n', '            _derivativeOut,\n', '            _minTokenOutAmountForFirstSwap\n', '        );\n', '\n', '        uint256 _collateralAmountToMint = vars.collateralToken.balanceOf(address(this));\n', '\n', '        // Step 2: execute (ΔC+, ΔBj-) using Method 1\n', '        (IERC20 tokenOut) = mintAndSwapCollateralToDerivativeInternal(\n', '            _poolToAddress,\n', '            _collateralAmountToMint,\n', '            _mintedDerivativeToSell,\n', '            _minTokenOutAmountForSecondSwap\n', '        );\n', '\n', '        uint256 tokenOutBalance = tokenOut.balanceOf(address(this));\n', '\n', '        // Transfer Back To user wallet\n', '        require(tokenOut.transfer(msg.sender, tokenOutBalance), "GIVE_OUT");\n', '    }\n', '\n', '     /// @notice  8 Mint & Add Liquidity - LP state=Live\n', '     function mintAndJoinPool(\n', '        address _pool,\n', '        uint256 _collateralAmount,\n', '        address _tokenIn,\n', '        uint256 _tokenAmountIn,\n', '        address _tokenOut,\n', '        uint256 _minAmountOut,\n', '        uint256 _minPoolAmountOut\n', '     ) external {\n', '         Vars memory vars;\n', '         vars.pool = IPool(_pool);\n', '\n', '         vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '         vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '         vars.complementToken = IERC20(vars.vault.complementToken());\n', '         vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '         // Transfer collateral tokens from users to Proxy\n', '         require(\n', '             vars.collateralToken.transferFrom(msg.sender, address(this), _collateralAmount),\n', '             "TAKE_COLLATERAL"\n', '         );\n', '\n', '         // Approve collateral Tokens for Vault Contract\n', '         vars.collateralToken.approve(address(vars.vault), _collateralAmount);\n', '\n', '         // Mint derivatives\n', '         vars.vault.mintTo(address(this), _collateralAmount);\n', '\n', '         if(_tokenAmountIn > 0) {\n', '             IERC20(_tokenIn).approve(_pool, _tokenAmountIn);\n', '\n', '             // Swap derivative for re-balancing\n', '             vars.pool.swapExactAmountIn(\n', '                 _tokenIn,\n', '                 _tokenAmountIn,\n', '                 _tokenOut,\n', '                 _minAmountOut\n', '             );\n', '         }\n', '\n', '         uint lpTokenSupply = IERC20(address(vars.pool)).totalSupply();\n', '         vars.primaryTokenBalance = vars.pool.getBalance(address(vars.primaryToken));\n', '         vars.complementTokenBalance = vars.pool.getBalance(address(vars.complementToken));\n', '         vars.primaryTokenAmount = vars.primaryToken.balanceOf(address(this));\n', '         vars.complementTokenAmount = vars.complementToken.balanceOf(address(this));\n', '\n', '         uint lpTokenMultiplier = 1;\n', '         vars.tokenDecimals = uint(IERC20Metadata(address(vars.collateralToken)).decimals());\n', '         if(vars.tokenDecimals > 0 && vars.tokenDecimals < 18) {\n', '             lpTokenMultiplier = 18 - vars.tokenDecimals;\n', '         }\n', '\n', '         uint poolAmountOut = min(\n', '             lpTokenSupply * scaleTo(vars.primaryTokenAmount, lpTokenMultiplier) * BONE / scaleTo(vars.primaryTokenBalance, lpTokenMultiplier),\n', '             lpTokenSupply * scaleTo(vars.complementTokenAmount, lpTokenMultiplier) * BONE / scaleTo(vars.complementTokenBalance, lpTokenMultiplier)\n', '         ) / BONE;\n', '\n', '         require(poolAmountOut >= _minPoolAmountOut, "MIN_POOL_AMOUNT_OUT");\n', '\n', '         vars.primaryToken.approve(_pool, vars.primaryTokenAmount);\n', '         vars.complementToken.approve(_pool, vars.complementTokenAmount);\n', '\n', '         uint256[2] memory tokenBalances;\n', '         tokenBalances[0] = vars.primaryTokenAmount;\n', '         tokenBalances[1] = vars.complementTokenAmount;\n', '\n', '         vars.pool.joinPool(poolAmountOut, tokenBalances);\n', '\n', '         require(vars.pool.transfer(msg.sender, poolAmountOut), "GIVE_POOL");\n', '     }\n', '\n', '\n', '    function scaleTo(uint256 _amount, uint256 _decimal) internal returns (uint256) {\n', '        return _amount * (10 ** _decimal);\n', '    }\n', '\n', '    /// @notice 9. Remove Liquidity & Redeem Settled Derivatives. User provides amount of LPtokens\n', '    function removeLiquidityOnSettledState(\n', '        address _pool,\n', '        uint256 _poolAmountIn,\n', '        uint256[2] calldata _minAmountsOut,\n', '        uint256[] memory _underlyingEndRoundHints\n', '    ) external {\n', '\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '        vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '        require(\n', '            vars.pool.transferFrom(msg.sender, address(this), _poolAmountIn),\n', '            "TAKE_POOL"\n', '        );\n', '\n', '        // Approve LP tokens for POOL // Not sure if this needed\n', '        require(vars.pool.approve(_pool, _poolAmountIn), "APPROVE");\n', '\n', '        // Step 1: Users sends LP tokens, receives (ΔBprim-, ΔBcompl-, ΔC-)\n', '        vars.pool.exitPool(_poolAmountIn, _minAmountsOut);\n', '\n', '        uint256 primaryTokenAmount = vars.primaryToken.balanceOf(address(this));\n', '        uint256 complementTokenAmount = vars.complementToken.balanceOf(address(this));\n', '\n', '        vars.primaryToken.approve(address(vars.vault), primaryTokenAmount);\n', '        vars.complementToken.approve(address(vars.vault), complementTokenAmount);\n', '\n', '        vars.vault.redeemTo(\n', '            msg.sender,\n', '            primaryTokenAmount,\n', '            complementTokenAmount,\n', '            _underlyingEndRoundHints\n', '        );\n', '    }\n', '\n', '    /// @notice 10. Remove Liquidity & Redeem Live Derivatives.\n', '    /// @notice User provides amount of LP tokens (method applies only when state = Minting or Live)\n', '    function removeLiquidityOnLiveOrMintingState(\n', '        address _pool,\n', '        uint256 _poolAmountIn,\n', '        address _tokenIn,\n', '        uint256 _tokenAmountIn,\n', '        uint256 _minAmountOut,\n', '        uint256[2] calldata _minAmountsOut\n', '    ) external {\n', '\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '        vars.collateralToken = IERC20(vars.vault.collateralToken());\n', '\n', '        require(\n', '            vars.pool.transferFrom(msg.sender, address(this), _poolAmountIn),\n', '            "TAKE_POOL"\n', '        );\n', '\n', '        // Approve LP tokens for POOL // Not sure if this needed\n', '        require(vars.pool.approve(_pool, _poolAmountIn), "APPROVE");\n', '\n', '        // Step 1: Users sends LP tokens, receives (ΔBprim-, ΔBcompl-)\n', '        vars.pool.exitPool(_poolAmountIn, _minAmountsOut);\n', '\n', '        // Step 2: Execute Composite Method 5 to reach symmetric derivative portfolio\n', '        if(_tokenAmountIn > 0) {\n', '//            address tokenOut = _tokenIn == address(vars.primaryToken)\n', '//                ? address(vars.complementToken)\n', '//                : address(vars.primaryToken);\n', '//\n', '//            IERC20 tokenIn = IERC20(_tokenIn);\n', '//            uint256 tokenInBalance = tokenIn.balanceOf(address(this));\n', '//\n', '//            tokenIn.approve(address(vars.pool), tokenInBalance);\n', '//\n', '//            vars.pool.swapExactAmountIn(\n', '//                address(tokenIn),\n', '//                _tokenAmountIn,\n', '//                tokenOut,\n', '//                _minAmountOut\n', '//            );\n', '        }\n', '\n', '        // Step 3: Redeem refund symmetric derivative portfolio for collateral\n', '        vars.primaryTokenAmount = vars.primaryToken.balanceOf(address(this));\n', '        vars.complementTokenAmount = vars.complementToken.balanceOf(address(this));\n', '\n', '        uint256 _tokensAmountOut = min(vars.primaryTokenAmount, vars.complementTokenAmount);\n', '\n', '        vars.primaryToken.approve(address(vars.vault), _tokensAmountOut);\n', '        vars.complementToken.approve(address(vars.vault), _tokensAmountOut);\n', '\n', '        vars.vault.refundTo(msg.sender, _tokensAmountOut);\n', '\n', '        if(vars.primaryToken.balanceOf(address(this)) > vars.complementToken.balanceOf(address(this))) {\n', '            vars.primaryToken.transfer(msg.sender, vars.primaryToken.balanceOf(address(this)));\n', '        } else {\n', '            vars.complementToken.transfer(msg.sender, vars.complementToken.balanceOf(address(this)));\n', '        }\n', '    }\n', '\n', '    function extractChange(address _pool) external {\n', '        Vars memory vars;\n', '        vars.pool = IPool(_pool);\n', '\n', '        vars.vault = IVault(vars.pool.derivativeVault());\n', '\n', '        vars.primaryToken = IERC20(vars.vault.primaryToken());\n', '        vars.complementToken = IERC20(vars.vault.complementToken());\n', '\n', '        if (vars.primaryToken.balanceOf(address(this)) > 0) {\n', '            vars.primaryToken.transfer(\n', '                msg.sender,\n', '                vars.primaryToken.balanceOf(address(this))\n', '            );\n', '        }\n', '\n', '        if (vars.complementToken.balanceOf(address(this)) > 0) {\n', '            vars.complementToken.transfer(\n', '                msg.sender,\n', '                vars.complementToken.balanceOf(address(this))\n', '            );\n', '        }\n', '    }\n', '}']