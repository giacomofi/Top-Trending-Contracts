['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-09\n', '*/\n', '\n', 'pragma solidity =0.8.0;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface INimbusRouter {\n', '    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n', '}\n', '\n', 'contract Ownable {\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    event OwnershipTransferred(address indexed from, address indexed to);\n', '\n', '    constructor() {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), owner);\n', '    }\n', '\n', '    modifier onlyOwner {\n', '        require(msg.sender == owner, "Ownable: Caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    function transferOwnership(address transferOwner) public onlyOwner {\n', '        require(transferOwner != newOwner);\n', '        newOwner = transferOwner;\n', '    }\n', '\n', '    function acceptOwnership() virtual public {\n', '        require(msg.sender == newOwner);\n', '        emit OwnershipTransferred(owner, newOwner);\n', '        owner = newOwner;\n', '        newOwner = address(0);\n', '    }\n', '}\n', '\n', 'library SafeMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '      if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0, "SafeMath: division by zero");\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'library Address {\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies in extcodesize, which returns 0 for contracts in construction, \n', '        // since the code is only stored at the end of the constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\n', '        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function callOptionalReturn(IERC20 token, bytes memory data) private {\n', '        require(address(token).isContract(), "SafeERC20: call to non-contract");\n', '\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) { \n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter, "ReentrancyGuard: reentrant call");\n', '    }\n', '}\n', '\n', 'interface ILockStakingRewards {\n', '    function earned(address account) external view returns (uint256);\n', '    function totalSupply() external view returns (uint256);\n', '    function balanceOf(address account) external view returns (uint256);\n', '    function stake(uint256 amount) external;\n', '    function stakeFor(uint256 amount, address user) external;\n', '    function getReward() external;\n', '    function withdraw(uint256 nonce) external;\n', '    function withdrawAndGetReward(uint256 nonce) external;\n', '}\n', '\n', 'interface IERC20Permit {\n', '    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n', '}\n', '\n', 'contract LockStakingRewardMinAmountFixedAPY is ILockStakingRewards, ReentrancyGuard, Ownable {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    IERC20 public immutable rewardsToken;\n', '    IERC20 public immutable stakingToken;\n', '    uint256 public rewardRate; \n', '    uint256 public immutable lockDuration; \n', '    uint256 public constant rewardDuration = 365 days; \n', '    \n', '    INimbusRouter public swapRouter;\n', '    address public swapToken;                       \n', '    uint public swapTokenAmountThresholdForStaking;\n', '\n', '    mapping(address => uint256) public weightedStakeDate;\n', '    mapping(address => mapping(uint256 => uint256)) public stakeLocks;\n', '    mapping(address => mapping(uint256 => uint256)) public stakeAmounts;\n', '    mapping(address => mapping(uint256 => uint256)) public stakeAmountsRewardEquivalent;\n', '    mapping(address => uint256) public stakeNonces;\n', '\n', '    uint256 private _totalSupply;\n', '    uint256 private _totalSupplyRewardEquivalent;\n', '    mapping(address => uint256) private _balances;\n', '    mapping(address => uint256) private _balancesRewardEquivalent;\n', '\n', '    event RewardUpdated(uint256 reward);\n', '    event Staked(address indexed user, uint256 amount);\n', '    event Withdrawn(address indexed user, uint256 amount);\n', '    event RewardPaid(address indexed user, uint256 reward);\n', '    event Rescue(address to, uint amount);\n', '    event RescueToken(address to, address token, uint amount);\n', '\n', '    constructor(\n', '        address _rewardsToken,\n', '        address _stakingToken,\n', '        uint _rewardRate,\n', '        uint _lockDuration,\n', '        address _swapRouter,\n', '        address _swapToken,\n', '        uint _swapTokenAmount\n', '    ) {\n', '        rewardsToken = IERC20(_rewardsToken);\n', '        stakingToken = IERC20(_stakingToken);\n', '        rewardRate = _rewardRate;\n', '        lockDuration = _lockDuration;\n', '        swapRouter = INimbusRouter(_swapRouter);\n', '        swapToken = _swapToken;\n', '        swapTokenAmountThresholdForStaking = _swapTokenAmount;\n', '    }\n', '\n', '    function totalSupply() external view override returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    function totalSupplyRewardEquivalent() external view returns (uint256) {\n', '        return _totalSupplyRewardEquivalent;\n', '    }\n', '\n', '    function balanceOf(address account) external view override returns (uint256) {\n', '        return _balances[account];\n', '    }\n', '    \n', '    function balanceOfRewardEquivalent(address account) external view returns (uint256) {\n', '        return _balancesRewardEquivalent[account];\n', '    }\n', '\n', '    function earned(address account) public view override returns (uint256) {\n', '        return (_balancesRewardEquivalent[account].mul(block.timestamp.sub(weightedStakeDate[account])).mul(rewardRate)) / (100 * rewardDuration);\n', '    }\n', '\n', '    function isAmountMeetsMinThreshold(uint amount) public view returns (bool) {\n', '        address[] memory path = new address[](2);\n', '        path[0] = address(stakingToken);\n', '        path[1] = swapToken;\n', '        uint tokenAmount = swapRouter.getAmountsOut(amount, path)[1];\n', '        return tokenAmount >= swapTokenAmountThresholdForStaking;\n', '    }\n', '\n', '    function stakeWithPermit(uint256 amount, uint deadline, uint8 v, bytes32 r, bytes32 s) external nonReentrant {\n', '        require(amount > 0, "LockStakingRewardMinAmountFixedAPY: Cannot stake 0");\n', '        // permit\n', '        IERC20Permit(address(stakingToken)).permit(msg.sender, address(this), amount, deadline, v, r, s);\n', '        _stake(amount, msg.sender);\n', '    }\n', '\n', '    function stake(uint256 amount) external override nonReentrant {\n', '        require(amount > 0, "LockStakingRewardMinAmountFixedAPY: Cannot stake 0");\n', '        _stake(amount, msg.sender);\n', '    }\n', '\n', '    function stakeFor(uint256 amount, address user) external override nonReentrant {\n', '        require(amount > 0, "LockStakingRewardMinAmountFixedAPY: Cannot stake 0");\n', '        _stake(amount, user);\n', '    }\n', '\n', '    function _stake(uint256 amount, address user) private {\n', '        require(isAmountMeetsMinThreshold(amount), "LockStakingRewardMinAmountFixedAPY: Amount is less than min stake");\n', '        stakingToken.safeTransferFrom(msg.sender, address(this), amount);\n', '        uint amountRewardEquivalent = getEquivalentAmount(amount);\n', '\n', '        _totalSupply = _totalSupply.add(amount);\n', '        _totalSupplyRewardEquivalent = _totalSupplyRewardEquivalent.add(amountRewardEquivalent);\n', '        uint previousAmount = _balances[user];\n', '        uint newAmount = previousAmount.add(amount);\n', '        weightedStakeDate[user] = (weightedStakeDate[user].mul(previousAmount) / newAmount).add(block.timestamp.mul(amount) / newAmount);\n', '        _balances[user] = newAmount;\n', '\n', '        uint stakeNonce = stakeNonces[user]++;\n', '        stakeAmounts[user][stakeNonce] = amount;\n', '        stakeLocks[user][stakeNonce] = block.timestamp + lockDuration;\n', '        \n', '        stakeAmountsRewardEquivalent[user][stakeNonce] = amountRewardEquivalent;\n', '        _balancesRewardEquivalent[user] = _balancesRewardEquivalent[user].add(amountRewardEquivalent);\n', '        emit Staked(user, amount);\n', '    }\n', '\n', '\n', '    //A user can withdraw its staking tokens even if there is no rewards tokens on the contract account\n', '    function withdraw(uint256 nonce) public override nonReentrant {\n', '        require(stakeAmounts[msg.sender][nonce] > 0, "LockStakingRewardMinAmountFixedAPY: This stake nonce was withdrawn");\n', '        require(stakeLocks[msg.sender][nonce] < block.timestamp, "LockStakingRewardMinAmountFixedAPY: Locked");\n', '        uint amount = stakeAmounts[msg.sender][nonce];\n', '        uint amountRewardEquivalent = stakeAmountsRewardEquivalent[msg.sender][nonce];\n', '        _totalSupply = _totalSupply.sub(amount);\n', '        _totalSupplyRewardEquivalent = _totalSupplyRewardEquivalent.sub(amountRewardEquivalent);\n', '        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n', '        _balancesRewardEquivalent[msg.sender] = _balancesRewardEquivalent[msg.sender].sub(amountRewardEquivalent);\n', '        stakingToken.safeTransfer(msg.sender, amount);\n', '        stakeAmounts[msg.sender][nonce] = 0;\n', '        stakeAmountsRewardEquivalent[msg.sender][nonce] = 0;\n', '        emit Withdrawn(msg.sender, amount);\n', '    }\n', '\n', '    function getReward() public override nonReentrant {\n', '        uint256 reward = earned(msg.sender);\n', '        if (reward > 0) {\n', '            weightedStakeDate[msg.sender] = block.timestamp;\n', '            rewardsToken.safeTransfer(msg.sender, reward);\n', '            emit RewardPaid(msg.sender, reward);\n', '        }\n', '    }\n', '\n', '    function withdrawAndGetReward(uint256 nonce) external override {\n', '        getReward();\n', '        withdraw(nonce);\n', '    }\n', '\n', '    function getEquivalentAmount(uint amount) public view returns (uint) {\n', '        address[] memory path = new address[](2);\n', '\n', '        uint equivalent;\n', '        if (stakingToken != rewardsToken) {\n', '            path[0] = address(stakingToken);            \n', '            path[1] = address(rewardsToken);\n', '            equivalent = swapRouter.getAmountsOut(amount, path)[1];\n', '        } else {\n', '            equivalent = amount;   \n', '        }\n', '        \n', '        return equivalent;\n', '    }\n', '\n', '\n', '    function updateRewardAmount(uint256 reward) external onlyOwner {\n', '        rewardRate = reward;\n', '        emit RewardUpdated(reward);\n', '    }\n', '\n', '    function updateSwapRouter(address newSwapRouter) external onlyOwner {\n', '        require(newSwapRouter != address(0), "LockStakingRewardMinAmountFixedAPY: Address is zero");\n', '        swapRouter = INimbusRouter(newSwapRouter);\n', '    }\n', '\n', '    function updateSwapToken(address newSwapToken) external onlyOwner {\n', '        require(newSwapToken != address(0), "LockStakingRewardMinAmountFixedAPY: Address is zero");\n', '        swapToken = newSwapToken;\n', '    }\n', '\n', '    function updateStakeSwapTokenAmountThreshold(uint threshold) external onlyOwner {\n', '        swapTokenAmountThresholdForStaking = threshold;\n', '    }\n', '\n', '    function rescue(address to, address token, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "LockStakingRewardMinAmountFixedAPY: Cannot rescue to the zero address");\n', '        require(amount > 0, "LockStakingRewardMinAmountFixedAPY: Cannot rescue 0");\n', '        require(token != address(stakingToken), "LockStakingRewardMinAmountFixedAPY: Cannot rescue staking token");\n', '        //owner can rescue rewardsToken if there is spare unused tokens on staking contract balance\n', '\n', '        IERC20(token).safeTransfer(to, amount);\n', '        emit RescueToken(to, address(token), amount);\n', '    }\n', '\n', '    function rescue(address payable to, uint256 amount) external onlyOwner {\n', '        require(to != address(0), "LockStakingRewardMinAmountFixedAPY: Cannot rescue to the zero address");\n', '        require(amount > 0, "LockStakingRewardMinAmountFixedAPY: Cannot rescue 0");\n', '\n', '        to.transfer(amount);\n', '        emit Rescue(to, amount);\n', '    }\n', '}']