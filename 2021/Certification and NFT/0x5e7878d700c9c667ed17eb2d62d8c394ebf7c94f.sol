['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-18\n', '*/\n', '\n', '// File: contracts/lib/Types.sol\n', '\n', '/*\n', '\n', '    Copyright 2020 DODO ZOO.\n', '    SPDX-License-Identifier: Apache-2.0\n', '\n', '*/\n', '\n', 'pragma solidity 0.6.9;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'library Types {\n', '    enum RStatus {ONE, ABOVE_ONE, BELOW_ONE}\n', '}\n', '\n', '// File: contracts/intf/IERC20.sol\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}\n', '\n', '// File: contracts/lib/InitializableOwnable.sol\n', '\n', '/**\n', ' * @title Ownable\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Ownership related functions\n', ' */\n', 'contract InitializableOwnable {\n', '    address public _OWNER_;\n', '    address public _NEW_OWNER_;\n', '\n', '    // ============ Events ============\n', '\n', '    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _OWNER_, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        require(newOwner != address(0), "INVALID_OWNER");\n', '        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n', '        _NEW_OWNER_ = newOwner;\n', '    }\n', '\n', '    function claimOwnership() external {\n', '        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");\n', '        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n', '        _OWNER_ = _NEW_OWNER_;\n', '        _NEW_OWNER_ = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/SafeMath.sol\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "MUL_ERROR");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "DIVIDING_ERROR");\n', '        return a / b;\n', '    }\n', '\n', '    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 quotient = div(a, b);\n', '        uint256 remainder = a - quotient * b;\n', '        if (remainder > 0) {\n', '            return quotient + 1;\n', '        } else {\n', '            return quotient;\n', '        }\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SUB_ERROR");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ADD_ERROR");\n', '        return c;\n', '    }\n', '\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = x / 2 + 1;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/DecimalMath.sol\n', '\n', '\n', '/**\n', ' * @title DecimalMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for fixed point number with 18 decimals\n', ' */\n', 'library DecimalMath {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant ONE = 10**18;\n', '\n', '    function mul(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(d) / ONE;\n', '    }\n', '\n', '    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(d).divCeil(ONE);\n', '    }\n', '\n', '    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(ONE).div(d);\n', '    }\n', '\n', '    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(ONE).divCeil(d);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ReentrancyGuard.sol\n', '\n', '\n', '/**\n', ' * @title ReentrancyGuard\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Protect functions from Reentrancy Attack\n', ' */\n', 'contract ReentrancyGuard {\n', '    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\n', '    // zero-state of _ENTERED_ is false\n', '    bool private _ENTERED_;\n', '\n', '    modifier preventReentrant() {\n', '        require(!_ENTERED_, "REENTRANT");\n', '        _ENTERED_ = true;\n', '        _;\n', '        _ENTERED_ = false;\n', '    }\n', '}\n', '\n', '// File: contracts/intf/IOracle.sol\n', '\n', '\n', '\n', 'interface IOracle {\n', '    function getPrice() external view returns (uint256);\n', '}\n', '\n', '// File: contracts/intf/IDODOLpToken.sol\n', '\n', '\n', '\n', 'interface IDODOLpToken {\n', '    function mint(address user, uint256 value) external;\n', '\n', '    function burn(address user, uint256 value) external;\n', '\n', '    function balanceOf(address owner) external view returns (uint256);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '}\n', '\n', '// File: contracts/impl/Storage.sol\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Storage\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Local Variables\n', ' */\n', 'contract Storage is InitializableOwnable, ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Variables for Control ============\n', '\n', '    bool internal _INITIALIZED_;\n', '    bool public _CLOSED_;\n', '    bool public _DEPOSIT_QUOTE_ALLOWED_;\n', '    bool public _DEPOSIT_BASE_ALLOWED_;\n', '    bool public _TRADE_ALLOWED_;\n', '    uint256 public _GAS_PRICE_LIMIT_;\n', '\n', '    // ============ Advanced Controls ============\n', '    bool public _BUYING_ALLOWED_;\n', '    bool public _SELLING_ALLOWED_;\n', '    uint256 public _BASE_BALANCE_LIMIT_;\n', '    uint256 public _QUOTE_BALANCE_LIMIT_;\n', '\n', '    // ============ Core Address ============\n', '\n', '    address public _SUPERVISOR_; // could freeze system in emergency\n', '    address public _MAINTAINER_; // collect maintainer fee to buy food for DODO\n', '\n', '    address public _BASE_TOKEN_;\n', '    address public _QUOTE_TOKEN_;\n', '    address public _ORACLE_;\n', '\n', '    // ============ Variables for PMM Algorithm ============\n', '\n', '    uint256 public _LP_FEE_RATE_;\n', '    uint256 public _MT_FEE_RATE_;\n', '    uint256 public _K_;\n', '\n', '    Types.RStatus public _R_STATUS_;\n', '    uint256 public _TARGET_BASE_TOKEN_AMOUNT_;\n', '    uint256 public _TARGET_QUOTE_TOKEN_AMOUNT_;\n', '    uint256 public _BASE_BALANCE_;\n', '    uint256 public _QUOTE_BALANCE_;\n', '\n', '    address public _BASE_CAPITAL_TOKEN_;\n', '    address public _QUOTE_CAPITAL_TOKEN_;\n', '\n', '    // ============ Variables for Final Settlement ============\n', '\n', '    uint256 public _BASE_CAPITAL_RECEIVE_QUOTE_;\n', '    uint256 public _QUOTE_CAPITAL_RECEIVE_BASE_;\n', '    mapping(address => bool) public _CLAIMED_;\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlySupervisorOrOwner() {\n', '        require(msg.sender == _SUPERVISOR_ || msg.sender == _OWNER_, "NOT_SUPERVISOR_OR_OWNER");\n', '        _;\n', '    }\n', '\n', '    modifier notClosed() {\n', '        require(!_CLOSED_, "DODO_CLOSED");\n', '        _;\n', '    }\n', '\n', '    // ============ Helper Functions ============\n', '\n', '    function _checkDODOParameters() internal view returns (uint256) {\n', '        require(_K_ < DecimalMath.ONE, "K>=1");\n', '        require(_K_ > 0, "K=0");\n', '        require(_LP_FEE_RATE_.add(_MT_FEE_RATE_) < DecimalMath.ONE, "FEE_RATE>=1");\n', '    }\n', '\n', '    function getOraclePrice() public view returns (uint256) {\n', '        return IOracle(_ORACLE_).getPrice();\n', '    }\n', '\n', '    function getBaseCapitalBalanceOf(address lp) public view returns (uint256) {\n', '        return IDODOLpToken(_BASE_CAPITAL_TOKEN_).balanceOf(lp);\n', '    }\n', '\n', '    function getTotalBaseCapital() public view returns (uint256) {\n', '        return IDODOLpToken(_BASE_CAPITAL_TOKEN_).totalSupply();\n', '    }\n', '\n', '    function getQuoteCapitalBalanceOf(address lp) public view returns (uint256) {\n', '        return IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).balanceOf(lp);\n', '    }\n', '\n', '    function getTotalQuoteCapital() public view returns (uint256) {\n', '        return IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).totalSupply();\n', '    }\n', '\n', '    // ============ Version Control ============\n', '    function version() external pure returns (uint256) {\n', '        return 101; // 1.0.1\n', '    }\n', '}\n', '\n', '// File: contracts/intf/IDODOCallee.sol\n', '\n', '\n', 'interface IDODOCallee {\n', '    function dodoCall(\n', '        bool isBuyBaseToken,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// File: contracts/lib/DODOMath.sol\n', '\n', '\n', '/**\n', ' * @title DODOMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n', ' */\n', 'library DODOMath {\n', '    using SafeMath for uint256;\n', '\n', '    /*\n', '        Integrate dodo curve fron V1 to V2\n', '        require V0>=V1>=V2>0\n', '        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n', '        let V1-V2=delta\n', '        res = i*delta*(1-k+k(V0^2/V1/V2))\n', '    */\n', '    function _GeneralIntegrate(\n', '        uint256 V0,\n', '        uint256 V1,\n', '        uint256 V2,\n', '        uint256 i,\n', '        uint256 k\n', '    ) internal pure returns (uint256) {\n', '        uint256 fairAmount = DecimalMath.mul(i, V1.sub(V2)); // i*delta\n', '        uint256 V0V0V1V2 = DecimalMath.divCeil(V0.mul(V0).div(V1), V2);\n', '        uint256 penalty = DecimalMath.mul(k, V0V0V1V2); // k(V0^2/V1/V2)\n', '        return DecimalMath.mul(fairAmount, DecimalMath.ONE.sub(k).add(penalty));\n', '    }\n', '\n', '    /*\n', '        The same with integration expression above, we have:\n', '        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n', '        Given Q1 and deltaB, solve Q2\n', '        This is a quadratic function and the standard version is\n', '        aQ2^2 + bQ2 + c = 0, where\n', '        a=1-k\n', '        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n', '        c=-kQ0^2\n', '        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n', '        note: another root is negative, abondan\n', '        if deltaBSig=true, then Q2>Q1\n', '        if deltaBSig=false, then Q2<Q1\n', '    */\n', '    function _SolveQuadraticFunctionForTrade(\n', '        uint256 Q0,\n', '        uint256 Q1,\n', '        uint256 ideltaB,\n', '        bool deltaBSig,\n', '        uint256 k\n', '    ) internal pure returns (uint256) {\n', '        // calculate -b value and sig\n', '        // -b = (1-k)Q1-kQ0^2/Q1+i*deltaB\n', '        uint256 kQ02Q1 = DecimalMath.mul(k, Q0).mul(Q0).div(Q1); // kQ0^2/Q1\n', '        uint256 b = DecimalMath.mul(DecimalMath.ONE.sub(k), Q1); // (1-k)Q1\n', '        bool minusbSig = true;\n', '        if (deltaBSig) {\n', '            b = b.add(ideltaB); // (1-k)Q1+i*deltaB\n', '        } else {\n', '            kQ02Q1 = kQ02Q1.add(ideltaB); // i*deltaB+kQ0^2/Q1\n', '        }\n', '        if (b >= kQ02Q1) {\n', '            b = b.sub(kQ02Q1);\n', '            minusbSig = true;\n', '        } else {\n', '            b = kQ02Q1.sub(b);\n', '            minusbSig = false;\n', '        }\n', '\n', '        // calculate sqrt\n', '        uint256 squareRoot = DecimalMath.mul(\n', '            DecimalMath.ONE.sub(k).mul(4),\n', '            DecimalMath.mul(k, Q0).mul(Q0)\n', '        ); // 4(1-k)kQ0^2\n', '        squareRoot = b.mul(b).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n', '\n', '        // final res\n', '        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\n', '        uint256 numerator;\n', '        if (minusbSig) {\n', '            numerator = b.add(squareRoot);\n', '        } else {\n', '            numerator = squareRoot.sub(b);\n', '        }\n', '\n', '        if (deltaBSig) {\n', '            return DecimalMath.divFloor(numerator, denominator);\n', '        } else {\n', '            return DecimalMath.divCeil(numerator, denominator);\n', '        }\n', '    }\n', '\n', '    /*\n', '        Start from the integration function\n', '        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n', '        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n', '        let fairAmount = i*deltaB\n', '    */\n', '    function _SolveQuadraticFunctionForTarget(\n', '        uint256 V1,\n', '        uint256 k,\n', '        uint256 fairAmount\n', '    ) internal pure returns (uint256 V0) {\n', '        // V0 = V1+V1*(sqrt-1)/2k\n', '        uint256 sqrt = DecimalMath.divCeil(DecimalMath.mul(k, fairAmount).mul(4), V1);\n', '        sqrt = sqrt.add(DecimalMath.ONE).mul(DecimalMath.ONE).sqrt();\n', '        uint256 premium = DecimalMath.divCeil(sqrt.sub(DecimalMath.ONE), k.mul(2));\n', '        // V0 is greater than or equal to V1 according to the solution\n', '        return DecimalMath.mul(V1, DecimalMath.ONE.add(premium));\n', '    }\n', '}\n', '\n', '// File: contracts/impl/Pricing.sol\n', '\n', '\n', '/**\n', ' * @title Pricing\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice DODO Pricing model\n', ' */\n', 'contract Pricing is Storage {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ R = 1 cases ============\n', '\n', '    function _ROneSellBaseToken(uint256 amount, uint256 targetQuoteTokenAmount)\n', '        internal\n', '        view\n', '        returns (uint256 receiveQuoteToken)\n', '    {\n', '        uint256 i = getOraclePrice();\n', '        uint256 Q2 = DODOMath._SolveQuadraticFunctionForTrade(\n', '            targetQuoteTokenAmount,\n', '            targetQuoteTokenAmount,\n', '            DecimalMath.mul(i, amount),\n', '            false,\n', '            _K_\n', '        );\n', '        // in theory Q2 <= targetQuoteTokenAmount\n', '        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n', '        return targetQuoteTokenAmount.sub(Q2);\n', '    }\n', '\n', '    function _ROneBuyBaseToken(uint256 amount, uint256 targetBaseTokenAmount)\n', '        internal\n', '        view\n', '        returns (uint256 payQuoteToken)\n', '    {\n', '        require(amount < targetBaseTokenAmount, "DODO_BASE_BALANCE_NOT_ENOUGH");\n', '        uint256 B2 = targetBaseTokenAmount.sub(amount);\n', '        payQuoteToken = _RAboveIntegrate(targetBaseTokenAmount, targetBaseTokenAmount, B2);\n', '        return payQuoteToken;\n', '    }\n', '\n', '    // ============ R < 1 cases ============\n', '\n', '    function _RBelowSellBaseToken(\n', '        uint256 amount,\n', '        uint256 quoteBalance,\n', '        uint256 targetQuoteAmount\n', '    ) internal view returns (uint256 receieQuoteToken) {\n', '        uint256 i = getOraclePrice();\n', '        uint256 Q2 = DODOMath._SolveQuadraticFunctionForTrade(\n', '            targetQuoteAmount,\n', '            quoteBalance,\n', '            DecimalMath.mul(i, amount),\n', '            false,\n', '            _K_\n', '        );\n', '        return quoteBalance.sub(Q2);\n', '    }\n', '\n', '    function _RBelowBuyBaseToken(\n', '        uint256 amount,\n', '        uint256 quoteBalance,\n', '        uint256 targetQuoteAmount\n', '    ) internal view returns (uint256 payQuoteToken) {\n', "        // Here we don't require amount less than some value\n", '        // Because it is limited at upper function\n', '        // See Trader.queryBuyBaseToken\n', '        uint256 i = getOraclePrice();\n', '        uint256 Q2 = DODOMath._SolveQuadraticFunctionForTrade(\n', '            targetQuoteAmount,\n', '            quoteBalance,\n', '            DecimalMath.mulCeil(i, amount),\n', '            true,\n', '            _K_\n', '        );\n', '        return Q2.sub(quoteBalance);\n', '    }\n', '\n', '    function _RBelowBackToOne() internal view returns (uint256 payQuoteToken) {\n', '        // important: carefully design the system to make sure spareBase always greater than or equal to 0\n', '        uint256 spareBase = _BASE_BALANCE_.sub(_TARGET_BASE_TOKEN_AMOUNT_);\n', '        uint256 price = getOraclePrice();\n', '        uint256 fairAmount = DecimalMath.mul(spareBase, price);\n', '        uint256 newTargetQuote = DODOMath._SolveQuadraticFunctionForTarget(\n', '            _QUOTE_BALANCE_,\n', '            _K_,\n', '            fairAmount\n', '        );\n', '        return newTargetQuote.sub(_QUOTE_BALANCE_);\n', '    }\n', '\n', '    // ============ R > 1 cases ============\n', '\n', '    function _RAboveBuyBaseToken(\n', '        uint256 amount,\n', '        uint256 baseBalance,\n', '        uint256 targetBaseAmount\n', '    ) internal view returns (uint256 payQuoteToken) {\n', '        require(amount < baseBalance, "DODO_BASE_BALANCE_NOT_ENOUGH");\n', '        uint256 B2 = baseBalance.sub(amount);\n', '        return _RAboveIntegrate(targetBaseAmount, baseBalance, B2);\n', '    }\n', '\n', '    function _RAboveSellBaseToken(\n', '        uint256 amount,\n', '        uint256 baseBalance,\n', '        uint256 targetBaseAmount\n', '    ) internal view returns (uint256 receiveQuoteToken) {\n', "        // here we don't require B1 <= targetBaseAmount\n", '        // Because it is limited at upper function\n', '        // See Trader.querySellBaseToken\n', '        uint256 B1 = baseBalance.add(amount);\n', '        return _RAboveIntegrate(targetBaseAmount, B1, baseBalance);\n', '    }\n', '\n', '    function _RAboveBackToOne() internal view returns (uint256 payBaseToken) {\n', '        // important: carefully design the system to make sure spareBase always greater than or equal to 0\n', '        uint256 spareQuote = _QUOTE_BALANCE_.sub(_TARGET_QUOTE_TOKEN_AMOUNT_);\n', '        uint256 price = getOraclePrice();\n', '        uint256 fairAmount = DecimalMath.divFloor(spareQuote, price);\n', '        uint256 newTargetBase = DODOMath._SolveQuadraticFunctionForTarget(\n', '            _BASE_BALANCE_,\n', '            _K_,\n', '            fairAmount\n', '        );\n', '        return newTargetBase.sub(_BASE_BALANCE_);\n', '    }\n', '\n', '    // ============ Helper functions ============\n', '\n', '    function getExpectedTarget() public view returns (uint256 baseTarget, uint256 quoteTarget) {\n', '        uint256 Q = _QUOTE_BALANCE_;\n', '        uint256 B = _BASE_BALANCE_;\n', '        if (_R_STATUS_ == Types.RStatus.ONE) {\n', '            return (_TARGET_BASE_TOKEN_AMOUNT_, _TARGET_QUOTE_TOKEN_AMOUNT_);\n', '        } else if (_R_STATUS_ == Types.RStatus.BELOW_ONE) {\n', '            uint256 payQuoteToken = _RBelowBackToOne();\n', '            return (_TARGET_BASE_TOKEN_AMOUNT_, Q.add(payQuoteToken));\n', '        } else if (_R_STATUS_ == Types.RStatus.ABOVE_ONE) {\n', '            uint256 payBaseToken = _RAboveBackToOne();\n', '            return (B.add(payBaseToken), _TARGET_QUOTE_TOKEN_AMOUNT_);\n', '        }\n', '    }\n', '\n', '    function getMidPrice() public view returns (uint256 midPrice) {\n', '        (uint256 baseTarget, uint256 quoteTarget) = getExpectedTarget();\n', '        if (_R_STATUS_ == Types.RStatus.BELOW_ONE) {\n', '            uint256 R = DecimalMath.divFloor(\n', '                quoteTarget.mul(quoteTarget).div(_QUOTE_BALANCE_),\n', '                _QUOTE_BALANCE_\n', '            );\n', '            R = DecimalMath.ONE.sub(_K_).add(DecimalMath.mul(_K_, R));\n', '            return DecimalMath.divFloor(getOraclePrice(), R);\n', '        } else {\n', '            uint256 R = DecimalMath.divFloor(\n', '                baseTarget.mul(baseTarget).div(_BASE_BALANCE_),\n', '                _BASE_BALANCE_\n', '            );\n', '            R = DecimalMath.ONE.sub(_K_).add(DecimalMath.mul(_K_, R));\n', '            return DecimalMath.mul(getOraclePrice(), R);\n', '        }\n', '    }\n', '\n', '    function _RAboveIntegrate(\n', '        uint256 B0,\n', '        uint256 B1,\n', '        uint256 B2\n', '    ) internal view returns (uint256) {\n', '        uint256 i = getOraclePrice();\n', '        return DODOMath._GeneralIntegrate(B0, B1, B2, i, _K_);\n', '    }\n', '\n', '    // function _RBelowIntegrate(\n', '    //     uint256 Q0,\n', '    //     uint256 Q1,\n', '    //     uint256 Q2\n', '    // ) internal view returns (uint256) {\n', '    //     uint256 i = getOraclePrice();\n', '    //     i = DecimalMath.divFloor(DecimalMath.ONE, i); // 1/i\n', '    //     return DODOMath._GeneralIntegrate(Q0, Q1, Q2, i, _K_);\n', '    // }\n', '}\n', '\n', '// File: contracts/lib/SafeERC20.sol\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n', '        );\n', '    }\n', '\n', '    function safeApprove(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require(\n', '            (value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/impl/Settlement.sol\n', '\n', '\n', '/**\n', ' * @title Settlement\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for assets settlement\n', ' */\n', 'contract Settlement is Storage {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // ============ Events ============\n', '\n', '    event Donate(uint256 amount, bool isBaseToken);\n', '\n', '    event ClaimAssets(address indexed user, uint256 baseTokenAmount, uint256 quoteTokenAmount);\n', '\n', '    // ============ Assets IN/OUT Functions ============\n', '\n', '    function _baseTokenTransferIn(address from, uint256 amount) internal {\n', '        require(_BASE_BALANCE_.add(amount) <= _BASE_BALANCE_LIMIT_, "BASE_BALANCE_LIMIT_EXCEEDED");\n', '        IERC20(_BASE_TOKEN_).safeTransferFrom(from, address(this), amount);\n', '        _BASE_BALANCE_ = _BASE_BALANCE_.add(amount);\n', '    }\n', '\n', '    function _quoteTokenTransferIn(address from, uint256 amount) internal {\n', '        require(\n', '            _QUOTE_BALANCE_.add(amount) <= _QUOTE_BALANCE_LIMIT_,\n', '            "QUOTE_BALANCE_LIMIT_EXCEEDED"\n', '        );\n', '        IERC20(_QUOTE_TOKEN_).safeTransferFrom(from, address(this), amount);\n', '        _QUOTE_BALANCE_ = _QUOTE_BALANCE_.add(amount);\n', '    }\n', '\n', '    function _baseTokenTransferOut(address to, uint256 amount) internal {\n', '        IERC20(_BASE_TOKEN_).safeTransfer(to, amount);\n', '        _BASE_BALANCE_ = _BASE_BALANCE_.sub(amount);\n', '    }\n', '\n', '    function _quoteTokenTransferOut(address to, uint256 amount) internal {\n', '        IERC20(_QUOTE_TOKEN_).safeTransfer(to, amount);\n', '        _QUOTE_BALANCE_ = _QUOTE_BALANCE_.sub(amount);\n', '    }\n', '\n', '    // ============ Donate to Liquidity Pool Functions ============\n', '\n', '    function _donateBaseToken(uint256 amount) internal {\n', '        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.add(amount);\n', '        emit Donate(amount, true);\n', '    }\n', '\n', '    function _donateQuoteToken(uint256 amount) internal {\n', '        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.add(amount);\n', '        emit Donate(amount, false);\n', '    }\n', '\n', '    function donateBaseToken(uint256 amount) external preventReentrant {\n', '        _baseTokenTransferIn(msg.sender, amount);\n', '        _donateBaseToken(amount);\n', '    }\n', '\n', '    function donateQuoteToken(uint256 amount) external preventReentrant {\n', '        _quoteTokenTransferIn(msg.sender, amount);\n', '        _donateQuoteToken(amount);\n', '    }\n', '\n', '    // ============ Final Settlement Functions ============\n', '\n', '    // last step to shut down dodo\n', '    function finalSettlement() external onlyOwner notClosed {\n', '        _CLOSED_ = true;\n', '        _DEPOSIT_QUOTE_ALLOWED_ = false;\n', '        _DEPOSIT_BASE_ALLOWED_ = false;\n', '        _TRADE_ALLOWED_ = false;\n', '        uint256 totalBaseCapital = getTotalBaseCapital();\n', '        uint256 totalQuoteCapital = getTotalQuoteCapital();\n', '\n', '        if (_QUOTE_BALANCE_ > _TARGET_QUOTE_TOKEN_AMOUNT_) {\n', '            uint256 spareQuote = _QUOTE_BALANCE_.sub(_TARGET_QUOTE_TOKEN_AMOUNT_);\n', '            _BASE_CAPITAL_RECEIVE_QUOTE_ = DecimalMath.divFloor(spareQuote, totalBaseCapital);\n', '        } else {\n', '            _TARGET_QUOTE_TOKEN_AMOUNT_ = _QUOTE_BALANCE_;\n', '        }\n', '\n', '        if (_BASE_BALANCE_ > _TARGET_BASE_TOKEN_AMOUNT_) {\n', '            uint256 spareBase = _BASE_BALANCE_.sub(_TARGET_BASE_TOKEN_AMOUNT_);\n', '            _QUOTE_CAPITAL_RECEIVE_BASE_ = DecimalMath.divFloor(spareBase, totalQuoteCapital);\n', '        } else {\n', '            _TARGET_BASE_TOKEN_AMOUNT_ = _BASE_BALANCE_;\n', '        }\n', '\n', '        _R_STATUS_ = Types.RStatus.ONE;\n', '    }\n', '\n', '    // claim remaining assets after final settlement\n', '    function claimAssets() external preventReentrant {\n', '        require(_CLOSED_, "DODO_NOT_CLOSED");\n', '        require(!_CLAIMED_[msg.sender], "ALREADY_CLAIMED");\n', '        _CLAIMED_[msg.sender] = true;\n', '\n', '        uint256 quoteCapital = getQuoteCapitalBalanceOf(msg.sender);\n', '        uint256 baseCapital = getBaseCapitalBalanceOf(msg.sender);\n', '\n', '        uint256 quoteAmount = 0;\n', '        if (quoteCapital > 0) {\n', '            quoteAmount = _TARGET_QUOTE_TOKEN_AMOUNT_.mul(quoteCapital).div(getTotalQuoteCapital());\n', '        }\n', '        uint256 baseAmount = 0;\n', '        if (baseCapital > 0) {\n', '            baseAmount = _TARGET_BASE_TOKEN_AMOUNT_.mul(baseCapital).div(getTotalBaseCapital());\n', '        }\n', '\n', '        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.sub(quoteAmount);\n', '        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.sub(baseAmount);\n', '\n', '        quoteAmount = quoteAmount.add(DecimalMath.mul(baseCapital, _BASE_CAPITAL_RECEIVE_QUOTE_));\n', '        baseAmount = baseAmount.add(DecimalMath.mul(quoteCapital, _QUOTE_CAPITAL_RECEIVE_BASE_));\n', '\n', '        _baseTokenTransferOut(msg.sender, baseAmount);\n', '        _quoteTokenTransferOut(msg.sender, quoteAmount);\n', '\n', '        IDODOLpToken(_BASE_CAPITAL_TOKEN_).burn(msg.sender, baseCapital);\n', '        IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).burn(msg.sender, quoteCapital);\n', '\n', '        emit ClaimAssets(msg.sender, baseAmount, quoteAmount);\n', '        return;\n', '    }\n', '\n', '    // in case someone transfer to contract directly\n', '    function retrieve(address token, uint256 amount) external onlyOwner {\n', '        if (token == _BASE_TOKEN_) {\n', '            require(\n', '                IERC20(_BASE_TOKEN_).balanceOf(address(this)) >= _BASE_BALANCE_.add(amount),\n', '                "DODO_BASE_BALANCE_NOT_ENOUGH"\n', '            );\n', '        }\n', '        if (token == _QUOTE_TOKEN_) {\n', '            require(\n', '                IERC20(_QUOTE_TOKEN_).balanceOf(address(this)) >= _QUOTE_BALANCE_.add(amount),\n', '                "DODO_QUOTE_BALANCE_NOT_ENOUGH"\n', '            );\n', '        }\n', '        IERC20(token).safeTransfer(msg.sender, amount);\n', '    }\n', '}\n', '\n', '// File: contracts/impl/Trader.sol\n', '\n', '\n', '/**\n', ' * @title Trader\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for trader operations\n', ' */\n', 'contract Trader is Storage, Pricing, Settlement {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    event SellBaseToken(address indexed seller, uint256 payBase, uint256 receiveQuote);\n', '\n', '    event BuyBaseToken(address indexed buyer, uint256 receiveBase, uint256 payQuote);\n', '\n', '    event ChargeMaintainerFee(address indexed maintainer, bool isBaseToken, uint256 amount);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier tradeAllowed() {\n', '        require(_TRADE_ALLOWED_, "TRADE_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    modifier buyingAllowed() {\n', '        require(_BUYING_ALLOWED_, "BUYING_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    modifier sellingAllowed() {\n', '        require(_SELLING_ALLOWED_, "SELLING_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    modifier gasPriceLimit() {\n', '        require(tx.gasprice <= _GAS_PRICE_LIMIT_, "GAS_PRICE_EXCEED");\n', '        _;\n', '    }\n', '\n', '    // ============ Trade Functions ============\n', '\n', '    function sellBaseToken(\n', '        uint256 amount,\n', '        uint256 minReceiveQuote,\n', '        bytes calldata data\n', '    ) external tradeAllowed sellingAllowed gasPriceLimit preventReentrant returns (uint256) {\n', '        // query price\n', '        (\n', '            uint256 receiveQuote,\n', '            uint256 lpFeeQuote,\n', '            uint256 mtFeeQuote,\n', '            Types.RStatus newRStatus,\n', '            uint256 newQuoteTarget,\n', '            uint256 newBaseTarget\n', '        ) = _querySellBaseToken(amount);\n', '        require(receiveQuote >= minReceiveQuote, "SELL_BASE_RECEIVE_NOT_ENOUGH");\n', '\n', '        // settle assets\n', '        _quoteTokenTransferOut(msg.sender, receiveQuote);\n', '        if (data.length > 0) {\n', '            IDODOCallee(msg.sender).dodoCall(false, amount, receiveQuote, data);\n', '        }\n', '        _baseTokenTransferIn(msg.sender, amount);\n', '        if (mtFeeQuote != 0) {\n', '            _quoteTokenTransferOut(_MAINTAINER_, mtFeeQuote);\n', '            emit ChargeMaintainerFee(_MAINTAINER_, false, mtFeeQuote);\n', '        }\n', '\n', '        // update TARGET\n', '        if (_TARGET_QUOTE_TOKEN_AMOUNT_ != newQuoteTarget) {\n', '            _TARGET_QUOTE_TOKEN_AMOUNT_ = newQuoteTarget;\n', '        }\n', '        if (_TARGET_BASE_TOKEN_AMOUNT_ != newBaseTarget) {\n', '            _TARGET_BASE_TOKEN_AMOUNT_ = newBaseTarget;\n', '        }\n', '        if (_R_STATUS_ != newRStatus) {\n', '            _R_STATUS_ = newRStatus;\n', '        }\n', '\n', '        _donateQuoteToken(lpFeeQuote);\n', '        emit SellBaseToken(msg.sender, amount, receiveQuote);\n', '\n', '        return receiveQuote;\n', '    }\n', '\n', '    function buyBaseToken(\n', '        uint256 amount,\n', '        uint256 maxPayQuote,\n', '        bytes calldata data\n', '    ) external tradeAllowed buyingAllowed gasPriceLimit preventReentrant returns (uint256) {\n', '        // query price\n', '        (\n', '            uint256 payQuote,\n', '            uint256 lpFeeBase,\n', '            uint256 mtFeeBase,\n', '            Types.RStatus newRStatus,\n', '            uint256 newQuoteTarget,\n', '            uint256 newBaseTarget\n', '        ) = _queryBuyBaseToken(amount);\n', '        require(payQuote <= maxPayQuote, "BUY_BASE_COST_TOO_MUCH");\n', '\n', '        // settle assets\n', '        _baseTokenTransferOut(msg.sender, amount);\n', '        if (data.length > 0) {\n', '            IDODOCallee(msg.sender).dodoCall(true, amount, payQuote, data);\n', '        }\n', '        _quoteTokenTransferIn(msg.sender, payQuote);\n', '        if (mtFeeBase != 0) {\n', '            _baseTokenTransferOut(_MAINTAINER_, mtFeeBase);\n', '            emit ChargeMaintainerFee(_MAINTAINER_, true, mtFeeBase);\n', '        }\n', '\n', '        // update TARGET\n', '        if (_TARGET_QUOTE_TOKEN_AMOUNT_ != newQuoteTarget) {\n', '            _TARGET_QUOTE_TOKEN_AMOUNT_ = newQuoteTarget;\n', '        }\n', '        if (_TARGET_BASE_TOKEN_AMOUNT_ != newBaseTarget) {\n', '            _TARGET_BASE_TOKEN_AMOUNT_ = newBaseTarget;\n', '        }\n', '        if (_R_STATUS_ != newRStatus) {\n', '            _R_STATUS_ = newRStatus;\n', '        }\n', '\n', '        _donateBaseToken(lpFeeBase);\n', '        emit BuyBaseToken(msg.sender, amount, payQuote);\n', '\n', '        return payQuote;\n', '    }\n', '\n', '    // ============ Query Functions ============\n', '\n', '    function querySellBaseToken(uint256 amount) external view returns (uint256 receiveQuote) {\n', '        (receiveQuote, , , , , ) = _querySellBaseToken(amount);\n', '        return receiveQuote;\n', '    }\n', '\n', '    function queryBuyBaseToken(uint256 amount) external view returns (uint256 payQuote) {\n', '        (payQuote, , , , , ) = _queryBuyBaseToken(amount);\n', '        return payQuote;\n', '    }\n', '\n', '    function _querySellBaseToken(uint256 amount)\n', '        internal\n', '        view\n', '        returns (\n', '            uint256 receiveQuote,\n', '            uint256 lpFeeQuote,\n', '            uint256 mtFeeQuote,\n', '            Types.RStatus newRStatus,\n', '            uint256 newQuoteTarget,\n', '            uint256 newBaseTarget\n', '        )\n', '    {\n', '        (newBaseTarget, newQuoteTarget) = getExpectedTarget();\n', '\n', '        uint256 sellBaseAmount = amount;\n', '\n', '        if (_R_STATUS_ == Types.RStatus.ONE) {\n', '            // case 1: R=1\n', '            // R falls below one\n', '            receiveQuote = _ROneSellBaseToken(sellBaseAmount, newQuoteTarget);\n', '            newRStatus = Types.RStatus.BELOW_ONE;\n', '        } else if (_R_STATUS_ == Types.RStatus.ABOVE_ONE) {\n', '            uint256 backToOnePayBase = newBaseTarget.sub(_BASE_BALANCE_);\n', '            uint256 backToOneReceiveQuote = _QUOTE_BALANCE_.sub(newQuoteTarget);\n', '            // case 2: R>1\n', '            // complex case, R status depends on trading amount\n', '            if (sellBaseAmount < backToOnePayBase) {\n', '                // case 2.1: R status do not change\n', '                receiveQuote = _RAboveSellBaseToken(sellBaseAmount, _BASE_BALANCE_, newBaseTarget);\n', '                newRStatus = Types.RStatus.ABOVE_ONE;\n', '                if (receiveQuote > backToOneReceiveQuote) {\n', '                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n', '                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n', '                    receiveQuote = backToOneReceiveQuote;\n', '                }\n', '            } else if (sellBaseAmount == backToOnePayBase) {\n', '                // case 2.2: R status changes to ONE\n', '                receiveQuote = backToOneReceiveQuote;\n', '                newRStatus = Types.RStatus.ONE;\n', '            } else {\n', '                // case 2.3: R status changes to BELOW_ONE\n', '                receiveQuote = backToOneReceiveQuote.add(\n', '                    _ROneSellBaseToken(sellBaseAmount.sub(backToOnePayBase), newQuoteTarget)\n', '                );\n', '                newRStatus = Types.RStatus.BELOW_ONE;\n', '            }\n', '        } else {\n', '            // _R_STATUS_ == Types.RStatus.BELOW_ONE\n', '            // case 3: R<1\n', '            receiveQuote = _RBelowSellBaseToken(sellBaseAmount, _QUOTE_BALANCE_, newQuoteTarget);\n', '            newRStatus = Types.RStatus.BELOW_ONE;\n', '        }\n', '\n', '        // count fees\n', '        lpFeeQuote = DecimalMath.mul(receiveQuote, _LP_FEE_RATE_);\n', '        mtFeeQuote = DecimalMath.mul(receiveQuote, _MT_FEE_RATE_);\n', '        receiveQuote = receiveQuote.sub(lpFeeQuote).sub(mtFeeQuote);\n', '\n', '        return (receiveQuote, lpFeeQuote, mtFeeQuote, newRStatus, newQuoteTarget, newBaseTarget);\n', '    }\n', '\n', '    function _queryBuyBaseToken(uint256 amount)\n', '        internal\n', '        view\n', '        returns (\n', '            uint256 payQuote,\n', '            uint256 lpFeeBase,\n', '            uint256 mtFeeBase,\n', '            Types.RStatus newRStatus,\n', '            uint256 newQuoteTarget,\n', '            uint256 newBaseTarget\n', '        )\n', '    {\n', '        (newBaseTarget, newQuoteTarget) = getExpectedTarget();\n', '\n', '        // charge fee from user receive amount\n', '        lpFeeBase = DecimalMath.mul(amount, _LP_FEE_RATE_);\n', '        mtFeeBase = DecimalMath.mul(amount, _MT_FEE_RATE_);\n', '        uint256 buyBaseAmount = amount.add(lpFeeBase).add(mtFeeBase);\n', '\n', '        if (_R_STATUS_ == Types.RStatus.ONE) {\n', '            // case 1: R=1\n', '            payQuote = _ROneBuyBaseToken(buyBaseAmount, newBaseTarget);\n', '            newRStatus = Types.RStatus.ABOVE_ONE;\n', '        } else if (_R_STATUS_ == Types.RStatus.ABOVE_ONE) {\n', '            // case 2: R>1\n', '            payQuote = _RAboveBuyBaseToken(buyBaseAmount, _BASE_BALANCE_, newBaseTarget);\n', '            newRStatus = Types.RStatus.ABOVE_ONE;\n', '        } else if (_R_STATUS_ == Types.RStatus.BELOW_ONE) {\n', '            uint256 backToOnePayQuote = newQuoteTarget.sub(_QUOTE_BALANCE_);\n', '            uint256 backToOneReceiveBase = _BASE_BALANCE_.sub(newBaseTarget);\n', '            // case 3: R<1\n', '            // complex case, R status may change\n', '            if (buyBaseAmount < backToOneReceiveBase) {\n', '                // case 3.1: R status do not change\n', '                // no need to check payQuote because spare base token must be greater than zero\n', '                payQuote = _RBelowBuyBaseToken(buyBaseAmount, _QUOTE_BALANCE_, newQuoteTarget);\n', '                newRStatus = Types.RStatus.BELOW_ONE;\n', '            } else if (buyBaseAmount == backToOneReceiveBase) {\n', '                // case 3.2: R status changes to ONE\n', '                payQuote = backToOnePayQuote;\n', '                newRStatus = Types.RStatus.ONE;\n', '            } else {\n', '                // case 3.3: R status changes to ABOVE_ONE\n', '                payQuote = backToOnePayQuote.add(\n', '                    _ROneBuyBaseToken(buyBaseAmount.sub(backToOneReceiveBase), newBaseTarget)\n', '                );\n', '                newRStatus = Types.RStatus.ABOVE_ONE;\n', '            }\n', '        }\n', '\n', '        return (payQuote, lpFeeBase, mtFeeBase, newRStatus, newQuoteTarget, newBaseTarget);\n', '    }\n', '}\n', '\n', '// File: contracts/impl/LiquidityProvider.sol\n', '\n', '\n', '/**\n', ' * @title LiquidityProvider\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for liquidity provider operations\n', ' */\n', 'contract LiquidityProvider is Storage, Pricing, Settlement {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    event Deposit(\n', '        address indexed payer,\n', '        address indexed receiver,\n', '        bool isBaseToken,\n', '        uint256 amount,\n', '        uint256 lpTokenAmount\n', '    );\n', '\n', '    event Withdraw(\n', '        address indexed payer,\n', '        address indexed receiver,\n', '        bool isBaseToken,\n', '        uint256 amount,\n', '        uint256 lpTokenAmount\n', '    );\n', '\n', '    event ChargePenalty(address indexed payer, bool isBaseToken, uint256 amount);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier depositQuoteAllowed() {\n', '        require(_DEPOSIT_QUOTE_ALLOWED_, "DEPOSIT_QUOTE_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    modifier depositBaseAllowed() {\n', '        require(_DEPOSIT_BASE_ALLOWED_, "DEPOSIT_BASE_NOT_ALLOWED");\n', '        _;\n', '    }\n', '\n', '    modifier dodoNotClosed() {\n', '        require(!_CLOSED_, "DODO_CLOSED");\n', '        _;\n', '    }\n', '\n', '    // ============ Routine Functions ============\n', '\n', '    function withdrawBase(uint256 amount) external returns (uint256) {\n', '        return withdrawBaseTo(msg.sender, amount);\n', '    }\n', '\n', '    function depositBase(uint256 amount) external returns (uint256) {\n', '        return depositBaseTo(msg.sender, amount);\n', '    }\n', '\n', '    function withdrawQuote(uint256 amount) external returns (uint256) {\n', '        return withdrawQuoteTo(msg.sender, amount);\n', '    }\n', '\n', '    function depositQuote(uint256 amount) external returns (uint256) {\n', '        return depositQuoteTo(msg.sender, amount);\n', '    }\n', '\n', '    function withdrawAllBase() external returns (uint256) {\n', '        return withdrawAllBaseTo(msg.sender);\n', '    }\n', '\n', '    function withdrawAllQuote() external returns (uint256) {\n', '        return withdrawAllQuoteTo(msg.sender);\n', '    }\n', '\n', '    // ============ Deposit Functions ============\n', '\n', '    function depositQuoteTo(address to, uint256 amount)\n', '        public\n', '        preventReentrant\n', '        depositQuoteAllowed\n', '        returns (uint256)\n', '    {\n', '        (, uint256 quoteTarget) = getExpectedTarget();\n', '        uint256 totalQuoteCapital = getTotalQuoteCapital();\n', '        uint256 capital = amount;\n', '        if (totalQuoteCapital == 0) {\n', '            // give remaining quote token to lp as a gift\n', '            capital = amount.add(quoteTarget);\n', '        } else if (quoteTarget > 0) {\n', '            capital = amount.mul(totalQuoteCapital).div(quoteTarget);\n', '        }\n', '\n', '        // settlement\n', '        _quoteTokenTransferIn(msg.sender, amount);\n', '        _mintQuoteCapital(to, capital);\n', '        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.add(amount);\n', '\n', '        emit Deposit(msg.sender, to, false, amount, capital);\n', '        return capital;\n', '    }\n', '\n', '    function depositBaseTo(address to, uint256 amount)\n', '        public\n', '        preventReentrant\n', '        depositBaseAllowed\n', '        returns (uint256)\n', '    {\n', '        (uint256 baseTarget, ) = getExpectedTarget();\n', '        uint256 totalBaseCapital = getTotalBaseCapital();\n', '        uint256 capital = amount;\n', '        if (totalBaseCapital == 0) {\n', '            // give remaining base token to lp as a gift\n', '            capital = amount.add(baseTarget);\n', '        } else if (baseTarget > 0) {\n', '            capital = amount.mul(totalBaseCapital).div(baseTarget);\n', '        }\n', '\n', '        // settlement\n', '        _baseTokenTransferIn(msg.sender, amount);\n', '        _mintBaseCapital(to, capital);\n', '        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.add(amount);\n', '\n', '        emit Deposit(msg.sender, to, true, amount, capital);\n', '        return capital;\n', '    }\n', '\n', '    // ============ Withdraw Functions ============\n', '\n', '    function withdrawQuoteTo(address to, uint256 amount)\n', '        public\n', '        preventReentrant\n', '        dodoNotClosed\n', '        returns (uint256)\n', '    {\n', '        // calculate capital\n', '        (, uint256 quoteTarget) = getExpectedTarget();\n', '        uint256 totalQuoteCapital = getTotalQuoteCapital();\n', '        require(totalQuoteCapital > 0, "NO_QUOTE_LP");\n', '\n', '        uint256 requireQuoteCapital = amount.mul(totalQuoteCapital).divCeil(quoteTarget);\n', '        require(\n', '            requireQuoteCapital <= getQuoteCapitalBalanceOf(msg.sender),\n', '            "LP_QUOTE_CAPITAL_BALANCE_NOT_ENOUGH"\n', '        );\n', '\n', '        // handle penalty, penalty may exceed amount\n', '        uint256 penalty = getWithdrawQuotePenalty(amount);\n', '        require(penalty < amount, "PENALTY_EXCEED");\n', '\n', '        // settlement\n', '        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.sub(amount);\n', '        _burnQuoteCapital(msg.sender, requireQuoteCapital);\n', '        _quoteTokenTransferOut(to, amount.sub(penalty));\n', '        _donateQuoteToken(penalty);\n', '\n', '        emit Withdraw(msg.sender, to, false, amount.sub(penalty), requireQuoteCapital);\n', '        emit ChargePenalty(msg.sender, false, penalty);\n', '\n', '        return amount.sub(penalty);\n', '    }\n', '\n', '    function withdrawBaseTo(address to, uint256 amount)\n', '        public\n', '        preventReentrant\n', '        dodoNotClosed\n', '        returns (uint256)\n', '    {\n', '        // calculate capital\n', '        (uint256 baseTarget, ) = getExpectedTarget();\n', '        uint256 totalBaseCapital = getTotalBaseCapital();\n', '        require(totalBaseCapital > 0, "NO_BASE_LP");\n', '\n', '        uint256 requireBaseCapital = amount.mul(totalBaseCapital).divCeil(baseTarget);\n', '        require(\n', '            requireBaseCapital <= getBaseCapitalBalanceOf(msg.sender),\n', '            "LP_BASE_CAPITAL_BALANCE_NOT_ENOUGH"\n', '        );\n', '\n', '        // handle penalty, penalty may exceed amount\n', '        uint256 penalty = getWithdrawBasePenalty(amount);\n', '        require(penalty <= amount, "PENALTY_EXCEED");\n', '\n', '        // settlement\n', '        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.sub(amount);\n', '        _burnBaseCapital(msg.sender, requireBaseCapital);\n', '        _baseTokenTransferOut(to, amount.sub(penalty));\n', '        _donateBaseToken(penalty);\n', '\n', '        emit Withdraw(msg.sender, to, true, amount.sub(penalty), requireBaseCapital);\n', '        emit ChargePenalty(msg.sender, true, penalty);\n', '\n', '        return amount.sub(penalty);\n', '    }\n', '\n', '    // ============ Withdraw all Functions ============\n', '\n', '    function withdrawAllQuoteTo(address to)\n', '        public\n', '        preventReentrant\n', '        dodoNotClosed\n', '        returns (uint256)\n', '    {\n', '        uint256 withdrawAmount = getLpQuoteBalance(msg.sender);\n', '        uint256 capital = getQuoteCapitalBalanceOf(msg.sender);\n', '\n', '        // handle penalty, penalty may exceed amount\n', '        uint256 penalty = getWithdrawQuotePenalty(withdrawAmount);\n', '        require(penalty <= withdrawAmount, "PENALTY_EXCEED");\n', '\n', '        // settlement\n', '        _TARGET_QUOTE_TOKEN_AMOUNT_ = _TARGET_QUOTE_TOKEN_AMOUNT_.sub(withdrawAmount);\n', '        _burnQuoteCapital(msg.sender, capital);\n', '        _quoteTokenTransferOut(to, withdrawAmount.sub(penalty));\n', '        _donateQuoteToken(penalty);\n', '\n', '        emit Withdraw(msg.sender, to, false, withdrawAmount, capital);\n', '        emit ChargePenalty(msg.sender, false, penalty);\n', '\n', '        return withdrawAmount.sub(penalty);\n', '    }\n', '\n', '    function withdrawAllBaseTo(address to) public preventReentrant dodoNotClosed returns (uint256) {\n', '        uint256 withdrawAmount = getLpBaseBalance(msg.sender);\n', '        uint256 capital = getBaseCapitalBalanceOf(msg.sender);\n', '\n', '        // handle penalty, penalty may exceed amount\n', '        uint256 penalty = getWithdrawBasePenalty(withdrawAmount);\n', '        require(penalty <= withdrawAmount, "PENALTY_EXCEED");\n', '\n', '        // settlement\n', '        _TARGET_BASE_TOKEN_AMOUNT_ = _TARGET_BASE_TOKEN_AMOUNT_.sub(withdrawAmount);\n', '        _burnBaseCapital(msg.sender, capital);\n', '        _baseTokenTransferOut(to, withdrawAmount.sub(penalty));\n', '        _donateBaseToken(penalty);\n', '\n', '        emit Withdraw(msg.sender, to, true, withdrawAmount, capital);\n', '        emit ChargePenalty(msg.sender, true, penalty);\n', '\n', '        return withdrawAmount.sub(penalty);\n', '    }\n', '\n', '    // ============ Helper Functions ============\n', '\n', '    function _mintBaseCapital(address user, uint256 amount) internal {\n', '        IDODOLpToken(_BASE_CAPITAL_TOKEN_).mint(user, amount);\n', '    }\n', '\n', '    function _mintQuoteCapital(address user, uint256 amount) internal {\n', '        IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).mint(user, amount);\n', '    }\n', '\n', '    function _burnBaseCapital(address user, uint256 amount) internal {\n', '        IDODOLpToken(_BASE_CAPITAL_TOKEN_).burn(user, amount);\n', '    }\n', '\n', '    function _burnQuoteCapital(address user, uint256 amount) internal {\n', '        IDODOLpToken(_QUOTE_CAPITAL_TOKEN_).burn(user, amount);\n', '    }\n', '\n', '    // ============ Getter Functions ============\n', '\n', '    function getLpBaseBalance(address lp) public view returns (uint256 lpBalance) {\n', '        uint256 totalBaseCapital = getTotalBaseCapital();\n', '        (uint256 baseTarget, ) = getExpectedTarget();\n', '        if (totalBaseCapital == 0) {\n', '            return 0;\n', '        }\n', '        lpBalance = getBaseCapitalBalanceOf(lp).mul(baseTarget).div(totalBaseCapital);\n', '        return lpBalance;\n', '    }\n', '\n', '    function getLpQuoteBalance(address lp) public view returns (uint256 lpBalance) {\n', '        uint256 totalQuoteCapital = getTotalQuoteCapital();\n', '        (, uint256 quoteTarget) = getExpectedTarget();\n', '        if (totalQuoteCapital == 0) {\n', '            return 0;\n', '        }\n', '        lpBalance = getQuoteCapitalBalanceOf(lp).mul(quoteTarget).div(totalQuoteCapital);\n', '        return lpBalance;\n', '    }\n', '\n', '    function getWithdrawQuotePenalty(uint256 amount) public view returns (uint256 penalty) {\n', '        require(amount <= _QUOTE_BALANCE_, "DODO_QUOTE_BALANCE_NOT_ENOUGH");\n', '        if (_R_STATUS_ == Types.RStatus.BELOW_ONE) {\n', '            uint256 spareBase = _BASE_BALANCE_.sub(_TARGET_BASE_TOKEN_AMOUNT_);\n', '            uint256 price = getOraclePrice();\n', '            uint256 fairAmount = DecimalMath.mul(spareBase, price);\n', '            uint256 targetQuote = DODOMath._SolveQuadraticFunctionForTarget(\n', '                _QUOTE_BALANCE_,\n', '                _K_,\n', '                fairAmount\n', '            );\n', '            // if amount = _QUOTE_BALANCE_, div error\n', '            uint256 targetQuoteWithWithdraw = DODOMath._SolveQuadraticFunctionForTarget(\n', '                _QUOTE_BALANCE_.sub(amount),\n', '                _K_,\n', '                fairAmount\n', '            );\n', '            return targetQuote.sub(targetQuoteWithWithdraw.add(amount));\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '\n', '    function getWithdrawBasePenalty(uint256 amount) public view returns (uint256 penalty) {\n', '        require(amount <= _BASE_BALANCE_, "DODO_BASE_BALANCE_NOT_ENOUGH");\n', '        if (_R_STATUS_ == Types.RStatus.ABOVE_ONE) {\n', '            uint256 spareQuote = _QUOTE_BALANCE_.sub(_TARGET_QUOTE_TOKEN_AMOUNT_);\n', '            uint256 price = getOraclePrice();\n', '            uint256 fairAmount = DecimalMath.divFloor(spareQuote, price);\n', '            uint256 targetBase = DODOMath._SolveQuadraticFunctionForTarget(\n', '                _BASE_BALANCE_,\n', '                _K_,\n', '                fairAmount\n', '            );\n', '            // if amount = _BASE_BALANCE_, div error\n', '            uint256 targetBaseWithWithdraw = DODOMath._SolveQuadraticFunctionForTarget(\n', '                _BASE_BALANCE_.sub(amount),\n', '                _K_,\n', '                fairAmount\n', '            );\n', '            return targetBase.sub(targetBaseWithWithdraw.add(amount));\n', '        } else {\n', '            return 0;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/impl/Admin.sol\n', '\n', '\n', '/**\n', ' * @title Admin\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for admin operations\n', ' */\n', 'contract Admin is Storage {\n', '    // ============ Events ============\n', '\n', '    event UpdateGasPriceLimit(uint256 oldGasPriceLimit, uint256 newGasPriceLimit);\n', '\n', '    event UpdateLiquidityProviderFeeRate(\n', '        uint256 oldLiquidityProviderFeeRate,\n', '        uint256 newLiquidityProviderFeeRate\n', '    );\n', '\n', '    event UpdateMaintainerFeeRate(uint256 oldMaintainerFeeRate, uint256 newMaintainerFeeRate);\n', '\n', '    event UpdateK(uint256 oldK, uint256 newK);\n', '\n', '    // ============ Params Setting Functions ============\n', '\n', '    function setOracle(address newOracle) external onlyOwner {\n', '        _ORACLE_ = newOracle;\n', '    }\n', '\n', '    function setSupervisor(address newSupervisor) external onlyOwner {\n', '        _SUPERVISOR_ = newSupervisor;\n', '    }\n', '\n', '    function setMaintainer(address newMaintainer) external onlyOwner {\n', '        _MAINTAINER_ = newMaintainer;\n', '    }\n', '\n', '    function setLiquidityProviderFeeRate(uint256 newLiquidityPorviderFeeRate) external onlyOwner {\n', '        emit UpdateLiquidityProviderFeeRate(_LP_FEE_RATE_, newLiquidityPorviderFeeRate);\n', '        _LP_FEE_RATE_ = newLiquidityPorviderFeeRate;\n', '        _checkDODOParameters();\n', '    }\n', '\n', '    function setMaintainerFeeRate(uint256 newMaintainerFeeRate) external onlyOwner {\n', '        emit UpdateMaintainerFeeRate(_MT_FEE_RATE_, newMaintainerFeeRate);\n', '        _MT_FEE_RATE_ = newMaintainerFeeRate;\n', '        _checkDODOParameters();\n', '    }\n', '\n', '    function setK(uint256 newK) external onlyOwner {\n', '        emit UpdateK(_K_, newK);\n', '        _K_ = newK;\n', '        _checkDODOParameters();\n', '    }\n', '\n', '    function setGasPriceLimit(uint256 newGasPriceLimit) external onlySupervisorOrOwner {\n', '        emit UpdateGasPriceLimit(_GAS_PRICE_LIMIT_, newGasPriceLimit);\n', '        _GAS_PRICE_LIMIT_ = newGasPriceLimit;\n', '    }\n', '\n', '    // ============ System Control Functions ============\n', '\n', '    function disableTrading() external onlySupervisorOrOwner {\n', '        _TRADE_ALLOWED_ = false;\n', '    }\n', '\n', '    function enableTrading() external onlyOwner notClosed {\n', '        _TRADE_ALLOWED_ = true;\n', '    }\n', '\n', '    function disableQuoteDeposit() external onlySupervisorOrOwner {\n', '        _DEPOSIT_QUOTE_ALLOWED_ = false;\n', '    }\n', '\n', '    function enableQuoteDeposit() external onlyOwner notClosed {\n', '        _DEPOSIT_QUOTE_ALLOWED_ = true;\n', '    }\n', '\n', '    function disableBaseDeposit() external onlySupervisorOrOwner {\n', '        _DEPOSIT_BASE_ALLOWED_ = false;\n', '    }\n', '\n', '    function enableBaseDeposit() external onlyOwner notClosed {\n', '        _DEPOSIT_BASE_ALLOWED_ = true;\n', '    }\n', '\n', '    // ============ Advanced Control Functions ============\n', '\n', '    function disableBuying() external onlySupervisorOrOwner {\n', '        _BUYING_ALLOWED_ = false;\n', '    }\n', '\n', '    function enableBuying() external onlyOwner notClosed {\n', '        _BUYING_ALLOWED_ = true;\n', '    }\n', '\n', '    function disableSelling() external onlySupervisorOrOwner {\n', '        _SELLING_ALLOWED_ = false;\n', '    }\n', '\n', '    function enableSelling() external onlyOwner notClosed {\n', '        _SELLING_ALLOWED_ = true;\n', '    }\n', '\n', '    function setBaseBalanceLimit(uint256 newBaseBalanceLimit) external onlyOwner notClosed {\n', '        _BASE_BALANCE_LIMIT_ = newBaseBalanceLimit;\n', '    }\n', '\n', '    function setQuoteBalanceLimit(uint256 newQuoteBalanceLimit) external onlyOwner notClosed {\n', '        _QUOTE_BALANCE_LIMIT_ = newQuoteBalanceLimit;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/Ownable.sol\n', '\n', '\n', '/**\n', ' * @title Ownable\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Ownership related functions\n', ' */\n', 'contract Ownable {\n', '    address public _OWNER_;\n', '    address public _NEW_OWNER_;\n', '\n', '    // ============ Events ============\n', '\n', '    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _OWNER_, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    constructor() internal {\n', '        _OWNER_ = msg.sender;\n', '        emit OwnershipTransferred(address(0), _OWNER_);\n', '    }\n', '\n', '    function transferOwnership(address newOwner) external onlyOwner {\n', '        require(newOwner != address(0), "INVALID_OWNER");\n', '        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n', '        _NEW_OWNER_ = newOwner;\n', '    }\n', '\n', '    function claimOwnership() external {\n', '        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");\n', '        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n', '        _OWNER_ = _NEW_OWNER_;\n', '        _NEW_OWNER_ = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/impl/DODOLpToken.sol\n', '\n', '\n', '/**\n', ' * @title DODOLpToken\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Tokenize liquidity pool assets. An ordinary ERC20 contract with mint and burn functions\n', ' */\n', 'contract DODOLpToken is Ownable {\n', '    using SafeMath for uint256;\n', '\n', '    string public symbol = "DLP";\n', '    address public originToken;\n', '\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) internal balances;\n', '    mapping(address => mapping(address => uint256)) internal allowed;\n', '\n', '    // ============ Events ============\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 amount);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '\n', '    event Mint(address indexed user, uint256 value);\n', '\n', '    event Burn(address indexed user, uint256 value);\n', '\n', '    // ============ Functions ============\n', '\n', '    constructor(address _originToken) public {\n', '        originToken = _originToken;\n', '    }\n', '\n', '    function name() public view returns (string memory) {\n', '        string memory lpTokenSuffix = "_DODO_LP_TOKEN_";\n', '        return string(abi.encodePacked(IERC20(originToken).name(), lpTokenSuffix));\n', '    }\n', '\n', '    function decimals() public view returns (uint8) {\n', '        return IERC20(originToken).decimals();\n', '    }\n', '\n', '    /**\n', '     * @dev transfer token for a specified address\n', '     * @param to The address to transfer to.\n', '     * @param amount The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 amount) public returns (bool) {\n', '        require(amount <= balances[msg.sender], "BALANCE_NOT_ENOUGH");\n', '\n', '        balances[msg.sender] = balances[msg.sender].sub(amount);\n', '        balances[to] = balances[to].add(amount);\n', '        emit Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param owner The address to query the the balance of.\n', '     * @return balance An uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance) {\n', '        return balances[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param amount uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        require(amount <= balances[from], "BALANCE_NOT_ENOUGH");\n', '        require(amount <= allowed[from][msg.sender], "ALLOWANCE_NOT_ENOUGH");\n', '\n', '        balances[from] = balances[from].sub(amount);\n', '        balances[to] = balances[to].add(amount);\n', '        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n', '        emit Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * @param spender The address which will spend the funds.\n', '     * @param amount The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        allowed[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return allowed[owner][spender];\n', '    }\n', '\n', '    function mint(address user, uint256 value) external onlyOwner {\n', '        balances[user] = balances[user].add(value);\n', '        totalSupply = totalSupply.add(value);\n', '        emit Mint(user, value);\n', '        emit Transfer(address(0), user, value);\n', '    }\n', '\n', '    function burn(address user, uint256 value) external onlyOwner {\n', '        balances[user] = balances[user].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Burn(user, value);\n', '        emit Transfer(user, address(0), value);\n', '    }\n', '}\n', '\n', '// File: contracts/dodo.sol\n', '\n', '\n', '\n', '/**\n', ' * @title DODO\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Entrance for users\n', ' */\n', 'contract DODO is Admin, Trader, LiquidityProvider {\n', '    function init(\n', '        address owner,\n', '        address supervisor,\n', '        address maintainer,\n', '        address baseToken,\n', '        address quoteToken,\n', '        address oracle,\n', '        uint256 lpFeeRate,\n', '        uint256 mtFeeRate,\n', '        uint256 k,\n', '        uint256 gasPriceLimit\n', '    ) external {\n', '        require(!_INITIALIZED_, "DODO_INITIALIZED");\n', '        _INITIALIZED_ = true;\n', '\n', '        // constructor\n', '        _OWNER_ = owner;\n', '        emit OwnershipTransferred(address(0), _OWNER_);\n', '\n', '        _SUPERVISOR_ = supervisor;\n', '        _MAINTAINER_ = maintainer;\n', '        _BASE_TOKEN_ = baseToken;\n', '        _QUOTE_TOKEN_ = quoteToken;\n', '        _ORACLE_ = oracle;\n', '\n', '        _DEPOSIT_BASE_ALLOWED_ = false;\n', '        _DEPOSIT_QUOTE_ALLOWED_ = false;\n', '        _TRADE_ALLOWED_ = false;\n', '        _GAS_PRICE_LIMIT_ = gasPriceLimit;\n', '\n', '        // Advanced controls are disabled by default\n', '        _BUYING_ALLOWED_ = true;\n', '        _SELLING_ALLOWED_ = true;\n', '        uint256 MAX_INT = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n', '        _BASE_BALANCE_LIMIT_ = MAX_INT;\n', '        _QUOTE_BALANCE_LIMIT_ = MAX_INT;\n', '\n', '        _LP_FEE_RATE_ = lpFeeRate;\n', '        _MT_FEE_RATE_ = mtFeeRate;\n', '        _K_ = k;\n', '        _R_STATUS_ = Types.RStatus.ONE;\n', '\n', '        _BASE_CAPITAL_TOKEN_ = address(new DODOLpToken(_BASE_TOKEN_));\n', '        _QUOTE_CAPITAL_TOKEN_ = address(new DODOLpToken(_QUOTE_TOKEN_));\n', '\n', '        _checkDODOParameters();\n', '    }\n', '}']