['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-28\n', '*/\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        uint256 c = a + b;\n', '        if (c < a) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b > a) return (false, 0);\n', '        return (true, a - b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '        if (a == 0) return (true, 0);\n', '        uint256 c = a * b;\n', '        if (c / a != b) return (false, 0);\n', '        return (true, c);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a / b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n', '        if (b == 0) return (false, 0);\n', '        return (true, a % b);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the addition of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `+` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Addition cannot overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "SafeMath: addition overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting on\n', '     * overflow (when the result is negative).\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SafeMath: subtraction overflow");\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the multiplication of two unsigned integers, reverting on\n', '     * overflow.\n', '     *\n', "     * Counterpart to Solidity's `*` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Multiplication cannot overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) return 0;\n', '        uint256 c = a * b;\n', '        require(c / a == b, "SafeMath: multiplication overflow");\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: division by zero");\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting when dividing by zero.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "SafeMath: modulo by zero");\n', '        return a % b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '     * overflow (when the result is negative).\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {trySub}.\n', '     *\n', "     * Counterpart to Solidity's `-` operator.\n", '     *\n', '     * Requirements:\n', '     *\n', '     * - Subtraction cannot overflow.\n', '     */\n', '    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b <= a, errorMessage);\n', '        return a - b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n', '     * division by zero. The result is rounded towards zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryDiv}.\n', '     *\n', "     * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '     * uses an invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a / b;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '     * reverting with custom message when dividing by zero.\n', '     *\n', '     * CAUTION: This function is deprecated because it requires allocating memory for the error\n', '     * message unnecessarily. For custom revert reasons use {tryMod}.\n', '     *\n', "     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '     * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '     * invalid opcode to revert (consuming all remaining gas).\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - The divisor cannot be zero.\n', '     */\n', '    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '        require(b > 0, errorMessage);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', '\n', 'pragma solidity >=0.6.2 <0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n', '\n', '\n', 'pragma solidity >=0.6.0 <0.8.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Deprecated. This function has issues similar to the ones found in\n', '     * {IERC20-approve}, and its usage is discouraged.\n', '     *\n', '     * Whenever possible, use {safeIncreaseAllowance} and\n', '     * {safeDecreaseAllowance} instead.\n', '     */\n', '    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '        uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '        // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '        bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '        if (returndata.length > 0) { // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: rainbow-bridge/contracts/eth/nearbridge/contracts/AdminControlled.sol\n', '\n', 'pragma solidity ^0.6;\n', '\n', 'contract AdminControlled {\n', '    address public admin;\n', '    uint public paused;\n', '\n', '    constructor(address _admin, uint flags) public {\n', '        admin = _admin;\n', '\n', '        // Add the possibility to set pause flags on the initialization\n', '        paused = flags;\n', '    }\n', '\n', '    modifier onlyAdmin {\n', '        require(msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    modifier pausable(uint flag) {\n', '        require((paused & flag) == 0 || msg.sender == admin);\n', '        _;\n', '    }\n', '\n', '    function adminPause(uint flags) public onlyAdmin {\n', '        paused = flags;\n', '    }\n', '\n', '    function adminSstore(uint key, uint value) public onlyAdmin {\n', '        assembly {\n', '            sstore(key, value)\n', '        }\n', '    }\n', '\n', '    function adminSendEth(address payable destination, uint amount) public onlyAdmin {\n', '        destination.transfer(amount);\n', '    }\n', '\n', '    function adminReceiveEth() public payable onlyAdmin {}\n', '\n', '    function adminDelegatecall(address target, bytes memory data) public payable onlyAdmin returns (bytes memory) {\n', '        (bool success, bytes memory rdata) = target.delegatecall(data);\n', '        require(success);\n', '        return rdata;\n', '    }\n', '}\n', '\n', '// File: rainbow-bridge/contracts/eth/nearbridge/contracts/Borsh.sol\n', '\n', 'pragma solidity ^0.6;\n', '\n', '\n', 'library Borsh {\n', '    using SafeMath for uint256;\n', '\n', '    struct Data {\n', '        uint256 offset;\n', '        bytes raw;\n', '    }\n', '\n', '    function from(bytes memory data) internal pure returns (Data memory) {\n', '        return Data({offset: 0, raw: data});\n', '    }\n', '\n', '    modifier shift(Data memory data, uint256 size) {\n', '        require(data.raw.length >= data.offset + size, "Borsh: Out of range");\n', '        _;\n', '        data.offset += size;\n', '    }\n', '\n', '    function finished(Data memory data) internal pure returns (bool) {\n', '        return data.offset == data.raw.length;\n', '    }\n', '\n', '    function peekKeccak256(Data memory data, uint256 length) internal pure returns (bytes32 res) {\n', '        return bytesKeccak256(data.raw, data.offset, length);\n', '    }\n', '\n', '    function bytesKeccak256(\n', '        bytes memory ptr,\n', '        uint256 offset,\n', '        uint256 length\n', '    ) internal pure returns (bytes32 res) {\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            res := keccak256(add(add(ptr, 32), offset), length)\n', '        }\n', '    }\n', '\n', '    function peekSha256(Data memory data, uint256 length) internal view returns (bytes32) {\n', '        return bytesSha256(data.raw, data.offset, length);\n', '    }\n', '\n', '    function bytesSha256(\n', '        bytes memory ptr,\n', '        uint256 offset,\n', '        uint256 length\n', '    ) internal view returns (bytes32) {\n', '        bytes32[1] memory result;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            pop(staticcall(gas(), 0x02, add(add(ptr, 32), offset), length, result, 32))\n', '        }\n', '        return result[0];\n', '    }\n', '\n', '    function decodeU8(Data memory data) internal pure shift(data, 1) returns (uint8 value) {\n', '        value = uint8(data.raw[data.offset]);\n', '    }\n', '\n', '    function decodeI8(Data memory data) internal pure shift(data, 1) returns (int8 value) {\n', '        value = int8(data.raw[data.offset]);\n', '    }\n', '\n', '    function decodeU16(Data memory data) internal pure returns (uint16 value) {\n', '        value = uint16(decodeU8(data));\n', '        value |= (uint16(decodeU8(data)) << 8);\n', '    }\n', '\n', '    function decodeI16(Data memory data) internal pure returns (int16 value) {\n', '        value = int16(decodeI8(data));\n', '        value |= (int16(decodeI8(data)) << 8);\n', '    }\n', '\n', '    function decodeU32(Data memory data) internal pure returns (uint32 value) {\n', '        value = uint32(decodeU16(data));\n', '        value |= (uint32(decodeU16(data)) << 16);\n', '    }\n', '\n', '    function decodeI32(Data memory data) internal pure returns (int32 value) {\n', '        value = int32(decodeI16(data));\n', '        value |= (int32(decodeI16(data)) << 16);\n', '    }\n', '\n', '    function decodeU64(Data memory data) internal pure returns (uint64 value) {\n', '        value = uint64(decodeU32(data));\n', '        value |= (uint64(decodeU32(data)) << 32);\n', '    }\n', '\n', '    function decodeI64(Data memory data) internal pure returns (int64 value) {\n', '        value = int64(decodeI32(data));\n', '        value |= (int64(decodeI32(data)) << 32);\n', '    }\n', '\n', '    function decodeU128(Data memory data) internal pure returns (uint128 value) {\n', '        value = uint128(decodeU64(data));\n', '        value |= (uint128(decodeU64(data)) << 64);\n', '    }\n', '\n', '    function decodeI128(Data memory data) internal pure returns (int128 value) {\n', '        value = int128(decodeI64(data));\n', '        value |= (int128(decodeI64(data)) << 64);\n', '    }\n', '\n', '    function decodeU256(Data memory data) internal pure returns (uint256 value) {\n', '        value = uint256(decodeU128(data));\n', '        value |= (uint256(decodeU128(data)) << 128);\n', '    }\n', '\n', '    function decodeI256(Data memory data) internal pure returns (int256 value) {\n', '        value = int256(decodeI128(data));\n', '        value |= (int256(decodeI128(data)) << 128);\n', '    }\n', '\n', '    function decodeBool(Data memory data) internal pure returns (bool value) {\n', '        value = (decodeU8(data) != 0);\n', '    }\n', '\n', '    function decodeBytes(Data memory data) internal pure returns (bytes memory value) {\n', '        value = new bytes(decodeU32(data));\n', '        for (uint i = 0; i < value.length; i++) {\n', '            value[i] = byte(decodeU8(data));\n', '        }\n', '    }\n', '\n', '    function decodeBytes32(Data memory data) internal pure shift(data, 32) returns (bytes32 value) {\n', '        bytes memory raw = data.raw;\n', '        uint256 offset = data.offset;\n', '        // solium-disable-next-line security/no-inline-assembly\n', '        assembly {\n', '            value := mload(add(add(raw, 32), offset))\n', '        }\n', '    }\n', '\n', '    function decodeBytes20(Data memory data) internal pure returns (bytes20 value) {\n', '        for (uint i = 0; i < 20; i++) {\n', '            value |= bytes20(byte(decodeU8(data)) & 0xFF) >> (i * 8);\n', '        }\n', '    }\n', '\n', '    // Public key\n', '\n', '    struct SECP256K1PublicKey {\n', '        uint256 x;\n', '        uint256 y;\n', '    }\n', '\n', '    function decodeSECP256K1PublicKey(Borsh.Data memory data) internal pure returns (SECP256K1PublicKey memory key) {\n', '        key.x = decodeU256(data);\n', '        key.y = decodeU256(data);\n', '    }\n', '\n', '    struct ED25519PublicKey {\n', '        bytes32 xy;\n', '    }\n', '\n', '    function decodeED25519PublicKey(Borsh.Data memory data) internal pure returns (ED25519PublicKey memory key) {\n', '        key.xy = decodeBytes32(data);\n', '    }\n', '\n', '    // Signature\n', '\n', '    struct SECP256K1Signature {\n', '        bytes32 r;\n', '        bytes32 s;\n', '        uint8 v;\n', '    }\n', '\n', '    function decodeSECP256K1Signature(Borsh.Data memory data) internal pure returns (SECP256K1Signature memory sig) {\n', '        sig.r = decodeBytes32(data);\n', '        sig.s = decodeBytes32(data);\n', '        sig.v = decodeU8(data);\n', '    }\n', '\n', '    struct ED25519Signature {\n', '        bytes32[2] rs;\n', '    }\n', '\n', '    function decodeED25519Signature(Borsh.Data memory data) internal pure returns (ED25519Signature memory sig) {\n', '        sig.rs[0] = decodeBytes32(data);\n', '        sig.rs[1] = decodeBytes32(data);\n', '    }\n', '}\n', '\n', '// File: rainbow-bridge/contracts/eth/nearbridge/contracts/NearDecoder.sol\n', '\n', 'pragma solidity ^0.6;\n', '\n', '\n', '\n', 'library NearDecoder {\n', '    using Borsh for Borsh.Data;\n', '    using NearDecoder for Borsh.Data;\n', '\n', '    struct PublicKey {\n', '        uint8 enumIndex;\n', '        Borsh.ED25519PublicKey ed25519;\n', '        Borsh.SECP256K1PublicKey secp256k1;\n', '    }\n', '\n', '    function decodePublicKey(Borsh.Data memory data) internal pure returns (PublicKey memory key) {\n', '        key.enumIndex = data.decodeU8();\n', '\n', '        if (key.enumIndex == 0) {\n', '            key.ed25519 = data.decodeED25519PublicKey();\n', '        } else if (key.enumIndex == 1) {\n', '            key.secp256k1 = data.decodeSECP256K1PublicKey();\n', '        } else {\n', '            revert("NearBridge: Only ED25519 and SECP256K1 public keys are supported");\n', '        }\n', '    }\n', '\n', '    struct ValidatorStake {\n', '        string account_id;\n', '        PublicKey public_key;\n', '        uint128 stake;\n', '    }\n', '\n', '    function decodeValidatorStake(Borsh.Data memory data) internal pure returns (ValidatorStake memory validatorStake) {\n', '        validatorStake.account_id = string(data.decodeBytes());\n', '        validatorStake.public_key = data.decodePublicKey();\n', '        validatorStake.stake = data.decodeU128();\n', '    }\n', '\n', '    struct OptionalValidatorStakes {\n', '        bool none;\n', '        ValidatorStake[] validatorStakes;\n', '        bytes32 hash; // Additional computable element\n', '    }\n', '\n', '    function decodeOptionalValidatorStakes(Borsh.Data memory data)\n', '        internal\n', '        view\n', '        returns (OptionalValidatorStakes memory stakes)\n', '    {\n', '        stakes.none = (data.decodeU8() == 0);\n', '        if (!stakes.none) {\n', '            uint256 start = data.offset;\n', '\n', '            stakes.validatorStakes = new ValidatorStake[](data.decodeU32());\n', '            for (uint i = 0; i < stakes.validatorStakes.length; i++) {\n', '                stakes.validatorStakes[i] = data.decodeValidatorStake();\n', '            }\n', '\n', '            uint256 stop = data.offset;\n', '            data.offset = start;\n', '            stakes.hash = data.peekSha256(stop - start);\n', '            data.offset = stop;\n', '        }\n', '    }\n', '\n', '    struct Signature {\n', '        uint8 enumIndex;\n', '        Borsh.ED25519Signature ed25519;\n', '        Borsh.SECP256K1Signature secp256k1;\n', '    }\n', '\n', '    function decodeSignature(Borsh.Data memory data) internal pure returns (Signature memory sig) {\n', '        sig.enumIndex = data.decodeU8();\n', '\n', '        if (sig.enumIndex == 0) {\n', '            sig.ed25519 = data.decodeED25519Signature();\n', '        } else if (sig.enumIndex == 1) {\n', '            sig.secp256k1 = data.decodeSECP256K1Signature();\n', '        } else {\n', '            revert("NearBridge: Only ED25519 and SECP256K1 signatures are supported");\n', '        }\n', '    }\n', '\n', '    struct OptionalSignature {\n', '        bool none;\n', '        Signature signature;\n', '    }\n', '\n', '    function decodeOptionalSignature(Borsh.Data memory data) internal pure returns (OptionalSignature memory sig) {\n', '        sig.none = (data.decodeU8() == 0);\n', '        if (!sig.none) {\n', '            sig.signature = data.decodeSignature();\n', '        }\n', '    }\n', '\n', '    struct LightClientBlock {\n', '        bytes32 prev_block_hash;\n', '        bytes32 next_block_inner_hash;\n', '        BlockHeaderInnerLite inner_lite;\n', '        bytes32 inner_rest_hash;\n', '        OptionalValidatorStakes next_bps;\n', '        OptionalSignature[] approvals_after_next;\n', '        bytes32 hash;\n', '        bytes32 next_hash;\n', '    }\n', '\n', '    struct InitialValidators {\n', '        ValidatorStake[] validator_stakes;\n', '    }\n', '\n', '    function decodeInitialValidators(Borsh.Data memory data)\n', '        internal\n', '        view\n', '        returns (InitialValidators memory validators)\n', '    {\n', '        validators.validator_stakes = new ValidatorStake[](data.decodeU32());\n', '        for (uint i = 0; i < validators.validator_stakes.length; i++) {\n', '            validators.validator_stakes[i] = data.decodeValidatorStake();\n', '        }\n', '    }\n', '\n', '    function decodeLightClientBlock(Borsh.Data memory data) internal view returns (LightClientBlock memory header) {\n', '        header.prev_block_hash = data.decodeBytes32();\n', '        header.next_block_inner_hash = data.decodeBytes32();\n', '        header.inner_lite = data.decodeBlockHeaderInnerLite();\n', '        header.inner_rest_hash = data.decodeBytes32();\n', '        header.next_bps = data.decodeOptionalValidatorStakes();\n', '\n', '        header.approvals_after_next = new OptionalSignature[](data.decodeU32());\n', '        for (uint i = 0; i < header.approvals_after_next.length; i++) {\n', '            header.approvals_after_next[i] = data.decodeOptionalSignature();\n', '        }\n', '\n', '        header.hash = sha256(\n', '            abi.encodePacked(\n', '                sha256(abi.encodePacked(header.inner_lite.hash, header.inner_rest_hash)),\n', '                header.prev_block_hash\n', '            )\n', '        );\n', '\n', '        header.next_hash = sha256(abi.encodePacked(header.next_block_inner_hash, header.hash));\n', '    }\n', '\n', '    struct BlockHeaderInnerLite {\n', '        uint64 height; /// Height of this block since the genesis block (height 0).\n', "        bytes32 epoch_id; /// Epoch start hash of this block's epoch. Used for retrieving validator information\n", '        bytes32 next_epoch_id;\n', '        bytes32 prev_state_root; /// Root hash of the state at the previous block.\n', '        bytes32 outcome_root; /// Root of the outcomes of transactions and receipts.\n', '        uint64 timestamp; /// Timestamp at which the block was built.\n', '        bytes32 next_bp_hash; /// Hash of the next epoch block producers set\n', '        bytes32 block_merkle_root;\n', '        bytes32 hash; // Additional computable element\n', '    }\n', '\n', '    function decodeBlockHeaderInnerLite(Borsh.Data memory data)\n', '        internal\n', '        view\n', '        returns (BlockHeaderInnerLite memory header)\n', '    {\n', '        header.hash = data.peekSha256(208);\n', '        header.height = data.decodeU64();\n', '        header.epoch_id = data.decodeBytes32();\n', '        header.next_epoch_id = data.decodeBytes32();\n', '        header.prev_state_root = data.decodeBytes32();\n', '        header.outcome_root = data.decodeBytes32();\n', '        header.timestamp = data.decodeU64();\n', '        header.next_bp_hash = data.decodeBytes32();\n', '        header.block_merkle_root = data.decodeBytes32();\n', '    }\n', '}\n', '\n', '// File: rainbow-bridge/contracts/eth/nearprover/contracts/ProofDecoder.sol\n', '\n', 'pragma solidity ^0.6;\n', '\n', '\n', '\n', 'library ProofDecoder {\n', '    using Borsh for Borsh.Data;\n', '    using ProofDecoder for Borsh.Data;\n', '    using NearDecoder for Borsh.Data;\n', '\n', '    struct FullOutcomeProof {\n', '        ExecutionOutcomeWithIdAndProof outcome_proof;\n', '        MerklePath outcome_root_proof; // TODO: now empty array\n', '        BlockHeaderLight block_header_lite;\n', '        MerklePath block_proof;\n', '    }\n', '\n', '    function decodeFullOutcomeProof(Borsh.Data memory data) internal view returns (FullOutcomeProof memory proof) {\n', '        proof.outcome_proof = data.decodeExecutionOutcomeWithIdAndProof();\n', '        proof.outcome_root_proof = data.decodeMerklePath();\n', '        proof.block_header_lite = data.decodeBlockHeaderLight();\n', '        proof.block_proof = data.decodeMerklePath();\n', '    }\n', '\n', '    struct BlockHeaderLight {\n', '        bytes32 prev_block_hash;\n', '        bytes32 inner_rest_hash;\n', '        NearDecoder.BlockHeaderInnerLite inner_lite;\n', '        bytes32 hash; // Computable\n', '    }\n', '\n', '    function decodeBlockHeaderLight(Borsh.Data memory data) internal view returns (BlockHeaderLight memory header) {\n', '        header.prev_block_hash = data.decodeBytes32();\n', '        header.inner_rest_hash = data.decodeBytes32();\n', '        header.inner_lite = data.decodeBlockHeaderInnerLite();\n', '\n', '        header.hash = sha256(\n', '            abi.encodePacked(\n', '                sha256(abi.encodePacked(header.inner_lite.hash, header.inner_rest_hash)),\n', '                header.prev_block_hash\n', '            )\n', '        );\n', '    }\n', '\n', '    struct ExecutionStatus {\n', '        uint8 enumIndex;\n', '        bool unknown;\n', '        bool failed;\n', '        bytes successValue; /// The final action succeeded and returned some value or an empty vec.\n', '        bytes32 successReceiptId; /// The final action of the receipt returned a promise or the signed\n', '        /// transaction was converted to a receipt. Contains the receipt_id of the generated receipt.\n', '    }\n', '\n', '    function decodeExecutionStatus(Borsh.Data memory data)\n', '        internal\n', '        pure\n', '        returns (ExecutionStatus memory executionStatus)\n', '    {\n', '        executionStatus.enumIndex = data.decodeU8();\n', '        if (executionStatus.enumIndex == 0) {\n', '            executionStatus.unknown = true;\n', '        } else if (executionStatus.enumIndex == 1) {\n', '            //revert("NearDecoder: decodeExecutionStatus failure case not implemented yet");\n', '            // Can avoid revert since ExecutionStatus is latest field in all parent structures\n', '            executionStatus.failed = true;\n', '        } else if (executionStatus.enumIndex == 2) {\n', '            executionStatus.successValue = data.decodeBytes();\n', '        } else if (executionStatus.enumIndex == 3) {\n', '            executionStatus.successReceiptId = data.decodeBytes32();\n', '        } else {\n', '            revert("NearDecoder: decodeExecutionStatus index out of range");\n', '        }\n', '    }\n', '\n', '    struct ExecutionOutcome {\n', '        bytes[] logs; /// Logs from this transaction or receipt.\n', '        bytes32[] receipt_ids; /// Receipt IDs generated by this transaction or receipt.\n', '        uint64 gas_burnt; /// The amount of the gas burnt by the given transaction or receipt.\n', '        uint128 tokens_burnt; /// The total number of the tokens burnt by the given transaction or receipt.\n', '        bytes executor_id; /// Hash of the transaction or receipt id that produced this outcome.\n', '        ExecutionStatus status; /// Execution status. Contains the result in case of successful execution.\n', '        bytes32[] merkelization_hashes;\n', '    }\n', '\n', '    function decodeExecutionOutcome(Borsh.Data memory data) internal view returns (ExecutionOutcome memory outcome) {\n', '        outcome.logs = new bytes[](data.decodeU32());\n', '        for (uint i = 0; i < outcome.logs.length; i++) {\n', '            outcome.logs[i] = data.decodeBytes();\n', '        }\n', '\n', '        uint256 start = data.offset;\n', '        outcome.receipt_ids = new bytes32[](data.decodeU32());\n', '        for (uint i = 0; i < outcome.receipt_ids.length; i++) {\n', '            outcome.receipt_ids[i] = data.decodeBytes32();\n', '        }\n', '        outcome.gas_burnt = data.decodeU64();\n', '        outcome.tokens_burnt = data.decodeU128();\n', '        outcome.executor_id = data.decodeBytes();\n', '        outcome.status = data.decodeExecutionStatus();\n', '        uint256 stop = data.offset;\n', '\n', '        outcome.merkelization_hashes = new bytes32[](1 + outcome.logs.length);\n', '        data.offset = start;\n', '        outcome.merkelization_hashes[0] = data.peekSha256(stop - start);\n', '        data.offset = stop;\n', '        for (uint i = 0; i < outcome.logs.length; i++) {\n', '            outcome.merkelization_hashes[i + 1] = sha256(outcome.logs[i]);\n', '        }\n', '    }\n', '\n', '    struct ExecutionOutcomeWithId {\n', '        bytes32 id; /// The transaction hash or the receipt ID.\n', '        ExecutionOutcome outcome;\n', '        bytes32 hash;\n', '    }\n', '\n', '    function decodeExecutionOutcomeWithId(Borsh.Data memory data)\n', '        internal\n', '        view\n', '        returns (ExecutionOutcomeWithId memory outcome)\n', '    {\n', '        outcome.id = data.decodeBytes32();\n', '        outcome.outcome = data.decodeExecutionOutcome();\n', '\n', '        uint256 len = 1 + outcome.outcome.merkelization_hashes.length;\n', '        outcome.hash = sha256(\n', '            abi.encodePacked(\n', '                uint8((len >> 0) & 0xFF),\n', '                uint8((len >> 8) & 0xFF),\n', '                uint8((len >> 16) & 0xFF),\n', '                uint8((len >> 24) & 0xFF),\n', '                outcome.id,\n', '                outcome.outcome.merkelization_hashes\n', '            )\n', '        );\n', '    }\n', '\n', '    struct MerklePathItem {\n', '        bytes32 hash;\n', '        uint8 direction; // 0 = left, 1 = right\n', '    }\n', '\n', '    function decodeMerklePathItem(Borsh.Data memory data) internal pure returns (MerklePathItem memory item) {\n', '        item.hash = data.decodeBytes32();\n', '        item.direction = data.decodeU8();\n', '        require(item.direction < 2, "ProofDecoder: MerklePathItem direction should be 0 or 1");\n', '    }\n', '\n', '    struct MerklePath {\n', '        MerklePathItem[] items;\n', '    }\n', '\n', '    function decodeMerklePath(Borsh.Data memory data) internal pure returns (MerklePath memory path) {\n', '        path.items = new MerklePathItem[](data.decodeU32());\n', '        for (uint i = 0; i < path.items.length; i++) {\n', '            path.items[i] = data.decodeMerklePathItem();\n', '        }\n', '    }\n', '\n', '    struct ExecutionOutcomeWithIdAndProof {\n', '        MerklePath proof;\n', '        bytes32 block_hash;\n', '        ExecutionOutcomeWithId outcome_with_id;\n', '    }\n', '\n', '    function decodeExecutionOutcomeWithIdAndProof(Borsh.Data memory data)\n', '        internal\n', '        view\n', '        returns (ExecutionOutcomeWithIdAndProof memory outcome)\n', '    {\n', '        outcome.proof = data.decodeMerklePath();\n', '        outcome.block_hash = data.decodeBytes32();\n', '        outcome.outcome_with_id = data.decodeExecutionOutcomeWithId();\n', '    }\n', '}\n', '\n', '// File: rainbow-bridge/contracts/eth/nearprover/contracts/INearProver.sol\n', '\n', 'pragma solidity ^0.6;\n', '\n', 'interface INearProver {\n', '    function proveOutcome(bytes calldata proofData, uint64 blockHeight) external view returns (bool);\n', '}\n', '\n', '// File: contracts/Locker.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', 'contract Locker {\n', '    using Borsh for Borsh.Data;\n', '    using ProofDecoder for Borsh.Data;\n', '\n', '    INearProver public prover_;\n', '    bytes public nearTokenFactory_;\n', '\n', '    /// Proofs from blocks that are below the acceptance height will be rejected.\n', '    // If `minBlockAcceptanceHeight_` value is zero - proofs from block with any height are accepted.\n', '    uint64 public minBlockAcceptanceHeight_;\n', '\n', '    // OutcomeReciptId -> Used\n', '    mapping(bytes32 => bool) public usedProofs_;\n', '\n', '    constructor(bytes memory nearTokenFactory, INearProver prover, uint64 minBlockAcceptanceHeight) public {\n', '        require(nearTokenFactory.length > 0, "Invalid Near Token Factory address");\n', '        require(address(prover) != address(0), "Invalid Near prover address");\n', '\n', '        nearTokenFactory_ = nearTokenFactory;\n', '        prover_ = prover;\n', '        minBlockAcceptanceHeight_ = minBlockAcceptanceHeight;\n', '    }\n', '\n', "    /// Parses the provided proof and consumes it if it's not already used.\n", '    /// The consumed event cannot be reused for future calls.\n', '    function _parseAndConsumeProof(bytes memory proofData, uint64 proofBlockHeight)\n', '        internal\n', '        returns (ProofDecoder.ExecutionStatus memory result)\n', '    {\n', '        require(proofBlockHeight >= minBlockAcceptanceHeight_, "Proof is from the ancient block");\n', '        require(prover_.proveOutcome(proofData, proofBlockHeight), "Proof should be valid");\n', '\n', '        // Unpack the proof and extract the execution outcome.\n', '        Borsh.Data memory borshData = Borsh.from(proofData);\n', '        ProofDecoder.FullOutcomeProof memory fullOutcomeProof = borshData.decodeFullOutcomeProof();\n', '        require(borshData.finished(), "Argument should be exact borsh serialization");\n', '\n', '        bytes32 receiptId = fullOutcomeProof.outcome_proof.outcome_with_id.outcome.receipt_ids[0];\n', '        require(!usedProofs_[receiptId], "The burn event proof cannot be reused");\n', '        usedProofs_[receiptId] = true;\n', '\n', '        require(keccak256(fullOutcomeProof.outcome_proof.outcome_with_id.outcome.executor_id)\n', '                == keccak256(nearTokenFactory_),\n', '                "Can only unlock tokens from the linked proof producer on Near blockchain");\n', '\n', '        result = fullOutcomeProof.outcome_proof.outcome_with_id.outcome.status;\n', '        require(!result.failed, "Cannot use failed execution outcome for unlocking the tokens");\n', '        require(!result.unknown, "Cannot use unknown execution outcome for unlocking the tokens");\n', '    }\n', '}\n', '\n', '// File: contracts/ERC20Locker.sol\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract ERC20Locker is Locker, AdminControlled {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    event Locked (\n', '        address indexed token,\n', '        address indexed sender,\n', '        uint256 amount,\n', '        string accountId\n', '    );\n', '\n', '    event Unlocked (\n', '        uint128 amount,\n', '        address recipient\n', '    );\n', '\n', '    // Function output from burning fungible token on Near side.\n', '    struct BurnResult {\n', '        uint128 amount;\n', '        address token;\n', '        address recipient;\n', '    }\n', '\n', '    uint constant UNPAUSED_ALL = 0;\n', '    uint constant PAUSED_LOCK = 1 << 0;\n', '    uint constant PAUSED_UNLOCK = 1 << 1;\n', '\n', '    // ERC20Locker is linked to the bridge token factory on NEAR side.\n', '    // It also links to the prover that it uses to unlock the tokens.\n', '    constructor(bytes memory nearTokenFactory,\n', '                INearProver prover,\n', '                uint64 minBlockAcceptanceHeight,\n', '                address _admin,\n', '                uint pausedFlags)\n', '        AdminControlled(_admin, pausedFlags)\n', '        Locker(nearTokenFactory, prover, minBlockAcceptanceHeight)\n', '        public\n', '    {\n', '    }\n', '\n', '    function lockToken(address ethToken, uint256 amount, string memory accountId)\n', '        public\n', '        pausable (PAUSED_LOCK)\n', '    {\n', '        require(IERC20(ethToken).balanceOf(address(this)).add(amount) <= ((uint256(1) << 128) - 1), "Maximum tokens locked exceeded (< 2^128 - 1)");\n', '        IERC20(ethToken).safeTransferFrom(msg.sender, address(this), amount);\n', '        emit Locked(address(ethToken), msg.sender, amount, accountId);\n', '    }\n', '\n', '    function unlockToken(bytes memory proofData, uint64 proofBlockHeight)\n', '        public\n', '        pausable (PAUSED_UNLOCK)\n', '    {\n', '        ProofDecoder.ExecutionStatus memory status = _parseAndConsumeProof(proofData, proofBlockHeight);\n', '        BurnResult memory result = _decodeBurnResult(status.successValue);\n', '        IERC20(result.token).safeTransfer(result.recipient, result.amount);\n', '        emit Unlocked(result.amount, result.recipient);\n', '    }\n', '\n', '    function _decodeBurnResult(bytes memory data) internal pure returns(BurnResult memory result) {\n', '        Borsh.Data memory borshData = Borsh.from(data);\n', '        uint8 flag = borshData.decodeU8();\n', '        require(flag == 0, "ERR_NOT_WITHDRAW_RESULT");\n', '        result.amount = borshData.decodeU128();\n', '        bytes20 token = borshData.decodeBytes20();\n', '        result.token = address(uint160(token));\n', '        bytes20 recipient = borshData.decodeBytes20();\n', '        result.recipient = address(uint160(recipient));\n', '    }\n', '\n', '    // tokenFallback implements the ContractReceiver interface from ERC223-token-standard.\n', '    // This allows to support ERC223 tokens with no extra cost.\n', "    // The function always passes: we don't need to make any decision and the contract always\n", '    // accept token transfers transfer.\n', '    function tokenFallback(address _from, uint _value, bytes memory _data) public pure {}\n', '\n', '    function adminTransfer(IERC20 token, address destination, uint amount)\n', '        public\n', '        onlyAdmin\n', '    {\n', '        token.safeTransfer(destination, amount);\n', '    }\n', '}']