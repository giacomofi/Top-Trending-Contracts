['// SPDX-License-Identifier: agpl-3.0\n', 'pragma solidity 0.6.12;\n', '\n', "import {IERC20} from './IERC20.sol';\n", "import {SafeERC20} from './SafeERC20.sol';\n", "import {ILendingPool} from './ILendingPool.sol';\n", "import {IAToken} from './IAToken.sol';\n", "import {WadRayMath} from './WadRayMath.sol';\n", "import {Errors} from './Errors.sol';\n", "import {VersionedInitializable} from './VersionedInitializable.sol';\n", "import {IncentivizedERC20} from './IncentivizedERC20.sol';\n", '\n', '/**\n', ' * @title Aave ERC20 AToken\n', ' * @dev Implementation of the interest bearing token for the Aave protocol\n', ' * @author Aave\n', ' */\n', 'contract AToken is VersionedInitializable, IncentivizedERC20, IAToken {\n', '  using WadRayMath for uint256;\n', '  using SafeERC20 for IERC20;\n', '\n', "  bytes public constant EIP712_REVISION = bytes('1');\n", '  bytes32 internal constant EIP712_DOMAIN =\n', "    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\n", '  bytes32 public constant PERMIT_TYPEHASH =\n', "    keccak256('Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)');\n", '\n', '  uint256 public constant UINT_MAX_VALUE = uint256(-1);\n', '  uint256 public constant ATOKEN_REVISION = 0x1;\n', '  address public immutable UNDERLYING_ASSET_ADDRESS;\n', '  address public immutable RESERVE_TREASURY_ADDRESS;\n', '  ILendingPool public immutable POOL;\n', '\n', '  /// @dev owner => next valid nonce to submit with permit()\n', '  mapping(address => uint256) public _nonces;\n', '\n', '  bytes32 public DOMAIN_SEPARATOR;\n', '\n', '  modifier onlyLendingPool {\n', '    require(_msgSender() == address(POOL), Errors.CT_CALLER_MUST_BE_LENDING_POOL);\n', '    _;\n', '  }\n', '\n', '  constructor(\n', '    ILendingPool pool,\n', '    address underlyingAssetAddress,\n', '    address reserveTreasuryAddress,\n', '    string memory tokenName,\n', '    string memory tokenSymbol,\n', '    address incentivesController\n', '  ) public IncentivizedERC20(tokenName, tokenSymbol, 18, incentivesController) {\n', '    POOL = pool;\n', '    UNDERLYING_ASSET_ADDRESS = underlyingAssetAddress;\n', '    RESERVE_TREASURY_ADDRESS = reserveTreasuryAddress;\n', '  }\n', '\n', '  function getRevision() internal pure virtual override returns (uint256) {\n', '    return ATOKEN_REVISION;\n', '  }\n', '\n', '  function initialize(\n', '    uint8 underlyingAssetDecimals,\n', '    string calldata tokenName,\n', '    string calldata tokenSymbol\n', '  ) external virtual initializer {\n', '    uint256 chainId;\n', '\n', '    //solium-disable-next-line\n', '    assembly {\n', '      chainId := chainid()\n', '    }\n', '\n', '    DOMAIN_SEPARATOR = keccak256(\n', '      abi.encode(\n', '        EIP712_DOMAIN,\n', '        keccak256(bytes(tokenName)),\n', '        keccak256(EIP712_REVISION),\n', '        chainId,\n', '        address(this)\n', '      )\n', '    );\n', '\n', '    _setName(tokenName);\n', '    _setSymbol(tokenSymbol);\n', '    _setDecimals(underlyingAssetDecimals);\n', '  }\n', '\n', '  /**\n', '   * @dev Burns aTokens from `user` and sends the equivalent amount of underlying to `receiverOfUnderlying`\n', '   * - Only callable by the LendingPool, as extra state updates there need to be managed\n', '   * @param user The owner of the aTokens, getting them burned\n', '   * @param receiverOfUnderlying The address that will receive the underlying\n', '   * @param amount The amount being burned\n', '   * @param index The new liquidity index of the reserve\n', '   **/\n', '  function burn(\n', '    address user,\n', '    address receiverOfUnderlying,\n', '    uint256 amount,\n', '    uint256 index\n', '  ) external override onlyLendingPool {\n', '    uint256 amountScaled = amount.rayDiv(index);\n', '    require(amountScaled != 0, Errors.CT_INVALID_BURN_AMOUNT);\n', '    _burn(user, amountScaled);\n', '\n', '    IERC20(UNDERLYING_ASSET_ADDRESS).safeTransfer(receiverOfUnderlying, amount);\n', '\n', '    emit Transfer(user, address(0), amount);\n', '    emit Burn(user, receiverOfUnderlying, amount, index);\n', '  }\n', '\n', '  /**\n', '   * @dev Mints `amount` aTokens to `user`\n', '   * - Only callable by the LendingPool, as extra state updates there need to be managed\n', '   * @param user The address receiving the minted tokens\n', '   * @param amount The amount of tokens getting minted\n', '   * @param index The new liquidity index of the reserve\n', '   * @return `true` if the the previous balance of the user was 0\n', '   */\n', '  function mint(\n', '    address user,\n', '    uint256 amount,\n', '    uint256 index\n', '  ) external override onlyLendingPool returns (bool) {\n', '    uint256 previousBalance = super.balanceOf(user);\n', '\n', '    uint256 amountScaled = amount.rayDiv(index);\n', '    require(amountScaled != 0, Errors.CT_INVALID_MINT_AMOUNT);\n', '    _mint(user, amountScaled);\n', '\n', '    emit Transfer(address(0), user, amount);\n', '    emit Mint(user, amount, index);\n', '\n', '    return previousBalance == 0;\n', '  }\n', '\n', '  /**\n', '   * @dev Mints aTokens to the reserve treasury\n', '   * - Only callable by the LendingPool\n', '   * @param amount The amount of tokens getting minted\n', '   * @param index The new liquidity index of the reserve\n', '   */\n', '  function mintToTreasury(uint256 amount, uint256 index) external override onlyLendingPool {\n', '    if (amount == 0) {\n', '      return;\n', '    }\n', '\n', "    // Compared to the normal mint, we don't check for rounding errors.\n", '    // The amount to mint can easily be very small since it is a fraction of the interest ccrued.\n', '    // In that case, the treasury will experience a (very small) loss, but it\n', '    // wont cause potentially valid transactions to fail.\n', '    _mint(RESERVE_TREASURY_ADDRESS, amount.rayDiv(index));\n', '\n', '    emit Transfer(address(0), RESERVE_TREASURY_ADDRESS, amount);\n', '    emit Mint(RESERVE_TREASURY_ADDRESS, amount, index);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers aTokens in the event of a borrow being liquidated, in case the liquidators reclaims the aToken\n', '   * - Only callable by the LendingPool\n', '   * @param from The address getting liquidated, current owner of the aTokens\n', '   * @param to The recipient\n', '   * @param value The amount of tokens getting transferred\n', '   **/\n', '  function transferOnLiquidation(\n', '    address from,\n', '    address to,\n', '    uint256 value\n', '  ) external override onlyLendingPool {\n', '    // Being a normal transfer, the Transfer() and BalanceTransfer() are emitted\n', '    // so no need to emit a specific event here\n', '    _transfer(from, to, value, false);\n', '\n', '    emit Transfer(from, to, value);\n', '  }\n', '\n', '  /**\n', '   * @dev Calculates the balance of the user: principal balance + interest generated by the principal\n', '   * @param user The user whose balance is calculated\n', '   * @return The balance of the user\n', '   **/\n', '  function balanceOf(address user)\n', '    public\n', '    view\n', '    override(IncentivizedERC20, IERC20)\n', '    returns (uint256)\n', '  {\n', '    return super.balanceOf(user).rayMul(POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the scaled balance of the user. The scaled balance is the sum of all the\n', "   * updated stored balance divided by the reserve's liquidity index at the moment of the update\n", '   * @param user The user whose balance is calculated\n', '   * @return The scaled balance of the user\n', '   **/\n', '  function scaledBalanceOf(address user) external view override returns (uint256) {\n', '    return super.balanceOf(user);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the scaled balance of the user and the scaled total supply.\n', '   * @param user The address of the user\n', '   * @return The scaled balance of the user\n', '   * @return The scaled balance and the scaled total supply\n', '   **/\n', '  function getScaledUserBalanceAndSupply(address user)\n', '    external\n', '    view\n', '    override\n', '    returns (uint256, uint256)\n', '  {\n', '    return (super.balanceOf(user), super.totalSupply());\n', '  }\n', '\n', '  /**\n', '   * @dev calculates the total supply of the specific aToken\n', '   * since the balance of every single user increases over time, the total supply\n', '   * does that too.\n', '   * @return the current total supply\n', '   **/\n', '  function totalSupply() public view override(IncentivizedERC20, IERC20) returns (uint256) {\n', '    uint256 currentSupplyScaled = super.totalSupply();\n', '\n', '    if (currentSupplyScaled == 0) {\n', '      return 0;\n', '    }\n', '\n', '    return currentSupplyScaled.rayMul(POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS));\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the scaled total supply of the variable debt token. Represents sum(debt/index)\n', '   * @return the scaled total supply\n', '   **/\n', '  function scaledTotalSupply() public view virtual override returns (uint256) {\n', '    return super.totalSupply();\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n', '   * assets in borrow(), withdraw() and flashLoan()\n', '   * @param target The recipient of the aTokens\n', '   * @param amount The amount getting transferred\n', '   * @return The amount transferred\n', '   **/\n', '  function transferUnderlyingTo(address target, uint256 amount)\n', '    external\n', '    override\n', '    onlyLendingPool\n', '    returns (uint256)\n', '  {\n', '    IERC20(UNDERLYING_ASSET_ADDRESS).safeTransfer(target, amount);\n', '    return amount;\n', '  }\n', '\n', '  /**\n', '   * @dev implements the permit function as for\n', '   * https://github.com/ethereum/EIPs/blob/8a34d644aacf0f9f8f00815307fd7dd5da07655f/EIPS/eip-2612.md\n', '   * @param owner The owner of the funds\n', '   * @param spender The spender\n', '   * @param value The amount\n', '   * @param deadline The deadline timestamp, type(uint256).max for max deadline\n', '   * @param v Signature param\n', '   * @param s Signature param\n', '   * @param r Signature param\n', '   */\n', '  function permit(\n', '    address owner,\n', '    address spender,\n', '    uint256 value,\n', '    uint256 deadline,\n', '    uint8 v,\n', '    bytes32 r,\n', '    bytes32 s\n', '  ) external {\n', "    require(owner != address(0), 'INVALID_OWNER');\n", '    //solium-disable-next-line\n', "    require(block.timestamp <= deadline, 'INVALID_EXPIRATION');\n", '    uint256 currentValidNonce = _nonces[owner];\n', '    bytes32 digest =\n', '      keccak256(\n', '        abi.encodePacked(\n', "          '\\x19\\x01',\n", '          DOMAIN_SEPARATOR,\n', '          keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, currentValidNonce, deadline))\n', '        )\n', '      );\n', "    require(owner == ecrecover(digest, v, r, s), 'INVALID_SIGNATURE');\n", '    _nonces[owner] = currentValidNonce.add(1);\n', '    _approve(owner, spender, value);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers the aTokens between two users. Validates the transfer\n', '   * (ie checks for valid HF after the transfer) if required\n', '   * @param from The source address\n', '   * @param to The destination address\n', '   * @param amount The amount getting transferred\n', '   * @param validate `true` if the transfer needs to be validated\n', '   **/\n', '  function _transfer(\n', '    address from,\n', '    address to,\n', '    uint256 amount,\n', '    bool validate\n', '  ) internal {\n', '    uint256 index = POOL.getReserveNormalizedIncome(UNDERLYING_ASSET_ADDRESS);\n', '\n', '    uint256 fromBalanceBefore = super.balanceOf(from).rayMul(index);\n', '    uint256 toBalanceBefore = super.balanceOf(to).rayMul(index);\n', '\n', '    super._transfer(from, to, amount.rayDiv(index));\n', '\n', '    if (validate) {\n', '      POOL.finalizeTransfer(\n', '        UNDERLYING_ASSET_ADDRESS,\n', '        from,\n', '        to,\n', '        amount,\n', '        fromBalanceBefore,\n', '        toBalanceBefore\n', '      );\n', '    }\n', '\n', '    emit BalanceTransfer(from, to, amount, index);\n', '  }\n', '\n', '  /**\n', '   * @dev Overrides the parent _transfer to force validated transfer() and transferFrom()\n', '   * @param from The source address\n', '   * @param to The destination address\n', '   * @param amount The amount getting transferred\n', '   **/\n', '  function _transfer(\n', '    address from,\n', '    address to,\n', '    uint256 amount\n', '  ) internal override {\n', '    _transfer(from, to, amount, true);\n', '  }\n', '}']