['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-25\n', '*/\n', '\n', '// SPDX-License-Identifier: MIXED\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '/// @notice A library for performing overflow-/underflow-safe math,\n', '/// updated with awesomeness from of DappHub (https://github.com/dapphub/ds-math).\n', 'library BoringMath {\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n', '        require(b == 0 || (c = a * b) / b == a, "BoringMath: Mul Overflow");\n', '    }\n', '\n', '    function to128(uint256 a) internal pure returns (uint128 c) {\n', '        require(a <= uint128(-1), "BoringMath: uint128 Overflow");\n', '        c = uint128(a);\n', '    }\n', '\n', '    function to64(uint256 a) internal pure returns (uint64 c) {\n', '        require(a <= uint64(-1), "BoringMath: uint64 Overflow");\n', '        c = uint64(a);\n', '    }\n', '\n', '    function to32(uint256 a) internal pure returns (uint32 c) {\n', '        require(a <= uint32(-1), "BoringMath: uint32 Overflow");\n', '        c = uint32(a);\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint128.\n', 'library BoringMath128 {\n', '    function add(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint128 a, uint128 b) internal pure returns (uint128 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint64.\n', 'library BoringMath64 {\n', '    function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint64 a, uint64 b) internal pure returns (uint64 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '/// @notice A library for performing overflow-/underflow-safe addition and subtraction on uint32.\n', 'library BoringMath32 {\n', '    function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '        require((c = a + b) >= b, "BoringMath: Add Overflow");\n', '    }\n', '\n', '    function sub(uint32 a, uint32 b) internal pure returns (uint32 c) {\n', '        require((c = a - b) <= a, "BoringMath: Underflow");\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/interfaces/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IERC20 {\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '\n', '    /// @notice EIP 2612\n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', '// Based on code and smartness by Ross Campbell and Keno\n', '// Uses immutable to store the domain separator to reduce gas usage\n', '// If the chain id changes due to a fork, the forked chain will calculate on the fly.\n', 'pragma solidity 0.6.12;\n', '\n', '// solhint-disable no-inline-assembly\n', '\n', 'contract Domain {\n', '    bytes32 private constant DOMAIN_SEPARATOR_SIGNATURE_HASH = keccak256("EIP712Domain(uint256 chainId,address verifyingContract)");\n', '    // See https://eips.ethereum.org/EIPS/eip-191\n', '    string private constant EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA = "\\x19\\x01";\n', '\n', '    // solhint-disable var-name-mixedcase\n', '    bytes32 private immutable _DOMAIN_SEPARATOR;\n', '    uint256 private immutable DOMAIN_SEPARATOR_CHAIN_ID;\n', '\n', '    /// @dev Calculate the DOMAIN_SEPARATOR\n', '    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n', '        return keccak256(abi.encode(DOMAIN_SEPARATOR_SIGNATURE_HASH, chainId, address(this)));\n', '    }\n', '\n', '    constructor() public {\n', '        uint256 chainId;\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '        _DOMAIN_SEPARATOR = _calculateDomainSeparator(DOMAIN_SEPARATOR_CHAIN_ID = chainId);\n', '    }\n', '\n', '    /// @dev Return the DOMAIN_SEPARATOR\n', "    // It's named internal to allow making it public from the contract that uses it by creating a simple view function\n", '    // with the desired public name, such as DOMAIN_SEPARATOR or domainSeparator.\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function _domainSeparator() internal view returns (bytes32) {\n', '        uint256 chainId;\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '        return chainId == DOMAIN_SEPARATOR_CHAIN_ID ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId);\n', '    }\n', '\n', '    function _getDigest(bytes32 dataHash) internal view returns (bytes32 digest) {\n', '        digest = keccak256(abi.encodePacked(EIP191_PREFIX_FOR_EIP712_STRUCTURED_DATA, _domainSeparator(), dataHash));\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '// solhint-disable no-inline-assembly\n', '// solhint-disable not-rely-on-time\n', '\n', '// Data part taken out for building of contracts that receive delegate calls\n', 'contract ERC20Data {\n', '    /// @notice owner > balance mapping.\n', '    mapping(address => uint256) public balanceOf;\n', '    /// @notice owner > spender > allowance mapping.\n', '    mapping(address => mapping(address => uint256)) public allowance;\n', '    /// @notice owner > nonce mapping. Used in `permit`.\n', '    mapping(address => uint256) public nonces;\n', '}\n', '\n', 'abstract contract ERC20 is IERC20, Domain {\n', '    /// @notice owner > balance mapping.\n', '    mapping(address => uint256) public override balanceOf;\n', '    /// @notice owner > spender > allowance mapping.\n', '    mapping(address => mapping(address => uint256)) public override allowance;\n', '    /// @notice owner > nonce mapping. Used in `permit`.\n', '    mapping(address => uint256) public nonces;\n', '\n', '    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n', '    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n', '\n', '    /// @notice Transfers `amount` tokens from `msg.sender` to `to`.\n', '    /// @param to The address to move the tokens.\n', '    /// @param amount of the tokens to move.\n', '    /// @return (bool) Returns True if succeeded.\n', '    function transfer(address to, uint256 amount) public returns (bool) {\n', '        // If `amount` is 0, or `msg.sender` is `to` nothing happens\n', '        if (amount != 0 || msg.sender == to) {\n', '            uint256 srcBalance = balanceOf[msg.sender];\n', '            require(srcBalance >= amount, "ERC20: balance too low");\n', '            if (msg.sender != to) {\n', '                require(to != address(0), "ERC20: no zero address"); // Moved down so low balance calls safe some gas\n', '\n', '                balanceOf[msg.sender] = srcBalance - amount; // Underflow is checked\n', '                balanceOf[to] += amount;\n', '            }\n', '        }\n', '        emit Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Transfers `amount` tokens from `from` to `to`. Caller needs approval for `from`.\n', '    /// @param from Address to draw tokens from.\n', '    /// @param to The address to move the tokens.\n', '    /// @param amount The token amount to move.\n', '    /// @return (bool) Returns True if succeeded.\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        // If `amount` is 0, or `from` is `to` nothing happens\n', '        if (amount != 0) {\n', '            uint256 srcBalance = balanceOf[from];\n', '            require(srcBalance >= amount, "ERC20: balance too low");\n', '\n', '            if (from != to) {\n', '                uint256 spenderAllowance = allowance[from][msg.sender];\n', "                // If allowance is infinite, don't decrease it to save on gas (breaks with EIP-20).\n", '                if (spenderAllowance != type(uint256).max) {\n', '                    require(spenderAllowance >= amount, "ERC20: allowance too low");\n', '                    allowance[from][msg.sender] = spenderAllowance - amount; // Underflow is checked\n', '                }\n', '                require(to != address(0), "ERC20: no zero address"); // Moved down so other failed calls safe some gas\n', '\n', '                balanceOf[from] = srcBalance - amount; // Underflow is checked\n', '                balanceOf[to] += amount;\n', '            }\n', '        }\n', '        emit Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /// @notice Approves `amount` from sender to be spend by `spender`.\n', "    /// @param spender Address of the party that can draw from msg.sender's account.\n", '    /// @param amount The maximum collective amount that `spender` can draw.\n', '    /// @return (bool) Returns True if approved.\n', '    function approve(address spender, uint256 amount) public override returns (bool) {\n', '        allowance[msg.sender][spender] = amount;\n', '        emit Approval(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    // solhint-disable-next-line func-name-mixedcase\n', '    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n', '        return _domainSeparator();\n', '    }\n', '\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 private constant PERMIT_SIGNATURE_HASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '\n', '    /// @notice Approves `value` from `owner_` to be spend by `spender`.\n', '    /// @param owner_ Address of the owner.\n', '    /// @param spender The address of the spender that gets approved to draw from `owner_`.\n', '    /// @param value The maximum collective amount that `spender` can draw.\n', '    /// @param deadline This permit must be redeemed before this deadline (UTC timestamp in seconds).\n', '    function permit(\n', '        address owner_,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external override {\n', '        require(owner_ != address(0), "ERC20: Owner cannot be 0");\n', '        require(block.timestamp < deadline, "ERC20: Expired");\n', '        require(\n', '            ecrecover(_getDigest(keccak256(abi.encode(PERMIT_SIGNATURE_HASH, owner_, spender, value, nonces[owner_]++, deadline))), v, r, s) ==\n', '                owner_,\n', '            "ERC20: Invalid Signature"\n', '        );\n', '        allowance[owner_][spender] = value;\n', '        emit Approval(owner_, spender, value);\n', '    }\n', '}\n', '\n', 'contract ERC20WithSupply is IERC20, ERC20 {\n', '    uint256 public override totalSupply;\n', '\n', '    function _mint(address user, uint256 amount) private {\n', '        uint256 newTotalSupply = totalSupply + amount;\n', '        require(newTotalSupply >= totalSupply, "Mint overflow");\n', '        totalSupply = newTotalSupply;\n', '        balanceOf[user] += amount;\n', '    }\n', '\n', '    function _burn(address user, uint256 amount) private {\n', '        require(balanceOf[user] >= amount, "Burn too much");\n', '        totalSupply -= amount;\n', '        balanceOf[user] -= amount;\n', '    }\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/libraries/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'struct Rebase {\n', '    uint128 elastic;\n', '    uint128 base;\n', '}\n', '\n', '/// @notice A rebasing library using overflow-/underflow-safe math.\n', 'library RebaseLibrary {\n', '    using BoringMath for uint256;\n', '    using BoringMath128 for uint128;\n', '\n', '    /// @notice Calculates the base value in relationship to `elastic` and `total`.\n', '    function toBase(\n', '        Rebase memory total,\n', '        uint256 elastic,\n', '        bool roundUp\n', '    ) internal pure returns (uint256 base) {\n', '        if (total.elastic == 0) {\n', '            base = elastic;\n', '        } else {\n', '            base = elastic.mul(total.base) / total.elastic;\n', '            if (roundUp && base.mul(total.elastic) / total.base < elastic) {\n', '                base = base.add(1);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Calculates the elastic value in relationship to `base` and `total`.\n', '    function toElastic(\n', '        Rebase memory total,\n', '        uint256 base,\n', '        bool roundUp\n', '    ) internal pure returns (uint256 elastic) {\n', '        if (total.base == 0) {\n', '            elastic = base;\n', '        } else {\n', '            elastic = base.mul(total.elastic) / total.base;\n', '            if (roundUp && elastic.mul(total.base) / total.elastic < base) {\n', '                elastic = elastic.add(1);\n', '            }\n', '        }\n', '    }\n', '\n', '    /// @notice Add `elastic` to `total` and doubles `total.base`.\n', '    /// @return (Rebase) The new total.\n', '    /// @return base in relationship to `elastic`.\n', '    function add(\n', '        Rebase memory total,\n', '        uint256 elastic,\n', '        bool roundUp\n', '    ) internal pure returns (Rebase memory, uint256 base) {\n', '        base = toBase(total, elastic, roundUp);\n', '        total.elastic = total.elastic.add(elastic.to128());\n', '        total.base = total.base.add(base.to128());\n', '        return (total, base);\n', '    }\n', '\n', '    /// @notice Sub `base` from `total` and update `total.elastic`.\n', '    /// @return (Rebase) The new total.\n', '    /// @return elastic in relationship to `base`.\n', '    function sub(\n', '        Rebase memory total,\n', '        uint256 base,\n', '        bool roundUp\n', '    ) internal pure returns (Rebase memory, uint256 elastic) {\n', '        elastic = toElastic(total, base, roundUp);\n', '        total.elastic = total.elastic.sub(elastic.to128());\n', '        total.base = total.base.sub(base.to128());\n', '        return (total, elastic);\n', '    }\n', '\n', '    /// @notice Add `elastic` and `base` to `total`.\n', '    function add(\n', '        Rebase memory total,\n', '        uint256 elastic,\n', '        uint256 base\n', '    ) internal pure returns (Rebase memory) {\n', '        total.elastic = total.elastic.add(elastic.to128());\n', '        total.base = total.base.add(base.to128());\n', '        return total;\n', '    }\n', '\n', '    /// @notice Subtract `elastic` and `base` to `total`.\n', '    function sub(\n', '        Rebase memory total,\n', '        uint256 elastic,\n', '        uint256 base\n', '    ) internal pure returns (Rebase memory) {\n', '        total.elastic = total.elastic.sub(elastic.to128());\n', '        total.base = total.base.sub(base.to128());\n', '        return total;\n', '    }\n', '\n', '    /// @notice Add `elastic` to `total` and update storage.\n', '    /// @return newElastic Returns updated `elastic`.\n', '    function addElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n', '        newElastic = total.elastic = total.elastic.add(elastic.to128());\n', '    }\n', '\n', '    /// @notice Subtract `elastic` from `total` and update storage.\n', '    /// @return newElastic Returns updated `elastic`.\n', '    function subElastic(Rebase storage total, uint256 elastic) internal returns (uint256 newElastic) {\n', '        newElastic = total.elastic = total.elastic.sub(elastic.to128());\n', '    }\n', '}\n', '\n', '// File @sushiswap/bentobox-sdk/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IBatchFlashBorrower {\n', '    function onBatchFlashLoan(\n', '        address sender,\n', '        IERC20[] calldata tokens,\n', '        uint256[] calldata amounts,\n', '        uint256[] calldata fees,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// File @sushiswap/bentobox-sdk/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IFlashBorrower {\n', '    function onFlashLoan(\n', '        address sender,\n', '        IERC20 token,\n', '        uint256 amount,\n', '        uint256 fee,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// File @sushiswap/bentobox-sdk/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IStrategy {\n', '    // Send the assets to the Strategy and call skim to invest them\n', '    function skim(uint256 amount) external;\n', '\n', '    // Harvest any profits made converted to the asset and pass them to the caller\n', '    function harvest(uint256 balance, address sender) external returns (int256 amountAdded);\n', '\n', '    // Withdraw assets. The returned amount can differ from the requested amount due to rounding.\n', "    // The actualAmount should be very close to the amount. The difference should NOT be used to report a loss. That's what harvest is for.\n", '    function withdraw(uint256 amount) external returns (uint256 actualAmount);\n', '\n', "    // Withdraw all assets in the safest way possible. This shouldn't fail.\n", '    function exit(uint256 balance) external returns (int256 amountAdded);\n', '}\n', '\n', '// File @sushiswap/bentobox-sdk/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IBentoBoxV1 {\n', '    event LogDeploy(address indexed masterContract, bytes data, address indexed cloneAddress);\n', '    event LogDeposit(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n', '    event LogFlashLoan(address indexed borrower, address indexed token, uint256 amount, uint256 feeAmount, address indexed receiver);\n', '    event LogRegisterProtocol(address indexed protocol);\n', '    event LogSetMasterContractApproval(address indexed masterContract, address indexed user, bool approved);\n', '    event LogStrategyDivest(address indexed token, uint256 amount);\n', '    event LogStrategyInvest(address indexed token, uint256 amount);\n', '    event LogStrategyLoss(address indexed token, uint256 amount);\n', '    event LogStrategyProfit(address indexed token, uint256 amount);\n', '    event LogStrategyQueued(address indexed token, address indexed strategy);\n', '    event LogStrategySet(address indexed token, address indexed strategy);\n', '    event LogStrategyTargetPercentage(address indexed token, uint256 targetPercentage);\n', '    event LogTransfer(address indexed token, address indexed from, address indexed to, uint256 share);\n', '    event LogWhiteListMasterContract(address indexed masterContract, bool approved);\n', '    event LogWithdraw(address indexed token, address indexed from, address indexed to, uint256 amount, uint256 share);\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    function balanceOf(IERC20, address) external view returns (uint256);\n', '\n', '    function batch(bytes[] calldata calls, bool revertOnFail) external payable returns (bool[] memory successes, bytes[] memory results);\n', '\n', '    function batchFlashLoan(\n', '        IBatchFlashBorrower borrower,\n', '        address[] calldata receivers,\n', '        IERC20[] calldata tokens,\n', '        uint256[] calldata amounts,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function claimOwnership() external;\n', '\n', '    function deploy(\n', '        address masterContract,\n', '        bytes calldata data,\n', '        bool useCreate2\n', '    ) external payable;\n', '\n', '    function deposit(\n', '        IERC20 token_,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 share\n', '    ) external payable returns (uint256 amountOut, uint256 shareOut);\n', '\n', '    function flashLoan(\n', '        IFlashBorrower borrower,\n', '        address receiver,\n', '        IERC20 token,\n', '        uint256 amount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function harvest(\n', '        IERC20 token,\n', '        bool balance,\n', '        uint256 maxChangeAmount\n', '    ) external;\n', '\n', '    function masterContractApproved(address, address) external view returns (bool);\n', '\n', '    function masterContractOf(address) external view returns (address);\n', '\n', '    function nonces(address) external view returns (uint256);\n', '\n', '    function owner() external view returns (address);\n', '\n', '    function pendingOwner() external view returns (address);\n', '\n', '    function pendingStrategy(IERC20) external view returns (IStrategy);\n', '\n', '    function permitToken(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function registerProtocol() external;\n', '\n', '    function setMasterContractApproval(\n', '        address user,\n', '        address masterContract,\n', '        bool approved,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external;\n', '\n', '    function setStrategy(IERC20 token, IStrategy newStrategy) external;\n', '\n', '    function setStrategyTargetPercentage(IERC20 token, uint64 targetPercentage_) external;\n', '\n', '    function strategy(IERC20) external view returns (IStrategy);\n', '\n', '    function strategyData(IERC20)\n', '        external\n', '        view\n', '        returns (\n', '            uint64 strategyStartDate,\n', '            uint64 targetPercentage,\n', '            uint128 balance\n', '        );\n', '\n', '    function toAmount(\n', '        IERC20 token,\n', '        uint256 share,\n', '        bool roundUp\n', '    ) external view returns (uint256 amount);\n', '\n', '    function toShare(\n', '        IERC20 token,\n', '        uint256 amount,\n', '        bool roundUp\n', '    ) external view returns (uint256 share);\n', '\n', '    function totals(IERC20) external view returns (Rebase memory totals_);\n', '\n', '    function transfer(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 share\n', '    ) external;\n', '\n', '    function transferMultiple(\n', '        IERC20 token,\n', '        address from,\n', '        address[] calldata tos,\n', '        uint256[] calldata shares\n', '    ) external;\n', '\n', '    function transferOwnership(\n', '        address newOwner,\n', '        bool direct,\n', '        bool renounce\n', '    ) external;\n', '\n', '    function whitelistMasterContract(address masterContract, bool approved) external;\n', '\n', '    function whitelistedMasterContracts(address) external view returns (bool);\n', '\n', '    function withdraw(\n', '        IERC20 token_,\n', '        address from,\n', '        address to,\n', '        uint256 amount,\n', '        uint256 share\n', '    ) external returns (uint256 amountOut, uint256 shareOut);\n', '}\n', '\n', '// File @boringcrypto/boring-solidity/contracts/[email\xa0protected]\n', '// License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', '\n', '// Audit on 5-Jan-2021 by Keno and BoringCrypto\n', '// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n', '// Edited by BoringCrypto\n', '\n', 'contract BoringOwnableData {\n', '    address public owner;\n', '    address public pendingOwner;\n', '}\n', '\n', 'contract BoringOwnable is BoringOwnableData {\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /// @notice `owner` defaults to msg.sender on construction.\n', '    constructor() public {\n', '        owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n', '    /// Can only be invoked by the current `owner`.\n', '    /// @param newOwner Address of the new owner.\n', '    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n', '    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n', '    function transferOwnership(\n', '        address newOwner,\n', '        bool direct,\n', '        bool renounce\n', '    ) public onlyOwner {\n', '        if (direct) {\n', '            // Checks\n', '            require(newOwner != address(0) || renounce, "Ownable: zero address");\n', '\n', '            // Effects\n', '            emit OwnershipTransferred(owner, newOwner);\n', '            owner = newOwner;\n', '            pendingOwner = address(0);\n', '        } else {\n', '            // Effects\n', '            pendingOwner = newOwner;\n', '        }\n', '    }\n', '\n', '    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n', '    function claimOwnership() public {\n', '        address _pendingOwner = pendingOwner;\n', '\n', '        // Checks\n', '        require(msg.sender == _pendingOwner, "Ownable: caller != pending owner");\n', '\n', '        // Effects\n', '        emit OwnershipTransferred(owner, _pendingOwner);\n', '        owner = _pendingOwner;\n', '        pendingOwner = address(0);\n', '    }\n', '\n', '    /// @notice Only allows the `owner` to execute the function.\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '}\n', '\n', '// File contracts/MagicInternetMoney.sol\n', '// License-Identifier: MIT\n', '\n', '// Magic Internet Money\n', '\n', '// ███╗   ███╗██╗███╗   ███╗\n', '// ████╗ ████║██║████╗ ████║\n', '// ██╔████╔██║██║██╔████╔██║\n', '// ██║╚██╔╝██║██║██║╚██╔╝██║\n', '// ██║ ╚═╝ ██║██║██║ ╚═╝ ██║\n', '// ╚═╝     ╚═╝╚═╝╚═╝     ╚═╝\n', '\n', '// BoringCrypto, 0xMerlin\n', '\n', 'pragma solidity 0.6.12;\n', '\n', '/// @title Cauldron\n', '/// @dev This contract allows contract calls to any contract (except BentoBox)\n', "/// from arbitrary callers thus, don't trust calls from this contract in any circumstances.\n", 'contract MagicInternetMoneyV1 is ERC20, BoringOwnable {\n', '    using BoringMath for uint256;\n', "    // ERC20 'variables'\n", '    string public constant symbol = "MIM";\n', '    string public constant name = "Magic Internet Money";\n', '    uint8 public constant decimals = 18;\n', '    uint256 public override totalSupply;\n', '\n', '    struct Minting {\n', '        uint128 time;\n', '        uint128 amount;\n', '    }\n', '\n', '    Minting public lastMint;\n', '    uint256 private constant MINTING_PERIOD = 24 hours;\n', '    uint256 private constant MINTING_INCREASE = 15000;\n', '    uint256 private constant MINTING_PRECISION = 1e5;\n', '\n', '    function mint(address to, uint256 amount) public onlyOwner {\n', '        require(to != address(0), "MIM: no mint to zero address");\n', '\n', '        // Limits the amount minted per period to a convergence function, with the period duration restarting on every mint\n', '        uint256 totalMintedAmount = uint256(lastMint.time < block.timestamp - MINTING_PERIOD ? 0 : lastMint.amount).add(amount);\n', '        require(totalSupply == 0 || totalSupply.mul(MINTING_INCREASE) / MINTING_PRECISION >= totalMintedAmount);\n', '\n', '        lastMint.time = block.timestamp.to128();\n', '        lastMint.amount = totalMintedAmount.to128();\n', '\n', '        totalSupply = totalSupply + amount;\n', '        balanceOf[to] += amount;\n', '        emit Transfer(address(0), to, amount);\n', '    }\n', '\n', '    function mintToBentoBox(\n', '        address clone,\n', '        uint256 amount,\n', '        IBentoBoxV1 bentoBox\n', '    ) public onlyOwner {\n', '        mint(address(bentoBox), amount);\n', '        bentoBox.deposit(IERC20(address(this)), address(bentoBox), clone, amount, 0);\n', '    }\n', '\n', '    function burn(uint256 amount) public {\n', '        require(amount <= balanceOf[msg.sender], "MIM: not enough");\n', '\n', '        balanceOf[msg.sender] -= amount;\n', '        totalSupply -= amount;\n', '        emit Transfer(msg.sender, address(0), amount);\n', '    }\n', '}']