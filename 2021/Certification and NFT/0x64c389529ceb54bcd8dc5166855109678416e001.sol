['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-07\n', '*/\n', '\n', '/*\n', 'https://powerpool.finance/\n', '\n', '          wrrrw r wrr\n', '         ppwr rrr wppr0       prwwwrp                                 prwwwrp                   wr0\n', '        rr 0rrrwrrprpwp0      pp   pr  prrrr0 pp   0r  prrrr0  0rwrrr pp   pr  prrrr0  prrrr0    r0\n', '        rrp pr   wr00rrp      prwww0  pp   wr pp w00r prwwwpr  0rw    prwww0  pp   wr pp   wr    r0\n', '        r0rprprwrrrp pr0      pp      wr   pr pp rwwr wr       0r     pp      wr   pr wr   pr    r0\n', '         prwr wrr0wpwr        00        www0   0w0ww    www0   0w     00        www0    www0   0www0\n', '          wrr ww0rrrr\n', '\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity 0.6.12;\n', '\n', 'interface IPiRouterFactory {\n', '  function buildRouter(address _piToken, bytes calldata _args) external returns (address);\n', '}\n', '\n', '// File: contracts/interfaces/sushi/ISushiBar.sol\n', '\n', 'interface ISushiBar {\n', '  function enter(uint256 _amount) external;\n', '\n', '  function leave(uint256 _amount) external;\n', '}\n', '\n', '// File: @powerpool/poweroracle/contracts/interfaces/IPowerPoke.sol\n', '\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IPowerPoke {\n', "  /*** CLIENT'S CONTRACT INTERFACE ***/\n", '  function authorizeReporter(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizeNonReporter(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizeNonReporterWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinDeposit_\n', '  ) external view;\n', '\n', '  function authorizePoker(uint256 userId_, address pokerKey_) external view;\n', '\n', '  function authorizePokerWithDeposit(\n', '    uint256 userId_,\n', '    address pokerKey_,\n', '    uint256 overrideMinStake_\n', '  ) external view;\n', '\n', '  function slashReporter(uint256 slasherId_, uint256 times_) external;\n', '\n', '  function reward(\n', '    uint256 userId_,\n', '    uint256 gasUsed_,\n', '    uint256 compensationPlan_,\n', '    bytes calldata pokeOptions_\n', '  ) external;\n', '\n', '  /*** CLIENT OWNER INTERFACE ***/\n', '  function transferClientOwnership(address client_, address to_) external;\n', '\n', '  function addCredit(address client_, uint256 amount_) external;\n', '\n', '  function withdrawCredit(\n', '    address client_,\n', '    address to_,\n', '    uint256 amount_\n', '  ) external;\n', '\n', '  function setReportIntervals(\n', '    address client_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external;\n', '\n', '  function setSlasherHeartbeat(address client_, uint256 slasherHeartbeat_) external;\n', '\n', '  function setGasPriceLimit(address client_, uint256 gasPriceLimit_) external;\n', '\n', '  function setFixedCompensations(\n', '    address client_,\n', '    uint256 eth_,\n', '    uint256 cvp_\n', '  ) external;\n', '\n', '  function setBonusPlan(\n', '    address client_,\n', '    uint256 planId_,\n', '    bool active_,\n', '    uint64 bonusNominator_,\n', '    uint64 bonusDenominator_,\n', '    uint64 perGas_\n', '  ) external;\n', '\n', '  function setMinimalDeposit(address client_, uint256 defaultMinDeposit_) external;\n', '\n', '  /*** POKER INTERFACE ***/\n', '  function withdrawRewards(uint256 userId_, address to_) external;\n', '\n', '  function setPokerKeyRewardWithdrawAllowance(uint256 userId_, bool allow_) external;\n', '\n', '  /*** OWNER INTERFACE ***/\n', '  function addClient(\n', '    address client_,\n', '    address owner_,\n', '    bool canSlash_,\n', '    uint256 gasPriceLimit_,\n', '    uint256 minReportInterval_,\n', '    uint256 maxReportInterval_\n', '  ) external;\n', '\n', '  function setClientActiveFlag(address client_, bool active_) external;\n', '\n', '  function setCanSlashFlag(address client_, bool canSlash) external;\n', '\n', '  function setOracle(address oracle_) external;\n', '\n', '  function pause() external;\n', '\n', '  function unpause() external;\n', '\n', '  /*** GETTERS ***/\n', '  function creditOf(address client_) external view returns (uint256);\n', '\n', '  function ownerOf(address client_) external view returns (address);\n', '\n', '  function getMinMaxReportIntervals(address client_) external view returns (uint256 min, uint256 max);\n', '\n', '  function getSlasherHeartbeat(address client_) external view returns (uint256);\n', '\n', '  function getGasPriceLimit(address client_) external view returns (uint256);\n', '\n', '  function getPokerBonus(\n', '    address client_,\n', '    uint256 bonusPlanId_,\n', '    uint256 gasUsed_,\n', '    uint256 userDeposit_\n', '  ) external view returns (uint256);\n', '\n', '  function getGasPriceFor(address client_) external view returns (uint256);\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '  /**\n', '   * @dev Returns the amount of tokens in existence.\n', '   */\n', '  function totalSupply() external view returns (uint256);\n', '\n', '  /**\n', '   * @dev Returns the amount of tokens owned by `account`.\n', '   */\n', '  function balanceOf(address account) external view returns (uint256);\n', '\n', '  /**\n', "   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   */\n', '  function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Returns the remaining number of tokens that `spender` will be\n', '   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '   * zero by default.\n', '   *\n', '   * This value changes when {approve} or {transferFrom} are called.\n', '   */\n', '  function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '  /**\n', "   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '   * that someone may use both the old and the new allowance by unfortunate\n', '   * transaction ordering. One possible solution to mitigate this race\n', "   * condition is to first reduce the spender's allowance to 0 and set the\n", '   * desired value afterwards:\n', '   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '   *\n', '   * Emits an {Approval} event.\n', '   */\n', '  function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "   * allowance mechanism. `amount` is then deducted from the caller's\n", '   * allowance.\n', '   *\n', '   * Returns a boolean value indicating whether the operation succeeded.\n', '   *\n', '   * Emits a {Transfer} event.\n', '   */\n', '  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '  /**\n', '   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '   * another (`to`).\n', '   *\n', '   * Note that `value` may be zero.\n', '   */\n', '  event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '  /**\n', '   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '   * a call to {approve}. `value` is the new allowance.\n', '   */\n', '  event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: @openzeppelin/contracts/math/SafeMath.sol\n', '\n', '/**\n', " * @dev Wrappers over Solidity's arithmetic operations with added overflow\n", ' * checks.\n', ' *\n', ' * Arithmetic operations in Solidity wrap on overflow. This can easily result\n', ' * in bugs, because programmers usually assume that an overflow raises an\n', ' * error, which is the standard behavior in high level programming languages.\n', ' * `SafeMath` restores this intuition by reverting the transaction when an\n', ' * operation overflows.\n', ' *\n', ' * Using this library instead of the unchecked operations eliminates an entire\n', " * class of bugs, so it's recommended to use it always.\n", ' */\n', 'library SafeMath {\n', '  /**\n', '   * @dev Returns the addition of two unsigned integers, reverting on\n', '   * overflow.\n', '   *\n', "   * Counterpart to Solidity's `+` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Addition cannot overflow.\n', '   */\n', '  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    uint256 c = a + b;\n', '    require(c >= a, "SafeMath: addition overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the subtraction of two unsigned integers, reverting on\n', '   * overflow (when the result is negative).\n', '   *\n', "   * Counterpart to Solidity's `-` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Subtraction cannot overflow.\n', '   */\n', '  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return sub(a, b, "SafeMath: subtraction overflow");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n', '   * overflow (when the result is negative).\n', '   *\n', "   * Counterpart to Solidity's `-` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Subtraction cannot overflow.\n', '   */\n', '  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '    require(b <= a, errorMessage);\n', '    uint256 c = a - b;\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the multiplication of two unsigned integers, reverting on\n', '   * overflow.\n', '   *\n', "   * Counterpart to Solidity's `*` operator.\n", '   *\n', '   * Requirements:\n', '   *\n', '   * - Multiplication cannot overflow.\n', '   */\n', '  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "    // benefit is lost if 'b' is also tested.\n", '    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n', '    if (a == 0) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 c = a * b;\n', '    require(c / a == b, "SafeMath: multiplication overflow");\n', '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the integer division of two unsigned integers. Reverts on\n', '   * division by zero. The result is rounded towards zero.\n', '   *\n', "   * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '   * uses an invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return div(a, b, "SafeMath: division by zero");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n', '   * division by zero. The result is rounded towards zero.\n', '   *\n', "   * Counterpart to Solidity's `/` operator. Note: this function uses a\n", '   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n', '   * uses an invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '    require(b > 0, errorMessage);\n', '    uint256 c = a / b;\n', "    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '    return c;\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '   * Reverts when dividing by zero.\n', '   *\n', "   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '   * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '   * invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '    return mod(a, b, "SafeMath: modulo by zero");\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n', '   * Reverts with custom message when dividing by zero.\n', '   *\n', "   * Counterpart to Solidity's `%` operator. This function uses a `revert`\n", '   * opcode (which leaves remaining gas untouched) while Solidity uses an\n', '   * invalid opcode to revert (consuming all remaining gas).\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - The divisor cannot be zero.\n', '   */\n', '  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n', '    require(b != 0, errorMessage);\n', '    return a % b;\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/utils/Address.sol\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '  /**\n', '   * @dev Returns true if `account` is a contract.\n', '   *\n', '   * [IMPORTANT]\n', '   * ====\n', '   * It is unsafe to assume that an address for which this function returns\n', '   * false is an externally-owned account (EOA) and not a contract.\n', '   *\n', '   * Among others, `isContract` will return false for the following\n', '   * types of addresses:\n', '   *\n', '   *  - an externally-owned account\n', '   *  - a contract in construction\n', '   *  - an address where a contract will be created\n', '   *  - an address where a contract lived, but was destroyed\n', '   * ====\n', '   */\n', '  function isContract(address account) internal view returns (bool) {\n', '    // This method relies on extcodesize, which returns 0 for contracts in\n', '    // construction, since the code is only stored at the end of the\n', '    // constructor execution.\n', '\n', '    uint256 size;\n', '    // solhint-disable-next-line no-inline-assembly\n', '    assembly { size := extcodesize(account) }\n', '    return size > 0;\n', '  }\n', '\n', '  /**\n', "   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '   * `recipient`, forwarding all available gas and reverting on errors.\n', '   *\n', '   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '   * imposed by `transfer`, making them unable to receive funds via\n', '   * `transfer`. {sendValue} removes this limitation.\n', '   *\n', '   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '   *\n', '   * IMPORTANT: because control is transferred to `recipient`, care must be\n', '   * taken to not create reentrancy vulnerabilities. Consider using\n', '   * {ReentrancyGuard} or the\n', '   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '   */\n', '  function sendValue(address payable recipient, uint256 amount) internal {\n', '    require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '    // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '    (bool success, ) = recipient.call{ value: amount }("");\n', '    require(success, "Address: unable to send value, recipient may have reverted");\n', '  }\n', '\n', '  /**\n', '   * @dev Performs a Solidity function call using a low level `call`. A\n', '   * plain`call` is an unsafe replacement for a function call: use this\n', '   * function instead.\n', '   *\n', '   * If `target` reverts with a revert reason, it is bubbled up by this\n', '   * function (like regular Solidity function calls).\n', '   *\n', '   * Returns the raw returned data. To convert to the expected return value,\n', '   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - `target` must be a contract.\n', '   * - calling `target` with `data` must not revert.\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '    return functionCall(target, data, "Address: low-level call failed");\n', '  }\n', '\n', '  /**\n', '   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '   * `errorMessage` as a fallback revert reason when `target` reverts.\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '    return functionCallWithValue(target, data, 0, errorMessage);\n', '  }\n', '\n', '  /**\n', '   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '   * but also transferring `value` wei to `target`.\n', '   *\n', '   * Requirements:\n', '   *\n', '   * - the calling contract must have an ETH balance of at least `value`.\n', '   * - the called Solidity function must be `payable`.\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '    return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '  }\n', '\n', '  /**\n', '   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '   * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '   *\n', '   * _Available since v3.1._\n', '   */\n', '  function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '    require(address(this).balance >= value, "Address: insufficient balance for call");\n', '    require(isContract(target), "Address: call to non-contract");\n', '\n', '    // solhint-disable-next-line avoid-low-level-calls\n', '    (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '    return _verifyCallResult(success, returndata, errorMessage);\n', '  }\n', '\n', '  /**\n', '   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '   * but performing a static call.\n', '   *\n', '   * _Available since v3.3._\n', '   */\n', '  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '    return functionStaticCall(target, data, "Address: low-level static call failed");\n', '  }\n', '\n', '  /**\n', '   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '   * but performing a static call.\n', '   *\n', '   * _Available since v3.3._\n', '   */\n', '  function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '    require(isContract(target), "Address: static call to non-contract");\n', '\n', '    // solhint-disable-next-line avoid-low-level-calls\n', '    (bool success, bytes memory returndata) = target.staticcall(data);\n', '    return _verifyCallResult(success, returndata, errorMessage);\n', '  }\n', '\n', '  function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '    if (success) {\n', '      return returndata;\n', '    } else {\n', '      // Look for revert reason and bubble it up if present\n', '      if (returndata.length > 0) {\n', '        // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly {\n', '          let returndata_size := mload(returndata)\n', '          revert(add(32, returndata), returndata_size)\n', '        }\n', '      } else {\n', '        revert(errorMessage);\n', '      }\n', '    }\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/token/ERC20/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '  using SafeMath for uint256;\n', '  using Address for address;\n', '\n', '  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '  }\n', '\n', '  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n', '  }\n', '\n', '  /**\n', '   * @dev Deprecated. This function has issues similar to the ones found in\n', '   * {IERC20-approve}, and its usage is discouraged.\n', '   *\n', '   * Whenever possible, use {safeIncreaseAllowance} and\n', '   * {safeDecreaseAllowance} instead.\n', '   */\n', '  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n', '    // safeApprove should only be called when setting an initial allowance,\n', '    // or when resetting it to zero. To increase and decrease it, use\n', "    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '    // solhint-disable-next-line max-line-length\n', '    require((value == 0) || (token.allowance(address(this), spender) == 0),\n', '      "SafeERC20: approve from non-zero to non-zero allowance"\n', '    );\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '  }\n', '\n', '  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '    uint256 newAllowance = token.allowance(address(this), spender).add(value);\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '  }\n', '\n', '  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n', '    uint256 newAllowance = token.allowance(address(this), spender).sub(value, "SafeERC20: decreased allowance below zero");\n', '    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n', '  }\n', '\n', '  /**\n', '   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '   * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '   * @param token The token targeted by the call.\n', '   * @param data The call data (encoded using abi.encode or one of its variants).\n', '   */\n', '  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n", '    // the target address contains contract code and also asserts for success in the low-level call.\n', '\n', '    bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");\n', '    if (returndata.length > 0) { // Return data is optional\n', '      // solhint-disable-next-line max-line-length\n', '      require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '    }\n', '  }\n', '}\n', '\n', '// File: contracts/interfaces/WrappedPiErc20Interface.sol\n', '\n', 'interface WrappedPiErc20Interface is IERC20 {\n', '  function deposit(uint256 _amount) external payable returns (uint256);\n', '\n', '  function withdraw(uint256 _amount) external payable returns (uint256);\n', '\n', '  function changeRouter(address _newRouter) external;\n', '\n', '  function setEthFee(uint256 _newEthFee) external;\n', '\n', '  function withdrawEthFee(address payable receiver) external;\n', '\n', '  function approveUnderlying(address _to, uint256 _amount) external;\n', '\n', '  function callExternal(\n', '    address voting,\n', '    bytes4 signature,\n', '    bytes calldata args,\n', '    uint256 value\n', '  ) external;\n', '\n', '  struct ExternalCallData {\n', '    address destination;\n', '    bytes4 signature;\n', '    bytes args;\n', '    uint256 value;\n', '  }\n', '\n', '  function callExternalMultiple(ExternalCallData[] calldata calls) external;\n', '\n', '  function getUnderlyingBalance() external view returns (uint256);\n', '}\n', '\n', '// File: contracts/interfaces/IPoolRestrictions.sol\n', '\n', 'interface IPoolRestrictions {\n', '  function getMaxTotalSupply(address _pool) external view returns (uint256);\n', '\n', '  function isVotingSignatureAllowed(address _votingAddress, bytes4 _signature) external view returns (bool);\n', '\n', '  function isVotingSenderAllowed(address _votingAddress, address _sender) external view returns (bool);\n', '\n', '  function isWithoutFee(address _addr) external view returns (bool);\n', '}\n', '\n', '// File: contracts/interfaces/PowerIndexBasicRouterInterface.sol\n', '\n', '\n', 'interface PowerIndexBasicRouterInterface {\n', '  function setVotingAndStaking(address _voting, address _staking) external;\n', '\n', '  function setReserveConfig(uint256 _reserveRatio, uint256 _claimRewardsInterval) external;\n', '\n', '  function getPiEquivalentForUnderlying(\n', '    uint256 _underlyingAmount,\n', '    IERC20 _underlyingToken,\n', '    uint256 _piTotalSupply\n', '  ) external view returns (uint256);\n', '\n', '  function getPiEquivalentForUnderlyingPure(\n', '    uint256 _underlyingAmount,\n', '    uint256 _totalUnderlyingWrapped,\n', '    uint256 _piTotalSupply\n', '  ) external pure returns (uint256);\n', '\n', '  function getUnderlyingEquivalentForPi(\n', '    uint256 _piAmount,\n', '    IERC20 _underlyingToken,\n', '    uint256 _piTotalSupply\n', '  ) external view returns (uint256);\n', '\n', '  function getUnderlyingEquivalentForPiPure(\n', '    uint256 _piAmount,\n', '    uint256 _totalUnderlyingWrapped,\n', '    uint256 _piTotalSupply\n', '  ) external pure returns (uint256);\n', '}\n', '\n', '// File: contracts/interfaces/BMathInterface.sol\n', '\n', 'interface BMathInterface {\n', '  function calcInGivenOut(\n', '    uint256 tokenBalanceIn,\n', '    uint256 tokenWeightIn,\n', '    uint256 tokenBalanceOut,\n', '    uint256 tokenWeightOut,\n', '    uint256 tokenAmountOut,\n', '    uint256 swapFee\n', '  ) external pure returns (uint256 tokenAmountIn);\n', '\n', '  function calcSingleInGivenPoolOut(\n', '    uint256 tokenBalanceIn,\n', '    uint256 tokenWeightIn,\n', '    uint256 poolSupply,\n', '    uint256 totalWeight,\n', '    uint256 poolAmountOut,\n', '    uint256 swapFee\n', '  ) external pure returns (uint256 tokenAmountIn);\n', '}\n', '\n', '// File: contracts/interfaces/BPoolInterface.sol\n', '\n', 'interface BPoolInterface is IERC20, BMathInterface {\n', '  function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn) external;\n', '\n', '  function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut) external;\n', '\n', '  function swapExactAmountIn(\n', '    address,\n', '    uint256,\n', '    address,\n', '    uint256,\n', '    uint256\n', '  ) external returns (uint256, uint256);\n', '\n', '  function swapExactAmountOut(\n', '    address,\n', '    uint256,\n', '    address,\n', '    uint256,\n', '    uint256\n', '  ) external returns (uint256, uint256);\n', '\n', '  function joinswapExternAmountIn(\n', '    address,\n', '    uint256,\n', '    uint256\n', '  ) external returns (uint256);\n', '\n', '  function joinswapPoolAmountOut(\n', '    address,\n', '    uint256,\n', '    uint256\n', '  ) external returns (uint256);\n', '\n', '  function exitswapPoolAmountIn(\n', '    address,\n', '    uint256,\n', '    uint256\n', '  ) external returns (uint256);\n', '\n', '  function exitswapExternAmountOut(\n', '    address,\n', '    uint256,\n', '    uint256\n', '  ) external returns (uint256);\n', '\n', '  function getDenormalizedWeight(address) external view returns (uint256);\n', '\n', '  function getBalance(address) external view returns (uint256);\n', '\n', '  function getSwapFee() external view returns (uint256);\n', '\n', '  function getTotalDenormalizedWeight() external view returns (uint256);\n', '\n', '  function getCommunityFee()\n', '  external\n', '  view\n', '  returns (\n', '    uint256,\n', '    uint256,\n', '    uint256,\n', '    address\n', '  );\n', '\n', '  function calcAmountWithCommunityFee(\n', '    uint256,\n', '    uint256,\n', '    address\n', '  ) external view returns (uint256, uint256);\n', '\n', '  function getRestrictions() external view returns (address);\n', '\n', '  function isPublicSwap() external view returns (bool);\n', '\n', '  function isFinalized() external view returns (bool);\n', '\n', '  function isBound(address t) external view returns (bool);\n', '\n', '  function getCurrentTokens() external view returns (address[] memory tokens);\n', '\n', '  function getFinalTokens() external view returns (address[] memory tokens);\n', '\n', '  function setSwapFee(uint256) external;\n', '\n', '  function setCommunityFeeAndReceiver(\n', '    uint256,\n', '    uint256,\n', '    uint256,\n', '    address\n', '  ) external;\n', '\n', '  function setController(address) external;\n', '\n', '  function setPublicSwap(bool) external;\n', '\n', '  function finalize() external;\n', '\n', '  function bind(\n', '    address,\n', '    uint256,\n', '    uint256\n', '  ) external;\n', '\n', '  function rebind(\n', '    address,\n', '    uint256,\n', '    uint256\n', '  ) external;\n', '\n', '  function unbind(address) external;\n', '\n', '  function gulp(address) external;\n', '\n', '  function callVoting(\n', '    address voting,\n', '    bytes4 signature,\n', '    bytes calldata args,\n', '    uint256 value\n', '  ) external;\n', '\n', '  function getMinWeight() external view returns (uint256);\n', '\n', '  function getMaxBoundTokens() external view returns (uint256);\n', '}\n', '\n', '// File: @openzeppelin/contracts/GSN/Context.sol\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with GSN meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract Context {\n', '  function _msgSender() internal view virtual returns (address payable) {\n', '    return msg.sender;\n', '  }\n', '\n', '  function _msgData() internal view virtual returns (bytes memory) {\n', '    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '    return msg.data;\n', '  }\n', '}\n', '\n', '// File: @openzeppelin/contracts/access/Ownable.sol\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract Ownable is Context {\n', '  address private _owner;\n', '\n', '  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '  /**\n', '   * @dev Initializes the contract setting the deployer as the initial owner.\n', '   */\n', '  constructor () internal {\n', '    address msgSender = _msgSender();\n', '    _owner = msgSender;\n', '    emit OwnershipTransferred(address(0), msgSender);\n', '  }\n', '\n', '  /**\n', '   * @dev Returns the address of the current owner.\n', '   */\n', '  function owner() public view returns (address) {\n', '    return _owner;\n', '  }\n', '\n', '  /**\n', '   * @dev Throws if called by any account other than the owner.\n', '   */\n', '  modifier onlyOwner() {\n', '    require(_owner == _msgSender(), "Ownable: caller is not the owner");\n', '    _;\n', '  }\n', '\n', '  /**\n', '   * @dev Leaves the contract without owner. It will not be possible to call\n', '   * `onlyOwner` functions anymore. Can only be called by the current owner.\n', '   *\n', '   * NOTE: Renouncing ownership will leave the contract without an owner,\n', '   * thereby removing any functionality that is only available to the owner.\n', '   */\n', '  function renounceOwnership() public virtual onlyOwner {\n', '    emit OwnershipTransferred(_owner, address(0));\n', '    _owner = address(0);\n', '  }\n', '\n', '  /**\n', '   * @dev Transfers ownership of the contract to a new account (`newOwner`).\n', '   * Can only be called by the current owner.\n', '   */\n', '  function transferOwnership(address newOwner) public virtual onlyOwner {\n', '    require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '    emit OwnershipTransferred(_owner, newOwner);\n', '    _owner = newOwner;\n', '  }\n', '}\n', '\n', '// File: contracts/interfaces/PowerIndexNaiveRouterInterface.sol\n', '\n', 'interface PowerIndexNaiveRouterInterface {\n', '  function migrateToNewRouter(\n', '    address _piToken,\n', '    address payable _newRouter,\n', '    address[] memory _tokens\n', '  ) external;\n', '\n', '  function piTokenCallback(address sender, uint256 _withdrawAmount) external payable;\n', '}\n', '\n', '// File: contracts/powerindex-router/PowerIndexNaiveRouter.sol\n', '\n', 'contract PowerIndexNaiveRouter is PowerIndexNaiveRouterInterface, Ownable {\n', '  using SafeMath for uint256;\n', '\n', '  function migrateToNewRouter(\n', '    address _piToken,\n', '    address payable _newRouter,\n', '    address[] memory _tokens\n', '  ) public virtual override onlyOwner {\n', '    WrappedPiErc20Interface(_piToken).changeRouter(_newRouter);\n', '  }\n', '\n', '  function piTokenCallback(address sender, uint256 _withdrawAmount) external payable virtual override {\n', '    // DO NOTHING\n', '  }\n', '}\n', '\n', '// File: contracts/powerindex-router/PowerIndexBasicRouter.sol\n', '\n', 'contract PowerIndexBasicRouter is PowerIndexBasicRouterInterface, PowerIndexNaiveRouter {\n', '  using SafeERC20 for IERC20;\n', '\n', '  uint256 public constant HUNDRED_PCT = 1 ether;\n', '\n', '  event SetVotingAndStaking(address indexed voting, address indexed staking);\n', '  event SetReserveConfig(uint256 ratio, uint256 claimRewardsInterval);\n', '  event SetRebalancingInterval(uint256 rebalancingInterval);\n', '  event IgnoreRebalancing(uint256 blockTimestamp, uint256 lastRebalancedAt, uint256 rebalancingInterval);\n', '  event RewardPool(address indexed pool, uint256 amount);\n', '  event SetRewardPools(uint256 len, address[] rewardPools);\n', '  event SetPvpFee(uint256 pvpFee);\n', '\n', '  enum ReserveStatus { EQUILIBRIUM, SHORTAGE, EXCESS }\n', '\n', '  struct BasicConfig {\n', '    address poolRestrictions;\n', '    address powerPoke;\n', '    address voting;\n', '    address staking;\n', '    uint256 reserveRatio;\n', '    uint256 reserveRatioToForceRebalance;\n', '    uint256 claimRewardsInterval;\n', '    address pvp;\n', '    uint256 pvpFee;\n', '    address[] rewardPools;\n', '  }\n', '\n', '  WrappedPiErc20Interface public immutable piToken;\n', '  address public immutable pvp;\n', '\n', '  IPoolRestrictions public poolRestrictions;\n', '  IPowerPoke public powerPoke;\n', '  address public voting;\n', '  address public staking;\n', '  uint256 public reserveRatio;\n', '  uint256 public claimRewardsInterval;\n', '  uint256 public lastClaimRewardsAt;\n', '  uint256 public lastRebalancedAt;\n', '  uint256 public reserveRatioToForceRebalance;\n', '  // 1 ether == 100%\n', '  uint256 public pvpFee;\n', '\n', '  address[] internal rewardPools;\n', '\n', '  uint256 internal constant COMPENSATION_PLAN_1_ID = 1;\n', '\n', '  modifier onlyPiToken() {\n', '    require(msg.sender == address(piToken), "ONLY_PI_TOKEN_ALLOWED");\n', '    _;\n', '  }\n', '\n', '  modifier onlyEOA() {\n', '    require(tx.origin == msg.sender, "ONLY_EOA");\n', '    _;\n', '  }\n', '\n', '  modifier onlyReporter(uint256 _reporterId, bytes calldata _rewardOpts) {\n', '    uint256 gasStart = gasleft();\n', '    powerPoke.authorizeReporter(_reporterId, msg.sender);\n', '    _;\n', '    _reward(_reporterId, gasStart, COMPENSATION_PLAN_1_ID, _rewardOpts);\n', '  }\n', '\n', '  modifier onlyNonReporter(uint256 _reporterId, bytes calldata _rewardOpts) {\n', '    uint256 gasStart = gasleft();\n', '    powerPoke.authorizeNonReporter(_reporterId, msg.sender);\n', '    _;\n', '    _reward(_reporterId, gasStart, COMPENSATION_PLAN_1_ID, _rewardOpts);\n', '  }\n', '\n', '  constructor(address _piToken, BasicConfig memory _basicConfig) public PowerIndexNaiveRouter() Ownable() {\n', '    require(_piToken != address(0), "INVALID_PI_TOKEN");\n', '    require(_basicConfig.reserveRatio <= HUNDRED_PCT, "RR_GT_HUNDRED_PCT");\n', '    require(_basicConfig.pvpFee < HUNDRED_PCT, "PVP_FEE_GTE_HUNDRED_PCT");\n', '    require(_basicConfig.pvp != address(0), "INVALID_PVP_ADDR");\n', '    require(_basicConfig.poolRestrictions != address(0), "INVALID_POOL_RESTRICTIONS_ADDR");\n', '\n', '    piToken = WrappedPiErc20Interface(_piToken);\n', '    poolRestrictions = IPoolRestrictions(_basicConfig.poolRestrictions);\n', '    powerPoke = IPowerPoke(_basicConfig.powerPoke);\n', '    voting = _basicConfig.voting;\n', '    staking = _basicConfig.staking;\n', '    reserveRatio = _basicConfig.reserveRatio;\n', '    reserveRatioToForceRebalance = _basicConfig.reserveRatioToForceRebalance;\n', '    claimRewardsInterval = _basicConfig.claimRewardsInterval;\n', '    pvp = _basicConfig.pvp;\n', '    pvpFee = _basicConfig.pvpFee;\n', '    rewardPools = _basicConfig.rewardPools;\n', '  }\n', '\n', '  receive() external payable {}\n', '\n', '  /*** OWNER METHODS ***/\n', '\n', '  /**\n', '   * @dev Changing the staking address with a positive underlying stake will break `getPiEquivalentForUnderlying`\n', '   *      formula. Consider moving all the reserves to the piToken contract before doing this.\n', '   */\n', '  function setVotingAndStaking(address _voting, address _staking) external override onlyOwner {\n', '    voting = _voting;\n', '    staking = _staking;\n', '    emit SetVotingAndStaking(_voting, _staking);\n', '  }\n', '\n', '  function setReserveConfig(uint256 _reserveRatio, uint256 _claimRewardsInterval) public virtual override onlyOwner {\n', '    require(_reserveRatio <= HUNDRED_PCT, "RR_GREATER_THAN_100_PCT");\n', '    reserveRatio = _reserveRatio;\n', '    claimRewardsInterval = _claimRewardsInterval;\n', '    emit SetReserveConfig(_reserveRatio, _claimRewardsInterval);\n', '  }\n', '\n', '  function setRewardPools(address[] calldata _rewardPools) external onlyOwner {\n', '    require(_rewardPools.length > 0, "AT_LEAST_ONE_EXPECTED");\n', '    rewardPools = _rewardPools;\n', '    emit SetRewardPools(_rewardPools.length, _rewardPools);\n', '  }\n', '\n', '  function setPvpFee(uint256 _pvpFee) external onlyOwner {\n', '    require(_pvpFee < HUNDRED_PCT, "PVP_FEE_OVER_THE_LIMIT");\n', '    pvpFee = _pvpFee;\n', '    emit SetPvpFee(_pvpFee);\n', '  }\n', '\n', '  function setPiTokenEthFee(uint256 _ethFee) external onlyOwner {\n', '    require(_ethFee <= 0.1 ether, "ETH_FEE_OVER_THE_LIMIT");\n', '    piToken.setEthFee(_ethFee);\n', '  }\n', '\n', '  function withdrawEthFee(address payable _receiver) external onlyOwner {\n', '    piToken.withdrawEthFee(_receiver);\n', '  }\n', '\n', '  function migrateToNewRouter(\n', '    address _piToken,\n', '    address payable _newRouter,\n', '    address[] memory _tokens\n', '  ) public override onlyOwner {\n', '    super.migrateToNewRouter(_piToken, _newRouter, _tokens);\n', '\n', '    _newRouter.transfer(address(this).balance);\n', '\n', '    uint256 len = _tokens.length;\n', '    for (uint256 i = 0; i < len; i++) {\n', '      IERC20 t = IERC20(_tokens[i]);\n', '      t.safeTransfer(_newRouter, t.balanceOf(address(this)));\n', '    }\n', '  }\n', '\n', '  function pokeFromReporter(\n', '    uint256 _reporterId,\n', '    bool _claimAndDistributeRewards,\n', '    bytes calldata _rewardOpts\n', '  ) external onlyReporter(_reporterId, _rewardOpts) onlyEOA {\n', '    (uint256 minInterval, ) = _getMinMaxReportInterval();\n', '    (ReserveStatus status, uint256 diff, bool forceRebalance) = getReserveStatus(_getUnderlyingStaked(), 0);\n', '    require(forceRebalance || lastRebalancedAt + minInterval < block.timestamp, "MIN_INTERVAL_NOT_REACHED");\n', '    require(status != ReserveStatus.EQUILIBRIUM, "RESERVE_STATUS_EQUILIBRIUM");\n', '    _rebalancePoke(status, diff);\n', '    _postPoke(_claimAndDistributeRewards);\n', '  }\n', '\n', '  function pokeFromSlasher(\n', '    uint256 _reporterId,\n', '    bool _claimAndDistributeRewards,\n', '    bytes calldata _rewardOpts\n', '  ) external onlyNonReporter(_reporterId, _rewardOpts) onlyEOA {\n', '    (, uint256 maxInterval) = _getMinMaxReportInterval();\n', '    (ReserveStatus status, uint256 diff, bool forceRebalance) = getReserveStatus(_getUnderlyingStaked(), 0);\n', '    require(forceRebalance || lastRebalancedAt + maxInterval < block.timestamp, "MAX_INTERVAL_NOT_REACHED");\n', '    require(status != ReserveStatus.EQUILIBRIUM, "RESERVE_STATUS_EQUILIBRIUM");\n', '    _rebalancePoke(status, diff);\n', '    _postPoke(_claimAndDistributeRewards);\n', '  }\n', '\n', '  function poke(bool _claimAndDistributeRewards) external onlyEOA {\n', '    (ReserveStatus status, uint256 diff, ) = getReserveStatus(_getUnderlyingStaked(), 0);\n', '    _rebalancePoke(status, diff);\n', '    _postPoke(_claimAndDistributeRewards);\n', '  }\n', '\n', '  function _postPoke(bool _claimAndDistributeRewards) internal {\n', '    lastRebalancedAt = block.timestamp;\n', '\n', '    if (_claimAndDistributeRewards && lastClaimRewardsAt + claimRewardsInterval < block.timestamp) {\n', '      _claimRewards();\n', '      _distributeRewards();\n', '      lastClaimRewardsAt = block.timestamp;\n', '    }\n', '  }\n', '\n', '  function _rebalancePoke(ReserveStatus reserveStatus, uint256 sushiDiff) internal virtual {\n', '    // need to redefine in implementation\n', '  }\n', '\n', '  function _claimRewards() internal virtual {\n', '    // need to redefine in implementation\n', '  }\n', '\n', '  function _distributeRewards() internal virtual {\n', '    // need to redefine in implementation\n', '  }\n', '\n', '  function _callVoting(bytes4 _sig, bytes memory _data) internal {\n', '    piToken.callExternal(voting, _sig, _data, 0);\n', '  }\n', '\n', '  function _callStaking(bytes4 _sig, bytes memory _data) internal {\n', '    piToken.callExternal(staking, _sig, _data, 0);\n', '  }\n', '\n', '  function _checkVotingSenderAllowed() internal view {\n', '    require(poolRestrictions.isVotingSenderAllowed(voting, msg.sender), "SENDER_NOT_ALLOWED");\n', '  }\n', '\n', '  function _distributeRewardToPvp(uint256 _totalReward, IERC20 _underlying)\n', '  internal\n', '  returns (uint256 pvpReward, uint256 remainder)\n', '  {\n', '    pvpReward = 0;\n', '    remainder = 0;\n', '\n', '    if (pvpFee > 0) {\n', '      pvpReward = _totalReward.mul(pvpFee).div(HUNDRED_PCT);\n', '      remainder = _totalReward.sub(pvpReward);\n', '      _underlying.safeTransfer(pvp, pvpReward);\n', '    } else {\n', '      remainder = _totalReward;\n', '    }\n', '  }\n', '\n', '  function _distributePiRemainderToPools(IERC20 _piToken)\n', '  internal\n', '  returns (uint256 piBalanceToDistribute, address[] memory pools)\n', '  {\n', '    pools = rewardPools;\n', '    uint256 poolsLen = pools.length;\n', '    require(poolsLen > 0, "MISSING_REWARD_POOLS");\n', '\n', '    piBalanceToDistribute = piToken.balanceOf(address(this));\n', '    require(piBalanceToDistribute > 0, "NO_POOL_REWARDS_PI");\n', '\n', '    uint256 totalPiOnPools = 0;\n', '    for (uint256 i = 0; i < poolsLen; i++) {\n', '      totalPiOnPools = totalPiOnPools.add(_piToken.balanceOf(pools[i]));\n', '    }\n', '    require(totalPiOnPools > 0, "TOTAL_PI_IS_0");\n', '\n', '    for (uint256 i = 0; i < poolsLen; i++) {\n', '      address pool = pools[i];\n', '      uint256 poolPiBalance = piToken.balanceOf(pool);\n', '      if (poolPiBalance == 0) {\n', '        continue;\n', '      }\n', '\n', '      uint256 poolReward = piBalanceToDistribute.mul(poolPiBalance) / totalPiOnPools;\n', '\n', '      piToken.transfer(pool, poolReward);\n', '\n', '      BPoolInterface(pool).gulp(address(piToken));\n', '      emit RewardPool(pool, poolReward);\n', '    }\n', '  }\n', '\n', '  /*\n', '   * @dev Getting status and diff of actual staked balance and target reserve balance.\n', '   */\n', '  function getReserveStatusForStakedBalance()\n', '  public\n', '  view\n', '  returns (\n', '    ReserveStatus status,\n', '    uint256 diff,\n', '    bool forceRebalance\n', '  )\n', '  {\n', '    return getReserveStatus(_getUnderlyingStaked(), 0);\n', '  }\n', '\n', '  /*\n', '   * @dev Getting status and diff of provided staked balance and target reserve balance.\n', '   */\n', '  function getReserveStatus(uint256 _stakedBalance, uint256 _withdrawAmount)\n', '  public\n', '  view\n', '  returns (\n', '    ReserveStatus status,\n', '    uint256 diff,\n', '    bool forceRebalance\n', '  )\n', '  {\n', '    uint256 expectedReserveAmount;\n', '    (status, diff, expectedReserveAmount) = getReserveStatusPure(\n', '      reserveRatio,\n', '      piToken.getUnderlyingBalance(),\n', '      _stakedBalance,\n', '      _withdrawAmount\n', '    );\n', '\n', '    if (status == ReserveStatus.SHORTAGE) {\n', '      uint256 currentRatio = expectedReserveAmount.sub(diff).mul(HUNDRED_PCT).div(expectedReserveAmount);\n', '      forceRebalance = reserveRatioToForceRebalance >= currentRatio;\n', '    }\n', '  }\n', '\n', '  // NOTICE: could/should be changed depending on implementation\n', '  function _getUnderlyingStaked() internal view virtual returns (uint256) {\n', '    if (staking == address(0)) {\n', '      return 0;\n', '    }\n', '    return IERC20(staking).balanceOf(address(piToken));\n', '  }\n', '\n', '  function getUnderlyingStaked() external view returns (uint256) {\n', '    return _getUnderlyingStaked();\n', '  }\n', '\n', '  function getRewardPools() external view returns (address[] memory) {\n', '    return rewardPools;\n', '  }\n', '\n', '  function getPiEquivalentForUnderlying(\n', '    uint256 _underlyingAmount,\n', '    IERC20 _underlyingToken,\n', '    uint256 _piTotalSupply\n', '  ) public view virtual override returns (uint256) {\n', '    uint256 underlyingOnPiToken = _underlyingToken.balanceOf(address(piToken));\n', '    return\n', '    getPiEquivalentForUnderlyingPure(\n', '      _underlyingAmount,\n', '    // underlyingOnPiToken + underlyingOnStaking,\n', '      underlyingOnPiToken.add(_getUnderlyingStaked()),\n', '      _piTotalSupply\n', '    );\n', '  }\n', '\n', '  function getPiEquivalentForUnderlyingPure(\n', '    uint256 _underlyingAmount,\n', '    uint256 _totalUnderlyingWrapped,\n', '    uint256 _piTotalSupply\n', '  ) public pure virtual override returns (uint256) {\n', '    if (_piTotalSupply == 0) {\n', '      return _underlyingAmount;\n', '    }\n', '    // return _piTotalSupply * _underlyingAmount / _totalUnderlyingWrapped;\n', '    return _piTotalSupply.mul(_underlyingAmount).div(_totalUnderlyingWrapped);\n', '  }\n', '\n', '  function getUnderlyingEquivalentForPi(\n', '    uint256 _piAmount,\n', '    IERC20 _underlyingToken,\n', '    uint256 _piTotalSupply\n', '  ) public view virtual override returns (uint256) {\n', '    uint256 underlyingOnPiToken = _underlyingToken.balanceOf(address(piToken));\n', '    return\n', '    getUnderlyingEquivalentForPiPure(\n', '      _piAmount,\n', '    // underlyingOnPiToken + underlyingOnStaking,\n', '      underlyingOnPiToken.add(_getUnderlyingStaked()),\n', '      _piTotalSupply\n', '    );\n', '  }\n', '\n', '  function getUnderlyingEquivalentForPiPure(\n', '    uint256 _piAmount,\n', '    uint256 _totalUnderlyingWrapped,\n', '    uint256 _piTotalSupply\n', '  ) public pure virtual override returns (uint256) {\n', '    if (_piTotalSupply == 0) {\n', '      return _piAmount;\n', '    }\n', '    // _piAmount * _totalUnderlyingWrapped / _piTotalSupply;\n', '    return _totalUnderlyingWrapped.mul(_piAmount).div(_piTotalSupply);\n', '  }\n', '\n', '  /**\n', '   * @notice Calculates the desired reserve status\n', '   * @param _reserveRatioPct The reserve ratio in %, 1 ether == 100 ether\n', '   * @param _leftOnPiToken The amount of origin tokens left on the piToken (WrappedPiErc20) contract\n', '   * @param _stakedBalance The amount of original tokens staked on the staking contract\n', '   * @param _withdrawAmount The amount to be withdrawn within the current transaction\n', '   *                        (could be negative in a case of deposit)\n', '   * @return status The reserve status:\n', '   * * SHORTAGE - There is not enough underlying funds on the wrapper contract to satisfy the reserve ratio,\n', '   *           the diff amount should be redeemed from the staking contract\n', '   * * EXCESS - there are some extra funds over reserve ratio on the wrapper contract,\n', '   *           the diff amount should be sent to the staking contract\n', "   * * EQUILIBRIUM - the reserve ratio hasn't changed,\n", '   *           the diff amount is 0 and there are no additional stake/redeem actions expected\n', '   * @return diff The difference between `adjustedReserveAmount` and `_leftOnWrapper`\n', '   * @return expectedReserveAmount The calculated expected reserve amount\n', '   */\n', '  function getReserveStatusPure(\n', '    uint256 _reserveRatioPct,\n', '    uint256 _leftOnPiToken,\n', '    uint256 _stakedBalance,\n', '    uint256 _withdrawAmount\n', '  )\n', '  public\n', '  pure\n', '  returns (\n', '    ReserveStatus status,\n', '    uint256 diff,\n', '    uint256 expectedReserveAmount\n', '  )\n', '  {\n', '    require(_reserveRatioPct <= HUNDRED_PCT, "RR_GREATER_THAN_100_PCT");\n', '    expectedReserveAmount = getExpectedReserveAmount(_reserveRatioPct, _leftOnPiToken, _stakedBalance, _withdrawAmount);\n', '\n', '    if (expectedReserveAmount > _leftOnPiToken) {\n', '      status = ReserveStatus.SHORTAGE;\n', '      diff = expectedReserveAmount.sub(_leftOnPiToken);\n', '    } else if (expectedReserveAmount < _leftOnPiToken) {\n', '      status = ReserveStatus.EXCESS;\n', '      diff = _leftOnPiToken.sub(expectedReserveAmount);\n', '    } else {\n', '      status = ReserveStatus.EQUILIBRIUM;\n', '      diff = 0;\n', '    }\n', '  }\n', '\n', '  /**\n', '   * @notice Calculates an expected reserve amount after the transaction taking into an account the withdrawAmount\n', '   * @param _reserveRatioPct % of a reserve ratio, 1 ether == 100%\n', '   * @param _leftOnPiToken The amount of origin tokens left on the piToken (WrappedPiErc20) contract\n', '   * @param _stakedBalance The amount of original tokens staked on the staking contract\n', '   * @param _withdrawAmount The amount to be withdrawn within the current transaction\n', '   *                        (could be negative in a case of deposit)\n', '   * @return expectedReserveAmount The expected reserve amount\n', '   *\n', '   *                           / %reserveRatio * (staked + _leftOnPiToken - withdrawAmount) \\\n', '   * expectedReserveAmount =  | ------------------------------------------------------------| + withdrawAmount\n', '   *                           \\                         100%                              /\n', '   */\n', '  function getExpectedReserveAmount(\n', '    uint256 _reserveRatioPct,\n', '    uint256 _leftOnPiToken,\n', '    uint256 _stakedBalance,\n', '    uint256 _withdrawAmount\n', '  ) public pure returns (uint256) {\n', '    return\n', '    _reserveRatioPct.mul(_stakedBalance.add(_leftOnPiToken).sub(_withdrawAmount)).div(HUNDRED_PCT).add(\n', '      _withdrawAmount\n', '    );\n', '  }\n', '\n', '  function _reward(\n', '    uint256 _reporterId,\n', '    uint256 _gasStart,\n', '    uint256 _compensationPlan,\n', '    bytes calldata _rewardOpts\n', '  ) internal {\n', '    powerPoke.reward(_reporterId, _gasStart.sub(gasleft()), _compensationPlan, _rewardOpts);\n', '  }\n', '\n', '  function _getMinMaxReportInterval() internal view returns (uint256 min, uint256 max) {\n', '    return powerPoke.getMinMaxReportIntervals(address(this));\n', '  }\n', '}\n', '\n', '// File: contracts/powerindex-router/implementations/SushiPowerIndexRouter.sol\n', '\n', 'contract SushiPowerIndexRouter is PowerIndexBasicRouter {\n', '  event Stake(address indexed sender, uint256 amount);\n', '  event Redeem(address indexed sender, uint256 amount);\n', '  event IgnoreDueMissingStaking();\n', '  event ClaimRewards(\n', '    address indexed sender,\n', '    uint256 xSushiBurned,\n', '    uint256 expectedSushiReward,\n', '    uint256 releasedSushiReward\n', '  );\n', '  event DistributeRewards(\n', '    address indexed sender,\n', '    uint256 sushiReward,\n', '    uint256 pvpReward,\n', '    uint256 poolRewardsUnderlying,\n', '    uint256 poolRewardsPi,\n', '    address[] pools\n', '  );\n', '\n', '  struct SushiConfig {\n', '    address SUSHI;\n', '  }\n', '\n', '  IERC20 internal immutable SUSHI;\n', '\n', '  constructor(\n', '    address _piToken,\n', '    BasicConfig memory _basicConfig,\n', '    SushiConfig memory _sushiConfig\n', '  ) public PowerIndexBasicRouter(_piToken, _basicConfig) {\n', '    SUSHI = IERC20(_sushiConfig.SUSHI);\n', '  }\n', '\n', '  /*** PERMISSIONLESS REWARD CLAIMING AND DISTRIBUTION ***/\n', '\n', '  /**\n', '   * @notice Withdraws the extra staked SUSHI as a reward and transfers it to the router\n', '   */\n', '  function _claimRewards() internal override {\n', '    uint256 rewardsPending = getPendingRewards();\n', '    require(rewardsPending > 0, "NOTHING_TO_CLAIM");\n', '\n', '    uint256 sushiBefore = SUSHI.balanceOf(address(piToken));\n', '    uint256 xSushiToBurn = getXSushiForSushi(rewardsPending);\n', '\n', '    // Step #1. Claim the excess of SUSHI from SushiBar\n', '    _callStaking(ISushiBar.leave.selector, abi.encode(xSushiToBurn));\n', '    uint256 released = SUSHI.balanceOf(address(piToken)).sub(sushiBefore);\n', '    require(released > 0, "NOTHING_RELEASED");\n', '\n', '    // Step #2. Transfer the claimed SUSHI to the router\n', '    piToken.callExternal(address(SUSHI), SUSHI.transfer.selector, abi.encode(address(this), released), 0);\n', '\n', '    emit ClaimRewards(msg.sender, xSushiToBurn, rewardsPending, released);\n', '  }\n', '\n', '  /**\n', "   * @notice Wraps the router's SUSHIs into piTokens and transfers it to the pools proportionally their SUSHI balances\n", '   */\n', '  function _distributeRewards() internal override {\n', '    uint256 pendingReward = SUSHI.balanceOf(address(this));\n', '    require(pendingReward > 0, "NO_PENDING_REWARD");\n', '\n', '    // Step #1. Distribute pvpReward\n', '    (uint256 pvpReward, uint256 poolRewardsUnderlying) = _distributeRewardToPvp(pendingReward, SUSHI);\n', '    require(poolRewardsUnderlying > 0, "NO_POOL_REWARDS_UNDERLYING");\n', '\n', '    // Step #2. Wrap SUSHI into piSUSHI\n', '    SUSHI.approve(address(piToken), poolRewardsUnderlying);\n', '    piToken.deposit(poolRewardsUnderlying);\n', '\n', '    // Step #3. Distribute piSUSHI over the pools\n', '    (uint256 poolRewardsPi, address[] memory pools) = _distributePiRemainderToPools(piToken);\n', '\n', '    emit DistributeRewards(msg.sender, pendingReward, pvpReward, poolRewardsUnderlying, poolRewardsPi, pools);\n', '  }\n', '\n', '  /*** VIEWERS ***/\n', '\n', '  /**\n', '   * @notice Get the amount of xSUSHI tokens SushiBar will mint in exchange of the given SUSHI tokens\n', '   * @param _sushi The input amount of SUSHI tokens\n', '   * @return The corresponding amount of xSUSHI tokens\n', '   */\n', '  function getXSushiForSushi(uint256 _sushi) public view returns (uint256) {\n', '    return _sushi.mul(IERC20(staking).totalSupply()) / SUSHI.balanceOf(staking);\n', '  }\n', '\n', '  /**\n', '   * @notice Get the amount of SUSHI tokens SushiBar will release in exchange of the given xSUSHI tokens\n', '   * @param _xSushi The input amount of xSUSHI tokens\n', '   * @return The corresponding amount of SUSHI tokens\n', '   */\n', '  function getSushiForXSushi(uint256 _xSushi) public view returns (uint256) {\n', '    return _xSushi.mul(SUSHI.balanceOf(staking)) / IERC20(staking).totalSupply();\n', '  }\n', '\n', '  /**\n', "   * @notice Get the total amount of SUSHI tokens could be released in exchange of the piToken's xSUSHI balance.\n", '   *         Is comprised of the underlyingStaked and the pendingRewards.\n', '   * @return The SUSHI amount\n', '   */\n', '  function getUnderlyingBackedByXSushi() public view returns (uint256) {\n', '    if (staking == address(0)) {\n', '      return 0;\n', '    }\n', '\n', '    uint256 xSushiAtPiToken = IERC20(staking).balanceOf(address(piToken));\n', '    if (xSushiAtPiToken == 0) {\n', '      return 0;\n', '    }\n', '\n', '    return getSushiForXSushi(xSushiAtPiToken);\n', '  }\n', '\n', '  /**\n', '   * @notice Get the amount of current pending rewards available at SushiBar\n', '   * @return amount of pending rewards\n', '   */\n', '  function getPendingRewards() public view returns (uint256 amount) {\n', '    // return sushiAtPiToken + sushiBackedByXSushi - piToken.totalSupply()\n', '    amount = SUSHI.balanceOf(address(piToken)).add(getUnderlyingBackedByXSushi()).add(1).sub(piToken.totalSupply());\n', '    return amount == 1 ? 0 : amount;\n', '  }\n', '\n', '  /*** EQUIVALENT METHODS OVERRIDES ***/\n', '\n', '  function getPiEquivalentForUnderlying(\n', '    uint256 _underlyingAmount,\n', '    IERC20, /* _underlyingToken */\n', '    uint256 /* _piTotalSupply */\n', '  ) public view override returns (uint256) {\n', '    return _underlyingAmount;\n', '  }\n', '\n', '  function getPiEquivalentForUnderlyingPure(\n', '    uint256 _underlyingAmount,\n', '    uint256, /* _totalUnderlyingWrapped */\n', '    uint256 /* _piTotalSupply */\n', '  ) public pure override returns (uint256) {\n', '    return _underlyingAmount;\n', '  }\n', '\n', '  function getUnderlyingEquivalentForPi(\n', '    uint256 _piAmount,\n', '    IERC20, /* _underlyingToken */\n', '    uint256 /* _piTotalSupply */\n', '  ) public view override returns (uint256) {\n', '    return _piAmount;\n', '  }\n', '\n', '  function getUnderlyingEquivalentForPiPure(\n', '    uint256 _piAmount,\n', '    uint256, /* _totalUnderlyingWrapped */\n', '    uint256 /* _piTotalSupply */\n', '  ) public pure override returns (uint256) {\n', '    return _piAmount;\n', '  }\n', '\n', '  /*** OWNER METHODS ***/\n', '\n', '  /**\n', '   * @notice The contract owner manually stakes the given amount of SUSHI\n', '   * @param _sushi The amount SUSHI to stake\n', '   */\n', '  function stake(uint256 _sushi) external onlyOwner {\n', '    _stake(_sushi);\n', '  }\n', '\n', '  /**\n', '   * @notice The contract owner manually burns the given amount of xSUSHI in exchange of SUSHI tokens\n', '   * @param _xSushi The amount xSUSHI to burn\n', '   */\n', '  function redeem(uint256 _xSushi) external onlyOwner {\n', '    _redeem(_xSushi);\n', '  }\n', '\n', '  /*** POKE FUNCTION ***/\n', '\n', '  function _rebalancePoke(ReserveStatus reserveStatus, uint256 sushiDiff) internal override {\n', '    require(staking != address(0), "STACKING_IS_NULL");\n', '\n', '    if (reserveStatus == ReserveStatus.SHORTAGE) {\n', '      _redeem(getXSushiForSushi(sushiDiff));\n', '    } else if (reserveStatus == ReserveStatus.EXCESS) {\n', '      _stake(sushiDiff);\n', '    }\n', '  }\n', '\n', '  /*** INTERNALS ***/\n', '\n', '  /**\n', '   * @notice Get the opposite to the reserve ratio amount of SUSHI staked at SushiBar\n', '   * @return The SUSHI amount\n', '   */\n', '  function _getUnderlyingStaked() internal view override returns (uint256) {\n', '    // return piTokenTotalSupply - sushiAtPiToken\n', '    return piToken.totalSupply().sub(SUSHI.balanceOf(address(piToken)));\n', '  }\n', '\n', '  function _stake(uint256 _sushi) internal {\n', '    require(_sushi > 0, "CANT_STAKE_0");\n', '\n', '    piToken.approveUnderlying(staking, _sushi);\n', '    _callStaking(ISushiBar(0).enter.selector, abi.encode(_sushi));\n', '\n', '    emit Stake(msg.sender, _sushi);\n', '  }\n', '\n', '  function _redeem(uint256 _xSushi) internal {\n', '    require(_xSushi > 0, "CANT_REDEEM_0");\n', '\n', '    _callStaking(ISushiBar(0).leave.selector, abi.encode(_xSushi));\n', '\n', '    emit Redeem(msg.sender, _xSushi);\n', '  }\n', '}\n', '\n', '// File: contracts/powerindex-router/implementations/factories/SushiPowerIndexRouterFactory.sol\n', '\n', 'contract SushiPowerIndexRouterFactory is IPiRouterFactory {\n', '  event BuildSushiRouter(address indexed builder, address indexed piToken, address indexed router);\n', '\n', '  function buildRouter(address _piToken, bytes calldata _args) external override returns (address) {\n', '    (PowerIndexBasicRouter.BasicConfig memory _basicConfig, SushiPowerIndexRouter.SushiConfig memory _sushiConfig) =\n', '    abi.decode(_args, (PowerIndexBasicRouter.BasicConfig, SushiPowerIndexRouter.SushiConfig));\n', '\n', '    address router = address(new SushiPowerIndexRouter(_piToken, _basicConfig, _sushiConfig));\n', '\n', '    emit BuildSushiRouter(msg.sender, _piToken, router);\n', '\n', '    Ownable(router).transferOwnership(msg.sender);\n', '\n', '    return router;\n', '  }\n', '}']