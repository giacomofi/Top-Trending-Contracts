['/**\n', ' *Submitted for verification at Etherscan.io on 2021-06-18\n', '*/\n', '\n', '// Sources flattened with hardhat v2.3.0 https://hardhat.org\n', '// SPDX-License-Identifier: MIT\n', '// File contracts/IBeacon.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is the interface that {BeaconProxy} expects of its beacon.\n', ' */\n', 'interface IBeacon {\n', '    /**\n', '     * @dev Must return an address that can be used as a delegate call target.\n', '     *\n', '     * {BeaconProxy} will check that this address is a contract.\n', '     */\n', '    function implementation() external view returns (address);\n', '}\n', '\n', '\n', '// File contracts/Address.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Collection of functions related to the address type\n', ' */\n', 'library Address {\n', '    /**\n', '     * @dev Returns true if `account` is a contract.\n', '     *\n', '     * [IMPORTANT]\n', '     * ====\n', '     * It is unsafe to assume that an address for which this function returns\n', '     * false is an externally-owned account (EOA) and not a contract.\n', '     *\n', '     * Among others, `isContract` will return false for the following\n', '     * types of addresses:\n', '     *\n', '     *  - an externally-owned account\n', '     *  - a contract in construction\n', '     *  - an address where a contract will be created\n', '     *  - an address where a contract lived, but was destroyed\n', '     * ====\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        // This method relies on extcodesize, which returns 0 for contracts in\n', '        // construction, since the code is only stored at the end of the\n', '        // constructor execution.\n', '\n', '        uint256 size;\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '\n', '    /**\n', "     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n", '     * `recipient`, forwarding all available gas and reverting on errors.\n', '     *\n', '     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n', '     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n', '     * imposed by `transfer`, making them unable to receive funds via\n', '     * `transfer`. {sendValue} removes this limitation.\n', '     *\n', '     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n', '     *\n', '     * IMPORTANT: because control is transferred to `recipient`, care must be\n', '     * taken to not create reentrancy vulnerabilities. Consider using\n', '     * {ReentrancyGuard} or the\n', '     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n', '     */\n', '    function sendValue(address payable recipient, uint256 amount) internal {\n', '        require(address(this).balance >= amount, "Address: insufficient balance");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n', '        (bool success, ) = recipient.call{ value: amount }("");\n', '        require(success, "Address: unable to send value, recipient may have reverted");\n', '    }\n', '\n', '    /**\n', '     * @dev Performs a Solidity function call using a low level `call`. A\n', '     * plain`call` is an unsafe replacement for a function call: use this\n', '     * function instead.\n', '     *\n', '     * If `target` reverts with a revert reason, it is bubbled up by this\n', '     * function (like regular Solidity function calls).\n', '     *\n', '     * Returns the raw returned data. To convert to the expected return value,\n', '     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `target` must be a contract.\n', '     * - calling `target` with `data` must not revert.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n', '      return functionCall(target, data, "Address: low-level call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n', '     * `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, 0, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but also transferring `value` wei to `target`.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - the calling contract must have an ETH balance of at least `value`.\n', '     * - the called Solidity function must be `payable`.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n', '        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n', '     * with `errorMessage` as a fallback revert reason when `target` reverts.\n', '     *\n', '     * _Available since v3.1._\n', '     */\n', '    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n', '        require(address(this).balance >= value, "Address: insufficient balance for call");\n', '        require(isContract(target), "Address: call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n', '        return functionStaticCall(target, data, "Address: low-level static call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a static call.\n', '     *\n', '     * _Available since v3.3._\n', '     */\n', '    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n', '        require(isContract(target), "Address: static call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.staticcall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n', '        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n', '    }\n', '\n', '    /**\n', '     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n', '     * but performing a delegate call.\n', '     *\n', '     * _Available since v3.4._\n', '     */\n', '    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n', '        require(isContract(target), "Address: delegate call to non-contract");\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = target.delegatecall(data);\n', '        return _verifyCallResult(success, returndata, errorMessage);\n', '    }\n', '\n', '    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n', '        if (success) {\n', '            return returndata;\n', '        } else {\n', '            // Look for revert reason and bubble it up if present\n', '            if (returndata.length > 0) {\n', '                // The easiest way to bubble the revert reason is using memory via assembly\n', '\n', '                // solhint-disable-next-line no-inline-assembly\n', '                assembly {\n', '                    let returndata_size := mload(returndata)\n', '                    revert(add(32, returndata), returndata_size)\n', '                }\n', '            } else {\n', '                revert(errorMessage);\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/StorageSlot.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Library for reading and writing primitive types to specific storage slots.\n', ' *\n', ' * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n', ' * This library helps with reading and writing to such slots without the need for inline assembly.\n', ' *\n', ' * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n', ' *\n', ' * Example usage to set ERC1967 implementation slot:\n', ' * ```\n', ' * contract ERC1967 {\n', ' *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', ' *\n', ' *     function _getImplementation() internal view returns (address) {\n', ' *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n', ' *     }\n', ' *\n', ' *     function _setImplementation(address newImplementation) internal {\n', ' *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n', ' *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n', ' *     }\n', ' * }\n', ' * ```\n', ' *\n', ' * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n', ' */\n', 'library StorageSlot {\n', '    struct AddressSlot {\n', '        address value;\n', '    }\n', '\n', '    struct BooleanSlot {\n', '        bool value;\n', '    }\n', '\n', '    struct Bytes32Slot {\n', '        bytes32 value;\n', '    }\n', '\n', '    struct Uint256Slot {\n', '        uint256 value;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n', '     */\n', '    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n', '        assembly {\n', '            r.slot := slot\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n', '     */\n', '    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n', '        assembly {\n', '            r.slot := slot\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n', '     */\n', '    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n', '        assembly {\n', '            r.slot := slot\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n', '     */\n', '    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n', '        assembly {\n', '            r.slot := slot\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/ERC1967Upgrade.sol\n', '\n', 'pragma solidity ^0.8.2;\n', '\n', '\n', '\n', '/**\n', ' * @dev This abstract contract provides getters and event emitting update functions for\n', ' * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n', ' *\n', ' * _Available since v4.1._\n', ' *\n', ' * @custom:oz-upgrades-unsafe-allow delegatecall\n', ' */\n', 'abstract contract ERC1967Upgrade {\n', '    // This is the keccak-256 hash of "eip1967.proxy.rollback" subtracted by 1\n', '    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n', '\n', '    /**\n', '     * @dev Storage slot with the address of the current implementation.\n', '     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n', '\n', '    /**\n', '     * @dev Emitted when the implementation is upgraded.\n', '     */\n', '    event Upgraded(address indexed implementation);\n', '\n', '    /**\n', '     * @dev Returns the current implementation address.\n', '     */\n', '    function _getImplementation() internal view returns (address) {\n', '        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new address in the EIP1967 implementation slot.\n', '     */\n', '    function _setImplementation(address newImplementation) private {\n', '        require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");\n', '        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n', '    }\n', '\n', '    /**\n', '     * @dev Perform implementation upgrade\n', '     *\n', '     * Emits an {Upgraded} event.\n', '     */\n', '    function _upgradeTo(address newImplementation) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '    }\n', '\n', '    /**\n', '     * @dev Perform implementation upgrade with additional setup call.\n', '     *\n', '     * Emits an {Upgraded} event.\n', '     */\n', '    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n', '        _setImplementation(newImplementation);\n', '        emit Upgraded(newImplementation);\n', '        if (data.length > 0 || forceCall) {\n', '            Address.functionDelegateCall(newImplementation, data);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n', '     *\n', '     * Emits an {Upgraded} event.\n', '     */\n', '    function _upgradeToAndCallSecure(address newImplementation, bytes memory data, bool forceCall) internal {\n', '        address oldImplementation = _getImplementation();\n', '\n', '        // Initial upgrade and setup call\n', '        _setImplementation(newImplementation);\n', '        if (data.length > 0 || forceCall) {\n', '            Address.functionDelegateCall(newImplementation, data);\n', '        }\n', '\n', '        // Perform rollback test if not already in progress\n', '        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n', '        if (!rollbackTesting.value) {\n', '            // Trigger rollback using upgradeTo from the new implementation\n', '            rollbackTesting.value = true;\n', '            Address.functionDelegateCall(\n', '                newImplementation,\n', '                abi.encodeWithSignature(\n', '                    "upgradeTo(address)",\n', '                    oldImplementation\n', '                )\n', '            );\n', '            rollbackTesting.value = false;\n', '            // Check rollback was effective\n', '            require(oldImplementation == _getImplementation(), "ERC1967Upgrade: upgrade breaks further upgrades");\n', '            // Finally reset to the new implementation and log the upgrade\n', '            _setImplementation(newImplementation);\n', '            emit Upgraded(newImplementation);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n', '     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n', '     *\n', '     * Emits a {BeaconUpgraded} event.\n', '     */\n', '    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n', '        _setBeacon(newBeacon);\n', '        emit BeaconUpgraded(newBeacon);\n', '        if (data.length > 0 || forceCall) {\n', '            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Storage slot with the admin of the contract.\n', '     * This is the keccak-256 hash of "eip1967.proxy.admin" subtracted by 1, and is\n', '     * validated in the constructor.\n', '     */\n', '    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n', '\n', '    /**\n', '     * @dev Emitted when the admin account has changed.\n', '     */\n', '    event AdminChanged(address previousAdmin, address newAdmin);\n', '\n', '    /**\n', '     * @dev Returns the current admin.\n', '     */\n', '    function _getAdmin() internal view returns (address) {\n', '        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new address in the EIP1967 admin slot.\n', '     */\n', '    function _setAdmin(address newAdmin) private {\n', '        require(newAdmin != address(0), "ERC1967: new admin is the zero address");\n', '        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n', '    }\n', '\n', '    /**\n', '     * @dev Changes the admin of the proxy.\n', '     *\n', '     * Emits an {AdminChanged} event.\n', '     */\n', '    function _changeAdmin(address newAdmin) internal {\n', '        emit AdminChanged(_getAdmin(), newAdmin);\n', '        _setAdmin(newAdmin);\n', '    }\n', '\n', '    /**\n', '     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n', "     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n", '     */\n', '    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n', '\n', '    /**\n', '     * @dev Emitted when the beacon is upgraded.\n', '     */\n', '    event BeaconUpgraded(address indexed beacon);\n', '\n', '    /**\n', '     * @dev Returns the current beacon.\n', '     */\n', '    function _getBeacon() internal view returns (address) {\n', '        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n', '    }\n', '\n', '    /**\n', '     * @dev Stores a new beacon in the EIP1967 beacon slot.\n', '     */\n', '    function _setBeacon(address newBeacon) private {\n', '        require(\n', '            Address.isContract(newBeacon),\n', '            "ERC1967: new beacon is not a contract"\n', '        );\n', '        require(\n', '            Address.isContract(IBeacon(newBeacon).implementation()),\n', '            "ERC1967: beacon implementation is not a contract"\n', '        );\n', '        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n', '    }\n', '}\n', '\n', '\n', '// File contracts/UUPSUpgradeable.sol\n', '\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev Base contract for building openzeppelin-upgrades compatible implementations for the {ERC1967Proxy}. It includes\n', ' * publicly available upgrade functions that are called by the plugin and by the secure upgrade mechanism to verify\n', ' * continuation of the upgradability.\n', ' *\n', ' * The {_authorizeUpgrade} function MUST be overridden to include access restriction to the upgrade mechanism.\n', ' *\n', ' * _Available since v4.1._\n', ' */\n', 'abstract contract UUPSUpgradeable is ERC1967Upgrade {\n', '    function upgradeTo(address newImplementation) external virtual {\n', '        _authorizeUpgrade(newImplementation);\n', '        _upgradeToAndCallSecure(newImplementation, bytes(""), false);\n', '    }\n', '\n', '    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {\n', '        _authorizeUpgrade(newImplementation);\n', '        _upgradeToAndCallSecure(newImplementation, data, true);\n', '    }\n', '\n', '    function _authorizeUpgrade(address newImplementation) internal virtual;\n', '}\n', '\n', '\n', '// File contracts/Initializable.sol\n', '\n', '// solhint-disable-next-line compiler-version\n', 'pragma solidity ^0.8.0;\n', '\n', '/**\n', ' * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n', " * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n", ' * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n', ' * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n', ' *\n', ' * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n', ' * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n', ' *\n', ' * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n', ' * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n', ' */\n', 'abstract contract Initializable {\n', '\n', '    /**\n', '     * @dev Indicates that the contract has been initialized.\n', '     */\n', '    bool private _initialized;\n', '\n', '    /**\n', '     * @dev Indicates that the contract is in the process of being initialized.\n', '     */\n', '    bool private _initializing;\n', '\n', '    /**\n', '     * @dev Modifier to protect an initializer function from being invoked twice.\n', '     */\n', '    modifier initializer() {\n', '        require(_initializing || !_initialized, "Initializable: contract is already initialized");\n', '\n', '        bool isTopLevelCall = !_initializing;\n', '        if (isTopLevelCall) {\n', '            _initializing = true;\n', '            _initialized = true;\n', '        }\n', '\n', '        _;\n', '\n', '        if (isTopLevelCall) {\n', '            _initializing = false;\n', '        }\n', '    }\n', '}\n', '\n', '\n', '// File contracts/ContextUpgradeable.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '/*\n', ' * @dev Provides information about the current execution context, including the\n', ' * sender of the transaction and its data. While these are generally available\n', ' * via msg.sender and msg.data, they should not be accessed in such a direct\n', ' * manner, since when dealing with meta-transactions the account sending and\n', ' * paying for execution may not be the actual sender (as far as an application\n', ' * is concerned).\n', ' *\n', ' * This contract is only required for intermediate, library-like contracts.\n', ' */\n', 'abstract contract ContextUpgradeable is Initializable {\n', '    function __Context_init() internal initializer {\n', '        __Context_init_unchained();\n', '    }\n', '\n', '    function __Context_init_unchained() internal initializer {\n', '    }\n', '    function _msgSender() internal view virtual returns (address) {\n', '        return msg.sender;\n', '    }\n', '\n', '    function _msgData() internal view virtual returns (bytes calldata) {\n', '        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n', '        return msg.data;\n', '    }\n', '    uint256[50] private __gap;\n', '}\n', '\n', '\n', '// File contracts/2StepOwnableUpgradeable.sol\n', '\n', 'pragma solidity ^0.8.0;\n', '\n', '\n', '/**\n', ' * @dev Contract module which provides a basic access control mechanism, where\n', ' * there is an account (an owner) that can be granted exclusive access to\n', ' * specific functions.\n', ' *\n', ' * By default, the owner account will be the one that deploys the contract. This\n', ' * can later be changed with {transferOwnership}.\n', ' *\n', ' * This module is used through inheritance. It will make available the modifier\n', ' * `onlyOwner`, which can be applied to your functions to restrict their use to\n', ' * the owner.\n', ' */\n', 'abstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n', '    address private _owner;\n', '    address private _newOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev Initializes the contract setting the deployer as the initial owner.\n', '     */\n', '    function __Ownable_init() internal initializer {\n', '        __Context_init_unchained();\n', '        __Ownable_init_unchained();\n', '    }\n', '\n', '    function __Ownable_init_unchained() internal initializer {\n', '        address msgSender = _msgSender();\n', '        _owner = msgSender;\n', '        emit OwnershipTransferred(address(0), msgSender);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the address of the current owner.\n', '     */\n', '    function owner() public view virtual returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers ownership of the contract to a new account (`newOwner`) \n', '     * Can only be called by the current owner.\n', '     * NewOwner must call acceptOwnership function to complete ownership transfer.\n', '     */\n', '    function transferOwnership(address newOwner) public virtual onlyOwner {\n', '        require(newOwner != address(0), "Ownable: new owner is the zero address");\n', '        _newOwner = newOwner;\n', '    }\n', '\n', '    function acceptOwnership() public virtual {\n', '        require(msg.sender == _newOwner);\n', '        emit OwnershipTransferred(_owner, _newOwner);\n', '        _owner = _newOwner;\n', '        _newOwner = address(0);\n', '    }\n', '\n', '    uint256[48] private __gap;\n', '}\n', '\n', '\n', '// File contracts/1PLCO2ImplementationChildV4.sol\n', '\n', 'pragma solidity >=0.8.0;\n', '/*\n', '                                                    ./>.\n', '                                    .<.           ./>>>>>.            .-\n', '                                    (>>>>><....<>>>>>>>>>>>>><...><>>>>>\n', '                                   (>>>>>>>>===   ........   ====>>>>>>>>\n', '                                 ./>>>== ..<>>>==============>>>>>. ==>>>>>\n', '                              .<>>=  (>>==                        ==>>>. =\\>><.\n', '                      (>>>>>>>>= ./>=       ..<>>>>>>>>>>>>>>>>..      =\\>< =\\>>>>>>>>\n', '                      (>>>>>= ./>=     .<>>>>>>>>>>>>>>>>>>>>>>>>>>>>.    =\\>> =\\>>>>=\n', '                      (>>>= </=-    <>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.    =\\> =\\>>>\n', '                     ./>= (/=    (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.   =\\> =\\>+\n', '                    (/= (/=    (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>+   =\\> (>>\n', '                 .<>>= (=    (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.   (> (\\>>.\n', '            (>>>>>>/ ./=   ./>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   (\\-.(>>>>>>+\n', '             (\\>>>>=./=   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=   =>>>>>>>>>>>.  =\\> (>>>>=\n', '              (>>>=./=   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=       \\>>>>>>>>>>-  (\\>.\\>>=\n', '               (>= (=   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>          \\>>>>>>>>>>   (> (>>\n', '               (>-(/   ./>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=            (>>>>>>>>>>   (> (>\n', '              (>= (=   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=     .<>>     (>>>>>>>>>>  (> (>>\n', '             (>>= /=   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=     (>====>>    (>>>>>>>>>   (> (>>.\n', '          ./>>>>-(>   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=    .<========>.   (>>>>>>>>   (> (>>>>.\n', '         =\\>>>>>-(>   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=     />==========>>   =>>>>>>>   (= (>>>>>=\n', '            =>>>-(>   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=    .>=====<<<<<<===>.   \\>>>>>   (= (>>=\n', '              (>) (>   (>>>>>>>>>>>>>>>>>>>>>>>>>>>>=    .>=====(<<<<<<<<</==>.  =\\>>=  (/=(>>=\n', '               (> (>   (>>>>>>>>>>>>>>>>>>>>>>>>>=.    .>====\\(<<<<<<<<<<<<</==>.  ==-  (/ (>=\n', '               (>=(\\=   (>>>>>>>>>>>>>>>>>>>==      .<>====\\/<<<<<<<<<<<<<<<<<</=>>.    /=(/>\n', '               (>> (>   (>>>>>>>>>>>====        ./>>====\\<<<<<<<<<<<<<<<<<<<<<<<<</=   (= (>>\n', '              (>>>> (>                   ...<>>>====\\<<<<<<<<<<<<<<<<<<<<<<<<<<<<</   (> (>>>\\\n', '             (>>>>>> (>    ..../<<<>==========\\\\<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=   (= (>>>>>>\n', '              ===>>>> (>.   ======<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=  ./= (>>>===\n', '                   =\\>.=\\>   =\\<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=   (/= (>=\n', '                     (>> (\\<   =\\<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=   ./= (//\n', '                      (>>> (>>   =<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=   ./= ./>>\n', '                      (>>>>< =\\>.    =<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<=   .</=../>>>=\n', '                      (>>>>>>>. =>>.    ==<<<<<<<<<<<<<<<<<<<<<<<<==    .<>= .<>>>>>>>\n', '                      (======>>>>. =\\>>.      ====<<<<<<<<=====     .<>>= .(>>>=======\n', '                                =\\>>>. ==>>>>..              ...<>>== ..>>>=\n', '                                  (>>>>>>>... =====>>>>>>======...<>>>>>>=\n', '                                   (\\>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>=\n', '                                    (>==         =>>>>>>>>==       .==>=\n', '                                                   =\\>>>=\n', '                                                     ==\n', '                                                     \n', '     \n', '             ▄▄▄▄     ▄▄▄▄▄▄▄▄▄▄▄  ▄▄           ▄▄▄▄▄▄▄▄▄▄▄   ▄▄▄▄▄▄▄▄▄▄   ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄\n', '             ████     ██▀▀▀▀▀▀▀██  ██           ███▀▀▀▀████  ▐██▀▀▀▀▀▀██▌  ██▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀██▀▀▀▀\n', '               ██     ███████████  ██           ███████████  ▐██      ██▌  ███████████       ██\n', '               ██     ████         ██           ██▌    ████  ▐████    ██▌  ████              ████\n', '               ██     ████         ███████████  ██▌    ████  ▐████    ██▌  ████              ████\n', '           ████████▌  ████         ███████████  ███    ████  ▐████    ██▌  ███████████       ████\n', '*/\n', '\n', '\n', '// ---------------------------------------------------------------------------------------------------------------\n', "// '1PLCO2' token contract\n", '//  1PLCO2 is a tokenized Carbon Credit.\n', '//  1PLCO2 = 1 Carbon Credit = 1 metric ton of CO2\n', '//  This 1PLANET contract also offers direct offsetting functions for dApps and Smart Contracts such as NFT minting.\n', '//  When 1PLCO2 is burned/retired then carbon credits are also permenantly burned/retired for carbon offsetting.\n', '//  Use the dApp at www.1PLANET.app for verification and see www.climatefutures.io for more information.\n', '//------------------------------------------------------------------------------------------------------------------\n', '\n', 'interface AggregatorV3Interface {\n', '\n', '  function decimals() external view returns (uint8);\n', '  function description() external view returns (string memory);\n', '  function version() external view returns (uint256);\n', '\n', '  // getRoundData and latestRoundData should both raise "No data present"\n', '  // if they do not have data to report, instead of returning unset values\n', '  // which could be misinterpreted as actual reported values.\n', '  function getRoundData(uint80 _roundId)\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '  function latestRoundData()\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC Token Standard #20 Interface\n', '// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '// ----------------------------------------------------------------------------\n', 'abstract contract ERC20Interface {\n', '    function totalSupply() public virtual view returns (uint);\n', '    function balanceOf(address tokenOwner) public virtual view returns (uint balance);\n', '    function allowance(address tokenOwner, address spender) public virtual view returns (uint remaining);\n', '    function transfer(address to, uint tokens) public virtual returns (bool success);\n', '    function approve(address spender, uint tokens) public virtual returns (bool success);\n', '    function transferFrom(address from, address to, uint tokens) public virtual returns (bool success);\n', '    \n', '    event Transfer(address indexed from, address indexed to, uint tokens);\n', '    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// Contract function to receive approval and execute function in one call\n', '//\n', '// Borrowed from MiniMeToken\n', '// ----------------------------------------------------------------------------\n', 'abstract contract ApproveAndCallFallBack {\n', '    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public virtual;\n', '}\n', '\n', '\n', '// ----------------------------------------------------------------------------\n', '// ERC20 Token, with the addition of symbol, name and decimals and assisted\n', '// token transfers\n', '// ----------------------------------------------------------------------------\n', 'contract OnePlanetCarbonOffsetRootV1 is ERC20Interface, OwnableUpgradeable, UUPSUpgradeable {\n', '    string public symbol;\n', '    string public  name;\n', '    uint8 public decimals;\n', '    uint public _totalSupply;\n', '    uint public startDate;\n', '    uint public endDate;\n', '    uint public _maxSupply;\n', '    uint public updateInterval;\n', '    uint public currentIntervalRound;\n', '    AggregatorV3Interface internal priceFeed;\n', '    uint public ethPrice;\n', '    uint public ethAmount;\n', '    uint public ethPrice1PL;\n', '    uint public sigDigits;\n', '    uint public offsetSigDigits;\n', '    uint public tokenPrice;\n', '\taddress payable public oracleAddress;\n', '\taddress payable public daiAddress;\n', '\taddress payable public tetherAddress;\n', '    address payable public usdcAddress;\n', '\taddress public retireAddress;\n', '\tuint256 public gasCO2factor;\n', '\tuint256 public CO2factor1; // for future use cases\n', '\tuint256 public CO2factor2;\n', '\tuint256 public CO2factor3;\n', '\tuint256 public CO2factor4;\n', '\tuint256 public CO2factor5;\n', '\tuint256 public gasEst;\n', '\t// Matic Variable\n', '\taddress public MintableERC20PredicateProxy;\n', '\t\n', '    event CarbonOffset(string message);\n', '    event ApprovedDaiPurchase(address buyer, uint256 ApprovedAmount, bool success, bytes data);\n', '    event Deposit(address indexed sender, uint value);\n', '    mapping(address => uint) balances;\n', '    mapping(address => mapping(address => uint)) allowed;\n', '\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Initializer\n', '    // ------------------------------------------------------------------------\n', 'function initialize() public initializer {\n', '        symbol = "1PLCO2";\n', '        name = "1PLANET Carbon Credit";\n', '        decimals = 18;\n', '        sigDigits = 100;\n', '        offsetSigDigits = 1e15; // to 1 kg CO2e\n', '        tokenPrice = 1000;\n', '        updateInterval = 1;\n', '        endDate = block.timestamp + 2000 weeks;\n', '        _maxSupply = 150000000000000000000000000; // 150M metric tons CO2e\n', '\t\toracleAddress = payable(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n', '\t\tretireAddress = 0x0000000000000000000000000000000000000000;\n', '\t\tdaiAddress = payable(0x6B175474E89094C44Da98b954EedeAC495271d0F);\n', '        tetherAddress = payable(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n', '        usdcAddress = payable(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\n', '\t\tpriceFeed = AggregatorV3Interface(oracleAddress);\n', '        gasCO2factor = 380000000000;\n', '        __Ownable_init();\n', '        \n', '        //Matic PoS Bridge\n', '        MintableERC20PredicateProxy = 0x9923263fA127b3d1484cFD649df8f1831c2A74e4;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Overwrite of _authorizeUpgrade for UUPSUpgradeable functions\n', '    // ------------------------------------------------------------------------\n', '\n', '    ///@dev upgradeTo and upgradeToAndCall will revert if caller is not the contract owner\n', '    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\n', '    \n', '    modifier onlyPredicate {\n', '        require(msg.sender == MintableERC20PredicateProxy);\n', '        _;\n', '    }\n', '\n', '    modifier estGas {\n', '        uint256 gasAtStart = gasleft();\n', '        _;\n', '        gasEst = gasAtStart - gasleft();\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Total supply\n', '    // ------------------------------------------------------------------------\n', '    function totalSupply() public override view returns (uint) {\n', '        return _totalSupply  - balances[address(0)];\n', '    }\n', '\t\n', '    function maxSupply() public view returns (uint) {\n', '        return _maxSupply;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Get the token balance for account `tokenOwner`\n', '    // ------------------------------------------------------------------------\n', '    function balanceOf(address tokenOwner) public override view returns (uint balance) {\n', '        return balances[tokenOwner];\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', "    // Transfer the balance from token owner's account to `to` account\n", "    // - Owner's account must have sufficient balance to transfer\n", '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transfer(address to, uint tokens) public override returns (bool success) {\n', '        balances[msg.sender] -= tokens;\n', '        balances[to] += tokens;\n', '        emit Transfer(msg.sender, to, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account\n", '    //\n', '    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\n', '    // recommends that there are no checks for the approval double-spend attack\n', '    // as this should be implemented in user interfaces\n', '    // ------------------------------------------------------------------------\n', '    function approve(address spender, uint tokens) public override returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Transfer `tokens` from the `from` account to the `to` account\n', '    //\n', '    // The calling account must already have sufficient tokens approve(...)-d\n', '    // for spending from the `from` account and\n', '    // - From account must have sufficient balance to transfer\n', '    // - Spender must have sufficient allowance to transfer\n', '    // - 0 value transfers are allowed\n', '    // ------------------------------------------------------------------------\n', '    function transferFrom(address from, address to, uint tokens) public override returns (bool success) {\n', '        balances[from] -= tokens;\n', '        allowed[from][msg.sender] -= tokens;\n', '        balances[to] += tokens;\n', '        emit Transfer(from, to, tokens);\n', '        return true;\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Returns the amount of tokens approved by the owner that can be\n', "    // transferred to the spender's account\n", '    // ------------------------------------------------------------------------\n', '    function allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\n', '        return allowed[tokenOwner][spender];\n', '    }\n', '\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Token owner can approve for `spender` to transferFrom(...) `tokens`\n', "    // from the token owner's account. The `spender` contract function\n", '    // `receiveApproval(...)` is then executed\n', '    // ------------------------------------------------------------------------\n', '    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n', '        allowed[msg.sender][spender] = tokens;\n', '        emit Approval(msg.sender, spender, tokens);\n', '        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n', '        return true;\n', '    }\n', '\n', '    // ------------------------------------------------------------------------\n', '    // Send ETH to get 1PLCO2 tokens\n', '    // ------------------------------------------------------------------------\n', '    receive() external payable {\n', '        require(block.timestamp >= startDate && block.timestamp <= endDate);\n', '        uint256 weiAmount = msg.value;\n', '        uint256 tokens = _getTokenAmount(weiAmount);\n', '        balances[msg.sender] += tokens;\n', '        _totalSupply += tokens;\n', '        emit Transfer(address(0), msg.sender, tokens);\n', '        payable(owner()).transfer(msg.value);\n', '        currentIntervalRound += 1;\n', '        if(currentIntervalRound == updateInterval) {\n', '            getLatestPrice();\n', '            currentIntervalRound = 0;\n', '        }\n', '    \n', '    }\n', '\n', '    function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {\n', '        uint256 temp = weiAmount * ethPrice;\n', '        temp /= sigDigits;\n', '        temp /= tokenPrice;\n', '        temp *= 100;\n', '        return temp;\n', '    }\n', '    \n', '    //-------------------------------------------------------------------------------------------\n', '    // Enables user to purchase 1PLCO2 carbon credits with DAI stable coins\n', '    // Buyer must first APPROVE the DAI amount transfer directly with the DAI contract\n', '    //-------------------------------------------------------------------------------------------\n', '    function buy1PLwithDAI(uint256 daiAmount) public returns (bool success) {\n', '        \n', '        ERC20Interface DAIpaymentInstance = ERC20Interface(daiAddress);\n', '        \n', '        require(daiAmount > 0, "You need to send at least some DAI");\n', '        require(DAIpaymentInstance.balanceOf(address(msg.sender)) >= daiAmount, "Not enough DAI");\n', '        uint256 daiAllowance = DAIpaymentInstance.allowance(msg.sender, address(this));\n', '        require(daiAllowance >= daiAmount, "You need to approve more DAI to be spent");\n', '        \n', '        uint256 tokens = daiAmount / tokenPrice;\n', '        tokens *= 100;\n', '        \n', '        DAIpaymentInstance.transferFrom(msg.sender, address(this), daiAmount);\n', '        \n', '        balances[msg.sender] += tokens;\n', '        _totalSupply += tokens;\n', '        \n', '        emit Transfer(address(0), msg.sender, tokens);\n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------------------------\n', '    // Enables user to purchase 1PLCO2 carbon credits with Tether stable coins\n', '    // Buyer must first APPROVE the Tether amount transfer directly with the Tether contract\n', '    //-------------------------------------------------------------------------------------------\n', '    function buy1PLwithUSDT(uint256 tetherAmount) public returns (bool success) {\n', '        \n', '        ERC20Interface TETHERpaymentInstance = ERC20Interface(tetherAddress);\n', '        \n', '        require(tetherAmount > 0, "You need to send at least some TETHER");\n', '        require(TETHERpaymentInstance.balanceOf(address(msg.sender)) >= tetherAmount, "Not enough TETHER");\n', '        uint256 tetherAllowance = TETHERpaymentInstance.allowance(msg.sender, address(this));\n', '        require(tetherAllowance >= tetherAmount, "You need to approve more TETHER to be spent");\n', '        \n', '        uint256 tokens = tetherAmount / tokenPrice;\n', '        tokens *= 100;\n', '        \n', '        TETHERpaymentInstance.transferFrom(msg.sender, address(this), tetherAmount);\n', '        \n', '        balances[msg.sender] += tokens;\n', '        _totalSupply += tokens;\n', '        \n', '        emit Transfer(address(0), msg.sender, tokens);\n', '        return true;\n', '    }\n', '\n', '    //-------------------------------------------------------------------------------------------\n', '    // Enables user to purchase 1PLCO2 carbon credits with USDC stable coins\n', '    // Buyer must first APPROVE the USDC amount transfer directly with the USDC contract\n', '    //-------------------------------------------------------------------------------------------\n', '    function buy1PLwithUSDC(uint256 usdcAmount) public returns (bool success) {\n', '        \n', '        ERC20Interface USDCpaymentInstance = ERC20Interface(usdcAddress);\n', '        \n', '        require(usdcAmount > 0, "You need to send at least some USDC");\n', '        require(USDCpaymentInstance.balanceOf(address(msg.sender)) >= usdcAmount, "Not enough USDC");\n', '        uint256 usdcAllowance = USDCpaymentInstance.allowance(msg.sender, address(this));\n', '        require(usdcAllowance >= usdcAmount, "You need to approve more USDC to be spent");\n', '        \n', '        uint256 tokens = usdcAmount / tokenPrice;\n', '        tokens *= 100;\n', '        \n', '        USDCpaymentInstance.transferFrom(msg.sender, address(this), usdcAmount);\n', '        \n', '        balances[msg.sender] += tokens;\n', '        _totalSupply += tokens;\n', '        \n', '        emit Transfer(address(0), msg.sender, tokens);\n', '        return true;\n', '    }\n', '    \n', '    //-------------------------------------------------------------------------------------------\n', '    // Enables dApps to perform carbon offsetting applications with 1PLCO2 carbon credits\n', '    // Can be used by third-party developers and it will log custom messages\n', '    // Verify transaction details at www.1PLANET.app\n', '    //-------------------------------------------------------------------------------------------\n', '    function retire1PLCO2(uint tokens, string calldata message) external returns (bool success) {\n', '        require(tokens > offsetSigDigits, "Retire at least 0.001 (1kg) 1PLCO2");\n', '        tokens /= offsetSigDigits;\n', '        tokens *= offsetSigDigits; // retire in kg\n', '        transfer(retireAddress, tokens);\n', '        emit CarbonOffset(message);\n', '        return true;\n', '    }\n', '    \n', '    //-------------------------------------------------------------------------------------------\n', '    // Enables dApps to perform carbon offsetting applications with ETH\n', '    // Users pay current spot price here for 1PLCO2 carbon credits\n', '    // Verify transaction details at www.1PLANET.app\n', '    //-------------------------------------------------------------------------------------------\n', '    function offsetDirect(string calldata message) external payable returns (bool success) {\n', '        \n', '        require(msg.value > 0, "You need to send at least some ETH");\n', '        ethAmount = msg.value * (1e18 / offsetSigDigits);\n', '        uint tokens = ethAmount / ethPrice1PL;\n', '        tokens *= offsetSigDigits; // only retire in kg\n', '        balances[retireAddress] += tokens;\n', '        emit Transfer(address(0), retireAddress, tokens);\n', '        emit CarbonOffset(message);\n', '        _totalSupply += tokens;\n', '        getLatestPrice();\n', '        return true;\n', '    }\n', '        \n', '    function update1PLpriceInt(uint price) public onlyOwner {\n', '        tokenPrice = price;\n', '    }\n', '\t\n', '\tfunction setOracleAddress(address payable newOracleAddress) public onlyOwner {\n', '        oracleAddress = newOracleAddress;\n', '        priceFeed = AggregatorV3Interface(oracleAddress);\n', '\t}\n', '\n', '    function setRetireAddress(address newAddress) public onlyOwner {\n', '        retireAddress = newAddress;\n', '    }\n', '    \n', '    function updateGasCO2factor (uint256 CO2factor) external onlyOwner {\n', '        gasCO2factor = CO2factor;\n', '    }\n', '    \n', '    function updateCO2factor1 (uint256 CO2factor) external onlyOwner {\n', '        CO2factor1 = CO2factor;\n', '    }\n', '    \n', '    function updateCO2factor2 (uint256 CO2factor) external onlyOwner {\n', '        CO2factor2 = CO2factor;\n', '    }\n', '    \n', '    function updateCO2factor3 (uint256 CO2factor) external onlyOwner {\n', '        CO2factor3 = CO2factor;\n', '    }\n', '    \n', '    function updateCO2factor4 (uint256 CO2factor) external onlyOwner {\n', '        CO2factor4 = CO2factor;\n', '    }\n', '    \n', '    function updateCO2factor5 (uint256 CO2factor) external onlyOwner {\n', '        CO2factor5 = CO2factor;\n', '    }\n', '    \n', '    \n', '    function setOracleUpdateInterval(uint interval) public onlyOwner {\n', '        updateInterval = interval;\n', '    }\n', '\n', '    function genAndSendTokens(address to, uint tokens) external onlyOwner returns (bool success) {\n', '        require(block.timestamp >= startDate && block.timestamp <= endDate);\n', '        require(_maxSupply >= (_totalSupply + tokens));\n', '        balances[to] += tokens;\n', '        _totalSupply += tokens;\n', '        emit Transfer(address(0), to, tokens);\n', '        \n', '        return true;\n', '    }\n', '\n', '    //-----------------------------------------------------\n', '    // Returns the latest Chainlink Oracle ETH USD price\n', '    //-----------------------------------------------------\n', '    function getLatestPrice() public {\n', '        (\n', '            uint80 roundID, \n', '            int price,\n', '            uint startedAt,\n', '            uint timeStamp,\n', '            uint80 answeredInRound\n', '        ) = priceFeed.latestRoundData();\n', '        // If the round is not complete yet, timestamp is 0\n', '        require(timeStamp > 0, "Round not complete");\n', '        ethPrice = uint(price) / 1000000;\n', '        uint256 temp = tokenPrice * 1e18;\n', '        ethPrice1PL = temp / ethPrice;\n', '    }\n', '\n', '    function updateEthPriceManually(uint price) external onlyOwner {\n', '        ethPrice = price;\n', '    }\n', '    \n', '    function update1PLethPriceManually(uint price) external onlyOwner {\n', '        ethPrice1PL = price;\n', '    }\n', '    \n', '    \n', '    //--------------------------------------------------------------------------------------\n', '    // Added due to Matic <-> Ethereum PoS transfer requiring 1PLCO2 on Matic network to be\n', '    // burned or minted. Eth supply can be increased if it is ever necessary.\n', '    //--------------------------------------------------------------------------------------\n', '    function setMaxVolume(uint maxVolume) external onlyOwner {\n', '        _maxSupply = maxVolume;\n', '    }\n', '    \n', '    //--------------------------------------------------------------------------------------\n', '    // Oracle returns price in decimal cents to 2 decimal places. If this changes it can\n', '    // be adjusted by changing this significant digit value.\n', '    // Should be a power of 10.\n', '    //--------------------------------------------------------------------------------------\n', '    function setSigDigits(uint digits) external onlyOwner {\n', '        sigDigits = digits;\n', '    }\n', '    \n', '    function setOffsetSigDigits(uint digits) external onlyOwner {\n', '        offsetSigDigits = digits;\n', '    }\n', '\n', '\n', '    function topUpBalance() public payable {\n', '    }\n', '\n', '    function withdrawFromBalance() public onlyOwner {\n', '        payable(owner()).transfer(address(this).balance);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Owner can transfer out any accidentally sent ERC20 tokens\n', '    // ------------------------------------------------------------------------\n', '    function transferAnyERC20Token(address tokenAddress, uint tokens) external onlyOwner returns (bool success) {\n', '        return ERC20Interface(tokenAddress).transfer(payable(owner()), tokens);\n', '    }\n', '    \n', '    \n', '    function removePermanently(address account, uint256 amount) external onlyOwner returns (bool success) {\n', '        require(account != address(0), "ERC20: burn from the zero address");\n', '\n', '        _beforeTokenTransfer(account, address(0), amount);\n', '\n', '        balances[account] -= amount;\n', '        _totalSupply -= amount;\n', '        emit Transfer(account, address(0), amount);\n', '        \n', '        return true;\n', '    }\n', '        /**\n', '     * @dev Hook that is called before any transfer of tokens. This includes\n', '     * minting and burning.\n', '     *\n', '     * Calling conditions:\n', '     *\n', "     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n", '     * will be to transferred to `to`.\n', '     * - when `from` is zero, `amount` tokens will be minted for `to`.\n', "     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n", '     * - `from` and `to` are never both zero.\n', '     *\n', '     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n', '     */\n', '    \n', '    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n', '    \n', '        // Matic L2 Bridge functions\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Matic Mint Function\n', '    // ------------------------------------------------------------------------\n', '    function mint(address user, uint256 amount) external onlyPredicate {\n', '        _mint(user, amount);\n', '    }\n', '    \n', '    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n', '     * the total supply.\n', '     *\n', '     * Emits a {Transfer} event with `from` set to the zero address.\n', '     *\n', '     * Requirements\n', '     *\n', '     * - `to` cannot be the zero address.\n', '     */\n', '\n', '    function _mint(address to, uint256 tokens) internal virtual estGas {\n', '        require(to != address(0), "ERC20: mint to the zero address");\n', '        require(block.timestamp >= startDate && block.timestamp <= endDate);\n', '        require(_maxSupply >= (_totalSupply + tokens));\n', '        _beforeTokenTransfer(address(0), to, tokens);\n', '        balances[to] += tokens;\n', '        _totalSupply += tokens;\n', '        emit Transfer(address(0), to, tokens);\n', '    }\n', '    \n', '    // ------------------------------------------------------------------------\n', '    // Matic Predicate Address\n', '    // ------------------------------------------------------------------------\n', "    // being proxified smart contract, most probably childChainManagerProxy contract's address\n", '    // is not going to change ever, but still, lets keep it \n', '\t\n', '    function updatePredicate(address payable newERC20PredicateProxy) external onlyOwner {\n', '        require(newERC20PredicateProxy != address(0), "Bad ERC20PredicateProxy address");\n', '        MintableERC20PredicateProxy = newERC20PredicateProxy;\n', '    }\n', '    \n', '}']