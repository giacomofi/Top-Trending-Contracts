['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-11\n', '*/\n', '\n', '/**\n', ' *Submitted for verification at Etherscan.io on 2019-11-14\n', '*/\n', '\n', '// hevm: flattened sources of /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/join.sol\n', 'pragma solidity =0.5.12;\n', '\n', '////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/lib.sol\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity 0.5.12; */\n', '\n', 'contract LibNote {\n', '    event LogNote(\n', '        bytes4   indexed  sig,\n', '        address  indexed  usr,\n', '        bytes32  indexed  arg1,\n', '        bytes32  indexed  arg2,\n', '        bytes             data\n', '    ) anonymous;\n', '\n', '    modifier note {\n', '        _;\n', '        assembly {\n', "            // log an 'anonymous' event with a constant 6 words of calldata\n", '            // and four indexed topics: selector, caller, arg1 and arg2\n', '            let mark := msize                         // end of memory ensures zero\n', '            mstore(0x40, add(mark, 288))              // update free memory pointer\n', '            mstore(mark, 0x20)                        // bytes type data offset\n', '            mstore(add(mark, 0x20), 224)              // bytes size (padded)\n', '            calldatacopy(add(mark, 0x40), 0, 224)     // bytes payload\n', '            log4(mark, 288,                           // calldata\n', '                 shl(224, shr(224, calldataload(0))), // msg.sig\n', '                 caller,                              // msg.sender\n', '                 calldataload(4),                     // arg1\n', '                 calldataload(36)                     // arg2\n', '                )\n', '        }\n', '    }\n', '}\n', '\n', '////// /nix/store/8xb41r4qd0cjb63wcrxf1qmfg88p0961-dss-6fd7de0/src/join.sol\n', '/// join.sol -- Basic token adapters\n', '\n', '// Copyright (C) 2018 Rain <[email\xa0protected]>\n', '//\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU Affero General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '//\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU Affero General Public License for more details.\n', '//\n', '// You should have received a copy of the GNU Affero General Public License\n', '// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n', '\n', '/* pragma solidity 0.5.12; */\n', '\n', '/* import "./lib.sol"; */\n', '\n', 'contract GemLike {\n', '    function decimals() public view returns (uint);\n', '    function transfer(address,uint) external returns (bool);\n', '    function transferFrom(address,address,uint) external returns (bool);\n', '}\n', '\n', 'contract DSTokenLike {\n', '    function mint(address,uint) external;\n', '    function burn(address,uint) external;\n', '}\n', '\n', 'contract VatLike {\n', '    function slip(bytes32,address,int) external;\n', '    function move(address,address,uint) external;\n', '}\n', '\n', '/*\n', '    Here we provide *adapters* to connect the Vat to arbitrary external\n', '    token implementations, creating a bounded context for the Vat. The\n', '    adapters here are provided as working examples:\n', '\n', '      - `GemJoin`: For well behaved ERC20 tokens, with simple transfer\n', '                   semantics.\n', '\n', '      - `ETHJoin`: For native Ether.\n', '\n', '      - `DaiJoin`: For connecting internal Dai balances to an external\n', '                   `DSToken` implementation.\n', '\n', '    In practice, adapter implementations will be varied and specific to\n', '    individual collateral types, accounting for different transfer\n', '    semantics and token standards.\n', '\n', '    Adapters need to implement two basic methods:\n', '\n', '      - `join`: enter collateral into the system\n', '      - `exit`: remove collateral from the system\n', '\n', '*/\n', '\n', 'contract GemJoin is LibNote {\n', '    // --- Auth ---\n', '    mapping (address => uint) public wards;\n', '    function rely(address usr) external note auth { wards[usr] = 1; }\n', '    function deny(address usr) external note auth { wards[usr] = 0; }\n', '    modifier auth {\n', '        require(wards[msg.sender] == 1, "GemJoin/not-authorized");\n', '        _;\n', '    }\n', '\n', '    VatLike public vat;\n', '    bytes32 public ilk;\n', '    GemLike public gem;\n', '    uint    public dec;\n', '    uint    public live;  // Access Flag\n', '\n', '    constructor(address vat_, bytes32 ilk_, address gem_) public {\n', '        wards[msg.sender] = 1;\n', '        live = 1;\n', '        vat = VatLike(vat_);\n', '        ilk = ilk_;\n', '        gem = GemLike(gem_);\n', '        dec = gem.decimals();\n', '    }\n', '    function cage() external note auth {\n', '        live = 0;\n', '    }\n', '    function join(address usr, uint wad) external note {\n', '        require(live == 1, "GemJoin/not-live");\n', '        require(int(wad) >= 0, "GemJoin/overflow");\n', '        vat.slip(ilk, usr, int(wad));\n', '        require(gem.transferFrom(msg.sender, address(this), wad), "GemJoin/failed-transfer");\n', '    }\n', '    function exit(address usr, uint wad) external note {\n', '        require(wad <= 2 ** 255, "GemJoin/overflow");\n', '        vat.slip(ilk, msg.sender, -int(wad));\n', '        require(gem.transfer(usr, wad), "GemJoin/failed-transfer");\n', '    }\n', '}\n', '\n', 'contract ETHJoin is LibNote {\n', '    // --- Auth ---\n', '    mapping (address => uint) public wards;\n', '    function rely(address usr) external note auth { wards[usr] = 1; }\n', '    function deny(address usr) external note auth { wards[usr] = 0; }\n', '    modifier auth {\n', '        require(wards[msg.sender] == 1, "ETHJoin/not-authorized");\n', '        _;\n', '    }\n', '\n', '    VatLike public vat;\n', '    bytes32 public ilk;\n', '    uint    public live;  // Access Flag\n', '\n', '    constructor(address vat_, bytes32 ilk_) public {\n', '        wards[msg.sender] = 1;\n', '        live = 1;\n', '        vat = VatLike(vat_);\n', '        ilk = ilk_;\n', '    }\n', '    function cage() external note auth {\n', '        live = 0;\n', '    }\n', '    function join(address usr) external payable note {\n', '        require(live == 1, "ETHJoin/not-live");\n', '        require(int(msg.value) >= 0, "ETHJoin/overflow");\n', '        vat.slip(ilk, usr, int(msg.value));\n', '    }\n', '    function exit(address payable usr, uint wad) external note {\n', '        require(int(wad) >= 0, "ETHJoin/overflow");\n', '        vat.slip(ilk, msg.sender, -int(wad));\n', '        usr.transfer(wad);\n', '    }\n', '}\n', '\n', 'contract DaiJoin is LibNote {\n', '    // --- Auth ---\n', '    mapping (address => uint) public wards;\n', '    function rely(address usr) external note auth { wards[usr] = 1; }\n', '    function deny(address usr) external note auth { wards[usr] = 0; }\n', '    modifier auth {\n', '        require(wards[msg.sender] == 1, "DaiJoin/not-authorized");\n', '        _;\n', '    }\n', '\n', '    VatLike public vat;\n', '    DSTokenLike public dai;\n', '    uint    public live;  // Access Flag\n', '\n', '    constructor(address vat_, address dai_) public {\n', '        wards[msg.sender] = 1;\n', '        live = 1;\n', '        vat = VatLike(vat_);\n', '        dai = DSTokenLike(dai_);\n', '    }\n', '    function cage() external note auth {\n', '        live = 0;\n', '    }\n', '    uint constant ONE = 10 ** 27;\n', '    function mul(uint x, uint y) internal pure returns (uint z) {\n', '        require(y == 0 || (z = x * y) / y == x);\n', '    }\n', '    function join(address usr, uint wad) external note {\n', '        vat.move(address(this), usr, mul(ONE, wad));\n', '        dai.burn(msg.sender, wad);\n', '    }\n', '    function exit(address usr, uint wad) external note {\n', '        require(live == 1, "DaiJoin/not-live");\n', '        vat.move(msg.sender, address(this), mul(ONE, wad));\n', '        dai.mint(usr, wad);\n', '    }\n', '}']