['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-01\n', '*/\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity 0.6.12;\n', 'pragma experimental ABIEncoderV2;\n', '\n', 'interface IERC20 {\n', '}\n', '\n', 'library BoringERC20 {\n', '    function symbol(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x95d89b41));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function name(IERC20 token) internal view returns (string memory) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x06fdde03));\n', '        return success && data.length > 0 ? abi.decode(data, (string)) : "???";\n', '    }\n', '\n', '    function decimals(IERC20 token) internal view returns (uint8) {\n', '        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(0x313ce567));\n', '        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n', '    }\n', '}\n', '\n', 'contract BoringHelper {\n', '    using BoringERC20 for IERC20;\n', '    \n', '    struct TokenInfo {\n', '        IERC20 token;\n', '        uint256 decimals;\n', '        string name;\n', '        string symbol;\n', '    }\n', '\n', '    function getTokenInfo(address[] calldata addresses) public view returns (TokenInfo[] memory) {\n', '        TokenInfo[] memory infos = new TokenInfo[](addresses.length);\n', '\n', '        for (uint256 i = 0; i < addresses.length; i++) {\n', '            IERC20 token = IERC20(addresses[i]);\n', '            infos[i].token = token;\n', '\n', '            infos[i].name = token.name();\n', '            infos[i].symbol = token.symbol();\n', '            infos[i].decimals = token.decimals();\n', '        }\n', '\n', '        return infos;\n', '    }\n', '}']