['pragma solidity =0.5.16;\n', '\n', 'import "./libraries/UQ112x112.sol";\n', 'import "./interfaces/IUniswapV2Pair.sol";\n', 'import "./interfaces/ISimpleUniswapOracle.sol";\n', '\n', 'contract SimpleUniswapOracle is ISimpleUniswapOracle {\n', '\tusing UQ112x112 for uint224;\n', '\t\n', '\tuint32 public constant MIN_T = 1800;\n', '\t\n', '\tstruct Pair {\n', '\t\tuint256 priceCumulativeA;\n', '\t\tuint256 priceCumulativeB;\n', '\t\tuint32 updateA;\n', '\t\tuint32 updateB;\n', '\t\tbool lastIsA;\n', '\t\tbool initialized;\n', '\t}\n', '\tmapping(address => Pair) public getPair;\n', '\n', '\tevent PriceUpdate(address indexed pair, uint256 priceCumulative, uint32 blockTimestamp, bool lastIsA);\n', '\t\n', '\tfunction toUint224(uint256 input) internal pure returns (uint224) {\n', '\t\trequire(input <= uint224(-1), "UniswapOracle: UINT224_OVERFLOW");\n', '\t\treturn uint224(input);\n', '\t}\n', '\t\n', '\tfunction getPriceCumulativeCurrent(address uniswapV2Pair) internal view returns (uint256 priceCumulative) {\n', '\t\tpriceCumulative = IUniswapV2Pair(uniswapV2Pair).price0CumulativeLast();\n', '\t\t(uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(uniswapV2Pair).getReserves();\n', '\t\tuint224 priceLast = UQ112x112.encode(reserve1).uqdiv(reserve0);\n', '\t\tuint32 timeElapsed = getBlockTimestamp() - blockTimestampLast; // overflow is desired\n', '\t\t// * never overflows, and + overflow is desired\n', '\t\tpriceCumulative += uint256(priceLast) * timeElapsed;\n', '\t}\n', '\t\n', '\tfunction initialize(address uniswapV2Pair) external {\n', '\t\tPair storage pairStorage = getPair[uniswapV2Pair];\n', '\t\trequire(!pairStorage.initialized, "UniswapOracle: ALREADY_INITIALIZED");\n', '\t\t\n', '\t\tuint256 priceCumulativeCurrent = getPriceCumulativeCurrent(uniswapV2Pair);\n', '\t\tuint32 blockTimestamp = getBlockTimestamp();\n', '\t\tpairStorage.priceCumulativeA = priceCumulativeCurrent;\n', '\t\tpairStorage.priceCumulativeB = priceCumulativeCurrent;\n', '\t\tpairStorage.updateA = blockTimestamp;\n', '\t\tpairStorage.updateB = blockTimestamp;\n', '\t\tpairStorage.lastIsA = true;\n', '\t\tpairStorage.initialized = true;\n', '\t\temit PriceUpdate(uniswapV2Pair, priceCumulativeCurrent, blockTimestamp, true);\n', '\t}\n', '\t\n', '\tfunction getResult(address uniswapV2Pair) external returns (uint224 price, uint32 T) {\n', '\t\tPair memory pair = getPair[uniswapV2Pair];\n', '\t\trequire(pair.initialized, "UniswapOracle: NOT_INITIALIZED");\n', '\t\tPair storage pairStorage = getPair[uniswapV2Pair];\n', '\t\t\t\t\n', '\t\tuint32 blockTimestamp = getBlockTimestamp();\n', '\t\tuint32 updateLast = pair.lastIsA ? pair.updateA : pair.updateB;\n', '\t\tuint256 priceCumulativeCurrent = getPriceCumulativeCurrent(uniswapV2Pair);\n', '\t\tuint256 priceCumulativeLast;\n', '\t\t\n', '\t\tif (blockTimestamp - updateLast >= MIN_T) {\n', '\t\t\t// update\n', '\t\t\tpriceCumulativeLast = pair.lastIsA ? pair.priceCumulativeA : pair.priceCumulativeB;\n', '\t\t\tif (pair.lastIsA) {\n', '\t\t\t\tpairStorage.priceCumulativeB = priceCumulativeCurrent;\n', '\t\t\t\tpairStorage.updateB = blockTimestamp;\n', '\t\t\t} else {\n', '\t\t\t\tpairStorage.priceCumulativeA = priceCumulativeCurrent;\n', '\t\t\t\tpairStorage.updateA = blockTimestamp;\n', '\t\t\t}\n', '\t\t\tpairStorage.lastIsA = !pair.lastIsA;\n', '\t\t\temit PriceUpdate(uniswapV2Pair, priceCumulativeCurrent, blockTimestamp, !pair.lastIsA);\n', '\t\t}\n', '\t\telse {\n', "\t\t\t// don't update and return price using previous priceCumulative\n", '\t\t\tupdateLast = pair.lastIsA ? pair.updateB : pair.updateA;\n', '\t\t\tpriceCumulativeLast = pair.lastIsA ? pair.priceCumulativeB : pair.priceCumulativeA;\n', '\t\t}\n', '\t\t\n', '\t\tT = blockTimestamp - updateLast; // overflow is desired\n', '\t\trequire(T >= MIN_T, "UniswapOracle: NOT_READY"); //reverts only if the pair has just been initialized\n', '\t\t// / is safe, and - overflow is desired\n', '\t\tprice = toUint224((priceCumulativeCurrent - priceCumulativeLast) / T);\n', '\t}\n', '\t\n', '\t/*** Utilities ***/\n', '\t\n', '\tfunction getBlockTimestamp() public view returns (uint32) {\n', '\t\treturn uint32(block.timestamp % 2**32);\n', '\t}\n', '}\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface ISimpleUniswapOracle {\n', '\tevent PriceUpdate(address indexed pair, uint256 priceCumulative, uint32 blockTimestamp, bool lastIsA);\n', '\tfunction MIN_T() external pure returns (uint32);\n', '\tfunction getBlockTimestamp() external view returns (uint32);\n', '\tfunction getPair(address uniswapV2Pair) external view returns (\n', '\t\tuint256 priceCumulativeA,\n', '\t\tuint256 priceCumulativeB,\n', '\t\tuint32 updateA,\n', '\t\tuint32 updateB,\n', '\t\tbool lastIsA,\n', '\t\tbool initialized\n', '\t);\n', '\tfunction initialize(address uniswapV2Pair) external;\n', '\tfunction getResult(address uniswapV2Pair) external returns (uint224 price, uint32 T);\n', '}\n', '\n', 'pragma solidity =0.5.16;\n', '\n', 'interface IUniswapV2Pair {\n', '    event Approval(address indexed owner, address indexed spender, uint value);\n', '    event Transfer(address indexed from, address indexed to, uint value);\n', '\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function decimals() external view returns (uint8);\n', '    function totalSupply() external view returns (uint);\n', '    function balanceOf(address owner) external view returns (uint);\n', '    function allowance(address owner, address spender) external view returns (uint);\n', '\n', '    function approve(address spender, uint value) external returns (bool);\n', '    function transfer(address to, uint value) external returns (bool);\n', '    function transferFrom(address from, address to, uint value) external returns (bool);\n', '\n', '    function token0() external view returns (address);\n', '    function token1() external view returns (address);\n', '    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n', '\n', '    function price0CumulativeLast() external view returns (uint);\n', '    function price1CumulativeLast() external view returns (uint);\n', '}\n', '\n', 'pragma solidity =0.5.16;\n', '\n', '// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\n', '\n', '// range: [0, 2**112 - 1]\n', '// resolution: 1 / 2**112\n', '\n', 'library UQ112x112 {\n', '    uint224 constant Q112 = 2**112;\n', '\n', '    // encode a uint112 as a UQ112x112\n', '    function encode(uint112 y) internal pure returns (uint224 z) {\n', '        z = uint224(y) * Q112; // never overflows\n', '    }\n', '\n', '    // divide a UQ112x112 by a uint112, returning a UQ112x112\n', '    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\n', '        z = x / uint224(y);\n', '    }\n', '}']