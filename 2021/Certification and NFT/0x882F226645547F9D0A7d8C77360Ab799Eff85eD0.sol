['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-18\n', '*/\n', '\n', '// File: @chainlink\\contracts\\src\\v0.7\\interfaces\\AggregatorV3Interface.sol\n', '\n', '// SPDX-License-Identifier: MIT\n', 'pragma solidity ^0.7.0;\n', '\n', 'interface AggregatorV3Interface {\n', '\n', '  function decimals()\n', '    external\n', '    view\n', '    returns (\n', '      uint8\n', '    );\n', '\n', '  function description()\n', '    external\n', '    view\n', '    returns (\n', '      string memory\n', '    );\n', '\n', '  function version()\n', '    external\n', '    view\n', '    returns (\n', '      uint256\n', '    );\n', '\n', '  // getRoundData and latestRoundData should both raise "No data present"\n', '  // if they do not have data to report, instead of returning unset values\n', '  // which could be misinterpreted as actual reported values.\n', '  function getRoundData(\n', '    uint80 _roundId\n', '  )\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '\n', '  function latestRoundData()\n', '    external\n', '    view\n', '    returns (\n', '      uint80 roundId,\n', '      int256 answer,\n', '      uint256 startedAt,\n', '      uint256 updatedAt,\n', '      uint80 answeredInRound\n', '    );\n', '\n', '}\n', '\n', '// File: contracts\\ChainlinkRewardOracle.sol\n', '\n', '\n', '\n', 'pragma solidity ^0.7.1;\n', '\n', '\n', 'contract ChainlinkRewardOracle {\n', '\n', '  mapping(uint16 => uint256[]) public base_SFI_rewards;\n', '  mapping(uint16 => uint256[]) public bonus_SFI_rewards;\n', '\n', '  mapping(uint256 => AggregatorV3Interface) public pool_feed;\n', '  mapping(uint256 => uint256) public base_asset_price_begin;\n', '  mapping(uint256 => uint256) public base_asset_price_end;\n', '  mapping(uint256 => uint256) public limit; // If end price is less than X percent of `begin` use maximum reward; 1e18 scale\n', '\n', '  mapping(uint16 => uint16[]) public tracked_pools;\n', '\n', '  enum states {UNSET, REWARD_SET, STARTED, ENDED}\n', '  mapping(uint16 => states) public epoch_state;\n', '\n', '  address public governance;\n', '  address public _new_governance;\n', '  address public strategy;\n', '\n', '  constructor(address strategyAddr) {\n', '    governance = msg.sender;\n', '    strategy = strategyAddr;\n', '  }\n', '\n', '  function set_feed(uint16 epoch, uint16 pool, address feedAddr, uint256 maxPct, uint256 alt_reward) public {\n', '    require(msg.sender == strategy || msg.sender == governance, "must be strategy or gov");\n', '    require(epoch_state[epoch] == states.REWARD_SET, "rewards must be set and not started");\n', '    require(pool < base_SFI_rewards[epoch].length, "cannot feed pool with undefined reward");\n', '    require(maxPct < 1 ether, "can\'t award on no change"); // Prevent divide by zero\n', '    uint256 index = pack(epoch, pool);\n', '    pool_feed[index] = AggregatorV3Interface(feedAddr);\n', '    tracked_pools[epoch].push(pool);\n', '    limit[index] = maxPct;\n', '    bonus_SFI_rewards[epoch][pool] = alt_reward;\n', '  }\n', '\n', '  function set_base_reward(uint16 epoch, uint256[] calldata SFI_rewards) public {\n', '    require(msg.sender == strategy || msg.sender == governance, "must be strategy or gov");\n', '    require(epoch_state[epoch] == states.UNSET || epoch_state[epoch] == states.REWARD_SET, "must not be started");\n', '    epoch_state[epoch] = states.REWARD_SET;\n', '    base_SFI_rewards[epoch] = SFI_rewards;\n', '    bonus_SFI_rewards[epoch] = SFI_rewards;\n', '  }\n', '\n', '  event BeginEpoch(uint16 epoch);\n', '\n', '  function begin_epoch(uint16 epoch) public {\n', '    require(msg.sender == strategy || msg.sender == governance, "must be strategy or gov");\n', '    require(epoch_state[epoch] == states.REWARD_SET, "must set rewards first");\n', '    epoch_state[epoch] = states.STARTED;\n', '    emit BeginEpoch(epoch);\n', '    for (uint256 i = 0; i < tracked_pools[epoch].length; i++) {\n', '      uint256 index = pack(epoch, tracked_pools[epoch][i]);\n', '      base_asset_price_begin[index] = get_latest_price(index);\n', '    }\n', '  }\n', '\n', '  event EndEpoch(uint16 epoch);\n', '\n', '  function end_epoch(uint16 epoch) public {\n', '    require(msg.sender == strategy || msg.sender == governance, "must be strategy or gov");\n', '    require(epoch_state[epoch] == states.STARTED, "must be started");\n', '    epoch_state[epoch] = states.ENDED;\n', '    emit EndEpoch(epoch);\n', '    for (uint256 i = 0; i < tracked_pools[epoch].length; i++) {\n', '      uint256 index = pack(epoch, tracked_pools[epoch][i]);\n', '      base_asset_price_end[index] = get_latest_price(index);\n', '    }\n', '  }\n', '\n', '  event OracleGetReward(uint256 index, uint256 begin, uint256 end, uint256 reward);\n', '\n', '  function get_reward(uint16 epoch, uint16 pool) public view returns (uint256 index, uint256 begin, uint256 end, uint256 reward) {\n', '    require(epoch_state[epoch] == states.ENDED, "must be ended");\n', '    if (pool > base_SFI_rewards[epoch].length) {\n', '      return (index, begin, end, reward);\n', '    }\n', '\n', '    index = pack(epoch, pool);\n', '\n', '    if (pool_feed[index] == AggregatorV3Interface(0x0)) {\n', '      reward = base_SFI_rewards[epoch][pool];\n', '      return (index, begin, end, reward);\n', '    }\n', '\n', '    begin = base_asset_price_begin[index];\n', '    end = base_asset_price_end[index];\n', '\n', '    if (end >= begin) {\n', '      reward = base_SFI_rewards[epoch][pool];\n', '      return (index, begin, end, reward);\n', '    }\n', '\n', '    uint256 pct = limit[index];\n', '    uint256 max_price_move = begin * pct / 1e18;\n', '\n', '    reward = base_SFI_rewards[epoch][pool] + calc_reward_bonus(begin, end, pct, max_price_move, bonus_SFI_rewards[epoch][pool]);\n', '\n', '    return (index, begin, end, reward);\n', '  }\n', '\n', '  function calc_reward_bonus(uint256 begin, uint256 end, uint256 pct, uint256 max_price_move, uint256 bonus_SFI_reward) internal pure returns (uint256) {\n', '    if (end <= max_price_move) return bonus_SFI_reward;\n', '    uint256 delta = (begin - end);\n', '    uint256 delta_pct = (delta * 1 ether) / begin;\n', '    uint256 reward_multiplier = delta_pct * 1 ether / (1 ether - pct);\n', '    return bonus_SFI_reward * reward_multiplier / 1 ether;\n', '  }\n', '\n', '  function get_latest_price(uint256 index) internal view returns (uint256) {\n', '    AggregatorV3Interface priceFeed = pool_feed[index];\n', '    require(priceFeed != AggregatorV3Interface(0x0), "no feed found");\n', '    // uint80 roundID, int price, uint startedAt, uint timeStamp, uint80 answeredInRound\n', '    (,int price,,,) = priceFeed.latestRoundData();\n', '    return uint256(price);\n', '  }\n', '\n', '  function pack(uint16 epoch, uint16 pool) internal pure returns (uint256) {\n', '    return uint256(epoch) | uint256(pool) << 16;\n', '  }\n', '\n', '  //  function unpack(uint256 value) public pure returns (uint16, uint16) {\n', '  //    return (uint16(value), uint16(value >> 16));\n', '  //  }\n', '\n', '  event SetGovernance(address prev, address next);\n', '  event AcceptGovernance(address who);\n', '\n', '  function set_governance(address to) external {\n', '    require(msg.sender == governance, "must be governance");\n', '    _new_governance = to;\n', '    emit SetGovernance(msg.sender, to);\n', '  }\n', '\n', '  function accept_governance() external {\n', '    require(msg.sender == _new_governance, "must be new governance");\n', '    governance = msg.sender;\n', '    emit AcceptGovernance(msg.sender);\n', '  }\n', '\n', '  function set_strategy(address to) external {\n', '    require(msg.sender == governance, "must be governance");\n', '    strategy = to;\n', '  }\n', '}']