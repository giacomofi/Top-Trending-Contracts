['// SPDX-License-Identifier: MIT\n', '\n', 'pragma solidity ^0.6.0;\n', '\n', 'import "./SafeMath.sol";\n', 'import "./Context.sol";\n', 'import "./Ownable.sol";\n', 'import "./Address.sol";\n', 'import "./IERC20.sol";\n', 'import "./IXAUToken.sol";\n', 'import "./IFeeApprover.sol";\n', 'import "./IXAUVault.sol";\n', '\n', '/**\n', ' * @dev Implementation of the {IERC20} interface.\n', ' *\n', ' * This implementation is agnostic to the way tokens are created. This means\n', ' * that a supply mechanism has to be added in a derived contract using {_mint}.\n', ' * For a generic mechanism see {ERC20PresetMinterPauser}.\n', ' *\n', ' * TIP: For a detailed writeup see our guide\n', ' * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n', ' * to implement supply mechanisms].\n', ' *\n', ' * We have followed general OpenZeppelin guidelines: functions revert instead\n', ' * of returning `false` on failure. This behavior is nonetheless conventional\n', ' * and does not conflict with the expectations of ERC20 applications.\n', ' *\n', ' * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n', ' * This allows applications to reconstruct the allowance for all accounts just\n', ' * by listening to said events. Other implementations of the EIP may not emit\n', " * these events, as it isn't required by the specification.\n", ' *\n', ' * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n', ' * functions have been added to mitigate the well-known issues around setting\n', ' * allowances. See {IERC20-approve}.\n', ' */\n', 'contract XAUToken is IXAUToken, Context, Ownable {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    mapping(address => uint256) private _balances;\n', '\n', '    mapping(address => mapping(address => uint256)) private _allowances;\n', '\n', '    address public override rebaser;\n', '\n', '    uint256 internal _totalSupply;\n', '\n', '    /**\n', '     * @notice Used for percentage maths\n', '     */\n', '    uint256 public constant BASE = 10**18;\n', '    \n', '\n', '    /**\n', "     * @notice Scaling factor that adjusts everyone's balances\n", '     */\n', '    uint256 internal xauScalingFactor;\n', '\n', '    /**\n', '     * @notice Internal decimals used to handle scaling factor\n', '     */\n', '    uint256 public constant internalDecimals = 10**24;\n', '\n', '    modifier onlyRebaser() {\n', '        require(msg.sender == rebaser);\n', '        _;\n', '    }\n', '\n', '    string private _name;\n', '    string private _symbol;\n', '    uint8 private _decimals;\n', '    uint256 public initialSupply;\n', '    uint256 public initialSupplyUnderlying;\n', '    uint256 public contractStartTimestamp;\n', '\n', '\n', '    /**\n', '     * @dev Returns the name of the token.\n', '     */\n', '    function name() public override view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    constructor (\n', '        string memory __name,\n', '        string memory __symbol,\n', '        uint256 __initialSupply\n', '    ) public {\n', '        _name = __name;\n', '        _symbol = __symbol;\n', '        _decimals = 18;\n', '        xauScalingFactor = BASE;\n', '        initialSupply = __initialSupply;\n', '        initialSupplyUnderlying = _toUnderlying(__initialSupply);\n', '        _totalSupply = __initialSupply;\n', '        _balances[address(msg.sender)] = initialSupplyUnderlying;\n', '        contractStartTimestamp = block.timestamp;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the symbol of the token, usually a shorter version of the\n', '     * name.\n', '     */\n', '    function symbol() public override view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns the number of decimals used to get its user representation.\n', '     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n', '     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n', '     *\n', '     * Tokens usually opt for a value of 18, imitating the relationship between\n', '     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n', '     * called.\n', '     *\n', '     * NOTE: This information is only used for _display_ purposes: it in\n', '     * no way affects any of the arithmetic of the contract, including\n', '     * {IERC20-balanceOf} and {IERC20-transfer}.\n', '     */\n', '    function decimals() public override view returns (uint8) {\n', '        return _decimals;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-totalSupply}.\n', '     */\n', '    function totalSupply() public override view returns (uint256) {\n', '        return _totalSupply;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-balanceOf}.\n', '     */\n', '    // function balanceOf(address account) public override returns (uint256) {\n', '    //     return _balances[account];\n', '    // }\n', '    function balanceOf(address _owner) public override view returns (uint256) {\n', '        return _fromUnderlying(_balances[_owner]);\n', '    }\n', '\n', '    /** @notice Currently returns the internal storage amount\n', '    * @param who The address to query.\n', '    * @return The underlying balance of the specified address.\n', '    */\n', '    function balanceOfUnderlying(address who)\n', '      external\n', '      override\n', '      view\n', '      returns (uint256)\n', '    {\n', '      return _balances[who];\n', '    }\n', '\n', '    /**\n', '    * @notice Computes the current max scaling factor\n', '    */\n', '    function maxScalingFactor()\n', '        external\n', '        override\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _maxScalingFactor();\n', '    }\n', '\n', '    function _maxScalingFactor()\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        // scaling factor can only go up to 2**256-1 = initialSupplyUnderlying * xauScalingFactor\n', '        // this is used to check if xauScalingFactor will be too high to compute balances when rebasing.\n', '        return uint256(-1) / initialSupplyUnderlying;\n', '    }\n', '\n', '    function fromUnderlying(uint256 underlying)\n', '        external\n', '        override\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _fromUnderlying(underlying);\n', '    }\n', '\n', '    function toUnderlying(uint256 value)\n', '        external\n', '        override\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _toUnderlying(value);\n', '    }\n', '\n', '    function _fromUnderlying(uint256 underlying)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return underlying.mul(xauScalingFactor).div(internalDecimals);\n', '    }\n', '\n', '    function _toUnderlying(uint256 value)\n', '        internal\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return value.mul(internalDecimals).div(xauScalingFactor);\n', '    }\n', '\n', '    function scalingFactor() \n', '        external\n', '        override\n', '        view \n', '        returns (uint256) \n', '    {\n', '        return xauScalingFactor;\n', '    }\n', '\n', '    /**\n', '    * @notice Initiates a new rebase operation, provided the minimum time period has elapsed.\n', '    *\n', '    * @dev The supply adjustment equals (totalSupply * DeviationFromTargetRate) / rebaseLag\n', '    *      Where DeviationFromTargetRate is (MarketOracleRate - targetRate) / targetRate\n', '    *      and targetRate is CpiOracleRate / baseCpi\n', '    */\n', '    function rebase(\n', '        uint256 epoch,\n', '        uint256 indexDelta,\n', '        bool positive\n', '    )\n', '        external\n', '        override\n', '        onlyRebaser\n', '        returns (uint256)\n', '    {\n', '        // no change\n', '        if (indexDelta == 0) {\n', '          emit Rebase(epoch, xauScalingFactor, xauScalingFactor);\n', '          return _totalSupply;\n', '        }\n', '\n', '        // for events\n', '        uint256 oldScalingFactor = xauScalingFactor;\n', '\n', '        if (!positive) {\n', '            // negative rebase, decrease scaling factor\n', '            xauScalingFactor = xauScalingFactor.mul(BASE.sub(indexDelta)).div(BASE);\n', "            require(xauScalingFactor > 0);  // FIX: ensure that scaling factor won't drop down to zero as this would be unrecoverable\n", '        } else {\n', '            // positive reabse, increase scaling factor\n', '            uint256 newScalingFactor = xauScalingFactor.mul(BASE.add(indexDelta)).div(BASE);\n', '            if (newScalingFactor < _maxScalingFactor()) {\n', '                xauScalingFactor = newScalingFactor;\n', '            } else {\n', '                xauScalingFactor = _maxScalingFactor();\n', '            }\n', '        }\n', '\n', '        // update total supply, correctly\n', '        _totalSupply = _fromUnderlying(initialSupplyUnderlying);\n', '\n', '        emit Rebase(epoch, oldScalingFactor, xauScalingFactor);\n', '        return _totalSupply;\n', '    }\n', '\n', '    /** @notice sets the rebaser\n', '     * @param _rebaser The address of the rebaser contract to use for authentication.\n', '     */\n', '    function setRebaser(address _rebaser)\n', '        external\n', '        override\n', '        onlyOwner\n', '    {\n', '        address oldRebaser = rebaser;\n', '        rebaser = _rebaser;\n', '        emit NewRebaser(oldRebaser, _rebaser);\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transfer}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `recipient` cannot be the zero address.\n', '     * - the caller must have a balance of at least `amount`.\n', '     */\n', '    function transfer(address recipient, uint256 amount)\n', '        public\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        _transfer(_msgSender(), recipient, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-allowance}.\n', '     */\n', '    function allowance(address owner, address spender)\n', '        public\n', '        virtual\n', '        override\n', '        view\n', '        returns (uint256)\n', '    {\n', '        return _allowances[owner][spender];\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-approve}.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function approve(address spender, uint256 amount)\n', '        public\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        _approve(_msgSender(), spender, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev See {IERC20-transferFrom}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance. This is not\n', '     * required by the EIP. See the note at the beginning of {ERC20};\n', '     *\n', '     * Requirements:\n', '     * - `sender` and `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', "     * - the caller must have allowance for ``sender``'s tokens of at least\n", '     * `amount`.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) public virtual override returns (bool) {\n', '        _transfer(sender, recipient, amount);\n', '        _approve(\n', '            sender,\n', '            _msgSender(),\n', '            _allowances[sender][_msgSender()].sub(\n', '                amount,\n', '                "ERC20: transfer amount exceeds allowance"\n', '            )\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically increases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function increaseAllowance(address spender, uint256 addedValue)\n', '        public\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        _approve(\n', '            _msgSender(),\n', '            spender,\n', '            _allowances[_msgSender()][spender].add(addedValue)\n', '        );\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n', '     *\n', '     * This is an alternative to {approve} that can be used as a mitigation for\n', '     * problems described in {IERC20-approve}.\n', '     *\n', '     * Emits an {Approval} event indicating the updated allowance.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `spender` cannot be the zero address.\n', '     * - `spender` must have allowance for the caller of at least\n', '     * `subtractedValue`.\n', '     */\n', '    function decreaseAllowance(address spender, uint256 subtractedValue)\n', '        public\n', '        virtual\n', '        override\n', '        returns (bool)\n', '    {\n', '        _approve(\n', '            _msgSender(),\n', '            spender,\n', '            _allowances[_msgSender()][spender].sub(\n', '                subtractedValue,\n', '                "ERC20: decreased allowance below zero"\n', '            )\n', '        );\n', '        return true;\n', '    }\n', '\n', '    address public override transferHandler;\n', '\n', '    function setTransferHandler(address _transferHandler)\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        address oldTransferHandler = transferHandler;\n', '        transferHandler = _transferHandler;\n', '        emit NewTransferHandler(oldTransferHandler, _transferHandler);        \n', '    }\n', '\n', '    address public override feeDistributor;\n', '\n', '    function setFeeDistributor(address _feeDistributor)\n', '        public\n', '        override\n', '        onlyOwner\n', '    {\n', '        address oldFeeDistributor = feeDistributor;\n', '        feeDistributor = _feeDistributor;\n', '        emit NewFeeDistributor(oldFeeDistributor, _feeDistributor);        \n', '    }\n', '\n', '    /**\n', '     * @dev Moves tokens `amount` from `sender` to `recipient`.\n', '     *\n', '     * This is internal function is equivalent to {transfer}, and can be used to\n', '     * e.g. implement automatic token fees, slashing mechanisms, etc.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `sender` cannot be the zero address.\n', '     * - `recipient` cannot be the zero address.\n', '     * - `sender` must have a balance of at least `amount`.\n', '     */\n', '    function _transfer(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) internal virtual {\n', '        require(sender != address(0), "ERC20: transfer from the zero address");\n', '        require(recipient != address(0), "ERC20: transfer to the zero address");\n', '        \n', '        // Divide by current scaling factor to get underlying balance\n', '        // note, this means as scaling factor grows, dust will be untransferrable.\n', '        // minimum transfer value == xauScalingFactor / 1e24;\n', '\n', '        // get amount in underlying\n', '        uint256 underlying = _toUnderlying(amount);\n', '\n', '        _balances[sender] = _balances[sender].sub(\n', '            underlying,\n', '            "ERC20: transfer amount exceeds balance"\n', '        );\n', '        \n', '        (uint256 transferToAmount, uint256 transferToFeeDistributorAmount) = IFeeApprover(transferHandler).calculateAmountsAfterFee(sender, recipient, underlying);\n', '\n', '        // Addressing a broken checker contract\n', '        require(transferToAmount.add(transferToFeeDistributorAmount) == underlying, "Math broke, does gravity still work?");\n', '\n', '        _balances[recipient] = _balances[recipient].add(transferToAmount);\n', '        emit Transfer(sender, recipient, _fromUnderlying(transferToAmount));\n', '\n', '        \n', '        if (transferToFeeDistributorAmount > 0 && feeDistributor != address(0)) {\n', '            _balances[feeDistributor] = _balances[feeDistributor].add(transferToFeeDistributorAmount);\n', '            emit Transfer(sender, feeDistributor, _fromUnderlying(transferToFeeDistributorAmount));\n', '            if (feeDistributor != address(0)) {\n', '                IXAUVault(feeDistributor).addPendingRewards(transferToFeeDistributorAmount);\n', '            }\n', '        }\n', '    }\n', '\n', '    /**\n', '     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n', '     *\n', '     * This is internal function is equivalent to `approve`, and can be used to\n', '     * e.g. set automatic allowances for certain subsystems, etc.\n', '     *\n', '     * Emits an {Approval} event.\n', '     *\n', '     * Requirements:\n', '     *\n', '     * - `owner` cannot be the zero address.\n', '     * - `spender` cannot be the zero address.\n', '     */\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount\n', '    ) internal virtual {\n', '        require(owner != address(0), "ERC20: approve from the zero address");\n', '        require(spender != address(0), "ERC20: approve to the zero address");\n', '\n', '        _allowances[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Sets {decimals} to a value other than the default one of 18.\n', '     *\n', '     * WARNING: This function should only be called from the constructor. Most\n', '     * applications that interact with token contracts will not expect\n', '     * {decimals} to ever change, and may work incorrectly if it does.\n', '     */\n', '    function _setupDecimals(uint8 decimals_) internal {\n', '        _decimals = decimals_;\n', '    }\n', '\n', '    // Gives governance ability to recover any ERC20 tokens mistakenly sent to this contract address.\n', '    function recoverERC20(\n', '        address token,\n', '        address to,\n', '        uint256 amount\n', '    )\n', '        external\n', '        override\n', '        onlyOwner\n', '        returns (bool)\n', '    {\n', '        return IERC20(token).transfer(to, amount);\n', '    }\n', '\n', '}']