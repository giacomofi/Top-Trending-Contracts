['/**\n', ' *Submitted for verification at Etherscan.io on 2021-07-15\n', '*/\n', '\n', '// SPDX-License-Identifier: UNLICENSED\n', '\n', 'pragma solidity ^0.8.6;\n', '\n', '// BigShortBets.com sale contract - via StableCoins and ETH\n', '//\n', '// USE ONLY OWN WALLET (Metamask, Trezor, Ledger...)\n', '// DO NOT SEND FROM EXCHANGES OR ANY SERVICES\n', '//\n', '// Use ONLY ETH network, ERC20 tokens (Not Binance/Tron/whatever!)\n', '//\n', '// Set approval to contract address or use USDC authorization first\n', '//\n', '// DO NOT SEND STABLE TOKENS DIRECTLY - IT WILL NOT COUNT THAT!\n', '//\n', '// send ONLY round number of USDT/USDC/DAI!\n', '// ie 20, 500, 2000 NOT 20.1, 500.5, 2000.3\n', '// contract will IGNORE decimals!\n', '//\n', '// Need 150k gas limit.\n', '// Use proper pay* function\n', 'contract BigShortBetsSale {\n', '    /// max tokens per user is 15000 as $15000 is AML limit\n', '    uint256 public constant maxTokens = 15000 * 1 ether;\n', '\n', '    /// contract starts accepting transfers\n', '    uint256 public immutable dateStart;\n', '    /// hard time limit\n', '    uint256 public immutable dateEnd;\n', '\n', '    /// total collected USD\n', '    uint256 public usdCollected;\n', '\n', '    /// sale is limited by tokens count\n', '    uint256 public immutable tokensLimit;\n', '\n', '    /// tokens sold in this sale\n', '    uint256 public tokensSold;\n', '\n', '    uint256 private constant DECIMALS_DAI = 18;\n', '    uint256 private constant DECIMALS_USD = 6;\n', '\n', '    // addresses of tokens\n', '    address public immutable usdt;\n', '    address public immutable usdc;\n', '    address public immutable dai;\n', '    address public immutable oracle;\n', '\n', '    address public owner;\n', '    address public newOwner;\n', '\n', '    bool public saleEnded;\n', '\n', '    // deposited USD tokens per token address\n', '    mapping(address => uint256) private _deposited;\n', '\n', '    /// Tokens bought by user\n', '    mapping(address => uint256) public tokensBoughtOf;\n', '\n', '    event AcceptedUSD(address indexed user, uint256 amount);\n', '    event AcceptedETH(address indexed user, uint256 amount);\n', '\n', '    string constant ERR_TRANSFER = "Token transfer failed";\n', '    string constant ERR_SALE_LIMIT = "Token sale limit reached";\n', '    string constant ERR_AML = "AML sale limit reached";\n', '    string constant ERR_SOON = "SOON";\n', '\n', '    /**\n', '    Contract constructor\n', '    @param _owner adddress of contract owner\n', '    @param _tokensLimit maximum tokens that can be sold (round, ie 320123)\n', '    @param _startDate sale start timestamp\n', '    @param _endDate sale end timestamp\n', '    @param _usdt USDT token address\n', '    @param _usdc USDC token address\n', '    @param _dai DAI token address\n', '    @param _oracle Chainlink USD/ETH oracle address\n', '     */\n', '    constructor(\n', '        address _owner,\n', '        uint256 _tokensLimit, // 3398743\n', '        uint256 _startDate, // 15-07-2020 20:00 CEST (UTC +2)\n', '        uint256 _endDate, // 15-08-2020 20:00 CEST (UTC +2)\n', '        address _usdt,\n', '        address _usdc,\n', '        address _dai,\n', '        address _oracle\n', '    ) {\n', '        owner = _owner;\n', '        tokensLimit = _tokensLimit * 1 ether;\n', '        dateStart = _startDate;\n', '        dateEnd = _endDate;\n', '        usdt = _usdt;\n', '        usdc = _usdc;\n', '        dai = _dai;\n', '        oracle = _oracle;\n', '\n', '        /**\n', '        mainnet:\n', '        usdt=0xdAC17F958D2ee523a2206206994597C13D831ec7;\n', '        usdc=0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n', '        dai=0x6B175474E89094C44Da98b954EedeAC495271d0F;\n', '        0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419 chainlink ETH/USD oracle\n', '        */\n', '    }\n', '\n', '    /**\n', '    Pay in using USDC, use approve/transferFrom\n', '    @param amount number of USDC (with decimals)\n', '    */\n', '    function payUSDC(uint256 amount) external {\n', '        require(\n', '            INterfaces(usdc).transferFrom(msg.sender, address(this), amount),\n', '            ERR_TRANSFER\n', '        );\n', '        _pay(msg.sender, amount / (10**DECIMALS_USD));\n', '        _deposited[usdc] += amount;\n', '    }\n', '\n', '    /**\n', '    Pay in using USDT, need set approval first\n', '    @param amount USDT amount (with decimals)\n', '    */\n', '    function payUSDT(uint256 amount) external {\n', '        IUsdt(usdt).transferFrom(msg.sender, address(this), amount);\n', '        _pay(msg.sender, amount / (10**DECIMALS_USD));\n', '        _deposited[usdt] += amount;\n', '    }\n', '\n', '    /**\n', '    Pay in using DAI, need set approval first\n', '    @param amount number of DAI (with decimals)\n', '    */\n', '    function payDAI(uint256 amount) external {\n', '        require(\n', '            INterfaces(dai).transferFrom(msg.sender, address(this), amount),\n', '            ERR_TRANSFER\n', '        );\n', '        _pay(msg.sender, amount / (10**DECIMALS_DAI));\n', '        _deposited[dai] += amount;\n', '    }\n', '\n', '    //\n', '    // accept ETH\n', '    //\n', '\n', '    // takes about 50k gas\n', '    receive() external payable {\n', '        _payEth(msg.sender, msg.value);\n', '    }\n', '\n', '    function payETH() external payable {\n', '        _payEth(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '    Get ETH price from Chainlink.\n', '    @return ETH price in USD with 18 decimals\n', '    */\n', '    function tokensPerEth() public view returns (uint256) {\n', '        int256 answer;\n', '        (, answer, , , ) = INterfaces(oracle).latestRoundData();\n', '        // need 18 decimals\n', '        return uint256(answer * (10**10));\n', '    }\n', '\n', '    /**\n', '    How much tokens left to sale\n', '    */\n', '    function tokensLeft() external view returns (uint256) {\n', '        return tokensLimit - tokensSold;\n', '    }\n', '\n', '    function _payEth(address user, uint256 amount) internal notEnded {\n', '        uint256 sold = (amount * tokensPerEth()) / 1 ether;\n', '        tokensSold += sold;\n', '        require(tokensSold <= tokensLimit, ERR_SALE_LIMIT);\n', '        tokensBoughtOf[user] += sold;\n', '        require(tokensBoughtOf[user] <= maxTokens, ERR_AML);\n', '        emit AcceptedETH(user, amount);\n', '    }\n', '\n', '    function _pay(address user, uint256 usd) internal notEnded {\n', '        uint256 sold = usd * 1 ether; // price is $1\n', '        tokensSold += sold;\n', '        require(tokensSold <= tokensLimit, ERR_SALE_LIMIT);\n', '        tokensBoughtOf[user] += sold;\n', '        require(tokensBoughtOf[user] <= maxTokens, ERR_AML);\n', '        emit AcceptedUSD(user, usd);\n', '    }\n', '\n', '    //\n', '    // modifiers\n', '    //\n', '\n', '    modifier notEnded() {\n', '        require(!saleEnded, "Sale ended");\n', '        require(\n', '            block.timestamp > dateStart && block.timestamp < dateEnd,\n', '            "Too soon or too late"\n', '        );\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == owner, "Only for contract Owner");\n', '        _;\n', '    }\n', '\n', '    //\n', '    // Rick mode\n', '    //\n', '\n', '    /// Take out all stables and ETH\n', '    /// Possible after timeout or after sell 90%\n', '    /// Also closes sale\n', '    function takeAll() external onlyOwner {\n', '        require(\n', '            tokensSold > ((tokensLimit / 10) * 9) || block.timestamp > dateEnd,\n', '            ERR_SOON\n', '        );\n', '        saleEnded = true; //just to save gas for ppl that want buy too late\n', '        uint256 amt = INterfaces(usdt).balanceOf(address(this));\n', '        if (amt > 0) {\n', '            IUsdt(usdt).transfer(owner, amt);\n', '        }\n', '        amt = INterfaces(usdc).balanceOf(address(this));\n', '        if (amt > 0) {\n', '            require(INterfaces(usdc).transfer(owner, amt), ERR_TRANSFER);\n', '        }\n', '        amt = INterfaces(dai).balanceOf(address(this));\n', '        if (amt > 0) {\n', '            require(INterfaces(dai).transfer(owner, amt), ERR_TRANSFER);\n', '        }\n', '        amt = address(this).balance;\n', '        if (amt > 0) {\n', '            payable(owner).transfer(amt);\n', '        }\n', '    }\n', '\n', '    /// we can recover any ERC20 token send in wrong way... for price!\n', '    function recoverErc20(address token) external onlyOwner {\n', '        uint256 amt = INterfaces(token).balanceOf(address(this));\n', '        // do not take deposits\n', '        amt -= _deposited[token];\n', '        if (amt > 0) {\n', '            IUsdt(token).transfer(owner, amt); // use broken ERC20 to ignore return value\n', '        }\n', '    }\n', '\n', '    /// should not be needed, but...\n', '    function recoverEth() external onlyOwner {\n', '        require(block.timestamp > dateEnd, ERR_SOON);\n', '        payable(owner).transfer(address(this).balance);\n', '    }\n', '\n', '    function changeOwner(address _newOwner) external onlyOwner {\n', '        newOwner = _newOwner;\n', '    }\n', '\n', '    function acceptOwnership() external {\n', '        require(\n', '            msg.sender != address(0) && msg.sender == newOwner,\n', '            "Only NewOwner"\n', '        );\n', '        newOwner = address(0);\n', '        owner = msg.sender;\n', '    }\n', '}\n', '\n', '// Interfaces for contract interaction\n', 'interface INterfaces {\n', '    function balanceOf(address) external returns (uint256);\n', '\n', '    function transfer(address, uint256) external returns (bool);\n', '\n', '    function transferFrom(\n', '        address,\n', '        address,\n', '        uint256\n', '    ) external returns (bool);\n', '\n', '    // chainlink ETH/USD oracle\n', '    // answer|int256 :  216182781556 - 8 decimals\n', '    function latestRoundData()\n', '        external\n', '        view\n', '        returns (\n', '            uint80 roundId,\n', '            int256 answer,\n', '            uint256 startedAt,\n', '            uint256 updatedAt,\n', '            uint80 answeredInRound\n', '        );\n', '}\n', '\n', '// USDT is not ERC-20 compliant, not returning true on transfers\n', 'interface IUsdt {\n', '    function transfer(address, uint256) external;\n', '\n', '    function transferFrom(\n', '        address,\n', '        address,\n', '        uint256\n', '    ) external;\n', '}\n', '\n', '// rav3n_pl was here']