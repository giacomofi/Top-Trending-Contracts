['// SPDX-License-Identifier: J-J-J-JENGA!!!\n', 'pragma solidity ^0.7.4;\n', '\n', '/* ROOTKIT:\n', 'A floor calculator (to use with ERC31337) for RootKit uniswap pairs\n', 'Ensures 100% of accessible funds are backed at all times\n', '*/\n', '\n', 'import "./IFloorCalculator.sol";\n', 'import "./RootKit.sol";\n', 'import "./SafeMath.sol";\n', 'import "./UniswapV2Library.sol";\n', 'import "./IUniswapV2Factory.sol";\n', 'import "./TokensRecoverable.sol";\n', '\n', 'contract RootKitTwoPoolCalculator is IFloorCalculator, TokensRecoverable\n', '{\n', '    using SafeMath for uint256;\n', '    uint256 public totalIgnored;\n', '\n', '    RootKit immutable rootKit;\n', '    IUniswapV2Factory immutable uniswapV2Factory;\n', '\n', '    constructor(RootKit _rootKit, IUniswapV2Factory _uniswapV2Factory)\n', '    {\n', '        rootKit = _rootKit;\n', '        uniswapV2Factory = _uniswapV2Factory;\n', '    }    \n', '\n', '    function setIgnoredAddresses(address[] memory ignoredAddresses) public ownerOnly()\n', '    {\n', '        totalIgnored = 0;\n', '        for (uint i = 0; i < ignoredAddresses.length; i++) {\n', '            totalIgnored = totalIgnored.add(rootKit.balanceOf(ignoredAddresses[i]));\n', '        }\n', '    }\n', '\n', '    function addExtraIgnoreAddress(address extraToIgnore) public ownerOnly(){\n', '        totalIgnored = totalIgnored.add(rootKit.balanceOf(extraToIgnore));\n', '    }\n', '\n', '    function calculateExcessInPool(IERC20 token, address pair, uint256 liquidityShare, uint256 rootKitTotalSupply, uint256 rootKitPoolsLiquidity) internal view returns (uint256)\n', '    {\n', '        uint256 freeRootKit = (rootKitTotalSupply.sub(rootKitPoolsLiquidity)).mul(liquidityShare).div(1e12);\n', '\n', '        uint256 sellAllProceeds = 0;\n', '        if (freeRootKit > 0) {\n', '            address[] memory path = new address[](2);\n', '            path[0] = address(rootKit);\n', '            path[1] = address(token);\n', '            uint256[] memory amountsOut = UniswapV2Library.getAmountsOut(address(uniswapV2Factory), freeRootKit, path);\n', '            sellAllProceeds = amountsOut[1];\n', '        }\n', '\n', '        uint256 backingInPool = token.balanceOf(pair);\n', '        if (backingInPool <= sellAllProceeds) { return 0; }\n', '        uint256 excessInPool = backingInPool - sellAllProceeds;\n', '\n', '        return excessInPool;\n', '    }\n', '\n', '    function calculateExcessInPools(IERC20 wrappedToken, IERC20 backingToken) public view returns (uint256)\n', '    {\n', '        address kethPair = UniswapV2Library.pairFor(address(uniswapV2Factory), address(rootKit), address(backingToken));\n', '        address wethPair = UniswapV2Library.pairFor(address(uniswapV2Factory), address(rootKit), address(wrappedToken));   \n', '        \n', '        uint256 rootKitTotalSupply = rootKit.totalSupply().sub(totalIgnored);\n', '        uint256 rootKitPoolsLiquidity = rootKit.balanceOf(kethPair).add(rootKit.balanceOf(wethPair));\n', '        uint256 ethPoolsLiquidity = backingToken.balanceOf(kethPair).add(wrappedToken.balanceOf(wethPair));\n', '\n', '        uint256 rootLiquidityShareInKethPair = rootKit.balanceOf(kethPair).mul(1e12).div(rootKitPoolsLiquidity);\n', '        uint256 kethLiquidityShareInKethPair = backingToken.balanceOf(kethPair).mul(1e12).div(ethPoolsLiquidity);\n', '        uint256 avgLiquidityShareInKethPair = (rootLiquidityShareInKethPair.add(kethLiquidityShareInKethPair)).div(2);\n', '        uint256 one = 1e12;\n', '\n', '        uint256 excessInKethPool = calculateExcessInPool(backingToken, kethPair, avgLiquidityShareInKethPair, rootKitTotalSupply, rootKitPoolsLiquidity);\n', '        uint256 excessInWethPool = calculateExcessInPool(wrappedToken, wethPair, (one).sub(avgLiquidityShareInKethPair), rootKitTotalSupply, rootKitPoolsLiquidity);\n', '        return excessInKethPool.add(excessInWethPool);\n', '    }\n', '\n', '    function calculateSubFloor(IERC20 wrappedToken, IERC20 backingToken) public override view returns (uint256) // backing token = keth\n', '    {        \n', '        uint256 excessInPools = calculateExcessInPools(wrappedToken, backingToken);\n', '\n', '        uint256 requiredBacking = backingToken.totalSupply().sub(excessInPools);\n', '        uint256 currentBacking = wrappedToken.balanceOf(address(backingToken));\n', '        if (requiredBacking >= currentBacking) { return 0; }\n', '        return currentBacking - requiredBacking;\n', '    }\n', '}']