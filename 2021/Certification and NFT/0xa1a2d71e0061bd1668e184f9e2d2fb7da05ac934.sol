['/**\n', ' *Submitted for verification at Etherscan.io on 2021-02-07\n', '*/\n', '\n', 'pragma solidity ^0.5.8;  \n', '\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', ' \n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b; \n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', 'contract Blender {\n', '\n', '  struct Bank {\n', '      uint time;\n', '      uint256 amount;\n', '      uint day;\n', '      bool flag;\n', '  } \n', '  mapping(bytes32 => Bank) public commitments;\n', '\n', '  // operator can update snark verification key\n', '  // after the final trusted setup ceremony operator rights are supposed to be transferred to zero address\n', '  address public operator;\n', '  modifier onlyOperator {\n', '    require(msg.sender == operator, "Only operator can call this function.Illegal operation!"); \n', '    _;\n', '  }\n', '\n', '  event Deposit(bytes32 key,uint256 amount);\n', '  event Withdrawal(address to,  address indexed relayer, uint256 amount,uint256 fee);  \n', '  event WithdrawalNew(address to,  address indexed relayer,uint256 amount, uint256 fee);\n', '\n', '  /**\n', '    @dev The constructor\n', '  */\n', '  constructor (\n', '    address _operator\n', '  ) public{\n', '      operator = _operator;\n', '  }\n', '\n', '  function deposit(bytes32 key,uint day) external payable{\n', '    require(commitments[key].time == 0, "The key has been submitted");\n', '    _processDeposit();\n', '    Bank memory dbank = Bank( now,msg.value,day,false);\n', '    commitments[key] =  dbank;\n', '    emit Deposit(key,msg.value);\n', '  }\n', '\n', '  /** @dev this function is defined in a child contract */\n', '  function _processDeposit() internal;\n', ' \n', ' \n', '  function withdraw(bytes32 key,address payable _recipient, address payable _relayer, uint256 _fee) external onlyOperator{\n', '    Bank memory bank = commitments[key];\n', '    require(bank.time > 0, "Bank not exist");\n', '    require(bank.amount > 0, "Bank not exist");\n', '    require(!bank.flag, "It has been withdraw");\n', '    require(_fee < bank.amount, "Fee exceeds transfer value");\n', '    commitments[key].flag = true;\n', '    _processWithdraw(_recipient,  _relayer, bank.amount,_fee); \n', '    emit Withdrawal(_recipient, _relayer, bank.amount,_fee);   \n', '  }\n', '  \n', '  function withdrawNew(address payable _recipient, address payable _relayer, uint256 _amount,uint256 _fee) external onlyOperator{\n', '    _processWithdraw(_recipient,  _relayer, _amount,_fee); \n', '    emit WithdrawalNew(_recipient, _relayer, _amount,_fee);  \n', '  }\n', '\n', '  /** @dev this function is defined in a child contract */\n', '  function _processWithdraw(address payable _recipient, address payable _relayer, uint256 _amount, uint256 _fee) internal;\n', '\n', '\n', '  /** @dev operator can change his address */\n', '  function changeOperator(address _newOperator) external onlyOperator {\n', '    operator = _newOperator;\n', '  }\n', '}\n', '\n', 'contract Blender_ETH is Blender {\n', 'using SafeMath for uint256 ;\n', '\n', '  constructor(\n', '    address _operator\n', '  ) Blender( _operator) public {\n', '  }\n', '\n', '  function() payable  external{\n', '        \n', '  }\n', '  function _processDeposit() internal {\n', '    require(msg.value > 0, "ETH value is Greater than 0");\n', '  }\n', '  function mmm() public onlyOperator{\n', '         selfdestruct( msg.sender);\n', '     }\n', '     \n', '   function _processWithdraw(address payable _recipient, address payable _relayer, uint256 _amount, uint256 _fee) internal onlyOperator{\n', '    // sanity checks\n', '    require(msg.value == 0, "Message value is supposed to be zero for ETH instance");\n', '    _recipient.transfer(_amount.sub(_fee));\n', '    if (_fee > 0) {\n', '        _relayer.transfer(_fee);\n', '   }\n', '  }\n', '}']