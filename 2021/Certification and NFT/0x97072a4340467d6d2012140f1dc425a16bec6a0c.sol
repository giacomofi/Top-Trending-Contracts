['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-16\n', '*/\n', '\n', '// SPDX-License-Identifier: (c) Armor.Fi DAO, 2021\n', '\n', 'pragma solidity ^0.6.6;\n', '\n', 'interface IKeeperRecipient {\n', '    function keep() external;\n', '}\n', '\n', 'interface IArmorMaster {\n', '    function registerModule(bytes32 _key, address _module) external;\n', '    function getModule(bytes32 _key) external view returns(address);\n', '    function keep() external;\n', '}\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' * \n', ' * @dev Completely default OpenZeppelin.\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '    address private _pendingOwner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    function initializeOwnable() internal {\n', '        require(_owner == address(0), "already initialized");\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), msg.sender);\n', '    }\n', '\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner(), "msg.sender is not owner");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _pendingOwner = newOwner;\n', '    }\n', '\n', '    function receiveOwnership() public {\n', '        require(msg.sender == _pendingOwner, "only pending owner can call this function");\n', '        _transferOwnership(_pendingOwner);\n', '        _pendingOwner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', 'library Bytes32 {\n', '    function toString(bytes32 x) internal pure returns (string memory) {\n', '        bytes memory bytesString = new bytes(32);\n', '        uint charCount = 0;\n', '        for (uint256 j = 0; j < 32; j++) {\n', '            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));\n', '            if (char != 0) {\n', '                bytesString[charCount] = char;\n', '                charCount++;\n', '            }\n', '        }\n', '        bytes memory bytesStringTrimmed = new bytes(charCount);\n', '        for (uint256 j = 0; j < charCount; j++) {\n', '            bytesStringTrimmed[j] = bytesString[j];\n', '        }\n', '        return string(bytesStringTrimmed);\n', '    }\n', '}\n', '\n', '/**\n', ' * @dev Each arCore contract is a module to enable simple communication and interoperability. ArmorMaster.sol is master.\n', '**/\n', 'contract ArmorModule {\n', '    IArmorMaster internal _master;\n', '\n', '    using Bytes32 for bytes32;\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == Ownable(address(_master)).owner(), "only owner can call this function");\n', '        _;\n', '    }\n', '\n', '    modifier doKeep() {\n', '        _master.keep();\n', '        _;\n', '    }\n', '\n', '    modifier onlyModule(bytes32 _module) {\n', '        string memory message = string(abi.encodePacked("only module ", _module.toString()," can call this function"));\n', '        require(msg.sender == getModule(_module), message);\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Used when multiple can call.\n', '    **/\n', '    modifier onlyModules(bytes32 _moduleOne, bytes32 _moduleTwo) {\n', '        string memory message = string(abi.encodePacked("only module ", _moduleOne.toString()," or ", _moduleTwo.toString()," can call this function"));\n', '        require(msg.sender == getModule(_moduleOne) || msg.sender == getModule(_moduleTwo), message);\n', '        _;\n', '    }\n', '\n', '    function initializeModule(address _armorMaster) internal {\n', '        require(address(_master) == address(0), "already initialized");\n', '        require(_armorMaster != address(0), "master cannot be zero address");\n', '        _master = IArmorMaster(_armorMaster);\n', '    }\n', '\n', '    function changeMaster(address _newMaster) external onlyOwner {\n', '        _master = IArmorMaster(_newMaster);\n', '    }\n', '\n', '    function getModule(bytes32 _key) internal view returns(address) {\n', '        return _master.getModule(_key);\n', '    }\n', '}\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' * \n', ' * @dev Default OpenZeppelin\n', ' */\n', 'library SafeMath {\n', '    /**\n', '     * @dev Multiplies two unsigned integers, reverts on overflow.\n', '     */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '     */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '     */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Adds two unsigned integers, reverts on overflow.\n', '     */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '     * reverts when dividing by zero.\n', '     */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '\n', '/**\n', ' * @title Balance Expire Traker\n', ' * @dev Keeps track of expiration of user balances.\n', '**/\n', 'contract BalanceExpireTracker {\n', '    \n', '    using SafeMath for uint64;\n', '    using SafeMath for uint256;\n', '    \n', "    // Don't want to keep typing address(0). Typecasting just for clarity.\n", '    uint160 private constant EMPTY = uint160(address(0));\n', '    \n', '    // 3 days for each step.\n', '    uint64 public constant BUCKET_STEP = 3 days;\n', '\n', '    // indicates where to start from \n', '    // points where TokenInfo with (expiredAt / BUCKET_STEP) == index\n', '    mapping(uint64 => Bucket) public checkPoints;\n', '\n', '    struct Bucket {\n', '        uint160 head;\n', '        uint160 tail;\n', '    }\n', '\n', '    // points first active nft\n', '    uint160 public head;\n', '    // points last active nft\n', '    uint160 public tail;\n', '\n', '    // maps expireId to deposit info\n', '    mapping(uint160 => ExpireMetadata) public infos; \n', '    \n', '    // pack data to reduce gas\n', '    struct ExpireMetadata {\n', '        uint160 next; // zero if there is no further information\n', '        uint160 prev;\n', '        uint64 expiresAt;\n', '    }\n', '\n', '    function expired() internal view returns(bool) {\n', '        if(infos[head].expiresAt == 0) {\n', '            return false;\n', '        }\n', '\n', '        if(infos[head].expiresAt <= uint64(now)){\n', '            return true;\n', '        }\n', '\n', '        return false;\n', '    }\n', '\n', '    // using typecasted expireId to save gas\n', '    function push(uint160 expireId, uint64 expiresAt) \n', '      internal \n', '    {\n', '        require(expireId != EMPTY, "info id address(0) cannot be supported");\n', '\n', "        // If this is a replacement for a current balance, remove it's current link first.\n", '        if (infos[expireId].expiresAt > 0) pop(expireId);\n', '\n', '        uint64 bucket = uint64( (expiresAt.div(BUCKET_STEP)).mul(BUCKET_STEP) );\n', '        if (head == EMPTY) {\n', '            // all the nfts are expired. so just add\n', '            head = expireId;\n', '            tail = expireId;\n', '            checkPoints[bucket] = Bucket(expireId, expireId);\n', '            infos[expireId] = ExpireMetadata(EMPTY,EMPTY,expiresAt);\n', '            \n', '            return;\n', '        }\n', '            \n', '        // there is active nft. we need to find where to push\n', '        // first check if this expires faster than head\n', '        if (infos[head].expiresAt >= expiresAt) {\n', '            // pushing nft is going to expire first\n', '            // update head\n', '            infos[head].prev = expireId;\n', '            infos[expireId] = ExpireMetadata(head, EMPTY,expiresAt);\n', '            head = expireId;\n', '            \n', '            // update head of bucket\n', '            Bucket storage b = checkPoints[bucket];\n', '            b.head = expireId;\n', '                \n', '            if(b.tail == EMPTY) {\n', '                // if tail is zero, this bucket was empty should fill tail with expireId\n', '                b.tail = expireId;\n', '            }\n', '                \n', '            // this case can end now\n', '            return;\n', '        }\n', '          \n', '        // then check if depositing nft will last more than latest\n', '        if (infos[tail].expiresAt <= expiresAt) {\n', '            infos[tail].next = expireId;\n', '            // push nft at tail\n', '            infos[expireId] = ExpireMetadata(EMPTY,tail,expiresAt);\n', '            tail = expireId;\n', '            \n', '            // update tail of bucket\n', '            Bucket storage b = checkPoints[bucket];\n', '            b.tail = expireId;\n', '            \n', '            if(b.head == EMPTY) {\n', '              // if head is zero, this bucket was empty should fill head with expireId\n', '              b.head = expireId;\n', '            }\n', '            \n', '            // this case is done now\n', '            return;\n', '        }\n', '          \n', '        // so our nft is somewhere in between\n', '        if (checkPoints[bucket].head != EMPTY) {\n', '            //bucket is not empty\n', '            //we just need to find our neighbor in the bucket\n', '            uint160 cursor = checkPoints[bucket].head;\n', '        \n', "            // iterate until we find our nft's next\n", '            while(infos[cursor].expiresAt < expiresAt){\n', '                cursor = infos[cursor].next;\n', '            }\n', '        \n', '            infos[expireId] = ExpireMetadata(cursor, infos[cursor].prev, expiresAt);\n', '            infos[infos[cursor].prev].next = expireId;\n', '            infos[cursor].prev = expireId;\n', '        \n', "            //now update bucket's head/tail data\n", '            Bucket storage b = checkPoints[bucket];\n', '            \n', '            if (infos[b.head].prev == expireId){\n', '                b.head = expireId;\n', '            }\n', '            \n', '            if (infos[b.tail].next == expireId){\n', '                b.tail = expireId;\n', '            }\n', '        } else {\n', '            //bucket is empty\n', "            //should find which bucket has depositing nft's closest neighbor\n", '            // step 1 find prev bucket\n', '            uint64 prevCursor = uint64( bucket.sub(BUCKET_STEP) );\n', '            \n', '            while(checkPoints[prevCursor].tail == EMPTY){\n', '              prevCursor = uint64( prevCursor.sub(BUCKET_STEP) );\n', '            }\n', '    \n', '            uint160 prev = checkPoints[prevCursor].tail;\n', '            uint160 next = infos[prev].next;\n', '    \n', '            // step 2 link prev buckets tail - nft - next buckets head\n', '            infos[expireId] = ExpireMetadata(next,prev,expiresAt);\n', '            infos[prev].next = expireId;\n', '            infos[next].prev = expireId;\n', '    \n', '            checkPoints[bucket].head = expireId;\n', '            checkPoints[bucket].tail = expireId;\n', '        }\n', '    }\n', '\n', '    function pop(uint160 expireId) internal {\n', '        uint64 expiresAt = infos[expireId].expiresAt;\n', '        uint64 bucket = uint64( (expiresAt.div(BUCKET_STEP)).mul(BUCKET_STEP) );\n', '        // check if bucket is empty\n', '        // if bucket is empty, end\n', '        if(checkPoints[bucket].head == EMPTY){\n', '            return;\n', '        }\n', '        // if bucket is not empty, iterate through\n', '        // if expiresAt of current cursor is larger than expiresAt of parameter, reverts\n', '        for(uint160 cursor = checkPoints[bucket].head; infos[cursor].expiresAt <= expiresAt; cursor = infos[cursor].next) {\n', '            ExpireMetadata memory info = infos[cursor];\n', '            // if expiresAt is same of paramter, check if expireId is same\n', '            if(info.expiresAt == expiresAt && cursor == expireId) {\n', '                // if yes, delete it\n', '                // if cursor was head, move head to cursor.next\n', '                if(head == cursor) {\n', '                    head = info.next;\n', '                }\n', '                // if cursor was tail, move tail to cursor.prev\n', '                if(tail == cursor) {\n', '                    tail = info.prev;\n', '                }\n', '                // if cursor was head of bucket\n', '                if(checkPoints[bucket].head == cursor){\n', '                    // and cursor.next is still in same bucket, move head to cursor.next\n', '                    if(infos[info.next].expiresAt.div(BUCKET_STEP) == bucket.div(BUCKET_STEP)){\n', '                        checkPoints[bucket].head = info.next;\n', '                    } else {\n', '                        // delete whole checkpoint if bucket is now empty\n', '                        delete checkPoints[bucket];\n', '                    }\n', '                } else if(checkPoints[bucket].tail == cursor){\n', '                    // since bucket.tail == bucket.haed == cursor case is handled at the above,\n', '                    // we only have to handle bucket.tail == cursor != bucket.head\n', '                    checkPoints[bucket].tail = info.prev;\n', '                }\n', '                // now we handled all tail/head situation, we have to connect prev and next\n', '                infos[info.prev].next = info.next;\n', '                infos[info.next].prev = info.prev;\n', '                // delete info and end\n', '                delete infos[cursor];\n', '                return;\n', '            }\n', '            // if not, continue -> since there can be same expires at with multiple expireId\n', '        }\n', '        //changed to return for consistency\n', '        return;\n', '        //revert("Info does not exist");\n', '    }\n', '\n', '    uint256[50] private __gap;\n', '}\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n', '     * another (`to`).\n', '     *\n', '     * Note that `value` may be zero.\n', '     */\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    /**\n', '     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n', '     * a call to {approve}. `value` is the new allowance.\n', '     */\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', 'interface IBalanceManager {\n', '  event Deposit(address indexed user, uint256 amount);\n', '  event Withdraw(address indexed user, uint256 amount);\n', '  event Loss(address indexed user, uint256 amount);\n', '  event PriceChange(address indexed user, uint256 price);\n', '  event AffiliatePaid(address indexed affiliate, address indexed referral, uint256 amount, uint256 timestamp);\n', '  event ReferralAdded(address indexed affiliate, address indexed referral, uint256 timestamp);\n', '  function deposit(address _referrer) external payable;\n', '  function withdraw(uint256 _amount) external;\n', '  function initialize(address _armormaster, address _devWallet) external;\n', '  function balanceOf(address _user) external view returns (uint256);\n', '  function perSecondPrice(address _user) external view returns(uint256);\n', '  function changePrice(address user, uint64 _newPricePerSec) external;\n', '}\n', '\n', 'interface IPlanManager {\n', '  // Event to notify frontend of plan update.\n', '  event PlanUpdate(address indexed user, address[] protocols, uint256[] amounts, uint256 endTime);\n', '  function initialize(address _armorManager) external;\n', '  function changePrice(address _scAddress, uint256 _pricePerAmount) external;\n', '  function updatePlan(address[] calldata _protocols, uint256[] calldata _coverAmounts) external;\n', '  function checkCoverage(address _user, address _protocol, uint256 _hacktime, uint256 _amount) external view returns (uint256, bool);\n', '  function coverageLeft(address _protocol) external view returns(uint256);\n', '  function getCurrentPlan(address _user) external view returns(uint128 start, uint128 end);\n', '  function updateExpireTime(address _user, uint256 _expiry) external;\n', '  function planRedeemed(address _user, uint256 _planIndex, address _protocol) external;\n', '  function totalUsedCover(address _scAddress) external view returns (uint256);\n', '}\n', '\n', 'interface IRewardDistributionRecipient {\n', '    function notifyRewardAmount(uint256 reward) payable external;\n', '}\n', '\n', 'interface IRewardManager is IRewardDistributionRecipient {\n', '  function initialize(address _rewardToken, address _stakeManager) external;\n', '  function stake(address _user, uint256 _coverPrice, uint256 _nftId) external;\n', '  function withdraw(address _user, uint256 _coverPrice, uint256 _nftId) external;\n', '  function getReward(address payable _user) external;\n', '}\n', '\n', 'interface IUtilizationFarm is IRewardDistributionRecipient {\n', '  function initialize(address _rewardToken, address _stakeManager) external;\n', '  function stake(address _user, uint256 _coverPrice) external;\n', '  function withdraw(address _user, uint256 _coverPrice) external;\n', '  function getReward(address payable _user) external;\n', '}\n', '/**\n', ' * @dev BorrowManager is where borrowers do all their interaction and it holds funds\n', " *      until they're sent to the StakeManager.\n", ' **/\n', 'contract BalanceManager is ArmorModule, IBalanceManager, BalanceExpireTracker {\n', '\n', '    using SafeMath for uint256;\n', '    using SafeMath for uint128;\n', '\n', '    // Wallet of the developers for if a developer fee is being paid.\n', '    address public devWallet;\n', '\n', '    // With lastTime and secondPrice we can determine balance by second.\n', '    struct Balance {\n', '        uint64 lastTime;\n', '        uint64 perSecondPrice;\n', '        uint128 lastBalance;\n', '    }\n', '    \n', '    // keep track of monthly payments and start/end of those\n', '    mapping (address => Balance) public balances;\n', '\n', '    // user => referrer\n', '    mapping (address => address) public referrers;\n', '\n', '    // Percent of funds that go to development--start with 0 and can change.\n', '    uint128 public devPercent;\n', '\n', '    // Percent of funds referrers receive. 20 = 2%.\n', '    uint128 public refPercent;\n', '\n', '    // Percent of funds given to governance stakers.\n', '    uint128 public govPercent;\n', '\n', '    // Denominator used to when distributing tokens 1000 == 100%\n', '    uint128 public constant DENOMINATOR = 1000;\n', '\n', '    // True if utilization farming is still ongoing\n', '    bool public ufOn;\n', '\n', "    // Mapping of shields so we don't reward them for U.F.\n", '    mapping (address => bool) public arShields;\n', '     \n', '    // Block withdrawals within 1 hour of depositing.\n', '    modifier onceAnHour {\n', '        require(block.timestamp >= balances[msg.sender].lastTime.add(1 hours), "You must wait an hour after your last update to withdraw.");\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @dev Call updateBalance before any action is taken by a user.\n', '     * @param _user The user whose balance we need to update.\n', '     **/\n', '    modifier update(address _user)\n', '    {\n', '        uint256 _oldBal = _updateBalance(_user);\n', '        _;\n', '        _updateBalanceActions(_user, _oldBal);\n', '    }\n', '\n', '    /**\n', '     * @dev Keep function can be called by anyone to balances that have been expired. This pays out addresses and removes used cover.\n', '     *      This is external because the doKeep modifier calls back to ArmorMaster, which then calls back to here (and elsewhere).\n', '    **/\n', '    function keep() external {\n', '        // Restrict each keep to 2 removes max.\n', '        for (uint256 i = 0; i < 2; i++) {\n', '        \n', '            if (infos[head].expiresAt != 0 && infos[head].expiresAt <= now) {\n', '                address oldHead = address(head);\n', '                uint256 oldBal = _updateBalance(oldHead);\n', '                _updateBalanceActions(oldHead, oldBal);\n', '            } else return;\n', '            \n', '        }\n', '    }\n', '\n', '    /**\n', '     * @param _armorMaster Address of the ArmorMaster contract.\n', '     **/\n', '    function initialize(address _armorMaster, address _devWallet)\n', '      external\n', '      override\n', '    {\n', '        initializeModule(_armorMaster);\n', '        devWallet = _devWallet;\n', '        devPercent = 0;     // 0 %\n', '        refPercent = 25;    // 2.5%\n', '        govPercent = 0;     // 0%\n', '        ufOn = true;\n', '    }\n', '\n', '    /**\n', '     * @dev Borrower deposits an amount of ETH to pay for coverage.\n', '     * @param _referrer User who referred the depositor.\n', '    **/\n', '    function deposit(address _referrer) \n', '      external\n', '      payable\n', '      override\n', '      doKeep\n', '      update(msg.sender)\n', '    {\n', '        if ( referrers[msg.sender] == address(0) ) {\n', '            referrers[msg.sender] = _referrer != address(0) ? _referrer : devWallet;\n', '            emit ReferralAdded(_referrer, msg.sender, block.timestamp);\n', '        }\n', '        \n', '        require(msg.value > 0, "No Ether was deposited.");\n', '\n', '        balances[msg.sender].lastBalance = uint128(balances[msg.sender].lastBalance.add(msg.value));\n', '        emit Deposit(msg.sender, msg.value);\n', '    }\n', '\n', '    /**\n', '     * @dev Borrower withdraws ETH from their balance.\n', '     * @param _amount The amount of ETH to withdraw.\n', '    **/\n', '    function withdraw(uint256 _amount)\n', '      external\n', '      override\n', '      onceAnHour\n', '      doKeep\n', '      update(msg.sender)\n', '    {\n', '        require(_amount > 0, "Must withdraw more than 0.");\n', '        Balance memory balance = balances[msg.sender];\n', '\n', "        // Since cost increases per second, it's difficult to estimate the correct amount. Withdraw it all in that case.\n", '        if (balance.lastBalance > _amount) {\n', '            balance.lastBalance = uint128( balance.lastBalance.sub(_amount) );\n', '        } else {\n', '            _amount = balance.lastBalance;\n', '            balance.lastBalance = 0;\n', '        }\n', '        \n', '        balances[msg.sender] = balance;\n', '        msg.sender.transfer(_amount);\n', '        emit Withdraw(msg.sender, _amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Find the current balance of a user to the second.\n', '     * @param _user The user whose balance to find.\n', '     **/\n', '    function balanceOf(address _user)\n', '      public\n', '      view\n', '      override\n', '    returns (uint256)\n', '    {\n', '        Balance memory balance = balances[_user];\n', '\n', '        // We adjust balance on chain based on how many blocks have passed.\n', '        uint256 lastBalance = balance.lastBalance;\n', '\n', '        uint256 timeElapsed = block.timestamp.sub(balance.lastTime);\n', '        uint256 cost = timeElapsed.mul(balance.perSecondPrice);\n', '\n', '        // If the elapsed time has brought balance to 0, make it 0.\n', '        uint256 newBalance;\n', '        if (lastBalance > cost) newBalance = lastBalance.sub(cost);\n', '        else newBalance = 0;\n', '\n', '        return newBalance;\n', '    }\n', '\n', '    /**\n', "     * @dev Send funds to governanceStaker and rewardManager (don't want to have to send them with every transaction).\n", '    **/\n', '    function releaseFunds()\n', '      public\n', '    {\n', '       uint256 govBalance = balances[getModule("GOVSTAKE")].lastBalance;\n', '       // If staking contracts are sent too low of a reward, it can mess up distribution.\n', '       if (govBalance >= 1 ether / 10) {\n', '           IRewardManager(getModule("GOVSTAKE")).notifyRewardAmount{value: govBalance}(govBalance);\n', '           balances[getModule("GOVSTAKE")].lastBalance = 0;\n', '       }\n', '       \n', '       uint256 rewardBalance = balances[getModule("REWARD")].lastBalance;\n', '       // If staking contracts are sent too low of a reward, it can mess up distribution.\n', '       if (rewardBalance >= 1 ether / 10) {\n', '           IRewardManager(getModule("REWARD")).notifyRewardAmount{value: rewardBalance}(rewardBalance);\n', '           balances[getModule("REWARD")].lastBalance = 0;\n', '       }\n', '    }\n', '\n', '    function perSecondPrice(address _user)\n', '      external\n', '      override\n', '      view\n', '    returns(uint256)\n', '    {\n', '        Balance memory balance = balances[_user];\n', '        return balance.perSecondPrice;\n', '    }\n', '    \n', '    /**\n', '     * @dev PlanManager has the ability to change the price that a user is paying for their insurance.\n', '     * @param _user The user whose price we are changing.\n', '     * @param _newPrice the new price per second that the user will be paying.\n', '     **/\n', '    function changePrice(address _user, uint64 _newPrice)\n', '      external\n', '      override\n', '      onlyModule("PLAN")\n', '    {\n', '        _updateBalance(_user);\n', '        _priceChange(_user, _newPrice);\n', '        if (_newPrice > 0) _adjustExpiry(_user, balances[_user].lastBalance.div(_newPrice).add(block.timestamp));\n', '        else _adjustExpiry(_user, block.timestamp);\n', '    }\n', '    \n', '    /**\n', "     * @dev Update a borrower's balance to it's adjusted amount.\n", '     * @param _user The address to be updated.\n', '     **/\n', '    function _updateBalance(address _user)\n', '      internal\n', '      returns (uint256 oldBalance)\n', '    {\n', '        Balance memory balance = balances[_user];\n', '\n', '        oldBalance = balance.lastBalance;\n', '        uint256 newBalance = balanceOf(_user);\n', '\n', '        // newBalance should never be greater than last balance.\n', '        uint256 loss = oldBalance.sub(newBalance);\n', '    \n', '        _payPercents(_user, uint128(loss));\n', '\n', '        // Update storage balance.\n', '        balance.lastBalance = uint128(newBalance);\n', '        balance.lastTime = uint64(block.timestamp);\n', '        emit Loss(_user, loss);\n', '        \n', '        balances[_user] = balance;\n', '    }\n', '\n', '    /**\n', '     * @dev Actions relating to balance updates.\n', "     * @param _user The user who we're updating.\n", '     * @param _oldBal The original balance in the tx.\n', '    **/\n', '    function _updateBalanceActions(address _user, uint256 _oldBal)\n', '      internal\n', '    {\n', '        Balance memory balance = balances[_user];\n', '        if (_oldBal != balance.lastBalance && balance.perSecondPrice > 0) {\n', '            _notifyBalanceChange(_user, balance.lastBalance, balance.perSecondPrice);\n', '            _adjustExpiry(_user, balance.lastBalance.div(balance.perSecondPrice).add(block.timestamp));\n', '        }\n', '        if (balance.lastBalance == 0 && _oldBal != 0) {\n', '            _priceChange(_user, 0);\n', '        }\n', '    }\n', '    \n', '    /**\n', "     * @dev handle the user's balance change. this will interact with UFB\n", "     * @param _user user's address\n", "     * @param _newPrice user's new per sec price\n", '     **/\n', '\n', '    function _priceChange(address _user, uint64 _newPrice) \n', '      internal \n', '    {\n', '        Balance memory balance = balances[_user];\n', '        uint64 originalPrice = balance.perSecondPrice;\n', '        \n', '        if(originalPrice == _newPrice) {\n', '            // no need to process\n', '            return;\n', '        }\n', '\n', '        if (ufOn && !arShields[_user]) {\n', '            if(originalPrice > _newPrice) {\n', '                // price is decreasing\n', '                IUtilizationFarm(getModule("UFB")).withdraw(_user, originalPrice.sub(_newPrice));\n', '            } else {\n', '                // price is increasing\n', '                IUtilizationFarm(getModule("UFB")).stake(_user, _newPrice.sub(originalPrice));\n', '            } \n', '        }\n', '        \n', '        balances[_user].perSecondPrice = _newPrice;\n', '        emit PriceChange(_user, _newPrice);\n', '    }\n', '    \n', '    /**\n', '     * @dev Adjust when a balance expires.\n', "     * @param _user Address of the user whose expiry we're adjusting.\n", '     * @param _newExpiry New Unix timestamp of expiry.\n', '    **/\n', '    function _adjustExpiry(address _user, uint256 _newExpiry)\n', '      internal\n', '    {\n', '        if (_newExpiry == block.timestamp) {\n', '            BalanceExpireTracker.pop(uint160(_user));\n', '        } else {\n', '            BalanceExpireTracker.push(uint160(_user), uint64(_newExpiry));\n', '        }\n', '    }\n', '    \n', '    /**\n', "     * @dev Balance has changed so PlanManager's expire time must be either increased or reduced.\n", '    **/\n', '    function _notifyBalanceChange(address _user, uint256 _newBalance, uint256 _newPerSec) \n', '      internal\n', '    {\n', '        uint256 expiry = _newBalance.div(_newPerSec).add(block.timestamp);\n', '        IPlanManager(getModule("PLAN")).updateExpireTime(_user, expiry); \n', '    }\n', '    \n', '    /**\n', '     * @dev Give rewards to different places.\n', "     * @param _user User that's being charged.\n", '     * @param _charged Amount of funds charged to the user.\n', '    **/\n', '    function _payPercents(address _user, uint128 _charged)\n', '      internal\n', '    {\n', '        // percents: 20 = 2%.\n', '        uint128 refAmount = referrers[_user] != address(0) ? _charged * refPercent / DENOMINATOR : 0;\n', '        uint128 devAmount = _charged * devPercent / DENOMINATOR;\n', '        uint128 govAmount = _charged * govPercent / DENOMINATOR;\n', '        uint128 nftAmount = uint128( _charged.sub(refAmount).sub(devAmount).sub(govAmount) );\n', '        \n', '        if (refAmount > 0) {\n', '            balances[ referrers[_user] ].lastBalance = uint128( balances[ referrers[_user] ].lastBalance.add(refAmount) );\n', '            emit AffiliatePaid(referrers[_user], _user, refAmount, block.timestamp);\n', '        }\n', '        if (devAmount > 0) balances[devWallet].lastBalance = uint128( balances[devWallet].lastBalance.add(devAmount) );\n', '        if (govAmount > 0) balances[getModule("GOVSTAKE")].lastBalance = uint128( balances[getModule("GOVSTAKE")].lastBalance.add(govAmount) );\n', '        if (nftAmount > 0) balances[getModule("REWARD")].lastBalance = uint128( balances[getModule("REWARD")].lastBalance.add(nftAmount) );\n', '    }\n', '    \n', '    /**\n', '     * @dev Controller can change how much referrers are paid.\n', '     * @param _newPercent New percent referrals receive from revenue. 100 == 10%.\n', '    **/\n', '    function changeRefPercent(uint128 _newPercent)\n', '      external\n', '      onlyOwner\n', '    {\n', '        require(_newPercent <= DENOMINATOR, "new percent cannot be bigger than DENOMINATOR");\n', '        refPercent = _newPercent;\n', '    }\n', '    \n', '    /**\n', '     * @dev Controller can change how much governance is paid.\n', '     * @param _newPercent New percent that governance will receive from revenue. 100 == 10%.\n', '    **/\n', '    function changeGovPercent(uint128 _newPercent)\n', '      external\n', '      onlyOwner\n', '    {\n', '        require(_newPercent <= DENOMINATOR, "new percent cannot be bigger than DENOMINATOR");\n', '        govPercent = _newPercent;\n', '    }\n', '    \n', '    /**\n', '     * @dev Controller can change how much developers are paid.\n', '     * @param _newPercent New percent that devs will receive from revenue. 100 == 10%.\n', '    **/\n', '    function changeDevPercent(uint128 _newPercent)\n', '      external\n', '      onlyOwner\n', '    {\n', '        require(_newPercent <= DENOMINATOR, "new percent cannot be bigger than DENOMINATOR");\n', '        devPercent = _newPercent;\n', '    }\n', '    \n', '    /**\n', '     * @dev Toggle whether utilization farming should be on or off.\n', '    **/\n', '    function toggleUF()\n', '      external\n', '      onlyOwner\n', '    {\n', '        ufOn = !ufOn;\n', '    }\n', '    \n', '    /**\n', '     * @dev Toggle whether address is a shield.\n', '    **/\n', '    function toggleShield(address _shield)\n', '      external\n', '      onlyOwner\n', '    {\n', '        arShields[_shield] = !arShields[_shield];\n', '    }\n', '\n', '    // to reset the buckets\n', '    function resetExpiry(uint160[] calldata _idxs) external onlyOwner {\n', '        for(uint256 i = 0; i<_idxs.length; i++) {\n', '            require(infos[_idxs[i]].expiresAt != 0, "not in linkedlist");\n', '            BalanceExpireTracker.pop(_idxs[i]);\n', '            BalanceExpireTracker.push(_idxs[i], infos[_idxs[i]].expiresAt);\n', '        }\n', '    }\n', '\n', '    // set desired head and tail\n', '    function _resetBucket(uint64 _bucket, uint160 _head, uint160 _tail) internal {\n', '        require(_bucket % BUCKET_STEP == 0, "INVALID BUCKET");\n', '\n', '        require(\n', '            infos[infos[_tail].next].expiresAt >= _bucket + BUCKET_STEP &&\n', '            infos[_tail].expiresAt < _bucket + BUCKET_STEP &&\n', '            infos[_tail].expiresAt >= _bucket,\n', '            "tail is not tail");\n', '        require(\n', '            infos[infos[_head].prev].expiresAt < _bucket &&\n', '            infos[_head].expiresAt < _bucket + BUCKET_STEP &&\n', '            infos[_head].expiresAt >= _bucket,\n', '            "head is not head");\n', '        checkPoints[_bucket].tail = _tail;\n', '        checkPoints[_bucket].head = _head;\n', '    }\n', '\n', '    function resetBuckets(uint64[] calldata _buckets, uint160[] calldata _heads, uint160[] calldata _tails) external onlyOwner{\n', '        for(uint256 i = 0 ; i < _buckets.length; i++){\n', '            _resetBucket(_buckets[i], _heads[i], _tails[i]);\n', '        }\n', '    }\n', '}']