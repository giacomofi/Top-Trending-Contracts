['/**\n', ' *Submitted for verification at Etherscan.io on 2021-05-23\n', '*/\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/IERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title IERC165\n', ' * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n', ' */\n', 'interface IERC165 {\n', '    /**\n', '     * @notice Query if a contract implements an interface\n', '     * @param interfaceId The interface identifier, as specified in ERC-165\n', '     * @dev Interface identification is specified in ERC-165. This function\n', '     * uses less than 30,000 gas.\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic interface\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721 is IERC165 {\n', '    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n', '    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n', '    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n', '\n', '    function balanceOf(address owner) public view returns (uint256 balance);\n', '    function ownerOf(uint256 tokenId) public view returns (address owner);\n', '\n', '    function approve(address to, uint256 tokenId) public;\n', '    function getApproved(uint256 tokenId) public view returns (address operator);\n', '\n', '    function setApprovalForAll(address operator, bool _approved) public;\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 tokenId) public;\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n', '\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Receiver.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title ERC721 token receiver interface\n', ' * @dev Interface for any contract that wants to support safeTransfers\n', ' * from ERC721 asset contracts.\n', ' */\n', 'contract IERC721Receiver {\n', '    /**\n', '     * @notice Handle the receipt of an NFT\n', '     * @dev The ERC721 smart contract calls this function on the recipient\n', '     * after a `safeTransfer`. This function MUST return the function selector,\n', '     * otherwise the caller will revert the transaction. The selector to be\n', '     * returned can be obtained as `this.onERC721Received.selector`. This\n', '     * function MAY throw to revert and reject the transfer.\n', '     * Note: the ERC721 contract address is always the message sender.\n', '     * @param operator The address which called `safeTransferFrom` function\n', '     * @param from The address which previously owned the token\n', '     * @param tokenId The NFT identifier which is being transferred\n', '     * @param data Additional data with no specified format\n', '     * @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '     */\n', '    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n', '    public returns (bytes4);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @dev Unsigned math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    /**\n', '    * @dev Multiplies two unsigned integers, reverts on overflow.\n', '    */\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', "        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n", "        // benefit is lost if 'b' is also tested.\n", '        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n', '    */\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        // Solidity only automatically asserts when dividing by 0\n', '        require(b > 0);\n', '        uint256 c = a / b;\n', "        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n", '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n', '    */\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a);\n', '        uint256 c = a - b;\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Adds two unsigned integers, reverts on overflow.\n', '    */\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a);\n', '\n', '        return c;\n', '    }\n', '\n', '    /**\n', '    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n', '    * reverts when dividing by zero.\n', '    */\n', '    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b != 0);\n', '        return a % b;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/Address.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * Utility library of inline functions on addresses\n', ' */\n', 'library Address {\n', '    /**\n', '     * Returns whether the target address is a contract\n', '     * @dev This function will return false if invoked during the constructor of a contract,\n', '     * as the code is not actually created until after the constructor finishes.\n', '     * @param account address of the account to check\n', '     * @return whether the target address is a contract\n', '     */\n', '    function isContract(address account) internal view returns (bool) {\n', '        uint256 size;\n', '        // XXX Currently there is no better way to check if there is a contract in an address\n', '        // than to check the size of the code at that address.\n', '        // See https://ethereum.stackexchange.com/a/14016/36603\n', '        // for more details about how this works.\n', '        // TODO Check this again before the Serenity release, because all addresses will be\n', '        // contracts then.\n', '        // solhint-disable-next-line no-inline-assembly\n', '        assembly { size := extcodesize(account) }\n', '        return size > 0;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/introspection/ERC165.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC165\n', ' * @author Matt Condon (@shrugs)\n', ' * @dev Implements ERC165 using a lookup table.\n', ' */\n', 'contract ERC165 is IERC165 {\n', '    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n', '    /**\n', '     * 0x01ffc9a7 ===\n', "     *     bytes4(keccak256('supportsInterface(bytes4)'))\n", '     */\n', '\n', '    /**\n', "     * @dev a mapping of interface id to whether or not it's supported\n", '     */\n', '    mapping(bytes4 => bool) private _supportedInterfaces;\n', '\n', '    /**\n', '     * @dev A contract implementing SupportsInterfaceWithLookup\n', '     * implement ERC165 itself\n', '     */\n', '    constructor () internal {\n', '        _registerInterface(_INTERFACE_ID_ERC165);\n', '    }\n', '\n', '    /**\n', '     * @dev implement supportsInterface(bytes4) using a lookup table\n', '     */\n', '    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n', '        return _supportedInterfaces[interfaceId];\n', '    }\n', '\n', '    /**\n', '     * @dev internal method for registering an interface\n', '     */\n', '    function _registerInterface(bytes4 interfaceId) internal {\n', '        require(interfaceId != 0xffffffff);\n', '        _supportedInterfaces[interfaceId] = true;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC721 Non-Fungible Token Standard basic implementation\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721 is ERC165, IERC721 {\n', '    using SafeMath for uint256;\n', '    using Address for address;\n', '\n', '    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n', '    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n', '    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n', '\n', '    // Mapping from token ID to owner\n', '    mapping (uint256 => address) private _tokenOwner;\n', '\n', '    // Mapping from token ID to approved address\n', '    mapping (uint256 => address) private _tokenApprovals;\n', '\n', '    // Mapping from owner to number of owned token\n', '    mapping (address => uint256) private _ownedTokensCount;\n', '\n', '    // Mapping from owner to operator approvals\n', '    mapping (address => mapping (address => bool)) private _operatorApprovals;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n', '    /*\n', '     * 0x80ac58cd ===\n', "     *     bytes4(keccak256('balanceOf(address)')) ^\n", "     *     bytes4(keccak256('ownerOf(uint256)')) ^\n", "     *     bytes4(keccak256('approve(address,uint256)')) ^\n", "     *     bytes4(keccak256('getApproved(uint256)')) ^\n", "     *     bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n", "     *     bytes4(keccak256('isApprovedForAll(address,address)')) ^\n", "     *     bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n", "     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n", '     */\n', '\n', '    constructor () public {\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address\n', '     * @param owner address to query the balance of\n', '     * @return uint256 representing the amount owned by the passed address\n', '     */\n', '    function balanceOf(address owner) public view returns (uint256) {\n', '        require(owner != address(0));\n', '        return _ownedTokensCount[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the owner of the specified token ID\n', '     * @param tokenId uint256 ID of the token to query the owner of\n', '     * @return owner address currently marked as the owner of the given token ID\n', '     */\n', '    function ownerOf(uint256 tokenId) public view returns (address) {\n', '        address owner = _tokenOwner[tokenId];\n', '        require(owner != address(0));\n', '        return owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Approves another address to transfer the given token ID\n', '     * The zero address indicates there is no approved address.\n', '     * There can only be one approved address per token at a given time.\n', '     * Can only be called by the token owner or an approved operator.\n', '     * @param to address to be approved for the given token ID\n', '     * @param tokenId uint256 ID of the token to be approved\n', '     */\n', '    function approve(address to, uint256 tokenId) public {\n', '        address owner = ownerOf(tokenId);\n', '        require(to != owner);\n', '        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n', '\n', '        _tokenApprovals[tokenId] = to;\n', '        emit Approval(owner, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the approved address for a token ID, or zero if no address set\n', '     * Reverts if the token ID does not exist.\n', '     * @param tokenId uint256 ID of the token to query the approval of\n', '     * @return address currently approved for the given token ID\n', '     */\n', '    function getApproved(uint256 tokenId) public view returns (address) {\n', '        require(_exists(tokenId));\n', '        return _tokenApprovals[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Sets or unsets the approval of a given operator\n', '     * An operator is allowed to transfer all tokens of the sender on their behalf\n', '     * @param to operator address to set the approval\n', '     * @param approved representing the status of the approval to be set\n', '     */\n', '    function setApprovalForAll(address to, bool approved) public {\n', '        require(to != msg.sender);\n', '        _operatorApprovals[msg.sender][to] = approved;\n', '        emit ApprovalForAll(msg.sender, to, approved);\n', '    }\n', '\n', '    /**\n', '     * @dev Tells whether an operator is approved by a given owner\n', '     * @param owner owner address which you want to query the approval of\n', '     * @param operator operator address which you want to query the approval of\n', '     * @return bool whether the given operator is approved by the given owner\n', '     */\n', '    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n', '        return _operatorApprovals[owner][operator];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers the ownership of a given token ID to another address\n', '     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function transferFrom(address from, address to, uint256 tokenId) public {\n', '        require(_isApprovedOrOwner(msg.sender, tokenId));\n', '\n', '        _transferFrom(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     *\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n', '        safeTransferFrom(from, to, tokenId, "");\n', '    }\n', '\n', '    /**\n', '     * @dev Safely transfers the ownership of a given token ID to another address\n', '     * If the target address is a contract, it must implement `onERC721Received`,\n', '     * which is called upon a safe transfer, and return the magic value\n', '     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n', '     * the transfer is reverted.\n', '     * Requires the msg sender to be the owner, approved, or operator\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes data to send along with a safe transfer check\n', '     */\n', '    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n', '        transferFrom(from, to, tokenId);\n', '        require(_checkOnERC721Received(from, to, tokenId, _data));\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the specified token exists\n', '     * @param tokenId uint256 ID of the token to query the existence of\n', '     * @return whether the token exists\n', '     */\n', '    function _exists(uint256 tokenId) internal view returns (bool) {\n', '        address owner = _tokenOwner[tokenId];\n', '        return owner != address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Returns whether the given spender can transfer a given token ID\n', '     * @param spender address of the spender to query\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @return bool whether the msg.sender is approved for the given token ID,\n', '     *    is an operator of the owner, or is the owner of the token\n', '     */\n', '    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n', '        address owner = ownerOf(tokenId);\n', '        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to The address that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        require(to != address(0));\n', '        require(!_exists(tokenId));\n', '\n', '        _tokenOwner[tokenId] = to;\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '\n', '        emit Transfer(address(0), to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead.\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == owner);\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);\n', '        _tokenOwner[tokenId] = address(0);\n', '\n', '        emit Transfer(owner, address(0), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(uint256 tokenId) internal {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        require(ownerOf(tokenId) == from);\n', '        require(to != address(0));\n', '\n', '        _clearApproval(tokenId);\n', '\n', '        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n', '        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n', '\n', '        _tokenOwner[tokenId] = to;\n', '\n', '        emit Transfer(from, to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to invoke `onERC721Received` on a target address\n', '     * The call is not executed if the target address is not a contract\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param to target address that will receive the tokens\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     * @param _data bytes optional data to send along with the call\n', '     * @return whether the call correctly returned the expected magic value\n', '     */\n', '    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n', '        internal returns (bool)\n', '    {\n', '        if (!to.isContract()) {\n', '            return true;\n', '        }\n', '\n', '        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n', '        return (retval == _ERC721_RECEIVED);\n', '    }\n', '\n', '    /**\n', '     * @dev Private function to clear current approval of a given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '     */\n', '    function _clearApproval(uint256 tokenId) private {\n', '        if (_tokenApprovals[tokenId] != address(0)) {\n', '            _tokenApprovals[tokenId] = address(0);\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Enumerable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721Enumerable is IERC721 {\n', '    function totalSupply() public view returns (uint256);\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n', '\n', '    function tokenByIndex(uint256 index) public view returns (uint256);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Enumerable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n', '    // Mapping from owner to list of owned token IDs\n', '    mapping(address => uint256[]) private _ownedTokens;\n', '\n', '    // Mapping from token ID to index of the owner tokens list\n', '    mapping(uint256 => uint256) private _ownedTokensIndex;\n', '\n', '    // Array with all token ids, used for enumeration\n', '    uint256[] private _allTokens;\n', '\n', '    // Mapping from token id to position in the allTokens array\n', '    mapping(uint256 => uint256) private _allTokensIndex;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n', '    /**\n', '     * 0x780e9d63 ===\n', "     *     bytes4(keccak256('totalSupply()')) ^\n", "     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n", "     *     bytes4(keccak256('tokenByIndex(uint256)'))\n", '     */\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor () public {\n', '        // register the supported interface to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token ID at a given index of the tokens list of the requested owner\n', '     * @param owner address owning the tokens list to be accessed\n', '     * @param index uint256 representing the index to be accessed of the requested tokens list\n', '     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n', '     */\n', '    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n', '        require(index < balanceOf(owner));\n', '        return _ownedTokens[owner][index];\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the total amount of tokens stored by the contract\n', '     * @return uint256 representing the total amount of tokens\n', '     */\n', '    function totalSupply() public view returns (uint256) {\n', '        return _allTokens.length;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token ID at a given index of all the tokens in this contract\n', '     * Reverts if the index is greater or equal to the total number of tokens\n', '     * @param index uint256 representing the index to be accessed of the tokens list\n', '     * @return uint256 token ID at the given index of the tokens list\n', '     */\n', '    function tokenByIndex(uint256 index) public view returns (uint256) {\n', '        require(index < totalSupply());\n', '        return _allTokens[index];\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to transfer ownership of a given token ID to another address.\n', '     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n', '     * @param from current owner of the token\n', '     * @param to address to receive the ownership of the given token ID\n', '     * @param tokenId uint256 ID of the token to be transferred\n', '    */\n', '    function _transferFrom(address from, address to, uint256 tokenId) internal {\n', '        super._transferFrom(from, to, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(from, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to mint a new token\n', '     * Reverts if the given token ID already exists\n', '     * @param to address the beneficiary that will own the minted token\n', '     * @param tokenId uint256 ID of the token to be minted\n', '     */\n', '    function _mint(address to, uint256 tokenId) internal {\n', '        super._mint(to, tokenId);\n', '\n', '        _addTokenToOwnerEnumeration(to, tokenId);\n', '\n', '        _addTokenToAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        _removeTokenFromOwnerEnumeration(owner, tokenId);\n', '        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n', '        _ownedTokensIndex[tokenId] = 0;\n', '\n', '        _removeTokenFromAllTokensEnumeration(tokenId);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the list of token IDs of the requested owner\n', '     * @param owner address owning the tokens\n', '     * @return uint256[] List of token IDs owned by the requested address\n', '     */\n', '    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n', '        return _ownedTokens[owner];\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n", '     * @param to address representing the new owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n', '     */\n', '    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n', '        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n', '        _ownedTokens[to].push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to add a token to this extension's token tracking data structures.\n", '     * @param tokenId uint256 ID of the token to be added to the tokens list\n', '     */\n', '    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n', '        _allTokensIndex[tokenId] = _allTokens.length;\n', '        _allTokens.push(tokenId);\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n", '     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n', '     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n', '     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n', '     * @param from address representing the previous owner of the given token ID\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n', '     */\n', '    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n', "        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n", '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n', '        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary\n', '        if (tokenIndex != lastTokenIndex) {\n', '            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n', '\n', '            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '        }\n', '\n', '        // This also deletes the contents at the last position of the array\n', '        _ownedTokens[from].length--;\n', '\n', "        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occcupied by\n", '        // lasTokenId, or just over the end of the array if the token was the last one).\n', '    }\n', '\n', '    /**\n', "     * @dev Private function to remove a token from this extension's token tracking data structures.\n", '     * This has O(1) time complexity, but alters the order of the _allTokens array.\n', '     * @param tokenId uint256 ID of the token to be removed from the tokens list\n', '     */\n', '    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n', '        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n', '        // then delete the last slot (swap and pop).\n', '\n', '        uint256 lastTokenIndex = _allTokens.length.sub(1);\n', '        uint256 tokenIndex = _allTokensIndex[tokenId];\n', '\n', '        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n', '        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n', "        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n", '        uint256 lastTokenId = _allTokens[lastTokenIndex];\n', '\n', '        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n', "        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n", '\n', '        // This also deletes the contents at the last position of the array\n', '        _allTokens.length--;\n', '        _allTokensIndex[tokenId] = 0;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/IERC721Metadata.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '/**\n', ' * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n', ' * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract IERC721Metadata is IERC721 {\n', '    function name() external view returns (string memory);\n', '    function symbol() external view returns (string memory);\n', '    function tokenURI(uint256 tokenId) external view returns (string memory);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Metadata.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', 'contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n', '    // Token name\n', '    string private _name;\n', '\n', '    // Token symbol\n', '    string private _symbol;\n', '\n', '    // Optional mapping for token URIs\n', '    mapping(uint256 => string) private _tokenURIs;\n', '\n', '    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n', '    /**\n', '     * 0x5b5e139f ===\n', "     *     bytes4(keccak256('name()')) ^\n", "     *     bytes4(keccak256('symbol()')) ^\n", "     *     bytes4(keccak256('tokenURI(uint256)'))\n", '     */\n', '\n', '    /**\n', '     * @dev Constructor function\n', '     */\n', '    constructor (string memory name, string memory symbol) public {\n', '        _name = name;\n', '        _symbol = symbol;\n', '\n', '        // register the supported interfaces to conform to ERC721 via ERC165\n', '        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token name\n', '     * @return string representing the token name\n', '     */\n', '    function name() external view returns (string memory) {\n', '        return _name;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the token symbol\n', '     * @return string representing the token symbol\n', '     */\n', '    function symbol() external view returns (string memory) {\n', '        return _symbol;\n', '    }\n', '\n', '    /**\n', '     * @dev Returns an URI for a given token ID\n', '     * Throws if the token ID does not exist. May return an empty string.\n', '     * @param tokenId uint256 ID of the token to query\n', '     */\n', '    function tokenURI(uint256 tokenId) external view returns (string memory) {\n', '        require(_exists(tokenId));\n', '        return _tokenURIs[tokenId];\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to set the token URI for a given token\n', '     * Reverts if the token ID does not exist\n', '     * @param tokenId uint256 ID of the token to set its URI\n', '     * @param uri string URI to assign\n', '     */\n', '    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n', '        require(_exists(tokenId));\n', '        _tokenURIs[tokenId] = uri;\n', '    }\n', '\n', '    /**\n', '     * @dev Internal function to burn a specific token\n', '     * Reverts if the token does not exist\n', '     * Deprecated, use _burn(uint256) instead\n', '     * @param owner owner of the token to burn\n', '     * @param tokenId uint256 ID of the token being burned by the msg.sender\n', '     */\n', '    function _burn(address owner, uint256 tokenId) internal {\n', '        super._burn(owner, tokenId);\n', '\n', '        // Clear metadata (if any)\n', '        if (bytes(_tokenURIs[tokenId]).length != 0) {\n', '            delete _tokenURIs[tokenId];\n', '        }\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC721/ERC721Full.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '/**\n', ' * @title Full ERC721 Token\n', ' * This implementation includes all the required and some optional functionality of the ERC721 standard\n', ' * Moreover, it includes approve all functionality using operator terminology\n', ' * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n', ' */\n', 'contract ERC721Full is ERC721, ERC721Enumerable, ERC721Metadata {\n', '    constructor (string memory name, string memory symbol) public ERC721Metadata(name, symbol) {\n', '        // solhint-disable-previous-line no-empty-blocks\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title ERC20 interface\n', ' * @dev see https://github.com/ethereum/EIPs/issues/20\n', ' */\n', 'interface IERC20 {\n', '    function transfer(address to, uint256 value) external returns (bool);\n', '\n', '    function approve(address spender, uint256 value) external returns (bool);\n', '\n', '    function transferFrom(address from, address to, uint256 value) external returns (bool);\n', '\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function balanceOf(address who) external view returns (uint256);\n', '\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 value);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 value);\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @dev The Ownable contract has an owner address, and provides basic authorization control\n', ' * functions, this simplifies the implementation of "user permissions".\n', ' */\n', 'contract Ownable {\n', '    address private _owner;\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    /**\n', '     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n', '     * account.\n', '     */\n', '    constructor () internal {\n', '        _owner = msg.sender;\n', '        emit OwnershipTransferred(address(0), _owner);\n', '    }\n', '\n', '    /**\n', '     * @return the address of the owner.\n', '     */\n', '    function owner() public view returns (address) {\n', '        return _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Throws if called by any account other than the owner.\n', '     */\n', '    modifier onlyOwner() {\n', '        require(isOwner());\n', '        _;\n', '    }\n', '\n', '    /**\n', '     * @return true if `msg.sender` is the owner of the contract.\n', '     */\n', '    function isOwner() public view returns (bool) {\n', '        return msg.sender == _owner;\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to relinquish control of the contract.\n', '     * @notice Renouncing to ownership will leave the contract without an owner.\n', '     * It will not be possible to call the functions with the `onlyOwner`\n', '     * modifier anymore.\n', '     */\n', '    function renounceOwnership() public onlyOwner {\n', '        emit OwnershipTransferred(_owner, address(0));\n', '        _owner = address(0);\n', '    }\n', '\n', '    /**\n', '     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        _transferOwnership(newOwner);\n', '    }\n', '\n', '    /**\n', '     * @dev Transfers control of the contract to a newOwner.\n', '     * @param newOwner The address to transfer ownership to.\n', '     */\n', '    function _transferOwnership(address newOwner) internal {\n', '        require(newOwner != address(0));\n', '        emit OwnershipTransferred(_owner, newOwner);\n', '        _owner = newOwner;\n', '    }\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/access/Roles.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Roles\n', ' * @dev Library for managing addresses assigned to a Role.\n', ' */\n', 'library Roles {\n', '    struct Role {\n', '        mapping (address => bool) bearer;\n', '    }\n', '\n', '    /**\n', '     * @dev give an account access to this role\n', '     */\n', '    function add(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(!has(role, account));\n', '\n', '        role.bearer[account] = true;\n', '    }\n', '\n', '    /**\n', "     * @dev remove an account's access to this role\n", '     */\n', '    function remove(Role storage role, address account) internal {\n', '        require(account != address(0));\n', '        require(has(role, account));\n', '\n', '        role.bearer[account] = false;\n', '    }\n', '\n', '    /**\n', '     * @dev check if an account has this role\n', '     * @return bool\n', '     */\n', '    function has(Role storage role, address account) internal view returns (bool) {\n', '        require(account != address(0));\n', '        return role.bearer[account];\n', '    }\n', '}\n', '\n', '// File: contracts/helpers/strings.sol\n', '\n', '/*\n', ' * @title String & slice utility library for Solidity contracts.\n', ' * @author Nick Johnson <[email\xa0protected]>\n', ' */\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', 'library strings {\n', '    struct slice {\n', '        uint _len;\n', '        uint _ptr;\n', '    }\n', '\n', '    function memcpy(uint dest, uint src, uint len) private pure {\n', '        // Copy word-length chunks while possible\n', '        for (; len >= 32; len -= 32) {\n', '            assembly {\n', '                mstore(dest, mload(src))\n', '            }\n', '            dest += 32;\n', '            src += 32;\n', '        }\n', '\n', '        // Copy remaining bytes\n', '        uint mask = 256 ** (32 - len) - 1;\n', '        assembly {\n', '            let srcpart := and(mload(src), not(mask))\n', '            let destpart := and(mload(dest), mask)\n', '            mstore(dest, or(destpart, srcpart))\n', '        }\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a slice containing the entire string.\n', '     * @param self The string to make a slice from.\n', '     * @return A newly allocated slice containing the entire string.\n', '     */\n', '    function toSlice(string memory self) internal pure returns (slice memory) {\n', '        uint ptr;\n', '        assembly {\n', '            ptr := add(self, 0x20)\n', '        }\n', '        return slice(bytes(self).length, ptr);\n', '    }\n', '\n', '    /*\n', '     * @dev Returns a newly allocated string containing the concatenation of\n', '     *      `self` and `other`.\n', '     * @param self The first slice to concatenate.\n', '     * @param other The second slice to concatenate.\n', '     * @return The concatenation of the two strings.\n', '     */\n', '    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\n', '        string memory ret = new string(self._len + other._len);\n', '        uint retptr;\n', '        assembly {\n', '            retptr := add(ret, 32)\n', '        }\n', '        memcpy(retptr, self._ptr, self._len);\n', '        memcpy(retptr + self._len, other._ptr, other._len);\n', '        return ret;\n', '    }\n', '}\n', '\n', '// File: contracts/Metadata.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '/**\n', '* Metadata contract is upgradeable and returns metadata about Token\n', '*/\n', '\n', '\n', 'contract Metadata {\n', '    using strings for *;\n', '\n', '    function tokenURI(uint _tokenId) public pure returns (string memory _infoUrl) {\n', '        string memory base = "https://folia.app/v1/metadata/";\n', '        string memory id = uint2str(_tokenId);\n', '        return base.toSlice().concat(id.toSlice());\n', '    }\n', '    function uint2str(uint i) internal pure returns (string memory) {\n', '        if (i == 0) return "0";\n', '        uint j = i;\n', '        uint length;\n', '        while (j != 0) {\n', '            length++;\n', '            j /= 10;\n', '        }\n', '        bytes memory bstr = new bytes(length);\n', '        uint k = length - 1;\n', '        while (i != 0) {\n', '            uint _uint = 48 + i % 10;\n', '            bstr[k--] = toBytes(_uint)[31];\n', '            i /= 10;\n', '        }\n', '        return string(bstr);\n', '    }\n', '    function toBytes(uint256 x) public pure returns (bytes memory b) {\n', '        b = new bytes(32);\n', '        assembly { mstore(add(b, 32), x) }\n', '    }\n', '}\n', '\n', '// File: contracts/Folia.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '\n', '/**\n', ' * The Token contract does this and that...\n', ' */\n', 'contract Folia is ERC721Full, Ownable {\n', '    using Roles for Roles.Role;\n', '    Roles.Role private _admins;\n', '    uint8 admins;\n', '\n', '    address public metadata;\n', '    address public controller;\n', '\n', '    modifier onlyAdminOrController() {\n', '        require((_admins.has(msg.sender) || msg.sender == controller), "DOES_NOT_HAVE_ADMIN_OR_CONTROLLER_ROLE");\n', '        _;\n', '    }\n', '\n', '    constructor(string memory name, string memory symbol, address _metadata) public ERC721Full(name, symbol) {\n', '        metadata = _metadata;\n', '        _admins.add(msg.sender);\n', '        admins += 1;\n', '    }\n', '\n', '    function mint(address recepient, uint256 tokenId) public onlyAdminOrController {\n', '        _mint(recepient, tokenId);\n', '    }\n', '    function burn(uint256 tokenId) public onlyAdminOrController {\n', '        _burn(ownerOf(tokenId), tokenId);\n', '    }\n', '    function updateMetadata(address _metadata) public onlyAdminOrController {\n', '        metadata = _metadata;\n', '    }\n', '    function updateController(address _controller) public onlyAdminOrController {\n', '        controller = _controller;\n', '    }\n', '\n', '    function addAdmin(address _admin) public onlyOwner {\n', '        _admins.add(_admin);\n', '        admins += 1;\n', '    }\n', '    function removeAdmin(address _admin) public onlyOwner {\n', '        require(admins > 1, "CANT_REMOVE_LAST_ADMIN");\n', '        _admins.remove(_admin);\n', '        admins -= 1;\n', '    }\n', '\n', '    function tokenURI(uint _tokenId) external view returns (string memory _infoUrl) {\n', '        return Metadata(metadata).tokenURI(_tokenId);\n', '    }\n', '\n', '    /**\n', '    * @dev Moves Eth to a certain address for use in the FoliaController\n', '    * @param _to The address to receive the Eth.\n', '    * @param _amount The amount of Eth to be transferred.\n', '    */\n', '    function moveEth(address payable _to, uint256 _amount) public onlyAdminOrController {\n', '        require(_amount <= address(this).balance);\n', '        _to.transfer(_amount);\n', '    }\n', '    /**\n', '    * @dev Moves Token to a certain address for use in the FoliaController\n', '    * @param _to The address to receive the Token.\n', '    * @param _amount The amount of Token to be transferred.\n', '    * @param _token The address of the Token to be transferred.\n', '    */\n', '    function moveToken(address _to, uint256 _amount, address _token) public onlyAdminOrController returns (bool) {\n', '        require(_amount <= IERC20(_token).balanceOf(address(this)));\n', '        return IERC20(_token).transfer(_to, _amount);\n', '    }\n', '\n', '}\n', '\n', '// File: contracts/FoliaController.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * The FoliaController is an upgradeable endpoint for controlling Folia.sol\n', ' */\n', '\n', '\n', '\n', '\n', 'contract FoliaController is Ownable {\n', '\n', '    event newWork(uint256 workId, address payable artist, uint256 editions, uint256 price, bool paused);\n', '    event updatedWork(uint256 workId, address payable artist, uint256 editions, uint256 price, bool paused);\n', '    event editionBought(uint256 workId, uint256 editionId, uint256 tokenId, address recipient, uint256 paid, uint256 artistReceived, uint256 adminReceived);\n', '\n', '    using SafeMath for uint256;\n', '\n', '    uint256 constant MAX_EDITIONS = 1000000;\n', '    uint256 public latestWorkId;\n', '\n', '    mapping (uint256 => Work) public works;\n', '    struct Work {\n', '        bool exists;\n', '        bool paused;\n', '        uint256 editions;\n', '        uint256 printed;\n', '        uint256 price;\n', '        address payable artist;\n', '    }\n', '\n', '    uint256 public adminSplit = 15;\n', '\n', '    address payable public adminWallet;\n', '    bool public paused;\n', '    Folia public folia;\n', '\n', '    modifier notPaused() {\n', '        require(!paused, "Must not be paused");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        Folia _folia,\n', '        address payable _adminWallet\n', '    ) public {\n', '        folia = _folia;\n', '        adminWallet = _adminWallet;\n', '    }\n', '\n', '    function addArtwork(address payable artist, uint256 editions, uint256 price, bool _paused) public onlyOwner {\n', '        require(editions < MAX_EDITIONS, "MAX_EDITIONS_EXCEEDED");\n', '\n', '        latestWorkId += 1;\n', '\n', '        works[latestWorkId].exists = true;\n', '        works[latestWorkId].editions = editions;\n', '        works[latestWorkId].price = price;\n', '        works[latestWorkId].artist = artist;\n', '        works[latestWorkId].paused = _paused;\n', '        emit newWork(latestWorkId, artist, editions, price, _paused);\n', '    }\n', '\n', '    function updateArtworkPaused(uint256 workId, bool _paused) public onlyOwner {\n', '        require(works[workId].exists, "WORK_DOES_NOT_EXIST");\n', '        works[workId].paused = _paused;\n', '        emit updatedWork(workId, works[workId].artist, works[workId].editions, works[workId].price, works[workId].paused);\n', '    }\n', '\n', '    function updateArtworkEditions(uint256 workId, uint256 _editions) public onlyOwner {\n', '        require(works[workId].exists, "WORK_DOES_NOT_EXIST");\n', '        require(works[workId].printed < _editions, "WORK_EXCEEDS_EDITIONS");\n', '        works[workId].editions = _editions;\n', '        emit updatedWork(workId, works[workId].artist, works[workId].editions, works[workId].price, works[workId].paused);\n', '    }\n', '\n', '    function updateArtworkPrice(uint256 workId, uint256 _price) public onlyOwner {\n', '        require(works[workId].exists, "WORK_DOES_NOT_EXIST");\n', '        works[workId].price = _price;\n', '        emit updatedWork(workId, works[workId].artist, works[workId].editions, works[workId].price, works[workId].paused);\n', '    }\n', '\n', '    function updateArtworkArtist(uint256 workId, address payable _artist) public onlyOwner {\n', '        require(works[workId].exists, "WORK_DOES_NOT_EXIST");\n', '        works[workId].artist = _artist;\n', '        emit updatedWork(workId, works[workId].artist, works[workId].editions, works[workId].price, works[workId].paused);\n', '    }\n', '\n', '    function buy(address recipient, uint256 workId) public payable notPaused returns (bool) {\n', '        require(!works[workId].paused, "WORK_NOT_YET_FOR_SALE");\n', '        require(works[workId].exists, "WORK_DOES_NOT_EXIST");\n', '        require(works[workId].editions > works[workId].printed, "EDITIONS_EXCEEDED");\n', '        require(msg.value == works[workId].price, "DID_NOT_SEND_PRICE");\n', '\n', '        uint256 editionId = works[workId].printed.add(1);\n', '        works[workId].printed = editionId;\n', '        \n', '        uint256 tokenId = workId.mul(MAX_EDITIONS).add(editionId);\n', '\n', '        folia.mint(recipient, tokenId);\n', '        \n', '        uint256 adminReceives = msg.value.mul(adminSplit).div(100);\n', '        uint256 artistReceives = msg.value.sub(adminReceives);\n', '\n', '        adminWallet.transfer(adminReceives);\n', '        works[workId].artist.transfer(artistReceives);\n', '\n', '        emit editionBought(workId, editionId, tokenId, recipient,  works[workId].price, artistReceives, adminReceives);\n', '    }\n', '\n', '    function updateAdminSplit(uint256 _adminSplit) public onlyOwner {\n', '        require(_adminSplit <= 100, "SPLIT_MUST_BE_LTE_100");\n', '        adminSplit = _adminSplit;\n', '    }\n', '\n', '    function updateAdminWallet(address payable _adminWallet) public onlyOwner {\n', '        adminWallet = _adminWallet;\n', '    }\n', '\n', '    function updatePaused(bool _paused) public onlyOwner {\n', '        paused = _paused;\n', '    }\n', '\n', '}\n', '\n', '// File: openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\n', '\n', 'pragma solidity ^0.5.0;\n', '\n', '/**\n', ' * @title Helps contracts guard against reentrancy attacks.\n', ' * @author Remco Bloemen <[email\xa0protected]π.com>, Eenae <[email\xa0protected]>\n', ' * @dev If you mark a function `nonReentrant`, you should also\n', ' * mark it `external`.\n', ' */\n', 'contract ReentrancyGuard {\n', '    /// @dev counter to allow mutex lock with only one SSTORE operation\n', '    uint256 private _guardCounter;\n', '\n', '    constructor () internal {\n', '        // The counter starts at one to prevent changing it from zero to a non-zero\n', '        // value, which is a more expensive operation.\n', '        _guardCounter = 1;\n', '    }\n', '\n', '    /**\n', '     * @dev Prevents a contract from calling itself, directly or indirectly.\n', '     * Calling a `nonReentrant` function from another `nonReentrant`\n', '     * function is not supported. It is possible to prevent this from happening\n', '     * by making the `nonReentrant` function external, and make it call a\n', '     * `private` function that does the actual work.\n', '     */\n', '    modifier nonReentrant() {\n', '        _guardCounter += 1;\n', '        uint256 localCounter = _guardCounter;\n', '        _;\n', '        require(localCounter == _guardCounter);\n', '    }\n', '}\n', '\n', '// File: contracts/FoliaControllerV2.sol\n', '\n', 'pragma solidity ^0.5.0;\n', 'pragma experimental ABIEncoderV2;\n', '/**\n', ' * The FoliaControllerV2 is an upgradeable endpoint for controlling Folia.sol\n', ' */\n', '\n', '\n', '\n', '\n', '\n', '\n', 'contract FoliaControllerV2 is Ownable, ReentrancyGuard {\n', '\n', '    event newWork(uint256 workId, address payable artist, uint256 editions, uint256 price, bool paused);\n', '    event updatedWork(uint256 workId, address payable artist, uint256 editions, uint256 price, bool paused);\n', '    event editionBought(uint256 workId, uint256 editionId, uint256 tokenId, address recipient, uint256 paid, uint256 artistReceived, uint256 adminReceived);\n', '\n', '    using SafeMath for uint256;\n', '\n', '    enum SaleType {noID, ID}\n', '\n', '    uint256 constant MAX_EDITIONS = 1000000;\n', '    uint256 public latestWorkId = 9;\n', '\n', '    mapping (uint256 => Work) public _works;\n', '    struct Work {\n', '        bool exists;\n', '        bool paused;\n', '        SaleType saleType;\n', '        uint256 editions;\n', '        uint256 printed;\n', '        uint256 price;\n', '        address payable artist;\n', '    }\n', '\n', '    uint256 public adminSplit = 15;\n', '\n', '    address payable public adminWallet;\n', '    bool public paused;\n', '    Folia public folia;\n', '    FoliaController public foliaController;\n', '\n', '    modifier notPaused() {\n', '        require(!paused, "Must not be paused");\n', '        _;\n', '    }\n', '\n', '    constructor(\n', '        Folia _folia,\n', '        FoliaController _foliaController,\n', '        address payable _adminWallet\n', '    ) public {\n', '        folia = _folia;\n', '        foliaController = _foliaController;\n', '        adminWallet = _adminWallet;\n', '    }\n', '\n', '    function works(uint256 workId) public view returns (bool exists, bool paused, SaleType saleType, uint256 editions, uint256 printed, uint256 price, address payable artist) {\n', '      if (workId > foliaController.latestWorkId()) {\n', '        return (_works[workId].exists, _works[workId].paused, _works[workId].saleType, _works[workId].editions, _works[workId].printed, _works[workId].price, _works[workId].artist);\n', '      } else {\n', '        (bool _exists, bool _paused, uint256 _editions, uint256 _printed, uint256 _price, address payable _artist) = foliaController.works(workId);\n', '        return (_exists, _paused, SaleType.noID, _editions, _printed, _price, _artist);\n', '      }\n', '    }\n', '\n', '    function addArtwork(address payable artist, uint256 editions, uint256 price, bool _paused, SaleType saleType) public onlyOwner {\n', '        require(editions < MAX_EDITIONS, "MAX_EDITIONS_EXCEEDED");\n', '\n', '        latestWorkId += 1;\n', '\n', '        _works[latestWorkId] = Work({\n', '          exists: true,\n', '          paused: _paused,\n', '          saleType: saleType,\n', '          editions: editions,\n', '          printed: 0,\n', '          price: price,\n', '          artist: artist\n', '        });\n', '\n', '        emit newWork(latestWorkId, artist, editions, price, _paused);\n', '    }\n', '\n', '    function updateArtworkPaused(uint256 workId, bool _paused) public onlyOwner {\n', '        Work storage work = _works[workId];\n', '        require(work.exists, "WORK_DOES_NOT_EXIST");\n', '        work.paused = _paused;\n', '        emit updatedWork(workId, work.artist, work.editions, work.price, work.paused);\n', '    }\n', '\n', '    function updateArtworkEditions(uint256 workId, uint256 _editions) public onlyOwner {\n', '        Work storage work = _works[workId];\n', '        require(work.exists, "WORK_DOES_NOT_EXIST");\n', '        require(work.printed < _editions, "WORK_EXCEEDS_EDITIONS");\n', '        work.editions = _editions;\n', '        emit updatedWork(workId, work.artist, work.editions, work.price, work.paused);\n', '    }\n', '\n', '    function updateArtworkPrice(uint256 workId, uint256 _price) public onlyOwner {\n', '        Work storage work = _works[workId];\n', '        require(work.exists, "WORK_DOES_NOT_EXIST");\n', '        work.price = _price;\n', '        emit updatedWork(workId, work.artist, work.editions, work.price, work.paused);\n', '    }\n', '\n', '    function updateArtworkArtist(uint256 workId, address payable _artist) public onlyOwner {\n', '        Work storage work = _works[workId];\n', '        require(work.exists, "WORK_DOES_NOT_EXIST");\n', '        work.artist = _artist;\n', '        emit updatedWork(workId, work.artist, work.editions, work.price, work.paused);\n', '    }\n', '\n', '    function buyByID(address recipient, uint256 workId, uint256 editionId) public payable notPaused nonReentrant returns(bool) {\n', '        Work storage work = _works[workId];\n', '        require(!work.paused, "WORK_NOT_YET_FOR_SALE");\n', '        require(work.saleType == SaleType.ID, "WRONG_SALE_TYPE");\n', '        require(work.exists, "WORK_DOES_NOT_EXIST");\n', '\n', '        require(work.editions >= editionId && editionId > 0, "OUTSIDE_RANGE_OF_EDITIONS");\n', '        uint256 tokenId = workId.mul(MAX_EDITIONS).add(editionId);\n', '\n', '        require(msg.value == work.price, "DID_NOT_SEND_PRICE");\n', '\n', '        work.printed += 1;\n', '        folia.mint(recipient, tokenId);\n', '        \n', '        uint256 adminReceives = msg.value.mul(adminSplit).div(100);\n', '        uint256 artistReceives = msg.value.sub(adminReceives);\n', '\n', '        (bool success, ) = adminWallet.call.value(adminReceives)("");\n', '        require(success, "admin failed to receive");\n', '\n', '        (success, ) = work.artist.call.value(artistReceives)("");\n', '        require(success, "artist failed to receive");\n', '\n', '        emit editionBought(workId, editionId, tokenId, recipient,  work.price, artistReceives, adminReceives);\n', '    }\n', '\n', '    function buy(address recipient, uint256 workId) public payable notPaused nonReentrant returns (bool) {\n', '        Work storage work = _works[workId];\n', '        require(!work.paused, "WORK_NOT_YET_FOR_SALE");\n', '        require(work.saleType == SaleType.noID, "WRONG_SALE_TYPE");\n', '        require(work.exists, "WORK_DOES_NOT_EXIST");\n', '        require(work.editions > work.printed, "EDITIONS_EXCEEDED");\n', '        require(msg.value == work.price, "DID_NOT_SEND_PRICE");\n', '\n', '        uint256 editionId = work.printed.add(1);\n', '        work.printed = editionId;\n', '        \n', '        uint256 tokenId = workId.mul(MAX_EDITIONS).add(editionId);\n', '\n', '        folia.mint(recipient, tokenId);\n', '        \n', '        uint256 adminReceives = msg.value.mul(adminSplit).div(100);\n', '        uint256 artistReceives = msg.value.sub(adminReceives);\n', '\n', '        (bool success, ) = adminWallet.call.value(adminReceives)("");\n', '        require(success, "admin failed to receive");\n', '        \n', '        (success, ) = work.artist.call.value(artistReceives)("");\n', '        require(success, "artist failed to receive");\n', '\n', '        emit editionBought(workId, editionId, tokenId, recipient,  work.price, artistReceives, adminReceives);\n', '    }\n', '\n', '    function updateAdminSplit(uint256 _adminSplit) public onlyOwner {\n', '        require(_adminSplit <= 100, "SPLIT_MUST_BE_LTE_100");\n', '        adminSplit = _adminSplit;\n', '    }\n', '\n', '    function updateAdminWallet(address payable _adminWallet) public onlyOwner {\n', '        adminWallet = _adminWallet;\n', '    }\n', '\n', '    function updatePaused(bool _paused) public onlyOwner {\n', '        paused = _paused;\n', '    }\n', '\n', '}']