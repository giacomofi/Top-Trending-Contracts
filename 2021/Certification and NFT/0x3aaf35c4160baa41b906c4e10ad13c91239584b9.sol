['/**\n', ' *Submitted for verification at Etherscan.io on 2021-04-24\n', '*/\n', '\n', '// SPDX-License-Identifier: GPL-3.0-or-later\n', '\n', '/// split.sol -- splits funds sent to this contract\n', '\n', '// Copyright (C) 2021 HDSplit\n', '\n', '// This program is free software: you can redistribute it and/or modify\n', '// it under the terms of the GNU General Public License as published by\n', '// the Free Software Foundation, either version 3 of the License, or\n', '// (at your option) any later version.\n', '\n', '// This program is distributed in the hope that it will be useful,\n', '// but WITHOUT ANY WARRANTY; without even the implied warranty of\n', '// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n', '// GNU General Public License for more details.\n', '\n', '// You should have received a copy of the GNU General Public License\n', '// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n', '\n', 'pragma solidity ^0.6.12;\n', '\n', 'interface IERC20 {\n', '    function balanceOf(address) external view returns (uint256);\n', '    function transfer(address, uint256) external returns (bool);\n', '    function transferFrom(address, address, uint256) external returns (bool);\n', '}\n', '\n', 'contract HDSplit {\n', '    address immutable public dai;\n', '    uint256 public debt;\n', '    uint256 public limit;\n', '    address payable[] public folks;\n', '    uint256[] public bps;\n', '\n', '    // token->total\n', '    mapping (address => uint256) public total;\n', '\n', '    // folk[i]->token->balance\n', '    mapping (address => mapping (address => uint256)) public balance;\n', '\n', '    // folks[i]->folk[i]->owe: DAI amount owed per person\n', '    // A       ->B      ->owe: B owes A owe DAI\n', '    mapping (address => mapping (address => uint256)) public owe;\n', '\n', '    // auth\n', '    mapping (address => uint256) public wards;\n', '    modifier auth {\n', '        require(wards[msg.sender] == 1, "HDSplit/not-authorized");\n', '        _;\n', '    }\n', '\n', '    // events\n', '    event Push();\n', '    event Rely(address indexed usr);\n', '    event Comp(address indexed sender, address indexed recipient, uint256 amt);\n', '    event Sent(address indexed guy, address indexed gem, uint256 amt);\n', '    event Receive(address indexed guy, uint256 amt);\n', '\n', '    // math\n', '    uint256 THOUSAND = 10 ** 4;\n', '    function add(uint256 _x, uint256 _y) internal pure returns (uint256 _z) {\n', '        require((_z = _x + _y) >= _x);\n', '    }\n', '    function sub(uint256 _x, uint256 _y) internal pure returns (uint256 _z) {\n', '        require((_z = _x - _y) <= _x);\n', '    }\n', '    function mul(uint256 _x, uint256 _y) internal pure returns (uint256 _z) {\n', '        require(_y == 0 || (_z = _x * _y) / _y == _x);\n', '    }\n', '\n', '    constructor(\n', '        address _dai,\n', '        uint256 _limit,\n', '        address payable[] memory _folks,\n', '        uint256[] memory _bps\n', '    ) public {\n', '        require(_folks.length == _bps.length, "HDSplit/length-must-match");\n', '\n', '        uint256 _total;\n', '\n', '        for (uint256 i = 0; i < _folks.length; i++) {\n', '            _total = add(_total, _bps[i]);\n', '            folks.push(_folks[i]);\n', '            bps.push(_bps[i]);\n', '            wards[_folks[i]] = 1;\n', '            emit Rely(_folks[i]);\n', '        }\n', '        require(_total == 10000, "HDSplit/basis-points-must-total-10000");\n', '\n', '        dai   = _dai;\n', '        limit = _limit;\n', '    }\n', '\n', '    receive() external payable {\n', '        emit Receive(msg.sender, msg.value);\n', '    }\n', '\n', '    function tell(uint256 _wad) external auth {\n', '        require(dai != address(0), "HDSplit/no-compensation-plan");\n', '\n', '        address payable[] memory _folks = folks;\n', '\n', '        for (uint256 i = 0; i < _folks.length; i++) {\n', '            if (msg.sender != _folks[i]) {\n', '                uint256 _amt = mul(_wad, bps[i]) / THOUSAND;\n', '                debt = add(debt, _amt);\n', '                owe[msg.sender][_folks[i]] = add(\n', '                    owe[msg.sender][_folks[i]], _amt\n', '                );\n', '            }\n', '        }\n', '\n', '        require(debt <= limit, "HDSplit/over-debt-limit");\n', '    }\n', '\n', '    function take() external {\n', '        take(address(0));\n', '    }\n', '\n', '    function take(address _token) public auth {\n', '        uint256 _moar;\n', '        address payable[] memory _folks = folks;\n', '\n', '        if (_token == address(0)) {\n', '            _moar = sub(address(this).balance, total[_token]);\n', '        } else {\n', '            _moar = sub(IERC20(_token).balanceOf(address(this)), total[_token]);\n', '        }\n', '\n', '        if (_moar > 0) {\n', '            total[_token] = add(total[_token], _moar);\n', '\n', "            // figure out everyong's amounts\n", '            for (uint256 i = 0; i < _folks.length; i++) {\n', '                balance[_folks[i]][_token] = add(\n', '                    balance[_folks[i]][_token],\n', '                    mul(_moar, bps[i]) / THOUSAND\n', '                );\n', '            }\n', '        }\n', '\n', '        // pay expenses\n', '        for (uint256 i = 0; i < _folks.length; i++) {\n', '            comp(_folks[i]);\n', '        }\n', '\n', '        send(_token);\n', '\n', '        emit Push();\n', '    }\n', '\n', '    function send(address _token) internal {\n', '        uint256 _amt = balance[msg.sender][_token];\n', '        balance[msg.sender][_token] = 0;\n', '        total[_token] = sub(total[_token], _amt);\n', '        emit Sent(msg.sender, _token, _amt);\n', '        if (_token == address(0)) {\n', '            require(msg.sender.send(_amt) == true, "HDSplit/send-failed");\n', '        } else {\n', '            bytes memory _data = abi.encodeWithSelector(\n', '                IERC20(_token).transfer.selector, msg.sender, _amt\n', '            );\n', '            (bool _success, bytes memory _returndata) = _token.call(_data);\n', '            require(_success, "HDSplit/transfer-failed-1");\n', '\n', '            if (_returndata.length > 0) {\n', '                require(\n', '                    abi.decode(_returndata, (bool)), "HDSplit/transfer-failed-2"\n', '                );\n', '            }\n', '        }\n', '    }\n', '\n', '    function comp(address _guy) internal {\n', '        if (dai == address(0)) { return; }\n', '\n', '        uint256 _amt = owe[_guy][msg.sender];\n', '\n', '        if (_amt > 0) {\n', '            owe[_guy][msg.sender] = 0;\n', '            debt = sub(debt, _amt);\n', '            emit Comp(msg.sender, _guy, _amt);\n', '            require(\n', '                IERC20(dai).transferFrom(msg.sender, _guy, _amt),\n', '                "HDSplit/dai-transfer-failed"\n', '            );\n', '        }\n', '    }\n', '\n', '}']