['pragma solidity 0.4.24;\n', '\n', 'import "./DetailedERC20.sol";\n', 'import "./PausableToken.sol";\n', 'import "./MintableToken.sol";\n', 'import "./BurnableToken.sol";\n', 'import "./MapBoolOfAddress.sol";\n', '\n', '\n', 'contract ZadToken is DetailedERC20, PausableToken, MintableToken, BurnableToken {\n', '    MapBoolOfAddress locks;\n', '    \n', '    constructor(string _name, string _symbol, uint8 _decimals, uint256 _amount)\n', '    DetailedERC20(_name, _symbol, _decimals) public {\n', '        require(_amount > 0, "amount has to be greater than 0");\n', '        totalSupply_ = _amount.mul(10 ** uint256(_decimals));\n', '        balances[msg.sender] = totalSupply_;\n', '        locks = new MapBoolOfAddress();\n', '        emit Transfer(address(0), msg.sender, totalSupply_);\n', '    }\n', '    \n', '    function _zadToWei(uint256 _zad) public view returns (uint256) {\n', '        return _zad.mul(10 ** uint256(decimals));\n', '    }\n', '    \n', '    function transfer(address _to, uint256 _value) public returns (bool) {\n', '        require(!locks.getByKey(msg.sender), "locked address");\n', '        \n', '        return super.transfer(_to, _value);\n', '    }\n', '    \n', '    function tokenInfo() public view returns (string, string, uint256, address, address) {\n', '        address _tokenAddress = this;\n', '        \n', '        return (name, symbol, totalSupply_, _tokenAddress, owner);\n', '    }\n', '    \n', '    function lock(address _beneficiary) external onlyOwner {\n', '        locks.addOrUpdate(_beneficiary, true);\n', '    }\n', '    \n', '    function lockMany(address[] _beneficiaries) external onlyOwner {\n', '    \tfor (uint i = 0; i < _beneficiaries.length; i++) {\n', '    \t\tlocks.addOrUpdate(_beneficiaries[i], true);\n', '    \t}\n', '    }\n', '    \n', '    function lockAll() external onlyOwner {\n', '        uint _size = locks.size();\n', '        address[] memory _beneficiaries = locks.getKeys();\n', '        for (uint i = 0; i < _size; i++) {\n', '            address _beneficiary = _beneficiaries[i];\n', '            locks.addOrUpdate(_beneficiary, true);\n', '        }\n', '    }\n', '    \n', '    function unlock(address _beneficiary) external onlyOwner {\n', '        locks.addOrUpdate(_beneficiary, false);\n', '    }\n', '    \n', '    function unlockMany(address[] _beneficiaries) external onlyOwner {\n', '    \tfor (uint i = 0; i < _beneficiaries.length; i++) {\n', '    \t\tlocks.addOrUpdate(_beneficiaries[i], false);\n', '    \t}\n', '    }\n', '    \n', '    function unlockAll() external onlyOwner {\n', '        uint _size = locks.size();\n', '        address[] memory _beneficiaries = locks.getKeys();\n', '        for (uint i = 0; i < _size; i++) {\n', '            address _beneficiary = _beneficiaries[i];\n', '            locks.addOrUpdate(_beneficiary, false);\n', '        }\n', '    }\n', '    \n', '    function islock(address _beneficiary) public view returns (bool) {\n', '        return locks.getByKey(_beneficiary);\n', '    }\n', '}']