['/**\n', ' *Submitted for verification at Etherscan.io on 2021-03-14\n', '*/\n', '\n', '// File: contracts/lib/InitializableOwnable.sol\n', '\n', '/*\n', '\n', '    Copyright 2020 DODO ZOO.\n', '    SPDX-License-Identifier: Apache-2.0\n', '\n', '*/\n', '\n', 'pragma solidity 0.6.9;\n', 'pragma experimental ABIEncoderV2;\n', '\n', '/**\n', ' * @title Ownable\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Ownership related functions\n', ' */\n', 'contract InitializableOwnable {\n', '    address public _OWNER_;\n', '    address public _NEW_OWNER_;\n', '    bool internal _INITIALIZED_;\n', '\n', '    // ============ Events ============\n', '\n', '    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n', '\n', '    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n', '\n', '    // ============ Modifiers ============\n', '\n', '    modifier notInitialized() {\n', '        require(!_INITIALIZED_, "DODO_INITIALIZED");\n', '        _;\n', '    }\n', '\n', '    modifier onlyOwner() {\n', '        require(msg.sender == _OWNER_, "NOT_OWNER");\n', '        _;\n', '    }\n', '\n', '    // ============ Functions ============\n', '\n', '    function initOwner(address newOwner) public notInitialized {\n', '        _INITIALIZED_ = true;\n', '        _OWNER_ = newOwner;\n', '    }\n', '\n', '    function transferOwnership(address newOwner) public onlyOwner {\n', '        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n', '        _NEW_OWNER_ = newOwner;\n', '    }\n', '\n', '    function claimOwnership() public {\n', '        require(msg.sender == _NEW_OWNER_, "INVALID_CLAIM");\n', '        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n', '        _OWNER_ = _NEW_OWNER_;\n', '        _NEW_OWNER_ = address(0);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/FeeRateModel.sol\n', '\n', '\n', 'interface IFeeRateImpl {\n', '    function getFeeRate(address pool, address trader) external view returns (uint256);\n', '}\n', '\n', 'interface IFeeRateModel {\n', '    function getFeeRate(address trader) external view returns (uint256);\n', '}\n', '\n', 'contract FeeRateModel is InitializableOwnable {\n', '    address public feeRateImpl;\n', '\n', '    function setFeeProxy(address _feeRateImpl) public onlyOwner {\n', '        feeRateImpl = _feeRateImpl;\n', '    }\n', '    \n', '    function getFeeRate(address trader) external view returns (uint256) {\n', '        if(feeRateImpl == address(0))\n', '            return 0;\n', '        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender,trader);\n', '    }\n', '}\n', '\n', '// File: contracts/intf/IERC20.sol\n', '\n', '\n', '/**\n', ' * @dev Interface of the ERC20 standard as defined in the EIP.\n', ' */\n', 'interface IERC20 {\n', '    /**\n', '     * @dev Returns the amount of tokens in existence.\n', '     */\n', '    function totalSupply() external view returns (uint256);\n', '\n', '    function decimals() external view returns (uint8);\n', '\n', '    function name() external view returns (string memory);\n', '\n', '    function symbol() external view returns (string memory);\n', '\n', '    /**\n', '     * @dev Returns the amount of tokens owned by `account`.\n', '     */\n', '    function balanceOf(address account) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transfer(address recipient, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Returns the remaining number of tokens that `spender` will be\n', '     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n', '     * zero by default.\n', '     *\n', '     * This value changes when {approve} or {transferFrom} are called.\n', '     */\n', '    function allowance(address owner, address spender) external view returns (uint256);\n', '\n', '    /**\n', "     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n", '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n', '     * that someone may use both the old and the new allowance by unfortunate\n', '     * transaction ordering. One possible solution to mitigate this race\n', "     * condition is to first reduce the spender's allowance to 0 and set the\n", '     * desired value afterwards:\n', '     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n', '     *\n', '     * Emits an {Approval} event.\n', '     */\n', '    function approve(address spender, uint256 amount) external returns (bool);\n', '\n', '    /**\n', '     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n', "     * allowance mechanism. `amount` is then deducted from the caller's\n", '     * allowance.\n', '     *\n', '     * Returns a boolean value indicating whether the operation succeeded.\n', '     *\n', '     * Emits a {Transfer} event.\n', '     */\n', '    function transferFrom(\n', '        address sender,\n', '        address recipient,\n', '        uint256 amount\n', '    ) external returns (bool);\n', '}\n', '\n', '// File: contracts/lib/SafeMath.sol\n', '\n', '\n', '/**\n', ' * @title SafeMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Math operations with safety checks that revert on error\n', ' */\n', 'library SafeMath {\n', '    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        if (a == 0) {\n', '            return 0;\n', '        }\n', '\n', '        uint256 c = a * b;\n', '        require(c / a == b, "MUL_ERROR");\n', '\n', '        return c;\n', '    }\n', '\n', '    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b > 0, "DIVIDING_ERROR");\n', '        return a / b;\n', '    }\n', '\n', '    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 quotient = div(a, b);\n', '        uint256 remainder = a - quotient * b;\n', '        if (remainder > 0) {\n', '            return quotient + 1;\n', '        } else {\n', '            return quotient;\n', '        }\n', '    }\n', '\n', '    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        require(b <= a, "SUB_ERROR");\n', '        return a - b;\n', '    }\n', '\n', '    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n', '        uint256 c = a + b;\n', '        require(c >= a, "ADD_ERROR");\n', '        return c;\n', '    }\n', '\n', '    function sqrt(uint256 x) internal pure returns (uint256 y) {\n', '        uint256 z = x / 2 + 1;\n', '        y = x;\n', '        while (z < y) {\n', '            y = z;\n', '            z = (x / z + z) / 2;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/DecimalMath.sol\n', '\n', '\n', '\n', '/**\n', ' * @title DecimalMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for fixed point number with 18 decimals\n', ' */\n', 'library DecimalMath {\n', '    using SafeMath for uint256;\n', '\n', '    uint256 internal constant ONE = 10**18;\n', '    uint256 internal constant ONE2 = 10**36;\n', '\n', '    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(d) / (10**18);\n', '    }\n', '\n', '    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(d).divCeil(10**18);\n', '    }\n', '\n', '    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(10**18).div(d);\n', '    }\n', '\n', '    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n', '        return target.mul(10**18).divCeil(d);\n', '    }\n', '\n', '    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\n', '        return uint256(10**36).div(target);\n', '    }\n', '\n', '    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\n', '        return uint256(10**36).divCeil(target);\n', '    }\n', '}\n', '\n', '// File: contracts/lib/SafeERC20.sol\n', '\n', '/**\n', ' * @title SafeERC20\n', ' * @dev Wrappers around ERC20 operations that throw on failure (when the token\n', ' * contract returns false). Tokens that return no value (and instead revert or\n', ' * throw on failure) are also supported, non-reverting calls are assumed to be\n', ' * successful.\n', ' * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n', ' * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n', ' */\n', 'library SafeERC20 {\n', '    using SafeMath for uint256;\n', '\n', '    function safeTransfer(\n', '        IERC20 token,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n', '    }\n', '\n', '    function safeTransferFrom(\n', '        IERC20 token,\n', '        address from,\n', '        address to,\n', '        uint256 value\n', '    ) internal {\n', '        _callOptionalReturn(\n', '            token,\n', '            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n', '        );\n', '    }\n', '\n', '    function safeApprove(\n', '        IERC20 token,\n', '        address spender,\n', '        uint256 value\n', '    ) internal {\n', '        // safeApprove should only be called when setting an initial allowance,\n', '        // or when resetting it to zero. To increase and decrease it, use\n', "        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n", '        // solhint-disable-next-line max-line-length\n', '        require(\n', '            (value == 0) || (token.allowance(address(this), spender) == 0),\n', '            "SafeERC20: approve from non-zero to non-zero allowance"\n', '        );\n', '        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n', '    }\n', '\n', '    /**\n', '     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n', '     * on the return value: the return value is optional (but if data is returned, it must not be false).\n', '     * @param token The token targeted by the call.\n', '     * @param data The call data (encoded using abi.encode or one of its variants).\n', '     */\n', '    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n', "        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n", "        // we're implementing it ourselves.\n", '\n', '        // A Solidity high level call has three parts:\n', '        //  1. The target address is checked to verify it contains contract code\n', '        //  2. The call itself is made, and success asserted\n', '        //  3. The return value is decoded, which in turn checks the size of the returned data.\n', '        // solhint-disable-next-line max-line-length\n', '\n', '        // solhint-disable-next-line avoid-low-level-calls\n', '        (bool success, bytes memory returndata) = address(token).call(data);\n', '        require(success, "SafeERC20: low-level call failed");\n', '\n', '        if (returndata.length > 0) {\n', '            // Return data is optional\n', '            // solhint-disable-next-line max-line-length\n', '            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/ReentrancyGuard.sol\n', '\n', '\n', '/**\n', ' * @title ReentrancyGuard\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Protect functions from Reentrancy Attack\n', ' */\n', 'contract ReentrancyGuard {\n', '    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\n', '    // zero-state of _ENTERED_ is false\n', '    bool private _ENTERED_;\n', '\n', '    modifier preventReentrant() {\n', '        require(!_ENTERED_, "REENTRANT");\n', '        _ENTERED_ = true;\n', '        _;\n', '        _ENTERED_ = false;\n', '    }\n', '}\n', '\n', '// File: contracts/lib/DODOMath.sol\n', '\n', '\n', '/**\n', ' * @title DODOMath\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n', ' */\n', 'library DODOMath {\n', '    using SafeMath for uint256;\n', '\n', '    /*\n', '        Integrate dodo curve from V1 to V2\n', '        require V0>=V1>=V2>0\n', '        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n', '        let V1-V2=delta\n', '        res = i*delta*(1-k+k(V0^2/V1/V2))\n', '\n', '        i is the price of V-res trading pair\n', '\n', '        support k=1 & k=0 case\n', '\n', '        [round down]\n', '    */\n', '    function _GeneralIntegrate(\n', '        uint256 V0,\n', '        uint256 V1,\n', '        uint256 V2,\n', '        uint256 i,\n', '        uint256 k\n', '    ) internal pure returns (uint256) {\n', '        require(V0 > 0, "TARGET_IS_ZERO");\n', '        uint256 fairAmount = i.mul(V1.sub(V2)); // i*delta\n', '        if (k == 0) {\n', '            return fairAmount.div(DecimalMath.ONE);\n', '        }\n', '        uint256 V0V0V1V2 = DecimalMath.divFloor(V0.mul(V0).div(V1), V2);\n', '        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n', '        return DecimalMath.ONE.sub(k).add(penalty).mul(fairAmount).div(DecimalMath.ONE2);\n', '    }\n', '\n', '    /*\n', '        Follow the integration function above\n', '        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n', '        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n', '\n', '        i is the price of delta-V trading pair\n', '        give out target of V\n', '\n', '        support k=1 & k=0 case\n', '\n', '        [round down]\n', '    */\n', '    function _SolveQuadraticFunctionForTarget(\n', '        uint256 V1,\n', '        uint256 delta,\n', '        uint256 i,\n', '        uint256 k\n', '    ) internal pure returns (uint256) {\n', '        if (V1 == 0) {\n', '            return 0;\n', '        }\n', '        if (k == 0) {\n', '            return V1.add(DecimalMath.mulFloor(i, delta));\n', '        }\n', '        // V0 = V1*(1+(sqrt-1)/2k)\n', '        // sqrt = √(1+4kidelta/V1)\n', '        // premium = 1+(sqrt-1)/2k\n', '        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\n', '        uint256 sqrt;\n', '        uint256 ki = (4 * k).mul(i);\n', '        if (ki == 0) {\n', '            sqrt = DecimalMath.ONE;\n', '        } else if ((ki * delta) / ki == delta) {\n', '            sqrt = (ki * delta).div(V1).add(DecimalMath.ONE2).sqrt();\n', '        } else {\n', '            sqrt = ki.div(V1).mul(delta).add(DecimalMath.ONE2).sqrt();\n', '        }\n', '        uint256 premium =\n', '            DecimalMath.divFloor(sqrt.sub(DecimalMath.ONE), k * 2).add(DecimalMath.ONE);\n', '        // V0 is greater than or equal to V1 according to the solution\n', '        return DecimalMath.mulFloor(V1, premium);\n', '    }\n', '\n', '    /*\n', '        Follow the integration expression above, we have:\n', '        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n', '        Given Q1 and deltaB, solve Q2\n', '        This is a quadratic function and the standard version is\n', '        aQ2^2 + bQ2 + c = 0, where\n', '        a=1-k\n', '        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n', '        c=-kQ0^2 \n', '        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n', '        note: another root is negative, abondan\n', '\n', '        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\n', '        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\n', '        return |Q1-Q2|\n', '\n', '        as we only support sell amount as delta, the deltaB is always negative\n', '        the input ideltaB is actually -ideltaB in the equation\n', '\n', '        i is the price of delta-V trading pair\n', '\n', '        support k=1 & k=0 case\n', '\n', '        [round down]\n', '    */\n', '    function _SolveQuadraticFunctionForTrade(\n', '        uint256 V0,\n', '        uint256 V1,\n', '        uint256 delta,\n', '        uint256 i,\n', '        uint256 k\n', '    ) internal pure returns (uint256) {\n', '        require(V0 > 0, "TARGET_IS_ZERO");\n', '        if (delta == 0) {\n', '            return 0;\n', '        }\n', '\n', '        if (k == 0) {\n', '            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\n', '        }\n', '\n', '        if (k == DecimalMath.ONE) {\n', '            // if k==1\n', '            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\n', '            // temp = ideltaBQ1/Q0/Q0\n', '            // Q2 = Q1/(1+temp)\n', '            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\n', '            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\n', '            uint256 temp;\n', '            uint256 idelta = i.mul(delta);\n', '            if (idelta == 0) {\n', '                temp = 0;\n', '            } else if ((idelta * V1) / idelta == V1) {\n', '                temp = (idelta * V1).div(V0.mul(V0));\n', '            } else {\n', '                temp = delta.mul(V1).div(V0).mul(i).div(V0);\n', '            }\n', '            return V1.mul(temp).div(temp.add(DecimalMath.ONE));\n', '        }\n', '\n', '        // calculate -b value and sig\n', '        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\n', '        // part1 = (1-k)Q1 >=0\n', '        // part2 = kQ0^2/Q1-i*deltaB >=0\n', '        // bAbs = abs(part1-part2)\n', '        // if part1>part2 => b is negative => bSig is false\n', '        // if part2>part1 => b is positive => bSig is true\n', '        uint256 part2 = k.mul(V0).div(V1).mul(V0).add(i.mul(delta)); // kQ0^2/Q1-i*deltaB\n', '        uint256 bAbs = DecimalMath.ONE.sub(k).mul(V1); // (1-k)Q1\n', '\n', '        bool bSig;\n', '        if (bAbs >= part2) {\n', '            bAbs = bAbs - part2;\n', '            bSig = false;\n', '        } else {\n', '            bAbs = part2 - bAbs;\n', '            bSig = true;\n', '        }\n', '        bAbs = bAbs.div(DecimalMath.ONE);\n', '\n', '        // calculate sqrt\n', '        uint256 squareRoot =\n', '            DecimalMath.mulFloor(\n', '                DecimalMath.ONE.sub(k).mul(4),\n', '                DecimalMath.mulFloor(k, V0).mul(V0)\n', '            ); // 4(1-k)kQ0^2\n', '        squareRoot = bAbs.mul(bAbs).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n', '\n', '        // final res\n', '        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\n', '        uint256 numerator;\n', '        if (bSig) {\n', '            numerator = squareRoot.sub(bAbs);\n', '        } else {\n', '            numerator = bAbs.add(squareRoot);\n', '        }\n', '\n', '        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\n', '        if (V2 > V1) {\n', '            return 0;\n', '        } else {\n', '            return V1 - V2;\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/lib/PMMPricing.sol\n', '\n', '\n', '/**\n', ' * @title Pricing\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice DODO Pricing model\n', ' */\n', '\n', 'library PMMPricing {\n', '    using SafeMath for uint256;\n', '\n', '    enum RState {ONE, ABOVE_ONE, BELOW_ONE}\n', '\n', '    struct PMMState {\n', '        uint256 i;\n', '        uint256 K;\n', '        uint256 B;\n', '        uint256 Q;\n', '        uint256 B0;\n', '        uint256 Q0;\n', '        RState R;\n', '    }\n', '\n', '    // ============ buy & sell ============\n', '\n', '    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\n', '        internal\n', '        pure\n', '        returns (uint256 receiveQuoteAmount, RState newR)\n', '    {\n', '        if (state.R == RState.ONE) {\n', '            // case 1: R=1\n', '            // R falls below one\n', '            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n', '            newR = RState.BELOW_ONE;\n', '        } else if (state.R == RState.ABOVE_ONE) {\n', '            uint256 backToOnePayBase = state.B0.sub(state.B);\n', '            uint256 backToOneReceiveQuote = state.Q.sub(state.Q0);\n', '            // case 2: R>1\n', '            // complex case, R status depends on trading amount\n', '            if (payBaseAmount < backToOnePayBase) {\n', '                // case 2.1: R status do not change\n', '                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\n', '                newR = RState.ABOVE_ONE;\n', '                if (receiveQuoteAmount > backToOneReceiveQuote) {\n', '                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n', '                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n', '                    receiveQuoteAmount = backToOneReceiveQuote;\n', '                }\n', '            } else if (payBaseAmount == backToOnePayBase) {\n', '                // case 2.2: R status changes to ONE\n', '                receiveQuoteAmount = backToOneReceiveQuote;\n', '                newR = RState.ONE;\n', '            } else {\n', '                // case 2.3: R status changes to BELOW_ONE\n', '                receiveQuoteAmount = backToOneReceiveQuote.add(\n', '                    _ROneSellBaseToken(state, payBaseAmount.sub(backToOnePayBase))\n', '                );\n', '                newR = RState.BELOW_ONE;\n', '            }\n', '        } else {\n', '            // state.R == RState.BELOW_ONE\n', '            // case 3: R<1\n', '            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\n', '            newR = RState.BELOW_ONE;\n', '        }\n', '    }\n', '\n', '    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n', '        internal\n', '        pure\n', '        returns (uint256 receiveBaseAmount, RState newR)\n', '    {\n', '        if (state.R == RState.ONE) {\n', '            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\n', '            newR = RState.ABOVE_ONE;\n', '        } else if (state.R == RState.ABOVE_ONE) {\n', '            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\n', '            newR = RState.ABOVE_ONE;\n', '        } else {\n', '            uint256 backToOnePayQuote = state.Q0.sub(state.Q);\n', '            uint256 backToOneReceiveBase = state.B.sub(state.B0);\n', '            if (payQuoteAmount < backToOnePayQuote) {\n', '                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\n', '                newR = RState.BELOW_ONE;\n', '                if (receiveBaseAmount > backToOneReceiveBase) {\n', '                    receiveBaseAmount = backToOneReceiveBase;\n', '                }\n', '            } else if (payQuoteAmount == backToOnePayQuote) {\n', '                receiveBaseAmount = backToOneReceiveBase;\n', '                newR = RState.ONE;\n', '            } else {\n', '                receiveBaseAmount = backToOneReceiveBase.add(\n', '                    _ROneSellQuoteToken(state, payQuoteAmount.sub(backToOnePayQuote))\n', '                );\n', '                newR = RState.ABOVE_ONE;\n', '            }\n', '        }\n', '    }\n', '\n', '    // ============ R = 1 cases ============\n', '\n', '    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveQuoteToken\n', '        )\n', '    {\n', '        // in theory Q2 <= targetQuoteTokenAmount\n', '        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n', '        return\n', '            DODOMath._SolveQuadraticFunctionForTrade(\n', '                state.Q0,\n', '                state.Q0,\n', '                payBaseAmount,\n', '                state.i,\n', '                state.K\n', '            );\n', '    }\n', '\n', '    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveBaseToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._SolveQuadraticFunctionForTrade(\n', '                state.B0,\n', '                state.B0,\n', '                payQuoteAmount,\n', '                DecimalMath.reciprocalFloor(state.i),\n', '                state.K\n', '            );\n', '    }\n', '\n', '    // ============ R < 1 cases ============\n', '\n', '    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveBaseToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._GeneralIntegrate(\n', '                state.Q0,\n', '                state.Q.add(payQuoteAmount),\n', '                state.Q,\n', '                DecimalMath.reciprocalFloor(state.i),\n', '                state.K\n', '            );\n', '    }\n', '\n', '    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveQuoteToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._SolveQuadraticFunctionForTrade(\n', '                state.Q0,\n', '                state.Q,\n', '                payBaseAmount,\n', '                state.i,\n', '                state.K\n', '            );\n', '    }\n', '\n', '    // ============ R > 1 cases ============\n', '\n', '    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveQuoteToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._GeneralIntegrate(\n', '                state.B0,\n', '                state.B.add(payBaseAmount),\n', '                state.B,\n', '                state.i,\n', '                state.K\n', '            );\n', '    }\n', '\n', '    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n', '        internal\n', '        pure\n', '        returns (\n', '            uint256 // receiveBaseToken\n', '        )\n', '    {\n', '        return\n', '            DODOMath._SolveQuadraticFunctionForTrade(\n', '                state.B0,\n', '                state.B,\n', '                payQuoteAmount,\n', '                DecimalMath.reciprocalFloor(state.i),\n', '                state.K\n', '            );\n', '    }\n', '\n', '    // ============ Helper functions ============\n', '\n', '    function adjustedTarget(PMMState memory state) internal pure {\n', '        if (state.R == RState.BELOW_ONE) {\n', '            state.Q0 = DODOMath._SolveQuadraticFunctionForTarget(\n', '                state.Q,\n', '                state.B.sub(state.B0),\n', '                state.i,\n', '                state.K\n', '            );\n', '        } else if (state.R == RState.ABOVE_ONE) {\n', '            state.B0 = DODOMath._SolveQuadraticFunctionForTarget(\n', '                state.B,\n', '                state.Q.sub(state.Q0),\n', '                DecimalMath.reciprocalFloor(state.i),\n', '                state.K\n', '            );\n', '        }\n', '    }\n', '\n', '    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\n', '        if (state.R == RState.BELOW_ONE) {\n', '            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\n', '            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n', '            return DecimalMath.divFloor(state.i, R);\n', '        } else {\n', '            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\n', '            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n', '            return DecimalMath.mulFloor(state.i, R);\n', '        }\n', '    }\n', '}\n', '\n', '// File: contracts/DODOVendingMachine/impl/DVMStorage.sol\n', '\n', '\n', 'contract DVMStorage is ReentrancyGuard {\n', '    using SafeMath for uint256;\n', '\n', '    bool public _IS_OPEN_TWAP_ = false;\n', '\n', '    bool internal _DVM_INITIALIZED_;\n', '\n', '    // ============ Core Address ============\n', '\n', '    address public _MAINTAINER_;\n', '\n', '    IERC20 public _BASE_TOKEN_;\n', '    IERC20 public _QUOTE_TOKEN_;\n', '\n', '    uint112 public _BASE_RESERVE_;\n', '    uint112 public _QUOTE_RESERVE_;\n', '    uint32 public _BLOCK_TIMESTAMP_LAST_;\n', '\n', '    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n', '\n', '    // ============ Shares (ERC20) ============\n', '\n', '    string public symbol;\n', '    uint8 public decimals;\n', '    string public name;\n', '\n', '    uint256 public totalSupply;\n', '    mapping(address => uint256) internal _SHARES_;\n', '    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\n', '\n', '    // ================= Permit ======================\n', '\n', '    bytes32 public DOMAIN_SEPARATOR;\n', '    // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n', '    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n', '    mapping(address => uint256) public nonces;\n', '\n', '    // ============ Variables for Pricing ============\n', '\n', '    uint256 public _LP_FEE_RATE_;\n', '    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n', '    uint256 public _K_;\n', '    uint256 public _I_;\n', '\n', '\n', '    // ============ Helper Functions ============\n', '\n', '    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n', '        state.i = _I_;\n', '        state.K = _K_;\n', '        state.B = _BASE_RESERVE_;\n', '        state.Q = _QUOTE_RESERVE_;\n', '        state.B0 = 0; // will be calculated in adjustedTarget\n', '        state.Q0 = 0;\n', '        state.R = PMMPricing.RState.ABOVE_ONE;\n', '        PMMPricing.adjustedTarget(state);\n', '    }\n', '\n', '    function getPMMStateForCall() \n', '        external \n', '        view \n', '        returns (\n', '            uint256 i,\n', '            uint256 K,\n', '            uint256 B,\n', '            uint256 Q,\n', '            uint256 B0,\n', '            uint256 Q0,\n', '            uint256 R\n', '        )\n', '    {\n', '        PMMPricing.PMMState memory state = getPMMState();\n', '        i = state.i;\n', '        K = state.K;\n', '        B = state.B;\n', '        Q = state.Q;\n', '        B0 = state.B0;\n', '        Q0 = state.Q0;\n', '        R = uint256(state.R);\n', '    }\n', '\n', '    function getMidPrice() public view returns (uint256 midPrice) {\n', '        return PMMPricing.getMidPrice(getPMMState());\n', '    }\n', '}\n', '\n', '// File: contracts/DODOVendingMachine/impl/DVMVault.sol\n', '\n', '\n', '\n', 'contract DVMVault is DVMStorage {\n', '    using SafeMath for uint256;\n', '    using SafeERC20 for IERC20;\n', '\n', '    // ============ Events ============\n', '\n', '    event Transfer(address indexed from, address indexed to, uint256 amount);\n', '\n', '    event Approval(address indexed owner, address indexed spender, uint256 amount);\n', '\n', '    event Mint(address indexed user, uint256 value);\n', '\n', '    event Burn(address indexed user, uint256 value);\n', '\n', '    // ============ View Functions ============\n', '\n', '    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n', '        baseReserve = _BASE_RESERVE_;\n', '        quoteReserve = _QUOTE_RESERVE_;\n', '    }\n', '\n', '    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\n', '        lpFeeRate = _LP_FEE_RATE_;\n', '        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\n', '    }\n', '\n', '    // ============ Asset In ============\n', '\n', '    function getBaseInput() public view returns (uint256 input) {\n', '        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\n', '    }\n', '\n', '    function getQuoteInput() public view returns (uint256 input) {\n', '        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\n', '    }\n', '\n', '    // ============ TWAP UPDATE ===========\n', '    \n', '    function _twapUpdate() internal {\n', '        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n', '        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n', '        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n', '            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n', '        }\n', '        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n', '    }\n', '\n', '    // ============ Set States ============\n', '\n', '    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n', '        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), "OVERFLOW");\n', '        _BASE_RESERVE_ = uint112(baseReserve);\n', '        _QUOTE_RESERVE_ = uint112(quoteReserve);\n', '\n', '        if(_IS_OPEN_TWAP_) _twapUpdate();\n', '    }\n', '\n', '    function _sync() internal {\n', '        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n', '        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n', '        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), "OVERFLOW");\n', '        if (baseBalance != _BASE_RESERVE_) {\n', '            _BASE_RESERVE_ = uint112(baseBalance);\n', '        }\n', '        if (quoteBalance != _QUOTE_RESERVE_) {\n', '            _QUOTE_RESERVE_ = uint112(quoteBalance);\n', '        }\n', '\n', '        if(_IS_OPEN_TWAP_) _twapUpdate();\n', '    }\n', '\n', '\n', '    function sync() external preventReentrant {\n', '        _sync();\n', '    }\n', '\n', '    // ============ Asset Out ============\n', '\n', '    function _transferBaseOut(address to, uint256 amount) internal {\n', '        if (amount > 0) {\n', '            _BASE_TOKEN_.safeTransfer(to, amount);\n', '        }\n', '    }\n', '\n', '    function _transferQuoteOut(address to, uint256 amount) internal {\n', '        if (amount > 0) {\n', '            _QUOTE_TOKEN_.safeTransfer(to, amount);\n', '        }\n', '    }\n', '\n', '    // ============ Shares (ERC20) ============\n', '\n', '    /**\n', '     * @dev transfer token for a specified address\n', '     * @param to The address to transfer to.\n', '     * @param amount The amount to be transferred.\n', '     */\n', '    function transfer(address to, uint256 amount) public returns (bool) {\n', '        require(amount <= _SHARES_[msg.sender], "BALANCE_NOT_ENOUGH");\n', '\n', '        _SHARES_[msg.sender] = _SHARES_[msg.sender].sub(amount);\n', '        _SHARES_[to] = _SHARES_[to].add(amount);\n', '        emit Transfer(msg.sender, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Gets the balance of the specified address.\n', '     * @param owner The address to query the the balance of.\n', '     * @return balance An uint256 representing the amount owned by the passed address.\n', '     */\n', '    function balanceOf(address owner) external view returns (uint256 balance) {\n', '        return _SHARES_[owner];\n', '    }\n', '\n', '    /**\n', '     * @dev Transfer tokens from one address to another\n', '     * @param from address The address which you want to send tokens from\n', '     * @param to address The address which you want to transfer to\n', '     * @param amount uint256 the amount of tokens to be transferred\n', '     */\n', '    function transferFrom(\n', '        address from,\n', '        address to,\n', '        uint256 amount\n', '    ) public returns (bool) {\n', '        require(amount <= _SHARES_[from], "BALANCE_NOT_ENOUGH");\n', '        require(amount <= _ALLOWED_[from][msg.sender], "ALLOWANCE_NOT_ENOUGH");\n', '\n', '        _SHARES_[from] = _SHARES_[from].sub(amount);\n', '        _SHARES_[to] = _SHARES_[to].add(amount);\n', '        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(amount);\n', '        emit Transfer(from, to, amount);\n', '        return true;\n', '    }\n', '\n', '    /**\n', '     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n', '     * @param spender The address which will spend the funds.\n', '     * @param amount The amount of tokens to be spent.\n', '     */\n', '    function approve(address spender, uint256 amount) public returns (bool) {\n', '        _approve(msg.sender, spender, amount);\n', '        return true;\n', '    }\n', '\n', '    function _approve(\n', '        address owner,\n', '        address spender,\n', '        uint256 amount\n', '    ) private {\n', '        _ALLOWED_[owner][spender] = amount;\n', '        emit Approval(owner, spender, amount);\n', '    }\n', '\n', '    /**\n', '     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\n', '     * @param owner address The address which owns the funds.\n', '     * @param spender address The address which will spend the funds.\n', '     * @return A uint256 specifying the amount of tokens still available for the spender.\n', '     */\n', '    function allowance(address owner, address spender) public view returns (uint256) {\n', '        return _ALLOWED_[owner][spender];\n', '    }\n', '\n', '    function _mint(address user, uint256 value) internal {\n', '        require(value > 0, "MINT_INVALID");\n', '        _SHARES_[user] = _SHARES_[user].add(value);\n', '        totalSupply = totalSupply.add(value);\n', '        emit Mint(user, value);\n', '        emit Transfer(address(0), user, value);\n', '    }\n', '\n', '    function _burn(address user, uint256 value) internal {\n', '        _SHARES_[user] = _SHARES_[user].sub(value);\n', '        totalSupply = totalSupply.sub(value);\n', '        emit Burn(user, value);\n', '        emit Transfer(user, address(0), value);\n', '    }\n', '\n', '    // ============================ Permit ======================================\n', '    \n', '    function permit(\n', '        address owner,\n', '        address spender,\n', '        uint256 value,\n', '        uint256 deadline,\n', '        uint8 v,\n', '        bytes32 r,\n', '        bytes32 s\n', '    ) external {\n', '        require(deadline >= block.timestamp, "DODO_DVM_LP: EXPIRED");\n', '        bytes32 digest = keccak256(\n', '            abi.encodePacked(\n', '                "\\x19\\x01",\n', '                DOMAIN_SEPARATOR,\n', '                keccak256(\n', '                    abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)\n', '                )\n', '            )\n', '        );\n', '        address recoveredAddress = ecrecover(digest, v, r, s);\n', '        require(\n', '            recoveredAddress != address(0) && recoveredAddress == owner,\n', '            "DODO_DVM_LP: INVALID_SIGNATURE"\n', '        );\n', '        _approve(owner, spender, value);\n', '    }\n', '}\n', '\n', '// File: contracts/intf/IDODOCallee.sol\n', '\n', '\n', 'interface IDODOCallee {\n', '    function DVMSellShareCall(\n', '        address sender,\n', '        uint256 burnShareAmount,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function DVMFlashLoanCall(\n', '        address sender,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function DPPFlashLoanCall(\n', '        address sender,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '    function CPCancelCall(\n', '        address sender,\n', '        uint256 amount,\n', '        bytes calldata data\n', '    ) external;\n', '\n', '\tfunction CPClaimBidCall(\n', '        address sender,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        bytes calldata data\n', '    ) external;\n', '}\n', '\n', '// File: contracts/DODOVendingMachine/impl/DVMTrader.sol\n', '\n', '\n', 'contract DVMTrader is DVMVault {\n', '    using SafeMath for uint256;\n', '\n', '    // ============ Events ============\n', '\n', '    event DODOSwap(\n', '        address fromToken,\n', '        address toToken,\n', '        uint256 fromAmount,\n', '        uint256 toAmount,\n', '        address trader,\n', '        address receiver\n', '    );\n', '\n', '    event DODOFlashLoan(\n', '        address borrower,\n', '        address assetTo,\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount\n', '    );\n', '\n', '    // ============ Trade Functions ============\n', '\n', '    function sellBase(address to)\n', '        external\n', '        preventReentrant\n', '        returns (uint256 receiveQuoteAmount)\n', '    {\n', '        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n', '        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n', '        uint256 mtFee;\n', '        (receiveQuoteAmount, mtFee) = querySellBase(tx.origin, baseInput);\n', '\n', '        _transferQuoteOut(to, receiveQuoteAmount);\n', '        _transferQuoteOut(_MAINTAINER_, mtFee);\n', '        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n', '\n', '        emit DODOSwap(\n', '            address(_BASE_TOKEN_),\n', '            address(_QUOTE_TOKEN_),\n', '            baseInput,\n', '            receiveQuoteAmount,\n', '            msg.sender,\n', '            to\n', '        );\n', '    }\n', '\n', '    function sellQuote(address to)\n', '        external\n', '        preventReentrant\n', '        returns (uint256 receiveBaseAmount)\n', '    {\n', '        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n', '        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n', '        uint256 mtFee;\n', '        (receiveBaseAmount, mtFee) = querySellQuote(tx.origin, quoteInput);\n', '\n', '        _transferBaseOut(to, receiveBaseAmount);\n', '        _transferBaseOut(_MAINTAINER_, mtFee);\n', '        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n', '\n', '        emit DODOSwap(\n', '            address(_QUOTE_TOKEN_),\n', '            address(_BASE_TOKEN_),\n', '            quoteInput,\n', '            receiveBaseAmount,\n', '            msg.sender,\n', '            to\n', '        );\n', '    }\n', '\n', '    function flashLoan(\n', '        uint256 baseAmount,\n', '        uint256 quoteAmount,\n', '        address assetTo,\n', '        bytes calldata data\n', '    ) external preventReentrant {\n', '        _transferBaseOut(assetTo, baseAmount);\n', '        _transferQuoteOut(assetTo, quoteAmount);\n', '\n', '        if (data.length > 0)\n', '            IDODOCallee(assetTo).DVMFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n', '\n', '        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n', '        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n', '        \n', '        // no input -> pure loss\n', '        require(\n', '            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\n', '            "FLASH_LOAN_FAILED"\n', '        );\n', '\n', '        // sell quote\n', '        if (baseBalance < _BASE_RESERVE_) {\n', '            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n', '            (uint256 receiveBaseAmount, uint256 mtFee) = querySellQuote(tx.origin, quoteInput);\n', '            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, "FLASH_LOAN_FAILED");\n', '\n', '            _transferBaseOut(_MAINTAINER_, mtFee);\n', '            emit DODOSwap(\n', '                address(_QUOTE_TOKEN_),\n', '                address(_BASE_TOKEN_),\n', '                quoteInput,\n', '                receiveBaseAmount,\n', '                msg.sender,\n', '                assetTo\n', '            );\n', '        }\n', '\n', '        // sell base\n', '        if (quoteBalance < _QUOTE_RESERVE_) {\n', '            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n', '            (uint256 receiveQuoteAmount, uint256 mtFee) = querySellBase(tx.origin, baseInput);\n', '            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, "FLASH_LOAN_FAILED");\n', '\n', '            _transferQuoteOut(_MAINTAINER_, mtFee);\n', '            emit DODOSwap(\n', '                address(_BASE_TOKEN_),\n', '                address(_QUOTE_TOKEN_),\n', '                baseInput,\n', '                receiveQuoteAmount,\n', '                msg.sender,\n', '                assetTo\n', '            );\n', '        }\n', '\n', '        _sync();\n', '        \n', '        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n', '    }\n', '\n', '    // ============ Query Functions ============\n', '\n', '    function querySellBase(address trader, uint256 payBaseAmount)\n', '        public\n', '        view\n', '        returns (uint256 receiveQuoteAmount, uint256 mtFee)\n', '    {\n', '        (receiveQuoteAmount, ) = PMMPricing.sellBaseToken(getPMMState(), payBaseAmount);\n', '\n', '        uint256 lpFeeRate = _LP_FEE_RATE_;\n', '        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n', '        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n', '        receiveQuoteAmount = receiveQuoteAmount\n', '            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\n', '            .sub(mtFee);\n', '    }\n', '\n', '    function querySellQuote(address trader, uint256 payQuoteAmount)\n', '        public\n', '        view\n', '        returns (uint256 receiveBaseAmount, uint256 mtFee)\n', '    {\n', '        (receiveBaseAmount, ) = PMMPricing.sellQuoteToken(getPMMState(), payQuoteAmount);\n', '\n', '        uint256 lpFeeRate = _LP_FEE_RATE_;\n', '        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n', '        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n', '        receiveBaseAmount = receiveBaseAmount\n', '            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\n', '            .sub(mtFee);\n', '    }\n', '}\n', '\n', '// File: contracts/DODOVendingMachine/impl/DVMFunding.sol\n', '\n', '\n', 'contract DVMFunding is DVMVault {\n', '    // ============ Events ============\n', '\n', '    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n', '\n', '    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n', '\n', '    // ============ Buy & Sell Shares ============\n', '\n', '    // buy shares [round down]\n', '    function buyShares(address to)\n', '        external\n', '        preventReentrant\n', '        returns (\n', '            uint256 shares,\n', '            uint256 baseInput,\n', '            uint256 quoteInput\n', '        )\n', '    {\n', '        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n', '        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n', '        uint256 baseReserve = _BASE_RESERVE_;\n', '        uint256 quoteReserve = _QUOTE_RESERVE_;\n', '\n', '        baseInput = baseBalance.sub(baseReserve);\n', '        quoteInput = quoteBalance.sub(quoteReserve);\n', '        require(baseInput > 0, "NO_BASE_INPUT");\n', '\n', '        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\n', '        // But May Happen，reserve >0 But totalSupply = 0\n', '        if (totalSupply == 0) {\n', '            // case 1. initial supply\n', '            require(baseBalance >= 10**3, "INSUFFICIENT_LIQUIDITY_MINED");\n', '            shares = baseBalance; // 以免出现balance很大但shares很小的情况\n', '        } else if (baseReserve > 0 && quoteReserve == 0) {\n', '            // case 2. supply when quote reserve is 0\n', '            shares = baseInput.mul(totalSupply).div(baseReserve);\n', '        } else if (baseReserve > 0 && quoteReserve > 0) {\n', '            // case 3. normal case\n', '            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n', '            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n', '            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n', '            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\n', '        }\n', '        _mint(to, shares);\n', '        _setReserve(baseBalance, quoteBalance);\n', '        emit BuyShares(to, shares, _SHARES_[to]);\n', '    }\n', '\n', '    // sell shares [round down]\n', '    function sellShares(\n', '        uint256 shareAmount,\n', '        address to,\n', '        uint256 baseMinAmount,\n', '        uint256 quoteMinAmount,\n', '        bytes calldata data,\n', '        uint256 deadline\n', '    ) external preventReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n', '        require(deadline >= block.timestamp, "TIME_EXPIRED");\n', '        require(shareAmount <= _SHARES_[msg.sender], "DLP_NOT_ENOUGH");\n', '        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n', '        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n', '        uint256 totalShares = totalSupply;\n', '\n', '        baseAmount = baseBalance.mul(shareAmount).div(totalShares);\n', '        quoteAmount = quoteBalance.mul(shareAmount).div(totalShares);\n', '\n', '        require(\n', '            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\n', '            "WITHDRAW_NOT_ENOUGH"\n', '        );\n', '\n', '        _burn(msg.sender, shareAmount);\n', '        _transferBaseOut(to, baseAmount);\n', '        _transferQuoteOut(to, quoteAmount);\n', '        _sync();\n', '\n', '        if (data.length > 0) {\n', '            IDODOCallee(to).DVMSellShareCall(\n', '                msg.sender,\n', '                shareAmount,\n', '                baseAmount,\n', '                quoteAmount,\n', '                data\n', '            );\n', '        }\n', '\n', '        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\n', '    }\n', '}\n', '\n', '// File: contracts/DODOVendingMachine/impl/DVM.sol\n', '\n', '/**\n', ' * @title DODO VendingMachine\n', ' * @author DODO Breeder\n', ' *\n', ' * @notice DODOVendingMachine initialization\n', ' */\n', 'contract DVM is DVMTrader, DVMFunding {\n', '    function init(\n', '        address maintainer,\n', '        address baseTokenAddress,\n', '        address quoteTokenAddress,\n', '        uint256 lpFeeRate,\n', '        address mtFeeRateModel,\n', '        uint256 i,\n', '        uint256 k,\n', '        bool isOpenTWAP\n', '    ) external {\n', '        require(!_DVM_INITIALIZED_, "DVM_INITIALIZED");\n', '        _DVM_INITIALIZED_ = true;\n', '        \n', '        require(baseTokenAddress != quoteTokenAddress, "BASE_QUOTE_CAN_NOT_BE_SAME");\n', '        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n', '        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n', '\n', '        require(i > 0 && i <= 10**36);\n', '        _I_ = i;\n', '\n', '        require(k <= 10**18);\n', '        _K_ = k;\n', '\n', '        _LP_FEE_RATE_ = lpFeeRate;\n', '        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n', '        _MAINTAINER_ = maintainer;\n', '\n', '        _IS_OPEN_TWAP_ = isOpenTWAP;\n', '        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n', '\n', '        string memory connect = "_";\n', '        string memory suffix = "DLP";\n', '\n', '        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\n', '        symbol = "DLP";\n', '        decimals = _BASE_TOKEN_.decimals();\n', '\n', '        // ============================== Permit ====================================\n', '        uint256 chainId;\n', '        assembly {\n', '            chainId := chainid()\n', '        }\n', '        DOMAIN_SEPARATOR = keccak256(\n', '            abi.encode(\n', "                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n", '                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n', '                keccak256(bytes(name)),\n', '                keccak256(bytes("1")),\n', '                chainId,\n', '                address(this)\n', '            )\n', '        );\n', '        // ==========================================================================\n', '    }\n', '\n', '    function addressToShortString(address _addr) public pure returns (string memory) {\n', '        bytes32 value = bytes32(uint256(_addr));\n', '        bytes memory alphabet = "0123456789abcdef";\n', '\n', '        bytes memory str = new bytes(8);\n', '        for (uint256 i = 0; i < 4; i++) {\n', '            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n', '            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n', '        }\n', '        return string(str);\n', '    }\n', '\n', '    // ============ Version Control ============\n', '    \n', '    function version() external pure returns (string memory) {\n', '        return "DVM 1.0.2";\n', '    }\n', '}']